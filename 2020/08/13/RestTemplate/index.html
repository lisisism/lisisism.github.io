<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    RestTemplate 丨
    

    Lism Blog
  </title>

  
  <link rel="shortcut icon" href="/icon.svg">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="/Lism Blog" type="application/atom+xml">
</head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">/Lism Blog</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <article class="post">
  
  <div class="post-title">RestTemplate</div>
  <div class="post-meta">
    <div class="date">2020 八月 13日</div>
    <div class="tags">
      
      <div class="tag-item">Java</div>
      
      <div class="tag-item">Spring</div>
      
    </div>
  </div>
  

  <main class="post-content"><h1 id="resttemplate"><a class="markdownIt-Anchor" href="#resttemplate"></a> $RestTemplate</h1>
<h1 id="resttemplate-2"><a class="markdownIt-Anchor" href="#resttemplate-2"></a> RestTemplate</h1>
<ul>
<li><a href="">RestTemplate</a>
<ul>
<li><a href="">入门</a>
<ul>
<li><a href="">什么是RestTemplate</a></li>
<li><a href="">非Spring环境下使用</a></li>
<li><a href="">spring环境使用RestTemplate</a></li>
</ul>
</li>
<li><a href="">底层HTTP客户端类库切换</a>
<ul>
<li><a href="">源码解析</a></li>
<li><a href="">底层切换方法</a>
<ul>
<li><a href="">切换为okHTTP</a></li>
<li><a href="">切换为Apache HttpComponects</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="">Get请求使用方法</a>
<ul>
<li><a href="">getForObject</a>
<ul>
<li><a href="">接收String</a></li>
<li><a href="">接收POJO对象</a></li>
<li><a href="">接收数组</a></li>
<li><a href="">使用占位符传参</a></li>
</ul>
</li>
<li><a href="">getForEntity</a></li>
</ul>
</li>
<li><a href="">Post请求</a>
<ul>
<li><a href="">发送JSON</a></li>
<li><a href="">postForObject模拟表单数据提交</a></li>
<li><a href="">url支持占位符语法</a></li>
<li><a href="">postForEntity()方法</a></li>
<li><a href="">postForLocation() 方法</a></li>
</ul>
</li>
<li><a href="">DELETE/PUT等</a>
<ul>
<li><a href="">RESTful风格与HTTP method</a></li>
<li><a href="">使用DELETE方法删除资源</a></li>
<li><a href="">使用PUT方法修改资源</a></li>
<li><a href="">通用方法exchange</a></li>
<li><a href="">使用HEAD方法获取HTTP请求头数据</a></li>
<li><a href="">使用OPTIONS获取HTTP资源支持的method</a></li>
</ul>
</li>
<li><a href="">操作文件</a>
<ul>
<li><a href="">文件上�</a>�</li>
<li><a href="">文件下载</a></li>
<li><a href="">大文件下载</a></li>
<li><a href="">可以暂停/恢复的下载</a></li>
</ul>
</li>
<li><a href="">自定义请求失败异常处理</a>
<ul>
<li><a href="">源码解析-默认实现</a></li>
<li><a href="">自定义异常处理</a></li>
</ul>
</li>
<li><a href="">请求失败自动重试</a>
<ul>
<li><a href="">Spring Retry配置生效</a></li>
<li><a href="">使用案例：</a></li>
</ul>
</li>
<li><a href="">如何通过HTTP BasicAuth认证</a>
<ul>
<li><a href="">HttpBasic认证原理说明</a></li>
<li><a href="">请求头方式携带认证信息</a></li>
<li><a href="">拦截器方式携带认证信息</a></li>
<li><a href="">进一步简化</a></li>
</ul>
</li>
<li><a href="">使用代理作为跳板发送请求</a>
<ul>
<li><a href="">搭建一个代理服务器</a></li>
<li><a href="">代理使用者RestTemplate</a></li>
</ul>
</li>
<li><a href="">使用示例：</a></li>
</ul>
</li>
</ul>
<h2 id="入门"><a class="markdownIt-Anchor" href="#入门"></a> 入门</h2>
<h3 id="什么是resttemplate"><a class="markdownIt-Anchor" href="#什么是resttemplate"></a> 什么是RestTemplate</h3>
<p>RestTemplate是执行HTTP请求的同步阻塞式的客户端，它在HTTP客户端库（例如JDK HttpURLConnection，Apache HttpComponents，okHttp等）基础封装了更加简单易用的模板方法API。也就是说RestTemplate是一个封装，底层的实现还是java应用开发中常用的一些HTTP客户端。但是相对于直接使用底层的HTTP客户端库，它的操作更加方便、快捷，能很大程度上提升我们的开发效率。</p>
<p>RestTemplate作为spring-web项目的一部分，在Spring 3.0版本开始被引入。RestTemplate类通过为HTTP方法（例如GET，POST，PUT，DELETE等）提供重载的方法，提供了一种非常方便的方法访问基于HTTP的Web服务。如果你的Web服务API基于标准的RESTful风格设计，使用效果将更加的完美。</p>
<blockquote>
<p>根据Spring官方文档及源码中的介绍，RestTemplate在将来的版本中它可能会被弃用，因为他们已在Spring 5中引入了<strong>WebClient</strong>作为非阻塞式Reactive HTTP客户端。但是RestTemplate目前在Spring 社区内还是很多项目的“重度依赖”，比如说Spring Cloud。另外，RestTemplate说白了是一个客户端API封装，和服务端相比，非阻塞Reactive 编程的需求并没有那么高。</p>
</blockquote>
<h3 id="非spring环境下使用"><a class="markdownIt-Anchor" href="#非spring环境下使用"></a> 非Spring环境下使用</h3>
<p>RestTemplate是spring的一个rest客户端，在spring-web这个包下。这个包虽然叫做spring-web，但是它的RestTemplate可以脱离Spring 环境使用。</p>
<pre><code class="highlight plaintext">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
  &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<p>使用RestTemplate发送一个GET请求，并把请求得到的JSON数据结果打印出来</p>
<pre><code class="highlight plaintext">@Test
public void simpleTest()
&#123;
    RestTemplate restTemplate = new RestTemplate();
    String url = &quot;http://jsonplaceholder.typicode.com/posts/1&quot;;
    String str = restTemplate.getForObject(url, String.class);
    System.out.println(str);
&#125;</code></pre>
<h3 id="spring环境使用resttemplate"><a class="markdownIt-Anchor" href="#spring环境使用resttemplate"></a> spring环境使用RestTemplate</h3>
<p>将maven坐标从spring-web换成spring-boot-starter-web</p>
<pre><code class="highlight plaintext">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<p>将RestTemplate配置初始化为一个Bean。这种初始化方法，是使用了JDK 自带的HttpURLConnection作为底层HTTP客户端实现。我们还可以把底层实现切换为Apache HttpComponents，okHttp等。</p>
<pre><code class="highlight plaintext">@Configuration
public class ContextConfig &#123;

    //默认使用JDK 自带的HttpURLConnection作为底层实现
    @Bean
    public RestTemplate restTemplate()&#123;
        RestTemplate restTemplate = new RestTemplate();
        return restTemplate;
    &#125;
&#125;</code></pre>
<p>在需要使用RestTemplate 的位置，注入并使用即可</p>
<pre><code class="highlight plaintext">@Resource
//@AutoWired
private RestTemplate restTemplate;</code></pre>
<h2 id="底层http客户端类库切换"><a class="markdownIt-Anchor" href="#底层http客户端类库切换"></a> 底层HTTP客户端类库切换</h2>
<p>RestTemplate只是对其他的HTTP客户端的封装，其本身并没有实现HTTP相关的基础功能。其底层实现是可以配置切换的</p>
<h3 id="源码解析"><a class="markdownIt-Anchor" href="#源码解析"></a> 源码解析</h3>
<p>RestTemplate 支持至少三种HTTP客户端库。</p>
<ul>
<li><strong>SimpleClientHttpRequestFactory</strong>。对应的HTTP库是java JDK自带的HttpURLConnection。</li>
<li><strong>HttpComponentsAsyncClientHttpRequestFactory</strong>。对应的HTTP库是Apache HttpComponents。</li>
<li><strong>OkHttp3ClientHttpRequestFactory</strong>。对应的HTTP库是OkHttpjava</li>
</ul>
<p>JDK自带的HttpURLConnection是默认的底层HTTP实现客户端</p>
<p>SimpleClientHttpRequestFactory，即java JDK自带的HttpURLConnection不支持HTTP协议的Patch方法，如果希望使用Patch方法，需要将底层HTTP客户端实现切换为Apache HttpComponents 或 OkHttp</p>
<p>可以通过<strong>设置setRequestFactory方法，来切换RestTemplate的底层HTTP客户端实现类库</strong>。</p>
<h3 id="底层切换方法"><a class="markdownIt-Anchor" href="#底层切换方法"></a> 底层切换方法</h3>
<p>从开发人员的反馈，和网上的各种HTTP客户端性能以及易用程度评测来看，OkHttp 优于 Apache HttpComponents、Apache HttpComponents优于HttpURLConnection。所以我个人更建议大家将底层HTTP实现切换为okHTTP</p>
<h4 id="切换为okhttp"><a class="markdownIt-Anchor" href="#切换为okhttp"></a> 切换为okHTTP</h4>
<p>首先通过maven坐标将okHTTP的包引入到项目中来</p>
<pre><code class="highlight plaintext">&lt;dependency&gt;
    &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;
    &lt;artifactId&gt;okhttp&lt;/artifactId&gt;
    &lt;version&gt;4.7.2&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<p>如果是spring 环境下通过如下方式使用OkHttp3ClientHttpRequestFactory初始化RestTemplate bean对象</p>
<pre><code class="highlight plaintext">@Configuration
public class ContextConfig &#123;
    @Bean(&quot;OKHttp3&quot;)
    public RestTemplate OKHttp3RestTemplate()&#123;
        RestTemplate restTemplate = new RestTemplate(new OkHttp3ClientHttpRequestFactory());
        return restTemplate;
    &#125;
&#125;</code></pre>
<p>如果是非Spring环境，直接new之后使用就可以了</p>
<pre><code class="highlight plaintext">new RestTemplate(new OkHttp3ClientHttpRequestFactory()</code></pre>
<h4 id="切换为apache-httpcomponects"><a class="markdownIt-Anchor" href="#切换为apache-httpcomponects"></a> 切换为Apache HttpComponects</h4>
<pre><code class="highlight plaintext">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;
    &lt;version&gt;4.5.12&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<p>使用HttpComponentsClientHttpRequestFactory初始化RestTemplate bean对象</p>
<pre><code class="highlight plaintext">@Bean(&quot;httpClient&quot;)
public RestTemplate httpClientRestTemplate()&#123;
    RestTemplate restTemplate = new RestTemplate(new HttpComponentsClientHttpRequestFactory());
    return restTemplate;
&#125;</code></pre>
<h2 id="get请求使用方法"><a class="markdownIt-Anchor" href="#get请求使用方法"></a> Get请求使用方法</h2>
<p>RestTemplate可以发送HTTP GET请求，经常使用到的方法有两个：</p>
<ul>
<li>getForObject()</li>
<li>getForEntity()</li>
</ul>
<p>二者的主要区别在于</p>
<ul>
<li>getForObject()返回值是HTTP协议的<strong>响应体</strong>。</li>
<li>getForEntity()返回的是ResponseEntity，ResponseEntity是对HTTP响应的封装，除了包含<strong>响应体，还包含HTTP状态码、contentType、contentLength、Header</strong>等信息。</li>
</ul>
<h3 id="getforobject"><a class="markdownIt-Anchor" href="#getforobject"></a> getForObject</h3>
<h4 id="接收string"><a class="markdownIt-Anchor" href="#接收string"></a> 接收String</h4>
<p>在Spring Boot环境下写一个单元测试用例，以String类型接收响应结果信息</p>
<pre><code class="highlight plaintext">@SpringBootTest
class ResttemplateWithSpringApplicationTests &#123;

   @Resource
   private RestTemplate restTemplate;

   @Test
   void testSimple()  &#123;
      String url = &quot;http://jsonplaceholder.typicode.com/posts/1&quot;;
      String str = restTemplate.getForObject(url, String.class);
      System.out.println(str);
   &#125;

&#125;</code></pre>
<blockquote>
<p>getForObject第二个参数为返回值的类型，String.class以字符串的形式接受getForObject响应结果</p>
</blockquote>
<h4 id="接收pojo对象"><a class="markdownIt-Anchor" href="#接收pojo对象"></a> 接收POJO对象</h4>
<pre><code class="highlight plaintext">@Test
public void testPoJO() &#123;
   String url = &quot;http://jsonplaceholder.typicode.com/posts/1&quot;;
   PostDTO postDTO = restTemplate.getForObject(url, PostDTO.class);
   System.out.println(postDTO.toString());
&#125;</code></pre>
<p>POJO的定义如下，根据JSON String的数据格式定义。</p>
<pre><code class="highlight plaintext">@Data
public class PostDTO &#123;
    private int userId;
    private int id;
    private String title;
    private String body;
&#125;</code></pre>
<h4 id="接收数组"><a class="markdownIt-Anchor" href="#接收数组"></a> 接收数组</h4>
<pre><code class="highlight plaintext">@Test
public void testArrays() &#123;
   String url = &quot;http://jsonplaceholder.typicode.com/posts&quot;;
   PostDTO[] postDTOs = restTemplate.getForObject(url, PostDTO[].class);
   System.out.println(&quot;数组长度：&quot; + postDTOs.length);
&#125;</code></pre>
<h4 id="使用占位符传参"><a class="markdownIt-Anchor" href="#使用占位符传参"></a> 使用占位符传参</h4>
<p>使用占位符的形式传递参数：</p>
<pre><code class="highlight plaintext">String url = &quot;http://jsonplaceholder.typicode.com/&#123;1&#125;/&#123;2&#125;&quot;;
PostDTO postDTO = restTemplate.getForObject(url, PostDTO.class, &quot;posts&quot;, 1);</code></pre>
<p>另一种使用占位符的形式：</p>
<pre><code class="highlight plaintext">String url = &quot;http://jsonplaceholder.typicode.com/&#123;type&#125;/&#123;id&#125;&quot;;
String type = &quot;posts&quot;;
int id = 1;
PostDTO postDTO = restTemplate.getForObject(url, PostDTO.class, type, id);</code></pre>
<p>我们也可以使用 map 装载参数：</p>
<pre><code class="highlight plaintext">String url = &quot;http://jsonplaceholder.typicode.com/&#123;type&#125;/&#123;id&#125;&quot;;
Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
map.put(&quot;type&quot;, &quot;posts&quot;);
map.put(&quot;id&quot;, 1);
PostDTO  postDTO = restTemplate.getForObject(url, PostDTO.class, map);</code></pre>
<h3 id="getforentity"><a class="markdownIt-Anchor" href="#getforentity"></a> getForEntity</h3>
<p>上面的所有的getForObject请求传参方法，getForEntity都可以使用，<strong>使用方法上也几乎是一致的</strong>，只是在返回结果接收的时候略有差别。</p>
<ul>
<li>使用ResponseEntity<T> responseEntity来接收响应结果。</li>
<li>用responseEntity.getBody()获取响应体。</li>
</ul>
<p>响应体内容同getForObject方法返回结果一致。剩下的这些响应信息就是getForEntity比getForObject多出来的内容。</p>
<pre><code class="highlight plaintext">@Test
public void testEntityPoJo() &#123;
   String url = &quot;http://jsonplaceholder.typicode.com/posts/5&quot;;
   ResponseEntity&lt;PostDTO&gt; responseEntity
               = restTemplate.getForEntity(url, PostDTO.class);
   PostDTO postDTO = responseEntity.getBody(); // 获取响应体
   System.out.println(&quot;HTTP 响应body：&quot; + postDTO.toString());

   //以下是getForEntity比getForObject多出来的内容
   HttpStatus statusCode = responseEntity.getStatusCode(); // 获取响应码
   int statusCodeValue = responseEntity.getStatusCodeValue(); // 获取响应码值
   HttpHeaders headers = responseEntity.getHeaders(); // 获取响应头

   System.out.println(&quot;HTTP 响应状态：&quot; + statusCode);
   System.out.println(&quot;HTTP 响应状态码：&quot; + statusCodeValue);
   System.out.println(&quot;HTTP Headers信息：&quot; + headers);
&#125;</code></pre>
<h2 id="post请求"><a class="markdownIt-Anchor" href="#post请求"></a> Post请求</h2>
<h3 id="发送json"><a class="markdownIt-Anchor" href="#发送json"></a> 发送JSON</h3>
<ul>
<li>jsonplaceholder.typicode.com是一个可以提供在线免费RESTful测试服务的一个网站”</li>
<li>/posts&quot;服务接收PostDTO 参数对象，并将请求结果以JSON字符串的形式进行响应。</li>
<li>响应结果就是请求参数对象对应的JSON字符串。所以postForObject方法第二个参数是请求数据对象，第三个参数是返回值类型</li>
</ul>
<pre><code class="highlight plaintext">@SpringBootTest
class PostTests &#123;

   @Resource
   private RestTemplate restTemplate;

   @Test
   void testSimple()  &#123;
      // 请求地址
      String url = &quot;http://jsonplaceholder.typicode.com/posts&quot;;

      // 要发送的数据对象
      PostDTO postDTO = new PostDTO();
      postDTO.setUserId(110);
      postDTO.setTitle(&quot;zimug 发布文章&quot;);
      postDTO.setBody(&quot;zimug 发布文章 测试内容&quot;);

      // 发送post请求，并输出结果
      PostDTO result = restTemplate.postForObject(url, postDTO, PostDTO.class);
      System.out.println(result);
   &#125;
&#125;</code></pre>
<h3 id="postforobject模拟表单数据提交"><a class="markdownIt-Anchor" href="#postforobject模拟表单数据提交"></a> postForObject模拟表单数据提交</h3>
<p>使用postForObject模拟表单数据提交的例子，即：提交x-www-form-urlencoded格式的数据</p>
<pre><code class="highlight plaintext">@Test
public void testForm() &#123;
   // 请求地址
   String url = &quot;http://jsonplaceholder.typicode.com/posts&quot;;

   // 请求头设置,x-www-form-urlencoded格式的数据
   HttpHeaders headers = new HttpHeaders();
   headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

   //提交参数设置
   MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;&gt;();
   map.add(&quot;title&quot;, &quot;zimug 发布文章第二篇&quot;);
   map.add(&quot;body&quot;, &quot;zimug 发布文章第二篇 测试内容&quot;);

   // 组装请求体
   HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; request =
               new HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt;(map, headers);

   // 发送post请求，并打印结果，以String类型接收响应结果JSON字符串
   String result = restTemplate.postForObject(url, request, String.class);
   System.out.println(result);
&#125;</code></pre>
<h3 id="url支持占位符语法"><a class="markdownIt-Anchor" href="#url支持占位符语法"></a> url支持占位符语法</h3>
<p>具体的用法和使用GET方法请求是一致的</p>
<pre><code class="highlight plaintext">String url = &quot;http://jsonplaceholder.typicode.com/&#123;1&#125;/&#123;2&#125;&quot;;
String url = &quot;http://jsonplaceholder.typicode.com/&#123;type&#125;/&#123;id&#125;&quot;;</code></pre>
<h3 id="postforentity方法"><a class="markdownIt-Anchor" href="#postforentity方法"></a> postForEntity()方法</h3>
<p>上面的所有的postForObject请求传参方法，postForEntity都可以使用，使用方法上也几乎是一致的，只是在返回结果接收的时候略有差别。使用ResponseEntity<T> responseEntity来接收响应结果。用responseEntity.getBody()获取响应体。响应体内容同postForObject方法返回结果一致。剩下的这些响应信息就是postForEntity比postForObject多出来的内容。</p>
<pre><code class="highlight plaintext">
@Test
public void testEntityPoJo() &#123;
   // 请求地址
   String url = &quot;http://jsonplaceholder.typicode.com/posts&quot;;

   // 要发送的数据对象
   PostDTO postDTO = new PostDTO();
   postDTO.setUserId(110);
   postDTO.setTitle(&quot;zimug 发布文章&quot;);
   postDTO.setBody(&quot;zimug 发布文章 测试内容&quot;);

   // 发送post请求，并输出结果
   ResponseEntity&lt;String&gt; responseEntity
               = restTemplate.postForEntity(url, postDTO, String.class);
   String body = responseEntity.getBody(); // 获取响应体
   System.out.println(&quot;HTTP 响应body：&quot; + postDTO.toString());

   //以下是postForEntity比postForObject多出来的内容
   HttpStatus statusCode = responseEntity.getStatusCode(); // 获取响应码
   int statusCodeValue = responseEntity.getStatusCodeValue(); // 获取响应码值
   HttpHeaders headers = responseEntity.getHeaders(); // 获取响应头

   System.out.println(&quot;HTTP 响应状态：&quot; + statusCode);
   System.out.println(&quot;HTTP 响应状态码：&quot; + statusCodeValue);
   System.out.println(&quot;HTTP Headers信息：&quot; + headers);
&#125;</code></pre>
<h3 id="postforlocation-方法"><a class="markdownIt-Anchor" href="#postforlocation-方法"></a> postForLocation() 方法</h3>
<p>postForLocation的传参的类型、个数、用法基本都和postForObject()或postForEntity()一致。和前两者的唯一区别在于返回值是一个URI。该URI返回值体现的是：用于提交完成数据之后的页面跳转，或数据提交完成之后的下一步数据操作URI</p>
<pre><code class="highlight plaintext">@Test
public void testURI() &#123;
   // 请求地址
   String url = &quot;http://jsonplaceholder.typicode.com/posts&quot;;

   PostDTO postDTO = new PostDTO();
   postDTO.setUserId(110);
   postDTO.setTitle(&quot;zimug 发布文章&quot;);
   postDTO.setBody(&quot;zimug 发布文章 测试内容&quot;);

   // 发送post请求，并输出结果
   URI uri = restTemplate.postForLocation(url,postDTO);
   System.out.println(uri);
&#125;</code></pre>
<h2 id="deleteput等"><a class="markdownIt-Anchor" href="#deleteput等"></a> DELETE/PUT等</h2>
<h3 id="restful风格与http-method"><a class="markdownIt-Anchor" href="#restful风格与http-method"></a> RESTful风格与HTTP method</h3>
<table>
<thead>
<tr>
<th>常用HTTP方法</th>
<th>RESTful风格语义（操作）</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>查询、获取数据</td>
</tr>
<tr>
<td>POST</td>
<td>新增、提交数据</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除数据</td>
</tr>
<tr>
<td>PUT</td>
<td>更新、修改数据</td>
</tr>
<tr>
<td>HEAD</td>
<td>获取HTTP请求头数据</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>判断URL提供的当前API支持哪些HTTP method方法</td>
</tr>
</tbody>
</table>
<h3 id="使用delete方法删除资源"><a class="markdownIt-Anchor" href="#使用delete方法删除资源"></a> 使用DELETE方法删除资源</h3>
<p>删除一个已经存在的资源，使用RestTemplate的delete(uri)方法。该方法会向URL代表的资源发送一个HTTP DELETE方法请求</p>
<pre><code class="highlight plaintext">@Test
void testDelete()  &#123;
   String url = &quot;http://jsonplaceholder.typicode.com/posts/1&quot;;
   restTemplate.delete(url);
&#125;</code></pre>
<h3 id="使用put方法修改资源"><a class="markdownIt-Anchor" href="#使用put方法修改资源"></a> 使用PUT方法修改资源</h3>
<p>修改一个已经存在的资源，使用RestTemplate的put()方法。该方法会向URL代表的资源发送一个HTTP PUT方法请求。</p>
<pre><code class="highlight plaintext">@Test
void testPut()  &#123;
   // 请求地址
   String url = &quot;http://jsonplaceholder.typicode.com/posts/1&quot;;

   // 要发送的数据对象（修改数据）
   PostDTO postDTO = new PostDTO();
   postDTO.setUserId(110);
   postDTO.setTitle(&quot;zimug 发布文章&quot;);
   postDTO.setBody(&quot;zimug 发布文章 测试内容&quot;);

   // 发送PUT请求
   restTemplate.put(url, postDTO);
&#125;</code></pre>
<h3 id="通用方法exchange"><a class="markdownIt-Anchor" href="#通用方法exchange"></a> 通用方法exchange</h3>
<p>exchange方法是一个通用的方法，它可以发送GET、POST、DELETE、PUT等等HTTP方法请求。</p>
<p>下面的两种方式发送GET请求效果是一样的</p>
<pre><code class="highlight plaintext">//使用getForEntity发送GET请求
ResponseEntity&lt;PostDTO&gt; responseEntity
            = restTemplate.getForEntity(url, PostDTO.class);
//使用exchange发送GET请求
ResponseEntity&lt;PostDTO&gt; responseEntity = restTemplate.exchange(url, HttpMethod.GET,
            null, PostDTO.class);</code></pre>
<p>下面的两种方式发送POST请求效果是一样的</p>
<pre><code class="highlight plaintext">// 使用postForEntity发送POST请求
ResponseEntity&lt;String&gt; responseEntity
            = restTemplate.postForEntity(url, postDTO, String.class);
// 使用exchange发送POST请求
ResponseEntity&lt;String&gt; responseEntity
            = restTemplate.exchange(url, HttpMethod.POST,null, String.class);</code></pre>
<p>下面的两种方式发送DELETE请求效果是一样的，只是一个有返回值，一个返回值为void</p>
<pre><code class="highlight plaintext">// 使用delete发送DELETE请求，返回值为void
restTemplate.delete(url);
// 使用exchange发送DELETE请求
ResponseEntity&lt;String&gt; result = restTemplate.exchange(url, HttpMethod.DELETE,null,String.class);</code></pre>
<h3 id="使用head方法获取http请求头数据"><a class="markdownIt-Anchor" href="#使用head方法获取http请求头数据"></a> 使用HEAD方法获取HTTP请求头数据</h3>
<p>使用headForHeaders()API 获取某个资源的URI的请求头信息，并且只专注于获取HTTP请求头信息。</p>
<pre><code class="highlight plaintext">@Test
public void testHEAD()  &#123;
   String url = &quot;http://jsonplaceholder.typicode.com/posts/1&quot;;
   HttpHeaders httpHeaders  = restTemplate.headForHeaders(url);

   //断言该资源接口数据为JSON类型
   assertTrue(httpHeaders.getContentType()
               .includes(MediaType.APPLICATION_JSON));
   System.out.println(httpHeaders);
&#125;</code></pre>
<h3 id="使用options获取http资源支持的method"><a class="markdownIt-Anchor" href="#使用options获取http资源支持的method"></a> 使用OPTIONS获取HTTP资源支持的method</h3>
<p>下文代码使用optionsForAllow测试该URL资源是否支持GET、POST、PUT、DELETE，即增删改查。</p>
<pre><code class="highlight plaintext">@Test
public void testOPTIONS()  &#123;
   String url = &quot;http://jsonplaceholder.typicode.com/posts/1&quot;;
   Set&lt;HttpMethod&gt; optionsForAllow  = restTemplate.optionsForAllow(url);

   HttpMethod[] supportedMethods
               = &#123;HttpMethod.GET, HttpMethod.POST, HttpMethod.PUT, HttpMethod.DELETE&#125;;
   //测试该url资源是否支持GET、POST、PUT、DELETE，即增删改查
   assertTrue(optionsForAllow.containsAll(Arrays.asList(supportedMethods)));
&#125;</code></pre>
<h2 id="操作文件"><a class="markdownIt-Anchor" href="#操作文件"></a> 操作文件</h2>
<h3 id="文件上传"><a class="markdownIt-Anchor" href="#文件上传"></a> 文件上传</h3>
<p>方式一：</p>
<pre><code class="highlight plaintext">@SpringBootTestclass 
UpDownLoadTests &#123;

   @Resource
   private RestTemplate restTemplate;

   @Test
   void testUpload()  &#123;
      // 文件上传服务上传接口
      String url = &quot;http://localhost:8888/upload&quot;;
      // 待上传的文件（存在客户端本地磁盘）
      String filePath = &quot;D:\\data\\local\\splash.png&quot;;

      // 封装请求参数
      FileSystemResource resource = new FileSystemResource(new File(filePath));
      MultiValueMap&lt;String, Object&gt; param = new LinkedMultiValueMap&lt;&gt;();
      param.add(&quot;uploadFile&quot;, resource);  //服务端MultipartFile uploadFile
      //param.add(&quot;param1&quot;, &quot;test&quot;);   //服务端如果接受额外参数，可以传递

      // 发送请求并输出结果
      System.out.println(&quot;--- 开始上传文件 ---&quot;);
      String result = restTemplate.postForObject(url, param, String.class);
      System.out.println(&quot;--- 访问地址：&quot; + result);
   &#125;

&#125;</code></pre>
<p>方式二：</p>
<ul>
<li>不占用内存，不占用本地空间方式</li>
</ul>
<pre><code class="highlight plaintext">@SpringBootTestclass 
UpDownLoadTests &#123;

   @Resource
   private RestTemplate restTemplate;

   @Test
   void testUpload(CommonsMultipartFile file)  &#123;
      // 文件上传服务上传接口
      String url = &quot;http://localhost:8888/upload&quot;;
      // 待上传的文件（存在客户端本地磁盘）
      String filePath = &quot;D:\\data\\local\\splash.png&quot;;

      // 封装请求参数
      InputStreamResource inputStreamResource = new InputStreamResource(file.getInputStream()) &#123;
            @Override
            public long contentLength() &#123;
                return file.getSize();
            &#125;
            @Override
            public String getFilename() &#123;
                return file.getOriginalFilename();
            &#125;
      &#125;;
      MultiValueMap&lt;String, Object&gt; param = new LinkedMultiValueMap&lt;&gt;();
      param.add(&quot;uploadFile&quot;, inputStreamResource);  //服务端MultipartFile uploadFile
      //param.add(&quot;param1&quot;, &quot;test&quot;);   //服务端如果接受额外参数，可以传递

      // 发送请求并输出结果
      System.out.println(&quot;--- 开始上传文件 ---&quot;);
      String result = restTemplate.postForObject(url, param, String.class);
      System.out.println(&quot;--- 访问地址：&quot; + result);
   &#125;

&#125;</code></pre>
<p>方式三：</p>
<ul>
<li>转发流方式</li>
</ul>
<pre><code class="highlight plaintext">RequestCallback requestCallback = request -&gt;&#123;
    request.getHeaders().add(&quot;Content-type&quot;, &quot;application/octet-stream&quot;);
    request.getHeaders().add(HttpHeaders.COOKIE,&quot;sdmHttpServer_jh7(_8Hk9GH%jkl&quot;);
    IOUtils.copy(file.getInputStream(), request.getBody());
&#125;;
HttpMessageConverterExtractor&lt;String&gt; responseExtractor = new HttpMessageConverterExtractor&lt;String&gt;(String.class, 
restTemplate.getMessageConverters());
String resEntity = restTemplate.execute(url, HttpMethod.POST, requestCallback, responseExtractor);</code></pre>
<h3 id="文件下载"><a class="markdownIt-Anchor" href="#文件下载"></a> 文件下载</h3>
<p>执行下列代码之后，被下载文件url，会被正确的保存到本地磁盘目录targetPath。</p>
<p>这种下载方法实际上是将下载文件一次性加载到客户端本地内存，然后从内存将文件写入磁盘。这种方式对于小文件的下载还比较适合，如果文件比较大或者文件下载并发量比较大，容易造成内存的大量占用，从而降低应用的运行效率。</p>
<pre><code class="highlight plaintext">
@Testvoid testDownLoad() throws IOException &#123;
   // 待下载的文件地址
   String url = &quot;http://localhost:8888/2020/08/12/028b38f1-3f9b-4088-9bea-1af8c18cd619.png&quot;;
   ResponseEntity&lt;byte[]&gt; rsp = restTemplate.getForEntity(url, byte[].class);
   System.out.println(&quot;文件下载请求结果状态码：&quot; + rsp.getStatusCode());

   // 将下载下来的文件内容保存到本地
   String targetPath = &quot;D:\\data\\local\\splash-down.png&quot;;
   Files.write(Paths.get(targetPath), Objects.requireNonNull(rsp.getBody(),
               &quot;未获取到下载文件&quot;));&#125;</code></pre>
<h3 id="大文件下载"><a class="markdownIt-Anchor" href="#大文件下载"></a> 大文件下载</h3>
<p>这种下载方式的区别在于</p>
<ul>
<li>设置了请求头APPLICATION_OCTET_STREAM，表示以流的形式进行数据加载</li>
<li>RequestCallback 结合File.copy保证了接收到一部分文件内容，就向磁盘写入一部分内容。而不是全部加载到内存，最后再写入磁盘文件。</li>
</ul>
<pre><code class="highlight plaintext">@Testvoid testDownLoadBigFile() throws IOException &#123;
   // 待下载的文件地址
   String url = &quot;http://localhost:8888/2020/08/12/028b38f1-3f9b-4088-9bea-1af8c18cd619.png&quot;;
   // 文件保存的本地路径
   String targetPath = &quot;D:\\data\\local\\splash-down-big.png&quot;;
   //定义请求头的接收类型
   RequestCallback requestCallback = request -&gt; request.getHeaders()
               .setAccept(Arrays.asList(MediaType.APPLICATION_OCTET_STREAM, MediaType.ALL));
   //对响应进行流式处理而不是将其全部加载到内存中
   restTemplate.execute(url, HttpMethod.GET, requestCallback, clientHttpResponse -&gt; &#123;
      Files.copy(clientHttpResponse.getBody(), Paths.get(targetPath));
      return null;
   &#125;);&#125;</code></pre>
<h3 id="可以暂停恢复的下载"><a class="markdownIt-Anchor" href="#可以暂停恢复的下载"></a> 可以暂停/恢复的下载</h3>
<p>检查 URL 下载链接是否支持恢复下载</p>
<pre><code class="highlight plaintext">HttpHeaders headers = restTemplate.headForHeaders(FILE_URL);
Assertions
.assertThat(headers.get(&quot;Accept-Ranges&quot;))
.contains(&quot;bytes&quot;);
Assertions
.assertThat(headers.getContentLength())
.isGreaterThan(0);</code></pre>
<p>实现 RequestCallback 来自定义 Range 请求头来恢复下载</p>
<pre><code class="highlight plaintext">restTemplate.execute(
    FILE_URL,
    HttpMethod.GET,
    clientHttpRequest -&gt; clientHttpRequest.getHeaders().set(
        &quot;Range&quot;,
        String.format(&quot;bytes=%d-%d&quot;, file.length(), contentLength)),
    clientHttpResponse -&gt; &#123;
        StreamUtils.copy(clientHttpResponse.getBody(), new FileOutputStream(file, true));
        return file;
&#125;);
Assertions
.assertThat(file.length())
.isLessThanOrEqualTo(contentLength);
</code></pre>
<h2 id="自定义请求失败异常处理"><a class="markdownIt-Anchor" href="#自定义请求失败异常处理"></a> 自定义请求失败异常处理</h2>
<p>在使用RestTemplate进行远程接口服务调用的时候，当请求的服务出现异常：超时、服务不存在等情况的时候（响应状态非200、而是400、500HTTP状态码），就会抛出如下异常：</p>
<blockquote>
<p>该异常我是模拟出来的，将正确的请求服务地址由“/posts/1”改成“/postss/1”。服务不存在所以抛出404异常。</p>
</blockquote>
<pre><code class="highlight plaintext">@Test
public void testEntity() &#123;
   String url = &quot;http://jsonplaceholder.typicode.com/postss/1&quot;;
   ResponseEntity&lt;String&gt; responseEntity
               = restTemplate.getForEntity(url, String.class);  //这行抛出异常
   //下面两行代码执行不到
   HttpStatus statusCode = responseEntity.getStatusCode(); // 获取响应码
   System.out.println(&quot;HTTP 响应状态：&quot; + statusCode);
&#125;</code></pre>
<blockquote>
<p>异常抛出之后，程序后面的代码就执行不到了，无法进行后面的代码执行。实际的业务开发中，有的时候我们更期望的结果是：不管你服务端是超时了还是服务不存在，我们都应该获得最终的请求结果（HTTP请求结果状态400、500），而不是获得一个抛出的异常</p>
</blockquote>
<h3 id="源码解析-默认实现"><a class="markdownIt-Anchor" href="#源码解析-默认实现"></a> 源码解析-默认实现</h3>
<p>首先我要说一个结论：RestTemplate请求结果异常是可以自定义处理的。在开始进行自定义的异常处理逻辑之前，我们有必要看一下异常处理的默认实现。也就是：为什么会产生上面小节提到的现象？</p>
<ul>
<li>ResponseErrorHandler是RestTemplate请求结果的异常处理器接口
<ul>
<li>接口的第一个方法hasError用于判断HttpResponse是否是异常响应（通过状态码）</li>
<li>接口的第二个方法handleError用于处理异常响应结果（非200状态码段）</li>
</ul>
</li>
<li>DefaultResponseErrorHandler是ResponseErrorHandler的默认实现</li>
</ul>
<p>所以我们就来看看DefaultResponseErrorHandler是如何来处理异常响应的？从HttpResponse解析出Http StatusCode，如果状态码StatusCode为null，就抛出UnknownHttpStatusCodeException异常。</p>
<p>如果StatusCode存在，则解析出StatusCode的series，也就是状态码段（除了200段，其他全是异常状态码）,解析规则是StatusCode/100取整。</p>
<pre><code class="highlight plaintext">public enum Series &#123;

   INFORMATIONAL(1),  // 1xx/100
   SUCCESSFUL(2),  // 2xx/100
   REDIRECTION(3), // 3xx/100
   CLIENT_ERROR(4), // 4xx/100   ,客户端异常
   SERVER_ERROR(5); // 5xx/100 ，服务端异常
&#125;</code></pre>
<p>进一步针对客户端异常和服务端异常进行处理，处理的方法是抛出HttpClientErrorException。也就是第一小节出现的异常的原因</p>
<h3 id="自定义异常处理"><a class="markdownIt-Anchor" href="#自定义异常处理"></a> 自定义异常处理</h3>
<p>所以我们要实现自定义异常，实现ResponseErrorHandler 接口就可以</p>
<pre><code class="highlight plaintext">public class MyRestErrorHandler implements ResponseErrorHandler &#123;

    /**
     * 判断返回结果response是否是异常结果
     * 主要是去检查response 的HTTP Status
     * 仿造DefaultResponseErrorHandler实现即可
     */
    @Override
    public boolean hasError(ClientHttpResponse response) throws IOException &#123;
        int rawStatusCode = response.getRawStatusCode();
        HttpStatus statusCode = HttpStatus.resolve(rawStatusCode);
        return (statusCode != null ? statusCode.isError(): hasError(rawStatusCode));
    &#125;

    protected boolean hasError(int unknownStatusCode) &#123;
        HttpStatus.Series series = HttpStatus.Series.resolve(unknownStatusCode);
        return (series == HttpStatus.Series.CLIENT_ERROR || series == HttpStatus.Series.SERVER_ERROR);
    &#125;

    @Override
    public void handleError(ClientHttpResponse response) throws IOException &#123;
        // 里面可以实现你自己遇到了Error进行合理的处理
        //TODO 将接口请求的异常信息持久化
    &#125;
&#125;</code></pre>
<p>将MyRestErrorHandler 在RestTemplate实例化的时候进行注册</p>
<pre><code class="highlight plaintext">RestTemplate restTemplate = new RestTemplate(getClientHttpRequestFactory());
restTemplate.setErrorHandler(new MyRestErrorHandler());</code></pre>
<blockquote>
<p>这时再去执行第一小节中的示例代码，就不会抛出异常。而是得到一个HTTP Status 404的结果。我们可以根据这个结果，在程序中继续向下执行代码</p>
</blockquote>
<h2 id="请求失败自动重试"><a class="markdownIt-Anchor" href="#请求失败自动重试"></a> 请求失败自动重试</h2>
<p>另外一种通用的异常的处理机制：那就是自动重试。也就是说，在RestTemplate发送请求得到非200状态结果的时候，间隔一定的时间再次发送n次请求。n次请求都失败之后，最后抛出HttpClientErrorException。</p>
<h3 id="spring-retry配置生效"><a class="markdownIt-Anchor" href="#spring-retry配置生效"></a> Spring Retry配置生效</h3>
<p>通过maven坐标引入spring-retry，spring-retry的实现依赖于面向切面编程，所以引入aspectjweaver。以下配置过程都是基于Spring Boot应用。</p>
<pre><code class="highlight plaintext">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;
    &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;
    &lt;version&gt;1.2.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<p>在Spring Boot 应用入口启动类，也就是配置类的上面加上@SpringRetry注解，表示让重试机制生效。</p>
<h3 id="使用案例"><a class="markdownIt-Anchor" href="#使用案例"></a> 使用案例：</h3>
<p>写一个模拟的业务类RetryService ，在其里面注入RestTemplate</p>
<p>将正确的请求服务地址由“/posts/1”改成“/postss/1”。服务不存在所以抛出404异常，是为了触发重试机制。</p>
<pre><code class="highlight plaintext">@Service
public class RetryService &#123;

  @Resource
  private RestTemplate restTemplate;

  private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);

  @Retryable(value = RestClientException.class, maxAttempts = 3,
          backoff = @Backoff(delay = 5000L,multiplier = 2))
  public HttpStatus testEntity() &#123;
    System.out.println(&quot;发起远程API请求:&quot; + DATE_TIME_FORMATTER.format(LocalDateTime.now()));

    String url = &quot;http://jsonplaceholder.typicode.com/postss/1&quot;;
    ResponseEntity&lt;String&gt; responseEntity
            = restTemplate.getForEntity(url, String.class);

    return responseEntity.getStatusCode(); // 获取响应码
  &#125;

&#125;</code></pre>
<p>@Retryable注解的方法在发生异常时会重试，参数说明：</p>
<ul>
<li>value：当指定异常发生时会进行重试 ,HttpClientErrorException是RestClientException的子类。</li>
<li>include：和value一样，默认空。如果 exclude也为空时，所有异常都重试</li>
<li>exclude：指定异常不重试，默认空。如果 include也为空时，所有异常都重试</li>
<li>maxAttemps：最大重试次数，默认3</li>
<li>backoff：重试等待策略，默认空</li>
</ul>
<p>@Backoff注解为重试等待的策略，参数说明：</p>
<ul>
<li>delay：指定重试的延时时间，默认为1000毫秒</li>
<li>multiplier：指定延迟的倍数，比如设置delay=5000，multiplier=2时，第一次重试为5秒后，第二次为10(5x2)秒，第三次为20(10x2)秒。</li>
</ul>
<p>写一个测试的RetryController 对RetryService 的testEntity方法进行调用</p>
<pre><code class="highlight plaintext">@RestController
public class RetryController &#123;

    @Resource
    private RetryService retryService;

    @GetMapping(&quot;/retry&quot;)
    public HttpStatus test() &#123;
        return retryService.testEntity();
    &#125;
&#125;</code></pre>
<p>测试结果：</p>
<h2 id="如何通过http-basicauth认证"><a class="markdownIt-Anchor" href="#如何通过http-basicauth认证"></a> 如何通过HTTP BasicAuth认证</h2>
<p>服务提供方通常会通过一定的授权、鉴权认证逻辑来保护API接口。其中比较简单、容易实现的方式就是使用HTTP 的Basic Auth来实现接口访问用户的认证。</p>
<h3 id="httpbasic认证原理说明"><a class="markdownIt-Anchor" href="#httpbasic认证原理说明"></a> HttpBasic认证原理说明</h3>
<ul>
<li>首先，HttpBasic模式要求传输的用户名密码使用Base64模式进行加密。如果用户名是 “admin”  ，密码是“ admin”，则将字符串&quot;admin:admin&quot;使用Base64编码算法加密。加密结果可能是：YWtaW46YWRtaW4=。</li>
<li>然后，在Http请求中使用authorization作为一个HTTP请求头Header name，“Basic YWtaW46YWRtaW4=“作为Header的值，发送给服务端。（注意这里使用Basic+空格+加密串）</li>
<li>服务器在收到这样的请求时，到达BasicAuthenticationFilter过滤器，将提取“authorization”的Header值，并使用用于验证用户身份的相同算法Base64进行解码。</li>
<li>解码结果与登录验证的用户名密码匹配，匹配成功则可以继续过滤器后续的访问。</li>
</ul>
<h3 id="请求头方式携带认证信息"><a class="markdownIt-Anchor" href="#请求头方式携带认证信息"></a> 请求头方式携带认证信息</h3>
<p>在HTTP请求头中携带Basic Auth认证的用户名和密码</p>
<pre><code class="highlight plaintext">@SpringBootTest
class BasicAuthTests &#123;

   @Resource
   private RestTemplate restTemplate;

   @Test
   void testBasicAuth() &#123;
      //该url上携带用户名密码是httpbin网站测试接口的要求，
     //真实的业务是不需要在url上体现basic auth用户名密码的
      String url = &quot;http://www.httpbin.org/basic-auth/admin/adminpwd&quot;;

      //在请求头信息中携带Basic认证信息(这里才是实际Basic认证传递用户名密码的方式)
      HttpHeaders headers = new HttpHeaders();
      headers.set(&quot;authorization&quot;,
                  &quot;Basic &quot; +
                  Base64.getEncoder()  
                       .encodeToString(&quot;admin:adminpwd&quot;.getBytes()));

     //发送请求
      HttpEntity&lt;String&gt; ans = restTemplate.exchange(url,HttpMethod.GET,   //GET请求
                        new HttpEntity&lt;&gt;(null, headers),   //加入headers
                        String.class);  //body响应数据接收类型
      System.out.println(ans);
   &#125;
&#125;</code></pre>
<h3 id="拦截器方式携带认证信息"><a class="markdownIt-Anchor" href="#拦截器方式携带认证信息"></a> 拦截器方式携带认证信息</h3>
<p>上面的代码虽然实现了功能，但是不够好。因为每一次发送HTTP请求，我们都需要去组装HttpHeaders 信息，这样不好，造成大量的代码冗余。那么有没有一种方式可以实现可以一次性的为所有RestTemplate请求API添加Http Basic认证信息呢？答案就是：在RestTemplate Bean初始化的时候加入拦截器，以拦截器的方式统一添加Basic认证信息。</p>
<pre><code class="highlight plaintext">@Configuration
public class ContextConfig &#123;

    @Bean(&quot;OKHttp3&quot;)
    public RestTemplate OKHttp3RestTemplate()&#123;
        RestTemplate restTemplate = new RestTemplate(getClientHttpRequestFactory());
        //添加拦截器
        restTemplate.getInterceptors().add(getCustomInterceptor());
        return restTemplate;
    &#125;
   //实现一个拦截器：使用拦截器为每一个HTTP请求添加Basic Auth认证用户名密码信息
    private ClientHttpRequestInterceptor getCustomInterceptor()&#123;
        ClientHttpRequestInterceptor interceptor = (httpRequest, bytes, execution) -&gt; &#123;
            httpRequest.getHeaders().set(&quot;authorization&quot;,
                    &quot;Basic &quot; +
                            Base64.getEncoder()
                                    .encodeToString(&quot;admin:adminpwd&quot;.getBytes()));
            return execution.execute(httpRequest, bytes);
        &#125;;
        return interceptor;
    &#125;

    //这段代码是《第3节-底层HTTP客户端实现切换》的内容
    private ClientHttpRequestFactory getClientHttpRequestFactory() &#123;
        int timeout = 100000;
        OkHttp3ClientHttpRequestFactory clientHttpRequestFactory
                = new OkHttp3ClientHttpRequestFactory();
        clientHttpRequestFactory.setConnectTimeout(timeout);
        return clientHttpRequestFactory;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>在RestTemplate Bean初始化的时候加入拦截器之后，上面的代码就可以省略HttpHeaders Basic Auth请求头携带信息的组装过程。发送请求，结果和第三小节中的效果是一样的</p>
</blockquote>
<h3 id="进一步简化"><a class="markdownIt-Anchor" href="#进一步简化"></a> 进一步简化</h3>
<p>上面的方式使用了拦截器，但仍然是我们自己来封装HTTP headers请求头信息。进一步的简化方法就是，Spring RestTemplate 已经为我们提供了封装好的Basic Auth拦截器，我们直接使用就可以了，不需要我们自己去实现拦截器。</p>
<pre><code class="highlight plaintext">public RestTemplate OKHttp3RestTemplate()&#123;
    RestTemplate restTemplate = new RestTemplate(getClientHttpRequestFactory());
    restTemplate.getInterceptors().add(new BasicAuthenticationInterceptor(&quot;admin&quot;,&quot;adminpwd&quot;));
    return restTemplate;
&#125;</code></pre>
<p>下面的方法是在RestTemplate Bean实例化的时候使用RestTemplateBuilder，自带basicAuthentication。所以到这里拦截器也不需要了（实际底层代码实现仍然是拦截器，只是api层面不需要指定拦截器了）</p>
<pre><code class="highlight plaintext">public RestTemplate OKHttp3RestTemplate()&#123;
        RestTemplate restTemplate = new RestTemplateBuilder().basicAuthentication(&quot;admin&quot;,&quot;adminpwd&quot;).build();
        restTemplate.setRequestFactory(getClientHttpRequestFactory());
        return restTemplate;
&#125;</code></pre>
<h2 id="使用代理作为跳板发送请求"><a class="markdownIt-Anchor" href="#使用代理作为跳板发送请求"></a> 使用代理作为跳板发送请求</h2>
<p>，如何在使用RestTemplate发送请求的时候使用代理Proxy。至于为什么要使用代理，给大家举一个简单的例子：一些做过爬虫的同学可能都知道，当爬虫高频的多次访问一个网站数据，可能导致请求客户端Ip被封锁的可能。很多情况下，做爬虫的企业就维护一个代理IP池，每发送一次请求，就更换一次IP。</p>
<p>代理Proxy作为跳板成为服务的直接访问者，代理使用者（真正的客户端）是间接访问服务。这样在服务端看来，每次请求是代理发出的，从代理IP池中一直更换代理发送请求，这样能够降低IP封锁的可能。</p>
<h3 id="搭建一个代理服务器"><a class="markdownIt-Anchor" href="#搭建一个代理服务器"></a> 搭建一个代理服务器</h3>
<p>代理服务器还是由我自己来搭建用来测试，在我的一个CentOS服务器上安装tinyproxy，tinyproxy可以提供代理服务。</p>
<pre><code class="highlight plaintext"># 安装tinyproxy 命令
sudo yum install tinyproxy -y</code></pre>
<p>编辑tinyproxy的配置文件<code>vim /etc/tinyproxy/tinyproxy.conf</code>。为该代理配置允许访问的使用者客户端ip，也就是我家的ip，所以这个代理服务只能我用，其他人用不了。</p>
<pre><code class="highlight plaintext"># 代理服务端口
Port 1080
# 允许哪个客户端使用该代理程序？
Allow xxx.xxx.xxx.xxx</code></pre>
<p>启动tinyproxy提供代理服务，最好检查一下防火墙是否开放了1080端口。</p>
<pre><code class="highlight plaintext">systemctl start tinyproxy.service</code></pre>
<h3 id="代理使用者resttemplate"><a class="markdownIt-Anchor" href="#代理使用者resttemplate"></a> 代理使用者RestTemplate</h3>
<p>我的上面设置的代理服务器的ip是88.99.10.251，tinyproxy代理服务端口1080。下文代码通过SimpleClientHttpRequestFactory设置访问代理</p>
<pre><code class="highlight plaintext">@SpringBootTest
class ProxyTests &#123;

   @Resource
   private RestTemplate restTemplate;

   @Test
   void testProxyIp() &#123;

      String url = &quot;http://www.httpbin.org/ip&quot;;

      SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();
      requestFactory.setProxy(
         new Proxy(
            Proxy.Type.HTTP,
            new InetSocketAddress(&quot;88.99.10.251&quot;, 1080)  //设置代理服务
         )
      );
      restTemplate.setRequestFactory(requestFactory);
      //发送请求
      String result = restTemplate.getForObject(url, String.class);
      System.out.println(result);  //打印响应结果
   &#125;

&#125;
</code></pre>
<h2 id="使用示例"><a class="markdownIt-Anchor" href="#使用示例"></a> 使用示例：</h2>
<pre><code class="highlight plaintext">/**
 * @author libo
 * @date Created in 2020/8/14 14:00
 * 调用sdm http服务
 */
public class RemoteSdmHttpServer &#123;
    private static RestTemplate restTemplate = new RestTemplate();

    /**
     * 调用sdm http服务删除指定文件
     */
    public static boolean deleteFile(String sdmIp, String filePath)&#123;
        HttpHeaders headers = new HttpHeaders();
        headers.add(HttpHeaders.COOKIE,&quot;sdmHttpServer_jh7(_8Hk9GH%jkl&quot;);
        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

        MultiValueMap&lt;String, String&gt; bodyHashMap= new LinkedMultiValueMap&lt;&gt;();
        bodyHashMap.add(&quot;filePath&quot;,filePath);
        HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; multiValueMapHttpEntity = new HttpEntity&lt;&gt;(bodyHashMap, headers);
        try&#123;
            ResponseEntity&lt;String&gt; resEntity = restTemplate.exchange(&quot;http://&quot;+ sdmIp+&quot;:44016/delete?&quot;, HttpMethod.POST, multiValueMapHttpEntity, String.class);
            if(resEntity.getStatusCode().toString().startsWith(&quot;4&quot;))&#123;
                return false;
            &#125;
        &#125;catch (Exception e)&#123;
            return false;
        &#125;
        return true;
    &#125;
    /**
     * 调用sdm http服务上传文件
     */
    public static CommonSuccess uploadFile(String sdmIp, String typeName, String taskName, String userName, CommonsMultipartFile files)&#123;
        CommonsMultipartFile[] commonsMultipartFiles = new CommonsMultipartFile[]&#123;files&#125;;
        return uploadFile(sdmIp,typeName,taskName,userName,commonsMultipartFiles);
    &#125;

    /**
     * 调用sdm http服务上传文件
     */
    public static CommonSuccess uploadFile(String sdmIp, String typeName, String taskName, String userName, CommonsMultipartFile[] files)&#123;
        HttpHeaders headers = new HttpHeaders();
        MediaType type = MediaType.parseMediaType(&quot;multipart/form-data&quot;);
        headers.setContentType(type);
        headers.add(HttpHeaders.COOKIE,&quot;sdmHttpServer_jh7(_8Hk9GH%jkl&quot;);
        //设置请求体，注意是LinkedMultiValueMap
        MultiValueMap&lt;String, Object&gt; form = new LinkedMultiValueMap&lt;&gt;();
        for(CommonsMultipartFile file:files)&#123;
            String fileName = file.getOriginalFilename();
            if(fileName.matches(&quot;.*\\.conf&quot;))&#123;
                fileName = &quot;krb5.conf&quot;;
            &#125;else if(fileName.matches(&quot;.*\\.keytab&quot;))&#123;
                if(typeName.equals(&quot;hadoop&quot;))&#123;
                    fileName = &quot;hadoop.keytab&quot;;
                &#125;else if(typeName.equals(&quot;hive&quot;))&#123;
                    fileName = &quot;hive.keytab&quot;;
                &#125;
            &#125;
            String key = &quot;file_&quot;+fileName;
            ByteArrayResource fileSystemResource = new ByteArrayResource(file.getBytes());
            form.add(key, fileSystemResource);
        &#125;
        HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; requestEntity = new HttpEntity&lt;&gt;(form, headers);
        String url = &quot;http://&quot;+ sdmIp+&quot;:44016/upload?typeName=&quot;+typeName+&quot;&amp;taskName=&quot;+taskName+&quot;&amp;userName=&quot;+userName;
        ResponseEntity&lt;String&gt; resEntity = null;
        try&#123;
            resEntity = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);
        &#125;catch (HttpClientErrorException e)&#123;
            if(e.getStatusCode().toString().startsWith(&quot;4&quot;))&#123;
                String responseBodyAsString = e.getResponseBodyAsString();
                if(responseBodyAsString.isEmpty())&#123;
                    throw new SdmOperationException(CommonConstants.ONE, &quot;上传文件失败&quot;);
                &#125;
                String substringBetween = StringUtils.substringBetween(responseBodyAsString, &quot;&#123;&quot;, &quot;&#125;&quot;);
                String errorMessage = JSONObject.parseObject(&quot;&#123;&quot;+substringBetween+&quot;&#125;&quot;).getString(&quot;message&quot;);
                throw new SdmOperationException(CommonConstants.ONE, errorMessage);
            &#125;
        &#125;catch (Exception e)&#123;
            throw new SdmOperationException(CommonConstants.ONE, &quot;上传文件失败&quot;);
        &#125;
        JSONObject jsonObject = JSONObject.parseObject(resEntity.getBody());
        String code = jsonObject.getString(&quot;code&quot;);
        String message = jsonObject.getString(&quot;message&quot;);
        return new CommonSuccess(Integer.parseInt(code),message);
    &#125;

    /**
     * 调用sdm http服务下载文件
     */
    public static byte[] downloadFile(String sdmIp, String taskName, String userName)&#123;
        HttpHeaders headers = new HttpHeaders();
        headers.add(HttpHeaders.COOKIE,&quot;sdmHttpServer_jh7(_8Hk9GH%jkl&quot;);
        HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; requestEntity = new HttpEntity&lt;&gt;(null, headers);
        String url = &quot;http://&quot;+ sdmIp+&quot;:44016/download?taskName=&quot;+taskName+&quot;&amp;userName=&quot;+userName;
        //先缓存到本地
//        RequestCallback requestCallback = request -&gt; &#123;
//            request.getHeaders().setAccept(Arrays.asList(MediaType.APPLICATION_OCTET_STREAM, MediaType.ALL));
//            request.getHeaders().add(HttpHeaders.COOKIE,&quot;sdmHttpServer_jh7(_8Hk9GH%jkl&quot;);
//        &#125;;
//        File file = restTemplate.execute(url, HttpMethod.GET, requestCallback, clientHttpResponse -&gt; &#123;
//            File ret = File.createTempFile(&quot;download&quot;, &quot;tmp&quot;);
//            StreamUtils.copy(clientHttpResponse.getBody(), new FileOutputStream(ret));
//            return ret;
//        &#125;);
        ResponseEntity&lt;byte[]&gt; responseEntity = null;
        try&#123;
            responseEntity = restTemplate.exchange(url, HttpMethod.GET, requestEntity, byte[].class);
        &#125;catch(HttpClientErrorException e)&#123;
            if(e.getStatusCode().toString().startsWith(&quot;4&quot;))&#123;
                String responseBodyAsString = e.getResponseBodyAsString();
                if(responseBodyAsString.isEmpty())&#123;
                    throw new SdmOperationException(CommonConstants.ONE, &quot;下载文件失败&quot;);
                &#125;
                String substringBetween = StringUtils.substringBetween(responseBodyAsString, &quot;&#123;&quot;, &quot;&#125;&quot;);
                String errorMessage = JSONObject.parseObject(&quot;&#123;&quot;+substringBetween+&quot;&#125;&quot;).getString(&quot;message&quot;);
                throw new SdmOperationException(CommonConstants.ONE, errorMessage);
            &#125;
        &#125;catch (Exception e)&#123;
            throw new SdmOperationException(CommonConstants.ONE, &quot;下载失败&quot;);
        &#125;
        return responseEntity.getBody();
    &#125;
&#125;
</code></pre>
</main>

</article>


<script src="/js/highlight.js"></script>

  </main>
  <footer class="footer">
  
  <span>Copyright © 2026 Lism Blog | lisisism@qq.com</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>