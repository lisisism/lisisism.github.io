<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    设计模式 丨
    

    Lism Blog
  </title>

  
  <link rel="shortcut icon" href="/icon.svg">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="/Lism Blog" type="application/atom+xml">
</head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">/Lism Blog</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <article class="post">
  
  <div class="post-title">设计模式</div>
  <div class="post-meta">
    <div class="date">2020 十月 24日</div>
    <div class="tags">
      
      <div class="tag-item">设计模式</div>
      
    </div>
  </div>
  

  <main class="post-content"><h1 id="设计模式"><a class="markdownIt-Anchor" href="#设计模式"></a> $设计模式</h1>
<ul>
<li><a href="">设计模式</a>
<ul>
<li><a href="">创建型模式</a>
<ul>
<li><a href="">工厂方法</a></li>
<li><a href="">抽象工厂</a></li>
<li><a href="">生成器</a></li>
<li><a href="">原型</a></li>
<li><a href="">单例</a></li>
</ul>
</li>
<li><a href="">结构性模式</a>
<ul>
<li><a href="">适配器</a></li>
<li><a href="">桥接</a></li>
<li><a href="">组合</a></li>
<li><a href="">装饰器</a></li>
<li><a href="">外观</a></li>
<li><a href="">享元</a></li>
<li><a href="">代理</a></li>
</ul>
</li>
<li><a href="">行为型模式</a>
<ul>
<li><a href="">责任链</a></li>
<li><a href="">命令</a></li>
<li><a href="">解释器</a></li>
<li><a href="">迭代器</a></li>
<li><a href="">中介</a></li>
<li><a href="">备忘录</a></li>
<li><a href="">观察�</a>�</li>
<li><a href="">状态</a></li>
<li><a href="">策略</a></li>
<li><a href="">模板方法</a></li>
<li><a href="">访问�</a>�</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="设计模式-2"><a class="markdownIt-Anchor" href="#设计模式-2"></a> 设计模式</h1>
<h2 id="创建型模式"><a class="markdownIt-Anchor" href="#创建型模式"></a> 创建型模式</h2>
<p>创建型模式关注点是如何创建对象，其核心思想是要把对象的创建和使用相分离，这样使得两者能相对独立地变换。</p>
<p>创建型模式包括：</p>
<ul>
<li>工厂方法：Factory Method</li>
<li>抽象工厂：Abstract Factory</li>
<li>建造者：Builder</li>
<li>原型：Prototype</li>
<li>单例：Singleton</li>
</ul>
<h3 id="工厂方法"><a class="markdownIt-Anchor" href="#工厂方法"></a> 工厂方法</h3>
<blockquote>
<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。</p>
</blockquote>
<p>工厂方法即Factory Method，是一种对象创建型模式。</p>
<p>工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品：</p>
<p><img src="image/.png" alt=".png" /></p>
<p>我们以具体的例子来说：假设我们希望实现一个解析字符串到Number的Factory，可以定义如下：</p>
<pre><code class="highlight plaintext">public interface NumberFactory &#123;
    Number parse(String s);
&#125;</code></pre>
<p>有了工厂接口，再编写一个工厂的实现类：</p>
<pre><code class="highlight plaintext">public class NumberFactoryImpl implements NumberFactory &#123;
    public Number parse(String s) &#123;
        return new BigDecimal(s);
    &#125;
&#125;</code></pre>
<p>而产品接口是Number，NumberFactoryImpl返回的实际产品是BigDecimal。</p>
<p>那么客户端如何创建NumberFactoryImpl呢？通常我们会在接口Factory中定义一个静态方法getFactory()来返回真正的子类：</p>
<pre><code class="highlight plaintext">public interface NumberFactory &#123;
    // 创建方法:
    Number parse(String s);

    // 获取工厂实例:
    static NumberFactory getFactory() &#123;
        return impl;
    &#125;

    static NumberFactory impl = new NumberFactoryImpl();
&#125;</code></pre>
<p>在客户端中，我们只需要和工厂接口NumberFactory以及抽象产品Number打交道：</p>
<pre><code class="highlight plaintext">NumberFactory factory = NumberFactory.getFactory();
Number result = factory.parse(&quot;123.456&quot;);</code></pre>
<p>调用方可以完全忽略真正的工厂NumberFactoryImpl和实际的产品BigDecimal，<strong>这样做的好处是允许创建产品的代码独立地变换，而不会影响到调用方</strong>。</p>
<p>有的童鞋会问：一个简单的parse()需要写这么复杂的工厂吗？实际上大多数情况下我们并不需要抽象工厂，而是通过静态方法直接返回产品，即：</p>
<pre><code class="highlight plaintext">public class NumberFactory &#123;
    public static Number parse(String s) &#123;
        return new BigDecimal(s);
    &#125;
&#125;</code></pre>
<p>这种简化的使用静态方法创建产品的方式称为静态工厂方法（Static Factory Method）。静态工厂方法广泛地应用在Java标准库中。例如：</p>
<pre><code class="highlight plaintext">Integer n = Integer.valueOf(100);</code></pre>
<p>Integer既是产品又是静态工厂。它提供了静态方法valueOf()来创建Integer。那么这种方式和直接写new Integer(100)有何区别呢？我们观察valueOf()方法：</p>
<pre><code class="highlight plaintext">public final class Integer &#123;
    public static Integer valueOf(int i) &#123;
        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    &#125;
    ...
&#125;</code></pre>
<p>它的好处在于，valueOf()内部可能会使用new创建一个新的Integer实例，但也可能直接返回一个缓存的Integer实例。对于<strong>调用方来说，没必要知道Integer创建的细节</strong>。</p>
<blockquote>
<p>工厂方法可以隐藏创建产品的细节，且不一定每次都会真正创建产品，完全可以返回缓存的产品，从而提升速度并减少内存消耗。</p>
</blockquote>
<p>如果调用方直接使用Integer n = new Integer(100)，那么就失去了使用缓存优化的可能性。</p>
<p>我们经常使用的另一个静态工厂方法是List.of()：</p>
<pre><code class="highlight plaintext">List&lt;String&gt; list = List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);</code></pre>
<p>这个静态工厂方法接收可变参数，然后返回List接口。需要注意的是，调用方获取的产品总是List接口，而且并不关心它的实际类型。即使调用方知道List产品的实际类型是java.util.ImmutableCollections$ListN，也不要去强制转型为子类，因为静态工厂方法List.of()保证返回List，但也完全可以修改为返回java.util.ArrayList。这就是里氏替换原则：返回实现接口的任意子类都可以满足该方法的要求，且不影响调用方。</p>
<blockquote>
<p>总是引用接口而非实现类，能允许变换子类而不影响调用方，即尽可能面向抽象编程。</p>
</blockquote>
<p>和List.of()类似，我们使用MessageDigest时，为了创建某个摘要算法，总是使用静态工厂方法getInstance(String)：</p>
<pre><code class="highlight plaintext">MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);
MessageDigest sha1 = MessageDigest.getInstance(&quot;SHA-1&quot;);</code></pre>
<p>调用方通过产品名称获得产品实例，不但调用简单，而且获得的引用仍然是MessageDigest这个抽象类。</p>
<h3 id="抽象工厂"><a class="markdownIt-Anchor" href="#抽象工厂"></a> 抽象工厂</h3>
<blockquote>
<p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
</blockquote>
<p>抽象工厂模式（Abstract Factory）是一个比较复杂的创建型模式。</p>
<p>抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应到多个实际工厂，每个实际工厂负责创建多个实际产品：</p>
<p><img src="image/-1.png" alt="-1.png" /></p>
<p>这种模式有点类似于多个供应商负责提供一系列类型的产品。我们举个例子：</p>
<p>假设我们希望为用户提供一个Markdown文本转换为HTML和Word的服务，它的接口定义如下：</p>
<pre><code class="highlight plaintext">public interface AbstractFactory &#123;
    // 创建Html文档:
    HtmlDocument createHtml(String md);
    // 创建Word文档:
    WordDocument createWord(String md);
&#125;</code></pre>
<p>注意到上面的抽象工厂仅仅是一个接口，没有任何代码。同样的，因为HtmlDocument和WordDocument都比较复杂，现在我们并不知道如何实现它们，所以只有接口：</p>
<pre><code class="highlight plaintext">
// Html文档接口:public interface HtmlDocument &#123;
    String toHtml();
    void save(Path path) throws IOException;
&#125;

// Word文档接口:public interface WordDocument &#123;
    void save(Path path) throws IOException;
&#125;</code></pre>
<p>这样，我们就定义好了抽象工厂（AbstractFactory）以及两个抽象产品（HtmlDocument和WordDocument）。因为实现它们比较困难，我们决定让供应商来完成。</p>
<p>现在市场上有两家供应商：FastDoc Soft的产品便宜，并且转换速度快，而GoodDoc Soft的产品贵，但转换效果好。我们决定同时使用这两家供应商的产品，以便给免费用户和付费用户提供不同的服务。</p>
<p>我们先看看FastDoc Soft的产品是如何实现的。首先，FastDoc Soft必须要有实际的产品，即FastHtmlDocument和FastWordDocument：</p>
<pre><code class="highlight plaintext">public class FastHtmlDocument implements HtmlDocument &#123;
    public String toHtml() &#123;
        ...
    &#125;
    public void save(Path path) throws IOException &#123;
        ...
    &#125;
&#125;

public class FastWordDocument implements WordDocument &#123;
    public void save(Path path) throws IOException &#123;
        ...
    &#125;
&#125;</code></pre>
<p>然后，FastDoc Soft必须提供一个实际的工厂来生产这两种产品，即FastFactory：</p>
<pre><code class="highlight plaintext">public class FastFactory implements AbstractFactory &#123;
    public HtmlDocument createHtml(String md) &#123;
        return new FastHtmlDocument(md);
    &#125;
    public WordDocument createWord(String md) &#123;
        return new FastWordDocument(md);
    &#125;
&#125;</code></pre>
<p>这样，我们就可以使用FastDoc Soft的服务了。客户端编写代码如下：</p>
<pre><code class="highlight plaintext">// 创建AbstractFactory，实际类型是FastFactory:
AbstractFactory factory = new FastFactory();
// 生成Html文档:
HtmlDocument html = factory.createHtml(&quot;#Hello\nHello, world!&quot;);
html.save(Paths.get(&quot;.&quot;, &quot;fast.html&quot;));
// 生成Word文档:
WordDocument word = factory.createWord(&quot;#Hello\nHello, world!&quot;);
word.save(Paths.get(&quot;.&quot;, &quot;fast.doc&quot;));</code></pre>
<p>如果我们要同时使用GoodDoc Soft的服务怎么办？因为用了抽象工厂模式，GoodDoc Soft只需要根据我们定义的抽象工厂和抽象产品接口，实现自己的实际工厂和实际产品即可：</p>
<pre><code class="highlight plaintext">// 实际工厂:public class GoodFactory implements AbstractFactory &#123;
    public HtmlDocument createHtml(String md) &#123;
        return new GoodHtmlDocument(md);
    &#125;
    public WordDocument createWord(String md) &#123;
        return new GoodWordDocument(md);
    &#125;
&#125;

// 实际产品:public class GoodHtmlDocument implements HtmlDocument &#123;
    ...
&#125;

public class GoodWordDocument implements HtmlDocument &#123;
    ...
&#125;</code></pre>
<p>客户端要使用GoodDoc Soft的服务，只需要把原来的new FastFactory()切换为new GoodFactory()即可。</p>
<p>注意到客户端代码除了通过new创建了FastFactory或GoodFactory外，其余代码只引用了产品接口，并未引用任何实际产品（例如，FastHtmlDocument），如果把创建工厂的代码放到AbstractFactory中，就可以连实际工厂也屏蔽了：</p>
<pre><code class="highlight plaintext">public interface AbstractFactory &#123;
    public static AbstractFactory createFactory(String name) &#123;
        if (name.equalsIgnoreCase(&quot;fast&quot;)) &#123;
            return new FastFactory();
        &#125; else if (name.equalsIgnoreCase(&quot;good&quot;)) &#123;
            return new GoodFactory();
        &#125; else &#123;
            throw new IllegalArgumentException(&quot;Invalid factory name&quot;);
        &#125;
    &#125;
&#125;</code></pre>
<blockquote>
<p>注意：出于简化代码的目的，我们只支持两种Markdown语法：以#开头的标题以及普通正文。</p>
</blockquote>
<h3 id="生成器"><a class="markdownIt-Anchor" href="#生成器"></a> 生成器</h3>
<blockquote>
<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
</blockquote>
<p>生成器模式（Builder）是使用多个“小型”工厂来最终创建出一个完整对象。</p>
<p>当我们使用Builder的时候，一般来说，是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。</p>
<p>我们仍然以Markdown转HTML为例，因为直接编写一个完整的转换器比较困难，但如果针对类似下面的一行文本：</p>
<pre><code class="highlight plaintext"># this is a heading</code></pre>
<p>转换成HTML就很简单：</p>
<pre><code class="highlight plaintext">&lt;h1&gt;this is a heading&lt;/h1&gt;</code></pre>
<p>因此，我们把Markdown转HTML看作一行一行的转换，每一行根据语法，使用不同的转换器：</p>
<ul>
<li>如果以#开头，使用HeadingBuilder转换；</li>
<li>如果以&gt;开头，使用QuoteBuilder转换；</li>
<li>如果以—开头，使用HrBuilder转换；</li>
<li>其余使用ParagraphBuilder转换。</li>
</ul>
<p>这个HtmlBuilder写出来如下：</p>
<pre><code class="highlight plaintext">public class HtmlBuilder &#123;
    private HeadingBuilder headingBuilder = new HeadingBuilder();
    private HrBuilder hrBuilder = new HrBuilder();
    private ParagraphBuilder paragraphBuilder = new ParagraphBuilder();
    private QuoteBuilder quoteBuilder = new QuoteBuilder();

    public String toHtml(String markdown) &#123;
        StringBuilder buffer = new StringBuilder();
        markdown.lines().forEach(line -&gt; &#123;
            if (line.startsWith(&quot;#&quot;)) &#123;
                buffer.append(headingBuilder.buildHeading(line)).append(&#x27;\n&#x27;);
            &#125; else if (line.startsWith(&quot;&gt;&quot;)) &#123;
                buffer.append(quoteBuilder.buildQuote(line)).append(&#x27;\n&#x27;);
            &#125; else if (line.startsWith(&quot;---&quot;)) &#123;
                buffer.append(hrBuilder.buildHr(line)).append(&#x27;\n&#x27;);
            &#125; else &#123;
                buffer.append(paragraphBuilder.buildParagraph(line)).append(&#x27;\n&#x27;);
            &#125;
        &#125;);
        return buffer.toString();
    &#125;
&#125;</code></pre>
<p>注意观察上述代码，HtmlBuilder并不是一次性把整个Markdown转换为HTML，而是一行一行转换，并且，它自己并不会将某一行转换为特定的HTML，而是根据特性把每一行都“委托”给一个XxxBuilder去转换，最后，把所有转换的结果组合起来，返回给客户端。</p>
<p>这样一来，我们只需要针对每一种类型编写不同的Builder。例如，针对以#开头的行，需要HeadingBuilder：</p>
<pre><code class="highlight plaintext">
public class HeadingBuilder &#123;
    public String buildHeading(String line) &#123;
        int n = 0;
        while (line.charAt(0) == &#x27;#&#x27;) &#123;
            n++;
            line = line.substring(1);
        &#125;
        return String.format(&quot;&lt;h%d&gt;%s&lt;/h%d&gt;&quot;, n, line.strip(), n);
    &#125;
&#125;</code></pre>
<p>可见，使用Builder模式时，适用于创建的对象比较复杂，最好一步一步创建出“零件”，最后再装配起来。</p>
<p>JavaMail的MimeMessage就可以看作是一个Builder模式，只不过Builder和最终产品合二为一，都是MimeMessage：</p>
<pre><code class="highlight plaintext">Multipart multipart = new MimeMultipart();
// 添加text:
BodyPart textpart = new MimeBodyPart();
textpart.setContent(body, &quot;text/html;charset=utf-8&quot;);
multipart.addBodyPart(textpart);
// 添加image:
BodyPart imagepart = new MimeBodyPart();
imagepart.setFileName(fileName);
imagepart.setDataHandler(new DataHandler(new ByteArrayDataSource(input, &quot;application/octet-stream&quot;)));
multipart.addBodyPart(imagepart);

MimeMessage message = new MimeMessage(session);
// 设置发送方地址:
message.setFrom(new InternetAddress(&quot;me@example.com&quot;));
// 设置接收方地址:
message.setRecipient(Message.RecipientType.TO, new InternetAddress(&quot;xiaoming@somewhere.com&quot;));
// 设置邮件主题:
message.setSubject(&quot;Hello&quot;, &quot;UTF-8&quot;);
// 设置邮件内容为multipart:
message.setContent(multipart);</code></pre>
<p>很多时候，我们可以简化Builder模式，以链式调用的方式来创建对象。例如，我们经常编写这样的代码：</p>
<pre><code class="highlight plaintext">StringBuilder builder = new StringBuilder();
builder.append(secure ? &quot;https://&quot; : &quot;http://&quot;)
       .append(&quot;www.liaoxuefeng.com&quot;)
       .append(&quot;/&quot;)
       .append(&quot;?t=0&quot;);
String url = builder.toString();</code></pre>
<p>由于我们经常需要构造URL字符串，可以使用Builder模式编写一个URLBuilder，调用方式如下：</p>
<pre><code class="highlight plaintext">String url = URLBuilder.builder() // 创建Builder
        .setDomain(&quot;www.liaoxuefeng.com&quot;) // 设置domain
        .setScheme(&quot;https&quot;) // 设置scheme
        .setPath(&quot;/&quot;) // 设置路径
        .setQuery(Map.of(&quot;a&quot;, &quot;123&quot;, &quot;q&quot;, &quot;K&amp;R&quot;)) // 设置query
        .build(); // 完成build</code></pre>
<h3 id="原型"><a class="markdownIt-Anchor" href="#原型"></a> 原型</h3>
<blockquote>
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
</blockquote>
<p>原型模式，即Prototype，是指创建新对象的时候，根据现有的一个原型来创建。</p>
<p>我们举个例子：如果我们已经有了一个String[]数组，想再创建一个一模一样的String[]数组，怎么写？</p>
<p>实际上创建过程很简单，就是把现有数组的元素复制到新数组。如果我们把这个创建过程封装一下，就成了原型模式。用代码实现如下：</p>
<pre><code class="highlight plaintext">// 原型:
String[] original = &#123; &quot;Apple&quot;, &quot;Pear&quot;, &quot;Banana&quot; &#125;;
// 新对象:
String[] copy = Arrays.copyOf(original, original.length);</code></pre>
<p>对于普通类，我们如何实现原型拷贝？Java的Object提供了一个clone()方法，它的意图就是复制一个新的对象出来，我们需要实现一个Cloneable接口来标识一个对象是“可复制”的：</p>
<pre><code class="highlight plaintext">public class Student implements Cloneable &#123;
    private int id;
    private String name;
    private int score;

    // 复制新对象并返回:
    public Object clone() &#123;
        Student std = new Student();
        std.id = this.id;
        std.name = this.name;
        std.score = this.score;
        return std;
    &#125;
&#125;</code></pre>
<p>使用的时候，因为clone()的方法签名是定义在Object中，返回类型也是Object，所以要强制转型，比较麻烦：</p>
<pre><code class="highlight plaintext">Student std1 = new Student();
std1.setId(123);
std1.setName(&quot;Bob&quot;);
std1.setScore(88);
// 复制新对象:
Student std2 = (Student) std1.clone();
System.out.println(std1);
System.out.println(std2);
System.out.println(std1 == std2); // false</code></pre>
<p>实际上，使用原型模式更好的方式是定义一个copy()方法，返回明确的类型：</p>
<pre><code class="highlight plaintext">public class Student &#123;
    private int id;
    private String name;
    private int score;

    public Student copy() &#123;
        Student std = new Student();
        std.id = this.id;
        std.name = this.name;
        std.score = this.score;
        return std;
    &#125;
&#125;</code></pre>
<p>原型模式应用不是很广泛，因为很多实例会持有类似文件、Socket这样的资源，而这些资源是无法复制给另一个对象共享的，只有存储简单类型的“值”对象可以复制。</p>
<h3 id="单例"><a class="markdownIt-Anchor" href="#单例"></a> 单例</h3>
<blockquote>
<p><strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点</strong>。</p>
</blockquote>
<p>单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。</p>
<p>因为这个类只有一个实例，因此，自然不能让调用方使用new Xyz()来创建实例了。所以，单例的构造方法必须是private，这样就防止了调用方自己创建实例，但是在类的内部，是可以用一个静态字段来引用唯一创建的实例的：</p>
<pre><code class="highlight plaintext">public class Singleton &#123;
    // 静态字段引用唯一实例:
    private static final Singleton INSTANCE = new Singleton();

    // private构造方法保证外部无法实例化:
    private Singleton() &#123;
    &#125;
&#125;</code></pre>
<p>那么问题来了，外部调用方如何获得这个唯一实例？</p>
<p>答案是提供一个静态方法，直接返回实例：</p>
<pre><code class="highlight plaintext">public class Singleton &#123;
    // 静态字段引用唯一实例:
    private static final Singleton INSTANCE = new Singleton();

    // 通过静态方法返回实例:
    public static Singleton getInstance() &#123;
        return INSTANCE;
    &#125;

    // private构造方法保证外部无法实例化:
    private Singleton() &#123;
    &#125;
&#125;</code></pre>
<p>或者直接把static变量暴露给外部：</p>
<pre><code class="highlight plaintext">public class Singleton &#123;
    // 静态字段引用唯一实例:
    public static final Singleton INSTANCE = new Singleton();

    // private构造方法保证外部无法实例化:
    private Singleton() &#123;
    &#125;
&#125;</code></pre>
<p>所以，单例模式的实现方式很简单：</p>
<ol>
<li>只有private构造方法，确保外部无法实例化；</li>
<li>通过private static变量持有唯一实例，保证全局唯一性；</li>
<li>通过public static方法返回此唯一实例，使外部调用方能获取到实例。</li>
</ol>
<p>Java标准库有一些类就是单例，例如Runtime这个类：</p>
<pre><code class="highlight plaintext">Runtime runtime = Runtime.getRuntime();</code></pre>
<p>有些童鞋可能听说过延迟加载，即在调用方第一次调用getInstance()时才初始化全局唯一实例，类似这样：</p>
<pre><code class="highlight plaintext">public class Singleton &#123;
    private static Singleton INSTANCE = null;

    public static Singleton getInstance() &#123;
        if (INSTANCE == null) &#123;
            INSTANCE = new Singleton();
        &#125;
        return INSTANCE;
    &#125;

    private Singleton() &#123;
    &#125;
&#125;</code></pre>
<p>遗憾的是，这种写法在多线程中是错误的，在竞争条件下会创建出多个实例。必须对整个方法进行加锁：</p>
<pre><code class="highlight plaintext">public synchronized static Singleton getInstance() &#123;
    if (INSTANCE == null) &#123;
        INSTANCE = new Singleton();
    &#125;
    return INSTANCE;
&#125;</code></pre>
<p>但加锁会严重影响并发性能。还有些童鞋听说过双重检查，类似这样：</p>
<pre><code class="highlight plaintext">public static Singleton getInstance() &#123;
    if (INSTANCE == null) &#123;
        synchronized (Singleton.class) &#123;
            if (INSTANCE == null) &#123;
                INSTANCE = new Singleton();
            &#125;
        &#125;
    &#125;
    return INSTANCE;
&#125;</code></pre>
<p>然而，由于Java的内存模型，双重检查在这里不成立。要真正实现延迟加载，只能通过Java的ClassLoader机制完成。如果没有特殊的需求，使用Singleton模式的时候，最好不要延迟加载，这样会使代码更简单。</p>
<p>另一种实现Singleton的方式是利用Java的enum，因为Java保证枚举类的每个枚举都是单例，所以我们只需要编写一个只有一个枚举的类即可：</p>
<pre><code class="highlight plaintext">public enum World &#123;
    // 唯一枚举:
        INSTANCE;

        private String name = &quot;world&quot;;

        public String getName() &#123;
                return this.name;
        &#125;

        public void setName(String name) &#123;
                this.name = name;
        &#125;
&#125;</code></pre>
<p>枚举类也完全可以像其他类那样定义自己的字段、方法，这样上面这个World类在调用方看来就可以这么用：</p>
<pre><code class="highlight plaintext">String name = World.INSTANCE.getName();</code></pre>
<p>使用<strong>枚举实现Singleton还避免了第一种方式实现Singleton的一个潜在问题</strong>：即<strong>序列化和反序列化会绕过普通类的private构造方法从而创建出多个实例</strong>，而枚举类就没有这个问题。</p>
<p>那我们什么时候应该用Singleton呢？实际上，很多程序，尤其是Web程序，大部分服务类都应该被视作Singleton，如果全部按Singleton的写法写，会非常麻烦，所以，通常是通过约定让框架（例如Spring）来实例化这些类，保证只有一个实例，调用方自觉通过框架获取实例而不是new操作符：</p>
<pre><code class="highlight plaintext">@Component // 表示一个单例组件public class MyService &#123;
    ...
&#125;</code></pre>
<p>因此，除非确有必要，否则Singleton模式一般以“约定”为主，不会刻意实现它。</p>
<p>Singleton模式是为了保证一个程序的运行期间，某个类有且只有一个全局唯一实例；Singleton模式既可以严格实现，也可以以约定的方式把普通类视作单例。</p>
<h2 id="结构性模式"><a class="markdownIt-Anchor" href="#结构性模式"></a> 结构性模式</h2>
<h3 id="适配器"><a class="markdownIt-Anchor" href="#适配器"></a> 适配器</h3>
<blockquote>
<p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
</blockquote>
<p>适配器模式是Adapter，也称Wrapper，是指如果一个接口需要B接口，但是待传入的对象却是A接口，怎么办？</p>
<p>我们举个例子。如果去美国，我们随身带的电器是无法直接使用的，因为美国的插座标准和中国不同，所以，我们需要一个适配器：</p>
<p><img src="image/-2.png" alt="-2.png" /></p>
<p>在程序设计中，适配器也是类似的。我们已经有一个Task类，实现了Callable接口：</p>
<pre><code class="highlight plaintext">public class Task implements Callable&lt;Long&gt; &#123;
    private long num;
    public Task(long num) &#123;
        this.num = num;
    &#125;

    public Long call() throws Exception &#123;
        long r = 0;
        for (long n = 1; n &lt;= this.num; n++) &#123;
            r = r + n;
        &#125;
        System.out.println(&quot;Result: &quot; + r);
        return r;
    &#125;
&#125;</code></pre>
<p>现在，我们想通过一个线程去执行它：</p>
<pre><code class="highlight plaintext">Callable&lt;Long&gt; callable = new Task(123450000L);
Thread thread = new Thread(callable); // compile error!
thread.start();</code></pre>
<p>发现编译不过！因为Thread接收Runnable接口，但不接收Callable接口，肿么办？</p>
<p>一个办法是改写Task类，把实现的Callable改为Runnable，但这样做不好，因为Task很可能在其他地方作为Callable被引用，改写Task的接口，会导致其他正常工作的代码无法编译。</p>
<p>另一个办法不用改写Task类，而是用一个Adapter，把这个Callable接口“变成”Runnable接口，这样，就可以正常编译：</p>
<pre><code class="highlight plaintext">Callable&lt;Long&gt; callable = new Task(123450000L);
Thread thread = new Thread(new RunnableAdapter(callable));
thread.start();</code></pre>
<p>这个RunnableAdapter类就是Adapter，它接收一个Callable，输出一个Runnable。怎么实现这个RunnableAdapter呢？我们先看完整的代码：</p>
<pre><code class="highlight plaintext">public class RunnableAdapter implements Runnable &#123;
    // 引用待转换接口:
    private Callable&lt;?&gt; callable;

    public RunnableAdapter(Callable&lt;?&gt; callable) &#123;
        this.callable = callable;
    &#125;

    // 实现指定接口:
    public void run() &#123;
        // 将指定接口调用委托给转换接口调用:
        try &#123;
            callable.call();
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;</code></pre>
<p>编写一个Adapter的步骤如下：</p>
<ol>
<li>实现目标接口，这里是Runnable；</li>
<li>内部持有一个待转换接口的引用，这里是通过字段持有Callable接口；</li>
<li>在目标接口的实现方法内部，调用待转换接口的方法。</li>
</ol>
<p>这样一来，Thread就可以接收这个RunnableAdapter，因为它实现了Runnable接口。Thread作为调用方，它会调用RunnableAdapter的run()方法，在这个run()方法内部，又调用了Callable的call()方法，相当于Thread通过一层转换，间接调用了Callable的call()方法。</p>
<p>适配器模式在Java标准库中有广泛应用。比如我们持有数据类型是String[]，但是需要List接口时，可以用一个Adapter：</p>
<pre><code class="highlight plaintext">String[] exist = new String[] &#123;&quot;Good&quot;, &quot;morning&quot;, &quot;Bob&quot;, &quot;and&quot;, &quot;Alice&quot;&#125;;
Set&lt;String&gt; set = new HashSet&lt;&gt;(Arrays.asList(exist));</code></pre>
<p>注意到List<T> Arrays.asList(T[])就相当于一个转换器，它可以把数组转换为List。</p>
<p>我们再看一个例子：假设我们持有一个InputStream，希望调用readText(Reader)方法，但它的参数类型是Reader而不是InputStream，怎么办？</p>
<p>当然是使用适配器，把InputStream“变成”Reader：</p>
<pre><code class="highlight plaintext">InputStream input = Files.newInputStream(Paths.get(&quot;/path/to/file&quot;));
Reader reader = new InputStreamReader(input, &quot;UTF-8&quot;);
readText(reader);</code></pre>
<p>InputStreamReader就是Java标准库提供的Adapter，它负责把一个InputStream适配为Reader。类似的还有OutputStreamWriter。</p>
<p>如果我们把readText(Reader)方法参数从Reader改为FileReader，会有什么问题？这个时候，因为我们需要一个FileReader类型，就必须把InputStream适配为FileReader：</p>
<pre><code class="highlight plaintext">FileReader reader = new InputStreamReader(input, &quot;UTF-8&quot;); // compile error!直接使用InputStreamReader</code></pre>
<p>这个Adapter是不行的，因为它只能转换出Reader接口。事实上，要把InputStream转换为FileReader也不是不可能，但需要花费十倍以上的功夫。这时，面向抽象编程这一原则就体现出了威力：持有高层接口不但代码更灵活，而且把各种接口组合起来也更容易。一旦持有某个具体的子类类型，要想做一些改动就非常困难。</p>
<h3 id="桥接"><a class="markdownIt-Anchor" href="#桥接"></a> 桥接</h3>
<blockquote>
<p>将抽象部分与它的实现部分分离，使它们都可以独立地变化</p>
</blockquote>
<p>桥接模式的定义非常玄乎，直接理解不太容易，所以我们还是举例子。假设某个汽车厂商生产三种品牌的汽车：Big、Tiny和Boss，每种品牌又可以选择燃油、纯电和混合动力。如果用传统的继承来表示各个最终车型，一共有3个抽象类加9个最终子类：</p>
<p><img src="image/-3.png" alt="-3.png" /></p>
<p>如果要新增一个品牌，或者加一个新的引擎（比如核动力），那么子类的数量增长更快。</p>
<p>所以，桥接模式就是为了避免直接继承带来的子类爆炸。</p>
<p>我们来看看桥接模式如何解决上述问题。</p>
<p>在桥接模式中，首先把Car按品牌进行子类化，但是，每个品牌选择什么发动机，不再使用子类扩充，而是通过一个抽象的“修正”类，以组合的形式引入。我们来看看具体的实现。</p>
<p>首先定义抽象类Car，它引用一个Engine：</p>
<pre><code class="highlight plaintext">public abstract class Car &#123;
    // 引用Engine:
    protected Engine engine;

    public Car(Engine engine) &#123;
        this.engine = engine;
    &#125;

    public abstract void drive();
&#125;</code></pre>
<p>Engine的定义如下：</p>
<pre><code class="highlight plaintext">public interface Engine &#123;
    void start();
&#125;</code></pre>
<p>紧接着，在一个“修正”的抽象类RefinedCar中定义一些额外操作：</p>
<pre><code class="highlight plaintext">public abstract class RefinedCar extends Car &#123;
    public RefinedCar(Engine engine) &#123;
        super(engine);
    &#125;

    public void drive() &#123;
        this.engine.start();
        System.out.println(&quot;Drive &quot; + getBrand() + &quot; car...&quot;);
    &#125;

    public abstract String getBrand();
&#125;</code></pre>
<p>这样一来，最终的不同品牌继承自RefinedCar，例如BossCar：</p>
<pre><code class="highlight plaintext">public class BossCar extends RefinedCar &#123;
    public BossCar(Engine engine) &#123;
        super(engine);
    &#125;

    public String getBrand() &#123;
        return &quot;Boss&quot;;
    &#125;
&#125;</code></pre>
<p>而针对每一种引擎，继承自Engine，例如HybridEngine：</p>
<pre><code class="highlight plaintext">public class HybridEngine implements Engine &#123;
    public void start() &#123;
        System.out.println(&quot;Start Hybrid Engine...&quot;);
    &#125;
&#125;</code></pre>
<p>客户端通过自己选择一个品牌，再配合一种引擎，得到最终的Car：</p>
<pre><code class="highlight plaintext">RefinedCar car = new BossCar(new HybridEngine());
car.drive();</code></pre>
<p>使用桥接模式的好处在于，如果要增加一种引擎，只需要针对Engine派生一个新的子类，如果要增加一个品牌，只需要针对RefinedCar派生一个子类，任何RefinedCar的子类都可以和任何一种Engine自由组合，即一辆汽车的两个维度：品牌和引擎都可以独立地变化。</p>
<p><img src="image/-4.png" alt="-4.png" /></p>
<p>桥接模式实现比较复杂，实际应用也非常少，但它提供的设计思想值得借鉴，即不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能。</p>
<h3 id="组合"><a class="markdownIt-Anchor" href="#组合"></a> 组合</h3>
<blockquote>
<p>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>
</blockquote>
<p>组合模式（Composite）经常用于树形结构，为了简化代码，使用Composite可以把一个叶子节点与一个父节点统一起来处理。我们来看一个具体的例子。</p>
<p>在XML或HTML中，从根节点开始，每个节点都可能包含任意个其他节点，这些层层嵌套的节点就构成了一颗树。</p>
<p>要以树的结构表示XML，我们可以先抽象出节点类型Node：</p>
<pre><code class="highlight plaintext">public interface Node &#123;
    // 添加一个节点为子节点:
    Node add(Node node);
    // 获取子节点:
    List&lt;Node&gt; children();
    // 输出为XML:
    String toXml();
&#125;</code></pre>
<p>对于一个<abc>这样的节点，我们称之为ElementNode，它可以作为容器包含多个子节点：</p>
<pre><code class="highlight plaintext">public class ElementNode implements Node &#123;
    private String name;
    private List&lt;Node&gt; list = new ArrayList&lt;&gt;();

    public ElementNode(String name) &#123;
        this.name = name;
    &#125;

    public Node add(Node node) &#123;
        list.add(node);
        return this;
    &#125;

    public List&lt;Node&gt; children() &#123;
        return list;
    &#125;

    public String toXml() &#123;
        String start = &quot;&lt;&quot; + name + &quot;&gt;\n&quot;;
        String end = &quot;&lt;/&quot; + name + &quot;&gt;\n&quot;;
        StringJoiner sj = new StringJoiner(&quot;&quot;, start, end);
        list.forEach(node -&gt; &#123;
            sj.add(node.toXml() + &quot;\n&quot;);
        &#125;);
        return sj.toString();
    &#125;
&#125;</code></pre>
<p>对于普通文本，我们把它看作TextNode，它没有子节点：</p>
<pre><code class="highlight plaintext">public class TextNode implements Node &#123;
        private String text;

        public TextNode(String text) &#123;
                this.text = text;
        &#125;

        public Node add(Node node) &#123;
                throw new UnsupportedOperationException();
        &#125;

        public List&lt;Node&gt; children() &#123;
                return List.of();
        &#125;

        public String toXml() &#123;
                return text;
        &#125;
&#125;</code></pre>
<p>此外，还可以有注释节点：</p>
<pre><code class="highlight plaintext">public class CommentNode implements Node &#123;
        private String text;

        public CommentNode(String text) &#123;
                this.text = text;
        &#125;

        public Node add(Node node) &#123;
                throw new UnsupportedOperationException();
        &#125;

        public List&lt;Node&gt; children() &#123;
                return List.of();
        &#125;

        public String toXml() &#123;
                return &quot;&lt;!-- &quot; + text + &quot; --&gt;&quot;;
        &#125;
&#125;</code></pre>
<p>通过ElementNode、TextNode和CommentNode，我们就可以构造出一颗树：</p>
<pre><code class="highlight plaintext">Node root = new ElementNode(&quot;school&quot;);
root.add(new ElementNode(&quot;classA&quot;)
        .add(new TextNode(&quot;Tom&quot;))
        .add(new TextNode(&quot;Alice&quot;)));
root.add(new ElementNode(&quot;classB&quot;)
        .add(new TextNode(&quot;Bob&quot;))
        .add(new TextNode(&quot;Grace&quot;))
        .add(new CommentNode(&quot;comment...&quot;)));
System.out.println(root.toXml());
</code></pre>
<p>最后通过root节点输出的XML如下：</p>
<pre><code class="highlight plaintext">&lt;school&gt;&lt;classA&gt;
Tom
Alice
&lt;/classA&gt;&lt;classB&gt;
Bob
Grace
&lt;!-- comment... --&gt;&lt;/classB&gt;&lt;/school&gt;</code></pre>
<p>可见，使用Composite模式时，需要先统一单个节点以及“容器”节点的接口:</p>
<p><img src="image/-5.png" alt="-5.png" /></p>
<p>作为容器节点的ElementNode又可以添加任意个Node，这样就可以构成层级结构。</p>
<p>类似的，像文件夹和文件、GUI窗口的各种组件，都符合Composite模式的定义，因为它们的结构天生就是层级结构。</p>
<h3 id="装饰器"><a class="markdownIt-Anchor" href="#装饰器"></a> 装饰器</h3>
<blockquote>
<p>动态地给一个对象添加一些额外的职责。就增加功能来说，相比生成子类更为灵活。</p>
</blockquote>
<p>装饰器（Decorator）模式，是一种在运行期动态给某个对象的实例增加功能的方法。</p>
<p>我们在IO的Filter模式一节中其实已经讲过装饰器模式了。在Java标准库中，InputStream是抽象类，FileInputStream、ServletInputStream、Socket.getInputStream()这些InputStream都是最终数据源。</p>
<p>现在，如果要给不同的最终数据源增加缓冲功能、计算签名功能、加密解密功能，那么，3个最终数据源、3种功能一共需要9个子类。如果继续增加最终数据源，或者增加新功能，子类会爆炸式增长，</p>
<p>这种设计方式显然是不可取的。Decorator模式的目的就是把一个一个的附加功能，用Decorator的方式给一层一层地累加到原始数据源上，最终，通过组合获得我们想要的功能。例如：给FileInputStream增加缓冲和解压缩功能，用Decorator模式写出来如下：</p>
<pre><code class="highlight plaintext">// 创建原始的数据源:
InputStream fis = new FileInputStream(&quot;test.gz&quot;);
// 增加缓冲功能:
InputStream bis = new BufferedInputStream(fis);
// 增加解压缩功能:
InputStream gis = new GZIPInputStream(bis);</code></pre>
<p>或者一次性写成这样：</p>
<pre><code class="highlight plaintext">InputStream input = new GZIPInputStream( // 第二层装饰
                        new BufferedInputStream( // 第一层装饰
                            new FileInputStream(&quot;test.gz&quot;) // 核心功能
                        ));</code></pre>
<p>观察BufferedInputStream和GZIPInputStream，它们实际上都是从FilterInputStream继承的，这个FilterInputStream就是一个抽象的Decorator。我们用图把Decorator模式画出来如下：</p>
<p><img src="image/-6.png" alt="-6.png" /></p>
<p>最顶层的Component是接口，对应到IO的就是InputStream这个抽象类。ComponentA、ComponentB是实际的子类，对应到IO的就是FileInputStream、ServletInputStream这些数据源。Decorator是用于实现各个附加功能的抽象装饰器，对应到IO的就是FilterInputStream。而从Decorator派生的就是一个一个的装饰器，它们每个都有独立的功能，对应到IO的就是BufferedInputStream、GZIPInputStream等。</p>
<p>Decorator模式有什么好处？它实际上把核心功能和附加功能给分开了。核心功能指FileInputStream这些真正读数据的源头，附加功能指加缓冲、压缩、解密这些功能。如果我们要新增核心功能，就增加Component的子类，例如ByteInputStream。如果我们要增加附加功能，就增加Decorator的子类，例如CipherInputStream。两部分都可以独立地扩展，而具体如何附加功能，由调用方自由组合，从而极大地增强了灵活性。</p>
<p>如果我们要自己设计完整的Decorator模式，应该如何设计？</p>
<p>我们还是举个栗子：假设我们需要渲染一个HTML的文本，但是文本还可以附加一些效果，比如加粗、变斜体、加下划线等。</p>
<p>为了实现动态附加效果，可以采用Decorator模式。首先，仍然需要定义顶层接口TextNode：</p>
<pre><code class="highlight plaintext">public interface TextNode &#123;
    // 设置text:
    void setText(String text);
    // 获取text:
    String getText();
&#125;</code></pre>
<p>对于核心节点，例如<span>，它需要从TextNode直接继承：</p>
<pre><code class="highlight plaintext">public class SpanNode implements TextNode &#123;
    private String text;

    public void setText(String text) &#123;
        this.text = text;
    &#125;

    public String getText() &#123;
        return &quot;&lt;span&gt;&quot; + text + &quot;&lt;/span&gt;&quot;;
    &#125;
&#125;</code></pre>
<p>紧接着，为了实现Decorator模式，需要有一个抽象的Decorator类：</p>
<pre><code class="highlight plaintext">public abstract class NodeDecorator implements TextNode &#123;
    protected final TextNode target;

    protected NodeDecorator(TextNode target) &#123;
        this.target = target;
    &#125;

    public void setText(String text) &#123;
        this.target.setText(text);
    &#125;
&#125;</code></pre>
<p>这个NodeDecorator类的核心是持有一个TextNode，即将要把功能附加到的TextNode实例。接下来就可以写一个加粗功能：</p>
<pre><code class="highlight plaintext">public class BoldDecorator extends NodeDecorator &#123;
    public BoldDecorator(TextNode target) &#123;
        super(target);
    &#125;

    public String getText() &#123;
        return &quot;&lt;b&gt;&quot; + target.getText() + &quot;&lt;/b&gt;&quot;;
    &#125;
&#125;</code></pre>
<p>类似的，可以继续加ItalicDecorator、UnderlineDecorator等。客户端可以自由组合这些</p>
<pre><code class="highlight plaintext">Decorator：TextNode n1 = new SpanNode();
TextNode n2 = new BoldDecorator(new UnderlineDecorator(new SpanNode()));
TextNode n3 = new ItalicDecorator(new BoldDecorator(new SpanNode()));
n1.setText(&quot;Hello&quot;);
n2.setText(&quot;Decorated&quot;);
n3.setText(&quot;World&quot;);
System.out.println(n1.getText());
// 输出&lt;span&gt;Hello&lt;/span&gt;

System.out.println(n2.getText());
// 输出&lt;b&gt;&lt;u&gt;&lt;span&gt;Decorated&lt;/span&gt;&lt;/u&gt;&lt;/b&gt;

System.out.println(n3.getText());
// 输出&lt;i&gt;&lt;b&gt;&lt;span&gt;World&lt;/span&gt;&lt;/b&gt;&lt;/i&gt;</code></pre>
<h3 id="外观"><a class="markdownIt-Anchor" href="#外观"></a> 外观</h3>
<blockquote>
<p>为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
</blockquote>
<p>外观模式，即Facade，是一个比较简单的模式。它的基本思想如下：</p>
<p>如果客户端要跟许多子系统打交道，那么客户端需要了解各个子系统的接口，比较麻烦。如果有一个统一的“中介”，让客户端只跟中介打交道，中介再去跟各个子系统打交道，对客户端来说就比较简单。所以Facade就相当于搞了一个中介。</p>
<p>我们以注册公司为例，假设注册公司需要三步：</p>
<ol>
<li>向工商局申请公司营业执照；</li>
<li>在银行开设账户；</li>
<li>在税务局开设纳税号。</li>
</ol>
<p>以下是三个系统的接口：</p>
<pre><code class="highlight plaintext">// 工商注册:public class AdminOfIndustry &#123;
    public Company register(String name) &#123;
        ...
    &#125;
&#125;

// 银行开户:public class Bank &#123;
    public String openAccount(String companyId) &#123;
        ...
    &#125;
&#125;

// 纳税登记:public class Taxation &#123;
    public String applyTaxCode(String companyId) &#123;
        ...
    &#125;
&#125;</code></pre>
<p>如果子系统比较复杂，并且客户对流程也不熟悉，那就把这些流程全部委托给中介：</p>
<pre><code class="highlight plaintext">public class Facade &#123;
    public Company openCompany(String name) &#123;
        Company c = this.admin.register(name);
        String bankAccount = this.bank.openAccount(c.getId());
        c.setBankAccount(bankAccount);
        String taxCode = this.taxation.applyTaxCode(c.getId());
        c.setTaxCode(taxCode);
        return c;
    &#125;
&#125;</code></pre>
<p>这样，客户端只跟Facade打交道，一次完成公司注册的所有繁琐流程：</p>
<pre><code class="highlight plaintext">Company c = facade.openCompany(&quot;Facade Software Ltd.&quot;);</code></pre>
<p>很多Web程序，内部有多个子系统提供服务，经常使用一个统一的Facade入口，例如一个RestApiController，使得外部用户调用的时候，只关心Facade提供的接口，不用管内部到底是哪个子系统处理的。</p>
<p>更复杂的Web程序，会有多个Web服务，这个时候，经常会使用一个统一的网关入口来自动转发到不同的Web服务，这种提供统一入口的网关就是Gateway，它本质上也是一个Facade，但可以附加一些用户认证、限流限速的额外服务。</p>
<h3 id="享元"><a class="markdownIt-Anchor" href="#享元"></a> 享元</h3>
<blockquote>
<p>运用共享技术有效地支持大量细粒度的对象。</p>
</blockquote>
<p>享元（Flyweight）的核心思想很简单：如果一个对象实例一经创建就不可变，那么反复创建相同的实例就没有必要，直接向调用方返回一个共享的实例就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。</p>
<p>享元模式在Java标准库中有很多应用。我们知道，包装类型如Byte、Integer都是不变类，因此，反复创建同一个值相同的包装类型是没有必要的。以Integer为例，如果我们通过Integer.valueOf()这个静态工厂方法创建Integer实例，当传入的int范围在-128~+127之间时，会直接返回缓存的Integer实例：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        Integer n1 = Integer.valueOf(100);
        Integer n2 = Integer.valueOf(100);
        System.out.println(n1 == n2); // true
    &#125;
&#125;</code></pre>
<p>对于Byte来说，因为它一共只有256个状态，所以，通过Byte.valueOf()创建的Byte实例，全部都是缓存对象。</p>
<p>因此，享元模式就是通过工厂方法创建对象，在工厂方法内部，很可能返回缓存的实例，而不是新创建实例，从而实现不可变实例的复用。</p>
<blockquote>
<p>总是使用工厂方法而不是new操作符创建实例，可获得享元模式的好处。</p>
</blockquote>
<p>在实际应用中，享元模式主要应用于缓存，即客户端如果重复请求某些对象，不必每次查询数据库或者读取文件，而是直接返回内存中缓存的数据。</p>
<p>我们以Student为例，设计一个静态工厂方法，它在内部可以返回缓存的对象：</p>
<p>在实际应用中，我们经常使用成熟的缓存库，例如Guava的Cache，因为它提供了最大缓存数量限制、定时过期等实用功能。</p>
<h3 id="代理"><a class="markdownIt-Anchor" href="#代理"></a> 代理</h3>
<blockquote>
<p>为其他对象提供一种代理以控制对这个对象的访问。</p>
</blockquote>
<p>代理模式，即Proxy，它和Adapter模式很类似。我们先回顾Adapter模式，它用于把A接口转换为B接口：</p>
<pre><code class="highlight plaintext">public class BAdapter implements B &#123;
    private A a;
    public BAdapter(A a) &#123;
        this.a = a;
    &#125;
    public void b() &#123;
        a.a();
    &#125;
&#125;</code></pre>
<p>而Proxy模式不是把A接口转换成B接口，它还是转换成A接口：</p>
<pre><code class="highlight plaintext">public class AProxy implements A &#123;
    private A a;
    public AProxy(A a) &#123;
        this.a = a;
    &#125;
    public void a() &#123;
        this.a.a();
    &#125;
&#125;</code></pre>
<p>合着Proxy就是为了给A接口再包一层，这不是脱了裤子放屁吗？</p>
<p>当然不是。我们观察Proxy的实现A接口的方法：</p>
<pre><code class="highlight plaintext">public void a() &#123;
    this.a.a();
&#125;</code></pre>
<p>这样写当然没啥卵用。但是，如果我们在调用a.a()的前后，加一些额外的代码：</p>
<pre><code class="highlight plaintext">public void a() &#123;
    if (getCurrentUser().isRoot()) &#123;
        this.a.a();
    &#125; else &#123;
        throw new SecurityException(&quot;Forbidden&quot;);
    &#125;
&#125;</code></pre>
<p>这样一来，我们就实现了权限检查，只有符合要求的用户，才会真正调用目标方法，否则，会直接抛出异常。</p>
<p>有的童鞋会问，为啥不把权限检查的功能直接写到目标实例A的内部？</p>
<p>因为我们编写代码的原则有：</p>
<ul>
<li>职责清晰：一个类只负责一件事；</li>
<li>易于测试：一次只测一个功能。</li>
</ul>
<p>用Proxy实现这个权限检查，我们可以获得更清晰、更简洁的代码：</p>
<ul>
<li>A接口：只定义接口；</li>
<li>ABusiness类：只实现A接口的业务逻辑；</li>
<li>APermissionProxy类：只实现A接口的权限检查代理。</li>
</ul>
<p>如果我们希望编写其他类型的代理，可以继续增加类似ALogProxy，而不必对现有的A接口、ABusiness类进行修改。实际上权限检查只是代理模式的一种应用。Proxy还广泛应用在：</p>
<p><strong>远程代理</strong></p>
<p>远程代理即Remote Proxy，本地的调用者持有的接口实际上是一个代理，这个代理负责把对接口的方法访问转换成远程调用，然后返回结果。Java内置的RMI机制就是一个完整的远程代理模式。</p>
<p><strong>虚代理</strong></p>
<p>虚代理即Virtual Proxy，它让调用者先持有一个代理对象，但真正的对象尚未创建。如果没有必要，这个真正的对象是不会被创建的，直到客户端需要真的必须调用时，才创建真正的对象。JDBC的连接池返回的JDBC连接（Connection对象）就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行JDBC查询或更新操作时，才真正创建实际的JDBC连接。</p>
<p><strong>保护代理</strong></p>
<p>保护代理即Protection Proxy，它用代理对象控制对原始对象的访问，常用于鉴权。</p>
<p><strong>智能引用</strong></p>
<p>智能引用即Smart Reference，它也是一种代理对象，如果有很多客户端对它进行访问，通过内部的计数器可以在外部调用者都不使用后自动释放它。</p>
<p>我们来看一下如何应用代理模式编写一个JDBC连接池（DataSource）。我们首先来编写一个虚代理，即如果调用者获取到Connection后，并没有执行任何SQL操作，那么这个Connection Proxy实际上并不会真正打开JDBC连接。调用者代码如下：</p>
<pre><code class="highlight plaintext">DataSource lazyDataSource = new LazyDataSource(jdbcUrl, jdbcUsername, jdbcPassword);
System.out.println(&quot;get lazy connection...&quot;);
try (Connection conn1 = lazyDataSource.getConnection()) &#123;
    // 并没有实际打开真正的Connection
&#125;
System.out.println(&quot;get lazy connection...&quot;);
try (Connection conn2 = lazyDataSource.getConnection()) &#123;
    try (PreparedStatement ps = conn2.prepareStatement(&quot;SELECT * FROM students&quot;)) &#123; // 打开了真正的Connection
        try (ResultSet rs = ps.executeQuery()) &#123;
            while (rs.next()) &#123;
                System.out.println(rs.getString(&quot;name&quot;));
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>现在我们来思考如何实现这个LazyConnectionProxy。为了简化代码，我们首先针对Connection接口做一个抽象的代理类：</p>
<pre><code class="highlight plaintext">public abstract class AbstractConnectionProxy implements Connection &#123;

    // 抽象方法获取实际的Connection:
    protected abstract Connection getRealConnection();

    // 实现Connection接口的每一个方法:
    public Statement createStatement() throws SQLException &#123;
        return getRealConnection().createStatement();
    &#125;

    public PreparedStatement prepareStatement(String sql) throws SQLException &#123;
        return getRealConnection().prepareStatement(sql);
    &#125;

    ...其他代理方法...
&#125;</code></pre>
<p>这个AbstractConnectionProxy代理类的作用是把Connection接口定义的方法全部实现一遍，因为Connection接口定义的方法太多了，后面我们要编写的LazyConnectionProxy只需要继承AbstractConnectionProxy，就不必再把Connection接口方法挨个实现一遍。</p>
<p>LazyConnectionProxy实现如下：</p>
<pre><code class="highlight plaintext">public class LazyConnectionProxy extends AbstractConnectionProxy &#123;
    private Supplier&lt;Connection&gt; supplier;
    private Connection target = null;

    public LazyConnectionProxy(Supplier&lt;Connection&gt; supplier) &#123;
        this.supplier = supplier;
    &#125;

    // 覆写close方法：只有target不为null时才需要关闭:
    public void close() throws SQLException &#123;
        if (target != null) &#123;
            System.out.println(&quot;Close connection: &quot; + target);
            super.close();
        &#125;
    &#125;

    @Override
    protected Connection getRealConnection() &#123;
        if (target == null) &#123;
            target = supplier.get();
        &#125;
        return target;
    &#125;
&#125;</code></pre>
<p>如果调用者没有执行任何SQL语句，那么target字段始终为null。只有第一次执行SQL语句时（即调用任何类似prepareStatement()方法时，触发getRealConnection()调用），才会真正打开实际的JDBC Connection。</p>
<p>最后，我们还需要编写一个LazyDataSource来支持这个LazyConnectionProxy：</p>
<pre><code class="highlight plaintext">public class LazyDataSource implements DataSource &#123;
    private String url;
    private String username;
    private String password;

    public LazyDataSource(String url, String username, String password) &#123;
        this.url = url;
        this.username = username;
        this.password = password;
    &#125;

    public Connection getConnection(String username, String password) throws SQLException &#123;
        return new LazyConnectionProxy(() -&gt; &#123;
            try &#123;
                Connection conn = DriverManager.getConnection(url, username, password);
                System.out.println(&quot;Open connection: &quot; + conn);
                return conn;
            &#125; catch (SQLException e) &#123;
                throw new RuntimeException(e);
            &#125;
        &#125;);
    &#125;
    ...
&#125;</code></pre>
<p>我们执行代码，输出如下：</p>
<pre><code class="highlight plaintext">get lazy connection...
get lazy connection...
Open connection: com.mysql.jdbc.JDBC4Connection@7a36aefa
小明
小红
小军
小白
...
Close connection: com.mysql.jdbc.JDBC4Connection@7a36aefa</code></pre>
<p>可见第一个getConnection()调用获取到的LazyConnectionProxy并没有实际打开真正的JDBC Connection。</p>
<p>使用连接池的时候，我们更希望能重复使用连接。如果调用方编写这样的代码：</p>
<pre><code class="highlight plaintext">DataSource pooledDataSource = new PooledDataSource(jdbcUrl, jdbcUsername, jdbcPassword);
try (Connection conn = pooledDataSource.getConnection()) &#123;
&#125;
try (Connection conn = pooledDataSource.getConnection()) &#123;
    // 获取到的是同一个Connection
&#125;
try (Connection conn = pooledDataSource.getConnection()) &#123;
    // 获取到的是同一个Connection
&#125;</code></pre>
<p>调用方并不关心是否复用了Connection，但从PooledDataSource获取的Connection确实自带这个优化功能。如何实现可复用Connection的连接池？答案仍然是使用代理模式。</p>
<pre><code class="highlight plaintext">public class PooledConnectionProxy extends AbstractConnectionProxy &#123;
    // 实际的Connection:
    Connection target;
    // 空闲队列:
    Queue&lt;PooledConnectionProxy&gt; idleQueue;
    public PooledConnectionProxy(Queue&lt;PooledConnectionProxy&gt; idleQueue, Connection target) &#123;
        this.idleQueue = idleQueue;
        this.target = target;
    &#125;
    public void close() throws SQLException &#123;
        System.out.println(&quot;Fake close and released to idle queue for future reuse: &quot; + target);
        // 并没有调用实际Connection的close()方法,
        // 而是把自己放入空闲队列:
        idleQueue.offer(this);
    &#125;
    protected Connection getRealConnection() &#123;
        return target;
    &#125;
&#125;</code></pre>
<p>复用连接的关键在于覆写close()方法，它并没有真正关闭底层JDBC连接，而是把自己放回一个空闲队列，以便下次使用。</p>
<p>空闲队列由PooledDataSource负责维护：</p>
<pre><code class="highlight plaintext">public class PooledDataSource implements DataSource &#123;
    private String url;
    private String username;
    private String password;

    // 维护一个空闲队列:
    private Queue&lt;PooledConnectionProxy&gt; idleQueue = new ArrayBlockingQueue&lt;&gt;(100);

    public PooledDataSource(String url, String username, String password) &#123;
        this.url = url;
        this.username = username;
        this.password = password;
    &#125;

    public Connection getConnection(String username, String password) throws SQLException &#123;
        // 首先试图获取一个空闲连接:
        PooledConnectionProxy conn = idleQueue.poll();
        if (conn == null) &#123;
            // 没有空闲连接时，打开一个新连接:
            conn = openNewConnection();
        &#125; else &#123;
            System.out.println(&quot;Return pooled connection: &quot; + conn.target);
        &#125;
        return conn;
    &#125;

    private PooledConnectionProxy openNewConnection() throws SQLException &#123;
        Connection conn = DriverManager.getConnection(url, username, password);
        System.out.println(&quot;Open new connection: &quot; + conn);
        return new PooledConnectionProxy(idleQueue, conn);
    &#125;
    ...
&#125;</code></pre>
<p>我们执行调用方代码，输出如下：</p>
<p><img src="image/-7.png" alt="-7.png" /></p>
<p>除了第一次打开了一个真正的JDBC Connection，后续获取的Connection实际上是同一个JDBC Connection。但是，对于调用方来说，完全不需要知道底层做了哪些优化。</p>
<p>我们实际使用的DataSource，例如HikariCP，都是基于代理模式实现的，原理同上，但增加了更多的如动态伸缩的功能（一个连接空闲一段时间后自动关闭）。</p>
<p>有的童鞋会发现Proxy模式和Decorator模式有些类似。确实，这两者看起来很像，但区别在于：Decorator模式让调用者自己创建核心类，然后组合各种功能，而Proxy模式决不能让调用者自己创建再组合，否则就失去了代理的功能。Proxy模式让调用者认为获取到的是核心类接口，但实际上是代理类。</p>
<h2 id="行为型模式"><a class="markdownIt-Anchor" href="#行为型模式"></a> 行为型模式</h2>
<p>行为型模式主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。</p>
<h3 id="责任链"><a class="markdownIt-Anchor" href="#责任链"></a> 责任链</h3>
<blockquote>
<p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>
</blockquote>
<p>责任链模式（Chain of Responsibility）是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到其中某个处理成功为止。责任链模式把多个处理器串成链，然后让请求在链上传递：</p>
<p><img src="image/-8.png" alt="-8.png" /></p>
<p>在实际场景中，财务审批就是一个责任链模式。假设某个员工需要报销一笔费用，审核者可以分为：</p>
<ul>
<li>Manager：只能审核1000元以下的报销；</li>
<li>Director：只能审核10000元以下的报销；</li>
<li>CEO：可以审核任意额度。</li>
</ul>
<p>用责任链模式设计此报销流程时，每个审核者只关心自己责任范围内的请求，并且处理它。对于超出自己责任范围的，扔给下一个审核者处理，这样，将来继续添加审核者的时候，不用改动现有逻辑。</p>
<p>我们来看看如何实现责任链模式</p>
<p>首先，我们要抽象出请求对象，它将在责任链上传递：</p>
<pre><code class="highlight plaintext">public class Request &#123;
    private String name;
    private BigDecimal amount;

    public Request(String name, BigDecimal amount) &#123;
        this.name = name;
        this.amount = amount;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public BigDecimal getAmount() &#123;
        return amount;
    &#125;</code></pre>
<p>}</p>
<p>其次，我们要抽象出处理器：</p>
<pre><code class="highlight plaintext">public interface Handler &#123;
    // 返回Boolean.TRUE = 成功
    // 返回Boolean.FALSE = 拒绝
    // 返回null = 交下一个处理
        Boolean process(Request request);
&#125;</code></pre>
<p>并且做好约定：如果返回Boolean.TRUE，表示处理成功，如果返回Boolean.FALSE，表示处理失败（请求被拒绝），如果返回null，则交由下一个Handler处理。</p>
<p>然后，依次编写ManagerHandler、DirectorHandler和CEOHandler。以ManagerHandler为例：</p>
<pre><code class="highlight plaintext">public class ManagerHandler implements Handler &#123;
    public Boolean process(Request request) &#123;
        // 如果超过1000元，处理不了，交下一个处理:
        if (request.getAmount().compareTo(BigDecimal.valueOf(1000)) &gt; 0) &#123;
            return null;
        &#125;
        // 对Bob有偏见:
        return !request.getName().equalsIgnoreCase(&quot;bob&quot;);
    &#125;
&#125;</code></pre>
<p>有了不同的Handler后，我们还要把这些Handler组合起来，变成一个链，并通过一个统一入口处理：</p>
<pre><code class="highlight plaintext">public class HandlerChain &#123;
    // 持有所有Handler:
    private List&lt;Handler&gt; handlers = new ArrayList&lt;&gt;();

    public void addHandler(Handler handler) &#123;
        this.handlers.add(handler);
    &#125;

    public boolean process(Request request) &#123;
        // 依次调用每个Handler:
        for (Handler handler : handlers) &#123;
            Boolean r = handler.process(request);
            if (r != null) &#123;
                // 如果返回TRUE或FALSE，处理结束:
                System.out.println(request + &quot; &quot; + (r ? &quot;Approved by &quot; : &quot;Denied by &quot;) + handler.getClass().getSimpleName());
                return r;
            &#125;
        &#125;
        throw new RuntimeException(&quot;Could not handle request: &quot; + request);
    &#125;
&#125;</code></pre>
<p>现在，我们就可以在客户端组装出责任链，然后用责任链来处理请求：</p>
<pre><code class="highlight plaintext">// 构造责任链:
HandlerChain chain = new HandlerChain();
chain.addHandler(new ManagerHandler());
chain.addHandler(new DirectorHandler());
chain.addHandler(new CEOHandler());
// 处理请求:
chain.process(new Request(&quot;Bob&quot;, new BigDecimal(&quot;123.45&quot;)));
chain.process(new Request(&quot;Alice&quot;, new BigDecimal(&quot;1234.56&quot;)));
chain.process(new Request(&quot;Bill&quot;, new BigDecimal(&quot;12345.67&quot;)));
chain.process(new Request(&quot;John&quot;, new BigDecimal(&quot;123456.78&quot;)));</code></pre>
<p>责任链模式本身很容易理解，需要注意的是，Handler添加的顺序很重要，如果顺序不对，处理的结果可能就不是符合要求的。</p>
<p>此外，责任链模式有很多变种。有些责任链的实现方式是通过某个Handler手动调用下一个Handler来传递Request，例如：</p>
<pre><code class="highlight plaintext">public class AHandler implements Handler &#123;
    private Handler next;
    public void process(Request request) &#123;
        if (!canProcess(request)) &#123;
            // 手动交给下一个Handler处理:
            next.process(request);
        &#125; else &#123;
            ...
        &#125;
    &#125;
&#125;</code></pre>
<p>还有一些责任链模式，每个Handler都有机会处理Request，通常这种责任链被称为拦截器（Interceptor）或者过滤器（Filter），它的目的不是找到某个Handler处理掉Request，而是每个Handler都做一些工作，比如：</p>
<ul>
<li>记录日志；</li>
<li>检查权限；</li>
<li>准备相关资源；</li>
<li>…</li>
</ul>
<p>例如，JavaEE的Servlet规范定义的Filter就是一种责任链模式，它不但允许每个Filter都有机会处理请求，还允许每个Filter决定是否将请求“放行”给下一个Filter：</p>
<pre><code class="highlight plaintext">public class AuditFilter implements Filter &#123;
    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException &#123;
        log(req);
        if (check(req)) &#123;
            // 放行:
            chain.doFilter(req, resp);
        &#125; else &#123;
            // 拒绝:
            sendError(resp);
        &#125;
    &#125;
&#125;</code></pre>
<p>这种模式不但允许一个Filter自行决定处理ServletRequest和ServletResponse，还可以“伪造”ServletRequest和ServletResponse以便让下一个Filter处理，能实现非常复杂的功能。</p>
<h3 id="命令"><a class="markdownIt-Anchor" href="#命令"></a> 命令</h3>
<blockquote>
<p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p>
</blockquote>
<p>命令模式（Command）是指，把请求封装成一个命令，然后执行该命令。</p>
<p>在使用命令模式前，我们先以一个编辑器为例子，看看如何实现简单的编辑操作：</p>
<pre><code class="highlight plaintext">public class TextEditor &#123;
    private StringBuilder buffer = new StringBuilder();

    public void copy() &#123;
        ...
    &#125;

    public void paste() &#123;
        String text = getFromClipBoard();
        add(text);
    &#125;

    public void add(String s) &#123;
        buffer.append(s);
    &#125;

    public void delete() &#123;
        if (buffer.length() &gt; 0) &#123;
            buffer.deleteCharAt(buffer.length() - 1);
        &#125;
    &#125;

    public String getState() &#123;
        return buffer.toString();
    &#125;
&#125;</code></pre>
<p>我们用一个StringBuilder模拟一个文本编辑器，它支持copy()、paste()、add()、delete()等方法。</p>
<p>正常情况，我们像这样调用TextEditor：</p>
<pre><code class="highlight plaintext">TextEditor editor = new TextEditor();
editor.add(&quot;Command pattern in text editor.\n&quot;);
editor.copy();
editor.paste();
System.out.println(editor.getState());</code></pre>
<p>这是直接调用方法，调用方需要了解TextEditor的所有接口信息。</p>
<p>如果改用命令模式，我们就要把调用方发送命令和执行方执行命令分开。怎么分？</p>
<p>解决方案是引入一个Command接口：</p>
<pre><code class="highlight plaintext">public interface Command &#123;
    void execute();
&#125;</code></pre>
<p>调用方创建一个对应的Command，然后执行，并不关心内部是如何具体执行的。为了支持CopyCommand和PasteCommand这两个命令，我们从Command接口派生：</p>
<pre><code class="highlight plaintext">public class CopyCommand implements Command &#123;
    // 持有执行者对象:
    private TextEditor receiver;

    public CopyCommand(TextEditor receiver) &#123;
        this.receiver = receiver;
    &#125;

    public void execute() &#123;
        receiver.copy();
    &#125;
&#125;

public class PasteCommand implements Command &#123;
    private TextEditor receiver;

    public PasteCommand(TextEditor receiver) &#123;
        this.receiver = receiver;
    &#125;

    public void execute() &#123;
        receiver.paste();
    &#125;
&#125;</code></pre>
<p>最后我们把Command和TextEditor组装一下，客户端这么写：</p>
<pre><code class="highlight plaintext">TextEditor editor = new TextEditor();
editor.add(&quot;Command pattern in text editor.\n&quot;);
// 执行一个CopyCommand:
Command copy = new CopyCommand(editor);
copy.execute();
editor.add(&quot;----\n&quot;);
// 执行一个PasteCommand:
Command paste = new PasteCommand(editor);
paste.execute();
System.out.println(editor.getState());</code></pre>
<p>这就是命令模式的结构：<img src="image/-9.png" alt="-9.png" /></p>
<p>有的童鞋会有疑问：搞了一大堆Command，多了好几个类，还不如直接这么写简单：</p>
<pre><code class="highlight plaintext">TextEditor editor = new TextEditor();
editor.add(&quot;Command pattern in text editor.\n&quot;);
editor.copy();
editor.paste();</code></pre>
<p>实际上，使用命令模式，确实增加了系统的复杂度。如果需求很简单，那么直接调用显然更直观而且更简单。</p>
<p>那么我们还需要命令模式吗？</p>
<p>答案是视需求而定。如果TextEditor复杂到一定程度，并且需要支持Undo、Redo的功能时，就需要使用命令模式，因为我们可以给每个命令增加undo()：</p>
<pre><code class="highlight plaintext">public interface Command &#123;
    void execute();
    void undo();
&#125;</code></pre>
<p>然后把执行的一系列命令用List保存起来，就既能支持Undo，又能支持Redo。这个时候，我们又需要一个Invoker对象，负责执行命令并保存历史命令：<img src="image/-10.png" alt="-10.png" /></p>
<p>可见，模式带来的设计复杂度的增加是随着需求而增加的，它减少的是系统各组件的耦合度。</p>
<h3 id="解释器"><a class="markdownIt-Anchor" href="#解释器"></a> 解释器</h3>
<blockquote>
<p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>
</blockquote>
<p>解释器模式（Interpreter）是一种针对特定问题设计的一种解决方案。例如，匹配字符串的时候，由于匹配条件非常灵活，使得通过代码来实现非常不灵活。举个例子，针对以下的匹配条件：</p>
<ul>
<li>以+开头的数字表示的区号和电话号码，如+861012345678；</li>
<li>以英文开头，后接英文和数字，并以.分隔的域名，<a target="_blank" rel="noopener" href="http://xn--www-eo8e.liaoxuefeng.com">如www.liaoxuefeng.com</a>；</li>
<li>以/开头的文件路径，如/path/to/file.txt；</li>
<li>…</li>
</ul>
<p>因此，需要一种通用的表示方法——正则表达式来进行匹配。正则表达式就是一个字符串，但要把正则表达式解析为语法树，然后再匹配指定的字符串，就需要一个解释器。</p>
<p>实现一个完整的正则表达式的解释器非常复杂，但是使用解释器模式却很简单：</p>
<pre><code class="highlight plaintext">String s = &quot;+861012345678&quot;;
System.out.println(s.matches(&quot;^\\+\\d+$&quot;));</code></pre>
<p>类似的，当我们使用JDBC时，执行的SQL语句虽然是字符串，但最终需要数据库服务器的SQL解释器来把SQL“翻译”成数据库服务器能执行的代码，这个执行引擎也非常复杂，但对于使用者来说，仅仅需要写出SQL字符串即可。</p>
<h3 id="迭代器"><a class="markdownIt-Anchor" href="#迭代器"></a> 迭代器</h3>
<blockquote>
<p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p>
</blockquote>
<p>迭代器模式（Iterator）实际上在Java的集合类中已经广泛使用了。我们以List为例，要遍历ArrayList，即使我们知道它的内部存储了一个Object[]数组，也不应该直接使用数组索引去遍历，因为这样需要了解集合内部的存储结构。如果使用Iterator遍历，那么，ArrayList和LinkedList都可以以一种统一的接口来遍历：</p>
<pre><code class="highlight plaintext">List&lt;String&gt; list = ...
for (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;
    String s = it.next();
&#125;</code></pre>
<p>实际上，因为Iterator模式十分有用，因此，Java允许我们直接把任何支持Iterator的集合对象用foreach循环写出来：</p>
<pre><code class="highlight plaintext">List&lt;String&gt; list = ...
for (String s : list) &#123;

&#125;</code></pre>
<p>然后由Java编译器完成Iterator模式的所有循环代码。</p>
<p>虽然我们对如何使用Iterator有了一定了解，但如何实现一个Iterator模式呢？我们以一个自定义的集合为例，通过Iterator模式实现倒序遍历：</p>
<pre><code class="highlight plaintext">public class ReverseArrayCollection&lt;T&gt; implements Iterable&lt;T&gt; &#123;
    // 以数组形式持有集合:
    private T[] array;

    public ReverseArrayCollection(T... objs) &#123;
        this.array = Arrays.copyOfRange(objs, 0, objs.length);
    &#125;

    public Iterator&lt;T&gt; iterator() &#123;
        return ???;
    &#125;
&#125;</code></pre>
<p>实现Iterator模式的关键是返回一个Iterator对象，该对象知道集合的内部结构，因为它可以实现倒序遍历。我们使用Java的内部类实现这个Iterator：</p>
<pre><code class="highlight plaintext">
public class ReverseArrayCollection&lt;T&gt; implements Iterable&lt;T&gt; &#123;
    private T[] array;

    public ReverseArrayCollection(T... objs) &#123;
        this.array = Arrays.copyOfRange(objs, 0, objs.length);
    &#125;

    public Iterator&lt;T&gt; iterator() &#123;
        return new ReverseIterator();
    &#125;

    class ReverseIterator implements Iterator&lt;T&gt; &#123;
        // 索引位置:
        int index;

        public ReverseIterator() &#123;
            // 创建Iterator时,索引在数组末尾:
            this.index = ReverseArrayCollection.this.array.length;
        &#125;

        public boolean hasNext() &#123;
            // 如果索引大于0,那么可以移动到下一个元素(倒序往前移动):
            return index &gt; 0;
        &#125;

        public T next() &#123;
            // 将索引移动到下一个元素并返回(倒序往前移动):
            index--;
            return array[index];
        &#125;
    &#125;
&#125;</code></pre>
<p>使用内部类的好处是内部类隐含地持有一个它所在对象的this引用，可以通过ReverseArrayCollection.this引用到它所在的集合。上述代码实现的逻辑非常简单，但是实际应用时，如果考虑到多线程访问，当一个线程正在迭代某个集合，而另一个线程修改了集合的内容时，是否能继续安全地迭代，还是抛出ConcurrentModificationException，就需要更仔细地设计。</p>
<h3 id="中介"><a class="markdownIt-Anchor" href="#中介"></a> 中介</h3>
<blockquote>
<p>用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
</blockquote>
<p>中介模式（Mediator）又称调停者模式，它的目的是把多方会谈变成双方会谈，从而实现多方的松耦合。</p>
<p>有些童鞋听到中介立刻想到房产中介，立刻气不打一处来。这个中介模式与房产中介还真有点像，所以消消气，先看例子。</p>
<p>考虑一个简单的点餐输入：<img src="image/-11.png" alt="-11.png" /></p>
<p>这个小系统有4个参与对象：</p>
<p><img src="image/-12.png" alt="-12.png" /></p>
<p>它的复杂性在于，当多选框变化时，它会影响“选择全部”和“取消所有”按钮的状态（是否可点击），当用户点击某个按钮时，例如“反选”，除了会影响多选框的状态，它又可能影响“选择全部”和“取消所有”按钮的状态。</p>
<p>所以这是一个多方会谈，逻辑写起来很复杂：</p>
<p><img src="image/-13.png" alt="-13.png" /></p>
<p>如果我们引入一个中介，把多方会谈变成多个双方会谈，虽然多了一个对象，但对象之间的关系就变简单了：</p>
<p><img src="image/-14.png" alt="-14.png" /></p>
<p>下面我们用中介模式来实现各个UI组件的交互。首先把UI组件给画出来：</p>
<pre><code class="highlight plaintext">
public class Main &#123;
    public static void main(String[] args) &#123;
        new OrderFrame(&quot;Hanburger&quot;, &quot;Nugget&quot;, &quot;Chip&quot;, &quot;Coffee&quot;);
    &#125;
&#125;

class OrderFrame extends JFrame &#123;
    public OrderFrame(String... names) &#123;
        setTitle(&quot;Order&quot;);
        setSize(460, 200);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        Container c = getContentPane();
        c.setLayout(new FlowLayout(FlowLayout.LEADING, 20, 20));
        c.add(new JLabel(&quot;Use Mediator Pattern&quot;));
        List&lt;JCheckBox&gt; checkboxList = addCheckBox(names);
        JButton selectAll = addButton(&quot;Select All&quot;);
        JButton selectNone = addButton(&quot;Select None&quot;);
        selectNone.setEnabled(false);
        JButton selectInverse = addButton(&quot;Inverse Select&quot;);
        new Mediator(checkBoxList, selectAll, selectNone, selectInverse);
        setVisible(true);
    &#125;

    private List&lt;JCheckBox&gt; addCheckBox(String... names) &#123;
        JPanel panel = new JPanel();
        panel.add(new JLabel(&quot;Menu:&quot;));
        List&lt;JCheckBox&gt; list = new ArrayList&lt;&gt;();
        for (String name : names) &#123;
            JCheckBox checkbox = new JCheckBox(name);
            list.add(checkbox);
            panel.add(checkbox);
        &#125;
        getContentPane().add(panel);
        return list;
    &#125;

    private JButton addButton(String label) &#123;
        JButton button = new JButton(label);
        getContentPane().add(button);
        return button;
    &#125;
&#125;</code></pre>
<p>然后，我们设计一个Mediator类，它引用4个UI组件，并负责跟它们交互：</p>
<pre><code class="highlight plaintext">
public class Mediator &#123;
    // 引用UI组件:
    private List&lt;JCheckBox&gt; checkBoxList;
    private JButton selectAll;
    private JButton selectNone;
    private JButton selectInverse;

    public Mediator(List&lt;JCheckBox&gt; checkBoxList, JButton selectAll, JButton selectNone, JButton selectInverse) &#123;
        this.checkBoxList = checkBoxList;
        this.selectAll = selectAll;
        this.selectNone = selectNone;
        this.selectInverse = selectInverse;
        // 绑定事件:
        this.checkBoxList.forEach(checkBox -&gt; &#123;
            checkBox.addChangeListener(this::onCheckBoxChanged);
        &#125;);
        this.selectAll.addActionListener(this::onSelectAllClicked);
        this.selectNone.addActionListener(this::onSelectNoneClicked);
        this.selectInverse.addActionListener(this::onSelectInverseClicked);
    &#125;

    // 当checkbox有变化时:
    public void onCheckBoxChanged(ChangeEvent event) &#123;
        boolean allChecked = true;
        boolean allUnchecked = true;
        for (var checkBox : checkBoxList) &#123;
            if (checkBox.isSelected()) &#123;
                allUnchecked = false;
            &#125; else &#123;
                allChecked = false;
            &#125;
        &#125;
        selectAll.setEnabled(!allChecked);
        selectNone.setEnabled(!allUnchecked);
    &#125;

    // 当点击select all:
    public void onSelectAllClicked(ActionEvent event) &#123;
        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(true));
        selectAll.setEnabled(false);
        selectNone.setEnabled(true);
    &#125;

    // 当点击select none:
    public void onSelectNoneClicked(ActionEvent event) &#123;
        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(false));
        selectAll.setEnabled(true);
        selectNone.setEnabled(false);
    &#125;

    // 当点击select inverse:
    public void onSelectInverseClicked(ActionEvent event) &#123;
        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(!checkBox.isSelected()));
        onCheckBoxChanged(null);
    &#125;
&#125;</code></pre>
<p>运行一下看看效果：</p>
<p><img src="image/-15.png" alt="-15.png" /></p>
<p>使用Mediator模式后，我们得到了以下好处：</p>
<ul>
<li>各个UI组件互不引用，这样就减少了组件之间的耦合关系；</li>
<li>Mediator用于当一个组件发生状态变化时，根据当前所有组件的状态决定更新某些组件；</li>
<li>如果新增一个UI组件，我们只需要修改Mediator更新状态的逻辑，现有的其他UI组件代码不变。</li>
</ul>
<p>Mediator模式经常用在有众多交互组件的UI上。为了简化UI程序，MVC模式以及MVVM模式都可以看作是Mediator模式的扩展。</p>
<h3 id="备忘录"><a class="markdownIt-Anchor" href="#备忘录"></a> 备忘录</h3>
<blockquote>
<p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
</blockquote>
<p>备忘录模式（Memento），主要用于捕获一个对象的内部状态，以便在将来的某个时候恢复此状态。</p>
<p>其实我们使用的几乎所有软件都用到了备忘录模式。最简单的备忘录模式就是保存到文件，打开文件。对于文本编辑器来说，保存就是把TextEditor类的字符串存储到文件，打开就是恢复TextEditor类的状态。对于图像编辑器来说，原理是一样的，只是保存和恢复的数据格式比较复杂而已。Java的序列化也可以看作是备忘录模式。</p>
<p>在使用文本编辑器的时候，我们还经常使用Undo、Redo这些功能。这些其实也可以用备忘录模式实现，即不定期地把TextEditor类的字符串复制一份存起来，这样就可以Undo或Redo。</p>
<p>标准的备忘录模式有这么几种角色：</p>
<ul>
<li>Memonto：存储的内部状态；</li>
<li>Originator：创建一个备忘录并设置其状态；</li>
<li>Caretaker：负责保存备忘录。</li>
</ul>
<p>实际上我们在使用备忘录模式的时候，不必设计得这么复杂，只需要对类似TextEditor的类，增加getState()和setState()就可以了。</p>
<p>我们以一个文本编辑器TextEditor为例，它内部使用StringBuilder允许用户增删字符：</p>
<pre><code class="highlight plaintext">public class TextEditor &#123;
    private StringBuilder buffer = new StringBuilder();

    public void add(char ch) &#123;
        buffer.append(ch);
    &#125;

    public void add(String s) &#123;
        buffer.append(s);
    &#125;

    public void delete() &#123;
        if (buffer.length() &gt; 0) &#123;
            buffer.deleteCharAt(buffer.length() - 1);
        &#125;
    &#125;
&#125;</code></pre>
<p>为了支持这个TextEditor能保存和恢复状态，我们增加getState()和setState()两个方法：</p>
<pre><code class="highlight plaintext">public class TextEditor &#123;
    ...

    // 获取状态:
    public String getState() &#123;
        return buffer.toString();
    &#125;

    // 恢复状态:
    public void setState(String state) &#123;
        this.buffer.delete(0, this.buffer.length());
        this.buffer.append(state);
    &#125;
&#125;</code></pre>
<p>对这个简单的文本编辑器，用一个String就可以表示其状态，对于复杂的对象模型，通常我们会使用JSON、XML等复杂格式。</p>
<h3 id="观察者"><a class="markdownIt-Anchor" href="#观察者"></a> 观察者</h3>
<blockquote>
<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
</blockquote>
<p>观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe：Pub/Sub）。它是一种通知机制，让发送通知的一方（被观察方）和接收通知的一方（观察者）能彼此分离，互不影响。</p>
<p>要理解观察者模式，我们还是看例子。</p>
<p>假设一个电商网站，有多种Product（商品），同时，Customer（消费者）和Admin（管理员）对商品上架、价格改变都感兴趣，希望能第一时间获得通知。于是，Store（商场）可以这么写：</p>
<pre><code class="highlight plaintext">public class Store &#123;
    Customer customer;
    Admin admin;

    private Map&lt;String, Product&gt; products = new HashMap&lt;&gt;();

    public void addNewProduct(String name, double price) &#123;
        Product p = new Product(name, price);
        products.put(p.getName(), p);
        // 通知用户:
        customer.onPublished(p);
        // 通知管理员:
        admin.onPublished(p);
    &#125;

    public void setProductPrice(String name, double price) &#123;
        Product p = products.get(name);
        p.setPrice(price);
        // 通知用户:
        customer.onPriceChanged(p);
        // 通知管理员:
        admin.onPriceChanged(p);
    &#125;
&#125;</code></pre>
<p>我们观察上述Store类的问题：它直接引用了Customer和Admin。先不考虑多个Customer或多个Admin的问题，上述Store类最大的问题是，如果要加一个新的观察者类型，例如工商局管理员，Store类就必须继续改动。</p>
<p>因此，上述问题的本质是Store希望发送通知给那些关心Product的对象，但Store并不想知道这些人是谁。观察者模式就是要分离被观察者和观察者之间的耦合关系。</p>
<p>要实现这一目标也很简单，Store不能直接引用Customer和Admin，相反，它引用一个ProductObserver接口，任何人想要观察Store，只要实现该接口，并且把自己注册到Store即可：</p>
<pre><code class="highlight plaintext">public class Store &#123;
    private List&lt;ProductObserver&gt; observers = new ArrayList&lt;&gt;();
    private Map&lt;String, Product&gt; products = new HashMap&lt;&gt;();

    // 注册观察者:
    public void addObserver(ProductObserver observer) &#123;
        this.observers.add(observer);
    &#125;

    // 取消注册:
    public void removeObserver(ProductObserver observer) &#123;
        this.observers.remove(observer);
    &#125;

    public void addNewProduct(String name, double price) &#123;
        Product p = new Product(name, price);
        products.put(p.getName(), p);
        // 通知观察者:
        observers.forEach(o -&gt; o.onPublished(p));
    &#125;

    public void setProductPrice(String name, double price) &#123;
        Product p = products.get(name);
        p.setPrice(price);
        // 通知观察者:
        observers.forEach(o -&gt; o.onPriceChanged(p));
    &#125;
&#125;</code></pre>
<p>就是这么一个小小的改动，使得观察者类型就可以无限扩充，而且，观察者的定义可以放到客户端：</p>
<pre><code class="highlight plaintext">// observer:
Admin a = new Admin();
Customer c = new Customer();
// store:
Store store = new Store();
// 注册观察者:
store.addObserver(a);
store.addObserver(c);</code></pre>
<p>甚至可以注册匿名观察者：</p>
<pre><code class="highlight plaintext">store.addObserver(new ProductObserver() &#123;
    public void onPublished(Product product) &#123;
        System.out.println(&quot;[Log] on product published: &quot; + product);
    &#125;

    public void onPriceChanged(Product product) &#123;
        System.out.println(&quot;[Log] on product price changed: &quot; + product);
    &#125;
&#125;);</code></pre>
<p>用一张图画出观察者模式：</p>
<p><img src="image/-16.png" alt="-16.png" /></p>
<p>观察者模式也有很多变体形式。有的观察者模式把被观察者也抽象出接口：</p>
<pre><code class="highlight plaintext">public interface ProductObservable &#123; // 注意此处拼写是Observable不是Observer!
    void addObserver(ProductObserver observer);
    void removeObserver(ProductObserver observer);
&#125;</code></pre>
<p>对应的实体被观察者就要实现该接口：</p>
<pre><code class="highlight plaintext">public class Store implements ProductObservable &#123;
    ...
&#125;</code></pre>
<p>有些观察者模式把通知变成一个Event对象，从而不再有多种方法通知，而是统一成一种：</p>
<pre><code class="highlight plaintext">public interface ProductObserver &#123;
    void onEvent(ProductEvent event);
&#125;</code></pre>
<p>让观察者自己从Event对象中读取通知类型和通知数据。</p>
<p>广义的观察者模式包括所有消息系统。所谓消息系统，就是把观察者和被观察者完全分离，通过消息系统本身来通知：</p>
<p><img src="image/-17.png" alt="-17.png" /></p>
<p>消息发送方称为Producer，消息接收方称为Consumer，Producer发送消息的时候，必须选择发送到哪个Topic。Consumer可以订阅自己感兴趣的Topic，从而只获得特定类型的消息。</p>
<p>使用消息系统实现观察者模式时，Producer和Consumer甚至经常不在同一台机器上，并且双方对对方完全一无所知，因为注册观察者这个动作本身都在消息系统中完成，而不是在Producer内部完成。</p>
<p>此外，注意到我们在编写观察者模式的时候，通知Observer是依靠语句：</p>
<pre><code class="highlight plaintext">observers.forEach(o -&gt; o.onPublished(p));</code></pre>
<p>这说明各个观察者是依次获得的同步通知，如果上一个观察者处理太慢，会导致下一个观察者不能及时获得通知。此外，如果观察者在处理通知的时候，发生了异常，还需要被观察者处理异常，才能保证继续通知下一个观察者。</p>
<p>有的童鞋可能发现Java标准库有个java.util.Observable类和一个Observer接口，用来帮助我们实现观察者模式。但是，这个类非常不！好！用！实现观察者模式的时候，也不推荐借助这两个东东。</p>
<h3 id="状态"><a class="markdownIt-Anchor" href="#状态"></a> 状态</h3>
<blockquote>
<p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p>
</blockquote>
<p>状态模式（State）经常用在带有状态的对象中。</p>
<p>什么是状态？我们以QQ聊天为例，一个用户的QQ有几种状态：</p>
<ul>
<li>离线状态（尚未登录）；</li>
<li>正在登录状态；</li>
<li>在线状态；</li>
<li>忙状态（暂时离开) 。</li>
</ul>
<p>如何表示状态？我们定义一个enum就可以表示不同的状态。但不同的状态需要对应不同的行为，比如收到消息时：</p>
<pre><code class="highlight plaintext">if (state == ONLINE) &#123;
    // 闪烁图标
&#125; else if (state == BUSY) &#123;
    reply(&quot;现在忙，稍后回复&quot;);
&#125; else if ...</code></pre>
<p>状态模式的目的是为了把上述一大串if…else…的逻辑给分拆到不同的状态类中，使得将来增加状态比较容易。</p>
<p>例如，我们设计一个聊天机器人，它有两个状态：</p>
<ul>
<li>未连线；</li>
<li>已连线。</li>
</ul>
<p>对于未连线状态，我们收到消息也不回复：</p>
<pre><code class="highlight plaintext">public class DisconnectedState implements State &#123;
    public String init() &#123;
        return &quot;Bye!&quot;;
    &#125;

    public String reply(String input) &#123;
        return &quot;&quot;;
    &#125;
&#125;</code></pre>
<p>对于已连线状态，我们回应收到的消息：public class</p>
<pre><code class="highlight plaintext">ConnectedState implements State &#123;
    public String init() &#123;
        return &quot;Hello, I&#x27;m Bob.&quot;;
    &#125;

    public String reply(String input) &#123;
        if (input.endsWith(&quot;?&quot;)) &#123;
            return &quot;Yes. &quot; + input.substring(0, input.length() - 1) + &quot;!&quot;;
        &#125;
        if (input.endsWith(&quot;.&quot;)) &#123;
            return input.substring(0, input.length() - 1) + &quot;!&quot;;
        &#125;
        return input.substring(0, input.length() - 1) + &quot;?&quot;;
    &#125;
&#125;</code></pre>
<p>状态模式的关键设计思想在于状态切换，我们引入一个BotContext完成状态切换：</p>
<pre><code class="highlight plaintext">public class BotContext &#123;
        private State state = new DisconnectedState();

        public String chat(String input) &#123;
                if (&quot;hello&quot;.equalsIgnoreCase(input)) &#123;
            // 收到hello切换到在线状态:
                        state = new ConnectedState();
                        return state.init();
                &#125; else if (&quot;bye&quot;.equalsIgnoreCase(input)) &#123;
            /  收到bye切换到离线状态:
                        state = new DisconnectedState();
                        return state.init();
                &#125;
                return state.reply(input);
        &#125;
&#125;</code></pre>
<p>这样，一个价值千万的AI聊天机器人就诞生了：</p>
<pre><code class="highlight plaintext">Scanner scanner = new Scanner(System.in);
BotContext bot = new BotContext();
for (;;) &#123;
    System.out.print(&quot;&gt; &quot;);
    String input = scanner.nextLine();
    String output = bot.chat(input);
    System.out.println(output.isEmpty() ? &quot;(no reply)&quot; : &quot;&lt; &quot; + output);
&#125;</code></pre>
<p><img src="image/-18.png" alt="-18.png" /></p>
<h3 id="策略"><a class="markdownIt-Anchor" href="#策略"></a> 策略</h3>
<blockquote>
<p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p>
</blockquote>
<p>策略模式：Strategy，是指，定义一组算法，并把其封装到一个对象中。然后在运行时，可以灵活的使用其中的一个算法。</p>
<p>策略模式在Java标准库中应用非常广泛，我们以排序为例，看看如何通过Arrays.sort()实现忽略大小写排序：</p>
<pre><code class="highlight plaintext">import java.util.Arrays;
public class Main &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        String[] array = &#123; &quot;apple&quot;, &quot;Pear&quot;, &quot;Banana&quot;, &quot;orange&quot; &#125;;
        Arrays.sort(array, String::compareToIgnoreCase);
        System.out.println(Arrays.toString(array));
    &#125;
&#125;</code></pre>
<p>如果我们想忽略大小写排序，就传入String::compareToIgnoreCase，如果我们想倒序排序，就传入(s1, s2) -&gt; -s1.compareTo(s2)，这个比较两个元素大小的算法就是策略。</p>
<p>我们观察Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)这个排序方法，它在内部实现了TimSort排序，但是，排序算法在比较两个元素大小的时候，需要借助我们传入的Comparator对象，才能完成比较。因此，这里的策略是指比较两个元素大小的策略，可以是忽略大小写比较，可以是倒序比较，也可以根据字符串长度比较。</p>
<p>因此，上述排序使用到了策略模式，它实际上指，在一个方法中，流程是确定的，但是，某些关键步骤的算法依赖调用方传入的策略，这样，传入不同的策略，即可获得不同的结果，大大增强了系统的灵活性。如果我们自己实现策略模式的排序，用冒泡法编写如下：</p>
<pre><code class="highlight plaintext">import java.util.*;
public class Main &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        String[] array = &#123; &quot;apple&quot;, &quot;Pear&quot;, &quot;Banana&quot;, &quot;orange&quot; &#125;;
        sort(array, String::compareToIgnoreCase);
        System.out.println(Arrays.toString(array));
    &#125;

    static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123;
        for (int i = 0; i &lt; a.length - 1; i++) &#123;
            for (int j = 0; j &lt; a.length - 1 - i; j++) &#123;
                if (c.compare(a[j], a[j + 1]) &gt; 0) &#123; // 注意这里比较两个元素的大小依赖传入的策略
                    T temp = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = temp;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>一个完整的策略模式要定义策略以及使用策略的上下文。我们以购物车结算为例，假设网站针对普通会员、Prime会员有不同的折扣，同时活动期间还有一个满100减20的活动，这些就可以作为策略实现。先定义打折策略接口：</p>
<pre><code class="highlight plaintext">public interface DiscountStrategy &#123;
    // 计算折扣额度:
    BigDecimal getDiscount(BigDecimal total);
&#125;</code></pre>
<p>接下来，就是实现各种策略。普通用户策略如下：</p>
<pre><code class="highlight plaintext">public class UserDiscountStrategy implements DiscountStrategy &#123;
    public BigDecimal getDiscount(BigDecimal total) &#123;
        // 普通会员打九折:
        return total.multiply(new BigDecimal(&quot;0.1&quot;)).setScale(2, RoundingMode.DOWN);
    &#125;
&#125;</code></pre>
<p>满减策略如下：</p>
<pre><code class="highlight plaintext">public class OverDiscountStrategy implements DiscountStrategy &#123;
    public BigDecimal getDiscount(BigDecimal total) &#123;
        // 满100减20优惠:
        return total.compareTo(BigDecimal.valueOf(100)) &gt;= 0 ? BigDecimal.valueOf(20) : BigDecimal.ZERO;
    &#125;
&#125;</code></pre>
<p>最后，要应用策略，我们需要一个DiscountContext：</p>
<pre><code class="highlight plaintext">public class DiscountContext &#123;
    // 持有某个策略:
    private DiscountStrategy strategy = new UserDiscountStrategy();

    // 允许客户端设置新策略:
    public void setStrategy(DiscountStrategy strategy) &#123;
        this.strategy = strategy;
    &#125;

    public BigDecimal calculatePrice(BigDecimal total) &#123;
        return total.subtract(this.strategy.getDiscount(total)).setScale(2);
    &#125;
&#125;</code></pre>
<p>调用方必须首先创建一个DiscountContext，并指定一个策略（或者使用默认策略），即可获得折扣后的价格：</p>
<pre><code class="highlight plaintext">DiscountContext ctx = new DiscountContext();

// 默认使用普通会员折扣:
BigDecimal pay1 = ctx.calculatePrice(BigDecimal.valueOf(105));
System.out.println(pay1);

// 使用满减折扣:
ctx.setStrategy(new OverDiscountStrategy());
BigDecimal pay2 = ctx.calculatePrice(BigDecimal.valueOf(105));
System.out.println(pay2);

// 使用Prime会员折扣:
ctx.setStrategy(new PrimeDiscountStrategy());
BigDecimal pay3 = ctx.calculatePrice(BigDecimal.valueOf(105));
System.out.println(pay3);</code></pre>
<p>上述完整的策略模式如下图所示：</p>
<p><img src="image/-19.png" alt="-19.png" /></p>
<p>策略模式的核心思想是在一个计算方法中把容易变化的算法抽出来作为“策略”参数传进去，从而使得新增策略不必修改原有逻辑。</p>
<h3 id="模板方法"><a class="markdownIt-Anchor" href="#模板方法"></a> 模板方法</h3>
<blockquote>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
</blockquote>
<p>模板方法（Template Method）是一个比较简单的模式。它的主要思想是，定义一个操作的一系列步骤，对于某些暂时确定不下来的步骤，就留给子类去实现好了，这样不同的子类就可以定义出不同的步骤。</p>
<p>因此，模板方法的核心在于定义一个“骨架”。我们还是举例说明。</p>
<p>假设我们开发了一个从数据库读取设置的类：</p>
<pre><code class="highlight plaintext">public class Setting &#123;
    public final String getSetting(String key) &#123;
        String value = readFromDatabase(key);
        return value;
    &#125;

        private String readFromDatabase(String key) &#123;
        // TODO: 从数据库读取
    &#125;
&#125;</code></pre>
<p>由于从数据库读取数据较慢，我们可以考虑把读取的设置缓存起来，这样下一次读取同样的key就不必再访问数据库了。但是怎么实现缓存，暂时没想好，但不妨碍我们先写出使用缓存的代码：</p>
<pre><code class="highlight plaintext">public class Setting &#123;
    public final String getSetting(String key) &#123;
        // 先从缓存读取:
        String value = lookupCache(key);
        if (value == null) &#123;
            // 在缓存中未找到,从数据库读取:
            value = readFromDatabase(key);
            System.out.println(&quot;[DEBUG] load from db: &quot; + key + &quot; = &quot; + value);
            // 放入缓存:
            putIntoCache(key, value);
        &#125; else &#123;
            System.out.println(&quot;[DEBUG] load from cache: &quot; + key + &quot; = &quot; + value);
        &#125;
        return value;
    &#125;
&#125;</code></pre>
<p>整个流程没有问题，但是，lookupCache(key)和putIntoCache(key, value)这两个方法还根本没实现，怎么编译通过？这个不要紧，我们声明抽象方法就可以：</p>
<pre><code class="highlight plaintext">public abstract class AbstractSetting &#123;
    public final String getSetting(String key) &#123;
        String value = lookupCache(key);
        if (value == null) &#123;
            value = readFromDatabase(key);
            putIntoCache(key, value);
        &#125;
        return value;
    &#125;

    protected abstract String lookupCache(String key);

    protected abstract void putIntoCache(String key, String value);
&#125;</code></pre>
<p>因为声明了抽象方法，自然整个类也必须是抽象类。如何实现lookupCache(key)和putIntoCache(key, value)这两个方法就交给子类了。子类其实并不关心核心代码getSetting(key)的逻辑，它只需要关心如何完成两个小小的子任务就可以了。</p>
<p>假设我们希望用一个Map做缓存，那么可以写一个LocalSetting：</p>
<pre><code class="highlight plaintext">public class LocalSetting extends AbstractSetting &#123;
    private Map&lt;String, String&gt; cache = new HashMap&lt;&gt;();

    protected String lookupCache(String key) &#123;
        return cache.get(key);
    &#125;

    protected void putIntoCache(String key, String value) &#123;
        cache.put(key, value);
    &#125;
&#125;</code></pre>
<p>如果我们要使用Redis做缓存，那么可以再写一个RedisSetting：</p>
<pre><code class="highlight plaintext">public class RedisSetting extends AbstractSetting &#123;
    private RedisClient client = RedisClient.create(&quot;redis://localhost:6379&quot;);

    protected String lookupCache(String key) &#123;
        try (StatefulRedisConnection&lt;String, String&gt; connection = client.connect()) &#123;
            RedisCommands&lt;String, String&gt; commands = connection.sync();
            return commands.get(key);
        &#125;
    &#125;

    protected void putIntoCache(String key, String value) &#123;
        try (StatefulRedisConnection&lt;String, String&gt; connection = client.connect()) &#123;
            RedisCommands&lt;String, String&gt; commands = connection.sync();
            commands.set(key, value);
        &#125;
    &#125;
&#125;</code></pre>
<p>客户端代码使用本地缓存的代码这么写：</p>
<pre><code class="highlight plaintext">AbstractSetting setting1 = new LocalSetting();
System.out.println(&quot;test = &quot; + setting1.getSetting(&quot;test&quot;));
System.out.println(&quot;test = &quot; + setting1.getSetting(&quot;test&quot;));</code></pre>
<p>要改成Redis缓存，只需要把LocalSetting替换为</p>
<pre><code class="highlight plaintext">RedisSetting：AbstractSetting setting2 = new RedisSetting();
System.out.println(&quot;autosave = &quot; + setting2.getSetting(&quot;autosave&quot;));
System.out.println(&quot;autosave = &quot; + setting2.getSetting(&quot;autosave&quot;));</code></pre>
<p>可见，模板方法的核心思想是：父类定义骨架，子类实现某些细节。</p>
<p>为了防止子类重写父类的骨架方法，可以在父类中对骨架方法使用final。对于需要子类实现的抽象方法，一般声明为protected，使得这些方法对外部客户端不可见。</p>
<p>Java标准库也有很多模板方法的应用。在集合类中，AbstractList和AbstractQueuedSynchronizer都定义了很多通用操作，子类只需要实现某些必要方法。</p>
<h3 id="访问者"><a class="markdownIt-Anchor" href="#访问者"></a> 访问者</h3>
<blockquote>
<p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
</blockquote>
<p>访问者模式（Visitor）是一种操作一组对象的操作，它的目的是不改变对象的定义，但允许新增不同的访问者，来定义新的操作。</p>
<p>访问者模式的设计比较复杂，如果我们查看GoF原始的访问者模式，它是这么设计的：</p>
<p><img src="image/-20.png" alt="-20.png" /></p>
<p>上述模式的复杂之处在于上述访问者模式为了实现所谓的“双重分派”，设计了一个回调再回调的机制。因为Java只支持基于多态的单分派模式，这里强行模拟出“双重分派”反而加大了代码的复杂性。</p>
<p>这里我们只介绍简化的访问者模式。假设我们要递归遍历某个文件夹的所有子文件夹和文件，然后找出.java文件，正常的做法是写个递归：</p>
<pre><code class="highlight plaintext">void scan(File dir, List&lt;File&gt; collector) &#123;
    for (File file : dir.listFiles()) &#123;
        if (file.isFile() &amp;&amp; file.getName().endsWith(&quot;.java&quot;)) &#123;
            collector.add(file);
        &#125; else if (file.isDir()) &#123;
            // 递归调用:
            scan(file, collector);
        &#125;
    &#125;
&#125;</code></pre>
<p>上述代码的问题在于，扫描目录的逻辑和处理.java文件的逻辑混在了一起。如果下次需要增加一个清理.class文件的功能，就必须再重复写扫描逻辑。</p>
<p>因此，访问者模式先把数据结构（这里是文件夹和文件构成的树型结构）和对其的操作（查找文件）分离开，以后如果要新增操作（例如清理.class文件），只需要新增访问者，不需要改变现有逻辑。</p>
<p>用访问者模式改写上述代码步骤如下：首先，我们需要定义访问者接口，即该访问者能够干的事情：</p>
<pre><code class="highlight plaintext">public interface Visitor &#123;
    // 访问文件夹:
    void visitDir(File dir);
    // 访问文件:
    void visitFile(File file);
&#125;</code></pre>
<p>紧接着，我们要定义能持有文件夹和文件的数据结构FileStructure：</p>
<pre><code class="highlight plaintext">public class FileStructure &#123;
    // 根目录:
    private File path;
    public FileStructure(File path) &#123;
        this.path = path;
    &#125;
&#125;</code></pre>
<p>然后，我们给FileStructure增加一个handle()方法，传入一个访问者：</p>
<pre><code class="highlight plaintext">public class FileStructure &#123;
    ...

    public void handle(Visitor visitor) &#123;
                scan(this.path, visitor);
        &#125;

        private void scan(File file, Visitor visitor) &#123;
                if (file.isDirectory()) &#123;
            // 让访问者处理文件夹:
                        visitor.visitDir(file);
                        for (File sub : file.listFiles()) &#123;
                // 递归处理子文件夹:
                                scan(sub, visitor);
                        &#125;
                &#125; else if (file.isFile()) &#123;
            // 让访问者处理文件:
                        visitor.visitFile(file);
                &#125;
        &#125;
&#125;</code></pre>
<p>这样，我们就把访问者的行为抽象出来了。如果我们要实现一种操作，例如，查找.java文件，就传入JavaFileVisitor：</p>
<pre><code class="highlight plaintext">FileStructure fs = new FileStructure(new File(&quot;.&quot;));
fs.handle(new JavaFileVisitor());</code></pre>
<p>这个JavaFileVisitor实现如下：</p>
<pre><code class="highlight plaintext">public class JavaFileVisitor implements Visitor &#123;
    public void visitDir(File dir) &#123;
        System.out.println(&quot;Visit dir: &quot; + dir);
    &#125;

    public void visitFile(File file) &#123;
        if (file.getName().endsWith(&quot;.java&quot;)) &#123;
            System.out.println(&quot;Found java file: &quot; + file);
        &#125;
    &#125;
&#125;
</code></pre>
<p>类似的，如果要清理.class文件，可以再写一个ClassFileClearnerVisitor：</p>
<pre><code class="highlight plaintext">public class ClassFileCleanerVisitor implements Visitor &#123;
        public void visitDir(File dir) &#123;
        &#125;

        public void visitFile(File file) &#123;
                if (file.getName().endsWith(&quot;.class&quot;)) &#123;
                        System.out.println(&quot;Will clean class file: &quot; + file);
                &#125;
        &#125;
&#125;</code></pre>
<p>可见，访问者模式的核心思想是为了访问比较复杂的数据结构，不去改变数据结构，而是把对数据的操作抽象出来，在“访问”的过程中以回调形式在访问者中处理操作逻辑。如果要新增一组操作，那么只需要增加一个新的访问者。</p>
<p>实际上，Java标准库提供的Files.walkFileTree()已经实现了一个访问者模式：</p>
<pre><code class="highlight plaintext">import java.io.*;
import java.nio.file.*;
import java.nio.file.attribute.*;
public class Main &#123;
    public static void main(String[] args) throws IOException &#123;
        Files.walkFileTree(Paths.get(&quot;.&quot;), new MyFileVisitor());
    &#125;
&#125;

// 实现一个FileVisitor:
class MyFileVisitor extends SimpleFileVisitor&lt;Path&gt; &#123;
    // 处理Directory:
    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException &#123;
        System.out.println(&quot;pre visit dir: &quot; + dir);
        // 返回CONTINUE表示继续访问:
        return FileVisitResult.CONTINUE;
    &#125;

    // 处理File:
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;
        System.out.println(&quot;visit file: &quot; + file);
        // 返回CONTINUE表示继续访问:
        return FileVisitResult.CONTINUE;
    &#125;
&#125;</code></pre>
<p>Files.walkFileTree()允许访问者返回FileVisitResult.CONTINUE以便继续访问，或者返回FileVisitResult.TERMINATE停止访问。</p>
<p>类似的，对XML的SAX处理也是一个访问者模式，我们需要提供一个SAX Handler作为访问者处理XML的各个节点。</p>
</main>

</article>


<script src="/js/highlight.js"></script>

  </main>
  <footer class="footer">
  
  <span>Copyright © 2026 Lism Blog | lisisism@qq.com</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>