<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    Lambda/函数式编程 丨
    

    Lism Blog
  </title>

  
  <link rel="shortcut icon" href="/icon.svg">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="/Lism Blog" type="application/atom+xml">
</head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">/Lism Blog</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <article class="post">
  
  <div class="post-title">Lambda/函数式编程</div>
  <div class="post-meta">
    <div class="date">2020 六月 15日</div>
    <div class="tags">
      
      <div class="tag-item">Lambda</div>
      
      <div class="tag-item">函数式编程</div>
      
    </div>
  </div>
  

  <main class="post-content"><h1 id="lambda函数式编程"><a class="markdownIt-Anchor" href="#lambda函数式编程"></a> $Lambda/函数式编程</h1>
<h2 id="函数式编程"><a class="markdownIt-Anchor" href="#函数式编程"></a> 函数式编程</h2>
<ul>
<li><a href="">函数式编程</a>
<ul>
<li><a href="">Lambda基础</a>
<ul>
<li><a href="">Lambda表达式</a></li>
<li><a href="">Functionallnterface</a></li>
</ul>
</li>
<li><a href="">方法引用</a>
<ul>
<li><a href="">普通方法引用</a></li>
<li><a href="">构造方法引用</a></li>
</ul>
</li>
<li><a href="">使用Stream</a>
<ul>
<li><a href="">创建Stream</a></li>
<li><a href="">map转换</a></li>
<li><a href="">filter过滤</a></li>
<li><a href="">reduce聚合</a></li>
<li><a href="">输出集合</a>
<ul>
<li><a href="">输出为List</a></li>
<li><a href="">输出为数组</a></li>
<li><a href="">输出为Map</a></li>
<li><a href="">分组输出</a></li>
</ul>
</li>
<li><a href="">其他操作</a>
<ul>
<li><a href="">排序</a></li>
<li><a href="">去重</a></li>
<li><a href="">截取</a></li>
<li><a href="">合并</a></li>
<li><a href="">flatMap</a></li>
<li><a href="">并行</a></li>
<li><a href="">其他聚合方法</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>我们先看看什么是函数。函数是一种最基本的任务，一个大型程序就是一个顶层函数调用若干底层函数，这些被调用的函数又可以调用其他函数，即大任务被一层层拆解并执行。所以函数就是面向过程的程序设计的基本单元。</p>
<p>Java不支持单独定义函数，但可以把静态方法视为独立的函数，把实例方法视为自带this参数的函数。</p>
<p>而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。</p>
<p>我们首先要搞明白计算机（Computer）和计算（Compute）的概念。</p>
<p>在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。</p>
<p>而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。</p>
<p>对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。</p>
<p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>
<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<h3 id="lambda基础"><a class="markdownIt-Anchor" href="#lambda基础"></a> Lambda基础</h3>
<p>在了解Lambda之前，我们先回顾一下Java的方法。</p>
<p>Java的方法分为实例方法，例如Integer定义的equals()方法：</p>
<pre><code class="highlight plaintext">public final class Integer &#123;
    boolean equals(Object o) &#123;
        ...
    &#125;
&#125;</code></pre>
<p>以及静态方法，例如Integer定义的parseInt()方法：</p>
<pre><code class="highlight plaintext">public final class Integer &#123;
    public static int parseInt(String s) &#123;
        ...
    &#125;
&#125;</code></pre>
<p>无论是实例方法，还是静态方法，本质上都相当于过程式语言的函数。例如C函数：</p>
<pre><code class="highlight plaintext">char* strcpy(char* dest, char* src)</code></pre>
<p>只不过Java的实例方法隐含地传入了一个this变量，即实例方法总是有一个隐含参数this。</p>
<p>函数式编程（Functional Programming）是把函数作为基本运算单元，函数可以作为变量，可以接收函数，还可以返回函数。历史上研究函数式编程的理论是Lambda演算，所以我们经常把支持函数式编程的编码风格称为Lambda表达式。</p>
<h4 id="lambda表达式"><a class="markdownIt-Anchor" href="#lambda表达式"></a> Lambda表达式</h4>
<p>在Java程序中，我们经常遇到一大堆单方法接口，即一个接口只定义了一个方法：</p>
<ul>
<li>Comparator</li>
<li>Runnable</li>
<li>Callable</li>
</ul>
<p>以Comparator为例，我们想要调用Arrays.sort()时，可以传入一个Comparator实例，以匿名类方式编写如下：</p>
<pre><code class="highlight plaintext">String[] array = ...
Arrays.sort(array, new Comparator&lt;String&gt;() &#123;
    public int compare(String s1, String s2) &#123;
        return s1.compareTo(s2);
    &#125;
&#125;);</code></pre>
<p>上述写法非常繁琐。从Java 8开始，我们可以用Lambda表达式替换单方法接口。改写上述代码如下</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        String[] array = new String[] &#123; &quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;, &quot;Lemon&quot; &#125;;
        Arrays.sort(array, (s1, s2) -&gt; &#123;
            return s1.compareTo(s2);
        &#125;);
        System.out.println(String.join(&quot;, &quot;, array));
    &#125;
&#125;</code></pre>
<p>观察<strong>Lambda表达式的写法</strong>，它只需要写出方法定义：</p>
<pre><code class="highlight plaintext">(s1, s2) -&gt; &#123;
    return s1.compareTo(s2);
&#125;</code></pre>
<p>其中，参数是(s1, s2)，参数类型可以省略，因为编译器可以自动推断出String类型</p>
<p><code>-&gt; &#123; ... &#125;</code> 表示方法体，所有代码写在内部即可。Lambda表达式没有class定义，因此写法非常简洁</p>
<p><strong>如果只有一行return xxx的代码，完全可以用更简单的写法</strong>：</p>
<pre><code class="highlight plaintext">Arrays.sort(array, (s1, s2) -&gt; s1.compareTo(s2));</code></pre>
<blockquote>
<p>返回值的类型也是由编译器自动推断的，这里推断出的返回值是int，因此，只要返回int，编译器就不会报错</p>
</blockquote>
<h4 id="functionallnterface"><a class="markdownIt-Anchor" href="#functionallnterface"></a> Functionallnterface</h4>
<p>我们把只定义了单方法的接口称之为FunctionalInterface，用注解@FunctionalInterface标记。例如，Callable接口：</p>
<pre><code class="highlight plaintext">@FunctionalInterface
public interface Callable&lt;V&gt; &#123;
    V call() throws Exception;
&#125;</code></pre>
<p>再来看Comparator接口：</p>
<pre><code class="highlight plaintext">@FunctionalInterface
public interface Comparator&lt;T&gt; &#123;

    int compare(T o1, T o2);

    boolean equals(Object obj);

    default Comparator&lt;T&gt; reversed() &#123;
        return Collections.reverseOrder(this);
    &#125;

    default Comparator&lt;T&gt; thenComparing(Comparator&lt;? super T&gt; other) &#123;
        ...
    &#125;
    ...
&#125;</code></pre>
<p>虽然Comparator接口有很多方法，但只有一个抽象方法int compare(T o1, T o2)，其他的方法都是default方法或static方法。另外注意到boolean equals(Object obj)是Object定义的方法，不算在接口方法内。因此，Comparator也是一个FunctionalInterface</p>
<h3 id="方法引用"><a class="markdownIt-Anchor" href="#方法引用"></a> 方法引用</h3>
<h4 id="普通方法引用"><a class="markdownIt-Anchor" href="#普通方法引用"></a> 普通方法引用</h4>
<p>使用Lambda表达式，我们就可以不必编写FunctionalInterface接口的实现类，从而简化代码：</p>
<pre><code class="highlight plaintext">Arrays.sort(array, (s1, s2) -&gt; &#123;
    return s1.compareTo(s2);
&#125;);</code></pre>
<p><strong>引入静态方法</strong></p>
<p>除了Lambda表达式，我们还可以<strong>直接传入方法引用</strong>。</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        String[] array = new String[] &#123; &quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;, &quot;Lemon&quot; &#125;;
        Arrays.sort(array, Main::cmp);
        System.out.println(String.join(&quot;, &quot;, array));
    &#125;

    static int cmp(String s1, String s2) &#123;
        return s1.compareTo(s2);
    &#125;
&#125;</code></pre>
<blockquote>
<p>上述代码在Arrays.sort()中直接传入了静态方法cmp的引用，用Main::cmp表示</p>
</blockquote>
<p>因此，所谓方法引用，是指如果某个<strong>方法签名（签名指方法返回值和参数相同）和接口恰好一致</strong>，就可以直接传入方法引用</p>
<p>因为Comparator<String>接口定义的方法是int compare(String, String)，和静态方法int cmp(String, String)相比，除了方法名外，方法参数一致，返回类型相同，因此，我们说两者的方法签名一致，可以直接把方法名作为Lambda表达式传入：</p>
<pre><code class="highlight plaintext">Arrays.sort(array, Main::cmp);</code></pre>
<blockquote>
<p>注意：在这里，方法签名只看参数类型和返回类型，不看方法名称，也不看类的继承关系</p>
</blockquote>
<p>案例：</p>
<pre><code class="highlight plaintext">    public static void main(String[] args) &#123;
        List&lt;Person&gt; persons = Arrays.asList(
                new Person(&quot;小明&quot;, 88),
                new Person(&quot;小黑&quot;, 62),
                new Person(&quot;小白&quot;, 45),
                new Person(&quot;小黄&quot;, 78),
                new Person(&quot;小红&quot;, 99),
                new Person(&quot;小林&quot;, 58));
        persons.stream().filter((p) -&gt; p.score &gt;= 60).forEach(Person::prin);
    &#125;

class Person &#123;
    String name;
    int score;
    Person(String name, int score) &#123;
        this.name = name;
        this.score = score;
    &#125;
    static void prin(Person p)&#123;
        System.out.println(p.score);System.out.println(p.name);
    &#125;
&#125;</code></pre>
<p><strong>引用实例方法</strong></p>
<ul>
<li>如果是<strong>实例方法，切记方法第一个参数是this</strong>，即没有形参的方法可以被有一个形参的接口传入方法引用</li>
</ul>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        String[] array = new String[] &#123; &quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;, &quot;Lemon&quot; &#125;;
        Arrays.sort(array, String::compareTo);
        System.out.println(String.join(&quot;, &quot;, array));
    &#125;
&#125;</code></pre>
<p>不但可以编译通过，而且运行结果也是一样的，这说明String.compareTo()方法也符合Lambda定义</p>
<p>观察String.compareTo()的方法定义：</p>
<pre><code class="highlight plaintext">public final class String &#123;
    public int compareTo(String o) &#123;
        ...
    &#125;
&#125;</code></pre>
<p>这个方法的签名只有一个参数，之所以能和int Comparator<String>.compare(String, String)能匹配，因为实例方法有一个隐含的this参数，String类的compareTo()方法在实际调用的时候，第一个隐含参数总是传入this，相当于静态方法：</p>
<pre><code class="highlight plaintext">public static int compareTo(this, String o);</code></pre>
<blockquote>
<p>所以，String.compareTo()方法也可作为方法引用传入</p>
</blockquote>
<h4 id="构造方法引用"><a class="markdownIt-Anchor" href="#构造方法引用"></a> 构造方法引用</h4>
<p>除了可以引用静态方法和实例方法，我们还可以引用构造方法。我们来看一个例子：</p>
<p>如果要把一个List<String>转换为List<Person>，应该怎么办？</p>
<pre><code class="highlight plaintext">class Person &#123;
    String name;
    public Person(String name) &#123;
        this.name = name;
    &#125;
&#125;

List&lt;String&gt; names = List.of(&quot;Bob&quot;, &quot;Alice&quot;, &quot;Tim&quot;);
List&lt;Person&gt; persons = ???</code></pre>
<p>传统的做法是先定义一个ArrayList<Person>，然后用for循环填充这个List：</p>
<pre><code class="highlight plaintext">List&lt;String&gt; names = List.of(&quot;Bob&quot;, &quot;Alice&quot;, &quot;Tim&quot;);
List&lt;Person&gt; persons = new ArrayList&lt;&gt;();
for (String name : names) &#123;
    persons.add(new Person(name));
&#125;</code></pre>
<p><strong>引入构造方法</strong></p>
<p>要更简单地实现String到Person的转换，我们可以引用Person的构造方法：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        List&lt;String&gt; names = List.of(&quot;Bob&quot;, &quot;Alice&quot;, &quot;Tim&quot;);
        List&lt;Person&gt; persons = names.stream().map(Person::new).collect(Collectors.toList());
        System.out.println(persons);
    &#125;
&#125;

class Person &#123;
    String name;
    public Person(String name) &#123;
        this.name = name;
    &#125;
    public String toString() &#123;
        return &quot;Person:&quot; + this.name;
    &#125;
&#125;</code></pre>
<p>后面我们会讲到Stream的map()方法。现在我们看到，这里的map()需要传入的FunctionalInterface的定义是：</p>
<pre><code class="highlight plaintext">@FunctionalInterface
public interface Function&lt;T, R&gt; &#123;
    R apply(T t);
&#125;</code></pre>
<p>把泛型对应上就是方法签名Person apply(String)，即传入参数String，返回类型Person。而Person类的构造方法恰好满足这个条件，因为构造方法的参数是String，而<strong>构造方法虽然没有return语句，但它会隐式地返回this实例</strong>，类型就是Person，因此，此处可以引用构造方法。构造方法的引用写法是类名::new，因此，此处传入Person::new</p>
<h3 id="使用stream"><a class="markdownIt-Anchor" href="#使用stream"></a> 使用Stream</h3>
<p>Java从8开始，不但引入了Lambda表达式，还引入了一个全新的流式API：Stream API。它位于java.util.stream包中</p>
<p><strong>划重点：这个Stream不同于java.io的InputStream和OutputStream</strong>，它代表的是任意Java对象的序列。两者对比如下：</p>
<table>
<thead>
<tr>
<th></th>
<th><a target="_blank" rel="noopener" href="http://java.io">java.io</a></th>
<th>java.util.stream</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储</td>
<td>顺序读写的byte或char</td>
<td>顺序输出任意的Java对象实例</td>
</tr>
<tr>
<td>用途</td>
<td>序列化至文件或网络</td>
<td>内存计算/业务逻辑</td>
</tr>
</tbody>
</table>
<p>有同学会问：一个顺序输出的Java对象序列，不就是一个List容器吗？</p>
<p><strong>再次划重点：这个Stream和List也不一样，List存储的每个元素都是已经存储在内存中的某个Java对象，而Stream输出的元素可能并没有预先存储在内存中，而是实时计算出来的</strong>。</p>
<p>换句话说，List的用途是操作一组已存在的Java对象，而Stream实现的是惰性计算，两者对比如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>java.util.List</th>
<th>java.util.stream</th>
</tr>
</thead>
<tbody>
<tr>
<td>元素</td>
<td>已分配并存储在内存</td>
<td>可能未分配，实时计算</td>
</tr>
<tr>
<td>用途</td>
<td>操作一组已存在的Java对象</td>
<td>惰性计算</td>
</tr>
</tbody>
</table>
<p>Stream看上去有点不好理解，但我们举个例子就明白了。</p>
<p>如果我们要表示一个全体自然数的集合，显然，用List是不可能写出来的，因为自然数是无限的，内存再大也没法放到List中：</p>
<pre><code class="highlight plaintext">List&lt;BigInteger&gt; list = ??? // 全体自然数?</code></pre>
<p>但是，用Stream可以做到。写法如下：</p>
<pre><code class="highlight plaintext">Stream&lt;BigInteger&gt; naturals = createNaturalStream(); // 全体自然数</code></pre>
<p>我们先不考虑createNaturalStream()这个方法是如何实现的，我们看看如何使用这个Stream。</p>
<p>首先，我们可以对每个自然数做一个平方，这样我们就把这个Stream转换成了另一个Stream：</p>
<pre><code class="highlight plaintext">Stream&lt;BigInteger&gt; naturals = createNaturalStream(); // 全体自然数
Stream&lt;BigInteger&gt; streamNxN = naturals.map(n -&gt; n.multiply(n)); // 全体自然数的平方</code></pre>
<p>因为这个streamNxN也有无限多个元素，要打印它，必须首先把无限多个元素变成有限个元素，可以用limit()方法截取前100个元素，最后用forEach()处理每个元素，这样，我们就打印出了前100个自然数的平方：</p>
<pre><code class="highlight plaintext">Stream&lt;BigInteger&gt; naturals = createNaturalStream();
naturals.map(n -&gt; n.multiply(n)) // 1, 4, 9, 16, 25...
        .limit(100)
        .forEach(System.out::println);</code></pre>
<p>我们总结一下Stream的特点：它可以“存储”有限个或无限个元素。这里的存储打了个引号，是因为元素有可能已经全部存储在内存中，也有可能是根据需要实时计算出来的。</p>
<p>Stream的另一个特点是，一个Stream可以轻易地转换为另一个Stream，而不是修改原Stream本身。</p>
<p>最后，真正的计算通常发生在最后结果的获取，也就是惰性计算。</p>
<pre><code class="highlight plaintext">Stream&lt;BigInteger&gt; naturals = createNaturalStream(); // 不计算
Stream&lt;BigInteger&gt; s2 = naturals.map(BigInteger::multiply); // 不计算
Stream&lt;BigInteger&gt; s3 = s2.limit(100); // 不计算
s3.forEach(System.out::println); // 计算</code></pre>
<p><strong>惰性计算的特点是：一个Stream转换为另一个Stream时，实际上只存储了转换规则，并没有任何计算发生</strong>。</p>
<p>例如，创建一个全体自然数的Stream，不会进行计算，把它转换为上述s2这个Stream，也不会进行计算。再把s2这个无限Stream转换为s3这个有限的Stream，也不会进行计算。只有最后，调用forEach确实需要Stream输出的元素时，才进行计算。我们通常把Stream的操作写成链式操作，代码更简洁：</p>
<pre><code class="highlight plaintext">createNaturalStream()
    .map(BigInteger::multiply)
    .limit(100)
    .forEach(System.out::println);</code></pre>
<p>因此，Stream API的基本用法就是：创建一个Stream，然后做若干次转换，最后调用一个求值方法获取真正计算的结果：</p>
<pre><code class="highlight plaintext">int result = createNaturalStream() // 创建Stream
             .filter(n -&gt; n % 2 == 0) // 任意个转换
             .map(n -&gt; n * n) // 任意个转换
             .limit(100) // 任意个转换
             .sum(); // 最终计算结果</code></pre>
<h4 id="创建stream"><a class="markdownIt-Anchor" href="#创建stream"></a> 创建Stream</h4>
<p>要使用Stream，就必须现创建它。创建Stream有很多种方法，我们来一一介绍</p>
<p><strong>Stream.of</strong>()</p>
<p>创建Stream最简单的方式是直接用Stream.of()静态方法，传入可变参数即创建了一个能输出确定元素的Stream：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Stream&lt;String&gt; stream = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;);
        // forEach()方法相当于内部循环调用，
        // 可传入符合Consumer接口的void accept(T t)的方法引用：
        stream.forEach(System.out::println);
    &#125;
&#125;</code></pre>
<blockquote>
<p>虽然这种方式基本上没啥实质性用途，但测试的时候很方便</p>
</blockquote>
<p><strong>基于数组或Collection</strong></p>
<p>第二种创建Stream的方法是基于一个数组或者Collection，这样该Stream输出的元素就是数组或者Collection持有的元素：</p>
<pre><code class="highlight plaintext">import java.util.*;
import java.util.stream.*;

public class Main &#123;
    public static void main(String[] args) &#123;
        Stream&lt;String&gt; stream1 = Arrays.stream(new String[] &#123; &quot;A&quot;, &quot;B&quot;, &quot;C&quot; &#125;);
        Stream&lt;String&gt; stream2 = List.of(&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;).stream();
        stream1.forEach(System.out::println);
        stream2.forEach(System.out::println);
    &#125;
&#125;</code></pre>
<blockquote>
<p>把数组变成Stream使用Arrays.stream()方法。对于Collection（List、Set、Queue等），直接调用stream()方法就可以获得Stream</p>
</blockquote>
<blockquote>
<p>上述创建Stream的方法都是把一个现有的序列变为Stream，它的元素是固定的</p>
</blockquote>
<p><strong>基于Supplier</strong></p>
<p>创建Stream还可以通过Stream.generate()方法，它需要传入一个Supplier对象：</p>
<pre><code class="highlight plaintext">Stream&lt;String&gt; s = Stream.generate(Supplier&lt;String&gt; sp);</code></pre>
<p>基于Supplier创建的Stream会不断调用Supplier.get()方法来不断产生下一个元素，这种Stream保存的不是元素，而是算法，它可以用来表示无限序列</p>
<p>例如，我们编写一个能不断生成自然数的Supplier，它的代码非常简单，每次调用get()方法，就生成下一个自然数：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Stream&lt;Integer&gt; natual = Stream.generate(new NatualSupplier());
        // 注意：无限序列必须先变成有限序列再打印:
        natual.limit(20).forEach(System.out::println);
    &#125;
&#125;

class NatualSupplier implements Supplier&lt;Integer&gt; &#123;
    int n = 0;
    public Integer get() &#123;
        n++;
        return n;
    &#125;
&#125;</code></pre>
<p>上述代码我们用一个Supplier<Integer>模拟了一个无限序列（当然受int范围限制不是真的无限大）。如果用List表示，即便在int范围内，也会占用巨大的内存，而Stream几乎不占用空间，因为每个元素都是实时计算出来的，用的时候再算。</p>
<p><strong>对于无限序列，如果直接调用forEach()或者count()这些最终求值操作，会进入死循环，因为永远无法计算完这个序列，所以正确的方法是先把无限序列变成有限序列</strong>，例如，用limit()方法可以截取前面若干个元素，这样就变成了一个有限序列，对这个有限序列调用forEach()或者count()操作就没有问题</p>
<p><strong>其他方法</strong></p>
<p>创建Stream的第三种方法是通过一些API提供的接口，直接获得Stream。</p>
<p>例如，Files类的lines()方法可以把一个文件变成一个Stream，每个元素代表文件的一行内容</p>
<pre><code class="highlight plaintext">try (Stream&lt;String&gt; lines = Files.lines(Paths.get(&quot;/path/to/file.txt&quot;))) &#123;
    ...
&#125;</code></pre>
<p>此方法对于按行遍历文本文件十分有用。</p>
<p>另外，正则表达式的Pattern对象有一个splitAsStream()方法，可以直接把一个长字符串分割成Stream序列而不是数组：</p>
<pre><code class="highlight plaintext">Pattern p = Pattern.compile(&quot;\\s+&quot;);
Stream&lt;String&gt; s = p.splitAsStream(&quot;The quick brown fox jumps over the lazy dog&quot;);
s.forEach(System.out::println);</code></pre>
<p><strong>基本类型</strong></p>
<p>因为Java的范型不支持基本类型，所以我们无法用Stream<int>这样的类型，会发生编译错误。为了保存int，只能使用Stream<Integer>，但这样会产生频繁的装箱、拆箱操作。为了提高效率，Java标准库提供了IntStream、LongStream和DoubleStream这三种使用基本类型的Stream，它们的使用方法和范型Stream没有大的区别，设计这三个Stream的目的是提高运行效率：</p>
<pre><code class="highlight plaintext">// 将int[]数组变为IntStream:
IntStream is = Arrays.stream(new int[] &#123; 1, 2, 3 &#125;);
// 将Stream&lt;String&gt;转换为LongStream:
LongStream ls = List.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;).stream().mapToLong(Long::parseLong);</code></pre>
<h4 id="map转换"><a class="markdownIt-Anchor" href="#map转换"></a> map转换</h4>
<p>Stream.map()是Stream最常用的一个转换方法，它把一个Stream转换为另一个Stream。</p>
<p>所谓map操作，就是把一种操作运算，映射到一个序列的每一个元素上。例如，对x计算它的平方，可以使用函数f(x) = x * x。我们把这个函数映射到一个序列1，2，3，4，5上，就得到了另一个序列1，4，9，16，25：</p>
<p>可见，map操作，把一个Stream的每个元素一一对应到应用了目标函数的结果上。</p>
<pre><code class="highlight plaintext">Stream&lt;Integer&gt; s = Stream.of(1, 2, 3, 4, 5);
Stream&lt;Integer&gt; s2 = s.map(n -&gt; n * n);</code></pre>
<p>如果我们查看Stream的源码，会发现map()方法接收的对象是Function接口对象，它定义了一个apply()方法，负责把一个T类型转换成R类型：</p>
<pre><code class="highlight plaintext">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</code></pre>
<p>其中，Function的定义是：</p>
<pre><code class="highlight plaintext">@FunctionalInterface
public interface Function&lt;T, R&gt; &#123;
    // 将T类型转换为R:
    R apply(T t);
&#125;</code></pre>
<p>利用map()，不但能完成数学计算，对于字符串操作，以及任何Java对象都是非常有用的。例如：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        List.of(&quot;  Apple &quot;, &quot; pear &quot;, &quot; ORANGE&quot;, &quot; BaNaNa &quot;)
                .stream()
                .map(String::trim) // 去空格
                .map(String::toLowerCase) // 变小写
                .forEach(System.out::println); // 打印
    &#125;
&#125;</code></pre>
<blockquote>
<p>通过若干步map转换，可以写出逻辑简单、清晰的代码</p>
</blockquote>
<h4 id="filter过滤"><a class="markdownIt-Anchor" href="#filter过滤"></a> filter过滤</h4>
<p>Stream.filter()是Stream的另一个常用转换方法。</p>
<p>所谓filter()操作，就是对一个Stream的所有元素一一进行测试，不满足条件的就被“滤掉”了，剩下的满足条件的元素就构成了一个新的Stream。</p>
<p>例如，我们对1，2，3，4，5这个Stream调用filter()，传入的测试函数f(x) = x % 2 != 0用来判断元素是否是奇数，这样就过滤掉偶数，只剩下奇数，因此我们得到了另一个序列1，3，5：</p>
<p>用IntStream写出上述逻辑，代码如下：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        IntStream.of(1, 2, 3, 4, 5, 6, 7, 8, 9)
                .filter(n -&gt; n % 2 != 0)
                .forEach(System.out::println);
    &#125;
&#125;</code></pre>
<blockquote>
<p>从结果可知，经过filter()后生成的Stream元素可能变少。</p>
</blockquote>
<p>filter()方法接收的对象是Predicate接口对象，它定义了一个test()方法，负责判断元素是否符合条件：</p>
<pre><code class="highlight plaintext">@FunctionalInterface
public interface Predicate&lt;T&gt; &#123;
    // 判断元素t是否符合条件:
    boolean test(T t);
&#125;</code></pre>
<p>案例：</p>
<p>filter()除了常用于数值外，也可应用于任何Java对象。例如，从一组给定的LocalDate中过滤掉工作日，以便得到休息日：</p>
<pre><code class="highlight plaintext">import java.time.*;
import java.util.function.*;
import java.util.stream.*;

public class Main &#123;
    public static void main(String[] args) &#123;
        Stream.generate(new LocalDateSupplier())
                .limit(31)
                .filter(ldt -&gt; ldt.getDayOfWeek() == DayOfWeek.SATURDAY || ldt.getDayOfWeek() == DayOfWeek.SUNDAY)
                .forEach(System.out::println);
    &#125;
&#125;

class LocalDateSupplier implements Supplier&lt;LocalDate&gt; &#123;
    LocalDate start = LocalDate.of(2020, 1, 1);
    int n = -1;
    public LocalDate get() &#123;
        n++;
        return start.plusDays(n);
    &#125;
&#125;</code></pre>
<p>使用filter()过滤出成绩及格的同学，并打印出名字</p>
<pre><code class="highlight plaintext">public class FilterProblem &#123;
    public static void main(String[] args) &#123;
        List&lt;Person&gt; persons = Arrays.asList(
                new Person(&quot;小明&quot;, 88),
                new Person(&quot;小黑&quot;, 62),
                new Person(&quot;小白&quot;, 45),
                new Person(&quot;小黄&quot;, 78),
                new Person(&quot;小红&quot;, 99),
                new Person(&quot;小林&quot;, 58));
        persons.stream()
                .filter(p -&gt; p.score &gt;= 60)
                .forEach(p -&gt; System.out.println(p.name));
    &#125;
&#125;

class Person &#123;
    String name;
    int score;

    Person(String name, int score) &#123;
        this.name = name;
        this.score = score;
    &#125;
&#125;</code></pre>
<h4 id="reduce聚合"><a class="markdownIt-Anchor" href="#reduce聚合"></a> reduce聚合</h4>
<p>map()和filter()都是Stream的转换方法，而Stream.reduce()则是Stream的一个聚合方法，它可以把一个Stream的所有元素按照聚合函数聚合成一个结果</p>
<p>我们来看一个简单的聚合方法：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        int sum = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9).reduce(0, (acc, n) -&gt; acc + n);
        System.out.println(sum); // 45
    &#125;
&#125;</code></pre>
<p>reduce()方法传入的对象是BinaryOperator接口，它定义了一个apply()方法，负责把上次累加的结果和本次的元素 进行运算，并返回累加的结果：</p>
<pre><code class="highlight plaintext">@FunctionalInterfacepublic interface BinaryOperator&lt;T&gt; &#123;
    // Bi操作：两个输入，一个输出
    T apply(T t, T u);
&#125;</code></pre>
<p>上述代码看上去不好理解，但我们用for循环改写一下，就容易理解了：</p>
<pre><code class="highlight plaintext">Stream&lt;Integer&gt; stream = ...
int sum = 0;
for (n : stream) &#123;
    sum = (sum, n) -&gt; sum + n;
&#125;</code></pre>
<p>可见，reduce()操作首先初始化结果为指定值（这里是0），紧接着，reduce()对每个元素依次调用(acc, n) -&gt; acc + n，其中，acc是上次计算的结果：</p>
<pre><code class="highlight plaintext">// 计算过程:
acc = 0 // 初始化为指定值
acc = acc + n = 0 + 1 = 1 // n = 1
acc = acc + n = 1 + 2 = 3 // n = 2
acc = acc + n = 3 + 3 = 6 // n = 3
acc = acc + n = 6 + 4 = 10 // n = 4
acc = acc + n = 10 + 5 = 15 // n = 5
acc = acc + n = 15 + 6 = 21 // n = 6
acc = acc + n = 21 + 7 = 28 // n = 7
acc = acc + n = 28 + 8 = 36 // n = 8
acc = acc + n = 36 + 9 = 45 // n = 9</code></pre>
<p>因此，实际上这个reduce()操作是一个求和.</p>
<p>如果去掉初始值，我们会得到一个Optional<Integer>：</p>
<pre><code class="highlight plaintext">Optional&lt;Integer&gt; opt = stream.reduce((acc, n) -&gt; acc + n);
if (opt.isPresent) &#123;
    System.out.println(opt.get());
&#125;</code></pre>
<p>这是因为Stream的元素有可能是0个，这样就没法调用reduce()的聚合函数了，因此返回Optional对象，需要进一步判断结果是否存在。</p>
<p>利用reduce()，我们可以把求和改成求积，代码也十分简单：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        int s = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9).reduce(1, (acc, n) -&gt; acc * n);
        System.out.println(s); // 362880
    &#125;
&#125;</code></pre>
<p>注意：计算求积时，初始值必须设置为1。</p>
<p>除了可以对数值进行累积计算外，灵活运用reduce()也可以对Java对象进行操作。下面的代码演示了如何将配置文件的每一行配置通过map()和reduce()操作聚合成一个Map&lt;String, String&gt;：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        // 按行读取配置文件:
        List&lt;String&gt; props = List.of(&quot;profile=native&quot;, &quot;debug=true&quot;, &quot;logging=warn&quot;, &quot;interval=500&quot;);
        Map&lt;String, String&gt; map = props.stream()
                // 把k=v转换为Map[k]=v:
                .map(kv -&gt; &#123;
                    String[] ss = kv.split(&quot;\\=&quot;, 2);
                    return Map.of(ss[0], ss[1]);
                &#125;)
                // 把所有Map聚合到一个Map:
                .reduce(new HashMap&lt;String, String&gt;(), (m, kv) -&gt; &#123;
                    m.putAll(kv);
                    return m;
                &#125;);
        // 打印结果:
        map.forEach((k, v) -&gt; &#123;
            System.out.println(k + &quot; = &quot; + v);
        &#125;);
    &#125;
&#125;
</code></pre>
<h4 id="输出集合"><a class="markdownIt-Anchor" href="#输出集合"></a> 输出集合</h4>
<p>我们介绍了Stream的几个常见操作：map()、filter()、reduce()。这些操作对Stream来说可以分为<strong>两类</strong></p>
<ul>
<li>一类是<strong>转换操作</strong>，即把一个Stream转换为另一个Stream，例如map()和filter()，</li>
<li>一类是<strong>聚合操作</strong>，即对Stream的每个元素进行计算，得到一个确定的结果，例如reduce()</li>
</ul>
<p>区分这两种操作是非常重要的，因为对于Stream来说，对其进行转换操作并不会触发任何计算！我们可以做个实验：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args)     &#123;
        Stream&lt;Long&gt; s1 = Stream.generate(new NatualSupplier());
        Stream&lt;Long&gt; s2 = s1.map(n -&gt; n * n);
        Stream&lt;Long&gt; s3 = s2.map(n -&gt; n - 1);
        System.out.println(s3); // java.util.stream.ReferencePipeline$3@49476842
    &#125;
&#125;

class NatualSupplier implements Supplier&lt;Long&gt; &#123;
    long n = 0;
    public Long get() &#123;
        n++;
        return n;
    &#125;
&#125;</code></pre>
<p>因为s1是一个Long类型的序列，它的元素高达922亿个，但执行上述代码，既不会有任何内存增长，也不会有任何计算，因为转换操作只是保存了转换规则，无论我们对一个Stream转换多少次，都不会有任何实际计算发生</p>
<p>而聚合操作则不一样，聚合操作会立刻促使Stream输出它的每一个元素，并依次纳入计算，以获得最终结果。所以，对一个Stream进行聚合操作，会触发一系列连锁反应：</p>
<pre><code class="highlight plaintext">Stream&lt;Long&gt; s1 = Stream.generate(new NatualSupplier());
Stream&lt;Long&gt; s2 = s1.map(n -&gt; n * n);
Stream&lt;Long&gt; s3 = s2.map(n -&gt; n - 1);
Stream&lt;Long&gt; s4 = s3.limit(10);
s4.reduce(0, (acc, n) -&gt; acc + n);</code></pre>
<p>我们对s4进行reduce()聚合计算，会不断请求s4输出它的每一个元素。因为s4的上游是s3，它又会向s3请求元素，导致s3向s2请求元素，s2向s1请求元素，最终，s1从Supplier实例中请求到真正的元素，并经过一系列转换，最终被reduce()聚合出结果。</p>
<p>可见，聚合操作是真正需要从Stream请求数据的，对一个<strong>Stream做聚合计算后，结果就不是一个Stream，而是一个其他的Java对象</strong>。</p>
<h5 id="输出为list"><a class="markdownIt-Anchor" href="#输出为list"></a> <strong>输出为List</strong></h5>
<p>reduce()只是一种聚合操作，如果我们希望把Stream的元素保存到集合，例如List，因为List的元素是确定的Java对象，因此，把Stream变为List不是一个转换操作，而是一个聚合操作，它会强制Stream输出每个元素。</p>
<p>下面的代码演示了如何将一组String先过滤掉空字符串，然后把非空字符串保存到List中：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Stream&lt;String&gt; stream = Stream.of(&quot;Apple&quot;, &quot;&quot;, null, &quot;Pear&quot;, &quot;  &quot;, &quot;Orange&quot;);
        List&lt;String&gt; list = stream.filter(s -&gt; s != null &amp;&amp; !s.isBlank()).collect(Collectors.toList());
        System.out.println(list);
    &#125;
&#125;</code></pre>
<p>把Stream的每个元素收集到List的方法是调用collect()并传入Collectors.toList()对象，它实际上是一个Collector实例，通过类似reduce()的操作，把每个元素添加到一个收集器中（实际上是ArrayList）</p>
<p>类似的，collect(Collectors.toSet())可以把Stream的每个元素收集到Set中</p>
<h5 id="输出为数组"><a class="markdownIt-Anchor" href="#输出为数组"></a> <strong>输出为数组</strong></h5>
<p>把Stream的元素输出为数组和输出为List类似，我们只需要调用toArray()方法，并传入数组的“构造方法”：</p>
<pre><code class="highlight plaintext">List&lt;String&gt; list = List.of(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;);
String[] array = list.stream().toArray(String[]::new);</code></pre>
<p>注意到传入的“构造方法”是String[]::new，它的签名实际上是IntFunction&lt;String[]&gt;定义的String[] apply(int)，即传入int参数，获得String[]数组的返回值。</p>
<p>注意到传入的“构造方法”是String[]::new，它的签名实际上是IntFunction&lt;String[]&gt;定义的String[] apply(int)，即传入int参数，获得String[]数组的返回值。</p>
<h5 id="输出为map"><a class="markdownIt-Anchor" href="#输出为map"></a> <strong>输出为Map</strong></h5>
<p>如果我们要把Stream的元素收集到Map中，就稍微麻烦一点。因为对于每个元素，添加到Map时需要key和value，因此，我们要指定两个映射函数，分别把元素映射为key和value：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Stream&lt;String&gt; stream = Stream.of(&quot;APPL:Apple&quot;, &quot;MSFT:Microsoft&quot;);
        Map&lt;String, String&gt; map = stream
                .collect(Collectors.toMap(
                        // 把元素s映射为key:
                        s -&gt; s.substring(0, s.indexOf(&#x27;:&#x27;)),
                        // 把元素s映射为value:
                        s -&gt; s.substring(s.indexOf(&#x27;:&#x27;) + 1)));
        System.out.println(map);
    &#125;
&#125;</code></pre>
<p>指定key-value，value是对象中的某个属性值。</p>
<pre><code class="highlight plaintext">Map&lt;Integer,String&gt; userMap1 = userList.stream().collect(Collectors.toMap(User::getId,User::getName));</code></pre>
<p>指定key-value，value是对象本身，User-&gt;User 是一个返回本身的lambda表达式</p>
<pre><code class="highlight plaintext">Map&lt;Integer,User&gt; userMap2 = userList.stream().collect(Collectors.toMap(User::getId,User-&gt;User));</code></pre>
<p>指定key-value，value是对象本身，Function.identity()是简洁写法，也是返回对象本身</p>
<pre><code class="highlight plaintext">Map&lt;Integer,User&gt; userMap3 = userList.stream().collect(Collectors.toMap(User::getId, Function.identity()));</code></pre>
<p>指定key-value，value是对象本身，Function.identity()是简洁写法，也是返回对象本身，key 冲突的解决办法，这里选择第二个key覆盖第一个key。</p>
<pre><code class="highlight plaintext">Map&lt;Integer,User&gt; userMap4 = userList.stream().collect(Collectors.toMap(User::getId, Function.identity(),(key1,key2)-&gt;key2));</code></pre>
<p>拼接key</p>
<pre><code class="highlight plaintext">Map&lt;String, Parts&gt; partsMap = synList.stream().collect(Collectors.toMap(k -&gt; k.getOe()+k.getOeId()+k.getPartGroupId()+k.getStdPartId()+k.getBrandCode(), part -&gt; part));</code></pre>
<h5 id="分组输出"><a class="markdownIt-Anchor" href="#分组输出"></a> <strong>分组输出</strong></h5>
<p>Stream还有一个强大的分组功能，可以按组输出。我们看下面的例子：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        List&lt;String&gt; list = List.of(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Blackberry&quot;, &quot;Coconut&quot;, &quot;Avocado&quot;, &quot;Cherry&quot;, &quot;Apricots&quot;);
        Map&lt;String, List&lt;String&gt;&gt; groups = list.stream()
                .collect(Collectors.groupingBy(s -&gt; s.substring(0, 1), Collectors.toList()));
        System.out.println(groups);
    &#125;
&#125;</code></pre>
<p>分组输出使用Collectors.groupingBy()，它需要提供两个函数：一个是分组的key，这里使用s -&gt; s.substring(0, 1)，表示只要首字母相同的String分到一组，第二个是分组的value，这里直接使用Collectors.toList()，表示输出为List，上述代码运行结果如下：</p>
<pre><code class="highlight plaintext">&#123;
    A=[Apple, Avocado, Apricots],
    B=[Banana, Blackberry],
    C=[Coconut, Cherry]
&#125;</code></pre>
<p>假设有这样一个Student类，包含学生姓名、班级和成绩：</p>
<pre><code class="highlight plaintext">class Student &#123;
    int gradeId; // 年级
    int classId; // 班级
    String name; // 名字
    int score; // 分数
&#125;</code></pre>
<p>如果我们有一个Stream<Student>，利用分组输出，可以非常简单地按年级或班级把Student归类。</p>
<h4 id="其他操作"><a class="markdownIt-Anchor" href="#其他操作"></a> 其他操作</h4>
<p>我们把Stream提供的操作分为两类：转换操作和聚合操作。除了前面介绍的常用操作外，Stream还提供了一系列非常有用的方法。</p>
<hr />
<h5 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> <strong>排序</strong></h5>
<p>对Stream的元素进行排序十分简单，只需调用sorted()方法：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        List&lt;String&gt; list = List.of(&quot;Orange&quot;, &quot;apple&quot;, &quot;Banana&quot;)
            .stream()
            .sorted()
            .collect(Collectors.toList());
        System.out.println(list);
    &#125;
&#125;</code></pre>
<p>此方法要求Stream的每个元素必须实现Comparable接口。如果要自定义排序，传入指定的Comparator即可：</p>
<pre><code class="highlight plaintext">List&lt;String&gt; list = List.of(&quot;Orange&quot;, &quot;apple&quot;, &quot;Banana&quot;)
    .stream()
    .sorted(String::compareToIgnoreCase)
    .collect(Collectors.toList());</code></pre>
<p>注意sorted()只是一个转换操作，它会返回一个新的Stream。</p>
<p><strong>指定输出的List</strong></p>
<pre><code class="highlight plaintext">stream().xxx.collect(Collectors.toCollection(LinkedList::new))</code></pre>
<p><strong>几种排序的方式</strong></p>
<p>sorted()：自然排序，流中元素需实现Comparable接口</p>
<pre><code class="highlight plaintext">package com.entity;
 
import lombok.*;
 
@Data
@ToString
@AllArgsConstructor
@NoArgsConstructor
public class Student implements Comparable&lt;Student&gt; &#123;
    private int id;
    private String name;
    private int age;
    @Override
    public int compareTo(Student ob) &#123;
        return name.compareTo(ob.getName());
    &#125;
    @Override
    public boolean equals(final Object obj) &#123;
        if (obj == null) &#123;
            return false;
        &#125;
        final Student std = (Student) obj;
        if (this == std) &#123;
            return true;
        &#125; else &#123;
            return (this.name.equals(std.name) &amp;&amp; (this.age == std.age));
        &#125;
    &#125;
    @Override
    public int hashCode() &#123;
        int hashno = 7;
        hashno = 13 * hashno + (name == null ? 0 : name.hashCode());
        return hashno;
    &#125;   
&#125;</code></pre>
<p>自然排序（升序）：</p>
<pre><code class="highlight plaintext">list = list.stream().sorted().collect(Collectors.toList());</code></pre>
<p>根据年龄排序（升序）：</p>
<pre><code class="highlight plaintext">list = list.stream().sorted(Comparator.comparing(Student::getAge)).collect(Collectors.toList());</code></pre>
<p>自然排序（降序）：</p>
<pre><code class="highlight plaintext">list = list.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());</code></pre>
<p>根据年龄排序（降序）：</p>
<pre><code class="highlight plaintext">list = list.stream().sorted(Comparator.comparing(Student::getAge).reversed()).collect(Collectors.toList());</code></pre>
<p>多字段排序：</p>
<pre><code class="highlight plaintext">list = list.sorted(Comparator.comparing(Student::getName).thenComparing(Student::getAge)).collect(Collectors.toList());</code></pre>
<hr />
<h5 id="去重"><a class="markdownIt-Anchor" href="#去重"></a> <strong>去重</strong></h5>
<p>对一个Stream的元素进行去重，没必要先转换为Set，可以直接用distinct()：</p>
<pre><code class="highlight plaintext">List.of(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;C&quot;, &quot;B&quot;, &quot;D&quot;)
    .stream()
    .distinct()
    .collect(Collectors.toList()); // [A, B, C, D]</code></pre>
<p>条件去重</p>
<pre><code class="highlight plaintext">ArrayList&lt;SdmExtractColumn&gt; collectDistinct = 
sdmExtractColumnList.stream().collect(Collectors.collectingAndThen(        Collectors.toCollection(() -&gt; new 
TreeSet&lt;&gt;(Comparator.comparing(SdmExtractColumn::getTableownerSrc).thenComparing(SdmExtractColumn::getTablenameSrc))), ArrayList::new));</code></pre>
<hr />
<h5 id="截取"><a class="markdownIt-Anchor" href="#截取"></a> <strong>截取</strong></h5>
<p>截取操作常用于把一个无限的Stream转换成有限的Stream，skip()用于跳过当前Stream的前N个元素，limit()用于截取当前Stream最多前N个元素：</p>
<pre><code class="highlight plaintext">List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;)
    .stream()
    .skip(2) // 跳过A, B
    .limit(3) // 截取C, D, E
    .collect(Collectors.toList()); // [C, D, E]</code></pre>
<p>截取操作也是一个转换操作，将返回新的Stream。</p>
<hr />
<h5 id="合并"><a class="markdownIt-Anchor" href="#合并"></a> <strong>合并</strong></h5>
<p>将两个Stream合并为一个Stream可以使用Stream的静态方法concat()</p>
<pre><code class="highlight plaintext">Stream&lt;String&gt; s1 = List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;).stream();
Stream&lt;String&gt; s2 = List.of(&quot;D&quot;, &quot;E&quot;).stream();
// 合并:
Stream&lt;String&gt; s = Stream.concat(s1, s2);
System.out.println(s.collect(Collectors.toList())); // [A, B, C, D, E]</code></pre>
<hr />
<h5 id="flatmap"><a class="markdownIt-Anchor" href="#flatmap"></a> <strong>flatMap</strong></h5>
<p>如果Stream的元素集合：</p>
<pre><code class="highlight plaintext">Stream&lt;List&lt;Integer&gt;&gt; s = Stream.of(
        Arrays.asList(1, 2, 3),
        Arrays.asList(4, 5, 6),
        Arrays.asList(7, 8, 9));</code></pre>
<p>而我们希望把上述Stream转换为Stream<Integer>，就可以使用flatMap()：</p>
<pre><code class="highlight plaintext">Stream&lt;Integer&gt; i = s.flatMap(list -&gt; list.stream());</code></pre>
<p>因此，所谓flatMap()，是指把Stream的每个元素（这里是List）映射为Stream，然后合并成一个新的Stream：</p>
<hr />
<h5 id="并行"><a class="markdownIt-Anchor" href="#并行"></a> <strong>并行</strong></h5>
<p>通常情况下，对Stream的元素进行处理是单线程的，即一个一个元素进行处理。但是很多时候，我们希望可以并行处理Stream的元素，因为在元素数量非常大的情况，并行处理可以大大加快处理速度。</p>
<p>把一个普通Stream转换为可以并行处理的Stream非常简单，只需要用parallel()进行转换：</p>
<pre><code class="highlight plaintext">
Stream&lt;String&gt; s = ...
String[] result = s.parallel() // 变成一个可以并行处理的Stream
                   .sorted() // 可以进行并行排序
                   .toArray(String[]::new);</code></pre>
<blockquote>
<p>经过parallel()转换后的Stream只要可能，就会对后续操作进行并行处理。我们不需要编写任何多线程代码就可以享受到并行处理带来的执行效率的提升</p>
</blockquote>
<hr />
<h5 id="其他聚合方法"><a class="markdownIt-Anchor" href="#其他聚合方法"></a> <strong>其他聚合方法</strong></h5>
<p>除了reduce()和collect()外，Stream还有一些常用的聚合方法：</p>
<ul>
<li>count()：用于返回元素个数；</li>
<li>max(Comparator&lt;? super T&gt; cp)：找出最大元素；</li>
<li>min(Comparator&lt;? super T&gt; cp)：找出最小元素。</li>
</ul>
<p>针对IntStream、LongStream和DoubleStream，还额外提供了以下聚合方法：</p>
<ul>
<li>sum()：对所有元素求和；</li>
<li>average()：对所有元素求平均数。</li>
</ul>
<p>还有一些方法，用来测试Stream的元素是否满足以下条件：</p>
<ul>
<li>boolean allMatch(Predicate&lt;? super T&gt;)：测试是否所有元素均满足测试条件；</li>
<li>boolean anyMatch(Predicate&lt;? super T&gt;)：测试是否至少有一个元素满足测试条件。</li>
</ul>
<p>最后一个常用的方法是forEach()，它可以循环处理Stream的每个元素，我们经常传入System.out::println来打印Stream的元素</p>
<pre><code class="highlight plaintext">：Stream&lt;String&gt; s = ...
s.forEach(str -&gt; &#123;
    System.out.println(&quot;Hello, &quot; + str);
&#125;);</code></pre>
</main>

</article>


<script src="/js/highlight.js"></script>

  </main>
  <footer class="footer">
  
  <span>Copyright © 2026 Lism Blog | lisisism@qq.com</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>