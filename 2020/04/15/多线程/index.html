<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    Java多线程 丨
    

    Lism Blog
  </title>

  
  <link rel="shortcut icon" href="/icon.svg">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="/Lism Blog" type="application/atom+xml">
</head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">/Lism Blog</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <article class="post">
  
  <div class="post-title">Java多线程</div>
  <div class="post-meta">
    <div class="date">2020 四月 15日</div>
    <div class="tags">
      
      <div class="tag-item">Java</div>
      
      <div class="tag-item">并发</div>
      
    </div>
  </div>
  

  <main class="post-content"><h1 id="多线程"><a class="markdownIt-Anchor" href="#多线程"></a> $多线程</h1>
<h1 id="多线程-2"><a class="markdownIt-Anchor" href="#多线程-2"></a> 多线程</h1>
<ul>
<li><a href="">多线程</a>
<ul>
<li><a href="">概述</a>
<ul>
<li><a href="">多线程的优点</a></li>
<li><a href="">多线程的代价</a></li>
<li><a href="">多线程基础</a></li>
</ul>
</li>
<li><a href="">并发编程模型</a>
<ul>
<li><a href="">并发模式与分布式系统的相似性</a></li>
<li><a href="">并行工作�</a>�</li>
<li><a href="">流水线模式</a></li>
<li><a href="">函数式并行（Functional Parallelism）</a></li>
</ul>
</li>
<li><a href="">创建Java线程</a>
<ul>
<li><a href="">创建Thread子类</a></li>
<li><a href="">实现Runnable接口</a></li>
<li><a href="">实现Callable接口</a></li>
<li><a href="">其他</a></li>
<li><a href="">Future</a>
<ul>
<li><a href="">java方法执行超时关闭</a></li>
</ul>
</li>
<li><a href="">CompletableFuture</a></li>
<li><a href="">ForkJoin</a></li>
<li><a href="">线程的状态</a></li>
<li><a href="">中断线程</a></li>
<li><a href="">守护线程</a></li>
</ul>
</li>
<li><a href="">多线程安全</a>
<ul>
<li><a href="">竞态条件与临界区</a></li>
<li><a href="">共享资源</a></li>
<li><a href="">不可变性</a></li>
</ul>
</li>
<li><a href="">Java内存模型</a>
<ul>
<li><a href="">Java内存模型内部原理</a></li>
<li><a href="">硬件内存架构</a></li>
<li><a href="">Java内存模型和硬件内存架构之间的桥接</a></li>
</ul>
</li>
<li><a href="">Java synchronized</a>
<ul>
<li><a href="">线程同步</a>
<ul>
<li><a href="">不需要synchronized的操作</a></li>
</ul>
</li>
<li><a href="">Java同步关键字</a></li>
<li><a href="">方法同步</a>
<ul>
<li><a href="">实例方法同步</a></li>
<li><a href="">静态方法同步</a></li>
</ul>
</li>
<li><a href="">块同步</a>
<ul>
<li><a href="">实例方法中同步块</a></li>
<li><a href="">静态方法中同步块</a></li>
</ul>
</li>
<li><a href="">Java同步示例</a></li>
</ul>
</li>
<li><a href="">线程通信</a>
<ul>
<li><a href="">通过共享对象通信</a></li>
<li><a href="">忙等待(Busy Wait)</a></li>
<li><a href="">使用wait和notify</a></li>
<li><a href="">wait()/notify()/notifyAll()</a>
<ul>
<li><a href="">丢失的信号</a></li>
<li><a href="">假唤醒</a></li>
</ul>
</li>
<li><a href="">多线程等待相同信号</a></li>
<li><a href="">信号量</a>
<ul>
<li><a href="">简单的Semaphore实现</a></li>
<li><a href="">使用Semaphore来发送信号</a></li>
<li><a href="">可计数的Semaphore</a></li>
<li><a href="">有上限的Semaphore</a></li>
<li><a href="">把Semaphore当锁来用</a></li>
</ul>
</li>
<li><a href="">不要对常量字符串或者全局对象调用wait()</a></li>
</ul>
</li>
<li><a href="">死锁</a>
<ul>
<li><a href="">死锁的产生</a></li>
<li><a href="">避免死锁</a>
<ul>
<li><a href="">加锁顺序</a></li>
<li><a href="">加锁时限</a></li>
<li><a href="">死锁检测</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="">饥饿与公平</a>
<ul>
<li><a href="">Lock</a></li>
<li><a href="">公平锁FairLock</a></li>
<li><a href="">性能考虑</a></li>
</ul>
</li>
<li><a href="">嵌套管程锁死</a>
<ul>
<li><a href="">嵌套管程锁死VS死锁</a></li>
</ul>
</li>
<li><a href="">Slipped Conditions</a></li>
<li><a href="">Java Lock</a>
<ul>
<li><a href="">Lock</a>
<ul>
<li><a href="">一个简单的锁</a></li>
<li><a href="">锁的可重入性</a></li>
<li><a href="">锁的公平性</a></li>
<li><a href="">在finally语句中调用unlock()</a></li>
</ul>
</li>
<li><a href="">Java ReentrantLock</a>
<ul>
<li><a href="">使用Condition</a></li>
</ul>
</li>
<li><a href="">Java ReadWriteLock</a>
<ul>
<li><a href="">使用ReadWriteLock</a></li>
<li><a href="">读/写锁的Java实现</a></li>
<li><a href="">读/写锁的重入</a>
<ul>
<li><a href="">读锁重入</a></li>
<li><a href="">写锁重入</a></li>
<li><a href="">读锁升级到写锁</a></li>
<li><a href="">写锁降级到读写锁</a></li>
</ul>
</li>
<li><a href="">可重入的ReadWriteLock的完整实现</a></li>
<li><a href="">在finally中调用unlock</a></li>
</ul>
</li>
<li><a href="">Java StampedLock</a></li>
<li><a href="">Concurrent集合</a></li>
<li><a href="">Atomic</a></li>
<li><a href="">Java ThreadLocal</a></li>
</ul>
</li>
<li><a href="">重入锁死</a></li>
<li><a href="">阻塞队列BlockingQueue</a>
<ul>
<li><a href="">阻塞队列的实现</a></li>
</ul>
</li>
<li><a href="">线程�</a>�
<ul>
<li><a href="">ThreadPoolExecutor</a>
<ul>
<li><a href="">线程池使用</a></li>
<li><a href="">线程池的关闭</a></li>
<li><a href="">线程池的分析</a></li>
<li><a href="">合理的配置线程�</a>�</li>
<li><a href="">线程池的监控</a></li>
</ul>
</li>
<li><a href="">Executors</a>
<ul>
<li><a href="">Executors的简单使用</a></li>
<li><a href="">使用Executors的风险</a></li>
</ul>
</li>
<li><a href="">线程池实现原理</a></li>
</ul>
</li>
<li><a href="">CAS</a>
<ul>
<li><a href="">CAS的使用场景</a></li>
<li><a href="">CAS用作原子操作</a></li>
</ul>
</li>
<li><a href="">刨析同步器</a></li>
<li><a href="">非阻塞算法</a>
<ul>
<li><a href="">阻塞并发算法</a></li>
<li><a href="">非阻塞并发算法</a></li>
<li><a href="">非阻塞算法VS阻塞算法</a></li>
<li><a href="">非阻塞并发数据结构</a></li>
<li><a href="">Volatile 变量</a></li>
<li><a href="">单个写线程的情景</a></li>
<li><a href="">基于volatile变量更高级的数据结构</a></li>
<li><a href="">使用CAS的乐观锁</a></li>
<li><a href="">不可替换的数据结构</a></li>
<li><a href="">使用非阻塞算法的好处</a></li>
</ul>
</li>
<li><a href="">悲观/乐观锁</a>
<ul>
<li><a href="">乐观锁</a>
<ul>
<li><a href="">乐观锁的两种实现方式</a>
<ul>
<li><a href="">版本号机制</a></li>
<li><a href="">CAS算法</a></li>
</ul>
</li>
<li><a href="">乐观锁的缺点</a></li>
</ul>
</li>
<li><a href="">悲观锁</a>
<ul>
<li><a href="">悲观锁的实现</a></li>
</ul>
</li>
<li><a href="">两种锁的使用场景</a></li>
<li><a href="">CAS于synchronized的使用情景</a></li>
</ul>
</li>
<li><a href="">哪个对象才是锁</a>
<ul>
<li><a href="">静态同步方法问题</a></li>
<li><a href="">实例同步方法问题</a></li>
<li><a href="">解答</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p>在过去单CPU时代，单任务在一个时间点只能执行单一程序。之后发展到多任务阶段，计算机能在同一时间点并行执行多任务或多进程。虽然<strong>并不是真正意义上的“同一时间点”，而是多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换</strong>，以使得每个任务都有机会获得一定的时间片运行。</p>
<p>随着多任务对软件开发者带来的新挑战，程序不在能假设独占所有的CPU时间、所有的内存和其他计算机资源。一个好的程序榜样是在其不再使用这些资源时对其进行释放，以使得其他程序能有机会使用这些资源。</p>
<p>再后来发展到多线程技术，使得在一个程序内部能拥有多个线程并行执行。一个线程的执行可以被认为是一个CPU在执行该程序。当一个程序运行在多线程下，就好像有多个CPU在同时执行该程序。</p>
<p>多线程比多任务更加有挑战。多线程是在同一个程序内部并行执行，因此会对相同的内存空间进行并发读写操作。这可能是在单线程程序中从来不会遇到的问题。其中的一些错误也未必会在单CPU机器上出现，因为两个线程从来不会得到真正的并行执行。然而，更现代的计算机伴随着多核CPU的出现，也就意味着不同的线程能被不同的CPU核得到真正意义的并行执行。</p>
<p>多线程比多任务更加有挑战。多线程是在同一个程序内部并行执行，因此会对相同的内存空间进行并发读写操作。这可能是在单线程程序中从来不会遇到的问题。其中的一些错误也未必会在单CPU机器上出现，因为两个线程从来不会得到真正的并行执行。然而，更现代的计算机伴随着多核CPU的出现，也就意味着不同的线程能被不同的CPU核得到真正意义的并行执行。</p>
<h3 id="多线程的优点"><a class="markdownIt-Anchor" href="#多线程的优点"></a> 多线程的优点</h3>
<p>尽管面临很多挑战，多线程有一些优点使得它一直被使用。这些优点是：</p>
<ul>
<li>资源利用率更好</li>
<li>程序设计在某些情况下更简单</li>
<li>程序响应更快</li>
</ul>
<hr />
<p><strong>资源利用率更好</strong></p>
<p>想象一下，一个应用程序需要从本地文件系统中读取和处理文件的情景。比方说，从磁盘读取一个文件需要5秒，处理一个文件需要2秒。处理两个文件则需要：</p>
<pre><code class="highlight plaintext">5秒读取文件A
2秒处理文件A
5秒读取文件B
2秒处理文件B
---------------------
总共需要14秒</code></pre>
<p>从磁盘中读取文件的时候，大部分的CPU时间用于等待磁盘去读取数据。在这段时间里，CPU非常的空闲。它可以做一些别的事情。通过改变操作的顺序，就能够更好的使用CPU资源。看下面的顺序：</p>
<pre><code class="highlight plaintext">5秒读取文件A
5秒读取文件B + 2秒处理文件A
2秒处理文件B
---------------------
总共需要12秒</code></pre>
<p>CPU等待第一个文件被读取完。然后开始读取第二个文件。当第二文件在被读取的时候，CPU会去处理第一个文件。记住，在等待磁盘读取文件的时候，CPU大部分时间是空闲的。</p>
<p>总的说来，CPU能够在等待IO的时候做一些其他的事情。这个不一定就是磁盘IO。它也可以是网络的IO，或者用户输入。通常情况下，网络和磁盘的IO比CPU和内存的IO慢的多。</p>
<hr />
<p><strong>程序设计更简单</strong></p>
<p>在单线程应用程序中，如果你想编写程序手动处理上面所提到的读取和处理的顺序，你必须记录每个文件读取和处理的状态。相反，你可以启动两个线程，每个线程处理一个文件的读取和操作。线程会在等待磁盘读取文件的过程中被阻塞。在等待的时候，其他的线程能够使用CPU去处理已经读取完的文件。其结果就是，磁盘总是在繁忙地读取不同的文件到内存中。这会带来磁盘和CPU利用率的提升。而且每个线程只需要记录一个文件，因此这种方式也很容易编程实现。</p>
<hr />
<p><strong>程序响应更快</strong></p>
<p>将一个单线程应用程序变成多线程应用程序的另一个常见的目的是实现一个响应更快的应用程序。设想一个服务器应用，它在某一个端口监听进来的请求。当一个请求到来时，它去处理这个请求，然后再返回去监听。</p>
<pre><code class="highlight plaintext">while(server is active)&#123;
    listen for request
    process request
&#125;</code></pre>
<p>如果一个请求需要占用大量的时间来处理，在这段时间内新的客户端就无法发送请求给服务端。只有服务器在监听的时候，请求才能被接收。另一种设计是，监听线程把请求传递给工作者线程(worker thread)，然后立刻返回去监听。而工作者线程则能够处理这个请求并发送一个回复给客户端。这种设计如下所述：</p>
<pre><code class="highlight plaintext">while(server is active)&#123;
    listen for request
    hand request to worker thread
&#125;</code></pre>
<p>这种方式，服务端线程迅速地返回去监听。因此，更多的客户端能够发送请求给服务端。这个服务也变得响应更快。</p>
<p>桌面应用也是同样如此。如果你点击一个按钮开始运行一个耗时的任务，这个线程既要执行任务又要更新窗口和按钮，那么在任务执行的过程中，这个应用程序看起来好像没有反应一样。相反，任务可以传递给工作者线程（word thread)。当工作者线程在繁忙地处理任务的时候，窗口线程可以自由地响应其他用户的请求。当工作者线程完成任务的时候，它发送信号给窗口线程。窗口线程便可以更新应用程序窗口，并显示任务的结果。对用户而言，这种具有工作者线程设计的程序显得响应速度更快。</p>
<h3 id="多线程的代价"><a class="markdownIt-Anchor" href="#多线程的代价"></a> 多线程的代价</h3>
<p>从一个单线程的应用到一个多线程的应用并不仅仅带来好处，它也会有一些代价。不要仅仅为了使用多线程而使用多线程。而应该明确在使用多线程时能多来的好处比所付出的代价大的时候，才使用多线程。如果存在疑问，应该尝试测量一下应用程序的性能和响应能力，而不只是猜测。</p>
<p><strong>设计更复杂</strong></p>
<p>虽然有一些多线程应用程序比单线程的应用程序要简单，但其他的一般都更复杂。在多线程访问共享数据的时候，这部分代码需要特别的注意。线程之间的交互往往非常复杂。不正确的线程同步产生的错误非常难以被发现，并且重现以修复。</p>
<p><strong>上下文切换开销</strong></p>
<p>当CPU从执行一个线程切换到执行另外一个线程的时候，它需要先存储当前线程的本地的数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后才开始执行。这种切换称为“上下文切换”(“context switch”)。CPU会在一个上下文中执行一个线程，然后切换到另外一个上下文中执行另外一个线程。</p>
<p>上下文切换并不廉价。如果没有必要，应该减少上下文切换的发生</p>
<p><strong>增加资源消耗</strong></p>
<p>线程在运行的时候需要从计算机里面得到一些资源。除了CPU，线程还需要一些内存来维持它本地的堆栈。它也需要占用操作系统中一些资源来管理线程。我们可以尝试编写一个程序，让它创建100个线程，这些线程什么事情都不做，只是在等待，然后看看这个程序在运行的时候占用了多少内存。</p>
<h3 id="多线程基础"><a class="markdownIt-Anchor" href="#多线程基础"></a> 多线程基础</h3>
<p><strong>进程</strong></p>
<p>在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。</p>
<p>某些进程内部还需要同时执行多个子任务。例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。</p>
<p>操作系统调度的最小任务单位其实不是进程，而是线程。常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。因为同一个应用程序，既可以有多个进程，也可以有多个线程，因此，实现多任务的方法，有以下几种：多进程模式（每个进程只有一个线程）：</p>
<p>多线程模式（一个进程有多个线程）：</p>
<p>多进程＋多线程模式（复杂度最高）：</p>
<p><strong>进程 vs 线程</strong></p>
<p>进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。</p>
<p>具体采用哪种方式，要考虑到进程和线程的特点。</p>
<p>和多线程相比，多进程的缺点在于：</p>
<ul>
<li>创建进程比创建线程开销大，尤其是在Windows系统上；</li>
<li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</li>
</ul>
<p>而多进程的优点在于：</p>
<ul>
<li>多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</li>
</ul>
<p><strong>多线程</strong></p>
<p>Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行main()方法，在main()方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p>
<p>因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。</p>
<p>和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。</p>
<p>Java多线程编程的特点又在于：</p>
<ul>
<li>多线程模型是Java程序最基本的并发模型；</li>
<li>后续读写网络、数据库、Web开发等都依赖Java多线程模型。</li>
</ul>
<p>因此，必须掌握Java多线程编程才能继续深入学习其他内容。</p>
<h2 id="并发编程模型"><a class="markdownIt-Anchor" href="#并发编程模型"></a> 并发编程模型</h2>
<p>并发系统可以采用多种并发编程模型来实现。并发模型指定了系统中的线程如何通过协作来完成分配给它们的作业。不同的并发模型采用不同的方式拆分作业，同时线程间的协作和交互方式也不相同。这篇并发模型教程将会较深入地介绍目前（2015年）比较流行的几种并发模型。</p>
<h3 id="并发模式与分布式系统的相似性"><a class="markdownIt-Anchor" href="#并发模式与分布式系统的相似性"></a> 并发模式与分布式系统的相似性</h3>
<p>本文所描述的并发模型类似于分布式系统中使用的很多体系结构。在并发系统中线程之间可以相互通信。在分布式系统中进程之间也可以相互通信（进程有可能在不同的机器中）。线程和进程之间具有很多相似的特性。这也就是为什么很多并发模型通常类似于各种分布式系统架构。</p>
<p>当然，分布式系统在处理网络失效、远程主机或进程宕掉等方面也面临着额外的挑战。但是运行在巨型服务器上的并发系统也可能遇到类似的问题，比如一块CPU失效、一块网卡失效或一个磁盘损坏等情况。虽然出现失效的概率可能很低，但是在理论上仍然有可能发生。</p>
<p>由于并发模型类似于分布式系统架构，因此它们通常可以互相借鉴思想。例如，为工作者们（线程）分配作业的模型一般与分布式系统中的负载均衡系统比较相似。同样，它们在日志记录、失效转移、幂等性等错误处理技术上也具有相似性。</p>
<blockquote>
<p>【注：幂等性，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同】</p>
</blockquote>
<h3 id="并行工作者"><a class="markdownIt-Anchor" href="#并行工作者"></a> 并行工作者</h3>
<h3 id="流水线模式"><a class="markdownIt-Anchor" href="#流水线模式"></a> 流水线模式</h3>
<h3 id="函数式并行functional-parallelism"><a class="markdownIt-Anchor" href="#函数式并行functional-parallelism"></a> 函数式并行（Functional Parallelism）</h3>
<h2 id="创建java线程"><a class="markdownIt-Anchor" href="#创建java线程"></a> 创建Java线程</h2>
<p>Java线程类也是一个object类,它的实例都继承自java.lang.Thread或其子类。 可以用如下方式用java中创建一个线程：</p>
<pre><code class="highlight plaintext">Tread thread = new Thread();</code></pre>
<p>执行该线程可以调用该线程的start()方法:</p>
<pre><code class="highlight plaintext">thread.start();</code></pre>
<p>在上面的例子中，我们并没有为线程编写运行代码，因此调用该方法后线程就终止了。</p>
<p>编写线程运行时执行的代码有两种方式：</p>
<ul>
<li>一种是<strong>创建Thread子类的一个实例并重写run方法</strong></li>
<li>第二种是<strong>创建类的时候实现Runnable接口</strong></li>
</ul>
<h3 id="创建thread子类"><a class="markdownIt-Anchor" href="#创建thread子类"></a> 创建Thread子类</h3>
<p><strong>创建Thread子类</strong>的一个实例并重写run方法，run方法会在调用start()方法之后被执行。例子如下：</p>
<pre><code class="highlight plaintext">public class MyThread extends Thread &#123;
   public void run()&#123;
     System.out.println(&quot;MyThread running&quot;);
   &#125;
&#125;</code></pre>
<p><strong>运行：</strong></p>
<pre><code class="highlight plaintext">MyThread myThread = new MyThread();
myTread.start();</code></pre>
<blockquote>
<p>一旦线程启动后start方法就会立即返回，而不会等待到run方法执行完毕才返回。就好像run方法是在另外一个cpu上执行一样。当run方法执行后，将会打印出字符串MyThread running</p>
</blockquote>
<hr />
<p><strong>或者可以创建一个Thread的匿名子类：</strong></p>
<pre><code class="highlight plaintext">Thread thread = new Thread()&#123;
   public void run()&#123;
     System.out.println(&quot;Thread Running&quot;);
   &#125;
&#125;;
thread.start();</code></pre>
<h3 id="实现runnable接口"><a class="markdownIt-Anchor" href="#实现runnable接口"></a> 实现Runnable接口</h3>
<p>第二种编写线程执行代码的方式是新建一个实现了java.lang.Runnable接口的类的实例，实例中的方法可以被线程调用。下面给出例子：</p>
<pre><code class="highlight plaintext">public class MyRunnable implements Runnable &#123;
   public void run()&#123;
    System.out.println(&quot;MyRunnable running&quot;);
   &#125;
&#125;</code></pre>
<p><strong>执行</strong> run()方法，需要在Thread类的构造函数中传入 MyRunnable的实例对象。示例如下：</p>
<pre><code class="highlight plaintext">Thread thread = new Thread(new MyRunnable());
thread.start();</code></pre>
<blockquote>
<p>当线程运行时，它将会调用实现了Runnable接口的run方法。上例中将会打印出”MyRunnable running”。</p>
</blockquote>
<hr />
<p><strong>也可以创建一个实现了Runnable接口的匿名内类</strong></p>
<pre><code class="highlight plaintext">Runnable myRunnable = new Runnable()&#123;
   public void run()&#123;
     System.out.println(&quot;Runnable running&quot;);
   &#125;
&#125;
Thread thread = new Thread(myRunnable);
thread.start();</code></pre>
<p>或者可以使用lambda语法进一步简写</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Thread t = new Thread(() -&gt; &#123;
            System.out.println(&quot;start new thread!&quot;);
        &#125;);
        t.start(); // 启动新线程
    &#125;
&#125;</code></pre>
<h3 id="实现callable接口"><a class="markdownIt-Anchor" href="#实现callable接口"></a> 实现Callable接口</h3>
<p>通过实现Callable接口来实现可以返回数据的多线程</p>
<ul>
<li>优点：<strong>可以获取返回值</strong>
<ul>
<li>Callable和Future接口</li>
<li>Callable是类似于Runnable的接口，实现Callable接口的类和实现Runnable的类都是可以被其他线程执行的任务。</li>
<li><strong>Callable和Runnable有几点不同</strong>：
<ol>
<li>Callable规定的方法是call()，而Runnable规定的方法是run()。</li>
<li>call()方法可以抛出异常，而run()方法不能抛出异常。</li>
<li>Callable的任务执行后可返回值，运行Callable任务可以拿到一个Future对象，而Runnable的任务是不能有返回值的。</li>
<li>Future表示异步计算结果，他提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果，通过Future对象可了解任务执行情况，可取消任务的执行，还可以获取任务执行的结果。</li>
</ol>
</li>
</ul>
</li>
<li>缺点：繁琐</li>
</ul>
<p><strong>步骤：</strong></p>
<ul>
<li>创建Callable实现类+重写call</li>
<li>借助执行调度服务ExecutorService获取Future对象。
<ul>
<li>ExecutorService ser = Executors.newFixedThreadPool(2);</li>
<li>Future result = ser.submit(实现类对象)</li>
</ul>
</li>
<li>获取值 result.get()</li>
<li>停止服务 ser.shutdownNow()</li>
</ul>
<pre><code class="highlight plaintext">/**
* 使用Callable接口实现线程
* 优点
*   可以申明异常
*   可以返回值
* @author Mr
*
*/
public class CallableDemo &#123;
     public static void main(String[] args) throws InterruptedException, ExecutionException &#123;
           Race tortoise = new Race(&quot;老乌龟&quot;,1000);  //乌龟一秒跑一步
           Race rabbit = new Race(&quot;小兔子&quot;,500);  //兔子0.5秒跑一步
           //创建线程
           ExecutorService ser = Executors.newFixedThreadPool(2);  //填写创建线程的数量
           //获取值
           Future&lt;Integer&gt; result1 = ser.submit(tortoise);
           Future&lt;Integer&gt; result2 = ser.submit(rabbit);
           
           Thread.sleep(2000);  //2秒后/总共跑两秒
           rabbit.setFlag(false);  //停止线程体循环
           tortoise.setFlag(false);
           
           
           int num1 = result1.get();//如果有必要，等待计算完成，获取结果
           int num2 = result2.get();
           System.out.println(&quot;乌龟跑了--&gt;&quot;+num1);
           System.out.println(&quot;兔子跑了--&gt;&quot;+num2);
           //停止服务，现在
           ser.shutdownNow();
           
           
     &#125;
&#125;
/*
* 两个好处
* 可以返回值
* 可以申明异常
*/
class Race implements Callable&lt;Integer&gt;&#123;
     private String name;  //名字
     private long time;  //延时时间
     private boolean flag = true;
     private int step = 0;//步数
     public Race() &#123;
           // TODO Auto-generated constructor stub
     &#125;
     public Race(String name) &#123;
           super();
           this.name = name;
     &#125;
     public Race(String name,long time)&#123;
           super();
           this.name = name;
           this.time = time;
     &#125;
/*
* 线程体
* 
*/
     public Integer call() throws Exception &#123;
           while(flag)&#123;
                Thread.sleep(time);
                step++;
           &#125;
           return step;
     &#125;
     public String getName() &#123;
           return name;
     &#125;
     public void setName(String name) &#123;
           this.name = name;
     &#125;
     public long getTime() &#123;
           return time;
     &#125;
     public void setTime(long time) &#123;
           this.time = time;
     &#125;
     public boolean isFlag() &#123;
           return flag;
     &#125;
     public void setFlag(boolean flag) &#123;
           this.flag = flag;
     &#125;
     public int getStep() &#123;
           return step;
     &#125;
     public void setStep(int step) &#123;
           this.step = step;
     &#125;
&#125;</code></pre>
<h3 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h3>
<p><strong>创建子类还是实现Runnable接口？</strong></p>
<p>对于这两种方式哪种好并没有一个确定的答案，它们都能满足要求。就我个人意见，我更倾向于实现Runnable接口这种方法。因为线程池可以有效的管理实现了Runnable接口的线程，如果线程池满了，新的线程就会排队等候执行，直到线程池空闲出来为止。而如果线程是通过实现Thread子类实现的，这将会复杂一些。</p>
<p>有时我们要同时融合实现Runnable接口和Thread子类两种方式。例如，实现了Thread子类的实例可以执行多个实现了Runnable接口的线程。一个典型的应用就是线程池。</p>
<hr />
<p><strong>常见错误：调用run()方法而非start()方法</strong></p>
<p>创建并运行一个线程所犯的常见错误是调用线程的run()方法而非start()方法，如下所示：</p>
<pre><code class="highlight plaintext">Thread newThread = new Thread(MyRunnable());
newThread.run();  //should be start();</code></pre>
<p>起初你并不会感觉到有什么不妥，因为run()方法的确如你所愿的被调用了。但是，事实上,run()方法并非是由刚创建的新线程所执行的，而是被创建新线程的当前线程所执行了。也就是被执行上面两行代码的线程所执行的。<strong>想要让创建的新线程执行run()方法，必须调用新线程的start方法</strong></p>
<hr />
<p><strong>线程名</strong></p>
<p>当创建一个线程的时候，可以给线程起一个名字。它有助于我们区分不同的线程。例如：如果有多个线程写入System.out，我们就能够通过线程名容易的找出是哪个线程正在输出。例子如下：</p>
<pre><code class="highlight plaintext">MyRunnable runnable = new MyRunnable();
Thread thread = new Thread(runnable, &quot;New Thread&quot;);
thread.start();
System.out.println(thread.getName());</code></pre>
<p>需要注意的是，因为MyRunnable并非Thread的子类，所以MyRunnable类并没有getName()方法。可以通过以下方式得到当前线程的引用：</p>
<pre><code class="highlight plaintext">Thread.currentThread();</code></pre>
<p>因此，通过如下代码可以得到当前线程的名字：</p>
<pre><code class="highlight plaintext">String threadName = Thread.currentThread().getName();</code></pre>
<hr />
<p><strong>线程代码举例：</strong></p>
<p>这里是一个小小的例子。首先输出执行main()方法线程名字。这个线程JVM分配的。然后开启10个线程，命名为1~10。每个线程输出自己的名字后就退出。</p>
<pre><code class="highlight plaintext">
public class ThreadExample &#123;
  public static void main(String[] args)&#123;
     System.out.println(Thread.currentThread().getName());
      for(int i=0; i&lt;10; i++)&#123;
         new Thread(&quot;&quot; + i)&#123;
            public void run()&#123;
             System.out.println(&quot;Thread: &quot; + getName() + &quot;running&quot;);
            &#125;
         &#125;.start();
      &#125;
  &#125;
&#125;</code></pre>
<blockquote>
<p>需要注意的是，尽管启动线程的顺序是有序的，但是执行的顺序并非是有序的。也就是说，1号线程并不一定是第一个将自己名字输出到控制台的线程。这是因为线程是并行执行而非顺序的。Jvm和操作系统一起决定了线程的执行顺序，他和线程的启动顺序并非一定是一致的。</p>
</blockquote>
<hr />
<p><strong>线程优先级</strong></p>
<p>可以对线程设定优先级，设定优先级的方法是：</p>
<pre><code class="highlight plaintext">Thread.setPriority(int n) // 1~10, 默认值5</code></pre>
<blockquote>
<p>优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。</p>
</blockquote>
<h3 id="future"><a class="markdownIt-Anchor" href="#future"></a> Future</h3>
<p>在执行多个任务的时候，使用Java标准库提供的线程池是非常方便的。</p>
<p>我们提交的任务只需要实现Runnable接口，就可以让线程池去执行：</p>
<pre><code class="highlight plaintext">class Task implements Runnable &#123;
    public String result;

    public void run() &#123;
        this.result = longTimeCalculation(); 
    &#125;
&#125;</code></pre>
<p>Runnable接口有个问题，它的方法没有返回值。如果任务需要一个返回结果，那么只能保存到变量，还要提供额外的方法读取，非常不便。所以，Java标准库还提供了一个Callable接口，和Runnable接口比，它多了一个返回值：</p>
<pre><code class="highlight plaintext">class Task implements Callable&lt;String&gt; &#123;
    public String call() throws Exception &#123;
        return longTimeCalculation(); 
    &#125;
&#125;</code></pre>
<p>并且Callable接口是一个泛型接口，可以返回指定类型的结果。现在的问题是，如何获得异步执行的结果？</p>
<p>如果仔细看ExecutorService.submit()方法，可以看到，它返回了一个Future类型，<strong>一个Future类型的实例代表一个未来能获取结果的对象</strong>：</p>
<pre><code class="highlight plaintext">ExecutorService executor = Executors.newFixedThreadPool(4); 
// 定义任务:
Callable&lt;String&gt; task = new Task();
// 提交任务并获得Future:
Future&lt;String&gt; future = executor.submit(task);
// 从Future获取异步执行返回的结果:
String result = future.get(); // 可能阻塞</code></pre>
<p>当我们提交一个Callable任务后，我们会同时获得一个Future对象，然后，我们在主线程某个时刻调用Future对象的get()方法，就可以获得异步执行的结果。在调用get()时，如果异步任务已经完成，我们就直接获得结果。如果异步任务还没有完成，那么get()会阻塞，直到任务完成后才返回结果。</p>
<p>一个Future<V>接口表示一个未来可能会返回的结果，它定义的方法有：</p>
<ul>
<li>get()：获取结果（可能会等待）</li>
<li>get(long timeout, TimeUnit unit)：获取结果，但只等待指定的时间；</li>
<li>cancel(boolean mayInterruptIfRunning)：取消当前任务；</li>
<li>isDone()：判断任务是否已完成。</li>
</ul>
<h4 id="java方法执行超时关闭"><a class="markdownIt-Anchor" href="#java方法执行超时关闭"></a> java方法执行超时关闭</h4>
<pre><code class="highlight plaintext">
Callable&lt;String&gt; task = new Callable&lt;String&gt;() &#123;
            @Override
            public String call() throws Exception&#123;
                //执行耗时代码
                Thread.sleep(10000);
                return &quot;success&quot;;
            &#125;
        &#125;;
ExecutorService executorService = Executors.newSingleThreadExecutor();
Future&lt;String&gt; future = executorService.submit(task);
try &#123;
    //设置超时时间
    String rst = future.get(5,TimeUnit.SECONDS);
    System.out.println(rst);
&#125; catch (TimeoutException e) &#123;
    System.out.println(&quot;执行超时&quot;);
&#125; catch(Exception e)&#123;
    System.out.println(&quot;获取数据异常,&quot; + e.getMessage());
&#125;finally &#123;
    executorService.shutdown();
&#125;</code></pre>
<h3 id="completablefuture"><a class="markdownIt-Anchor" href="#completablefuture"></a> CompletableFuture</h3>
<p>使用Future获得异步执行结果时，要么调用阻塞方法get()，要么轮询看isDone()是否为true，这两种方法都不是很好，因为主线程也会被迫等待。</p>
<p>从Java 8开始引入了CompletableFuture，它针对Future做了改进，<strong>可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法</strong>。我们以获取股票价格为例，看看如何使用CompletableFuture：</p>
<pre><code class="highlight plaintext">import java.util.concurrent.CompletableFuture;
public class Main &#123;
    public static void main(String[] args) throws Exception &#123;
        // 创建异步执行任务:
        CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(Main::fetchPrice);
        // 如果执行成功:
        cf.thenAccept((result) -&gt; &#123;
            System.out.println(&quot;price: &quot; + result);
        &#125;);
        // 如果执行异常:
        cf.exceptionally((e) -&gt; &#123;
            e.printStackTrace();
            return null;
        &#125;);
        // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:
        Thread.sleep(200);
    &#125;

    static Double fetchPrice() &#123;
        try &#123;
            Thread.sleep(100);
        &#125; catch (InterruptedException e) &#123;
        &#125;
        if (Math.random() &lt; 0.3) &#123;
            throw new RuntimeException(&quot;fetch price failed!&quot;);
        &#125;
        return 5 + Math.random() * 20;
    &#125;
&#125;</code></pre>
<p>创建一个CompletableFuture是通过CompletableFuture.supplyAsync()实现的，它需要一个实现了Supplier接口的对象：</p>
<pre><code class="highlight plaintext">public interface Supplier&lt;T&gt; &#123;
    T get();
&#125;</code></pre>
<p>这里我们用lambda语法简化了一下，直接传入Main::fetchPrice，因为Main.fetchPrice()静态方法的签名符合Supplier接口的定义（除了方法名外）。</p>
<p>紧接着，CompletableFuture已经被提交给默认的线程池执行了，我们需要定义的是CompletableFuture完成时和异常时需要回调的实例。完成时，CompletableFuture会调用Consumer对象：</p>
<pre><code class="highlight plaintext">public interface Consumer&lt;T&gt; &#123;
    void accept(T t);
&#125;</code></pre>
<p>异常时，CompletableFuture会调用Function对象：</p>
<pre><code class="highlight plaintext">public interface Function&lt;T, R&gt; &#123;
    R apply(T t);
&#125;</code></pre>
<p>这里我们都用lambda语法简化了代码。</p>
<p>可见CompletableFuture的优点是：</p>
<ul>
<li>异步任务结束时，会自动回调某个对象的方法；</li>
<li>异步任务出错时，会自动回调某个对象的方法；</li>
<li>主线程设置好回调后，不再关心异步任务的执行。</li>
</ul>
<p>如果只是实现了异步回调机制，我们还看不出CompletableFuture相比Future的优势。CompletableFuture更强大的功能是，多个CompletableFuture可以串行执行，例如，定义两个CompletableFuture，第一个CompletableFuture根据证券名称查询证券代码，第二个CompletableFuture根据证券代码查询证券价格，这两个CompletableFuture实现串行操作如下：</p>
<pre><code class="highlight plaintext">
import java.util.concurrent.CompletableFuture;
public class Main &#123;
    public static void main(String[] args) throws Exception &#123;
        // 第一个任务:
        CompletableFuture&lt;String&gt; cfQuery = CompletableFuture.supplyAsync(() -&gt; &#123;
            return queryCode(&quot;中国石油&quot;);
        &#125;);
        // cfQuery成功后继续执行下一个任务:
        CompletableFuture&lt;Double&gt; cfFetch = cfQuery.thenApplyAsync((code) -&gt; &#123;
            return fetchPrice(code);
        &#125;);
        // cfFetch成功后打印结果:
        cfFetch.thenAccept((result) -&gt; &#123;
            System.out.println(&quot;price: &quot; + result);
        &#125;);
        // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:
        Thread.sleep(2000);
    &#125;

    static String queryCode(String name) &#123;
        try &#123;
            Thread.sleep(100);
        &#125; catch (InterruptedException e) &#123;
        &#125;
        return &quot;601857&quot;;
    &#125;

    static Double fetchPrice(String code) &#123;
        try &#123;
            Thread.sleep(100);
        &#125; catch (InterruptedException e) &#123;
        &#125;
        return 5 + Math.random() * 20;
    &#125;
&#125;
</code></pre>
<p>除了串行执行外，多个CompletableFuture还可以并行执行。例如，我们考虑这样的场景：同时从新浪和网易查询证券代码，只要任意一个返回结果，就进行下一步查询价格，查询价格也同时从新浪和网易查询，只要任意一个返回结果，就完成操作：</p>
<pre><code class="highlight plaintext">
import java.util.concurrent.CompletableFuture;
public class Main &#123;
    public static void main(String[] args) throws Exception &#123;
        // 两个CompletableFuture执行异步查询:
        CompletableFuture&lt;String&gt; cfQueryFromSina = CompletableFuture.supplyAsync(() -&gt; &#123;
            return queryCode(&quot;中国石油&quot;, &quot;https://finance.sina.com.cn/code/&quot;);
        &#125;);
        CompletableFuture&lt;String&gt; cfQueryFrom163 = CompletableFuture.supplyAsync(() -&gt; &#123;
            return queryCode(&quot;中国石油&quot;, &quot;https://money.163.com/code/&quot;);
        &#125;);

        // 用anyOf合并为一个新的CompletableFuture:
        CompletableFuture&lt;Object&gt; cfQuery = CompletableFuture.anyOf(cfQueryFromSina, cfQueryFrom163);

        // 两个CompletableFuture执行异步查询:
        CompletableFuture&lt;Double&gt; cfFetchFromSina = cfQuery.thenApplyAsync((code) -&gt; &#123;
            return fetchPrice((String) code, &quot;https://finance.sina.com.cn/price/&quot;);
        &#125;);
        CompletableFuture&lt;Double&gt; cfFetchFrom163 = cfQuery.thenApplyAsync((code) -&gt; &#123;
            return fetchPrice((String) code, &quot;https://money.163.com/price/&quot;);
        &#125;);

        // 用anyOf合并为一个新的CompletableFuture:
        CompletableFuture&lt;Object&gt; cfFetch = CompletableFuture.anyOf(cfFetchFromSina, cfFetchFrom163);

        // 最终结果:
        cfFetch.thenAccept((result) -&gt; &#123;
            System.out.println(&quot;price: &quot; + result);
        &#125;);
        // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:
        Thread.sleep(200);
    &#125;

    static String queryCode(String name, String url) &#123;
        System.out.println(&quot;query code from &quot; + url + &quot;...&quot;);
        try &#123;
            Thread.sleep((long) (Math.random() * 100));
        &#125; catch (InterruptedException e) &#123;
        &#125;
        return &quot;601857&quot;;
    &#125;

    static Double fetchPrice(String code, String url) &#123;
        System.out.println(&quot;query price from &quot; + url + &quot;...&quot;);
        try &#123;
            Thread.sleep((long) (Math.random() * 100));
        &#125; catch (InterruptedException e) &#123;
        &#125;
        return 5 + Math.random() * 20;
    &#125;
&#125;
</code></pre>
<p>上述逻辑实现的异步查询规则实际上是：</p>
<p>除了anyOf()可以实现“任意个CompletableFuture只要一个成功”，allOf()可以实现“所有CompletableFuture都必须成功”，这些组合操作可以实现非常复杂的异步流程控制。最后我们注意CompletableFuture的命名规则：</p>
<ul>
<li>xxx()：表示该方法将继续在已有的线程中执行；</li>
<li>xxxAsync()：表示将异步在线程池中执行。</li>
</ul>
<h3 id="forkjoin"><a class="markdownIt-Anchor" href="#forkjoin"></a> ForkJoin</h3>
<p>Java 7开始引入了一种新的Fork/Join线程池，它可以执行一种特殊的任务：把一个大任务拆成多个小任务并行执行。我们举个例子：如果要计算一个超大数组的和，最简单的做法是用一个循环在一个线程内完成：</p>
<p>还有一种方法，可以把数组拆成两部分，分别计算，最后加起来就是最终结果，这样可以用两个线程并行执行：</p>
<p>如果拆成两部分还是很大，我们还可以继续拆，用4个线程并行执行：</p>
<p>这就是Fork/Join任务的原理：判断一个任务是否足够小，如果是，直接计算，否则，就分拆成几个小任务分别计算。这个过程可以反复“裂变”成一系列小任务。我们来看如何使用Fork/Join对大数据进行并行求和：</p>
<pre><code class="highlight plaintext">
import java.util.Random;
import java.util.concurrent.*;
public class Main &#123;
    public static void main(String[] args) throws Exception &#123;
        // 创建2000个随机数组成的数组:
        long[] array = new long[2000];
        long expectedSum = 0;
        for (int i = 0; i &lt; array.length; i++) &#123;
            array[i] = random();
            expectedSum += array[i];
        &#125;
        System.out.println(&quot;Expected sum: &quot; + expectedSum);
        // fork/join:
        ForkJoinTask&lt;Long&gt; task = new SumTask(array, 0, array.length);
        long startTime = System.currentTimeMillis();
        Long result = ForkJoinPool.commonPool().invoke(task);
        long endTime = System.currentTimeMillis();
        System.out.println(&quot;Fork/join sum: &quot; + result + &quot; in &quot; + (endTime - startTime) + &quot; ms.&quot;);
    &#125;

    static Random random = new Random(0);

    static long random() &#123;
        return random.nextInt(10000);
    &#125;
&#125;

class SumTask extends RecursiveTask&lt;Long&gt; &#123;
    static final int THRESHOLD = 500;
    long[] array;
    int start;
    int end;

    SumTask(long[] array, int start, int end) &#123;
        this.array = array;
        this.start = start;
        this.end = end;
    &#125;

    @Override
    protected Long compute() &#123;
        if (end - start &lt;= THRESHOLD) &#123;
            // 如果任务足够小,直接计算:
            long sum = 0;
            for (int i = start; i &lt; end; i++) &#123;
                sum += this.array[i];
                // 故意放慢计算速度:
                try &#123;
                    Thread.sleep(1);
                &#125; catch (InterruptedException e) &#123;
                &#125;
            &#125;
            return sum;
        &#125;
        // 任务太大,一分为二:
        int middle = (end + start) / 2;
        System.out.println(String.format(&quot;split %d~%d ==&gt; %d~%d, %d~%d&quot;, start, end, start, middle, middle, end));
        SumTask subtask1 = new SumTask(this.array, start, middle);
        SumTask subtask2 = new SumTask(this.array, middle, end);
        invokeAll(subtask1, subtask2);
        Long subresult1 = subtask1.join();
        Long subresult2 = subtask2.join();
        Long result = subresult1 + subresult2;
        System.out.println(&quot;result = &quot; + subresult1 + &quot; + &quot; + subresult2 + &quot; ==&gt; &quot; + result);
        return result;
    &#125;
&#125;
</code></pre>
<p>观察上述代码的执行过程，一个大的计算任务0<sub>2000首先分裂为两个小任务0</sub>1000和1000<sub>2000，这两个小任务仍然太大，继续分裂为更小的0</sub>500，500<sub>1000，1000</sub>1500，1500~2000，最后，计算结果被依次合并，得到最终结果。</p>
<p>因此，核心代码SumTask继承自RecursiveTask，在compute()方法中，关键是如何“分裂”出子任务并且提交子任务：</p>
<pre><code class="highlight plaintext">
class SumTask extends RecursiveTask&lt;Long&gt; &#123;
    protected Long compute() &#123;
        // “分裂”子任务:
        SumTask subtask1 = new SumTask(...);
        SumTask subtask2 = new SumTask(...);
        // invokeAll会并行运行两个子任务:
        invokeAll(subtask1, subtask2);
        // 获得子任务的结果:
        Long subresult1 = subtask1.join();
        Long subresult2 = subtask2.join();
        // 汇总结果:
        return subresult1 + subresult2;
    &#125;
&#125;</code></pre>
<p>Fork/Join线程池在Java标准库中就有应用。Java标准库提供的java.util.Arrays.parallelSort(array)可以进行并行排序，它的原理就是内部通过Fork/Join对大数组分拆进行并行排序，在多核CPU上就可以大大提高排序的速度。</p>
<h3 id="线程的状态"><a class="markdownIt-Anchor" href="#线程的状态"></a> 线程的状态</h3>
<p>在Java程序中，一个线程对象只能调用一次start()方法启动新线程，并在新线程中执行run()方法。一旦run()方法执行完毕，线程就结束了。因此，Java线程的状态有以下几种：</p>
<ul>
<li><strong>New</strong>：新创建的线程，尚未执行；</li>
<li><strong>Runnable</strong>：运行中的线程，正在执行run()方法的Java代码；</li>
<li><strong>Blocked</strong>：运行中的线程，因为某些操作被阻塞而挂起；</li>
<li><strong>Waiting</strong>：运行中的线程，因为某些操作在等待中；</li>
<li><strong>Timed Waiting</strong>：运行中的线程，因为执行sleep()方法正在计时等待；</li>
<li><strong>Terminated</strong>：线程已终止，因为run()方法执行完毕。</li>
</ul>
<p>用一个状态转移图表示如下：</p>
<p>当线程启动后，它可以在Runnable、Blocked、Waiting和Timed Waiting这几个状态之间切换，直到最后变成Terminated状态，线程终止。</p>
<p>线程终止的原因有：线程正常终止：</p>
<ul>
<li>run()方法执行到return语句返回；</li>
<li>线程意外终止：run()方法因为未捕获的异常导致线程终止；</li>
<li>对某个线程的Thread实例调用stop()方法强制终止（强烈不推荐使用）。</li>
</ul>
<p><strong>一个线程还可以等待另一个线程直到其运行结束</strong>。例如，main线程在启动t线程后，可以通过t.join()等待t线程结束后再继续运行：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        Thread t = new Thread(() -&gt; &#123;
            System.out.println(&quot;hello&quot;);
        &#125;);
        System.out.println(&quot;start&quot;);
        t.start();
        t.join();
        System.out.println(&quot;end&quot;);
    &#125;
&#125;</code></pre>
<h3 id="中断线程"><a class="markdownIt-Anchor" href="#中断线程"></a> 中断线程</h3>
<p>如果线程需要执行一个长时间任务，就可能需要能中断线程。中断线程就是其他线程给该线程发一个信号，该线程收到信号后结束执行run()方法，使得自身线程能立刻结束运行。</p>
<p>我们举个栗子：假设从网络下载一个100M的文件，如果网速很慢，用户等得不耐烦，就可能在下载过程中点“取消”，这时，程序就需要中断下载线程的执行。</p>
<p><strong>中断一个线程</strong>非常简单，<strong>只需要在其他线程中对目标线程调用interrupt()方法</strong>，目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行。</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        Thread t = new MyThread();
        t.start();
        Thread.sleep(1); // 暂停1毫秒
        t.interrupt(); // 中断t线程
        t.join(); // 等待t线程结束
        System.out.println(&quot;end&quot;);
    &#125;
&#125;

class MyThread extends Thread &#123;
    public void run() &#123;
        int n = 0;
        while (! isInterrupted()) &#123;
            n ++;
            System.out.println(n + &quot; hello!&quot;);
        &#125;
    &#125;
&#125;</code></pre>
<p>仔细看上述代码，main线程通过调用t.interrupt()方法中断t线程，但是要注意，interrupt()方法仅仅向t线程发出了“中断请求”，至于t线程是否能立刻响应，要看具体代码。而t线程的while循环会检测isInterrupted()，所以上述代码能正确响应interrupt()请求，使得自身立刻结束运行run()方法。</p>
<p>如果线程处于等待状态，例如，t.join()会让main线程进入等待状态，此时，如果对main线程调用interrupt()，join()方法会立刻抛出InterruptedException，因此，目标线程只要捕获到join()方法抛出的InterruptedException，就说明有其他线程对其调用了interrupt()方法，通常情况下该线程应该立刻结束运行。</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        Thread t = new MyThread();
        t.start();
        Thread.sleep(1000);
        t.interrupt(); // 中断t线程
        t.join(); // 等待t线程结束
        System.out.println(&quot;end&quot;);
    &#125;
&#125;

class MyThread extends Thread &#123;
    public void run() &#123;
        Thread hello = new HelloThread();
        hello.start(); // 启动hello线程
        try &#123;
            hello.join(); // 等待hello线程结束
        &#125; catch (InterruptedException e) &#123;
            System.out.println(&quot;interrupted!&quot;);
        &#125;
        hello.interrupt();
    &#125;
&#125;

class HelloThread extends Thread &#123;
    public void run() &#123;
        int n = 0;
        while (!isInterrupted()) &#123;
            n++;
            System.out.println(n + &quot; hello!&quot;);
            try &#123;
                Thread.sleep(100);
            &#125; catch (InterruptedException e) &#123;
                break;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>main线程通过调用t.interrupt()从而通知t线程中断，而此时t线程正位于hello.join()的等待中，此方法会立刻结束等待并抛出InterruptedException。由于我们在t线程中捕获了InterruptedException，因此，就可以准备结束该线程。在t线程结束前，对hello线程也进行了interrupt()调用通知其中断。如果去掉这一行代码，可以发现hello线程仍然会继续运行，且JVM不会退出。</p>
<p><strong>另一个常用的中断线程的方法是设置标志位</strong>。我们通常会用一个running标志位来标识线程是否应该继续运行，在外部线程中，通过把HelloThread.running置为false，就可以让线程结束：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args)  throws InterruptedException &#123;
        HelloThread t = new HelloThread();
        t.start();
        Thread.sleep(1);
        t.running = false; // 标志位置为false
    &#125;
&#125;

class HelloThread extends Thread &#123;
    public volatile boolean running = true;
    public void run() &#123;
        int n = 0;
        while (running) &#123;
            n ++;
            System.out.println(n + &quot; hello!&quot;);
        &#125;
        System.out.println(&quot;end!&quot;);
    &#125;
&#125;</code></pre>
<p>注意到HelloThread的标志位boolean running是一个线程间共享的变量。线程间共享变量需要使用volatile关键字标记，确保每个线程都能读取到更新后的变量值。</p>
<p>为什么要对线程间共享的变量用关键字volatile声明？</p>
<ul>
<li>这涉及到Java的内存模型。在Java虚拟机中，变量的值保存在主内存中，但是，当线程访问变量时，它会先获取一个副本，并保存在自己的工作内存中。如果线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存，但是，这个时间是不确定的！</li>
</ul>
<p>这会导致如果一个线程更新了某个变量，另一个线程读取的值可能还是更新前的。例如，主内存的变量a = true，线程1执行a = false时，它在此刻仅仅是把变量a的副本变成了false，主内存的变量a还是true，在JVM把修改后的a回写到主内存之前，其他线程读取到的a的值仍然是true，这就造成了多线程之间共享的变量不一致。</p>
<p>因此，volatile关键字的目的是告诉虚拟机：</p>
<ul>
<li><strong>每次访问变量时，总是获取主内存的最新值</strong>；</li>
<li><strong>每次修改变量后，立刻回写到主内存</strong>。</li>
</ul>
<p>volatile关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。</p>
<p>如果我们去掉volatile关键字，运行上述程序，发现效果和带volatile差不多，这是因为在x86的架构下，JVM回写主内存的速度非常快，但是，换成ARM的架构，就会有显著的延迟。</p>
<blockquote>
<p><strong>注意：volatile关键字只可以保证我写入变量可以立即被别人读</strong></p>
</blockquote>
<blockquote>
<p><strong>注意：volatile关键字只可以保证时效性，不能保证原子性</strong></p>
</blockquote>
<h3 id="守护线程"><a class="markdownIt-Anchor" href="#守护线程"></a> 守护线程</h3>
<p>Java程序入口就是由JVM启动main线程，main线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。</p>
<p>如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。</p>
<p>但是有一种线程的目的就是无限循环，例如，一个定时触发任务的线程：</p>
<pre><code class="highlight plaintext">class TimerThread extends Thread &#123;
    @Override
    public void run() &#123;
        while (true) &#123;
            System.out.println(LocalTime.now());
            try &#123;
                Thread.sleep(1000);
            &#125; catch (InterruptedException e) &#123;
                break;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>如果这个线程不结束，JVM进程就无法结束。问题是，由谁负责结束这个线程？</p>
<p>然而这类线程经常没有负责人来负责结束它们。但是，当其他线程结束时，JVM进程又必须要结束，怎么办？</p>
<ul>
<li>答案是使用守护线程（Daemon Thread）。</li>
</ul>
<p>守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</p>
<p>因此，JVM退出时，不必关心守护线程是否已结束。</p>
<p>如何创建守护线程呢？方法和普通线程一样，只是在调用start()方法前，调用setDaemon(true)把该线程标记为守护线程：</p>
<pre><code class="highlight plaintext">Thread t = new MyThread();
t.setDaemon(true);
t.start();</code></pre>
<blockquote>
<p>在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。</p>
</blockquote>
<h2 id="多线程安全"><a class="markdownIt-Anchor" href="#多线程安全"></a> 多线程安全</h2>
<h3 id="竞态条件与临界区"><a class="markdownIt-Anchor" href="#竞态条件与临界区"></a> 竞态条件与临界区</h3>
<p>在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如，同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化,多个线程读取相同的资源就是安全的。</p>
<pre><code class="highlight plaintext">public class Counter &#123;
        protected long count = 0;
        public void add(long value)&#123;
                this.count = this.count + value;   
        &#125;
&#125;</code></pre>
<p>想象下线程A和B同时执行同一个Counter对象的add()方法，我们无法知道操作系统何时会在两个线程之间切换。JVM并不是将这段代码视为单条指令来执行的，而是按照下面的顺序：</p>
<pre><code class="highlight plaintext">从内存获取 this.count 的值放到寄存器
将寄存器中的值增加value
将寄存器中的值写回内存</code></pre>
<p>观察线程A和B交错执行会发生什么：</p>
<pre><code class="highlight plaintext">this.count = 0;
   A:   读取 this.count 到一个寄存器 (0)
   B:   读取 this.count 到一个寄存器 (0)
   B:   将寄存器的值加2
   B:   回写寄存器值(2)到内存. this.count 现在等于 2
   A:   将寄存器的值加3
   A:   回写寄存器值(3)到内存. this.count 现在等于 3</code></pre>
<p>两个线程分别加了2和3到count变量上，两个线程执行结束后count变量的值应该等于5。然而由于两个线程是交叉执行的，两个线程从内存中读出的初始值都是0。然后各自加了2和3，并分别写回内存。最终的值并不是期望的5，而是最后写回内存的那个线程的值，上面例子中最后写回内存的是线程A，但实际中也可能是线程B。如果没有采用合适的同步机制，线程间的交叉执行情况就无法预料。</p>
<p><strong>竞态条件 &amp; 临界区</strong></p>
<p>当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。上例中add()方法就是一个临界区,它会产生竞态条件。在临界区中使用适当的同步就可以避免竞态条件。</p>
<h3 id="共享资源"><a class="markdownIt-Anchor" href="#共享资源"></a> 共享资源</h3>
<p>允许被多个线程同时执行的代码称作线程安全的代码。线程安全的代码不包含竞态条件。当多个线程同时更新共享资源时会引发竞态条件。因此，了解Java线程执行时共享了什么资源很重要。</p>
<hr />
<p><strong>局部变量</strong></p>
<p>局部变量存储在线程自己的栈中。也就是说，局部变量永远也不会被多个线程共享。所以，基础类型的局部变量是线程安全的。下面是基础类型的局部变量的一个例子：</p>
<pre><code class="highlight plaintext">public void someMethod()&#123;
  long threadSafeInt = 0;
  threadSafeInt++;
&#125;</code></pre>
<hr />
<p><strong>局部的对象引用</strong></p>
<p>对象的局部引用和基础类型的局部变量不太一样。尽管引用本身没有被共享，但引用所指的对象并没有存储在线程的栈内。所有的对象都存在共享堆中。如果在某个方法中创建的对象不会逃逸出（译者注：即该对象不会被其它方法获得，也不会被非局部变量引用到）该方法，那么它就是线程安全的。实际上，哪怕将这个对象作为参数传给其它方法，只要别的线程获取不到这个对象，那它仍是线程安全的。下面是一个线程安全的局部引用样例：</p>
<pre><code class="highlight plaintext">public void someMethod()&#123;
  
  LocalObject localObject = new LocalObject();

  localObject.callMethod();
  method2(localObject);
&#125;

public void method2(LocalObject localObject)&#123;
  localObject.setValue(&quot;value&quot;);
&#125;</code></pre>
<p>样例中LocalObject对象没有被方法返回，也没有被传递给someMethod()方法外的对象。每个执行someMethod()的线程都会创建自己的LocalObject对象，并赋值给localObject引用。因此，这里的LocalObject是线程安全的。事实上，整个someMethod()都是线程安全的。即使将LocalObject作为参数传给同一个类的其它方法或其它类的方法时，它仍然是线程安全的。当然，如果LocalObject通过某些方法被传给了别的线程，那它就不再是线程安全的了</p>
<hr />
<p><strong>对象成员</strong></p>
<p>对象成员存储在堆上。如果两个线程同时更新同一个对象的同一个成员，那这个代码就不是线程安全的。下面是一个样例：</p>
<pre><code class="highlight plaintext">public class NotThreadSafe&#123;
    StringBuilder builder = new StringBuilder();
    
    public add(String text)&#123;
        this.builder.append(text);
    &#125;   
&#125;</code></pre>
<p>如果两个线程同时调用同一个NotThreadSafe实例上的add()方法，就会有竞态条件问题。例如：</p>
<pre><code class="highlight plaintext">
NotThreadSafe sharedInstance = new NotThreadSafe();

new Thread(new MyRunnable(sharedInstance)).start();
new Thread(new MyRunnable(sharedInstance)).start();

public class MyRunnable implements Runnable&#123;
  NotThreadSafe instance = null;
  
  public MyRunnable(NotThreadSafe instance)&#123;
    this.instance = instance;
  &#125;

  public void run()&#123;
    this.instance.add(&quot;some text&quot;);
  &#125;
&#125;</code></pre>
<p>注意两个MyRunnable共享了同一个NotThreadSafe对象。因此，当它们调用add()方法时会造成竞态条件。</p>
<p>当然，如果这两个线程在不同的NotThreadSafe实例上调用call()方法，就不会导致竞态条件。下面是稍微修改后的例子：</p>
<pre><code class="highlight plaintext">new Thread(new MyRunnable(new NotThreadSafe())).start();
new Thread(new MyRunnable(new NotThreadSafe())).start();</code></pre>
<p>现在两个线程都有自己单独的NotThreadSafe对象，调用add()方法时就会互不干扰，再也不会有竞态条件问题了。所以非线程安全的对象仍可以通过某种方式来消除竞态条件。</p>
<hr />
<p><strong>线程控制逃逸规则</strong></p>
<p>线程控制逃逸规则可以帮助你判断代码中对某些资源的访问是否是线程安全的。</p>
<pre><code class="highlight plaintext">如果一个资源的创建，使用，销毁都在同一个线程内完成，
且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。</code></pre>
<p>资源可以是对象，数组，文件，数据库连接，套接字等等。Java中你无需主动销毁对象，所以“销毁”指不再有引用指向对象。</p>
<p>即使对象本身线程安全，但如果该对象中包含其他资源（文件，数据库连接），整个应用也许就不再是线程安全的了。比如2个线程都创建了各自的数据库连接，每个连接自身是线程安全的，但它们所连接到的同一个数据库也许不是线程安全的。比如，2个线程执行如下代码：</p>
<pre><code class="highlight plaintext">检查记录X是否存在，如果不存在，插入X</code></pre>
<p>如果两个线程同时执行，而且碰巧检查的是同一个记录，那么两个线程最终可能都插入了记录：</p>
<pre><code class="highlight plaintext">线程1检查记录X是否存在。检查结果：不存在
线程2检查记录X是否存在。检查结果：不存在
线程1插入记录X
线程2插入记录X</code></pre>
<p>同样的问题也会发生在文件或其他共享资源上。因此，区分某个线程控制的对象是资源本身，还是仅仅到某个资源的引用很重要。</p>
<h3 id="不可变性"><a class="markdownIt-Anchor" href="#不可变性"></a> 不可变性</h3>
<p>当多个线程同时访问同一个资源，并且其中的一个或者多个线程对这个资源进行了写操作，才会产生竞态条件。多个线程同时读同一个资源不会产生竞态条件</p>
<p>我们可以通过创建不可变的共享对象来保证对象在线程间共享时不会被修改，从而实现线程安全。如下示例：</p>
<pre><code class="highlight plaintext">
public class ImmutableValue&#123;
        private int value = 0;

        public ImmutableValue(int value)&#123;
                this.value = value;
        &#125;

        public int getValue()&#123;
                return this.value;
        &#125;
&#125;</code></pre>
<p>请注意ImmutableValue类的成员变量value是通过构造函数赋值的，并且在类中没有set方法。这意味着一旦ImmutableValue实例被创建，value变量就不能再被修改，这就是不可变性。但你可以通过getValue()方法读取这个变量的值。</p>
<blockquote>
<p>注意，“不变”（Immutable）和“只读”（Read Only）是不同的。当一个变量是“只读”时，变量的值不能直接改变，但是可以在其它变量发生改变的时候发生改变。比如，一个人的出生年月日是“不变”属性，而一个人的年龄便是“只读”属性，但是不是“不变”属性。随着时间的变化，一个人的年龄会随之发生变化，而一个人的出生年月日则不会变化。这就是“不变”和“只读”的区别。（摘自《Java与模式》第34章）</p>
</blockquote>
<p>如果你需要对ImmutableValue类的实例进行操作，可以通过得到value变量后创建一个新的实例来实现，下面是一个对value变量进行加法操作的示例：</p>
<pre><code class="highlight plaintext">
public class ImmutableValue&#123;
        private int value = 0;

        public ImmutableValue(int value)&#123;
                this.value = value;
        &#125;

        public int getValue()&#123;
                return this.value;
        &#125;

        public ImmutableValue add(int valueToAdd)&#123;
                return new ImmutableValue(this.value + valueToAdd);
        &#125;
&#125;</code></pre>
<p>请注意add()方法以加法操作的结果作为一个新的ImmutableValue类实例返回，而不是直接对它自己的value变量进行操作。</p>
<hr />
<p><strong>引用不是线程安全的</strong></p>
<p>重要的是要记住，即使一个对象是线程安全的不可变对象，指向这个对象的引用也可能不是线程安全的。看这个例子：</p>
<pre><code class="highlight plaintext">
public void Calculator&#123;
        private ImmutableValue currentValue = null;

        public ImmutableValue getValue()&#123;
                return currentValue;
        &#125;

        public void setValue(ImmutableValue newValue)&#123;
                this.currentValue = newValue;
        &#125;

        public void add(int newValue)&#123;
                this.currentValue = this.currentValue.add(newValue);
        &#125;
&#125;</code></pre>
<p>Calculator类持有一个指向ImmutableValue实例的引用。注意，通过setValue()方法和add()方法可能会改变这个引用。因此，即使Calculator类内部使用了一个不可变对象，但Calculator类本身还是可变的，因此Calculator类不是线程安全的。换句话说：ImmutableValue类是线程安全的，但使用它的类不是。当尝试通过不可变性去获得线程安全时，这点是需要牢记的</p>
<p>要使Calculator类实现线程安全，将getValue()、setValue()和add()方法都声明为同步方法即可。</p>
<h2 id="java内存模型"><a class="markdownIt-Anchor" href="#java内存模型"></a> Java内存模型</h2>
<p>Java内存模型规范了Java虚拟机与计算机内存是如何协同工作的。Java虚拟机是一个完整的计算机的一个模型，因此这个模型自然也包含一个内存模型——又称为Java内存模型。</p>
<p>如果你想设计表现良好的并发程序，理解Java内存模型是非常重要的。Java内存模型规定了如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量</p>
<p>原始的Java内存模型存在一些不足，因此Java内存模型在Java1.5时被重新修订。这个版本的Java内存模型在Java8中人在使用</p>
<h3 id="java内存模型内部原理"><a class="markdownIt-Anchor" href="#java内存模型内部原理"></a> Java内存模型内部原理</h3>
<p>Java内存模型把Java虚拟机内部划分为线程栈和堆。这张图演示了Java内存模型的逻辑视图。</p>
<p><strong>每一个运行在Java虚拟机里的线程都拥有自己的线程栈</strong>。这个线程栈包含了这个线程调用的方法当前执行点相关的信息。<strong>一个线程仅能访问自己的线程栈</strong>。一个线程创建的<strong>本地变量对其它线程不可见，仅自己可见</strong>。即使两个线程执行同样的代码，这两个线程任然在在自己的线程栈中的代码来创建本地变量。因此，每个线程拥有每个本地变量的独有版本</p>
<p><strong>所有原始类型的本地变量都存放在线程栈上</strong>，因此对其它线程不可见。一个线程可能向另一个线程传递一个原始类型变量的拷贝，但是它不能共享这个原始类型变量自身。</p>
<p>堆上包含在Java程序中创建的所有对象，无论是哪一个对象创建的。这包括原始类型的对象版本。如果一个对象被创建然后赋值给一个局部变量，或者用来作为另一个对象的成员变量，这个对象任然是存放在堆上。</p>
<p>下面这张图演示了调用栈和本地变量存放在线程栈上，对象存放在堆上。</p>
<ul>
<li>一个本地变量可能是原始类型，在这种情况下，它总是“呆在”线程栈上。</li>
<li>一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。</li>
<li>一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量任然存放在线程栈上，即使这些方法所属的对象存放在堆上。</li>
<li>一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。</li>
<li>静态成员变量跟随着类定义一起也存放在堆上。</li>
<li>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个本地变量的私有拷贝</li>
</ul>
<p>两个线程拥有一些列的本地变量。其中一个本地变量（Local Variable 2）执行堆上的一个共享对象（Object 3）。这两个线程分别拥有同一个对象的不同引用。这些引用都是本地变量，因此存放在各自线程的线程栈上。这两个不同的引用指向堆上同一个对象</p>
<blockquote>
<p>注意，这个共享对象（Object 3）持有Object2和Object4一个引用作为其成员变量（如图中Object3指向Object2和Object4的箭头）。通过在Object3中这些成员变量引用，这两个线程就可以访问Object2和Object4</p>
</blockquote>
<p>这张图也展示了指向堆上两个不同对象的一个本地变量。在这种情况下，指向两个不同对象的引用不是同一个对象。理论上，两个线程都可以访问Object1和Object5，如果两个线程都拥有两个对象的引用。但是在上图中，每一个线程仅有一个引用指向两个对象其中之一</p>
<p>因此，什么类型的Java代码会导致上面的内存图呢？如下所示：</p>
<pre><code class="highlight plaintext">public class MyRunnable implements Runnable() &#123;

    public void run() &#123;
        methodOne();
    &#125;

    public void methodOne() &#123;
        int localVariable1 = 45;

        MySharedObject localVariable2 =
            MySharedObject.sharedInstance;

        //... do more with local variables.

        methodTwo();
    &#125;

    public void methodTwo() &#123;
        Integer localVariable1 = new Integer(99);

        //... do more with local variable.
    &#125;
&#125;

public class MySharedObject &#123;

    //static variable pointing to instance of MySharedObject

    public static final MySharedObject sharedInstance =
        new MySharedObject();

    //member variables pointing to two objects on the heap

    public Integer object2 = new Integer(22);
    public Integer object4 = new Integer(44);

    public long member1 = 12345;
    public long member1 = 67890;
&#125;</code></pre>
<p>如果两个线程同时执行run()方法，就会出现上图所示的情景。run()方法调用methodOne()方法，methodOne()调用methodTwo()方法</p>
<p>methodOne()声明了一个原始类型的本地变量和一个引用类型的本地变量。</p>
<p>每个线程执行methodOne()都会在它们对应的线程栈上创建localVariable1和localVariable2的私有拷贝。localVariable1变量彼此完全独立，仅“生活”在每个线程的线程栈上。一个线程看不到另一个线程对它的localVariable1私有拷贝做出的修改。</p>
<p>每个线程执行methodOne()时也将会创建它们各自的localVariable2拷贝。然而，两个localVariable2的不同拷贝都指向堆上的同一个对象。代码中通过一个静态变量设置localVariable2指向一个对象引用。仅存在一个静态变量的一份拷贝，这份拷贝存放在堆上。因此，localVariable2的两份拷贝都指向由MySharedObject指向的静态变量的同一个实例。MySharedObject实例也存放在堆上。它对应于上图中的Object3。</p>
<blockquote>
<p>注意，MySharedObject类也包含两个成员变量。这些成员变量随着这个对象存放在堆上。这两个成员变量指向另外两个Integer对象。这些Integer对象对应于上图中的Object2和Object4.</p>
</blockquote>
<blockquote>
<p>注意，methodTwo()创建一个名为localVariable的本地变量。这个成员变量是一个指向一个Integer对象的对象引用。这个方法设置localVariable1引用指向一个新的Integer实例。在执行methodTwo方法时，localVariable1引用将会在每个线程中存放一份拷贝。这两个Integer对象实例化将会被存储堆上，但是每次执行这个方法时，这个方法都会创建一个新的Integer对象，两个线程执行这个方法将会创建两个不同的Integer实例。methodTwo方法创建的Integer对象对应于上图中的Object1和Object5。</p>
</blockquote>
<p>还有一点，MySharedObject类中的两个long类型的成员变量是原始类型的。因为，这些变量是成员变量，所以它们任然随着该对象存放在堆上，仅有本地变量存放在线程栈上。</p>
<h3 id="硬件内存架构"><a class="markdownIt-Anchor" href="#硬件内存架构"></a> 硬件内存架构</h3>
<p>现代硬件内存模型与Java内存模型有一些不同。理解内存模型架构以及Java内存模型如何与它协同工作也是非常重要的。这部分描述了通用的硬件内存架构，下面的部分将会描述Java内存是如何与它“联手”工作的。</p>
<p>下面是现代计算机硬件架构的简单图示：</p>
<p>一个现代计算机通常由两个或者多个CPU。其中一些CPU还有多核。从这一点可以看出，在一个有两个或者多个CPU的现代计算机上同时运行多个线程是可能的。每个CPU在某一时刻运行一个线程是没有问题的。这意味着，如果你的Java程序是多线程的，在你的Java程序中每个CPU上一个线程可能同时（并发）执行</p>
<p><strong>每个CPU都包含一系列的寄存器</strong>，它们是CPU内内存的基础。CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器的速度远大于主存</p>
<p><strong>每个CPU可能还有一个CPU缓存层</strong>。实际上，绝大多数的现代CPU都有一定大小的缓存层。CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度还要慢一点。一些CPU还有多层缓存，但这些对理解Java内存模型如何和内存交互不是那么重要。只要知道CPU中可以有一个缓存层就可以了</p>
<p>通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。</p>
<p>当CPU需要在缓存层存放一些东西的时候，存放在缓存中的内容通常会被刷新回主存。CPU缓存可以在某一时刻将数据局部写到它的内存中，和在某一时刻局部刷新它的内存。它不会再某一时刻读/写整个缓存。通常，在一个被称作“cache lines”的更小的内存块中缓存被更新。一个或者多个缓存行可能被读到缓存，一个或者多个缓存行可能再被刷新回主存</p>
<h3 id="java内存模型和硬件内存架构之间的桥接"><a class="markdownIt-Anchor" href="#java内存模型和硬件内存架构之间的桥接"></a> Java内存模型和硬件内存架构之间的桥接</h3>
<p>上面已经提到，Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。如下图所示：</p>
<p>当对象和变量被存放在计算机中各种不同的内存区域中时，就可能会出现一些具体的问题。主要包括如下两个方面：</p>
<ul>
<li>线程对共享变量修改的可见性</li>
<li>当读，写和检查共享变量时出现race conditions</li>
</ul>
<p><strong>共享对象可见性</strong></p>
<p>如果两个或者更多的线程在没有正确的使用volatile声明或者同步的情况下共享一个对象，一个线程更新这个共享对象可能对其它线程来说是不接见的</p>
<p>想象一下，共享对象被初始化在主存中。跑在CPU上的一个线程将这个共享对象读到CPU缓存中。然后修改了这个对象。只要CPU缓存没有被刷新会主存，对象修改后的版本对跑在其它CPU上的线程都是不可见的。这种方式可能导致每个线程拥有这个共享对象的私有拷贝，每个拷贝停留在不同的CPU缓存中</p>
<p>下图示意了这种情形。跑在左边CPU的线程拷贝这个共享对象到它的CPU缓存中，然后将count变量的值修改为2。这个修改对跑在右边CPU上的其它线程是不可见的，因为修改后的count的值还没有被刷新回主存中去</p>
<p>解决这个问题你可以使用Java中的volatile关键字。<strong>volatile关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去</strong></p>
<p><strong>volatile 只能保证每次读取都是从主存中取的，并不能保证是最新的。每个线程从主存取值，修改，写回不是原子性的</strong>。</p>
<p>T1取值，T1加一，T2取值，T1写回，T2加一，T2写回。最后还是只加一。</p>
<p>要解决同步问题还是得上锁，或者同步代码。</p>
<p>单个的volatile并不能保证同步。</p>
<hr />
<p><strong>Race Conditions</strong></p>
<p>如果两个或者更多的线程共享一个对象，多个线程在这个共享对象上更新变量，就有可能发生race conditions。</p>
<p>想象一下，如果线程A读一个共享对象的变量count到它的CPU缓存中。再想象一下，线程B也做了同样的事情，但是往一个不同的CPU缓存中。现在线程A将count加1，线程B也做了同样的事情。现在count已经被增在了两个，每个CPU缓存中一次</p>
<p>如果这些增加操作被顺序的执行，变量count应该被增加两次，然后原值+2被写回到主存中去。</p>
<p>然而，两次增加都是在没有适当的同步下并发执行的。无论是线程A还是线程B将count修改后的版本写回到主存中取，修改后的值仅会被原值大1，尽管增加了两次。</p>
<p>下图演示了上面描述的情况：</p>
<p>解决这个问题可以使用Java同步块。<strong>一个同步块可以保证在同一时刻仅有一个线程可以进入代码的临界区。同步块还可以保证代码块中所有被访问的变量将会从主存中读入，当线程退出同步代码块时，所有被更新的变量都会被刷新回主存中去，不管这个变量是否被声明为volatile</strong></p>
<h2 id="java-synchronized"><a class="markdownIt-Anchor" href="#java-synchronized"></a> Java synchronized</h2>
<p>synchronized是Java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够<strong>保证在同一时刻最多只有一个线程执行该段代码</strong></p>
<p>Java 同步块（<strong>synchronized</strong> block）用来标记方法或者代码块是同步的。Java同步块用来避免竞争</p>
<ul>
<li>当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块</li>
<li>然而，当一个线程访问object的一个synchronized(this)同步代码块时，<strong>另一个线程</strong>仍然<strong>可以访问该object中的非synchronized(this)同步代码块</strong></li>
<li>尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，<strong>其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞</strong></li>
<li>第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。</li>
</ul>
<h3 id="线程同步"><a class="markdownIt-Anchor" href="#线程同步"></a> 线程同步</h3>
<p>当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。因此，任何一个线程都有可能在任何指令处被操作系统暂停，然后在某个时间段后继续执行。</p>
<p>这个时候，有个单线程模型下不存在的问题就来了：如果多个线程同时读写共享变量，会出现数据不一致的问题。</p>
<p>我们来看一个例子：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) throws Exception &#123;
        var add = new AddThread();
        var dec = new DecThread();
        add.start();
        dec.start();
        add.join();
        dec.join();
        System.out.println(Counter.count);
    &#125;
&#125;

class Counter &#123;
    public static int count = 0;
&#125;

class AddThread extends Thread &#123;
    public void run() &#123;
        for (int i=0; i&lt;10000; i++) &#123; Counter.count += 1; &#125;
    &#125;
&#125;

class DecThread extends Thread &#123;
    public void run() &#123;
        for (int i=0; i&lt;10000; i++) &#123; Counter.count -= 1; &#125;
    &#125;
&#125;</code></pre>
<p>上面的代码很简单，两个线程同时对一个int变量进行操作，一个加10000次，一个减10000次，最后结果应该是0，但是，每次运行，结果实际上都是不一样的。</p>
<p>这是因为对变量进行读取和写入时，结果要正确，必须保证是原子操作。<strong>原子操作是指不能被中断的一个或一系列操作</strong>。</p>
<p>例如，对于语句：</p>
<pre><code class="highlight plaintext">n = n + 1;</code></pre>
<p>看上去是一行语句，实际上对应了3条指令：</p>
<pre><code class="highlight plaintext">ILOAD
IADD
ISTORE</code></pre>
<p>我们假设n的值是100，如果两个线程同时执行n = n + 1，得到的结果很可能不是102，而是101，原因在于：</p>
<p>如果线程1在执行ILOAD后被操作系统中断，此刻如果线程2被调度执行，它执行ILOAD后获取的值仍然是100，最终结果被两个线程的ISTORE写入后变成了101，而不是期待的102。</p>
<p>这说明多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以原子方式执行：即某一个线程执行时，其他线程必须等待：</p>
<p><strong>通过加锁和解锁的操作，就能保证3条指令总是在一个线程执行期间，不会有其他线程会进入此指令区间</strong>。即使在执行期线程被操作系统中断执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。这种 <strong>加锁和解锁之间的代码块我们称之为临界区</strong>（Critical Section），任何时候临界区最多只有一个线程能执行。</p>
<p>可见，保证一段代码的原子性就是通过加锁和解锁实现的。Java程序使用<strong>synchronized关键字</strong>对一个对象进行加锁：</p>
<pre><code class="highlight plaintext">synchronized(lock) &#123;
    n = n + 1;
&#125;</code></pre>
<p>synchronized保证了代码块在任意时刻最多只有一个线程能执行。我们把上面的代码用synchronized改写如下：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) throws Exception &#123;
        var add = new AddThread();
        var dec = new DecThread();
        add.start();
        dec.start();
        add.join();
        dec.join();
        System.out.println(Counter.count);
    &#125;
&#125;

class Counter &#123;
    public static final Object lock = new Object();
    public static int count = 0;
&#125;

class AddThread extends Thread &#123;
    public void run() &#123;
        for (int i=0; i&lt;10000; i++) &#123;
            synchronized(Counter.lock) &#123;
                Counter.count += 1;
            &#125;
        &#125;
    &#125;
&#125;

class DecThread extends Thread &#123;
    public void run() &#123;
        for (int i=0; i&lt;10000; i++) &#123;
            synchronized(Counter.lock) &#123;
                Counter.count -= 1;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>它表示用Counter.lock实例作为锁，两个线程在执行各自的synchronized(Counter.lock) { … }代码块时，必须先获得锁，才能进入代码块进行。执行结束后，在synchronized语句块结束会自动释放锁。这样一来，对Counter.count变量进行读写就不可能同时进行。上述代码无论运行多少次，最终结果都是0。</p>
<p>使用synchronized解决了多线程同步访问共享变量的正确性问题。但是，它的缺点是带来了性能下降。因为synchronized代码块无法并发执行。此外，加锁和解锁需要消耗一定的时间，所以，synchronized会降低程序的执行效率。</p>
<p>我们来概括一下如何使用synchronized：</p>
<ul>
<li>找出修改共享变量的线程代码块；</li>
<li>选择一个共享实例作为锁；</li>
<li>使用synchronized(lockObject) { … }。</li>
</ul>
<p>在使用synchronized的时候，不必担心抛出异常。因为<strong>无论是否有异常，都会在synchronized结束处正确释放锁</strong>：</p>
<pre><code class="highlight plaintext">public void add(int m) &#123;
    synchronized (obj) &#123;
        if (m &lt; 0) &#123;
            throw new RuntimeException();
        &#125;
        this.value += m;
    &#125; // 无论有无异常，都会在此释放锁
&#125;</code></pre>
<p><s>我们再来看一个错误使用synchronized的例子：</s></p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) throws Exception &#123;
        var add = new AddThread();
        var dec = new DecThread();
        add.start();
        dec.start();
        add.join();
        dec.join();
        System.out.println(Counter.count);
    &#125;
&#125;

class Counter &#123;
    public static final Object lock1 = new Object();
    public static final Object lock2 = new Object();
    public static int count = 0;
&#125;

class AddThread extends Thread &#123;
    public void run() &#123;
        for (int i=0; i&lt;10000; i++) &#123;
            synchronized(Counter.lock1) &#123;
                Counter.count += 1;
            &#125;
        &#125;
    &#125;
&#125;

class DecThread extends Thread &#123;
    public void run() &#123;
        for (int i=0; i&lt;10000; i++) &#123;
            synchronized(Counter.lock2) &#123;
                Counter.count -= 1;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>结果并不是0，这是<strong>因为两个线程各自的synchronized锁住的不是同一个对象！这使得两个线程各自都可以同时获得锁：因为JVM只保证同一个锁在任意时刻只能被一个线程获取，但两个不同的锁在同一时刻可以被两个线程分别获取</strong>。</p>
<p>因此，使用synchronized的时候，获取到的是哪个锁非常重要。锁对象如果不对，代码逻辑就不对。</p>
<p>我们再看一个例子：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) throws Exception &#123;
        var ts = new Thread[] &#123; new AddStudentThread(), new DecStudentThread(), new AddTeacherThread(), new DecTeacherThread() &#125;;
        for (var t : ts) &#123;
            t.start();
        &#125;
        for (var t : ts) &#123;
            t.join();
        &#125;
        System.out.println(Counter.studentCount);
        System.out.println(Counter.teacherCount);
    &#125;
&#125;

class Counter &#123;
    public static final Object lock = new Object();
    public static int studentCount = 0;
    public static int teacherCount = 0;
&#125;

class AddStudentThread extends Thread &#123;
    public void run() &#123;
        for (int i=0; i&lt;10000; i++) &#123;
            synchronized(Counter.lock) &#123;
                Counter.studentCount += 1;
            &#125;
        &#125;
    &#125;
&#125;

class DecStudentThread extends Thread &#123;
    public void run() &#123;
        for (int i=0; i&lt;10000; i++) &#123;
            synchronized(Counter.lock) &#123;
                Counter.studentCount -= 1;
            &#125;
        &#125;
    &#125;
&#125;

class AddTeacherThread extends Thread &#123;
    public void run() &#123;
        for (int i=0; i&lt;10000; i++) &#123;
            synchronized(Counter.lock) &#123;
                Counter.teacherCount += 1;
            &#125;
        &#125;
    &#125;
&#125;

class DecTeacherThread extends Thread &#123;
    public void run() &#123;
        for (int i=0; i&lt;10000; i++) &#123;
            synchronized(Counter.lock) &#123;
                Counter.teacherCount -= 1;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>上述代码的4个线程对两个共享变量分别进行读写操作，但是使用的锁都是Counter.lock这一个对象，这就造成了原本可以并发执行的Counter.studentCount += 1和Counter.teacherCount += 1，现在无法并发执行了，执行效率大大降低。实际上，需要同步的线程可以分成两组：AddStudentThread和DecStudentThread，AddTeacherThread和DecTeacherThread，组之间不存在竞争，因此，应该使用两个不同的锁，即：</p>
<p>AddStudentThread和DecStudentThread使用lockStudent锁：</p>
<pre><code class="highlight plaintext">synchronized(Counter.lockStudent) &#123;
    ...
&#125;</code></pre>
<p>AddTeacherThread和DecTeacherThread使用lockTeacher锁：</p>
<pre><code class="highlight plaintext">synchronized(Counter.lockTeacher) &#123;
    ...
&#125;</code></pre>
<blockquote>
<p>这样才能最大化地提高执行效率。</p>
</blockquote>
<h4 id="不需要synchronized的操作"><a class="markdownIt-Anchor" href="#不需要synchronized的操作"></a> 不需要synchronized的操作</h4>
<p>JVM规范定义了几种原子操作：</p>
<ul>
<li>基本类型（long和double除外）赋值，例如：int n = m；</li>
<li>引用类型赋值，例如：List<String> list = anotherList。</li>
</ul>
<p>long和double是64位数据，JVM没有明确规定64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把long和double的赋值作为原子操作实现的。</p>
<p>单条原子操作的语句不需要同步。例如：</p>
<pre><code class="highlight plaintext">public void set(int m) &#123;
    synchronized(lock) &#123;
        this.value = m;
    &#125;
&#125;</code></pre>
<p>对引用也是类似。例如：</p>
<pre><code class="highlight plaintext">public void set(String s) &#123;
    this.value = s;
&#125;</code></pre>
<p>但是，如果是多行赋值语句，就必须保证是同步操作，例如：</p>
<pre><code class="highlight plaintext">class Pair &#123;
    int first;
    int last;
    public void set(int first, int last) &#123;
        synchronized(this) &#123;
            this.first = first;
            this.last = last;
        &#125;
    &#125;
&#125;</code></pre>
<p>有些时候，通过一些巧妙的转换，可以把非原子操作变为原子操作。例如，上述代码如果改造成：</p>
<pre><code class="highlight plaintext">class Pair &#123;
    int[] pair;
    public void set(int first, int last) &#123;
        int[] ps = new int[] &#123; first, last &#125;;
        this.pair = ps;
    &#125;
&#125;</code></pre>
<p>就不再需要同步，因为this.pair = ps是引用赋值的原子操作。而语句：</p>
<pre><code class="highlight plaintext">int[] ps = new int[] &#123; first, last &#125;;</code></pre>
<p>这里的ps是方法内部定义的局部变量，每个线程都会有各自的局部变量，互不影响，并且互不可见，并不需要同步。</p>
<h3 id="java同步关键字"><a class="markdownIt-Anchor" href="#java同步关键字"></a> Java同步关键字</h3>
<p>Java中的同步块用synchronized标记。<strong>同步块在Java中是同步在某个对象上。所有同步在一个对象上的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出</strong>。</p>
<p>有四种不同的同步块：</p>
<ul>
<li>实例方法</li>
<li>静态方法</li>
<li>实例方法中的同步块</li>
<li>静态方法中的同步块</li>
</ul>
<p>上述同步块都同步在不同对象上。实际需要那种同步块视具体情况而定</p>
<h3 id="方法同步"><a class="markdownIt-Anchor" href="#方法同步"></a> 方法同步</h3>
<p>synchronized 方法：通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。</p>
<h4 id="实例方法同步"><a class="markdownIt-Anchor" href="#实例方法同步"></a> 实例方法同步</h4>
<ul>
<li>synchronized 方法控制对类成员变量的访问：每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。</li>
<li>这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁），从而有效避免了类成员变量的访问冲突（只要所有可能访问类成员变量的方法均被声明为 synchronized）</li>
</ul>
<pre><code class="highlight plaintext">public synchronized void add(int value)&#123;
    this.count += value;
&#125;</code></pre>
<p>注意在方法声明中同步（synchronized ）关键字。这告诉Java该方法是同步的</p>
<p>Java实例方法同步是<strong>同步在拥有该方法的对象上</strong>。这样，每个实例其方法同步都同步在不同的对象上，即该方法所属的实例。只有一个线程能够在实例方法同步块中运行。如果有多个实例存在，那么一个线程一次可以在一个实例同步块中执行操作。一个实例一个线程</p>
<h4 id="静态方法同步"><a class="markdownIt-Anchor" href="#静态方法同步"></a> 静态方法同步</h4>
<p>不光是类实例，每一个类也对应一把锁，这样我们也可将类的静态成员函数声明为synchronized ，以控制其对类的静态成员变量的访问</p>
<pre><code class="highlight plaintext">public static synchronized void add(int value)&#123;
     count += value;
&#125;</code></pre>
<p>静态方法的同步是指<strong>同步在该方法所在的类对象上</strong>。因为在Java虚拟机中一个类只能对应一个类对象，所以同时只允许一个线程执行同一个类中的静态同步方法。</p>
<p>对于不同类中的静态同步方法，一个线程可以执行每个类中的静态同步方法而无需等待。不管类中的那个静态同步方法被调用，一个类只能由一个线程同时执行。</p>
<h3 id="块同步"><a class="markdownIt-Anchor" href="#块同步"></a> 块同步</h3>
<h4 id="实例方法中同步块"><a class="markdownIt-Anchor" href="#实例方法中同步块"></a> 实例方法中同步块</h4>
<p>有时你不需要同步整个方法，而是同步方法中的一部分。Java可以对方法的一部分进行同步。</p>
<p>在非同步的Java方法中的同步块的例子如下所示：</p>
<pre><code class="highlight plaintext">public void add(int value)&#123;
    synchronized(this)&#123;
       this.count += value;
    &#125;
&#125;</code></pre>
<p>示例使用Java同步块构造器来标记一块代码是同步的。该代码在执行时和同步方法一样</p>
<p>注意Java同步块构造器用括号将对象括起来。在上例中，使用了“this”，即为调用add方法的实例本身。在同步构造器中用括号括起来的对象叫做监视器对象。上述代码使用监视器对象同步，同步实例方法使用调用方法本身的实例作为监视器对象。</p>
<p>一次只有一个线程能够在同步于同一个监视器对象的Java方法内执行</p>
<p>下面两个例子都同步他们所调用的实例对象上，因此他们在同步的执行效果上是等效的。</p>
<pre><code class="highlight plaintext">public class MyClass &#123;

   public synchronized void log1(String msg1, String msg2)&#123;
      log.writeln(msg1);
      log.writeln(msg2);
   &#125;

   public void log2(String msg1, String msg2)&#123;
      synchronized(this)&#123;
         log.writeln(msg1);
         log.writeln(msg2);
      &#125;
   &#125;
 &#125;</code></pre>
<p>在上例中，每次只有一个线程能够在两个同步块中任意一个方法内执行。</p>
<p>如果第二个同步块不是同步在this实例对象上，那么两个方法可以被线程同时执行。</p>
<h4 id="静态方法中同步块"><a class="markdownIt-Anchor" href="#静态方法中同步块"></a> 静态方法中同步块</h4>
<p>和上面类似，下面是MyClass类种有两个静态方法同步的例子。这些方法同步在该方法所属的类对象上。</p>
<pre><code class="highlight plaintext">public static synchronized void log1(String msg1, String msg2)&#123;
   log.writeln(msg1);
   log.writeln(msg2);
&#125;</code></pre>
<p>对于static方法，是没有this实例的，因为static方法是针对类而不是实例。但是我们注意到任何一个类都有一个由JVM自动创建的Class实例，因此，对static方法添加synchronized，锁住的是该类的Class实例。上述synchronized static方法实际上相当于：</p>
<pre><code class="highlight plaintext">public static void log2(String msg1, String msg2)&#123;
       synchronized(MyClass.class)&#123;
          log.writeln(msg1);
          log.writeln(msg2);
       &#125;
&#125;</code></pre>
<p>这两个方法不允许同时被线程访问。</p>
<p>如果第二个同步块不是同步在MyClass.class这个对象上。那么这两个方法可以同时被线程访问</p>
<hr />
<p>我们再考察Counter的get()方法：</p>
<pre><code class="highlight plaintext">public class Counter &#123;
    private int count;

    public int get() &#123;
        return count;
    &#125;
    ...
&#125;</code></pre>
<p>它没有同步，因为读一个int变量不需要同步。然而，如果我们把代码稍微改一下，返回一个包含两个int的对象：</p>
<pre><code class="highlight plaintext">public class Counter &#123;
    private int first;
    private int last;

    public Pair get() &#123;
        Pair p = new Pair();
        p.first = first;
        p.last = last;
        return p;
    &#125;
    ...
&#125;</code></pre>
<p>就必须要同步了。</p>
<hr />
<p><strong>如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的</strong>（thread-safe），上面的Counter类就是线程安全的。Java标准库的java.lang.StringBuffer也是线程安全的。</p>
<p>还有一些不变类，例如String，Integer，LocalDate，它们的所有成员变量都是final，多线程同时访问时只能读不能写，这些不变类也是线程安全的。</p>
<p>最后，类似Math这些只提供静态方法，没有成员变量的类，也是线程安全的。</p>
<p>除了上述几种少数情况，大部分类，例如ArrayList，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么ArrayList是可以安全地在线程间共享的。</p>
<blockquote>
<p>没有特殊说明，一个类默认是非线程安全的</p>
</blockquote>
<h3 id="java同步示例"><a class="markdownIt-Anchor" href="#java同步示例"></a> Java同步示例</h3>
<p>在下面例子中，启动了两个线程，都调用Counter类同一个实例的add方法。因为同步在该方法所属的实例上，所以同时只能有一个线程访问该方法。</p>
<pre><code class="highlight plaintext">
public class Counter&#123;
     long count = 0;

     public synchronized void add(long value)&#123;
       this.count += value;
     &#125;
  &#125;
  public class CounterThread extends Thread&#123;

     protected Counter counter = null;

     public CounterThread(Counter counter)&#123;
        this.counter = counter;
     &#125;

     public void run() &#123;
        for(int i=0; i&lt;10; i++)&#123;
           counter.add(i);
        &#125;
     &#125;
  &#125;
  public class Example &#123;

    public static void main(String[] args)&#123;
      Counter counter = new Counter();
      Thread  threadA = new CounterThread(counter);
      Thread  threadB = new CounterThread(counter);

      threadA.start();
      threadB.start();
    &#125;
  &#125;</code></pre>
<p>创建了两个线程。他们的构造器引用同一个Counter实例。Counter.add方法是同步在实例上，是因为add方法是实例方法并且被标记上synchronized关键字。因此每次只允许一个线程调用该方法。另外一个线程必须要等到第一个线程退出add()方法时，才能继续执行方法</p>
<p>如果两个线程引用了两个不同的Counter实例，那么他们可以同时调用add()方法。这些方法调用了不同的对象，因此这些方法也就同步在不同的对象上。这些方法调用将不会被阻塞。如下面这个例子所示：</p>
<pre><code class="highlight plaintext">public class Example &#123;

   public static void main(String[] args)&#123;
     Counter counterA = new Counter();
     Counter counterB = new Counter();
     Thread  threadA = new CounterThread(counterA);
     Thread  threadB = new CounterThread(counterB);

     threadA.start();
     threadB.start();
   &#125;
 &#125;</code></pre>
<p>注意这两个线程，threadA和threadB，不再引用同一个counter实例。CounterA和counterB的add方法同步在他们所属的对象上。调用counterA的add方法将不会阻塞调用counterB的add方法</p>
<h2 id="线程通信"><a class="markdownIt-Anchor" href="#线程通信"></a> 线程通信</h2>
<p>线程通信的目标是使线程间能够互相发送信号。另一方面，线程通信使线程能够等待其他线程的信号</p>
<p>例如，线程B可以等待线程A的一个信号，这个信号会通知线程B数据已经准备好了。本文将讲解以下几个JAVA线程间通信的主题：</p>
<h3 id="通过共享对象通信"><a class="markdownIt-Anchor" href="#通过共享对象通信"></a> 通过共享对象通信</h3>
<p>线程间发送信号的一个简单方式是在共享对象的变量里设置信号值。线程A在一个同步块里设置boolean型成员变量hasDataToProcess为true，线程B也在同步块里读取hasDataToProcess这个成员变量。这个简单的例子使用了一个持有信号的对象，并提供了set和check方法:</p>
<pre><code class="highlight plaintext">public class MySignal&#123;
  protected boolean hasDataToProcess = false;

  public synchronized boolean hasDataToProcess()&#123;
    return this.hasDataToProcess;
  &#125;

  public synchronized void setHasDataToProcess(boolean hasData)&#123;
    this.hasDataToProcess = hasData;
  &#125;
&#125;</code></pre>
<p>线程A和B必须获得指向一个MySignal共享实例的引用，以便进行通信。如果它们持有的引用指向不同的MySingal实例，那么彼此将不能检测到对方的信号。需要处理的数据可以存放在一个共享缓存区里，它和MySignal实例是分开存放的</p>
<h3 id="忙等待busy-wait"><a class="markdownIt-Anchor" href="#忙等待busy-wait"></a> 忙等待(Busy Wait)</h3>
<p>准备处理数据的线程B正在等待数据变为可用。换句话说，它在等待线程A的一个信号，这个信号使hasDataToProcess()返回true。线程B运行在一个循环里，以等待这个信号：</p>
<pre><code class="highlight plaintext">protected MySignal sharedSignal = ...

...

while(!sharedSignal.hasDataToProcess())&#123;
  //do nothing... busy waiting
&#125;</code></pre>
<h3 id="使用wait和notify"><a class="markdownIt-Anchor" href="#使用wait和notify"></a> 使用wait和notify</h3>
<p>在Java程序中，synchronized解决了多线程竞争的问题。例如，对于一个任务管理器，多个线程同时往队列中添加任务，可以用synchronized加锁：</p>
<pre><code class="highlight plaintext">
class TaskQueue &#123;
    Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();

    public synchronized void addTask(String s) &#123;
        this.queue.add(s);
    &#125;
&#125;</code></pre>
<p>但是synchronized并没有解决多线程协调的问题。</p>
<p>仍然以上面的TaskQueue为例，我们再编写一个getTask()方法取出队列的第一个任务：</p>
<pre><code class="highlight plaintext">class TaskQueue &#123;
    Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();

    public synchronized void addTask(String s) &#123;
        this.queue.add(s);
    &#125;

    public synchronized String getTask() &#123;
        while (queue.isEmpty()) &#123;
        &#125;
        return queue.remove();
    &#125;
&#125;</code></pre>
<p>上述代码看上去没有问题：getTask()内部先判断队列是否为空，如果为空，就循环等待，直到另一个线程往队列中放入了一个任务，while()循环退出，就可以返回队列的元素了。</p>
<p>但实际上while()循环永远不会退出。因为线程在执行while()循环时，已经在getTask()入口获取了this锁，其他线程根本无法调用addTask()，因为addTask()执行条件也是获取this锁。</p>
<p>因此，执行上述代码，线程会在getTask()中因为死循环而100%占用CPU资源。</p>
<p>如果深入思考一下，我们想要的执行效果是：</p>
<ul>
<li>线程1可以调用addTask()不断往队列中添加任务；</li>
<li>线程2可以调用getTask()从队列中获取任务。如果队列为空，则getTask()应该等待，直到队列中至少有一个任务时再返回。</li>
</ul>
<p>因此，多线程协调运行的原则就是：<strong>当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务</strong>。</p>
<p>对于上述TaskQueue，我们先改造getTask()方法，在条件不满足时，线程进入等待状态：</p>
<pre><code class="highlight plaintext">
public synchronized String getTask() &#123;
    while (queue.isEmpty()) &#123;
        this.wait();
    &#125;
    return queue.remove();
&#125;</code></pre>
<p>当一个线程执行到getTask()方法内部的while循环时，它必定已经获取到了this锁，此时，线程执行while条件判断，如果条件成立（队列为空），线程将执行this.wait()，进入等待状态。</p>
<p>这里的关键是：<strong>wait()方法必须在当前获取的锁对象上调用，这里获取的是this锁，因此调用this.wait()</strong></p>
<p>调用wait()方法后，线程进入等待状态，wait()方法不会返回，直到将来某个时刻，线程从等待状态被其他线程唤醒后，wait()方法才会返回，然后，继续执行下一条语句。</p>
<p>有些仔细的童鞋会指出：即使线程在getTask()内部等待，其他线程如果拿不到this锁，照样无法执行addTask()，肿么办？</p>
<p>这个问题的关键就在于wait()方法的执行机制非常复杂。首先，它不是一个普通的Java方法，而是<strong>定义在Object类的一个native方法</strong>，也就是由JVM的C代码实现的。其次，<strong>必须在synchronized块中才能调用wait()方法，因为wait()方法调用时，会释放线程获得的锁，wait()方法返回后，线程又会重新试图获得锁</strong>。</p>
<p>因此，只能在锁对象上调用wait()方法。因为在getTask()中，我们获得了this锁，因此，只能在this对象上调用wait()方法：</p>
<pre><code class="highlight plaintext">
public synchronized String getTask() &#123;
    while (queue.isEmpty()) &#123;
        // 释放this锁:
        this.wait();
        // 重新获取this锁
    &#125;
    return queue.remove();
&#125;</code></pre>
<p>当一个线程在this.wait()等待时，它就会释放this锁，从而使得其他线程能够在addTask()方法获得this锁。</p>
<p>现在我们面临第二个问题：如何让等待的线程被重新唤醒，然后从wait()方法返回？答案是在相同的锁对象上调用notify()方法。我们修改addTask()如下：</p>
<pre><code class="highlight plaintext">public synchronized void addTask(String s) &#123;
    this.queue.add(s);
    this.notify(); // 唤醒在this锁等待的线程
&#125;</code></pre>
<p>注意到在往队列中添加了任务后，线程立刻对this锁对象调用notify()方法，这个方法会唤醒一个正在this锁等待的线程（就是在getTask()中位于this.wait()的线程），从而使得等待线程从this.wait()方法返回。</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        var q = new TaskQueue();
        var ts = new ArrayList&lt;Thread&gt;();
        for (int i=0; i&lt;5; i++) &#123;
            var t = new Thread() &#123;
                public void run() &#123;
                    // 执行task:
                    while (true) &#123;
                        try &#123;
                            String s = q.getTask();
                            System.out.println(&quot;execute task: &quot; + s);
                        &#125; catch (InterruptedException e) &#123;
                            return;
                        &#125;
                    &#125;
                &#125;
            &#125;;
            t.start();
            ts.add(t);
        &#125;
        var add = new Thread(() -&gt; &#123;
            for (int i=0; i&lt;10; i++) &#123;
                // 放入task:
                String s = &quot;t-&quot; + Math.random();
                System.out.println(&quot;add task: &quot; + s);
                q.addTask(s);
                try &#123; Thread.sleep(100); &#125; catch(InterruptedException e) &#123;&#125;
            &#125;
        &#125;);
        add.start();
        add.join();
        Thread.sleep(100);
        for (var t : ts) &#123;
            t.interrupt();
        &#125;
    &#125;
&#125;

class TaskQueue &#123;
    Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();

    public synchronized void addTask(String s) &#123;
        this.queue.add(s);
        this.notifyAll();
    &#125;

    public synchronized String getTask() throws InterruptedException &#123;
        while (queue.isEmpty()) &#123;
            this.wait();
        &#125;
        return queue.remove();
    &#125;
&#125;
</code></pre>
<p>这个例子中，我们重点关注addTask()方法，内部调用了this.notifyAll()而不是this.notify()，使用notifyAll()将唤醒所有当前正在this锁等待的线程，而notify()只会唤醒其中一个（具体哪个依赖操作系统，有一定的随机性）。这是因为可能有多个线程正在getTask()方法内部的wait()中等待，使用notifyAll()将一次性全部唤醒。通常来说，notifyAll()更安全。有些时候，如果我们的代码逻辑考虑不周，用notify()会导致只唤醒了一个线程，而其他线程可能永远等待下去醒不过来了。</p>
<p>但是，注意到wait()方法返回时需要重新获得this锁。假设当前有3个线程被唤醒，唤醒后，首先要等待执行addTask()的线程结束此方法后，才能释放this锁，随后，这3个线程中只能有一个获取到this锁，剩下两个将继续等待。</p>
<p>再注意到我们在while()循环中调用wait()，而不是if语句：</p>
<pre><code class="highlight plaintext">
public synchronized String getTask() throws InterruptedException &#123;
    if (queue.isEmpty()) &#123;
        this.wait();
    &#125;
    return queue.remove();
&#125;</code></pre>
<p>这种写法实际上是错误的，因为线程被唤醒时，需要再次获取this锁。多个线程被唤醒后，只有一个线程能获取this锁，此刻，该线程执行queue.remove()可以获取到队列的元素，然而，剩下的线程如果获取this锁后执行queue.remove()，此刻队列可能已经没有任何元素了，所以，要始终在while循环中wait()，并且每次被唤醒后拿到this锁就必须再次判断：</p>
<pre><code class="highlight plaintext">while (queue.isEmpty()) &#123;
    this.wait();
&#125;</code></pre>
<p>所以，正确编写多线程代码是非常困难的，需要仔细考虑的条件非常多，任何一个地方考虑不周，都会导致多线程运行时不正常。</p>
<h3 id="waitnotifynotifyall"><a class="markdownIt-Anchor" href="#waitnotifynotifyall"></a> wait()/notify()/notifyAll()</h3>
<p>忙等待没有对运行等待线程的CPU进行有效的利用，除非平均等待时间非常短。否则，让等待线程进入睡眠或者非运行状态更为明智，直到它接收到它等待的信号</p>
<p><strong>Java有一个内建的等待机制来允许线程在等待信号的时候变为非运行状态</strong>。</p>
<p>java.lang.Object 类定义了三个方法，来实现这个等待机制：</p>
<ul>
<li>wait()</li>
<li>notify()</li>
<li>notifyAll()</li>
</ul>
<p><strong>一个线程一旦调用了_任意对象_的wait()方法，就会变为非运行状态，直到另一个线程调用了同一个对象的notify()方法</strong></p>
<p>为了调用wait()或者notify()，线程必须先获得那个对象的锁。也就是说，线程必须在同步块里调用wait()或者notify()。以下是MySingal的修改版本——使用了wait()和notify()的MyWaitNotify：</p>
<pre><code class="highlight plaintext">
public class MonitorObject&#123;
&#125;

public class MyWaitNotify&#123;

  MonitorObject myMonitorObject = new MonitorObject();

  public void doWait()&#123;
    synchronized(myMonitorObject)&#123;
      try&#123;
        myMonitorObject.wait();
      &#125; catch(InterruptedException e)&#123;...&#125;
    &#125;
  &#125;

  public void doNotify()&#123;
    synchronized(myMonitorObject)&#123;
      myMonitorObject.notify();
    &#125;
  &#125;
&#125;</code></pre>
<p>等待线程将调用doWait()，而唤醒线程将调用doNotify()。当一个线程<strong>调用一个对象的notify()方法</strong>，正在等待该对象的<strong>所有线程中将有一个线程被唤醒并允许执行</strong>（校注：这个将被唤醒的线程是<strong>随机</strong>的，不可以指定唤醒哪个线程）</p>
<p>同时也提供了一个<strong>notifyAll()方法来唤醒正在等待一个给定对象的所有线程</strong></p>
<p>如你所见，不管是等待线程还是唤醒线程都在同步块里调用wait()和notify()。这是强制性的！<strong>一个线程如果没有持有对象锁，将不能调用</strong>wait()，notify()或者notifyAll()。否则，会抛出IllegalMonitorStateException异常</p>
<blockquote>
<p>（校注：JVM是这么实现的，当你调用wait时候它首先要检查下当前线程是否是锁的拥有者，不是则抛出IllegalMonitorStateExcept，参考JVM源码的 1422行。）</p>
</blockquote>
<p>但是，这怎么可能？等待线程在同步块里面执行的时候，不是一直持有监视器对象（myMonitor对象）的锁吗？等待线程不能阻塞唤醒线程进入doNotify()的同步块吗？答案是：的确不能。<strong>一旦线程调用了wait()方法，它就释放了所持有的监视器对象上的锁</strong>。这将允许其他线程也可以调用wait()或者notify()。</p>
<p><strong>一旦一个线程被唤醒，不能立刻就退出wait()的方法调用，直到调用notify()的线程退出了它自己的同步块。换句话说：被唤醒的线程必须重新获得监视器对象的锁，才可以退出wait()的方法调用，因为wait方法调用运行在同步块里面。如果多个线程被notifyAll()唤醒，那么在同一时刻将只有一个线程可以退出wait()方法，因为每个线程在退出wait()前必须获得监视器对象的锁</strong>。</p>
<h4 id="丢失的信号"><a class="markdownIt-Anchor" href="#丢失的信号"></a> 丢失的信号</h4>
<p>notify()和notifyAll()方法不会保存调用它们的方法，因为当这两个方法被调用时，有可能没有线程处于等待状态。通知信号过后便丢弃了。因此，<strong>如果一个线程先于被通知线程调用wait()前调用了notify()，等待的线程将错过这个信号</strong>。这可能是也可能不是个问题。不过，在某些情况下，这可能使等待线程永远在等待，不再醒来，因为线程错过了唤醒信号。</p>
<p>为了避免丢失信号，必须把它们保存在信号类里。在MyWaitNotify的例子中，通知信号应被存储在MyWaitNotify实例的一个成员变量里。以下是MyWaitNotify的修改版本：</p>
<pre><code class="highlight plaintext">
public class MyWaitNotify2&#123;

  MonitorObject myMonitorObject = new MonitorObject();
  boolean wasSignalled = false;

  public void doWait()&#123;
    synchronized(myMonitorObject)&#123;
      if(!wasSignalled)&#123;
        try&#123;
          myMonitorObject.wait();
         &#125; catch(InterruptedException e)&#123;...&#125;
      &#125;
      //clear signal and continue running.
      wasSignalled = false;
    &#125;
  &#125;

  public void doNotify()&#123;
    synchronized(myMonitorObject)&#123;
      wasSignalled = true;
      myMonitorObject.notify();
    &#125;
  &#125;
&#125;</code></pre>
<p>留意doNotify()方法在调用notify()前把wasSignalled变量设为true。同时，留意doWait()方法在调用wait()前会检查wasSignalled变量。事实上，如果没有信号在前一次doWait()调用和这次doWait()调用之间的时间段里被接收到，它将只调用wait()。</p>
<blockquote>
<p>（校注：为了避免信号丢失， 用一个变量来保存是否被通知过。在notify前，设置自己已经被通知过。在wait后，设置自己没有被通知过，需要等待通知。）</p>
</blockquote>
<h4 id="假唤醒"><a class="markdownIt-Anchor" href="#假唤醒"></a> 假唤醒</h4>
<p>由于莫名其妙的原因，线程有可能在没有调用过notify()和notifyAll()的情况下醒来。这就是所谓的假唤醒（spurious wakeups）。无端端地醒过来了。</p>
<p>如果在MyWaitNotify2的doWait()方法里发生了假唤醒，等待线程即使没有收到正确的信号，也能够执行后续的操作。这可能导致你的应用程序出现严重问题。</p>
<p>为了防止假唤醒，保存信号的成员变量将在一个while循环里接受检查，而不是在if表达式里。这样的一个while循环叫做自旋锁（校注：<strong>这种做法要慎重，目前的JVM实现自旋会消耗CPU，如果长时间不调用doNotify方法，doWait方法会一直自旋，CPU会消耗太大</strong>）。被唤醒的线程会自旋直到自旋锁(while循环)里的条件变为false。以下MyWaitNotify2的修改版本展示了这点：</p>
<pre><code class="highlight plaintext">
public class MyWaitNotify3&#123;

  MonitorObject myMonitorObject = new MonitorObject();
  boolean wasSignalled = false;

  public void doWait()&#123;
    synchronized(myMonitorObject)&#123;
      while(!wasSignalled)&#123;
        try&#123;
          myMonitorObject.wait();
         &#125; catch(InterruptedException e)&#123;...&#125;
      &#125;
      //clear signal and continue running.
      wasSignalled = false;
    &#125;
  &#125;

  public void doNotify()&#123;
    synchronized(myMonitorObject)&#123;
      wasSignalled = true;
      myMonitorObject.notify();
    &#125;
  &#125;
&#125;</code></pre>
<p>留意wait()方法是在while循环里，而不在if表达式里。如果等待线程没有收到信号就唤醒，wasSignalled变量将变为false,while循环会再执行一次，促使醒来的线程回到等待状态。</p>
<h3 id="多线程等待相同信号"><a class="markdownIt-Anchor" href="#多线程等待相同信号"></a> 多线程等待相同信号</h3>
<p>如果你有多个线程在等待，被notifyAll()唤醒，但只有一个被允许继续执行，使用while循环也是个好方法。每次只有一个线程可以获得监视器对象锁，意味着只有一个线程可以退出wait()调用并清除wasSignalled标志（设为false）。一旦这个线程退出doWait()的同步块，其他线程退出wait()调用，并在while循环里检查wasSignalled变量值。但是，这个标志已经被第一个唤醒的线程清除了，所以其余醒来的线程将回到等待状态，直到下次信号到来。</p>
<h3 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h3>
<p>Semaphore（信号量） 是一个线程同步结构，用于在线程间传递信号，以避免出现信号丢失，或者像锁一样用于保护一个关键区域。自从5.0开始，jdk在 <strong>java.util.concurrent包里提供了Semaphore 的官方实现</strong>，因此大家不需要自己去实现Semaphore。但是还是很有必要去熟悉如何使用Semaphore及其背后的原理</p>
<h4 id="简单的semaphore实现"><a class="markdownIt-Anchor" href="#简单的semaphore实现"></a> 简单的Semaphore实现</h4>
<pre><code class="highlight plaintext">
public class Semaphore &#123;
    private boolean signal = false;
    public synchronized void take() &#123;
        this.signal = true;
        this.notify();
    &#125;
    public synchronized void release() throws InterruptedException&#123;
        while(!this.signal) wait();
        this.signal = false;
    &#125;
&#125;</code></pre>
<p>Take方法发出一个被存放在Semaphore内部的信号，而Release方法则等待一个信号，当其接收到信号后，标记位signal被清空，然后该方法终止。</p>
<p>使用这个semaphore可以避免错失某些信号通知。<strong>用take方法来代替notify，release方法来代替wait</strong>。<strong>如果某线程在调用release等待之前调用take方法，那么调用release方法的线程仍然知道take方法已经被某个线程调用过了</strong>，因为该Semaphore内部保存了take方法发出的信号。而wait和notify方法就没有这样的功能。</p>
<p>当用semaphore来产生信号时，take和release这两个方法名看起来有点奇怪。这两个名字来源于后面把semaphore当做锁的例子，后面会详细介绍这个例子，在该例子中，take和release这两个名字会变得很合理。</p>
<h4 id="使用semaphore来发送信号"><a class="markdownIt-Anchor" href="#使用semaphore来发送信号"></a> 使用Semaphore来发送信号</h4>
<p>下面的例子中，两个线程通过Semaphore发出的信号来通知对方</p>
<pre><code class="highlight plaintext">public static void main(String args[])&#123;
    //信号量
    Semaphore semaphore = new Semaphore();

    SendingThread sender = new SendingThread(semaphore)；
    ReceivingThread receiver = new ReceivingThread(semaphore);
    receiver.start();
    sender.start();
&#125;

public class SendingThread &#123;
    Semaphore semaphore = null;
    public SendingThread(Semaphore semaphore)&#123;
       this.semaphore = semaphore;
    &#125;
    public void run()&#123;
        while(true)&#123;
           //do something, then signal
            this.semaphore.take();
        &#125;
    &#125;
&#125;
public class RecevingThread &#123;
    Semaphore semaphore = null;
    public ReceivingThread(Semaphore semaphore)&#123;
        this.semaphore = semaphore;
    &#125;
    public void run()&#123;
        while(true)&#123;
         this.semaphore.release();
           //receive signal, then do something...
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="可计数的semaphore"><a class="markdownIt-Anchor" href="#可计数的semaphore"></a> 可计数的Semaphore</h4>
<p>上面提到的Semaphore的简单实现并没有计算通过调用take方法所产生信号的数量。可以把它改造成具有计数功能的Semaphore。下面是一个可计数的Semaphore的简单实现。</p>
<pre><code class="highlight plaintext">
public class CountingSemaphore &#123;

    private int signals = 0;

    public synchronized void take() &#123;
     this.signals++;
       this.notify();
    &#125;
    public synchronized void release() throws InterruptedException&#123;
       while(this.signals == 0) wait();
       this.signals--;
    &#125;
&#125;</code></pre>
<h4 id="有上限的semaphore"><a class="markdownIt-Anchor" href="#有上限的semaphore"></a> 有上限的Semaphore</h4>
<p>上面的CountingSemaphore并没有限制信号的数量。下面的代码将CountingSemaphore改造成一个信号数量有上限的BoundedSemaphore。</p>
<pre><code class="highlight plaintext">
public class BoundedSemaphore &#123;

private int signals = 0;

private int bound   = 0;

    public BoundedSemaphore(int upperBound)&#123;
     this.bound = upperBound;
    &#125;
    public synchronized void take() throws InterruptedException&#123;
        while(this.signals == bound) wait();
        this.signals++;
        this.notify();
    &#125;
    public synchronized void release() throws InterruptedException&#123;
        while(this.signals == 0) wait();
        this.signals--;
        this.notify();
    &#125;
&#125;</code></pre>
<p>在BoundedSemaphore中，当已经产生的信号数量达到了上限，take方法将阻塞新的信号产生请求，直到某个线程调用release方法后，被阻塞于take方法的线程才能传递自己的信号。</p>
<h4 id="把semaphore当锁来用"><a class="markdownIt-Anchor" href="#把semaphore当锁来用"></a> 把Semaphore当锁来用</h4>
<p>当信号量的数量上限是1时，Semaphore可以被当做锁来使用。通过take和release方法来保护关键区域。请看下面的例子：</p>
<pre><code class="highlight plaintext">BoundedSemaphore semaphore = new BoundedSemaphore(1);
...
semaphore.take();
try&#123;
    //critical section
&#125; finally &#123;
    semaphore.release();
&#125;</code></pre>
<p>在前面的例子中，Semaphore被用来在多个线程之间传递信号，这种情况下，take和release分别被不同的线程调用。但是在锁这个例子中，take和release方法将被同一线程调用，因为只允许一个线程来获取信号（允许进入关键区域的信号），其它调用take方法获取信号的线程将被阻塞，知道第一个调用take方法的线程调用release方法来释放信号。对release方法的调用永远不会被阻塞，这是因为任何一个线程都是先调用take方法，然后再调用release。</p>
<p>通过有上限的Semaphore可以限制进入某代码块的线程数量。设想一下，在上面的例子中，如果BoundedSemaphore 上限设为5将会发生什么？意味着允许5个线程同时访问关键区域，但是你必须保证，这个5个线程不会互相冲突。否则你的应用程序将不能正常运行。</p>
<p>必须注意，release方法应当在finally块中被执行。这样可以保在关键区域的代码抛出异常的情况下，信号也一定会被释放。</p>
<h3 id="不要对常量字符串或者全局对象调用wait"><a class="markdownIt-Anchor" href="#不要对常量字符串或者全局对象调用wait"></a> 不要对常量字符串或者全局对象调用wait()</h3>
<p>（校注：本章说的字符串常量指的是值为常量的变量）</p>
<p>本文早期的一个版本在MyWaitNotify例子里使用字符串常量（””）作为管程对象。以下是那个例子：</p>
<pre><code class="highlight plaintext">
public class MyWaitNotify&#123;

  String myMonitorObject = &quot;&quot;;
  boolean wasSignalled = false;

  public void doWait()&#123;
    synchronized(myMonitorObject)&#123;
      while(!wasSignalled)&#123;
        try&#123;
          myMonitorObject.wait();
         &#125; catch(InterruptedException e)&#123;...&#125;
      &#125;
      //clear signal and continue running.
      wasSignalled = false;
    &#125;
  &#125;

  public void doNotify()&#123;
    synchronized(myMonitorObject)&#123;
      wasSignalled = true;
      myMonitorObject.notify();
    &#125;
  &#125;
&#125;</code></pre>
<p>在空字符串作为锁的同步块(或者其他常量字符串)里调用wait()和notify()产生的问题是，JVM/编译器内部会把常量字符串转换成同一个对象。这意味着，即使你有2个不同的MyWaitNotify实例，它们都引用了相同的空字符串实例。同时也意味着存在这样的风险：在第一个MyWaitNotify实例上调用doWait()的线程会被在第二个MyWaitNotify实例上调用doNotify()的线程唤醒。这种情况可以画成以下这张图：</p>
<p>起初这可能不像个大问题。毕竟，如果doNotify()在第二个MyWaitNotify实例上被调用，真正发生的事不外乎线程A和B被错误的唤醒了 。这个被唤醒的线程（A或者B）将在while循环里检查信号值，然后回到等待状态，因为doNotify()并没有在第一个MyWaitNotify实例上调用，而这个正是它要等待的实例。这种情况相当于引发了一次假唤醒。线程A或者B在信号值没有更新的情况下唤醒。但是代码处理了这种情况，所以线程回到了等待状态。记住，即使4个线程在相同的共享字符串实例上调用wait()和notify()，doWait()和doNotify()里的信号还会被2个MyWaitNotify实例分别保存。在MyWaitNotify1上的一次doNotify()调用可能唤醒MyWaitNotify2的线程，但是信号值只会保存在MyWaitNotify1里。</p>
<p>问题在于，由于doNotify()仅调用了notify()而不是notifyAll()，即使有4个线程在相同的字符串（空字符串）实例上等待，只能有一个线程被唤醒。所以，如果线程A或B被发给C或D的信号唤醒，它会检查自己的信号值，看看有没有信号被接收到，然后回到等待状态。而C和D都没被唤醒来检查它们实际上接收到的信号值，这样信号便丢失了。这种情况相当于前面所说的丢失信号的问题。C和D被发送过信号，只是都不能对信号作出回应。</p>
<p>如果doNotify()方法调用notifyAll()，而非notify()，所有等待线程都会被唤醒并依次检查信号值。线程A和B将回到等待状态，但是C或D只有一个线程注意到信号，并退出doWait()方法调用。C或D中的另一个将回到等待状态，因为获得信号的线程在退出doWait()的过程中清除了信号值(置为false)。</p>
<p>看过上面这段后，你可能会设法使用notifyAll()来代替notify()，但是这在性能上是个坏主意。在只有一个线程能对信号进行响应的情况下，没有理由每次都去唤醒所有线程。</p>
<p>所以：<strong>在wait()/notify()机制中，不要使用全局对象，字符串常量等。应该使用对应唯一的对象</strong>。例如，每一个MyWaitNotify3的实例（前一节的例子）拥有一个属于自己的监视器对象，而不是在空字符串上调用wait()/notify()。</p>
<h2 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h2>
<p>Java的线程锁是可重入的锁。什么是可重入的锁？我们还是来看例子：</p>
<pre><code class="highlight plaintext">
public class Counter &#123;
    private int count = 0;

    public synchronized void add(int n) &#123;
        if (n &lt; 0) &#123;
            dec(-n);
        &#125; else &#123;
            count += n;
        &#125;
    &#125;

    public synchronized void dec(int n) &#123;
        count += n;
    &#125;
&#125;</code></pre>
<p>观察synchronized修饰的add()方法，一旦线程执行到add()方法内部，说明它已经获取了当前实例的this锁。如果传入的n &lt; 0，将在add()方法内部调用dec()方法。</p>
<p>由于dec()方法也需要获取this锁，现在问题来了：对同一个线程，能否在获取到锁以后继续获取同一个锁？</p>
<p>答案是肯定的。JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做<strong>可重入锁</strong>。</p>
<p>由于Java的线程锁是可重入锁，所以，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出synchronized块，记录-1，减到0的时候，才会真正释放锁。</p>
<p><strong>死锁</strong></p>
<p>一个线程可以获取一个锁后，再继续获取另一个锁。例如：</p>
<pre><code class="highlight plaintext">
public void add(int m) &#123;
    synchronized(lockA) &#123; // 获得lockA的锁
        this.value += m;
        synchronized(lockB) &#123; // 获得lockB的锁
            this.another += m;
        &#125; // 释放lockB的锁
    &#125; // 释放lockA的锁
&#125;

public void dec(int m) &#123;
    synchronized(lockB) &#123; // 获得lockB的锁
        this.another -= m;
        synchronized(lockA) &#123; // 获得lockA的锁
            this.value -= m;
        &#125; // 释放lockA的锁
    &#125; // 释放lockB的锁
&#125;</code></pre>
<p>在获取多个锁的时候，不同线程获取多个不同对象的锁可能导致死锁。对于上述代码，线程1和线程2如果分别执行add()和dec()方法时：</p>
<ul>
<li>线程1：进入add()，获得lockA；</li>
<li>线程2：进入dec()，获得lockB。</li>
</ul>
<p>随后：</p>
<ul>
<li>线程1：准备获得lockB，失败，等待中；</li>
<li>线程2：准备获得lockA，失败，等待中。</li>
</ul>
<p>此时，两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，这就是死锁。</p>
<p>死锁发生后，没有任何机制能解除死锁，<strong>只能强制结束JVM进程</strong>。因此，在编写多线程应用时，要特别注意防止死锁。因为死锁一旦形成，就只能强制结束进程。那么我们应该如何避免死锁呢？</p>
<p>答案是：线程获取锁的顺序要一致。即严格按照先获取lockA，再获取lockB的顺序，改写dec()方法如下：</p>
<pre><code class="highlight plaintext">
public void dec(int m) &#123;
    synchronized(lockA) &#123; // 获得lockA的锁
        this.value -= m;
        synchronized(lockB) &#123; // 获得lockB的锁
            this.another -= m;
        &#125; // 释放lockB的锁
    &#125; // 释放lockA的锁
&#125;</code></pre>
<h3 id="死锁的产生"><a class="markdownIt-Anchor" href="#死锁的产生"></a> 死锁的产生</h3>
<p>死锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候</p>
<p>例如，如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。</p>
<pre><code class="highlight plaintext">Thread 1  locks A, waits for B
Thread 2  locks B, waits for A</code></pre>
<p>这里有一个TreeNode类的例子，它调用了不同实例的synchronized方法：</p>
<pre><code class="highlight plaintext">
public class TreeNode &#123;
        TreeNode parent   = null;  
        List children = new ArrayList();

        public synchronized void addChild(TreeNode child)&#123;
                if(!this.children.contains(child)) &#123;
                        this.children.add(child);
                        child.setParentOnly(this);
                &#125;
        &#125;
  
        public synchronized void addChildOnly(TreeNode child)&#123;
                if(!this.children.contains(child)&#123;
                        this.children.add(child);
                &#125;
        &#125;
  
        public synchronized void setParent(TreeNode parent)&#123;
                this.parent = parent;
                parent.addChildOnly(this);
        &#125;

        public synchronized void setParentOnly(TreeNode parent)&#123;
                this.parent = parent;
        &#125;
&#125;</code></pre>
<p>如果线程1调用parent.addChild(child)方法的同时有另外一个线程2调用child.setParent(parent)方法，两个线程中的parent表示的是同一个对象，child亦然，此时就会发生死锁。下面的伪代码说明了这个过程：</p>
<pre><code class="highlight plaintext">Thread 1: parent.addChild(child); //locks parent
          --&gt; child.setParentOnly(parent);

Thread 2: child.setParent(parent); //locks child
          --&gt; parent.addChildOnly()</code></pre>
<p>首先线程1调用parent.addChild(child)。因为addChild()是同步的，所以线程1会对parent对象加锁以不让其它线程访问该对象。</p>
<p>然后线程2调用child.setParent(parent)。因为setParent()是同步的，所以线程2会对child对象加锁以不让其它线程访问该对象。</p>
<p>现在child和parent对象被两个不同的线程锁住了。接下来线程1尝试调用child.setParentOnly()方法，但是由于child对象现在被线程2锁住的，所以该调用会被阻塞。线程2也尝试调用parent.addChildOnly()，但是由于parent对象现在被线程1锁住，导致线程2也阻塞在该方法处。现在两个线程都被阻塞并等待着获取另外一个线程所持有的锁。</p>
<blockquote>
<p>注意：像上文描述的，这两个线程需要同时调用parent.addChild(child)和child.setParent(parent)方法，并且是同一个parent对象和同一个child对象，才有可能发生死锁。上面的代码可能运行一段时间才会出现死锁。</p>
</blockquote>
<p>这些线程需要同时获得锁。举个例子，如果线程1稍微领先线程2，然后成功地锁住了A和B两个对象，那么线程2就会在尝试对B加锁的时候被阻塞，这样死锁就不会发生。因为线程调度通常是不可预测的，因此没有一个办法可以准确预测什么时候死锁会发生，仅仅是可能会发生。</p>
<hr />
<p><strong>更复杂的死锁</strong></p>
<p>死锁可能不止包含2个线程，这让检测死锁变得更加困难。下面是4个线程发生死锁的例子：</p>
<pre><code class="highlight plaintext">Thread 1  locks A, waits for B
Thread 2  locks B, waits for C
Thread 3  locks C, waits for D
Thread 4  locks D, waits for A</code></pre>
<p>线程1等待线程2，线程2等待线程3，线程3等待线程4，线程4等待线程1。</p>
<hr />
<p><strong>数据库的死锁</strong></p>
<p>更加复杂的死锁场景发生在数据库事务中。一个数据库事务可能由多条SQL更新请求组成。当在一个事务中更新一条记录，这条记录就会被锁住避免其他事务的更新请求，直到第一个事务结束。同一个事务中每一个更新请求都可能会锁住一些记录</p>
<p>当多个事务同时需要对一些相同的记录做更新操作时，就很有可能发生死锁，例如：</p>
<pre><code class="highlight plaintext">Transaction 1, request 1, locks record 1 for update
Transaction 2, request 1, locks record 2 for update
Transaction 1, request 2, tries to lock record 2 for update.
Transaction 2, request 2, tries to lock record 1 for update.</code></pre>
<p>因为锁发生在不同的请求中，并且对于一个事务来说不可能提前知道所有它需要的锁，因此很难检测和避免数据库事务中的死锁。</p>
<h3 id="避免死锁"><a class="markdownIt-Anchor" href="#避免死锁"></a> 避免死锁</h3>
<p>在有些情况下死锁是可以避免的。本文将展示三种用于避免死锁的技术：</p>
<ul>
<li>加锁顺序</li>
<li>加锁时限</li>
<li>死锁检测</li>
</ul>
<h4 id="加锁顺序"><a class="markdownIt-Anchor" href="#加锁顺序"></a> 加锁顺序</h4>
<p>当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。</p>
<p><strong>如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生</strong>。看下面这个例子：</p>
<pre><code class="highlight plaintext">Thread 1:
  lock A 
  lock B

Thread 2:
   wait for A
   lock C (when A locked)

Thread 3:
   wait for A
   wait for B
   wait for C</code></pre>
<p>如果一个线程（比如线程3）需要一些锁，那么它必须按照确定的顺序获取锁。它只有获得了从顺序上排在前面的锁之后，才能获取后面的锁。</p>
<p>例如，线程2和线程3只有在获取了锁A之后才能尝试获取锁C(译者注：获取锁A是获取锁C的必要条件)。因为线程1已经拥有了锁A，所以线程2和3需要一直等到锁A被释放。然后在它们尝试对B或C加锁之前，必须成功地对A加了锁。</p>
<p>按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁(译者注：并对这些锁做适当的排序)，但总有些时候是无法预知的。</p>
<h4 id="加锁时限"><a class="markdownIt-Anchor" href="#加锁时限"></a> 加锁时限</h4>
<p>另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行(译者注：加锁超时后可以先继续运行干点其它事情，再回头来重复之前加锁的逻辑)。</p>
<p>以下是一个例子，展示了两个线程以不同的顺序尝试获取相同的两个锁，在发生超时后回退并重试的场景：</p>
<pre><code class="highlight plaintext">Thread 1 locks A
Thread 2 locks B

Thread 1 attempts to lock B but is blocked
Thread 2 attempts to lock A but is blocked

Thread 1&#x27;s lock attempt on B times out
Thread 1 backs up and releases A as well
Thread 1 waits randomly (e.g. 257 millis) before retrying.

Thread 2&#x27;s lock attempt on A times out
Thread 2 backs up and releases B as well
Thread 2 waits randomly (e.g. 43 millis) before retrying.</code></pre>
<p>在上面的例子中，线程2比线程1早200毫秒进行重试加锁，因此它可以先成功地获取到两个锁。这时，线程1尝试获取锁A并且处于等待状态。当线程2结束时，线程1也可以顺利的获得这两个锁（除非线程2或者其它线程在线程1成功获得两个锁之前又获得其中的一些锁）。</p>
<p>需要注意的是，由于存在锁的超时，所以我们不能认为这种场景就一定是出现了死锁。也可能是因为获得了锁的线程（导致其它线程超时）需要很长的时间去完成它的任务。</p>
<p>此外，如果有非常多的线程同一时间去竞争同一批资源，就算有超时和回退机制，还是可能会导致这些线程重复地尝试但却始终得不到锁。如果只有两个线程，并且重试的超时时间设定为0到500毫秒之间，这种现象可能不会发生，但是如果是10个或20个线程情况就不同了。因为这些线程等待相等的重试时间的概率就高的多（或者非常接近以至于会出现问题）。</p>
<p>这种机制存在一个问题，在Java中不能对synchronized同步块设置超时时间。你需要创建一个自定义锁，或使用Java5中java.util.concurrent包下的工具。写一个自定义锁类不复杂，但超出了本文的内容。后续的Java并发系列会涵盖自定义锁的内容。</p>
<h4 id="死锁检测"><a class="markdownIt-Anchor" href="#死锁检测"></a> 死锁检测</h4>
<p>死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。</p>
<p><strong>每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中</strong>。</p>
<p>当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）</p>
<p>当然，死锁一般要比两个线程互相持有对方的锁这种情况要复杂的多。线程A等待线程B，线程B等待线程C，线程C等待线程D，线程D又在等待线程A。线程A为了检测死锁，它需要递进地检测所有被B请求的锁。从线程B所请求的锁开始，线程A找到了线程C，然后又找到了线程D，发现线程D请求的锁被线程A自己持有着。这是它就知道发生了死锁。</p>
<p>下面是一幅关于四个线程（A,B,C和D）之间锁占有和请求的关系图。像这样的数据结构就可以被用来检测死锁。</p>
<p>那么当检测出死锁时，这些线程该做些什么呢？</p>
<p>一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁（编者注：原因同超时类似，不能从根本上减轻竞争）。</p>
<p>一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。</p>
<h2 id="饥饿与公平"><a class="markdownIt-Anchor" href="#饥饿与公平"></a> 饥饿与公平</h2>
<p>如果一个线程因为CPU时间全部被其他线程抢走而得不到CPU运行时间，这种状态被称之为“饥饿”。而该线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。解决饥饿的方案被称之为“公平性” – 即所有线程均能公平地获得运行机会</p>
<p><strong>Java中导致饥饿的原�</strong>�</p>
<ul>
<li><strong>高优先级线程吞噬所有的低优先级线程的CPU时间</strong>。
<ul>
<li>你能为每个线程设置独自的线程优先级，优先级越高的线程获得的CPU时间越多，线程优先级值设置在1到10之间，而这些优先级值所表示行为的准确解释则依赖于你的应用运行平台。对大多数应用来说，你最好是不要改变其优先级值。</li>
</ul>
</li>
<li><strong>线程被永久堵塞在一个等待进入同步块的状态</strong>，因为其他线程总是能在它之前持续地对该同步块进行访问。
<ul>
<li>Java的同步代码区也是一个导致饥饿的因素。Java的同步代码区对哪个线程允许进入的次序没有任何保障。这就意味着理论上存在一个试图进入该同步区的线程处于被永久堵塞的风险，因为其他线程总是能持续地先于它获得访问，这即是“饥饿”问题，而一个线程被“饥饿致死”正是因为它得不到CPU运行时间的机会</li>
</ul>
</li>
<li><strong>线程在等待一个本身也处于永久等待完成的对象</strong>(比如调用这个对象的wait方法)，因为其他线程总是被持续地获得唤醒。
<ul>
<li>如果多个线程处在wait()方法执行上，而对其调用notify()不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。</li>
</ul>
</li>
</ul>
<hr />
<p><strong>在Java中实现公平性方案，需要:</strong></p>
<ul>
<li>使用锁，而不是同步块。</li>
<li>公平锁。</li>
<li>注意性能方面。</li>
</ul>
<p>虽Java不可能实现100%的公平性，我们依然可以通过同步结构在线程间实现公平性的提高。</p>
<p>首先来学习一段简单的同步态代码：</p>
<pre><code class="highlight plaintext">public class Synchronizer&#123;

    public synchronized void doSynchronized()&#123;

    //do a lot of work which takes a long time

    &#125;
&#125;</code></pre>
<p>如果有一个以上的线程调用doSynchronized()方法，在第一个获得访问的线程未完成前，其他线程将一直处于阻塞状态，而且在这种多线程被阻塞的场景下，接下来将是哪个线程获得访问是没有保障的。</p>
<h3 id="lock"><a class="markdownIt-Anchor" href="#lock"></a> Lock</h3>
<p><strong>为了提高等待线程的公平性，我们使用锁方式来替代同步块</strong>。</p>
<pre><code class="highlight plaintext">public class Synchronizer&#123;
    Lock lock = new Lock();
    public void doSynchronized() throws InterruptedException&#123;
        this.lock.lock();
        //critical section, do a lot of work which takes a long time
        this.lock.unlock();
    &#125;
&#125;</code></pre>
<p>注意到doSynchronized()不再声明为synchronized，而是用lock.lock()和lock.unlock()来替代。</p>
<p>下面是用Lock类做的一个实现：</p>
<pre><code class="highlight plaintext">public class Lock&#123;
    private boolean isLocked      = false;
    private Thread lockingThread = null;
    public synchronized void lock() throws InterruptedException&#123;
    while(isLocked)&#123;
        wait();
    &#125;
    isLocked = true;
    lockingThread = Thread.currentThread();
&#125;
public synchronized void unlock()&#123;
    if(this.lockingThread != Thread.currentThread())&#123;
         throw new IllegalMonitorStateException(
              &quot;Calling thread has not locked this lock&quot;);
         &#125;
    isLocked = false;
    lockingThread = null;
    notify();
    &#125;
&#125;</code></pre>
<p>注意到上面对Lock的实现，如果存在多线程并发访问lock()，这些线程将阻塞在对lock()方法的访问上。另外，如果锁已经锁上（校对注：这里指的是isLocked等于true时），这些线程将阻塞在while(isLocked)循环的wait()调用里面。要记住的是，当线程正在等待进入lock() 时，可以调用wait()释放其锁实例对应的同步锁，使得其他多个线程可以进入lock()方法，并调用wait()方法。</p>
<p>这回看下doSynchronized()，你会注意到在lock()和unlock()之间的注释：在这两个调用之间的代码将运行很长一段时间。进一步设想，这段代码将长时间运行，和进入lock()并调用wait()来比较的话。这意味着大部分时间用在等待进入锁和进入临界区的过程是用在wait()的等待中，而不是被阻塞在试图进入lock()方法中。</p>
<p>在早些时候提到过，同步块不会对等待进入的多个线程谁能获得访问做任何保障，同样当调用notify()时，wait()也不会做保障一定能唤醒线程（至于为什么，请看线程通信）。因此这个版本的Lock类和doSynchronized()那个版本就保障公平性而言，没有任何区别。</p>
<p>但我们能改变这种情况。当前的Lock类版本调用自己的wait()方法，如果每个线程在不同的对象上调用wait()，那么只有一个线程会在该对象上调用wait()，Lock类可以决定哪个对象能对其调用notify()，因此能做到有效的选择唤醒哪个线程。</p>
<h3 id="公平锁fairlock"><a class="markdownIt-Anchor" href="#公平锁fairlock"></a> 公平锁FairLock</h3>
<p>下面来讲述将上面Lock类转变为公平锁FairLock。你会注意到新的实现和之前的Lock类中的同步和wait()/notify()稍有不同。</p>
<p>准确地说如何从之前的Lock类做到公平锁的设计是一个渐进设计的过程，每一步都是在解决上一步的问题而前进的：Nested Monitor Lockout, Slipped Conditions和Missed Signals。这些本身的讨论虽已超出本文的范围，但其中每一步的内容都将会专题进行讨论。重要的是，每一个调用lock()的线程都会进入一个队列，当解锁后，只有队列里的第一个线程被允许锁住Farlock实例，所有其它的线程都将处于等待状态，直到他们处于队列头部。</p>
<pre><code class="highlight plaintext">
public class FairLock &#123;
    private boolean           isLocked       = false;
    private Thread            lockingThread  = null;
    private List&lt;QueueObject&gt; waitingThreads =
            new ArrayList&lt;QueueObject&gt;();

  public void lock() throws InterruptedException&#123;
    QueueObject queueObject           = new QueueObject();
    boolean     isLockedForThisThread = true;
    synchronized(this)&#123;
        waitingThreads.add(queueObject);
    &#125;

    while(isLockedForThisThread)&#123;
      synchronized(this)&#123;
        isLockedForThisThread =
            isLocked || waitingThreads.get(0) != queueObject;
        if(!isLockedForThisThread)&#123;
          isLocked = true;
           waitingThreads.remove(queueObject);
           lockingThread = Thread.currentThread();
           return;
         &#125;
      &#125;
      try&#123;
        queueObject.doWait();
      &#125;catch(InterruptedException e)&#123;
        synchronized(this) &#123; waitingThreads.remove(queueObject); &#125;
        throw e;
      &#125;
    &#125;
  &#125;

  public synchronized void unlock()&#123;
    if(this.lockingThread != Thread.currentThread())&#123;
      throw new IllegalMonitorStateException(
        &quot;Calling thread has not locked this lock&quot;);
    &#125;
    isLocked      = false;
    lockingThread = null;
    if(waitingThreads.size() &gt; 0)&#123;
      waitingThreads.get(0).doNotify();
    &#125;
  &#125;
&#125;</code></pre>
<pre><code class="highlight plaintext">
public class QueueObject &#123;

    private boolean isNotified = false;

    public synchronized void doWait() throws InterruptedException &#123;

    while(!isNotified)&#123;
        this.wait();
    &#125;

    this.isNotified = false;

&#125;

public synchronized void doNotify() &#123;
    this.isNotified = true;
    this.notify();
&#125;

public boolean equals(Object o) &#123;
    return this == o;
&#125;

&#125;</code></pre>
<p>首先注意到lock()方法不在声明为synchronized，取而代之的是对必需同步的代码，在synchronized中进行嵌套</p>
<p>FairLock新创建了一个QueueObject的实例，并对每个调用lock()的线程进行入队列。调用unlock()的线程将从队列头部获取QueueObject，并对其调用doNotify()，以唤醒在该对象上等待的线程。通过这种方式，在同一时间仅有一个等待线程获得唤醒，而不是所有的等待线程。这也是实现FairLock公平性的核心所在。</p>
<p>请注意，在同一个同步块中，锁状态依然被检查和设置，以避免出现滑漏条件。</p>
<p>还需注意到，QueueObject实际是一个semaphore。doWait()和doNotify()方法在QueueObject中保存着信号。这样做以避免一个线程在调用queueObject.doWait()之前被另一个调用unlock()并随之调用queueObject.doNotify()的线程重入，从而导致信号丢失。queueObject.doWait()调用放置在synchronized(this)块之外，以避免被monitor嵌套锁死，所以另外的线程可以解锁，只要当没有线程在lock方法的synchronized(this)块中执行即可。</p>
<p>最后，注意到queueObject.doWait()在try – catch块中是怎样调用的。在InterruptedException抛出的情况下，线程得以离开lock()，并需让它从队列中移除。</p>
<h3 id="性能考虑"><a class="markdownIt-Anchor" href="#性能考虑"></a> 性能考虑</h3>
<p>如果比较Lock和FairLock类，你会注意到在FairLock类中lock()和unlock()还有更多需要深入的地方。这些额外的代码会导致FairLock的同步机制实现比Lock要稍微慢些。究竟存在多少影响，还依赖于应用在FairLock临界区执行的时长。执行时长越大，FairLock带来的负担影响就越小，当然这也和代码执行的频繁度相关。</p>
<h2 id="嵌套管程锁死"><a class="markdownIt-Anchor" href="#嵌套管程锁死"></a> 嵌套管程锁死</h2>
<p>嵌套管程锁死类似于死锁， 下面是一个嵌套管程锁死的场景：</p>
<pre><code class="highlight plaintext">线程1获得A对象的锁。
线程1获得对象B的锁（同时持有对象A的锁）。
线程1决定等待另一个线程的信号再继续。
线程1调用B.wait()，从而释放了B对象上的锁，但仍然持有对象A的锁。

线程2需要同时持有对象A和对象B的锁，才能向线程1发信号。
线程2无法获得对象A上的锁，因为对象A上的锁当前正被线程1持有。
线程2一直被阻塞，等待线程1释放对象A上的锁。

线程1一直阻塞，等待线程2的信号，因此，不会释放对象A上的锁，
而线程2需要对象A上的锁才能给线程1发信号……</code></pre>
<p>你可以能会说，这是个空想的场景，好吧，让我们来看看下面这个比较挫的Lock实现：</p>
<pre><code class="highlight plaintext">//lock implementation with nested monitor lockout problem
public class Lock&#123;
        protected MonitorObject monitorObject = new MonitorObject();
        protected boolean isLocked = false;

        public void lock() throws InterruptedException&#123;
                synchronized(this)&#123;
                        while(isLocked)&#123;
                                synchronized(this.monitorObject)&#123;
                                        this.monitorObject.wait();
                                &#125;
                        &#125;
                        isLocked = true;
                &#125;
        &#125;

        public void unlock()&#123;
                synchronized(this)&#123;
                        this.isLocked = false;
                        synchronized(this.monitorObject)&#123;
                                this.monitorObject.notify();
                        &#125;
                &#125;
        &#125;
&#125;</code></pre>
<p>可以看到，lock()方法首先在”this”上同步，然后在monitorObject上同步。如果isLocked等于false，因为线程不会继续调用monitorObject.wait()，那么一切都没有问题 。但是如果isLocked等于true，调用lock()方法的线程会在monitorObject.wait()上阻塞。</p>
<p>这里的问题在于，调用monitorObject.wait()方法只释放了monitorObject上的管程对象，而与”this“关联的管程对象并没有释放。换句话说，这个刚被阻塞的线程仍然持有”this”上的锁。</p>
<p>（校对注：如果一个线程持有这种Lock的时候另一个线程执行了lock操作）当一个已经持有这种Lock的线程想调用unlock(),就会在unlock()方法进入synchronized(this)块时阻塞。这会一直阻塞到在lock()方法中等待的线程离开synchronized(this)块。但是，在unlock中isLocked变为false，monitorObject.notify()被执行之后，lock()中等待的线程才会离开synchronized(this)块。</p>
<p>简而言之，在lock方法中等待的线程需要其它线程成功调用unlock方法来退出lock方法，但是，在lock()方法离开外层同步块之前，没有线程能成功执行unlock()。结果就是，任何调用lock方法或unlock方法的线程都会一直阻塞。这就是嵌套管程锁死。</p>
<p><strong>一个更现实的例子</strong></p>
<p>你可能会说，这么挫的实现方式我怎么可能会做呢？你或许不会在里层的管程对象上调用wait或notify方法，但完全有可能会在外层的this上调。</p>
<p>有很多类似上面例子的情况。例如，如果你准备实现一个公平锁。你可能希望每个线程在它们各自的QueueObject上调用wait()，这样就可以每次唤醒一个线程。下面是一个比较挫的公平锁实现方式：</p>
<pre><code class="highlight plaintext">
//Fair Lock implementation with nested monitor lockout problem
public class FairLock &#123;
        private boolean isLocked = false;
        private Thread lockingThread = null;
        private List waitingThreads =
                new ArrayList();

        public void lock() throws InterruptedException&#123;
                QueueObject queueObject = new QueueObject();

                synchronized(this)&#123;
                        waitingThreads.add(queueObject);

                        while(isLocked ||
                                waitingThreads.get(0) != queueObject)&#123;

                                synchronized(queueObject)&#123;
                                        try&#123;
                                                queueObject.wait();
                                        &#125;catch(InterruptedException e)&#123;
                                                waitingThreads.remove(queueObject);
                                                throw e;
                                        &#125;
                                &#125;
                        &#125;
                        waitingThreads.remove(queueObject);
                        isLocked = true;
                        lockingThread = Thread.currentThread();
                &#125;
        &#125;

        public synchronized void unlock()&#123;
                if(this.lockingThread != Thread.currentThread())&#123;
                        throw new IllegalMonitorStateException(
                                &quot;Calling thread has not locked this lock&quot;);
                &#125;
                isLocked = false;
                lockingThread = null;
                if(waitingThreads.size() &gt; 0)&#123;
                        QueueObject queueObject = waitingThread.get(0);
                        synchronized(queueObject)&#123;
                                queueObject.notify();
                        &#125;
                &#125;
        &#125;
&#125;</code></pre>
<p>乍看之下，嗯，很好，但是请注意lock方法是怎么调用queueObject.wait()的，在方法内部有两个synchronized块，一个锁定this，一个嵌在上一个synchronized块内部，它锁定的是局部变量queueObject。</p>
<p>当一个线程调用queueObject.wait()方法的时候，它仅仅释放的是在queueObject对象实例的锁，并没有释放”this”上面的锁。</p>
<p>现在我们还有一个地方需要特别注意， unlock方法被声明成了synchronized，这就相当于一个synchronized（this）块。这就意味着，如果一个线程在lock()中等待，该线程将持有与this关联的管程对象。所有调用unlock()的线程将会一直保持阻塞，等待着前面那个已经获得this锁的线程释放this锁，但这永远也发生不了，因为只有某个线程成功地给lock()中等待的线程发送了信号，this上的锁才会释放，但只有执行unlock()方法才会发送这个信号。</p>
<p>因此，上面的公平锁的实现会导致嵌套管程锁死。</p>
<h3 id="嵌套管程锁死vs死锁"><a class="markdownIt-Anchor" href="#嵌套管程锁死vs死锁"></a> 嵌套管程锁死VS死锁</h3>
<p>嵌套管程锁死与死锁很像：都是线程最后被一直阻塞着互相等待。</p>
<p>但是两者又不完全相同。在死锁中我们已经对死锁有了个大概的解释，死锁通常是因为两个线程获取锁的顺序不一致造成的，线程1锁住A，等待获取B，线程2已经获取了B，再等待获取A。如死锁避免中所说的，死锁可以通过总是以相同的顺序获取锁来避免。</p>
<p>但是发生嵌套管程锁死时锁获取的顺序是一致的。线程1获得A和B，然后释放B，等待线程2的信号。线程2需要同时获得A和B，才能向线程1发送信号。所以，一个线程在等待唤醒，另一个线程在等待想要的锁被释放。</p>
<pre><code class="highlight plaintext">死锁中，二个线程都在等待对方释放锁。

嵌套管程锁死中，线程1持有锁A，同时等待从线程2发来的信号，线程2需要锁A来发信号给线程1。</code></pre>
<h2 id="slipped-conditions"><a class="markdownIt-Anchor" href="#slipped-conditions"></a> Slipped Conditions</h2>
<p>所谓Slipped conditions，就是说， 从一个线程检查某一特定条件到该线程操作此条件期间，这个条件已经被其它线程改变，导致第一个线程在该条件上执行了错误的操作。这里有一个简单的例子：</p>
<pre><code class="highlight plaintext">
public class Lock &#123;
    private boolean isLocked = true;

    public void lock()&#123;
      synchronized(this)&#123;
        while(isLocked)&#123;
          try&#123;
            this.wait();
          &#125; catch(InterruptedException e)&#123;
            //do nothing, keep waiting
          &#125;
        &#125;
      &#125;

      synchronized(this)&#123;
        isLocked = true;
      &#125;
    &#125;

    public synchronized void unlock()&#123;
      isLocked = false;
      this.notify();
    &#125;
&#125;</code></pre>
<p>我们可以看到，lock()方法包含了两个同步块。第一个同步块执行wait操作直到isLocked变为false才退出，第二个同步块将isLocked置为true，以此来锁住这个Lock实例避免其它线程通过lock()方法。</p>
<p>我们可以设想一下，假如在某个时刻isLocked为false， 这个时候，有两个线程同时访问lock方法。如果第一个线程先进入第一个同步块，这个时候它会发现isLocked为false，若此时允许第二个线程执行，它也进入第一个同步块，同样发现isLocked是false。现在两个线程都检查了这个条件为false，然后它们都会继续进入第二个同步块中并设置isLocked为true。</p>
<p>这个场景就是slipped conditions的例子，两个线程检查同一个条件， 然后退出同步块，因此在这两个线程改变条件之前，就允许其它线程来检查这个条件。换句话说，条件被某个线程检查到该条件被此线程改变期间，这个条件已经被其它线程改变过了。</p>
<p>为避免slipped conditions，条件的检查与设置必须是原子的，也就是说，在第一个线程检查和设置条件期间，不会有其它线程检查这个条件。</p>
<p>解决上面问题的方法很简单，只是简单的把isLocked = true这行代码移到第一个同步块中，放在while循环后面即可：</p>
<pre><code class="highlight plaintext">
public class Lock &#123;
    private boolean isLocked = true;

    public void lock()&#123;
      synchronized(this)&#123;
        while(isLocked)&#123;
          try&#123;
            this.wait();
          &#125; catch(InterruptedException e)&#123;
            //do nothing, keep waiting
          &#125;
        &#125;
        isLocked = true;
      &#125;
    &#125;

    public synchronized void unlock()&#123;
      isLocked = false;
      this.notify();
    &#125;
&#125;</code></pre>
<p>现在检查和设置isLocked条件是在同一个同步块中原子地执行了。</p>
<p><strong>一个更现实的例子</strong></p>
<p>也许你会说，我才不可能写这么挫的代码，还觉得slipped conditions是个相当理论的问题。但是第一个简单的例子只是用来更好的展示slipped conditions。</p>
<p>饥饿和公平中实现的公平锁也许是个更现实的例子。再看下嵌套管程锁死中那个幼稚的实现，如果我们试图解决其中的嵌套管程锁死问题，很容易产生slipped conditions问题。 首先让我们看下嵌套管程锁死中的例子：</p>
<pre><code class="highlight plaintext">
//Fair Lock implementation with nested monitor lockout problem
public class FairLock &#123;
  private boolean isLocked = false;
  private Thread lockingThread = null;
  private List waitingThreads =
            new ArrayList();

  public void lock() throws InterruptedException&#123;
    QueueObject queueObject = new QueueObject();

    synchronized(this)&#123;
      waitingThreads.add(queueObject);

      while(isLocked || waitingThreads.get(0) != queueObject)&#123;

        synchronized(queueObject)&#123;
          try&#123;
            queueObject.wait();
          &#125;catch(InterruptedException e)&#123;
            waitingThreads.remove(queueObject);
            throw e;
          &#125;
        &#125;
      &#125;
      waitingThreads.remove(queueObject);
      isLocked = true;
      lockingThread = Thread.currentThread();
    &#125;
  &#125;

  public synchronized void unlock()&#123;
    if(this.lockingThread != Thread.currentThread())&#123;
      throw new IllegalMonitorStateException(
        &quot;Calling thread has not locked this lock&quot;);
    &#125;
    isLocked      = false;
    lockingThread = null;
    if(waitingThreads.size() &gt; 0)&#123;
      QueueObject queueObject = waitingThread.get(0);
      synchronized(queueObject)&#123;
        queueObject.notify();
      &#125;
    &#125;
  &#125;
&#125;
</code></pre>
<p>我们可以看到synchronized(queueObject)及其中的queueObject.wait()调用是嵌在synchronized(this)块里面的，这会导致嵌套管程锁死问题。为避免这个问题，我们必须将synchronized(queueObject)块移出synchronized(this)块。移出来之后的代码可能是这样的：</p>
<pre><code class="highlight plaintext">
//Fair Lock implementation with slipped conditions problem
public class FairLock &#123;
  private boolean isLocked = false;
  private Thread lockingThread  = null;
  private List waitingThreads =
            new ArrayList();

  public void lock() throws InterruptedException&#123;
    QueueObject queueObject = new QueueObject();

    synchronized(this)&#123;
      waitingThreads.add(queueObject);
    &#125;

    boolean mustWait = true;
    while(mustWait)&#123;

      synchronized(this)&#123;
        mustWait = isLocked || waitingThreads.get(0) != queueObject;
      &#125;

      synchronized(queueObject)&#123;
        if(mustWait)&#123;
          try&#123;
            queueObject.wait();
          &#125;catch(InterruptedException e)&#123;
            waitingThreads.remove(queueObject);
            throw e;
          &#125;
        &#125;
      &#125;
    &#125;

    synchronized(this)&#123;
      waitingThreads.remove(queueObject);
      isLocked = true;
      lockingThread = Thread.currentThread();
    &#125;
  &#125;
&#125;
</code></pre>
<p>注意：因为我只改动了lock()方法，这里只展现了lock方法。</p>
<p>现在lock()方法包含了3个同步块。</p>
<p>第一个，synchronized(this)块通过mustWait = isLocked || waitingThreads.get(0) != queueObject检查内部变量的值。</p>
<p>第二个，synchronized(queueObject)块检查线程是否需要等待。也有可能其它线程在这个时候已经解锁了，但我们暂时不考虑这个问题。我们就假设这个锁处在解锁状态，所以线程会立马退出synchronized(queueObject)块。</p>
<p>第三个，synchronized(this)块只会在mustWait为false的时候执行。它将isLocked重新设回true，然后离开lock()方法。</p>
<p>设想一下，在锁处于解锁状态时，如果有两个线程同时调用lock()方法会发生什么。首先，线程1会检查到isLocked为false，然后线程2同样检查到isLocked为false。接着，它们都不会等待，都会去设置isLocked为true。这就是slipped conditions的一个最好的例子。</p>
<p><strong>解决Slipped Conditions问题</strong></p>
<p>要解决上面例子中的slipped conditions问题，最后一个synchronized(this)块中的代码必须向上移到第一个同步块中。为适应这种变动，代码需要做点小改动。下面是改动过的代码：</p>
<pre><code class="highlight plaintext">
//Fair Lock implementation without nested monitor lockout problem,
//but with missed signals problem.
public class FairLock &#123;
  private boolean isLocked = false;
  private Thread lockingThread  = null;
  private List waitingThreads =
            new ArrayList();

  public void lock() throws InterruptedException&#123;
    QueueObject queueObject = new QueueObject();

    synchronized(this)&#123;
      waitingThreads.add(queueObject);
    &#125;

    boolean mustWait = true;
    while(mustWait)&#123;
      synchronized(this)&#123;
        mustWait = isLocked || waitingThreads.get(0) != queueObject;
        if(!mustWait)&#123;
          waitingThreads.remove(queueObject);
          isLocked = true;
          lockingThread = Thread.currentThread();
          return;
        &#125;
      &#125;     

      synchronized(queueObject)&#123;
        if(mustWait)&#123;
          try&#123;
            queueObject.wait();
          &#125;catch(InterruptedException e)&#123;
            waitingThreads.remove(queueObject);
            throw e;
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;
&#125;
</code></pre>
<p>我们可以看到对局部变量mustWait的检查与赋值是在同一个同步块中完成的。还可以看到，即使在synchronized(this)块外面检查了mustWait，在while(mustWait)子句中，mustWait变量从来没有在synchronized(this)同步块外被赋值。当一个线程检查到mustWait是false的时候，它将自动设置内部的条件（isLocked），所以其它线程再来检查这个条件的时候，它们就会发现这个条件的值现在为true了。</p>
<p>synchronized(this)块中的return;语句不是必须的。这只是个小小的优化。如果一个线程肯定不会等待（即mustWait为false），那么就没必要让它进入到synchronized(queueObject)同步块中和执行if(mustWait)子句了。</p>
<p>细心的读者可能会注意到上面的公平锁实现仍然有可能丢失信号。设想一下，当该FairLock实例处于锁定状态时，有个线程来调用lock()方法。执行完第一个 synchronized(this)块后，mustWait变量的值为true。再设想一下调用lock()的线程是通过抢占式的，拥有锁的那个线程那个线程此时调用了unlock()方法，但是看下之前的unlock()的实现你会发现，它调用了queueObject.notify()。但是，因为lock()中的线程还没有来得及调用queueObject.wait()，所以queueObject.notify()调用也就没有作用了，信号就丢失掉了。如果调用lock()的线程在另一个线程调用queueObject.notify()之后调用queueObject.wait()，这个线程会一直阻塞到其它线程调用unlock方法为止，但这永远也不会发生。</p>
<p>公平锁实现的信号丢失问题在饥饿和公平一文中我们已有过讨论，把QueueObject转变成一个信号量，并提供两个方法：doWait()和doNotify()。这些方法会在QueueObject内部对信号进行存储和响应。用这种方式，即使doNotify()在doWait()之前调用，信号也不会丢失。</p>
<h2 id="java-lock"><a class="markdownIt-Anchor" href="#java-lock"></a> Java Lock</h2>
<p>锁像synchronized同步块一样，是一种线程同步机制，但比Java中的synchronized同步块更复杂。因为锁（以及其它更高级的线程同步机制）是由synchronized同步块的方式实现的，所以我们还不能完全摆脱synchronized关键字（译者注：这说的是Java 5之前的情况）</p>
<p>自Java 5开始，java.util.concurrent.locks包中包含了一些锁的实现，因此你不用去实现自己的锁了。但是你仍然需要去了解怎样使用这些锁，且了解这些实现背后的理论也是很有用处的。</p>
<h3 id="lock-2"><a class="markdownIt-Anchor" href="#lock-2"></a> Lock</h3>
<h4 id="一个简单的锁"><a class="markdownIt-Anchor" href="#一个简单的锁"></a> 一个简单的锁</h4>
<p>让我们从java中的一个同步块开始：</p>
<pre><code class="highlight plaintext">public class Counter&#123;
        private int count = 0;

        public int inc()&#123;
                synchronized(this)&#123;
                        return ++count;
                &#125;
        &#125;
&#125;</code></pre>
<p>可以看到在inc()方法中有一个synchronized(this)代码块。该代码块可以保证在同一时间只有一个线程可以执行return <ins>count。虽然在synchronized的同步块中的代码可以更加复杂，但是</ins>count这种简单的操作已经足以表达出线程同步的意思。</p>
<p>以下的Counter类用Lock代替synchronized达到了同样的目的：</p>
<pre><code class="highlight plaintext">public class Counter&#123;
        private Lock lock = new Lock();
        private int count = 0;

        public int inc()&#123;
                lock.lock();
                int newCount = ++count;
                lock.unlock();
                return newCount;
        &#125;
&#125;</code></pre>
<p>lock()方法会对Lock实例对象进行加锁，因此所有对该对象调用lock()方法的线程都会被阻塞，直到该Lock对象的unlock()方法被调用。</p>
<p>这里有一个Lock类的简单实现：</p>
<pre><code class="highlight plaintext">
public class Counter&#123;
public class Lock&#123;
        private boolean isLocked = false;

        public synchronized void lock()
                throws InterruptedException&#123;
                while(isLocked)&#123;
                        wait();
                &#125;
                isLocked = true;
        &#125;

        public synchronized void unlock()&#123;
                isLocked = false;
                notify();
        &#125;
&#125;</code></pre>
<p>注意其中的while(isLocked)循环，它又被叫做“自旋锁”。自旋锁以及wait()和notify()方法在线程通信这篇文章中有更加详细的介绍。当isLocked为true时，调用lock()的线程在wait()调用上阻塞等待。为防止该线程没有收到notify()调用也从wait()中返回（也称作虚假唤醒），这个线程会重新去检查isLocked条件以决定当前是否可以安全地继续执行还是需要重新保持等待，而不是认为线程被唤醒了就可以安全地继续执行了。如果isLocked为false，当前线程会退出while(isLocked)循环，并将isLocked设回true，让其它正在调用lock()方法的线程能够在Lock实例上加锁。</p>
<p>当线程完成了临界区（位于lock()和unlock()之间）中的代码，就会调用unlock()。执行unlock()会重新将isLocked设置为false，并且通知（唤醒）其中一个（若有的话）在lock()方法中调用了wait()函数而处于等待状态的线程。</p>
<h4 id="锁的可重入性"><a class="markdownIt-Anchor" href="#锁的可重入性"></a> 锁的可重入性</h4>
<p>Java中的synchronized同步块是可重入的。这意味着如果一个java线程进入了代码中的synchronized同步块，并因此获得了该同步块使用的同步对象对应的管程上的锁，那么这个线程可以进入由同一个管程对象所同步的另一个java代码块。下面是一个例子：</p>
<pre><code class="highlight plaintext">public class Reentrant&#123;
        public synchronized outer()&#123;
                inner();
        &#125;

        public synchronized inner()&#123;
                //do something
        &#125;
&#125;</code></pre>
<p>注意outer()和inner()都被声明为synchronized，这在Java中和synchronized(this)块等效。如果一个线程调用了outer()，在outer()里调用inner()就没有什么问题，因为这两个方法（代码块）都由同一个管程对象（”this”)所同步。如果一个线程已经拥有了一个管程对象上的锁，那么它就有权访问被这个管程对象同步的所有代码块。这就是可重入。线程可以进入任何一个它已经拥有的锁所同步着的代码块。</p>
<p>前面给出的锁实现不是可重入的。如果我们像下面这样重写Reentrant类，当线程调用outer()时，会在inner()方法的lock.lock()处阻塞住。</p>
<pre><code class="highlight plaintext">
public class Reentrant2&#123;
        Lock lock = new Lock();

        public outer()&#123;
                lock.lock();
                inner();
                lock.unlock();
        &#125;

        public synchronized inner()&#123;
                lock.lock();
                //do something
                lock.unlock();
        &#125;
&#125;</code></pre>
<p>调用outer()的线程首先会锁住Lock实例，然后继续调用inner()。inner()方法中该线程将再一次尝试锁住Lock实例，结果该动作会失败（也就是说该线程会被阻塞），因为这个Lock实例已经在outer()方法中被锁住了。</p>
<p>两次lock()之间没有调用unlock()，第二次调用lock就会阻塞，看过lock()实现后，会发现原因很明显：</p>
<pre><code class="highlight plaintext">public class Lock&#123;
        boolean isLocked = false;

        public synchronized void lock()
                throws InterruptedException&#123;
                while(isLocked)&#123;
                        wait();
                &#125;
                isLocked = true;
        &#125;

        ...
&#125;</code></pre>
<p>一个线程是否被允许退出lock()方法是由while循环（自旋锁）中的条件决定的。当前的判断条件是只有当isLocked为false时lock操作才被允许，而没有考虑是哪个线程锁住了它。</p>
<p>为了让这个Lock类具有可重入性，我们需要对它做一点小的改动：</p>
<pre><code class="highlight plaintext">
public class Lock&#123;
        boolean isLocked = false;
        Thread  lockedBy = null;
        int lockedCount = 0;

        public synchronized void lock()
                throws InterruptedException&#123;
                Thread callingThread =
                        Thread.currentThread();
                while(isLocked &amp;&amp; lockedBy != callingThread)&#123;
                        wait();
                &#125;
                isLocked = true;
                lockedCount++;
                lockedBy = callingThread;
  &#125;

        public synchronized void unlock()&#123;
                if(Thread.curentThread() ==
                        this.lockedBy)&#123;
                        lockedCount--;

                        if(lockedCount == 0)&#123;
                                isLocked = false;
                                notify();
                        &#125;
                &#125;
        &#125;

        ...
&#125;</code></pre>
<p>注意到现在的while循环（自旋锁）也考虑到了已锁住该Lock实例的线程。如果当前的锁对象没有被加锁(isLocked = false)，或者当前调用线程已经对该Lock实例加了锁，那么while循环就不会被执行，调用lock()的线程就可以退出该方法（译者注：“被允许退出该方法”在当前语义下就是指不会调用wait()而导致阻塞）。</p>
<p>除此之外，我们需要记录同一个线程重复对一个锁对象加锁的次数。否则，一次unblock()调用就会解除整个锁，即使当前锁已经被加锁过多次。在unlock()调用没有达到对应lock()调用的次数之前，我们不希望锁被解除。</p>
<p>现在这个Lock类就是可重入的了。</p>
<h4 id="锁的公平性"><a class="markdownIt-Anchor" href="#锁的公平性"></a> 锁的公平性</h4>
<p>Java的synchronized块并不保证尝试进入它们的线程的顺序。因此，如果多个线程不断竞争访问相同的synchronized同步块，就存在一种风险，其中一个或多个线程永远也得不到访问权 —— 也就是说访问权总是分配给了其它线程。这种情况被称作线程饥饿。为了避免这种问题，锁需要实现公平性。本文所展现的锁在内部是用synchronized同步块实现的，因此它们也不保证公平性。饥饿和公平中有更多关于该内容的讨论。</p>
<h4 id="在finally语句中调用unlock"><a class="markdownIt-Anchor" href="#在finally语句中调用unlock"></a> 在finally语句中调用unlock()</h4>
<p>如果用Lock来保护临界区，并且临界区有可能会抛出异常，那么在finally语句中调用unlock()就显得非常重要了。这样可以保证这个锁对象可以被解锁以便其它线程能继续对其加锁。以下是一个示例：</p>
<pre><code class="highlight plaintext">lock.lock();
try&#123;
        //do critical section code,
        //which may throw exception
&#125; finally &#123;
        lock.unlock();
&#125;</code></pre>
<p>这个简单的结构可以保证当临界区抛出异常时Lock对象可以被解锁。如果不是在finally语句中调用的unlock()，当临界区抛出异常时，Lock对象将永远停留在被锁住的状态，这会导致其它所有在该Lock对象上调用lock()的线程一直阻塞。</p>
<h3 id="java-reentrantlock"><a class="markdownIt-Anchor" href="#java-reentrantlock"></a> Java ReentrantLock</h3>
<p>从Java 5开始，引入了一个高级的处理并发的java.util.concurrent包，它提供了大量更高级的并发功能，能大大简化多线程程序的编写。</p>
<p>我们知道Java语言直接提供了synchronized关键字用于加锁，但这种锁一是很重，二是<strong>获取时必须一直等待，没有额外的尝试机制</strong>。</p>
<p>java.util.concurrent.locks包提供的ReentrantLock用于替代synchronized加锁，我们来看一下传统的synchronized代码：</p>
<pre><code class="highlight plaintext">public class Counter &#123;
    private int count;

    public void add(int n) &#123;
        synchronized(this) &#123;
            count += n;
        &#125;
    &#125;
&#125;</code></pre>
<p>如果用ReentrantLock替代，可以把代码改造为：</p>
<pre><code class="highlight plaintext">public class Counter &#123;
    private final Lock lock = new ReentrantLock();
    private int count;

    public void add(int n) &#123;
        lock.lock();
        try &#123;
            count += n;
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;
&#125;</code></pre>
<p>因为synchronized是Java语言层面提供的语法，所以我们不需要考虑异常，而ReentrantLock是Java代码实现的锁，我们就必须先获取锁，然后在finally中正确释放锁。</p>
<p>顾名思义，ReentrantLock是可重入锁，它和synchronized一样，一个线程可以多次获取同一个锁。和synchronized不同的是，ReentrantLock可以尝试获取锁：</p>
<pre><code class="highlight plaintext">if (lock.tryLock(1, TimeUnit.SECONDS)) &#123;
    try &#123;
        ...
    &#125; finally &#123;
        lock.unlock();
    &#125;
&#125;
</code></pre>
<p>上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，tryLock()返回false，程序就可以做一些额外处理，而不是无限等待下去。</p>
<p>所以，使用ReentrantLock比直接使用synchronized更安全，线程在tryLock()失败的时候不会导致死锁。</p>
<h4 id="使用condition"><a class="markdownIt-Anchor" href="#使用condition"></a> 使用Condition</h4>
<p>使用ReentrantLock比直接使用synchronized更安全，可以替代synchronized进行线程同步。</p>
<p>但是，synchronized可以配合wait和notify实现线程在条件不满足时等待，条件满足时唤醒，用ReentrantLock我们怎么编写wait和notify的功能呢？</p>
<p>答案是<strong>使用Condition对象来实现wait和notify的功能</strong>。</p>
<p>我们仍然以TaskQueue为例，把前面用synchronized实现的功能通过ReentrantLock和Condition来实现：</p>
<pre><code class="highlight plaintext">
class TaskQueue &#123;
    private final Lock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();
    private Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();

    public void addTask(String s) &#123;
        lock.lock();
        try &#123;
            queue.add(s);
            condition.signalAll();
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    public String getTask() &#123;
        lock.lock();
        try &#123;
            while (queue.isEmpty()) &#123;
                condition.await();
            &#125;
            return queue.remove();
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;
&#125;</code></pre>
<p>可见，使用Condition时，引用的Condition对象必须<strong>从Lock实例的newCondition()返回，这样才能获得一个绑定了Lock实例的Condition实例</strong>。</p>
<p>Condition提供的await()、signal()、signalAll()原理和synchronized锁对象的wait()、notify()、notifyAll()是一致的，并且其行为也是一样的：</p>
<ul>
<li>await()会释放当前锁，进入等待状态；</li>
<li>signal()会唤醒某个等待线程；</li>
<li>signalAll()会唤醒所有等待线程；</li>
<li>唤醒线程从await()返回后需要重新获得锁。</li>
</ul>
<p>此外，和tryLock()类似，await()可以在等待指定时间后，如果还没有被其他线程通过signal()或signalAll()唤醒，可以自己醒来：</p>
<pre><code class="highlight plaintext">if (condition.await(1, TimeUnit.SECOND)) &#123;
    // 被其他线程唤醒
&#125; else &#123;
    // 指定时间内没有被其他线程唤醒
&#125;</code></pre>
<p>可见，使用Condition配合Lock，我们可以实现更灵活的线程同步。</p>
<h3 id="java-readwritelock"><a class="markdownIt-Anchor" href="#java-readwritelock"></a> Java ReadWriteLock</h3>
<p>相比Java中的锁(Locks in Java)里Lock实现，读写锁更复杂一些。假设你的程序中涉及到对一些共享资源的读和写操作，且写操作没有读操作那么频繁。在没有写操作的时候，两个线程同时读一个资源没有任何问题，所以应该允许多个线程能在同时读取共享资源。但是如果有一个线程想去写这些共享资源，就不应该再有其它线程对该资源进行读或写（译者注：也就是说：读-读能共存，读-写不能共存，写-写不能共存）。这就需要一个读/写锁来解决这个问题。</p>
<p>Java5 <strong>在java.util.concurrent包中已经包含了读写锁</strong>。尽管如此，我们还是应该了解其实现背后的原理。</p>
<h4 id="使用readwritelock"><a class="markdownIt-Anchor" href="#使用readwritelock"></a> 使用ReadWriteLock</h4>
<p>前面讲到的ReentrantLock保证了只有一个线程可以执行临界区代码：</p>
<pre><code class="highlight plaintext">
public class Counter &#123;
    private final Lock lock = new ReentrantLock();
    private int[] counts = new int[10];

    public void inc(int index) &#123;
        lock.lock();
        try &#123;
            counts[index] += 1;
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    public int[] get() &#123;
        lock.lock();
        try &#123;
            return Arrays.copyOf(counts, counts.length);
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;
&#125;</code></pre>
<p>但是有些时候，这种保护有点过头。因为我们发现，任何时刻，只允许一个线程修改，也就是调用inc()方法是必须获取锁，但是，get()方法只读取数据，不修改数据，它实际上允许多个线程同时调用。实际上我们想要的是：允许多个线程同时读，但只要有一个线程在写，其他线程就必须等待：</p>
<table>
<thead>
<tr>
<th></th>
<th>读</th>
<th>写</th>
</tr>
</thead>
<tbody>
<tr>
<td>读</td>
<td>允许</td>
<td>不允许</td>
</tr>
<tr>
<td>写</td>
<td>不允许</td>
<td>不允许</td>
</tr>
</tbody>
</table>
<p>使用ReadWriteLock可以解决这个问题，它保证：</p>
<ul>
<li>只允许一个线程写入（其他线程既不能写入也不能读取）；</li>
<li>没有写入时，多个线程允许同时读（提高性能）。</li>
</ul>
<p>用ReadWriteLock实现这个功能十分容易。我们需要创建一个ReadWriteLock实例，然后分别获取读锁和写锁：</p>
<pre><code class="highlight plaintext">public class Counter &#123;
    private final ReadWriteLock rwlock = new ReentrantReadWriteLock();
    private final Lock rlock = rwlock.readLock();
    private final Lock wlock = rwlock.writeLock();
    private int[] counts = new int[10];

    public void inc(int index) &#123;
        wlock.lock(); // 加写锁
        try &#123;
            counts[index] += 1;
        &#125; finally &#123;
            wlock.unlock(); // 释放写锁
        &#125;
    &#125;

    public int[] get() &#123;
        rlock.lock(); // 加读锁
        try &#123;
            return Arrays.copyOf(counts, counts.length);
        &#125; finally &#123;
            rlock.unlock(); // 释放读锁
        &#125;
    &#125;
&#125;</code></pre>
<p>把读写操作分别用读锁和写锁来加锁，在读取时，多个线程可以同时获得读锁，这样就大大提高了并发读的执行效率。</p>
<p>使用ReadWriteLock时，适用条件是同一个数据，有大量线程读取，但仅有少数线程修改。</p>
<p>例如，一个论坛的帖子，回复可以看做写入操作，它是不频繁的，但是，浏览可以看做读取操作，是非常频繁的，这种情况就可以使用ReadWriteLock。</p>
<h4 id="读写锁的java实现"><a class="markdownIt-Anchor" href="#读写锁的java实现"></a> 读/写锁的Java实现</h4>
<p>先让我们对读写访问资源的条件做个概述：</p>
<ul>
<li><strong>读取</strong> 没有线程正在做写操作，且没有线程在请求写操作。</li>
<li><strong>写入</strong> 没有线程正在做读写操作。</li>
</ul>
<p>如果某个线程想要读取资源，只要没有线程正在对该资源进行写操作且没有线程请求对该资源的写操作即可。我们假设对写操作的请求比对读操作的请求更重要，就要提升写请求的优先级。此外，如果读操作发生的比较频繁，我们又没有提升写操作的优先级，那么就会产生“饥饿”现象。请求写操作的线程会一直阻塞，直到所有的读线程都从ReadWriteLock上解锁了。如果一直保证新线程的读操作权限，那么等待写操作的线程就会一直阻塞下去，结果就是发生“饥饿”。因此，只有当没有线程正在锁住ReadWriteLock进行写操作，且没有线程请求该锁准备执行写操作时，才能保证读操作继续。</p>
<p>当其它线程没有对共享资源进行读操作或者写操作时，某个线程就有可能获得该共享资源的写锁，进而对共享资源进行写操作。有多少线程请求了写锁以及以何种顺序请求写锁并不重要，除非你想保证写锁请求的公平性。</p>
<pre><code class="highlight plaintext">public class ReadWriteLock&#123;
        private int readers = 0;
        private int writers = 0;
        private int writeRequests = 0;

        public synchronized void lockRead() 
                throws InterruptedException&#123;
                while(writers &gt; 0 || writeRequests &gt; 0)&#123;
                        wait();
                &#125;
                readers++;
        &#125;

        public synchronized void unlockRead()&#123;
                readers--;
                notifyAll();
        &#125;

        public synchronized void lockWrite() 
                throws InterruptedException&#123;
                writeRequests++;

                while(readers &gt; 0 || writers &gt; 0)&#123;
                        wait();
                &#125;
                writeRequests--;
                writers++;
        &#125;

        public synchronized void unlockWrite() 
                throws InterruptedException&#123;
                writers--;
                notifyAll();
        &#125;
&#125;</code></pre>
<p>ReadWriteLock类中，读锁和写锁各有一个获取锁和释放锁的方法。</p>
<p><strong>读锁的实现在lockRead()中</strong>,只要没有线程拥有写锁（writers==0），且没有线程在请求写锁（writeRequests ==0），所有想获得读锁的线程都能成功获取。</p>
<p><strong>写锁的实现在lockWrite()中</strong>,当一个线程想获得写锁的时候，首先会把写锁请求数加1（writeRequests++），然后再去判断是否能够真能获得写锁，当没有线程持有读锁（readers<mark>0 ）,且没有线程持有写锁（writers</mark>0）时就能获得写锁。有多少线程在请求写锁并无关系。</p>
<p>需要注意的是，在两个释放锁的方法（unlockRead，unlockWrite）中，<strong>都调用了notifyAll方法，而不是notify</strong>。要解释这个原因，我们可以想象下面一种情形：</p>
<p>如果有线程在等待获取读锁，同时又有线程在等待获取写锁。如果这时其中一个等待读锁的线程被notify方法唤醒，但因为此时仍有请求写锁的线程存在（writeRequests&gt;0），所以被唤醒的线程会再次进入阻塞状态。然而，等待写锁的线程一个也没被唤醒，就像什么也没发生过一样（译者注：信号丢失现象）。如果用的是notifyAll方法，所有的线程都会被唤醒，然后判断能否获得其请求的锁。</p>
<p>用notifyAll还有一个好处。如果有多个读线程在等待读锁且没有线程在等待写锁时，调用unlockWrite()后，所有等待读锁的线程都能立马成功获取读锁 —— 而不是一次只允许一个。</p>
<h4 id="读写锁的重入"><a class="markdownIt-Anchor" href="#读写锁的重入"></a> 读/写锁的重入</h4>
<p>上面实现的读/写锁(ReadWriteLock) 是不可重入的，当一个已经持有写锁的线程再次请求写锁时，就会被阻塞。原因是已经有一个写线程了——就是它自己。此外，考虑下面的例子：</p>
<ol>
<li>Thread 1 获得了读锁</li>
<li>Thread 2 请求写锁，但因为Thread 1 持有了读锁，所以写锁请求被阻塞。</li>
<li>Thread 1 再想请求一次读锁，但因为Thread 2处于请求写锁的状态，所以想再次获取读锁也会被阻塞。</li>
</ol>
<p>上面这种情形使用前面的ReadWriteLock就会被锁定——一种类似于死锁的情形。不会再有线程能够成功获取读锁或写锁了。</p>
<p>为了让ReadWriteLock可重入，需要对它做一些改进。下面会分别处理读锁的重入和写锁的重入。</p>
<h5 id="读锁重入"><a class="markdownIt-Anchor" href="#读锁重入"></a> 读锁重入</h5>
<p>为了让ReadWriteLock的读锁可重入，我们要先为读锁重入建立规则：</p>
<ul>
<li>要保证某个线程中的读锁可重入，要么满足获取读锁的条件（没有写或写请求），要么已经持有读锁（不管是否有写请求）。</li>
</ul>
<p>要确定一个线程是否已经持有读锁，可以用一个map来存储已经持有读锁的线程以及对应线程获取读锁的次数，当需要判断某个线程能否获得读锁时，就利用map中存储的数据进行判断。下面是方法lockRead和unlockRead修改后的的代码：</p>
<pre><code class="highlight plaintext">
public class ReadWriteLock&#123;
        private Map&lt;Thread, Integer&gt; readingThreads =
                new HashMap&lt;Thread, Integer&gt;();

        private int writers = 0;
        private int writeRequests = 0;

        public synchronized void lockRead() 
                throws InterruptedException&#123;
                Thread callingThread = Thread.currentThread();
                while(! canGrantReadAccess(callingThread))&#123;
                        wait();                                                                   
                &#125;

                readingThreads.put(callingThread,
                        (getAccessCount(callingThread) + 1));
        &#125;

        public synchronized void unlockRead()&#123;
                Thread callingThread = Thread.currentThread();
                int accessCount = getAccessCount(callingThread);
                if(accessCount == 1) &#123; 
                        readingThreads.remove(callingThread); 
                &#125; else &#123;
                        readingThreads.put(callingThread, (accessCount -1)); 
                &#125;
                notifyAll();
        &#125;

        private boolean canGrantReadAccess(Thread callingThread)&#123;
                if(writers &gt; 0) return false;
                if(isReader(callingThread) return true;
                if(writeRequests &gt; 0) return false;
                return true;
        &#125;

        private int getReadAccessCount(Thread callingThread)&#123;
                Integer accessCount = readingThreads.get(callingThread);
                if(accessCount == null) return 0;
                return accessCount.intValue();
        &#125;

        private boolean isReader(Thread callingThread)&#123;
                return readingThreads.get(callingThread) != null;
        &#125;
&#125;
</code></pre>
<p>代码中我们可以看到，只有在没有线程拥有写锁的情况下才允许读锁的重入。此外，重入的读锁比写锁优先级高。</p>
<h5 id="写锁重入"><a class="markdownIt-Anchor" href="#写锁重入"></a> 写锁重入</h5>
<p>仅当一个线程已经持有写锁，才允许写锁重入（再次获得写锁）。下面是方法lockWrite和unlockWrite修改后的的代码。</p>
<pre><code class="highlight plaintext">
public class ReadWriteLock&#123;
        private Map&lt;Thread, Integer&gt; readingThreads =
                new HashMap&lt;Thread, Integer&gt;();

        private int writeAccesses    = 0;
        private int writeRequests    = 0;
        private Thread writingThread = null;

        public synchronized void lockWrite() 
                throws InterruptedException&#123;
                writeRequests++;
                Thread callingThread = Thread.currentThread();
                while(!canGrantWriteAccess(callingThread))&#123;
                        wait();
                &#125;
                writeRequests--;
                writeAccesses++;
                writingThread = callingThread;
        &#125;

        public synchronized void unlockWrite() 
                throws InterruptedException&#123;
                writeAccesses--;
                if(writeAccesses == 0)&#123;
                        writingThread = null;
                &#125;
                notifyAll();
        &#125;

        private boolean canGrantWriteAccess(Thread callingThread)&#123;
                if(hasReaders()) return false;
                if(writingThread == null)    return true;
                if(!isWriter(callingThread)) return false;
                return true;
        &#125;

        private boolean hasReaders()&#123;
                return readingThreads.size() &gt; 0;
        &#125;

        private boolean isWriter(Thread callingThread)&#123;
                return writingThread == callingThread;
        &#125;
&#125;
</code></pre>
<p>注意在确定当前线程是否能够获取写锁的时候，是如何处理的。</p>
<h5 id="读锁升级到写锁"><a class="markdownIt-Anchor" href="#读锁升级到写锁"></a> 读锁升级到写锁</h5>
<p>有时，我们希望一个拥有读锁的线程，也能获得写锁。想要允许这样的操作，要求这个线程是唯一一个拥有读锁的线程。writeLock()需要做点改动来达到这个目的：</p>
<pre><code class="highlight plaintext">
public class ReadWriteLock&#123;
        private Map&lt;Thread, Integer&gt; readingThreads =
                new HashMap&lt;Thread, Integer&gt;();

        private int writeAccesses    = 0;
        private int writeRequests    = 0;
        private Thread writingThread = null;

        public synchronized void lockWrite() 
                throws InterruptedException&#123;
                writeRequests++;
                Thread callingThread = Thread.currentThread();
                while(!canGrantWriteAccess(callingThread))&#123;
                        wait();
                &#125;
                writeRequests--;
                writeAccesses++;
                writingThread = callingThread;
        &#125;

        public synchronized void unlockWrite() throws InterruptedException&#123;
                writeAccesses--;
                if(writeAccesses == 0)&#123;
                        writingThread = null;
                &#125;
                notifyAll();
        &#125;

        private boolean canGrantWriteAccess(Thread callingThread)&#123;
                if(isOnlyReader(callingThread)) return true;
                if(hasReaders()) return false;
                if(writingThread == null) return true;
                if(!isWriter(callingThread)) return false;
                return true;
        &#125;

        private boolean hasReaders()&#123;
                return readingThreads.size() &gt; 0;
        &#125;

        private boolean isWriter(Thread callingThread)&#123;
                return writingThread == callingThread;
        &#125;

        private boolean isOnlyReader(Thread thread)&#123;
                return readers == 1 &amp;&amp; readingThreads.get(callingThread) != null;
        &#125;
&#125;
</code></pre>
<p>现在ReadWriteLock类就可以从读锁升级到写锁了。</p>
<h5 id="写锁降级到读写锁"><a class="markdownIt-Anchor" href="#写锁降级到读写锁"></a> 写锁降级到读写锁</h5>
<p>有时拥有写锁的线程也希望得到读锁。如果一个线程拥有了写锁，那么自然其它线程是不可能拥有读锁或写锁了。所以对于一个拥有写锁的线程，再获得读锁，是不会有什么危险的。我们仅仅需要对上面canGrantReadAccess方法进行简单地修改：</p>
<pre><code class="highlight plaintext">
public class ReadWriteLock&#123;
        private boolean canGrantReadAccess(Thread callingThread)&#123;
                if(isWriter(callingThread)) return true;
                if(writingThread != null) return false;
                if(isReader(callingThread) return true;
                if(writeRequests &gt; 0) return false;
                return true;
        &#125;
&#125;</code></pre>
<h4 id="可重入的readwritelock的完整实现"><a class="markdownIt-Anchor" href="#可重入的readwritelock的完整实现"></a> 可重入的ReadWriteLock的完整实现</h4>
<p>下面是完整的ReadWriteLock实现。为了便于代码的阅读与理解，简单对上面的代码做了重构。重构后的代码如下。</p>
<pre><code class="highlight plaintext">
public class ReadWriteLock&#123;
        private Map&lt;Thread, Integer&gt; readingThreads =
                new HashMap&lt;Thread, Integer&gt;();

        private int writeAccesses    = 0;
        private int writeRequests    = 0;
        private Thread writingThread = null;

        public synchronized void lockRead() 
                throws InterruptedException&#123;
                Thread callingThread = Thread.currentThread();
                while(! canGrantReadAccess(callingThread))&#123;
                        wait();
                &#125;

                readingThreads.put(callingThread,
                        (getReadAccessCount(callingThread) + 1));
        &#125;

        private boolean canGrantReadAccess(Thread callingThread)&#123;
                if(isWriter(callingThread)) return true;
                if(hasWriter()) return false;
                if(isReader(callingThread)) return true;
                if(hasWriteRequests()) return false;
                return true;
        &#125;

        public synchronized void unlockRead()&#123;
                Thread callingThread = Thread.currentThread();
                if(!isReader(callingThread))&#123;
                        throw new IllegalMonitorStateException(
                                &quot;Calling Thread does not&quot; +
                                &quot; hold a read lock on this ReadWriteLock&quot;);
                &#125;
                int accessCount = getReadAccessCount(callingThread);
                if(accessCount == 1)&#123; 
                        readingThreads.remove(callingThread); 
                &#125; else &#123; 
                        readingThreads.put(callingThread, (accessCount -1));
                &#125;
                notifyAll();
        &#125;

        public synchronized void lockWrite() 
                throws InterruptedException&#123;
                writeRequests++;
                Thread callingThread = Thread.currentThread();
                while(!canGrantWriteAccess(callingThread))&#123;
                        wait();
                &#125;
                writeRequests--;
                writeAccesses++;
                writingThread = callingThread;
        &#125;

        public synchronized void unlockWrite() 
                throws InterruptedException&#123;
                if(!isWriter(Thread.currentThread())&#123;
                throw new IllegalMonitorStateException(
                        &quot;Calling Thread does not&quot; +
                        &quot; hold the write lock on this ReadWriteLock&quot;);
                &#125;
                writeAccesses--;
                if(writeAccesses == 0)&#123;
                        writingThread = null;
                &#125;
                notifyAll();
        &#125;

        private boolean canGrantWriteAccess(Thread callingThread)&#123;
                if(isOnlyReader(callingThread)) return true;
                if(hasReaders()) return false;
                if(writingThread == null) return true;
                if(!isWriter(callingThread)) return false;
                return true;
        &#125;

        private int getReadAccessCount(Thread callingThread)&#123;
                Integer accessCount = readingThreads.get(callingThread);
                if(accessCount == null) return 0;
                return accessCount.intValue();
        &#125;

        private boolean hasReaders()&#123;
                return readingThreads.size() &gt; 0;
        &#125;

        private boolean isReader(Thread callingThread)&#123;
                return readingThreads.get(callingThread) != null;
        &#125;

        private boolean isOnlyReader(Thread callingThread)&#123;
                return readingThreads.size() == 1 &amp;&amp;
                        readingThreads.get(callingThread) != null;
        &#125;

        private boolean hasWriter()&#123;
                return writingThread != null;
        &#125;

        private boolean isWriter(Thread callingThread)&#123;
                return writingThread == callingThread;
        &#125;

        private boolean hasWriteRequests()&#123;
                return this.writeRequests &gt; 0;
        &#125;
&#125;
</code></pre>
<h4 id="在finally中调用unlock"><a class="markdownIt-Anchor" href="#在finally中调用unlock"></a> 在finally中调用unlock</h4>
<p>在利用ReadWriteLock来保护临界区时，如果临界区可能抛出异常，在finally块中调用readUnlock()和writeUnlock()就显得很重要了。这样做是为了保证ReadWriteLock能被成功解锁，然后其它线程可以请求到该锁。这里有个例子：</p>
<pre><code class="highlight plaintext">lock.lockWrite();
try&#123;
        //do critical section code, which may throw exception
&#125; finally &#123;
        lock.unlockWrite();
&#125;</code></pre>
<p>上面这样的代码结构能够保证临界区中抛出异常时ReadWriteLock也会被释放。如果unlockWrite方法不是在finally块中调用的，当临界区抛出了异常时，ReadWriteLock 会一直保持在写锁定状态，就会导致所有调用lockRead()或lockWrite()的线程一直阻塞。唯一能够重新解锁ReadWriteLock的因素可能就是ReadWriteLock是可重入的，当抛出异常时，这个线程后续还可以成功获取这把锁，然后执行临界区以及再次调用unlockWrite()，这就会再次释放ReadWriteLock。但是如果该线程后续不再获取这把锁了呢？所以，在finally中调用unlockWrite对写出健壮代码是很重要的。</p>
<h3 id="java-stampedlock"><a class="markdownIt-Anchor" href="#java-stampedlock"></a> Java StampedLock</h3>
<p>前面介绍的ReadWriteLock可以解决多线程同时读，但只有一个线程能写的问题。</p>
<p>如果我们深入分析ReadWriteLock，会发现它有个潜在的问题：如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。</p>
<p>要进一步提升并发执行效率，Java 8引入了新的读写锁：</p>
<ul>
<li>StampedLock。StampedLock和ReadWriteLock相比，改进之处在于：<strong>读的过程中也允许获取写锁后写入</strong>！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。</li>
</ul>
<p>乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。我们来看例子：</p>
<pre><code class="highlight plaintext">
public class Point &#123;
    private final StampedLock stampedLock = new StampedLock();

    private double x;
    private double y;

    public void move(double deltaX, double deltaY) &#123;
        long stamp = stampedLock.writeLock(); // 获取写锁
        try &#123;
            x += deltaX;
            y += deltaY;
        &#125; finally &#123;
            stampedLock.unlockWrite(stamp); // 释放写锁
        &#125;
    &#125;

    public double distanceFromOrigin() &#123;
        long stamp = stampedLock.tryOptimisticRead(); // 获得一个乐观读锁
        // 注意下面两行代码不是原子操作
        // 假设x,y = (100,200)
        double currentX = x;
        // 此处已读取到x=100，但x,y可能被写线程修改为(300,400)
        double currentY = y;
        // 此处已读取到y，如果没有写入，读取是正确的(100,200)
        // 如果有写入，读取是错误的(100,400)
        if (!stampedLock.validate(stamp)) &#123; // 检查乐观读锁后是否有其他写锁发生
            stamp = stampedLock.readLock(); // 获取一个悲观读锁
            try &#123;
                currentX = x;
                currentY = y;
            &#125; finally &#123;
                stampedLock.unlockRead(stamp); // 释放悲观读锁
            &#125;
        &#125;
        return Math.sqrt(currentX * currentX + currentY * currentY);
    &#125;
&#125;</code></pre>
<p>和ReadWriteLock相比，写入的加锁是完全一样的，不同的是读取。注意到首先我们通过tryOptimisticRead()获取一个乐观读锁，并返回版本号。接着进行读取，读取完成后，我们通过validate()去验证版本号，如果在读取过程中没有写入，版本号不变，验证成功，我们就可以放心地继续后续操作。如果在读取过程中有写入，版本号会发生变化，验证将失败。在失败的时候，我们再通过获取悲观读锁再次读取。由于写入的概率不高，程序在绝大部分情况下可以通过乐观读锁获取数据，极少数情况下使用悲观读锁获取数据。</p>
<p>可见，StampedLock把读锁细分为乐观读和悲观读，能进一步提升并发效率。但这也是有代价的：一是代码更加复杂，二是StampedLock是不可重入锁，不能在一个线程中反复获取同一个锁。</p>
<p>StampedLock还提供了更复杂的将悲观读锁升级为写锁的功能，它主要使用在if-then-update的场景：即先读，如果读的数据满足条件，就返回，如果读的数据不满足条件，再尝试写。</p>
<h3 id="concurrent集合"><a class="markdownIt-Anchor" href="#concurrent集合"></a> Concurrent集合</h3>
<p>我们在前面已经通过ReentrantLock和Condition实现了一个BlockingQueue：</p>
<pre><code class="highlight plaintext">public class TaskQueue &#123;
    private final Lock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();
    private Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();

    public void addTask(String s) &#123;
        lock.lock();
        try &#123;
            queue.add(s);
            condition.signalAll();
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    public String getTask() &#123;
        lock.lock();
        try &#123;
            while (queue.isEmpty()) &#123;
                condition.await();
            &#125;
            return queue.remove();
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<p>BlockingQueue的意思就是说，当一个线程调用这个TaskQueue的getTask()方法时，该方法内部可能会让线程变成等待状态，直到队列条件满足不为空，线程被唤醒后，getTask()方法才会返回。</p>
<p>因为BlockingQueue非常有用，所以我们不必自己编写，可以直接使用Java标准库的java.util.concurrent包提供的线程安全的集合：ArrayBlockingQueue。</p>
<p>除了BlockingQueue外，针对List、Map、Set、Deque等，java.util.concurrent包也提供了对应的并发集合类。我们归纳一下：</p>
<table>
<thead>
<tr>
<th>interface</th>
<th>non-thread-safe</th>
<th>thread-safe</th>
</tr>
</thead>
<tbody>
<tr>
<td>List</td>
<td>ArrayList</td>
<td>CopyOnWriteArrayList</td>
</tr>
<tr>
<td>Map</td>
<td>HashMap</td>
<td>ConcurrentHashMap</td>
</tr>
<tr>
<td>Set</td>
<td>HashSet / TreeSet</td>
<td>CopyOnWriteArraySet</td>
</tr>
<tr>
<td>Queue</td>
<td>ArrayDeque / LinkedList</td>
<td>ArrayBlockingQueue / LinkedBlockingQueue</td>
</tr>
<tr>
<td>Deque</td>
<td>ArrayDeque / LinkedList</td>
<td>LinkedBlockingDeque</td>
</tr>
</tbody>
</table>
<p>使用这些并发集合与使用非线程安全的集合类完全相同。我们以ConcurrentHashMap为例：</p>
<pre><code class="highlight plaintext">Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();
// 在不同的线程读写:
map.put(&quot;A&quot;, &quot;1&quot;);
map.put(&quot;B&quot;, &quot;2&quot;);
map.get(&quot;A&quot;, &quot;1&quot;);</code></pre>
<p>因为所有的同步和加锁的逻辑都在集合内部实现，对外部调用者来说，只需要正常按接口引用，其他代码和原来的非线程安全代码完全一样。即当我们需要多线程访问时，把：</p>
<pre><code class="highlight plaintext">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
改为：
Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();</code></pre>
<p>就可以了。</p>
<p>java.util.Collections工具类还提供了一个<strong>旧的线程安全集合转换器</strong>，可以这么用：</p>
<pre><code class="highlight plaintext">Map unsafeMap = new HashMap();
Map threadSafeMap = Collections.synchronizedMap(unsafeMap);</code></pre>
<p>但是它实际上是用一个包装类包装了非线程安全的Map，然后对所有读写方法都用synchronized加锁，这样获得的线程安全集合的性能比java.util.concurrent集合要低很多，所以<strong>不推荐使用</strong>。</p>
<h3 id="atomic"><a class="markdownIt-Anchor" href="#atomic"></a> Atomic</h3>
<p>Java的java.util.concurrent包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于java.util.concurrent.atomic包。</p>
<p>我们以AtomicInteger为例，它提供的主要操作有：</p>
<ul>
<li>增加值并返回新值：int addAndGet(int delta)</li>
<li>加1后返回新值：int incrementAndGet()</li>
<li>获取当前值：int get()</li>
<li>用CAS方式设置：int compareAndSet(int expect, int update)</li>
</ul>
<p>Atomic类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了CAS：Compare and Set。</p>
<p>如果我们自己通过CAS编写incrementAndGet()，它大概长这样：</p>
<pre><code class="highlight plaintext">public int incrementAndGet(AtomicInteger var) &#123;
    int prev, next;
    do &#123;
        prev = var.get();
        next = prev + 1;
    &#125; while ( ! var.compareAndSet(prev, next));
    return next;
&#125;</code></pre>
<p>CAS是指，在这个操作中，如果AtomicInteger的当前值是prev，那么就更新为next，返回true。如果AtomicInteger的当前值不是prev，就什么也不干，返回false。通过CAS操作并配合do … while循环，即使其他线程修改了AtomicInteger的值，最终的结果也是正确的。</p>
<p>我们利用AtomicLong可以编写一个多线程安全的全局唯一ID生成器：class</p>
<pre><code class="highlight plaintext">IdGenerator &#123;
    AtomicLong var = new AtomicLong(0);

    public long getNextId() &#123;
        return var.incrementAndGet();
    &#125;
&#125;</code></pre>
<p>通常情况下，我们并不需要直接用do … while循环调用compareAndSet实现复杂的并发操作，而是用incrementAndGet()这样的封装好的方法，因此，使用起来非常简单。</p>
<p>在高度竞争的情况下，还可以使用Java 8提供的LongAdder和LongAccumulator。</p>
<h3 id="java-threadlocal"><a class="markdownIt-Anchor" href="#java-threadlocal"></a> Java ThreadLocal</h3>
<p>Java中的ThreadLocal类可以让你创建的变量只被同一个线程进行读和写操作。因此，尽管有两个线程同时执行一段相同的代码，而且这段代码又有一个指向同一个ThreadLocal变量的引用，但是这两个线程依然不能看到彼此的ThreadLocal变量域。</p>
<p><strong>创建一个ThreadLocal对象</strong></p>
<pre><code class="highlight plaintext">private ThreadLocal myThreadLocal = new ThreadLocal();</code></pre>
<p>你实例化了一个ThreadLocal对象。每个线程仅需要实例化一次即可。虽然不同的线程执行同一段代码时，访问同一个ThreadLocal变量，但是每个线程只能看到私有的ThreadLocal实例。所以不同的线程在给ThreadLocal对象设置不同的值时，他们也不能看到彼此的修改。</p>
<p><strong>访问ThreadLocal对象</strong></p>
<p>一旦创建了一个ThreadLocal对象，你就可以通过以下方式来存储此对象的值：</p>
<pre><code class="highlight plaintext">myThreadLocal.set(&quot;A thread local value&quot;);</code></pre>
<p>也可以直接读取一个ThreadLocal对象的值：</p>
<p>get()方法会返回一个Object对象，而set()方法则依赖一个Object对象参数。</p>
<p><strong>ThreadLocal泛型</strong></p>
<p>为了使get()方法返回值不用做强制类型转换，通常可以创建一个泛型化的ThreadLocal对象。以下就是一个泛型化的ThreadLocal示例：</p>
<pre><code class="highlight plaintext">private ThreadLocal myThreadLocal1 = new ThreadLocal&lt;String&gt;();</code></pre>
<p>现在你可以存储一个字符串到ThreadLocal实例里，此外，当你从此ThreadLocal实例中获取值的时候，就不必要做强制类型转换。</p>
<pre><code class="highlight plaintext">myThreadLocal1.set(&quot;Hello ThreadLocal&quot;);
String threadLocalValues = myThreadLocal.get();</code></pre>
<p><strong>初始化ThreadLocal</strong></p>
<p>由于ThreadLocal对象的set()方法设置的值只对当前线程可见，那有什么方法可以为ThreadLocal对象设置的值对所有线程都可见。</p>
<p>为此，我们可以通过ThreadLocal子类的实现，并覆写initialValue()方法，就可以为ThreadLocal对象指定一个初始化值。如下所示:</p>
<pre><code class="highlight plaintext">private ThreadLocal myThreadLocal = new ThreadLocal&lt;String&gt;() &#123;
   @Override protected String initialValue() &#123;
       return &quot;This is the initial value&quot;;
   &#125;
&#125;;</code></pre>
<p>此时，在set()方法调用前，当调用get()方法的时候，所有线程都可以看到同一个初始化值。</p>
<p><strong>Full ThreadLocal Example</strong></p>
<p>以下是一个完整的ThreadLocal示例：</p>
<pre><code class="highlight plaintext">
public class ThreadLocalExample &#123;

    public static class MyRunnable implements Runnable &#123;

        private ThreadLocal&lt;Integer&gt; threadLocal =
               new ThreadLocal&lt;Integer&gt;();

        @Override
        public void run() &#123;
            threadLocal.set( (int) (Math.random() * 100D) );

            try &#123;
                Thread.sleep(2000);
            &#125; catch (InterruptedException e) &#123;
            &#125;

            System.out.println(threadLocal.get());
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        MyRunnable sharedRunnableInstance = new MyRunnable();

        Thread thread1 = new Thread(sharedRunnableInstance);
        Thread thread2 = new Thread(sharedRunnableInstance);

        thread1.start();
        thread2.start();

        thread1.join(); //wait for thread 1 to terminate
        thread2.join(); //wait for thread 2 to terminate
    &#125;

&#125;</code></pre>
<p>上面创建了两个线程共享一个MyRunnable实例。每个线程执行run()方法的时候，会给同一个ThreadLocal实例设置不同的值。如果调用set()方法的时候用synchronized关键字同步，而且不是一个ThreadLocal对象实例，那么第二个线程将会覆盖第一个线程所设置的值。</p>
<p>然而，由于是ThreadLocal对象，所以两个线程无法看到彼此的值。因此，可以设置或者获取不同的值。</p>
<p><strong>InheritableThreadLocal</strong></p>
<p>InheritableThreadLocal类是ThreadLocal的子类。为了解决ThreadLocal实例内部每个线程都只能看到自己的私有值，所以InheritableThreadLocal允许一个线程创建的所有子线程访问其父线程的值</p>
<h2 id="重入锁死"><a class="markdownIt-Anchor" href="#重入锁死"></a> 重入锁死</h2>
<p>重入锁死与死锁和嵌套管程锁死非常相似。锁和读写锁两篇文章中都有涉及到重入锁死的问题。</p>
<p>当一个线程重新获取锁，读写锁或其他不可重入的同步器时，就可能发生重入锁死。可重入的意思是线程可以重复获得它已经持有的锁。Java的synchronized块是可重入的。因此下面的代码是没问题的：（<strong>这里提到的锁都是指的不可重入的锁实现，并不是Java类库中的Lock与ReadWriteLock类</strong>）</p>
<pre><code class="highlight plaintext">public class Reentrant&#123;
        public synchronized outer()&#123;
                inner();
        &#125;

        public synchronized inner()&#123;
                //do something
        &#125;
&#125;</code></pre>
<p>注意outer()和inner()都声明为synchronized，这在Java中这相当于synchronized(this)块（这里两个方法是实例方法，synchronized的实例方法相当于在this上加锁，如果是static方法，则不然）。如果某个线程调用了outer()，outer()中的inner()调用是没问题的，因为两个方法都是在同一个管程对象(即this)上同步的。如果一个线程持有某个管程对象上的锁，那么它就有权访问所有在该管程对象上同步的块。这就叫可重入。若线程已经持有锁，那么它就可以重复访问所有使用该锁的代码块。</p>
<p>下面这个锁的实现是不可重入的：</p>
<pre><code class="highlight plaintext">public class Lock&#123;
        private boolean isLocked = false;
        public synchronized void lock()
                throws InterruptedException&#123;
                while(isLocked)&#123;
                        wait();
                &#125;
                isLocked = true;
        &#125;

        public synchronized void unlock()&#123;
                isLocked = false;
                notify();
        &#125;
&#125;</code></pre>
<p>如果一个线程在两次调用lock()间没有调用unlock()方法，那么第二次调用lock()就会被阻塞，这就出现了重入锁死</p>
<p>避免重入锁死有两个选择：</p>
<ul>
<li>编写代码时避免再次获取已经持有的锁</li>
<li>使用可重入锁</li>
</ul>
<p>至于哪个选择最适合你的项目，得视具体情况而定。可重入锁通常没有不可重入锁那么好的表现，而且实现起来复杂，但这些情况在你的项目中也许算不上什么问题。无论你的项目用锁来实现方便还是不用锁方便，可重入特性都需要根据具体问题具体分析。</p>
<h2 id="阻塞队列blockingqueue"><a class="markdownIt-Anchor" href="#阻塞队列blockingqueue"></a> 阻塞队列BlockingQueue</h2>
<p>阻塞队列与普通队列的区别在于，<strong>当队列是空的时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞</strong>。试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程使队列重新变得空闲起来，如从队列中移除一个或者多个元素，或者完全清空队列，下图展示了如何通过阻塞队列来合作：</p>
<p>从阻塞队列中移除元素从5.0开始，<strong>JDK在java.util.concurrent包里提供了阻塞队列的官方实现</strong>。尽管JDK中已经包含了阻塞队列的官方实现，但是熟悉其背后的原理还是很有帮助的。</p>
<h3 id="阻塞队列的实现"><a class="markdownIt-Anchor" href="#阻塞队列的实现"></a> 阻塞队列的实现</h3>
<p>阻塞队列的实现类似于带上限的Semaphore的实现。下面是阻塞队列的一个简单实现</p>
<pre><code class="highlight plaintext">public class BlockingQueue &#123;
    private List queue = new LinkedList();
    private int  limit = 10;

    public BlockingQueue(int limit)&#123;
       this.limit = limit;
    &#125;
    //入队列
    public synchronized void enqueue(Object item)
    throws InterruptedException  &#123;
        while(this.queue.size() == this.limit) &#123;
             wait();
        &#125;
        if(this.queue.size() == 0) &#123;
             notifyAll();
        &#125;
        this.queue.add(item);
    &#125;
    //出队列
    public synchronized Object dequeue()
    throws InterruptedException&#123;
        while(this.queue.size() == 0)&#123;
            wait();
        &#125;
        if(this.queue.size() == this.limit)&#123;
             notifyAll();
        &#125;
        return this.queue.remove(0);
    &#125;
&#125;</code></pre>
<blockquote>
<p>必须注意到，在enqueue和dequeue方法内部，只有队列的大小等于上限（limit）或者下限（0）时，才调用notifyAll方法。如果队列的大小既不等于上限，也不等于下限，任何线程调用enqueue或者dequeue方法时，都不会阻塞，都能够正常的往队列中添加或者移除元素。</p>
</blockquote>
<h2 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h2>
<p><strong>ExecutorService是所有线程池的接口</strong></p>
<p>合理利用线程池能够带来三个好处。</p>
<ul>
<li>第一：<strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>第二：<strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>第三：<strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。</li>
</ul>
<p>Java语言虽然内置了多线程支持，启动一个新线程非常方便，但是，创建线程需要操作系统资源（线程资源，栈空间等），<strong>频繁创建和销毁大量线程需要消耗大量时间</strong>。如果可以复用一组线程：</p>
<p>那么我们就可以把很多小任务让一组线程来执行，而不是一个任务对应一个新线程。</p>
<p>这种能接收大量小任务并进行分发处理的就是线程池。简单地说，线程池内部维护了若干个线程，没有任务的时候，这些线程都处于等待状态。如果有新任务，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。</p>
<p>Java标准库提供了ExecutorService接口表示线程池，它的典型用法如下：</p>
<pre><code class="highlight plaintext">// 创建固定大小的线程池:
ExecutorService executor = Executors.newFixedThreadPool(3);
// 提交任务:
executor.submit(task1);
executor.submit(task2);
executor.submit(task3);
executor.submit(task4);
executor.submit(task5);</code></pre>
<p>因为ExecutorService只是接口，Java标准库提供的几个常用实现类有：</p>
<ul>
<li>FixedThreadPool：线程数固定的线程池；</li>
<li>CachedThreadPool：线程数根据任务动态调整的线程池；</li>
<li>SingleThreadExecutor：仅单线程执行的线程池。</li>
</ul>
<p>创建这些线程池的方法都被封装到Executors这个类中。我们以FixedThreadPool为例，看看线程池的执行逻辑：</p>
<pre><code class="highlight plaintext">import java.util.concurrent.*;

public class Main &#123;
    public static void main(String[] args) &#123;
        // 创建一个固定大小的线程池:
        ExecutorService es = Executors.newFixedThreadPool(4);
        for (int i = 0; i &lt; 6; i++) &#123;
            es.submit(new Task(&quot;&quot; + i));
        &#125;
        // 关闭线程池:
        es.shutdown();
    &#125;
&#125;

class Task implements Runnable &#123;
    private final String name;

    public Task(String name) &#123;
        this.name = name;
    &#125;

    @Override
    public void run() &#123;
        System.out.println(&quot;start task &quot; + name);
        try &#123;
            Thread.sleep(1000);
        &#125; catch (InterruptedException e) &#123;
        &#125;
        System.out.println(&quot;end task &quot; + name);
    &#125;
&#125;
</code></pre>
<p>我们观察执行结果，一次性放入6个任务，由于线程池只有固定的4个线程，因此，前4个任务会同时执行，等到有线程空闲后，才会执行后面的两个任务。</p>
<p>线程池在程序结束的时候要关闭。使用shutdown()方法关闭线程池的时候，它会等待正在执行的任务先完成，然后再关闭。shutdownNow()会立刻停止正在执行的任务，awaitTermination()则会等待指定的时间让线程池关闭。</p>
<p>如果我们把线程池改为CachedThreadPool，由于这个线程池的实现会根据任务数量动态调整线程池的大小，所以6个任务可一次性全部同时执行。如果我们想把线程池的大小限制在4～10个之间动态调整怎么办？</p>
<p>我们查看Executors.newCachedThreadPool()方法的源码：</p>
<pre><code class="highlight plaintext">
public static ExecutorService newCachedThreadPool() &#123;
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                    60L, TimeUnit.SECONDS,
                                    new SynchronousQueue&lt;Runnable&gt;());
&#125;</code></pre>
<p>因此，想创建指定动态范围的线程池，可以这么写：int min = 4;</p>
<pre><code class="highlight plaintext">int max = 10;
ExecutorService es = new ThreadPoolExecutor(min, max,
        60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());</code></pre>
<p><strong>ScheduledThreadPool</strong></p>
<p>还有一种任务，需要定期反复执行，例如，每秒刷新证券价格。这种任务本身固定，需要反复执行的，可以使用ScheduledThreadPool。放入ScheduledThreadPool的任务可以定期反复执行。创建一个ScheduledThreadPool仍然是通过Executors类：</p>
<pre><code class="highlight plaintext">ScheduledExecutorService ses = Executors.newScheduledThreadPool(4);</code></pre>
<p>我们可以提交一次性任务，它会在指定延迟后只执行一次：</p>
<pre><code class="highlight plaintext">// 1秒后执行一次性任务:
ses.schedule(new Task(&quot;one-time&quot;), 1, TimeUnit.SECONDS);</code></pre>
<p>如果任务以固定的每3秒执行，我们可以这样写：</p>
<pre><code class="highlight plaintext">// 2秒后开始执行定时任务，每3秒执行:
ses.scheduleAtFixedRate(new Task(&quot;fixed-rate&quot;), 2, 3, TimeUnit.SECONDS);</code></pre>
<p>如果任务以固定的3秒为间隔执行，我们可以这样写：</p>
<pre><code class="highlight plaintext">// 2秒后开始执行定时任务，以3秒为间隔执行:
ses.scheduleWithFixedDelay(new Task(&quot;fixed-delay&quot;), 2, 3, TimeUnit.SECONDS);</code></pre>
<p>注意FixedRate和FixedDelay的区别。FixedRate是指任务总是以固定时间间隔触发，不管任务执行多长时间：</p>
<p>而FixedDelay是指，上一次任务执行完毕后，等待固定的时间间隔，再执行下一次任务：</p>
<p>因此，使用ScheduledThreadPool时，我们要根据需要选择执行一次、FixedRate执行还是FixedDelay执行。</p>
<p>细心的童鞋还可以思考下面的问题：</p>
<ul>
<li>在FixedRate模式下，假设每秒触发，如果某次任务执行时间超过1秒，后续任务会不会并发执行？</li>
<li>如果任务抛出了异常，后续任务是否继续执行？</li>
</ul>
<p>Java标准库还提供了一个java.util.Timer类，这个类也可以定期执行任务，但是，一个Timer会对应一个Thread，所以，一个Timer只能定期执行一个任务，多个定时任务必须启动多个Timer，而一个ScheduledThreadPool就可以调度多个定时任务，所以，我们完全可以用ScheduledThreadPool取代旧的Timer。</p>
<h3 id="threadpoolexecutor"><a class="markdownIt-Anchor" href="#threadpoolexecutor"></a> ThreadPoolExecutor</h3>
<h4 id="线程池使用"><a class="markdownIt-Anchor" href="#线程池使用"></a> 线程池使用</h4>
<p><strong>创建一个线程�</strong>�</p>
<pre><code class="highlight plaintext">new ThreadPoolExecutor(corePoolSize, maximumPoolSize,
keepAliveTime, milliseconds,runnableTaskQueue, threadFactory,RejectedExecutionHandler
);</code></pre>
<ul>
<li><strong>corePoolSize</strong>（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的<strong>prestartAllCoreThreads</strong>方法，线程池会提前创建并启动所有基本线程</li>
<li><strong>runnableTaskQueue</strong>（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。
<ul>
<li><code>ArrayBlockingQueue</code>：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序</li>
<li><code>LinkedBlockingQueue</code>：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列</li>
<li><code>SynchronousQueue</code>：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列</li>
<li><code>PriorityBlockingQueue</code>：一个具有优先级得无限阻塞队列</li>
</ul>
</li>
<li><strong>maximumPoolSize</strong>（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。</li>
<li><strong>ThreadFactory</strong>：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug和定位问题时非常又帮助</li>
<li><strong>RejectedExecutionHandler</strong>（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是<code>AbortPolicy(直接抛出异常)</code>，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略
<ul>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉。</li>
<li>当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。</li>
</ul>
</li>
<li><strong>keepAliveTime</strong>（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</li>
<li><strong>TimeUnit</strong>（线程活动保持时间的单位）：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)</li>
</ul>
<hr />
<p><strong>向线程提交一个任务</strong></p>
<p>我们可以使用<strong>execute</strong>提交的任务，但是execute方法没有返回值，所以无法判断任务知否被线程池执行成功。通过以下代码可知execute方法输入的任务是一个Runnable类的实例。</p>
<pre><code class="highlight plaintext">threadsPool.execute(new Runnable() &#123;
    public void run() &#123;
    // TODO Auto-generated method stub
    &#125;
&#125;);</code></pre>
<p>我们也可以使用<strong>submit</strong> 方法来提交任务，它会<strong>返回一个future</strong>,那么我们可以通过这个future来判断任务是否执行成功，<strong>通过future的get方法来获取返回值</strong>，get方法会阻塞住直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。</p>
<pre><code class="highlight plaintext">try &#123;
Object s = future.get();
&#125; catch (InterruptedException e) &#123;
// 处理中断异常
&#125; catch (ExecutionException e) &#123;
// 处理无法执行任务异常
&#125; finally &#123;
// 关闭线程池
executor.shutdown();
&#125;</code></pre>
<hr />
<h4 id="线程池的关闭"><a class="markdownIt-Anchor" href="#线程池的关闭"></a> 线程池的关闭</h4>
<p>我们可以通过<strong>调用线程池的shutdown或shutdownNow方法来关闭线程�</strong>�，但是它们的实现原理不同，shutdown的原理是只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。shutdownNow的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。shutdownNow会首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。</p>
<p>只要调用了这两个关闭方法的其中一个，<strong>isShutdown方法就会返回true</strong>。当所有的任务都已关闭后,才表示<strong>线程池关闭成功，这时调用isTerminaed方法会返回true</strong>。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow。</p>
<h4 id="线程池的分析"><a class="markdownIt-Anchor" href="#线程池的分析"></a> 线程池的分析</h4>
<p>流程分析：线程池的主要工作流程如下图：</p>
<p>从上图我们可以看出，当提交一个新任务到线程池时，线程池的处理流程如下：</p>
<ol>
<li>首先线程池判断基本线程池是否已满？没满，创建一个工作线程来执行任务。满了，则进入下个流程。</li>
<li>其次线程池判断工作队列是否已满？没满，则将新提交的任务存储在工作队列里。满了，则进入下个流程。</li>
<li>最后线程池判断整个线程池是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务。</li>
</ol>
<p><strong>源码分析</strong>。上面的流程分析让我们很直观的了解的线程池的工作原理，让我们再通过源代码来看看是如何实现的。线程池执行任务的方法如下：</p>
<pre><code class="highlight plaintext">public void execute(Runnable command) &#123;
    if (command == null)
    throw new NullPointerException();
    //如果线程数小于基本线程数，则创建线程并执行当前任务
    if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;
        //如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。
        if (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;
             if (runState != RUNNING || poolSize == 0)
             ensureQueuedTaskHandled(command);
          &#125;
    //如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量，则创建一个线程执行任务。
    else if (!addIfUnderMaximumPoolSize(command))
        //抛出RejectedExecutionException异常
        reject(command); // is shutdown or saturated
    &#125;
&#125;</code></pre>
<p><strong>工作线程</strong>。线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会无限循环获取工作队列里的任务来执行。我们可以从Worker的run方法里看到这点：</p>
<pre><code class="highlight plaintext">public void run() &#123;
     try &#123;
           Runnable task = firstTask;
           firstTask = null;
            while (task != null || (task = getTask()) != null) &#123;
                    runTask(task);
                    task = null;
            &#125;
      &#125; finally &#123;
             workerDone(this);
      &#125;
&#125;</code></pre>
<h4 id="合理的配置线程池"><a class="markdownIt-Anchor" href="#合理的配置线程池"></a> 合理的配置线程池</h4>
<p>要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：</p>
<ul>
<li>任务的性质：CPU密集型任务，IO密集型任务和混合型任务。</li>
<li>任务的优先级：高，中和低。</li>
<li>任务的执行时间：长，中和短。</li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li>
</ul>
<p>任务性质不同的任务可以用不同规模的线程池分开处理。</p>
<ul>
<li><strong>CPU密集型</strong>任务配置尽可能少的线程数量，如配置Ncpu+1个线程的线程池。</li>
<li><strong>IO密集型</strong>任务则由于需要等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如<code>2*Ncpu</code></li>
<li><strong>混合型</strong>的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解</li>
<li><strong>优先级不同</strong>的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行</li>
<li><strong>执行时间不同</strong>的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行</li>
<li><strong>依赖数据库连接�</strong>�的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU</li>
</ul>
<blockquote>
<p>我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数</p>
</blockquote>
<p><strong>建议使用有界队列</strong>，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。有一次我们组使用的后台任务线程池的队列和线程池全满了，不断的抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞住，任务积压在线程池里。如果当时我们设置成无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然我们的系统所有的任务是用的单独的服务器部署的，而我们使用不同规模的线程池跑不同类型的任务，但是出现这样问题时也会影响到其他任务</p>
<h4 id="线程池的监控"><a class="markdownIt-Anchor" href="#线程池的监控"></a> 线程池的监控</h4>
<p><strong>通过线程池提供的参数进行监控</strong></p>
<p>线程池里有一些属性在监控线程池的时候可以使用</p>
<ul>
<li>taskCount：线程池需要执行的任务数量。</li>
<li>completedTaskCount：线程池在运行过程中已完成的任务数量。小于或等于taskCount。</li>
<li>largestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。</li>
<li>getPoolSize:线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不减。</li>
<li>getActiveCount：获取活动的线程数</li>
</ul>
<p><strong>通过扩展线程池进行监控</strong></p>
<p>通过继承线程池并重写线程池的beforeExecute，afterExecute和terminated方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。如：</p>
<pre><code class="highlight plaintext">protected void beforeExecute(Thread t, Runnable r) &#123; &#125;</code></pre>
<h3 id="executors"><a class="markdownIt-Anchor" href="#executors"></a> <s>Executors</s></h3>
<p>通过Executors提供四种线程池，分别为：</p>
<ul>
<li><strong>newCachedThreadPool</strong> 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li><strong>newFixedThreadPool</strong> 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li><strong>newScheduledThreadPool</strong> 创建一个定长线程池，支持定时及周期性任务执行。</li>
<li><strong>SingleThreadPool</strong> 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li>
</ul>
<h4 id="executors的简单使用"><a class="markdownIt-Anchor" href="#executors的简单使用"></a> Executors的简单使用</h4>
<pre><code class="highlight plaintext">
import java.util.ArrayList;   
import java.util.List;   
import java.util.concurrent.*;   
  
public class CallableDemo&#123;   
    public static void main(String[] args)&#123;   
        ExecutorService executorService = Executors.newCachedThreadPool();   
        List&lt;Future&lt;String&gt;&gt; resultList = new ArrayList&lt;Future&lt;String&gt;&gt;();   
  
        //创建10个任务并执行   
        for (int i = 0; i &lt; 10; i++)&#123;   
            //使用ExecutorService执行Callable类型的任务，并将结果保存在future变量中   
            Future&lt;String&gt; future = executorService.submit(new TaskWithResult(i));   
            //将任务执行结果存储到List中   
            resultList.add(future);   
        &#125;   
  
        //遍历任务的结果   
        for (Future&lt;String&gt; fs : resultList)&#123;   
                try&#123;   
                    while(!fs.isDone);//Future返回如果没有完成，则一直循环等待，直到Future返回完成  
                    System.out.println(fs.get());     //打印各个线程（任务）执行的结果   
                &#125;catch(InterruptedException e)&#123;   
                    e.printStackTrace();   
                &#125;catch(ExecutionException e)&#123;   
                    e.printStackTrace();   
                &#125;finally&#123;   
                    //启动一次顺序关闭，执行以前提交的任务，但不接受新任务  
                    executorService.shutdown();   
                &#125;   
        &#125;   
    &#125;   
&#125;   
  
  
class TaskWithResult implements Callable&lt;String&gt;&#123;   
    private int id;   
  
    public TaskWithResult(int id)&#123;   
        this.id = id;   
    &#125;   
  
    /**  
     * 任务的具体过程，一旦任务传给ExecutorService的submit方法， 
     * 则该方法自动在一个线程上执行 
     */   
    public String call() throws Exception &#123;  
        System.out.println(&quot;call()方法被自动调用！！！    &quot; + Thread.currentThread().getName());   
        //该返回结果将被Future的get方法得到  
        return &quot;call()方法被自动调用，任务返回的结果是：&quot; + id + &quot;    &quot; + Thread.currentThread().getName();   
    &#125;   
&#125;</code></pre>
<h4 id="使用executors的风险"><a class="markdownIt-Anchor" href="#使用executors的风险"></a> 使用Executors的风险</h4>
<p>《阿里巴巴Java开发手册》中强调线程池不允许使用 Executors 去创建，而是通过 new ThreadPoolExecutor 实例的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<ul>
<li>FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。</li>
<li>CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</li>
</ul>
<blockquote>
<p>说白了，使用Executors类创建线程池与使用ThreadPoolExecutor类的区别就是使用ThreadPoolExecutor类可以自定义传入我们设置的线程池的参数，更加灵活</p>
</blockquote>
<h3 id="线程池实现原理"><a class="markdownIt-Anchor" href="#线程池实现原理"></a> 线程池实现原理</h3>
<p>线程池（Thread Pool）对于限制应用程序中同一时刻运行的线程数很有用。因为<strong>每启动一个新线程都会有相应的性能开销</strong>，每个线程都需要给栈分配一些内存等等。</p>
<p>我们可以把并发执行的任务传递给一个线程池，来替代为每个并发执行的任务都启动一个新的线程。<strong>只要池里有空闲的线程，任务就会分配给一个线程执行</strong>。在线程池的内部，<strong>任务被插入一个阻塞队列</strong>（Blocking Queue ），线程池里的线程会去取这个队列里的任务。<strong>当一个新任务插入队列时，一个空闲线程就会成功的从队列中取出任务并且执行它</strong>。</p>
<p>线程池经常应用在多线程服务器上。每个通过网络到达服务器的连接都被包装成一个任务并且传递给线程池。线程池的线程会并发的处理连接上的请求。以后会再深入有关 Java 实现多线程服务器的细节。</p>
<p>Java 5 在 java.util.concurrent 包中自带了内置的线程池 <strong>java.util.concurrent.ExecutorService</strong>，所以你不用非得实现自己的线程池。</p>
<p>这里有一个简单的线程池实现：</p>
<p><strong>ThreadPool 是线程池的公开接口</strong></p>
<pre><code class="highlight plaintext">
public class ThreadPool &#123;
    //所有来的任务都进入阻塞队列
  private BlockingQueue taskQueue = null;
  //管理线程的容器
  private List&lt;PoolThread&gt; threads = new ArrayList&lt;PoolThread&gt;();
  //停止标志位
  private boolean isStopped = false;

  public ThreadPool(int noOfThreads, int maxNoOfTasks) &#123;
    taskQueue = new BlockingQueue(maxNoOfTasks);

    for (int i=0; i&lt;noOfThreads; i++) &#123;
      threads.add(new PoolThread(taskQueue));
    &#125;
    for (PoolThread thread : threads) &#123;
      thread.start();
    &#125;
  &#125;

  public void synchronized execute(Runnable task) &#123;
    if(this.isStopped) throw
      new IllegalStateException(&quot;ThreadPool is stopped&quot;);

    this.taskQueue.enqueue(task);
  &#125;

  public synchronized boolean stop() &#123;
    this.isStopped = true;
    for (PoolThread thread : threads) &#123;
      thread.stop();
    &#125;
  &#125;
&#125;</code></pre>
<p><strong>PoolThread 用来实现执行任务的子线程</strong></p>
<pre><code class="highlight plaintext">public class PoolThread extends Thread &#123;

  private BlockingQueue&lt;Runnable&gt; taskQueue = null;
  private boolean       isStopped = false;

  public PoolThread(BlockingQueue&lt;Runnable&gt; queue) &#123;
    taskQueue = queue;
  &#125;

  public void run() &#123;
    while (!isStopped()) &#123;
      try &#123;
        Runnable runnable =taskQueue.take();
        runnable.run();
      &#125; catch(Exception e) &#123;
        // 写日志或者报告异常,
        // 但保持线程池运行.
      &#125;
    &#125;
  &#125;

  public synchronized void toStop() &#123;
    isStopped = true;
    this.interrupt(); // 打断池中线程的 dequeue() 调用.
  &#125;

  public synchronized boolean isStopped() &#123;
    return isStopped;
  &#125;
&#125;
</code></pre>
<h2 id="cas"><a class="markdownIt-Anchor" href="#cas"></a> CAS</h2>
<p>CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。简单来说，比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。这听起来可能有一点复杂但是实际上你理解之后发现很简单，接下来，让我们跟深入的了解一下这项技术</p>
<h3 id="cas的使用场景"><a class="markdownIt-Anchor" href="#cas的使用场景"></a> CAS的使用场景</h3>
<p>在程序和算法中一个经常出现的模式就是“check and act”模式。先检查后操作模式发生在代码中首先检查一个变量的值，然后再基于这个值做一些操作。下面是一个简单的示例：</p>
<pre><code class="highlight plaintext">class MyLock &#123;
    private boolean locked = false;

    public boolean lock() &#123;
        if(!locked) &#123;
            locked = true;
            return true;
        &#125;
        return false;
    &#125;
&#125;</code></pre>
<p>上面这段代码，如果用在多线程的程序会出现很多错误，不过现在请忘掉它。</p>
<p>如你所见，lock()方法首先检查locked&gt;成员变量是否等于false，如果等于，就将locked设为true。</p>
<p>如果多个个线程访问同一个MyLock实例，上面的lock()将不能保证正常工作。</p>
<p>为了在一个多线程程序中良好的工作，”check then act” 操作必须是原子的。原子就是说”check“操作和”act“被当做一个原子代码块执行。不存在多个线程同时执行原子块</p>
<p>下面是一个代码示例，把之前的lock()方法用synchronized关键字重构成一个原子块。</p>
<pre><code class="highlight plaintext">class MyLock &#123;

    private boolean locked = false;

    public synchronized boolean lock() &#123;
        if(!locked) &#123;
            locked = true;
            return true;
        &#125;
        return false;
    &#125;
&#125;</code></pre>
<p>现在lock()方法是同步的，所以，在某一时刻只能有一个线程在同一个MyLock实例上执行它</p>
<p>原子的lock方法实际上是一个”compare and swap“的例子</p>
<h3 id="cas用作原子操作"><a class="markdownIt-Anchor" href="#cas用作原子操作"></a> CAS用作原子操作</h3>
<p>现在CPU内部已经执行原子的CAS操作。Java5以来，你可以使用java.util.concurrent.atomic包中的一些原子类来使用CPU中的这些功能</p>
<p>下面是一个使用AtomicBoolean类实现lock()方法的例子：</p>
<pre><code class="highlight plaintext">public static class MyLock &#123;
    private AtomicBoolean locked = new AtomicBoolean(false);

    public boolean lock() &#123;
        return locked.compareAndSet(false, true);
    &#125;
&#125;</code></pre>
<p>locked变量不再是boolean类型而是AtomicBoolean。这个类中有一个compareAndSet()方法，它使用一个期望值和AtomicBoolean实例的值比较，和两者相等，则使用一个新值替换原来的值。在这个例子中，它比较locked的值和false，如果locked的值为false，则把修改为true。</p>
<p>如果值被替换了，compareAndSet()返回true，否则，返回false</p>
<p>使用Java5+提供的CAS特性而不是使用自己实现的的好处是Java5+中内置的CAS特性可以让你利用底层的你的程序所运行机器的CPU的CAS特性。这会使还有CAS的代码运行更快</p>
<h2 id="刨析同步器"><a class="markdownIt-Anchor" href="#刨析同步器"></a> 刨析同步器</h2>
<p>虽然许多同步器（如锁，信号量，阻塞队列等）功能上各不相同，但它们的内部设计上却差别不大。换句话说，它们内部的的基础部分是相同（或相似）的。了解这些基础部件能在设计同步器的时候给我们大大的帮助。这就是本文要细说的内容。</p>
<p>大部分同步器都是用来保护某个区域（临界区）的代码，这些代码可能会被多线程并发访问。要实现这个目标，同步器一般要支持下列功能：</p>
<p><strong>状态</strong></p>
<p>同步器中的<strong>状态是用来确定某个线程是否有访问权限</strong>。在Lock中，状态是boolean类型的，表示当前Lock对象是否处于锁定状态。在BoundedSemaphore中，内部状态包含一个计数器（int类型）和一个上限（int类型），分别表示当前已经获取的许可数和最大可获取的许可数。BlockingQueue的状态是该队列中元素列表以及队列的最大容量</p>
<p>下面是Lock和BoundedSemaphore中的两个代码片段</p>
<pre><code class="highlight plaintext">public class Lock&#123;
  //state is kept here
  private boolean isLocked = false; 
  public synchronized void lock()
  throws InterruptedException&#123;
    while(isLocked)&#123;
      wait();
    &#125;
    isLocked = true;
  &#125;
  ...
&#125;</code></pre>
<pre><code class="highlight plaintext">public class BoundedSemaphore &#123;
  //state is kept here
  private int signals = 0;
  private int bound   = 0;
      
  public BoundedSemaphore(int upperBound)&#123;
    this.bound = upperBound;
  &#125;
  public synchronized void take() throws InterruptedException&#123;
    while(this.signals == bound) wait();
    this.signal++;
    this.notify();
  &#125;
  ...
&#125;</code></pre>
<p><strong>访问条件</strong></p>
<p>访问条件决定调用test-and-set-state方法的线程是否可以对状态进行设置。访问条件一般是基于同步器状态的。通常是放在一个while循环里，以避免虚假唤醒问题。访问条件的计算结果要么是true要么是false</p>
<p>Lock中的访问条件只是简单地检查isLocked的值。根据执行的动作是“获取”还是“释放”，BoundedSemaphore中实际上有两个访问条件。如果某个线程想“获取”许可，将检查signals变量是否达到上限；如果某个线程想“释放”许可，将检查signals变量是否为0</p>
<p>这里有两个来自Lock和BoundedSemaphore的代码片段，它们都有访问条件。注意观察条件是怎样在while循环中检查的。</p>
<pre><code class="highlight plaintext">public class Lock&#123;
  private boolean isLocked = false;
  public synchronized void lock()
  throws InterruptedException&#123;
    //access condition
    while(isLocked)&#123;
      wait();
    &#125;
    isLocked = true;
  &#125;
  ...
&#125;</code></pre>
<pre><code class="highlight plaintext">public class BoundedSemaphore &#123;
  private int signals = 0;
  private int bound = 0;
  
  public BoundedSemaphore(int upperBound)&#123;
    this.bound = upperBound;
  &#125;
  public synchronized void take() throws InterruptedException&#123;
    //access condition
    while(this.signals == bound) wait();
    this.signals++;
    this.notify();
  &#125;
  public synchronized void release() throws InterruptedException&#123;
    //access condition
    while(this.signals == 0) wait();
    this.signals--;
    this.notify();
  &#125;
&#125;</code></pre>
<p><strong>状态变化</strong></p>
<p>一旦一个线程获得了临界区的访问权限，它得改变同步器的状态，让其它线程阻塞，防止它们进入临界区。换而言之，这个状态表示正有一个线程在执行临界区的代码。其它线程想要访问临界区的时候，该状态应该影响到访问条件的结果</p>
<p>在Lock中，通过代码设置isLocked = true来改变状态，在信号量中，改变状态的是signals–或signals++;</p>
<pre><code class="highlight plaintext">public class Lock&#123;

  private boolean isLocked = false;

  public synchronized void lock()
  throws InterruptedException&#123;
    while(isLocked)&#123;
      wait();
    &#125;
    //state change
    isLocked = true;
  &#125;

  public synchronized void unlock()&#123;
    //state change
    isLocked = false;
    notify();
  &#125;
&#125;</code></pre>
<pre><code class="highlight plaintext">public class BoundedSemaphore &#123;
  private int signals = 0;
  private int bound   = 0;

  public BoundedSemaphore(int upperBound)&#123;
    this.bound = upperBound;
  &#125;

  public synchronized void take() throws InterruptedException&#123;
    while(this.signals == bound) wait();
    //state change
    this.signals++;
    this.notify();
  &#125;

  public synchronized void release() throws InterruptedException&#123;
    while(this.signals == 0) wait();
    //state change
    this.signals--;
    this.notify();
  &#125;
&#125;</code></pre>
<p><strong>通知策略</strong></p>
<p>一旦某个线程改变了同步器的状态，可能需要通知其它等待的线程状态已经变了。因为也许这个状态的变化会让其它线程的访问条件变为true。</p>
<p>通知策略通常分为三种：</p>
<ul>
<li>通知所有等待的线程</li>
<li>通知N个等待线程中的任意一个</li>
<li>通知N个等待线程中的某个指定的线程</li>
</ul>
<p>通知所有等待的线程非常简单。所有等待的线程都调用的同一个对象上的wait()方法，某个线程想要通知它们只需在这个对象上调用notifyAll()方法</p>
<p>通知等待线程中的任意一个也很简单，只需将notifyAll()调用换成notify()即可。调用notify方法没办法确定唤醒的是哪一个线程，也就是“等待线程中的任意一个”。</p>
<p>有时候可能需要通知指定的线程而非任意一个等待的线程。例如，如果你想保证线程被通知的顺序与它们进入同步块的顺序一致，或按某种优先级的顺序来通知。想要实现这种需求，每个等待的线程必须在其自有的对象上调用wait()。当通知线程想要通知某个特定的等待线程时，调用该线程自有对象的notify()方法即可。饥饿和公平中有这样的例子</p>
<p>下面是通知策略的一个例子（通知任意一个等待线程）：</p>
<pre><code class="highlight plaintext">public class Lock&#123;

  private boolean isLocked = false;

  public synchronized void lock()
  throws InterruptedException&#123;
    while(isLocked)&#123;
      //wait strategy - related to notification strategy
      wait();
    &#125;
    isLocked = true;
  &#125;

  public synchronized void unlock()&#123;
    isLocked = false;
    notify(); //notification strategy
  &#125;
&#125;
</code></pre>
<p><strong>Test-and-Set方法</strong></p>
<p>同步器中最常见的有两种类型的方法，test-and-set是第一种（set是另一种）。Test-and-set的意思是，调用这个方法的线程检查访问条件，如若满足，该线程设置同步器的内部状态来表示它已经获得了访问权限</p>
<p>状态的改变通常使其它试图获取访问权限的线程计算条件状态时得到false的结果，但并不一定总是如此。例如，在读写锁中，获取读锁的线程会更新读写锁的状态来表示它获取到了读锁，但是，只要没有线程请求写锁，其它请求读锁的线程也能成功。</p>
<p>test-and-set很有必要是原子的，也就是说在某个线程检查和设置状态期间，不允许有其它线程在test-and-set方法中执行。</p>
<p>test-and-set方法的程序流通常遵照下面的顺序：</p>
<ul>
<li>如有必要，在检查前先设置状态</li>
<li>检查访问条件</li>
<li>如果访问条件不满足，则等待</li>
<li>如果访问条件满足，设置状态，如有必要还要通知等待线程</li>
</ul>
<p>下面的ReadWriteLock类的lockWrite()方法展示了test-and-set方法。调用lockWrite()的线程在检查之前先设置状态(writeRequests++)。然后检查canGrantWriteAccess()中的访问条件，如果检查通过，在退出方法之前再次设置内部状态。这个方法中没有去通知等待线程。</p>
<pre><code class="highlight plaintext">
public class ReadWriteLock&#123;
    private Map&lt;Thread, Integer&gt; readingThreads =
        new HashMap&lt;Thread, Integer&gt;();

    private int writeAccesses    = 0;
    private int writeRequests    = 0;
    private Thread writingThread = null;

    ...
        
    public synchronized void lockWrite() throws InterruptedException&#123;
      writeRequests++;
      Thread callingThread = Thread.currentThread();
      while(! canGrantWriteAccess(callingThread))&#123;
        wait();
      &#125;
      writeRequests--;
      writeAccesses++;
      writingThread = callingThread;
    &#125; 
        
    ...
&#125;
</code></pre>
<p>下面的BoundedSemaphore类有两个test-and-set方法：take()和release()。两个方法都有检查和设置内部状态。</p>
<pre><code class="highlight plaintext">public class BoundedSemaphore &#123;
  private int signals = 0;
  private int bound   = 0;

  public BoundedSemaphore(int upperBound)&#123;
    this.bound = upperBound;
  &#125;

  public synchronized void take() throws InterruptedException&#123;
    while(this.signals == bound) wait();
    this.signals++;
    this.notify();
  &#125;

  public synchronized void release() throws InterruptedException&#123;
    while(this.signals == 0) wait();
    this.signals--;
    this.notify();
  &#125;
&#125;</code></pre>
<p><strong>Set方法</strong></p>
<p>set方法是同步器中常见的第二种方法。set方法仅是设置同步器的内部状态，而不先做检查。set方法的一个典型例子是Lock类中的unlock()方法。持有锁的某个线程总是能够成功解锁，而不需要检查该锁是否处于解锁状态。</p>
<p>set方法的程序流通常如下：</p>
<ul>
<li>设置内部状态</li>
<li>通知等待的线程</li>
</ul>
<p>这里是unlock()方法的一个例子：</p>
<pre><code class="highlight plaintext">public class Lock&#123;
  private boolean isLocked = false;
  
  public synchronized void unlock()&#123;
    isLocked = false;
    notify();
  &#125;
&#125;</code></pre>
<h2 id="非阻塞算法"><a class="markdownIt-Anchor" href="#非阻塞算法"></a> 非阻塞算法</h2>
<p>在并发上下文中，非阻塞算法是一种允许线程在阻塞其他线程的情况下访问共享状态的算法。在绝大多数项目中，在算法中如果一个线程的挂起没有导致其它的线程挂起，我们就说这个算法是非阻塞的。</p>
<p>为了更好的理解阻塞算法和非阻塞算法之间的区别，我会先讲解阻塞算法然后再讲解非阻塞算法。</p>
<h3 id="阻塞并发算法"><a class="markdownIt-Anchor" href="#阻塞并发算法"></a> 阻塞并发算法</h3>
<p>一个阻塞并发算法一般分下面两步：</p>
<ul>
<li>执行线程请求的操作</li>
<li>阻塞线程直到可以安全地执行操作</li>
</ul>
<p>很多算法和并发数据结构都是阻塞的。例如，java.util.concurrent.BlockingQueue的不同实现都是阻塞数据结构。如果一个线程要往一个阻塞队列中插入一个元素，队列中没有足够的空间，执行插入操作的线程就会阻塞直到队列中有了可以存放插入元素的空间。</p>
<p>下图演示了一个阻塞算法保证一个共享数据结构的行为：</p>
<h3 id="非阻塞并发算法"><a class="markdownIt-Anchor" href="#非阻塞并发算法"></a> 非阻塞并发算法</h3>
<p>一个非阻塞并发算法一般包含下面两步：</p>
<ul>
<li>执行线程请求的操作</li>
<li>通知请求线程操作不能被执行</li>
</ul>
<p>Java也包含几个非阻塞数据结构。AtomicBoolean,AtomicInteger,AtomicLong,AtomicReference都是非阻塞数据结构的例子</p>
<h3 id="非阻塞算法vs阻塞算法"><a class="markdownIt-Anchor" href="#非阻塞算法vs阻塞算法"></a> 非阻塞算法VS阻塞算法</h3>
<p>阻塞算法和非阻塞算法的主要不同在于上面两部分描述的它们的行为的第二步。换句话说，它们之间的不同在于当请求操作不能够执行时阻塞算法和非阻塞算法会怎么做。</p>
<p>阻塞算法会阻塞线程直到请求操作可以被执行。非阻塞算法会通知请求线程操作不能够被执行，并返回。</p>
<p>一个使用了阻塞算法的线程可能会阻塞直到有可能去处理请求。通常，其它线程的动作使第一个线程执行请求的动作成为了可能。 如果，由于某些原因线程被阻塞在程序某处，因此不能让第一个线程的请求动作被执行，第一个线程会阻塞——可能一直阻塞或者直到其他线程执行完必要的动作。</p>
<p>例如，如果一个线程产生往一个已经满了的阻塞队列里插入一个元素，这个线程就会阻塞，直到其他线程从这个阻塞队列中取走了一些元素。如果由于某些原因，从阻塞队列中取元素的线程假定被阻塞在了程序的某处，那么，尝试往阻塞队列中添加新元素的线程就会阻塞，要么一直阻塞下去，要么知道从阻塞队列中取元素的线程最终从阻塞队列中取走了一个元素</p>
<h3 id="非阻塞并发数据结构"><a class="markdownIt-Anchor" href="#非阻塞并发数据结构"></a> 非阻塞并发数据结构</h3>
<p>在一个多线程系统中，线程间通常通过一些数据结构”交流“。例如可以是任何的数据结构，从变量到更高级的数据结构（队列，栈等）。</p>
<p>为了确保正确，并发线程在访问这些数据结构的时候，这些数据结构必须由一些并发算法来保证。这些并发算法让这些数据结构成为<strong>并发数据结构。</strong></p>
<p>如果某个算法确保一个并发数据结构是阻塞的，它就被称为是一个阻塞算法。这个数据结构也被称为是一个阻塞，并发数据结构。</p>
<p>如果某个算法确保一个并发数据结构是非阻塞的，它就被称为是一个非阻塞算法。这个数据结构也被称为是一个非阻塞，并发数据结构。</p>
<p>每个并发数据结构被设计用来支持一个特定的通信方法。使用哪种并发数据结构取决于你的通信需要。在接下里的部分，我会引入一些非阻塞并发数据结构，并讲解它们各自的适用场景。通过这些并发数据结构工作原理的讲解应该能在非阻塞数据结构的设计和实现上一些启发。</p>
<h3 id="volatile-变量"><a class="markdownIt-Anchor" href="#volatile-变量"></a> Volatile 变量</h3>
<p>Java中的volatile变量是直接从主存中读取值的变量。当一个新的值赋给一个volatile变量时，这个值总是会被立即写回到主存中去。这样就确保了，一个volatile变量最新的值总是对跑在其他CPU上的线程可见。其他线程每次会从主存中读取变量的值，而不是比如线程所运行CPU的CPU缓存中。</p>
<p><strong>volatile变量是非阻塞的</strong>。<strong>修改一个volatile变量的值是一个原子操作</strong>。它不能够被中断。不过，<strong>在一个volatile变量上的一个 read-update-write 顺序的操作不是原子的</strong>。因此，下面的代码如果由多个线程执行可能导致竞态条件</p>
<pre><code class="highlight plaintext">volatile myVar = 0;
...
int temp = myVar;
temp++;
myVar = temp;</code></pre>
<p>首先，myVar这个volatile变量的值被从主存中读出来赋给了temp变量。然后，temp变量自增1。然后，temp变量的值又赋给了myVar这个volatile变量这意味着它会被写回到主存中</p>
<p>如果两个线程执行这段代码，然后它们都读取myVar的值，加1后，把它的值写回到主存。这样就存在myVar仅被加1，而没有被加2的风险。</p>
<p>你可能认为你不会写像上面这样的代码，但是在实践中上面的代码等同于如下的代码：</p>
<pre><code class="highlight plaintext">myVar++;</code></pre>
<p>执行上面的代码时，<strong>myVar的值读到一个CPU寄存器或者一个本地CPU缓存中，myVar加1，（在写之前还有读/加的操作，所以是非原子的，volatile只有写是原子的）然后这个CPU寄存器或者CPU缓存中的值被写回到主存中</strong></p>
<h3 id="单个写线程的情景"><a class="markdownIt-Anchor" href="#单个写线程的情景"></a> 单个写线程的情景</h3>
<p>在一些场景下，你仅有一个线程在向一个共享变量写，多个线程在读这个变量。当仅有一个线程在更新一个变量，不管有多少个线程在读这个变量，都不会发生竞态条件。因此，<strong>无论任何时候当仅有一个线程在写一个共享变量时，你可以把这个变量声明为volatile</strong>。</p>
<p>当多个线程在一个共享变量上执行一个 read-update-write 的顺序操作时才会发生竞态条件。如果你只有一个线程在执行一个 raed-update-write 的顺序操作，其他线程都在执行读操作，将不会发生竞态条件</p>
<p>下面是一个单个写线程的例子，它没有采取同步手段但任然是并发的。</p>
<pre><code class="highlight plaintext">public class SingleWriterCounter&#123;
    private volatile long count = 0;

    /**
     *Only one thread may ever call this method
     *or it will lead to race conditions
     */
     public void inc()&#123;
         this.count++;
     &#125;

     /**
      *Many reading threads may call this method
      *@return
      */
      public long count()&#123;
          return this.count;
      &#125;
&#125;</code></pre>
<p>多个线程访问同一个Counter实例，只要仅有一个线程调用inc()方法，这里，我不是说在某一时刻一个线程，我的意思是，仅有相同的，单个的线程被允许去调用inc()方法。多个线程可以调用count()方法。这样的场景将不会发生任何竞态条件。</p>
<h3 id="基于volatile变量更高级的数据结构"><a class="markdownIt-Anchor" href="#基于volatile变量更高级的数据结构"></a> 基于volatile变量更高级的数据结构</h3>
<p>使用多个volatile变量去创建数据结构是可以的，构建出的数据结构中每一个volatile变量仅被一个单个的线程写，被多个线程读。每个volatile变量可能被一个不同的线程写（但仅有一个）。使用像这样的数据结构多个线程可以使用这些volatile变量以一个非阻塞的方法彼此发送信息。</p>
<pre><code class="highlight plaintext">public class DoubleWriterCounter&#123;
    private volatile long countA = 0;
    private volatile long countB = 0;

    /**
     *Only one (and the same from thereon) thread may ever call this method,
     *or it will lead to race conditions.
     */
     public void incA()&#123;
         this.countA++;
     &#125;

     /**
      *Only one (and the same from thereon) thread may ever call this method, 
      *or it will  lead to race conditions.
      */
      public void incB()&#123;
          this.countB++;
      &#125;

      /**
       *Many reading threads may call this method
       */
      public long countA()&#123;
          return this.countA;
      &#125;

     /**
      *Many reading threads may call this method
      */
      public long countB()&#123;
          return this.countB;
      &#125;
&#125;</code></pre>
<p>如你所见，DoubleWriterCoounter现在包含两个volatile变量以及两对自增和读方法。在某一时刻，仅有一个单个的线程可以调用inc()，仅有一个单个的线程可以访问incB()。不过不同的线程可以同时调用incA()和incB()。countA()和countB()可以被多个线程调用。这将不会引发竞态条件。</p>
<p>DoubleWriterCoounter可以被用来比如线程间通信。countA和countB可以分别用来存储生产的任务数和消费的任务数。下图，展示了两个线程通过类似于上面的一个数据结构进行通信的</p>
<p>聪明的读者应该已经意识到使用两个SingleWriterCounter可以达到使用DoubleWriterCoounter的效果。如果需要，你甚至可以使用多个线程和SingleWriterCounter实例。</p>
<h3 id="使用cas的乐观锁"><a class="markdownIt-Anchor" href="#使用cas的乐观锁"></a> 使用CAS的乐观锁</h3>
<p><strong>如果你确实需要多个线程区写同一个共享变量，volatile变量是不合适的</strong>。你将会需要一些类型的排它锁（悲观锁）访问这个变量。下面代码演示了使用Java中的同步块进行排他访问的。</p>
<p><strong>悲观锁实现</strong></p>
<ul>
<li>不会造成操作失败，但是会造成线程阻塞，耗时比较久</li>
</ul>
<pre><code class="highlight plaintext">public class SynchronizedCounter&#123;
    long count = 0;

    public void inc()&#123;
        synchronized(this)&#123;
            count++;
        &#125;
    &#125;

    public long count()&#123;
        synchronized(this)&#123;
            return this.count;
        &#125;
    &#125;
&#125;</code></pre>
<p>注意，，inc()和count()方法都包含一个同步块。这也是我们像避免的东西——同步块和 wait()-notify 调用等。</p>
<p><strong>CAS乐观锁实现</strong></p>
<ul>
<li>不会阻塞线程，但是会造成大量的失败操作，耗时短</li>
</ul>
<p>我们可以使用一种Java的原子变量来代替这两个同步块。在这个例子是AtomicLong。下面是SynchronizedCounter类的AtomicLong实现版本。</p>
<pre><code class="highlight plaintext">import java.util.concurrent.atomic.AtomicLong;

public class AtomicLong&#123;
    private AtomicLong count = new AtomicLong(0);

    //该方法虽然不会阻塞多线程，但是会造成大量的失败操作
    //并发下耗时短
    public void inc()&#123;
        boolean updated = false;
        while(!updated)&#123;
            long prevCount = this.count.get();
            updated = this.count.compareAndSet(prevCount, prevCount + 1);
        &#125;
    &#125;

    public long count()&#123;
        return this.count.get();
    &#125;
&#125;</code></pre>
<blockquote>
<p>上面这些代码并不是一个原子操作。也就是说，对于两个不同的线程去调用inc()方法，然后执行long prevCount = this.count.get()语句，因此获得了这个计数器的上一个count。但是，上面的代码并没有包含任何的竞态条件。</p>
</blockquote>
<blockquote>
<p>秘密就在于while循环里的第二行代码。compareAndSet()方法调用是一个原子操作。它用一个期望值和AtomicLong 内部的值去比较，如果这两个值相等，就把AtomicLong内部值替换为一个新值。compareAndSet()通常被CPU中的compare-and-swap指令直接支持。因此，不需要去同步，也不需要去挂起线程。</p>
</blockquote>
<blockquote>
<p>假设，这个AtomicLong的内部值是20,。然后，两个线程去读这个值，都尝试调用compareAndSet(20, 20 + 1)。尽管compareAndSet()是一个原子操作，这个方法也会被这两个线程相继执行（某一个时刻只有一个）</p>
</blockquote>
<blockquote>
<p>第一个线程会使用期望值20（这个计数器的上一个值）与AtomicLong的内部值进行比较。由于两个值是相等的，AtomicLong会更新它的内部值至21（20 + 1 ）。变量updated被修改为true，while循环结束</p>
</blockquote>
<blockquote>
<p>现在，第二个线程调用compareAndSet(20, 20 + 1)。由于AtomicLong的内部值不再是20，这个调用将不会成功。AtomicLong的值不会再被修改为21。变量，updated被修改为false，线程将会再次在while循环外自旋。这段时间，它会读到值21并企图把值更新为22。如果在此期间没有其它线程调用inc()。第二次迭代将会成功更新AtomicLong的内部值到22。</p>
</blockquote>
<hr />
<p><strong>为什么称它为乐观锁</strong></p>
<p>上一部分展现的代码被称为乐观锁（optimistic locking）。乐观锁区别于传统的锁，有时也被称为悲观锁。<strong>悲观锁会使用同步块或其他类型的锁阻塞对临界区域的访问。一个同步块或锁可能会导致线程挂起</strong>。</p>
<p><strong>乐观锁允许所有的线程在不发生阻塞的情况下创建一份共享内存的拷贝</strong>。这些线程接下来可能会对它们的拷贝进行修改，并企图把它们修改后的版本写回到共享内存中。如果没有其它线程对共享内存做任何修改， CAS操作就允许线程将它的变化写回到共享内存中去。如果，另一个线程已经修改了共享内存，这个线程将不得不再次获得一个新的拷贝，在新的拷贝上做出修改，并尝试再次把它们写回到共享内存中去。</p>
<p>称之为“乐观锁”的原因就是，线程获得它们想修改的数据的拷贝并做出修改，在乐观的假在此期间没有线程对共享内存做出修改的情况下。当这个乐观假设成立时，这个线程仅仅在无锁的情况下完成共享内存的更新。当这个假设不成立时，线程所做的工作就会被丢弃，但任然不使用锁。</p>
<p>乐观锁使用于共享内存竞用不是非常高的情况。如果共享内存上的内容非常多，仅仅因为更新共享内存失败，就用浪费大量的CPU周期用在拷贝和修改上。但是，如果砸共享内存上有大量的内容，无论如何，你都要把你的代码设计的产生的争用更低。</p>
<hr />
<p><strong>乐观锁是非阻塞的</strong></p>
<p>我们这里提到的乐观锁机制是非阻塞的。如果一个线程获得了一份共享内存的拷贝，当尝试修改时，发生了阻塞，其它线程去访问这块内存区域不会发生阻塞。</p>
<p>对于一个传统的加锁/解锁模式，当一个线程持有一个锁时，其它所有的线程都会一直阻塞直到持有锁的线程再次释放掉这个锁。如果持有锁的这个线程被阻塞在某处，这个锁将很长一段时间不能被释放，甚至可能一直不能被释放。</p>
<h3 id="不可替换的数据结构"><a class="markdownIt-Anchor" href="#不可替换的数据结构"></a> 不可替换的数据结构</h3>
<p>简单的CAS乐观锁可以用于共享数据结果，这样一来，整个数据结构都可以通过一个单个的CAS操作被替换成为一个新的数据结构。尽管，使用一个修改后的拷贝来替换真个数据结构并不总是可行的。</p>
<p>假设，这个共享数据结构是队列。每当线程尝试从向队列中插入或从队列中取出元素时，都必须拷贝这个队列然后在拷贝上做出期望的修改。我们可以通过使用一个AtomicReference来达到同样的目的。拷贝引用，拷贝和修改队列，尝试替换在AtomicReference中的引用让它指向新创建的队列</p>
<p>然而，一个大的数据结构可能会需要大量的内存和CPU周期来复制。这会使你的程序占用大量的内存和浪费大量的时间再拷贝操作上。这将会降低你的程序的性能，特别是这个数据结构的竞用非常高情况下。更进一步说，一个线程花费在拷贝和修改这个数据结构上的时间越长，其它线程在此期间修改这个数据结构的可能性就越大。如你所知，如果另一个线程修改了这个数据结构在它被拷贝后，其它所有的线程都不等不再次执行 拷贝-修改 操作。这将会增大性能影响和内存浪费，甚至更多。</p>
<p>接下来的部分将会讲解一种实现非阻塞数据结构的方法，这种数据结构可以被并发修改，而不仅仅是拷贝和修改。</p>
<h3 id="使用非阻塞算法的好处"><a class="markdownIt-Anchor" href="#使用非阻塞算法的好处"></a> 使用非阻塞算法的好处</h3>
<p>非阻塞算法和阻塞算法相比有几个好处。下面让我们分别看一下：</p>
<p><strong>选择</strong></p>
<p>非阻塞算法的第一个好处是，给了线程一个选择当它们请求的动作不能够被执行时做些什么。不再是被阻塞在那，请求线程关于做什么有了一个选择。有时候，一个线程什么也不能做。在这种情况下，它可以选择阻塞或自我等待，像这样把CPU的使用权让给其它的任务。不过至少给了请求线程一个选择的机会。</p>
<p>在一个单个的CPU系统可能会挂起一个不能执行请求动作的线程，这样可以让其它线程获得CPU的使用权。不过即使在一个单个的CPU系统阻塞可能导致死锁，线程饥饿等并发问题。</p>
<p><strong>没有死锁</strong></p>
<p>非阻塞算法的第二个好处是，一个线程的挂起不能导致其它线程挂起。这也意味着不会发生死锁。两个线程不能互相彼此等待来获得被对方持有的锁。因为线程不会阻塞当它们不能执行它们的请求动作时，它们不能阻塞互相等待。非阻塞算法任然可能产生活锁（live lock），两个线程一直请求一些动作，但一直被告知不能够被执行（因为其他线程的动作）。</p>
<p><strong>没有线程挂起</strong></p>
<p>挂起和恢复一个线程的代价是昂贵的。没错，随着时间的推移，操作系统和线程库已经越来越高效，线程挂起和恢复的成本也不断降低。不过，线程的挂起和户对任然需要付出很高的代价。</p>
<p>无论什么时候，一个线程阻塞，就会被挂起。因此，引起了线程挂起和恢复过载。由于使用非阻塞算法线程不会被挂起，这种过载就不会发生。这就意味着CPU有可能花更多时间在执行实际的业务逻辑上而不是上下文切换。</p>
<p>在一个多个CPU的系统上，阻塞算法会对阻塞算法产生重要的影响。运行在CPUA上的一个线程阻塞等待运行在CPU B上的一个线程。这就降低了程序天生就具备的并行水平。当然，CPU A可以调度其他线程去运行，但是挂起和激活线程（上下文切换）的代价是昂贵的。需要挂起的线程越少越好。</p>
<p><strong>降低线程延迟</strong></p>
<p>在这里我们提到的延迟指的是一个请求产生到线程实际的执行它之间的时间。因为在非阻塞算法中线程不会被挂起，它们就不需要付昂贵的，缓慢的线程激活成本。这就意味着当一个请求执行时可以得到更快的响应，减少它们的响应延迟。</p>
<p>非阻塞算法通常忙等待直到请求动作可以被执行来降低延迟。当然，在一个非阻塞数据数据结构有着很高的线程争用的系统中，CPU可能在它们忙等待期间停止消耗大量的CPU周期。这一点需要牢牢记住。非阻塞算法可能不是最好的选择如果你的数据结构哦有着很高的线程争用。不过，也常常存在通过重构你的程序来达到更低的线程争用。</p>
<h2 id="悲观乐观锁"><a class="markdownIt-Anchor" href="#悲观乐观锁"></a> 悲观/乐观锁</h2>
<h3 id="乐观锁"><a class="markdownIt-Anchor" href="#乐观锁"></a> 乐观锁</h3>
<p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的</p>
<h4 id="乐观锁的两种实现方式"><a class="markdownIt-Anchor" href="#乐观锁的两种实现方式"></a> 乐观锁的两种实现方式</h4>
<p>乐观锁一般会使用版本号机制或CAS（Compare-and-Swap，即比较并替换）算法实现。</p>
<h5 id="版本号机制"><a class="markdownIt-Anchor" href="#版本号机制"></a> 版本号机制</h5>
<p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p>举一个简单的例子： 假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100</p>
<ul>
<li>操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）</li>
<li>在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）</li>
<li>操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2</li>
<li>操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回</li>
</ul>
<p>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p>
<h5 id="cas算法"><a class="markdownIt-Anchor" href="#cas算法"></a> CAS算法</h5>
<p>即 compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数</p>
<ul>
<li>需要读写的内存值 V</li>
<li>进行比较的值 A</li>
<li>拟写入的新值 B</li>
</ul>
<p>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</p>
<pre><code class="highlight plaintext">import java.util.concurrent.atomic.AtomicLong;

public class AtomicLong&#123;
    private AtomicLong count = new AtomicLong(0);

    //该方法虽然不会阻塞多线程，但是会造成大量的失败操作
    //并发下耗时短
    public void inc()&#123;
        boolean updated = false;
        while(!updated)&#123;
            long prevCount = this.count.get();
            updated = this.count.compareAndSet(prevCount, prevCount + 1);
        &#125;
    &#125;

    public long count()&#123;
        return this.count.get();
    &#125;
&#125;</code></pre>
<h4 id="乐观锁的缺点"><a class="markdownIt-Anchor" href="#乐观锁的缺点"></a> 乐观锁的缺点</h4>
<p><strong>ABA 问题</strong></p>
<p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 &quot;ABA&quot;问题。</p>
<p>JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<p><strong>循环时间长开销大</strong></p>
<p>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
<p><strong>只能保证一个共享变量的原子操作</strong></p>
<p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。</p>
<h3 id="悲观锁"><a class="markdownIt-Anchor" href="#悲观锁"></a> 悲观锁</h3>
<p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p>
<h4 id="悲观锁的实现"><a class="markdownIt-Anchor" href="#悲观锁的实现"></a> 悲观锁的实现</h4>
<p>悲观锁一般使用ynchronized实现</p>
<pre><code class="highlight plaintext">public class SynchronizedCounter&#123;
    long count = 0;

    public void inc()&#123;
        synchronized(this)&#123;
            count++;
        &#125;
    &#125;

    public long count()&#123;
        synchronized(this)&#123;
            return this.count;
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="两种锁的使用场景"><a class="markdownIt-Anchor" href="#两种锁的使用场景"></a> 两种锁的使用场景</h3>
<p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p>
<h3 id="cas于synchronized的使用情景"><a class="markdownIt-Anchor" href="#cas于synchronized的使用情景"></a> CAS于synchronized的使用情景</h3>
<p>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</p>
<ul>
<li>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li>
<li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li>
</ul>
<blockquote>
<p>补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</p>
</blockquote>
<h2 id="哪个对象才是锁"><a class="markdownIt-Anchor" href="#哪个对象才是锁"></a> 哪个对象才是锁</h2>
<p>我们都知道当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。这些基础也许大家都知道，但是很多人还是搞不清哪个对象才是锁？如果你能正确回答以下问题，那么才算你彻底搞明白了哪个对象才是锁？</p>
<h3 id="静态同步方法问题"><a class="markdownIt-Anchor" href="#静态同步方法问题"></a> 静态同步方法问题</h3>
<pre><code class="highlight plaintext">Class A&#123;
    public static synchronized void write(boolean b)&#123;
      isTrue = b;
    &#125;
    public static synchronized boolean read()&#123;
      return isTrue;
    &#125;
&#125;</code></pre>
<p>那么我们来问几个问题</p>
<ul>
<li>线程1访问A.write(true)方法时，线程2能访问A.read()方法吗？
<ul>
<li><strong>不能，因为静态方法的锁都是A.Class对象,线程1拿到锁之后，线程2就拿不到锁了</strong>。</li>
</ul>
</li>
<li>线程1访问new A().write(false)方法时，线程2能访问new A().read()方法吗？
<ul>
<li><strong>不能，原因同上</strong></li>
</ul>
</li>
<li>线程1访问A.write(false)方法时，线程2能访问new A().read()方法吗？
<ul>
<li><strong>不能，原因同上</strong></li>
</ul>
</li>
</ul>
<h3 id="实例同步方法问题"><a class="markdownIt-Anchor" href="#实例同步方法问题"></a> 实例同步方法问题</h3>
<p>如下代码是两个实例同步方法</p>
<pre><code class="highlight plaintext">public synchronized void write(boolean b)&#123;
  isTrue = b;
&#125;

public synchronized boolean read()&#123;
  return isTrue;
&#125;</code></pre>
<p>同样问两个问题：</p>
<ul>
<li>A a=new A(); 线程1访问a.write(false)方法，线程2能访问a.read()方法吗？
<ul>
<li><strong>不能，因为这两个方法的锁都是对象a，线程1拿到了锁，线程2就不能访问了</strong></li>
</ul>
</li>
<li>A a=new A(); A b=new A();线程1访问a.write(false)方法，线程2能访问b.read()方法吗？
<ul>
<li><strong>可以，因为线程1拿到的是锁是 a,而线程2访问b.read()需要的是锁是b</strong></li>
</ul>
</li>
</ul>
<h3 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h3>
<p>我们先回顾基础知识，Java中的每一个对象都可以作为锁，而不同的场景锁是不一样的。</p>
<p><strong>对于实例同步方法，锁是当前实例对象</strong>。</p>
<p><strong>对于静态同步方法，锁是当前对象的Class对象</strong>。</p>
<p><strong>对于同步方法块，锁是Synchonized括号里配置的对象</strong>。</p>
</main>

</article>


<script src="/js/highlight.js"></script>

  </main>
  <footer class="footer">
  
  <span>Copyright © 2026 Lism Blog | lisisism@qq.com</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>