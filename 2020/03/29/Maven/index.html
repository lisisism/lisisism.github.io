<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    Maven 丨
    

    Lism Blog
  </title>

  
  <link rel="shortcut icon" href="/icon.svg">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="/Lism Blog" type="application/atom+xml">
</head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">/Lism Blog</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <article class="post">
  
  <div class="post-title">Maven</div>
  <div class="post-meta">
    <div class="date">2020 三月 29日</div>
    <div class="tags">
      
      <div class="tag-item">Java</div>
      
      <div class="tag-item">Maven</div>
      
    </div>
  </div>
  

  <main class="post-content"><h1 id="maven"><a class="markdownIt-Anchor" href="#maven"></a> $Maven</h1>
<h1 id="maven-2"><a class="markdownIt-Anchor" href="#maven-2"></a> Maven</h1>
<ul>
<li><a href="">Maven</a>
<ul>
<li><a href="">介绍</a>
<ul>
<li><a href="">Maven项目结构</a></li>
<li><a href="">安装maven</a></li>
</ul>
</li>
<li><a href="">依赖管理</a>
<ul>
<li><a href="">依赖关系</a></li>
<li><a href="">唯一ID</a></li>
<li><a href="">Maven镜像</a></li>
<li><a href="">搜索第三方组件</a></li>
<li><a href="">命令行编译</a></li>
</ul>
</li>
<li><a href="">构建流程</a>
<ul>
<li><a href="">Lifecycle和Phase</a></li>
<li><a href="">Goal</a></li>
</ul>
</li>
<li><a href="">使用插件</a>
<ul>
<li><a href="">打包所有依赖包并生成可执行jar</a></li>
</ul>
</li>
<li><a href="">模块管理</a>
<ul>
<li><a href="">中央/私有/本地仓库</a></li>
</ul>
</li>
<li><a href="">使用mvnw</a></li>
<li><a href="">发布Artifact</a>
<ul>
<li><a href="">以静态文件发布</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2>
<p>在了解Maven之前，我们先来看看一个Java项目需要的东西。首先，我们需要确定引入哪些依赖包。例如，如果我们需要用到commons logging，我们就必须把commons logging的jar包放入classpath。如果我们还需要log4j，就需要把log4j相关的jar包都放到classpath中。这些就是依赖包的管理。</p>
<p>其次，我们要确定项目的目录结构。例如，src目录存放Java源码，resources目录存放配置文件，bin目录存放编译生成的.class文件。</p>
<p>此外，我们还需要配置环境，例如JDK的版本，编译打包的流程，当前代码的版本号。</p>
<p>最后，除了使用Eclipse这样的IDE进行编译外，我们还必须能通过命令行工具进行编译，才能够让项目在一个独立的服务器上编译、测试、部署。</p>
<p>这些工作难度不大，但是非常琐碎且耗时。如果每一个项目都自己搞一套配置，肯定会一团糟。我们需要的是一个标准化的Java项目管理和构建工具。</p>
<p><strong>Maven就是是专门为Java项目打造的管理和构建工具</strong>，它的主要功能有：</p>
<ul>
<li>提供了一套标准化的项目结构；</li>
<li>提供了一套标准化的构建流程（编译，测试，打包，发布……）；</li>
<li>提供了一套依赖管理机制。</li>
</ul>
<h3 id="maven项目结构"><a class="markdownIt-Anchor" href="#maven项目结构"></a> Maven项目结构</h3>
<p>一个使用Maven管理的普通的Java项目，它的目录结构默认如下：</p>
<p>项目的根目录a-maven-project是项目名，它有一个项目描述文件pom.xml，存放Java源码的目录是src/main/java，存放资源文件的目录是src/main/resources，存放测试源码的目录是src/test/java，存放测试资源的目录是src/test/resources，最后，所有编译、打包生成的文件都放在target目录里。这些就是一个Maven项目的标准目录结构。</p>
<p><strong>所有的目录结构都是约定好的标准结构，我们千万不要随意修改目录结构</strong>。使用标准结构不需要做任何配置，Maven就可以正常使用。</p>
<p>我们再来看最关键的一个项目描述文件pom.xml，它的内容长得像下面：</p>
<ul>
<li><strong>groupId</strong>：类似于Java的包名，通常是公司或组织名称</li>
<li><strong>artifactId</strong>：类似于Java的类名，通常是项目名称</li>
<li><strong>version</strong>：项目版本号</li>
</ul>
<pre><code class="highlight plaintext">&lt;project ...&gt;
        &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
        &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;
        &lt;artifactId&gt;hello&lt;/artifactId&gt;
        &lt;version&gt;1.0&lt;/version&gt;
        &lt;packaging&gt;jar&lt;/packaging&gt;
        &lt;properties&gt;
        ...
        &lt;/properties&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;commons-logging&lt;/groupId&gt;
                &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
                &lt;version&gt;1.2&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
&lt;/project&gt;</code></pre>
<p>其中，groupId类似于Java的包名，通常是公司或组织名称，artifactId类似于Java的类名，通常是项目名称，再加上version，一个<strong>Maven工程就是由groupId，artifactId和version作为唯一标识</strong>。我们在<strong>引用其他第三方库的时候，也是通过这3个变量确定</strong>。例如，依赖commons-logging：</p>
<pre><code class="highlight plaintext">&lt;dependency&gt;
    &lt;groupId&gt;commons-logging&lt;/groupId&gt;
    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
    &lt;version&gt;1.2&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<blockquote>
<p>使用<dependency>声明一个依赖后，Maven就会<strong>自动下载</strong>这个依赖包并把它放到classpath中</p>
</blockquote>
<h3 id="安装maven"><a class="markdownIt-Anchor" href="#安装maven"></a> 安装maven</h3>
<p>要安装Maven，可以从Maven官网下载最新的Maven 3.6.x，然后在本地解压，设置几个环境变量：</p>
<pre><code class="highlight plaintext">M2_HOME=/path/to/maven-3.6.xPATH=$PATH:$M2_HOME/bin</code></pre>
<p>Windows可以把%M2_HOME%\bin添加到系统Path变量中。</p>
<p>然后，打开命令行窗口，输入mvn -version，应该看到Maven的版本信息：</p>
<h2 id="依赖管理"><a class="markdownIt-Anchor" href="#依赖管理"></a> 依赖管理</h2>
<p>如果我们的项目依赖第三方的jar包，例如commons logging，那么问题来了：commons logging发布的jar包在哪下载？</p>
<p>如果我们还希望依赖log4j，那么使用log4j需要哪些jar包？</p>
<p>类似的依赖还包括：JUnit，JavaMail，MySQL驱动等等，一个可行的方法是通过搜索引擎搜索到项目的官网，然后手动下载zip包，解压，放入classpath。但是，这个过程非常繁琐。</p>
<p><strong>Maven解决了依赖管理问题</strong>。例如，我们的项目依赖abc这个jar包，而abc又依赖xyz这个jar包：</p>
<p>当我们声明了abc的依赖时，Maven自动把abc和xyz都加入了我们的项目依赖，不需要我们自己去研究abc是否需要依赖xyz。</p>
<p>因此，Maven的第一个作用就是解决依赖管理。我们声明了自己的项目需要abc，Maven会自动导入abc的jar包，再判断出abc需要xyz，又会自动导入xyz的jar包，这样，最终我们的项目会依赖abc和xyz两个jar包。</p>
<p>我们来看一个复杂依赖示例：</p>
<pre><code class="highlight plaintext">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;version&gt;1.4.2.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<p>当我们声明一个spring-boot-starter-web依赖时，Maven会自动解析并判断最终需要大概二三十个其他依赖：</p>
<blockquote>
<p>如果我们自己去手动管理这些依赖是非常费时费力的，而且出错的概率很大</p>
</blockquote>
<h3 id="依赖关系"><a class="markdownIt-Anchor" href="#依赖关系"></a> 依赖关系</h3>
<p>Maven定义了几种依赖关系，分别是compile、test、runtime和provided：</p>
<table>
<thead>
<tr>
<th><strong>scope</strong></th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>compile</td>
<td>编译时需要用到该jar包（默认）</td>
<td>commons-logging</td>
</tr>
<tr>
<td>test</td>
<td>编译Test时需要用到该jar包</td>
<td>junit</td>
</tr>
<tr>
<td>runtime</td>
<td>编译时不需要，但运行时需要用到</td>
<td>mysql</td>
</tr>
<tr>
<td>provided</td>
<td>编译时需要用到，但运行时由JDK或某个服务器提供</td>
<td>servlet-api</td>
</tr>
</tbody>
</table>
<p>其中，<strong>默认的compile是最常用的，Maven会把这种类型的依赖直接放入classpath</strong>。</p>
<p>test依赖表示仅在测试时使用，正常运行时并不需要。最常用的test依赖就是JUnit：</p>
<pre><code class="highlight plaintext">&lt;dependency&gt;
    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;
    &lt;version&gt;5.3.2&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
<p>runtime依赖表示编译时不需要，但运行时需要。最典型的runtime依赖是JDBC驱动，例如MySQL驱动：</p>
<pre><code class="highlight plaintext">&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.48&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
<p>provided依赖表示编译时需要，但运行时不需要。最典型的provided依赖是Servlet API，编译的时候需要，但是运行时，Servlet服务器内置了相关的jar，所以运行期不需要：</p>
<pre><code class="highlight plaintext">&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;version&gt;4.0.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
<p>最后一个问题是，Maven如何知道从何处下载所需的依赖？也就是相关的jar包？</p>
<ul>
<li>答案是<strong>Maven维护了一个中央仓库（<a target="_blank" rel="noopener" href="http://repo1.maven.org">repo1.maven.org</a>），所有第三方库将自身的jar以及相关信息上传至中央仓库，Maven就可以从中央仓库把所需依赖下载到本地</strong>。</li>
</ul>
<p>Maven并<strong>不会每次都从中央仓库下载jar�</strong>�。一个jar包一旦被下载过，就会被Maven自动<strong>缓存在本地目录</strong>（用户主目录的.m2目录），所以，除了第一次编译时因为下载需要时间会比较慢，后续过程因为有本地缓存，并不会重复下载相同的jar包。</p>
<h3 id="唯一id"><a class="markdownIt-Anchor" href="#唯一id"></a> 唯一ID</h3>
<p>对于某个依赖，Maven只需要3个变量即可唯一确定某个jar包：</p>
<ul>
<li>groupId：属于组织的名称，类似Java的包名；</li>
<li>artifactId：该jar包自身的名称，类似Java的类名；</li>
<li>version：该jar包的版本。</li>
</ul>
<p>通过上述3个变量，即可唯一确定某个jar包。Maven通过对jar包进行PGP签名确保任何一个jar包一经发布就无法修改。修改已发布jar包的唯一方法是发布一个新版本。</p>
<p>因此，某个jar包一旦被Maven下载过，即可永久地安全缓存在本地。</p>
<blockquote>
<p>注：只有以-SNAPSHOT结尾的版本号会被Maven视为开发版本，开发版本每次都会重复下载，这种SNAPSHOT版本只能用于内部私有的Maven repo，公开发布的版本不允许出现SNAPSHOT。</p>
</blockquote>
<h3 id="maven镜像"><a class="markdownIt-Anchor" href="#maven镜像"></a> Maven镜像</h3>
<p>除了可以从Maven的中央仓库下载外，还可以从Maven的镜像仓库下载。如果访问Maven的中央仓库非常慢，我们可以选择一个速度较快的Maven的镜像仓库。Maven镜像仓库定期从中央仓库同步：</p>
<p>中国区用户可以使用阿里云提供的Maven镜像仓库。使用Maven镜像仓库需要一个配置，在用户主目录下进入.m2目录，创建一个settings.xml配置文件，内容如下：</p>
<pre><code class="highlight plaintext">&lt;settings&gt;
    &lt;mirrors&gt;
        &lt;mirror&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
            &lt;!-- 国内推荐阿里云的Maven镜像 --&gt;
            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;
        &lt;/mirror&gt;
    &lt;/mirrors&gt;
 &lt;/settings&gt;</code></pre>
<h3 id="搜索第三方组件"><a class="markdownIt-Anchor" href="#搜索第三方组件"></a> 搜索第三方组件</h3>
<p>最后一个问题：如果我们要引用一个第三方组件，比如okhttp，如何确切地获得它的groupId、artifactId和version？</p>
<ul>
<li>方法是通过 <a target="_blank" rel="noopener" href="https://search.maven.org/">https://search.maven.org/</a> 搜索关键字，找到对应的组件后，直接复制：</li>
</ul>
<h3 id="命令行编译"><a class="markdownIt-Anchor" href="#命令行编译"></a> 命令行编译</h3>
<p>在命令中，进入到pom.xml所在目录，输入以下命令：</p>
<pre><code class="highlight plaintext">$ mvn clean package</code></pre>
<p>如果一切顺利，即可在target目录下获得编译后自动打包的jar。</p>
<h2 id="构建流程"><a class="markdownIt-Anchor" href="#构建流程"></a> 构建流程</h2>
<p>Maven不但有标准化的项目结构，而且还有一套标准化的构建流程，可以自动化实现编译，打包，发布，等等。</p>
<h3 id="lifecycle和phase"><a class="markdownIt-Anchor" href="#lifecycle和phase"></a> Lifecycle和Phase</h3>
<p>使用Maven时，我们首先要了解什么是Maven的生命周期（lifecycle）。</p>
<p>Maven的生命周期由一系列阶段（phase）构成，以内置的生命周期default为例，它包含以下phase：</p>
<ul>
<li>validate</li>
<li>initialize</li>
<li>generate-sources</li>
<li>process-sources</li>
<li>generate-resources</li>
<li>process-resources</li>
<li>compile</li>
<li>process-classes</li>
<li>generate-test-sources</li>
<li>process-test-sources</li>
<li>generate-test-resources</li>
<li>process-test-resources</li>
<li>test-compile</li>
<li>process-test-classes</li>
<li>test</li>
<li>prepare-package</li>
<li>package</li>
<li>pre-integration-test</li>
<li>integration-test</li>
<li>post-integration-test</li>
<li>verify</li>
<li>install</li>
<li>deploy</li>
</ul>
<p>如果我们运行<strong>mvn package</strong>，Maven就会执行default生命周期，它会从开始一直运行到package这个phase为止：</p>
<ul>
<li>validate</li>
<li>…</li>
<li>package</li>
</ul>
<p>如果我们运行<strong>mvn compile</strong>，Maven也会执行default生命周期，但这次它只会运行到compile，即以下几个phase：</p>
<ul>
<li>validate</li>
<li>…</li>
<li>compile</li>
</ul>
<p>Maven另一个常用的生命周期是<strong>clean</strong>，它会执行3个phase：</p>
<ul>
<li>pre-clean</li>
<li>clean （注意这个clean不是lifecycle而是phase）</li>
<li>post-clean</li>
</ul>
<blockquote>
<p>所以，我们使用mvn这个命令时，后面的参数是phase，Maven自动根据生命周期运行到指定的phase。</p>
</blockquote>
<p>更复杂的例子是指定多个phase，例如，运行mvn clean package，Maven先执行clean生命周期并运行到clean这个phase，然后执行default生命周期并运行到package这个phase，实际执行的phase如下：</p>
<ul>
<li>pre-clean</li>
<li>clean （注意这个clean是phase）</li>
<li>validate</li>
<li>…</li>
<li>package</li>
</ul>
<p>在实际开发过程中，经常使用的命令有：</p>
<ul>
<li><strong>mvn clean</strong>：清理所有生成的class和jar；</li>
<li><strong>mvn clean compile</strong>：先清理，再执行到compile；</li>
<li><strong>mvn clean test</strong>：先清理，再执行到test，因为执行test前必须执行compile，所以这里不必指定compile；</li>
<li><strong>mvn clean package</strong>：先清理，再执行到package。</li>
</ul>
<p>大多数phase在执行过程中，因为我们通常没有在pom.xml中配置相关的设置，所以这些phase什么事情都不做。</p>
<p>经常用到的phase其实只有几个：</p>
<ul>
<li><strong>clean</strong>：清理</li>
<li><strong>compile</strong>：编译</li>
<li><strong>test</strong>：运行测试</li>
<li><strong>package</strong>：打包</li>
</ul>
<h3 id="goal"><a class="markdownIt-Anchor" href="#goal"></a> Goal</h3>
<p>执行一个phase又会触发一个或多个goal：</p>
<table>
<thead>
<tr>
<th>执行的Phase</th>
<th>对应执行的Goal</th>
</tr>
</thead>
<tbody>
<tr>
<td>compile</td>
<td>compiler:compile</td>
</tr>
<tr>
<td>test</td>
<td>compiler:testCompile surefire:test</td>
</tr>
</tbody>
</table>
<p>goal的命名总是abc:xyz这种形式。</p>
<p>其实我们类比一下就明白了：</p>
<ul>
<li>lifecycle相当于Java的package，它包含一个或多个phase；</li>
<li>phase相当于Java的class，它包含一个或多个goal；</li>
<li>goal相当于class的method，它其实才是真正干活的。</li>
</ul>
<p>大多数情况，我们只要指定phase，就默认执行这些phase默认绑定的goal，只有少数情况，我们可以直接指定运行一个goal，例如，启动Tomcat服务器：</p>
<pre><code class="highlight plaintext">mvn tomcat:run</code></pre>
<h2 id="使用插件"><a class="markdownIt-Anchor" href="#使用插件"></a> 使用插件</h2>
<p>我们在前面介绍了Maven的lifecycle，phase和goal：使用Maven构建项目就是执行lifecycle，执行到指定的phase为止。每个phase会执行自己默认的一个或多个goal。goal是最小任务单元。</p>
<p>我们以compile这个phase为例，如果执行：</p>
<pre><code class="highlight plaintext">mvn compile</code></pre>
<p>Maven将执行compile这个phase，这个phase会调用compiler插件执行关联的compiler:compile这个goal。</p>
<p>实际上，执行每个phase，都是通过某个插件（plugin）来执行的，Maven本身其实并不知道如何执行compile，它只是负责找到对应的compiler插件，然后执行默认的compiler:compile这个goal来完成编译。</p>
<p>所以，使用Maven，实际上就是配置好需要使用的插件，然后通过phase调用它们。</p>
<p>Maven已经内置了一些常用的标准插件：</p>
<table>
<thead>
<tr>
<th>插件名称</th>
<th>对应执行的phase</th>
</tr>
</thead>
<tbody>
<tr>
<td>clean</td>
<td>clean</td>
</tr>
<tr>
<td>compiler</td>
<td>compile</td>
</tr>
<tr>
<td>surefire</td>
<td>test</td>
</tr>
<tr>
<td>jar</td>
<td>package</td>
</tr>
</tbody>
</table>
<p>如果标准插件无法满足需求，我们还可以使用自定义插件。使用自定义插件的时候，需要声明。例如，使用maven-shade-plugin可以创建一个可执行的jar，要使用这个插件，需要在pom.xml中声明它：</p>
<pre><code class="highlight plaintext">&lt;project&gt;
    ...
	&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
				&lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.2.1&lt;/version&gt;
				&lt;executions&gt;
					&lt;execution&gt;
						&lt;phase&gt;package&lt;/phase&gt;
						&lt;goals&gt;
							&lt;goal&gt;shade&lt;/goal&gt;
						&lt;/goals&gt;
						&lt;configuration&gt;
                            ...
						&lt;/configuration&gt;
					&lt;/execution&gt;
				&lt;/executions&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;
&lt;/project&gt;</code></pre>
<p>自定义插件往往需要一些配置，例如，maven-shade-plugin需要指定Java程序的入口，它的配置是：</p>
<pre><code class="highlight plaintext">&lt;configuration&gt;
    &lt;transformers&gt;
        &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;
            &lt;mainClass&gt;com.itranswarp.learnjava.Main&lt;/mainClass&gt;
        &lt;/transformer&gt;
    &lt;/transformers&gt;
&lt;/configuration&gt;</code></pre>
<blockquote>
<p>注意，Maven自带的标准插件例如compiler是无需声明的，只有引入其它的插件才需要声明。</p>
</blockquote>
<p>下面列举了一些常用的插件：</p>
<ul>
<li>maven-shade-plugin：打包所有依赖包并生成可执行jar；</li>
<li>cobertura-maven-plugin：生成单元测试覆盖率报告；</li>
<li>findbugs-maven-plugin：对Java源码进行静态分析以找出潜在问题。</li>
</ul>
<h3 id="打包所有依赖包并生成可执行jar"><a class="markdownIt-Anchor" href="#打包所有依赖包并生成可执行jar"></a> 打包所有依赖包并生成可执行jar</h3>
<pre><code class="highlight plaintext">&lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;archive&gt;
                        &lt;manifest&gt;
                            &lt;!--这里要替换成jar包main方法所在类 --&gt;
                            &lt;mainClass&gt;TestHadoop&lt;/mainClass&gt;
                        &lt;/manifest&gt;
                        &lt;manifestEntries&gt;
                            &lt;Class-Path&gt;.&lt;/Class-Path&gt;
                        &lt;/manifestEntries&gt;
                    &lt;/archive&gt;
                    &lt;descriptorRefs&gt;
                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
                    &lt;/descriptorRefs&gt;
                &lt;/configuration&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;make-assembly&lt;/id&gt; &lt;!-- this is used for inheritance merges --&gt;
                        &lt;phase&gt;package&lt;/phase&gt; &lt;!-- 指定在打包节点执行jar包合并操作 --&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;single&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;</code></pre>
<h2 id="模块管理"><a class="markdownIt-Anchor" href="#模块管理"></a> 模块管理</h2>
<p>在软件开发中，把一个大项目分拆为多个模块是降低软件复杂度的有效方法：</p>
<p>对于Maven工程来说，原来是一个大项目：</p>
<p>现在可以分拆成3个模块：</p>
<p>Maven可以有效地管理多个模块，我们只需要把每个模块当作一个独立的Maven项目，它们有各自独立的pom.xml。例如，模块A的pom.xml：</p>
<pre><code class="highlight plaintext">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;
    &lt;artifactId&gt;module-a&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;name&gt;module-a&lt;/name&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
        &lt;java.version&gt;11&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
            &lt;version&gt;1.7.28&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;
            &lt;version&gt;5.5.2&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;</code></pre>
<p>模块B的pom.xml：</p>
<pre><code class="highlight plaintext">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;
    &lt;artifactId&gt;module-b&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;name&gt;module-b&lt;/name&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
        &lt;java.version&gt;11&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
            &lt;version&gt;1.7.28&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;
            &lt;version&gt;5.5.2&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;</code></pre>
<p>可以看出来，模块A和模块B的pom.xml高度相似，因此，我们可以提取出共同部分作为parent：</p>
<pre><code class="highlight plaintext">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;
    &lt;artifactId&gt;parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;

    &lt;name&gt;parent&lt;/name&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
        &lt;java.version&gt;11&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
            &lt;version&gt;1.7.28&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;
            &lt;version&gt;5.5.2&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<hr />
<p>注意到<strong>parent的<packaging>是pom而不是jar</strong>，因为parent本身不含任何Java代码。编写parent的pom.xml只是为了在各个模块中减少重复的配置。现在我们的整个工程结构如下：</p>
<p>这样模块A就可以简化为：</p>
<pre><code class="highlight plaintext">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;parent&gt;
        &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;
        &lt;artifactId&gt;parent&lt;/artifactId&gt;
        &lt;version&gt;1.0&lt;/version&gt;
        &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt;
    &lt;/parent&gt;

    &lt;artifactId&gt;module-a&lt;/artifactId&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;name&gt;module-a&lt;/name&gt;
&lt;/project&gt;</code></pre>
<p>模块B、模块C都可以直接从parent继承，大幅简化了pom.xml的编写。</p>
<p>如果模块A依赖模块B，则模块A需要模块B的jar包才能正常编译，我们需要在模块A中引入模块B：</p>
<pre><code class="highlight plaintext">...
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;
        &lt;artifactId&gt;module-b&lt;/artifactId&gt;
        &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
<p>最后，在编译的时候，需要在根目录创建一个pom.xml统一编译：</p>
<pre><code class="highlight plaintext">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;
    &lt;artifactId&gt;build&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;name&gt;build&lt;/name&gt;

    &lt;modules&gt;
        &lt;module&gt;parent&lt;/module&gt;
        &lt;module&gt;module-a&lt;/module&gt;
        &lt;module&gt;module-b&lt;/module&gt;
        &lt;module&gt;module-c&lt;/module&gt;
    &lt;/modules&gt;
&lt;/project&gt;</code></pre>
<p>这样，在根目录执行mvn clean package时，Maven根据根目录的pom.xml找到包括parent在内的共4个<module>，一次性全部编译。</p>
<h3 id="中央私有本地仓库"><a class="markdownIt-Anchor" href="#中央私有本地仓库"></a> 中央/私有/本地仓库</h3>
<p><strong>中央仓库</strong></p>
<p>其实我们使用的大多数第三方模块都是这个用法，例如，我们使用commons logging、log4j这些第三方模块，就是第三方模块的开发者自己把编译好的jar包发布到Maven的中央仓库中。</p>
<p><strong>私有仓库</strong></p>
<p>私有仓库是指公司内部如果不希望把源码和jar包放到公网上，那么可以搭建私有仓库。私有仓库总是在公司内部使用，它只需要在本地的~/.m2/settings.xml中配置好，使用方式和中央仓位没有任何区别。</p>
<p><strong>本地仓库</strong></p>
<p>本地仓库是指把本地开发的项目“发布”在本地，这样其他项目可以通过本地仓库引用它。但是我们不推荐把自己的模块安装到Maven的本地仓库，因为每次修改某个模块的源码，都需要重新安装，非常容易出现版本不一致的情况。更好的方法是使用模块化编译，在编译的时候，告诉Maven几个模块之间存在依赖关系，需要一块编译，Maven就会自动按依赖顺序编译这些模块。</p>
<h2 id="使用mvnw"><a class="markdownIt-Anchor" href="#使用mvnw"></a> 使用mvnw</h2>
<p>我们使用Maven时，基本上只会用到mvn这一个命令。有些童鞋可能听说过mvnw，这个是啥？</p>
<p>mvnw是Maven Wrapper的缩写。因为我们安装Maven时，默认情况下，系统所有项目都会使用全局安装的这个Maven版本。但是，对于某些项目来说，它可能必须使用某个特定的Maven版本，这个时候，就可以使用Maven Wrapper，它可以负责给这个特定的项目安装指定版本的Maven，而其他项目不受影响。</p>
<p>简单地说，Maven Wrapper就是<strong>给一个项目提供一个独立的，指定版本的Maven给它使用</strong>。</p>
<p><strong>安装Maven Wrapper</strong></p>
<p>安装Maven Wrapper最简单的方式是在项目的根目录（即pom.xml所在的目录）下运行安装命令：</p>
<pre><code class="highlight plaintext">mvn -N io.takari:maven:0.7.6:wrapper</code></pre>
<p>它会自动使用最新版本的Maven。注意0.7.6是Maven Wrapper的版本。最新的Maven Wrapper版本可以去官方网站查看。</p>
<p>如果要指定使用的Maven版本，使用下面的安装命令指定版本，例如3.3.3：</p>
<pre><code class="highlight plaintext">mvn -N io.takari:maven:0.7.6:wrapper -Dmaven=3.3.3</code></pre>
<p>安装后，查看项目结构：</p>
<p>发现多了mvnw、mvnw.cmd和.mvn目录，我们只需要把mvn命令改成mvnw就可以使用跟项目关联的Maven。例如：</p>
<pre><code class="highlight plaintext">mvnw clean package</code></pre>
<p>在Linux或macOS下运行时需要加上./：</p>
<pre><code class="highlight plaintext">./mvnw clean package</code></pre>
<p>Maven Wrapper的另一个作用是把项目的mvnw、mvnw.cmd和.mvn提交到版本库中，可以使所有开发人员使用统一的Maven版本。</p>
<h2 id="发布artifact"><a class="markdownIt-Anchor" href="#发布artifact"></a> 发布Artifact</h2>
<p>当我们使用commons-logging这些第三方开源库的时候，我们实际上是通过Maven自动下载它的jar包，并根据其pom.xml解析依赖，自动把相关依赖包都下载后加入到classpath。</p>
<p>那么问题来了：当我们自己写了一个牛逼的开源库时，非常希望别人也能使用，总不能直接放个jar包的链接让别人下载吧？</p>
<p>如果我们把自己的开源库放到Maven的repo中，那么，别人只需按标准引用groupId:artifactId:version，即可自动下载jar包以及相关依赖。因此，本节我们介绍如何发布一个库到Maven的repo中。把自己的库发布到Maven的repo中有好几种方法，我们介绍3种最常用的方法。</p>
<h3 id="以静态文件发布"><a class="markdownIt-Anchor" href="#以静态文件发布"></a> 以静态文件发布</h3>
<p>如果我们观察一个中央仓库的Artifact结构，例如Commons Math，它的groupId是org.apache.commons，artifactId是commons-math3，以版本3.6.1为例，发布在中央仓库的文件夹路径就是<a target="_blank" rel="noopener" href="https://repo1.maven.org/maven2/org/apache/commons/commons-math3/3.6.1/%EF%BC%8C%E5%9C%A8%E6%AD%A4%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%EF%BC%8Ccommons-math3-3.6.1.jar%E5%B0%B1%E6%98%AF%E5%8F%91%E5%B8%83%E7%9A%84jar%E5%8C%85%EF%BC%8Ccommons-math3-3.6.1.pom%E5%B0%B1%E6%98%AF%E5%AE%83%E7%9A%84pom.xml%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%EF%BC%8Ccommons-math3-3.6.1-sources.jar%E6%98%AF%E6%BA%90%E4%BB%A3%E7%A0%81%EF%BC%8Ccommons-math3-3.6.1-javadoc.jar%E6%98%AF%E6%96%87%E6%A1%A3%E3%80%82%E5%85%B6%E5%AE%83%E4%BB%A5.asc%E3%80%81.md5%E3%80%81.sha1%E7%BB%93%E5%B0%BE%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%86%E5%88%AB%E6%98%AFGPG%E7%AD%BE%E5%90%8D%E3%80%81MD5%E6%91%98%E8%A6%81%E5%92%8CSHA-1%E6%91%98%E8%A6%81%E3%80%82">https://repo1.maven.org/maven2/org/apache/commons/commons-math3/3.6.1/，在此文件夹下，commons-math3-3.6.1.jar就是发布的jar包，commons-math3-3.6.1.pom就是它的pom.xml描述文件，commons-math3-3.6.1-sources.jar是源代码，commons-math3-3.6.1-javadoc.jar是文档。其它以.asc、.md5、.sha1结尾的文件分别是GPG签名、MD5摘要和SHA-1摘要。</a></p>
<p>我们只要按照这种目录结构组织文件，它就是一个有效的Maven仓库。</p>
<p>我们以广受好评的开源项目how-to-become-rich为例，先创建Maven工程目录结构如下：</p>
</main>

</article>


<script src="/js/highlight.js"></script>

  </main>
  <footer class="footer">
  
  <span>Copyright © 2026 Lism Blog | lisisism@qq.com</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>