<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <author>
    <name>Lism</name>
  </author>
  <generator uri="https://hexo.io/">Hexo</generator>
  <id>http://example.com/</id>
  <link href="http://example.com/" rel="alternate"/>
  <link href="http://example.com/atom.xml" rel="self"/>
  <rights>All rights reserved 2026, Lism</rights>
  <title>/Lism Blog</title>
  <updated>2026-02-27T09:27:49.610Z</updated>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Flink" scheme="http://example.com/tags/Flink/"/>
    <category term="大数据" scheme="http://example.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    <content>
      <![CDATA[<h1 id="apache-flink"><a class="markdownIt-Anchor" href="#apache-flink"></a> Apache Flink</h1><h2 id="简介与核心概念"><a class="markdownIt-Anchor" href="#简介与核心概念"></a> 简介与核心概念</h2><p>Apache Flink 是一个开源的分布式流处理和批处理框架，以其低延迟、高吞吐和精确一次（Exactly-Once）语义而闻名。Flink 支持真正的流批一体计算，能够同时处理无界流数据（实时数据）和有界流数据（批处理数据）</p><ul><li>流处理（Flink）：持续运行，周期性输出（每分钟输出一次）</li><li>批处理（如Spark）：处理完整数据集后一次性输出</li></ul><p><strong>核心特性</strong></p><ul><li>真正的流处理：不同于微批处理，Flink 采用真正的流处理模型</li><li>精确一次语义：确保每条数据被精确处理一次，不会重复或丢失</li><li>强大的状态管理：支持多种状态存储方式，状态可达 TB 级别</li><li>灵活的时间语义：支持事件时间、处理时间和摄入时间</li><li>流批一体：同一套 API 处理实时和批量数据</li><li>高可用性：支持多种部署模式，无单点故障</li></ul><p><strong>核心概念</strong></p><ul><li>DataStream：表示无限数据流的核心抽象</li><li>算子（Operator）：数据转换操作，如 map、filter、flatMap</li><li>窗口（Window）：将无限流切分为有限块进行计算</li><li>状态（State）：算子中间计算结果存储</li><li>Watermark：处理乱序数据的时间戳标记</li><li>Checkpoint：状态快照机制，实现容错恢复</li></ul><h2 id="搭建"><a class="markdownIt-Anchor" href="#搭建"></a> 搭建</h2><pre><code class="highlight sh"><span class="comment"># 下载 Flink（以 1.18.0 为例）</span>wget https://archive.apache.org/dist/flink/flink-1.18.0/flink-1.18.0-bin-scala_2.12.tar.gz<span class="comment"># 解压安装包</span>tar -xzf flink-1.18.0-bin-scala_2.12.tar.gz<span class="built_in">cd</span> flink-1.18.0<span class="comment"># 配置环境变量（可选）</span><span class="built_in">export</span> FLINK_HOME=/path/to/flink-1.18.0<span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$FLINK_HOME</span>/bin</code></pre><h2 id="部署模式"><a class="markdownIt-Anchor" href="#部署模式"></a> 部署模式</h2><h3 id="本地模式"><a class="markdownIt-Anchor" href="#本地模式"></a> 本地模式</h3><pre><code class="highlight bash"><span class="comment"># 启动本地集群</span>./bin/start-cluster.sh<span class="comment"># 验证启动</span>jps<span class="comment"># 应看到 StandaloneSessionClusterEntrypoint（JobManager）和 TaskManagerRunner 进程</span><span class="comment"># 访问 Web UI</span><span class="comment"># 浏览器访问 http://localhost:8081</span></code></pre><h3 id="standalone集群模式"><a class="markdownIt-Anchor" href="#standalone集群模式"></a> Standalone集群模式</h3><ol><li>修改配置文件​ conf/flink-conf.yaml：</li></ol><pre><code class="highlight bash"><span class="comment"># JobManager 地址</span>jobmanager.rpc.address: master-node<span class="comment"># TaskManager 内存配置</span>taskmanager.memory.process.size: 4096mtaskmanager.numberOfTaskSlots: 4<span class="comment"># 检查点配置</span>state.backend: filesystemstate.checkpoints.dir: file:///tmp/flink-checkpoints</code></pre><ol start="2"><li>配置 workers 文件：</li></ol><pre><code class="highlight bash"><span class="comment"># conf/workers</span>worker-node1worker-node2worker-node3</code></pre><ol start="3"><li>分发启动</li></ol><pre><code class="highlight bash"><span class="comment"># 分发到各节点</span>scp -r flink-1.18.0/ worker-node1:/opt/scp -r flink-1.18.0/ worker-node2:/opt/<span class="comment"># 在 master 节点启动集群</span>./bin/start-cluster.sh</code></pre><h3 id="docker部署"><a class="markdownIt-Anchor" href="#docker部署"></a> docker部署</h3><pre><code class="highlight yaml"><span class="comment"># docker-compose.yml</span><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span><span class="attr">services:</span>  <span class="attr">jobmanager:</span>    <span class="attr">image:</span> <span class="string">flink:1.18.0-scala_2.12</span>    <span class="attr">ports:</span>      <span class="bullet">-</span> <span class="string">&quot;8081:8081&quot;</span>    <span class="attr">command:</span> <span class="string">jobmanager</span>    <span class="attr">environment:</span>      <span class="bullet">-</span> <span class="string">JOB_MANAGER_RPC_ADDRESS=jobmanager</span>    <span class="attr">volumes:</span>      <span class="bullet">-</span> <span class="string">./data:/opt/flink/data</span>    <span class="attr">taskmanager:</span>    <span class="attr">image:</span> <span class="string">flink:1.18.0-scala_2.12</span>    <span class="attr">depends_on:</span>      <span class="bullet">-</span> <span class="string">jobmanager</span>    <span class="attr">command:</span> <span class="string">taskmanager</span>    <span class="attr">environment:</span>      <span class="bullet">-</span> <span class="string">JOB_MANAGER_RPC_ADDRESS=jobmanager</span>      <span class="bullet">-</span> <span class="string">TASK_MANAGER_NUMBER_OF_TASK_SLOTS=4</span>    <span class="attr">deploy:</span>      <span class="attr">replicas:</span> <span class="number">2</span></code></pre><h3 id="maven"><a class="markdownIt-Anchor" href="#maven"></a> Maven</h3><pre><code class="highlight xml"><span class="comment">&lt;!-- pom.xml --&gt;</span><span class="tag">&lt;<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">flink.version</span>&gt;</span>1.18.0<span class="tag">&lt;/<span class="name">flink.version</span>&gt;</span>    <span class="tag">&lt;<span class="name">scala.binary.version</span>&gt;</span>2.12<span class="tag">&lt;/<span class="name">scala.binary.version</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>    <span class="comment">&lt;!-- Flink 核心依赖 --&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!-- 可选：Table API --&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-api-java-bridge<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!-- 可选：连接器 --&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></code></pre><h2 id="flink基础使用"><a class="markdownIt-Anchor" href="#flink基础使用"></a> Flink基础使用</h2><h4 id="第一个-flink-程序wordcount"><a class="markdownIt-Anchor" href="#第一个-flink-程序wordcount"></a> 第一个 Flink 程序：WordCount</h4><pre><code class="highlight java"><span class="keyword">import</span> org.apache.flink.api.common.functions.FlatMapFunction;<span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;<span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;<span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;<span class="keyword">import</span> org.apache.flink.util.Collector;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCount</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">// 1. 创建执行环境</span>        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();                <span class="comment">// 2. 创建数据源</span>        DataStream&lt;String&gt; text = env.fromElements(            <span class="string">&quot;Hello Flink&quot;</span>,            <span class="string">&quot;Hello Java&quot;</span>,             <span class="string">&quot;Hello World&quot;</span>        );                <span class="comment">// 3. 定义转换操作</span>        DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; wordCounts = text            .flatMap(<span class="keyword">new</span> <span class="title class_">Tokenizer</span>())            .keyBy(value -&gt; value.f0)            .sum(<span class="number">1</span>);                <span class="comment">// 4. 输出结果</span>        wordCounts.print();                <span class="comment">// 5. 执行程序</span>        env.execute(<span class="string">&quot;WordCount Example&quot;</span>);    &#125;        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Tokenizer</span> <span class="keyword">implements</span> <span class="title class_">FlatMapFunction</span>&lt;String, Tuple2&lt;String, Integer&gt;&gt; &#123;        <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatMap</span><span class="params">(String value, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; out)</span> &#123;            String[] words = value.toLowerCase().split(<span class="string">&quot;\\W+&quot;</span>);            <span class="keyword">for</span> (String word : words) &#123;                <span class="keyword">if</span> (word.length() &gt; <span class="number">0</span>) &#123;                    out.collect(<span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(word, <span class="number">1</span>));                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="流处理"><a class="markdownIt-Anchor" href="#流处理"></a> 流处理</h4><pre><code class="highlight java"><span class="comment">// 创建执行环境</span><span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();<span class="comment">// 设置并行度</span>env.setParallelism(<span class="number">4</span>);<span class="comment">// 启用检查点（每5秒）</span>env.enableCheckpointing(<span class="number">5000</span>);<span class="comment">// 常见数据源</span>DataStream&lt;String&gt; source1 = env.fromElements(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);DataStream&lt;String&gt; source2 = env.readTextFile(<span class="string">&quot;input.txt&quot;</span>);DataStream&lt;String&gt; source3 = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>);<span class="comment">// 基本转换算子</span>DataStream&lt;String&gt; mapped = source1.map(String::toUpperCase);DataStream&lt;String&gt; filtered = source1.filter(s -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));DataStream&lt;String&gt; flatMapped = source1.flatMap((String s, Collector&lt;String&gt; out) -&gt; &#123;    <span class="keyword">for</span> (String word : s.split(<span class="string">&quot; &quot;</span>)) &#123;        out.collect(word);    &#125;&#125;);<span class="comment">// 分组聚合</span>DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; keyed = source1    .map(s -&gt; <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(s, <span class="number">1</span>))    .keyBy(t -&gt; t.f0)    .sum(<span class="number">1</span>);<span class="comment">// 窗口操作</span>DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; windowed = source1    .map(s -&gt; <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(s, <span class="number">1</span>))    .keyBy(t -&gt; t.f0)    .window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">10</span>)))    .sum(<span class="number">1</span>);</code></pre><h4 id="table-api-sql"><a class="markdownIt-Anchor" href="#table-api-sql"></a> Table API &amp; SQL</h4><pre><code class="highlight java"><span class="comment">// 创建表环境</span><span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();<span class="type">StreamTableEnvironment</span> <span class="variable">tableEnv</span> <span class="operator">=</span> StreamTableEnvironment.create(env);<span class="comment">// 从 DataStream 创建表</span>DataStream&lt;Order&gt; orderStream = env.addSource(...);<span class="type">Table</span> <span class="variable">orderTable</span> <span class="operator">=</span> tableEnv.fromDataStream(orderStream);<span class="comment">// 注册表</span>tableEnv.createTemporaryView(<span class="string">&quot;orders&quot;</span>, orderTable);<span class="comment">// 执行 SQL 查询</span><span class="type">Table</span> <span class="variable">resultTable</span> <span class="operator">=</span> tableEnv.sqlQuery(    <span class="string">&quot;SELECT user_id, COUNT(*) as order_count &quot;</span> +    <span class="string">&quot;FROM orders &quot;</span> +    <span class="string">&quot;WHERE status = &#x27;SUCCESS&#x27; &quot;</span> +    <span class="string">&quot;GROUP BY user_id&quot;</span>);<span class="comment">// 将结果转换为 DataStream</span>DataStream&lt;Row&gt; resultStream = tableEnv.toDataStream(resultTable);</code></pre><h4 id="实时处理kafka数据分析"><a class="markdownIt-Anchor" href="#实时处理kafka数据分析"></a> 实时处理kafka数据分析：</h4><pre><code class="highlight java"><span class="comment">// 实时日志分析示例</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAnalysisJob</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();                <span class="comment">// 从 Kafka 读取日志</span>        <span class="type">Properties</span> <span class="variable">kafkaProps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();        kafkaProps.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);                FlinkKafkaConsumer&lt;String&gt; source = <span class="keyword">new</span> <span class="title class_">FlinkKafkaConsumer</span>&lt;&gt;(            <span class="string">&quot;app-logs&quot;</span>,            <span class="keyword">new</span> <span class="title class_">SimpleStringSchema</span>(),            kafkaProps        );                DataStream&lt;String&gt; logStream = env.addSource(source);                <span class="comment">// 解析日志并统计错误率</span>        DataStream&lt;Tuple3&lt;String, String, Integer&gt;&gt; parsedLogs = logStream            .map(<span class="keyword">new</span> <span class="title class_">LogParser</span>())            .assignTimestampsAndWatermarks(                WatermarkStrategy                    .&lt;LogEvent&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">5</span>))                    .withTimestampAssigner((event, timestamp) -&gt; event.getTimestamp())            );                <span class="comment">// 每5分钟统计各服务的错误率</span>        DataStream&lt;ServiceErrorRate&gt; errorRates = parsedLogs            .filter(event -&gt; <span class="string">&quot;ERROR&quot;</span>.equals(event.getLevel()))            .keyBy(LogEvent::getServiceName)            .window(TumblingEventTimeWindows.of(Time.minutes(<span class="number">5</span>)))            .process(<span class="keyword">new</span> <span class="title class_">ErrorRateCalculator</span>());                errorRates.print();        env.execute(<span class="string">&quot;Log Analysis Job&quot;</span>);    &#125;        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LogParser</span> <span class="keyword">implements</span> <span class="title class_">MapFunction</span>&lt;String, LogEvent&gt; &#123;        <span class="meta">@Override</span>        <span class="keyword">public</span> LogEvent <span class="title function_">map</span><span class="params">(String value)</span> &#123;            <span class="comment">// 解析日志格式：timestamp|service|level|message</span>            String[] parts = value.split(<span class="string">&quot;\\|&quot;</span>);            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LogEvent</span>(                Long.parseLong(parts[<span class="number">0</span>]),                parts[<span class="number">1</span>],                parts[<span class="number">2</span>],                parts[<span class="number">3</span>]            );        &#125;    &#125;&#125;</code></pre><h4 id="实时-etl-管道kafka-elasticsearch"><a class="markdownIt-Anchor" href="#实时-etl-管道kafka-elasticsearch"></a> 实时 ETL 管道（Kafka → Elasticsearch）</h4><pre><code class="highlight java"><span class="comment">// 完整 ETL 管道示例</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaToElasticsearchETL</span> &#123;        <span class="comment">// 数据模型定义</span>    <span class="meta">@Data</span>    <span class="meta">@NoArgsConstructor</span>    <span class="meta">@AllArgsConstructor</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserEvent</span> &#123;        <span class="keyword">private</span> String userId;        <span class="keyword">private</span> String eventType;        <span class="keyword">private</span> String ipAddress;        <span class="keyword">private</span> String userAgent;        <span class="keyword">private</span> Double value;        <span class="keyword">private</span> Long timestamp;    &#125;        <span class="meta">@Data</span>    <span class="meta">@NoArgsConstructor</span>    <span class="meta">@AllArgsConstructor</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ProcessedEvent</span> &#123;        <span class="keyword">private</span> String userId;        <span class="keyword">private</span> String eventType;        <span class="keyword">private</span> String location;        <span class="keyword">private</span> String deviceCategory;        <span class="keyword">private</span> String osFamily;        <span class="keyword">private</span> Double normalizedValue;        <span class="keyword">private</span> Instant eventTime;        <span class="keyword">private</span> Instant processTime;    &#125;        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();                <span class="comment">// 1. Kafka Source</span>        KafkaSource&lt;UserEvent&gt; source = KafkaSource.&lt;UserEvent&gt;builder()            .setBootstrapServers(<span class="string">&quot;localhost:9092&quot;</span>)            .setTopics(<span class="string">&quot;user-events&quot;</span>)            .setGroupId(<span class="string">&quot;flink-etl-group&quot;</span>)            .setStartingOffsets(OffsetsInitializer.latest())            .setValueOnlyDeserializer(<span class="keyword">new</span> <span class="title class_">JsonDeserializationSchema</span>&lt;&gt;(UserEvent.class))            .build();                DataStream&lt;UserEvent&gt; rawStream = env.fromSource(            source,            WatermarkStrategy.forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">5</span>)),            <span class="string">&quot;Kafka Source&quot;</span>        );                <span class="comment">// 2. 数据转换处理</span>        DataStream&lt;ProcessedEvent&gt; processedStream = rawStream            .map(<span class="keyword">new</span> <span class="title class_">EventEnricher</span>())            .name(<span class="string">&quot;Event Enrichment&quot;</span>)            .filter(event -&gt; event.getNormalizedValue() &gt; <span class="number">0</span>)            .name(<span class="string">&quot;Filter Invalid Events&quot;</span>);                <span class="comment">// 3. Elasticsearch Sink</span>        List&lt;HttpHost&gt; httpHosts = Arrays.asList(            <span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>)        );                ElasticsearchSink&lt;ProcessedEvent&gt; esSink = <span class="keyword">new</span> <span class="title class_">Elasticsearch7SinkBuilder</span>&lt;ProcessedEvent&gt;()            .setHosts(httpHosts)            .setEmitter((element, context, indexer) -&gt; &#123;                <span class="type">IndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> Requests.indexRequest()                    .index(<span class="string">&quot;user-events&quot;</span>)                    .id(element.getUserId() + <span class="string">&quot;_&quot;</span> + element.getEventTime())                    .source(JsonUtils.toJson(element), XContentType.JSON);                indexer.add(request);            &#125;)            .setBulkFlushMaxActions(<span class="number">1000</span>)            .setBulkFlushInterval(<span class="number">1000L</span>)            .setBulkFlushBackoffStrategy(FlushBackoffType.EXPONENTIAL, <span class="number">3</span>, <span class="number">1000</span>)            .build();                processedStream.sinkTo(esSink).name(<span class="string">&quot;Elasticsearch Sink&quot;</span>);                <span class="comment">// 4. 执行作业</span>        env.execute(<span class="string">&quot;Kafka to Elasticsearch ETL&quot;</span>);    &#125;        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EventEnricher</span> <span class="keyword">implements</span> <span class="title class_">MapFunction</span>&lt;UserEvent, ProcessedEvent&gt; &#123;        <span class="keyword">private</span> <span class="keyword">transient</span> IPLocationService locationService;        <span class="keyword">private</span> <span class="keyword">transient</span> UserAgentParser uaParser;                <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(Configuration parameters)</span> &#123;            locationService = <span class="keyword">new</span> <span class="title class_">IPLocationService</span>();            uaParser = <span class="keyword">new</span> <span class="title class_">UserAgentParser</span>();        &#125;                <span class="meta">@Override</span>        <span class="keyword">public</span> ProcessedEvent <span class="title function_">map</span><span class="params">(UserEvent event)</span> &#123;            <span class="comment">// 丰富数据：IP解析地理位置、UserAgent解析设备信息</span>            <span class="type">String</span> <span class="variable">location</span> <span class="operator">=</span> locationService.getLocation(event.getIpAddress());            <span class="type">UserAgentInfo</span> <span class="variable">uaInfo</span> <span class="operator">=</span> uaParser.parse(event.getUserAgent());                        <span class="comment">// 数据标准化</span>            <span class="type">Double</span> <span class="variable">normalizedValue</span> <span class="operator">=</span> normalize(event.getValue());                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProcessedEvent</span>(                event.getUserId(),                event.getEventType(),                location,                uaInfo.getDeviceCategory(),                uaInfo.getOsFamily(),                normalizedValue,                Instant.ofEpochMilli(event.getTimestamp()),                Instant.now()            );        &#125;                <span class="keyword">private</span> Double <span class="title function_">normalize</span><span class="params">(Double value)</span> &#123;            <span class="comment">// 标准化逻辑</span>            <span class="keyword">return</span> value != <span class="literal">null</span> ? value / <span class="number">100.0</span> : <span class="number">0.0</span>;        &#125;    &#125;&#125;</code></pre><h4 id="检测电商数据"><a class="markdownIt-Anchor" href="#检测电商数据"></a> 检测电商数据</h4><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EcommerceOrderMonitor</span> &#123;        <span class="meta">@Data</span>    <span class="meta">@NoArgsConstructor</span>    <span class="meta">@AllArgsConstructor</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OrderEvent</span> &#123;        <span class="keyword">private</span> String orderId;        <span class="keyword">private</span> String userId;        <span class="keyword">private</span> String region;        <span class="keyword">private</span> Double amount;        <span class="keyword">private</span> String paymentMethod;        <span class="keyword">private</span> Long timestamp;    &#125;        <span class="meta">@Data</span>    <span class="meta">@NoArgsConstructor</span>    <span class="meta">@AllArgsConstructor</span>      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RegionOrderStats</span> &#123;        <span class="keyword">private</span> String region;        <span class="keyword">private</span> Long windowStart;        <span class="keyword">private</span> Long windowEnd;        <span class="keyword">private</span> Long orderCount;        <span class="keyword">private</span> Double totalAmount;        <span class="keyword">private</span> Double avgAmount;    &#125;        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();        env.setParallelism(<span class="number">4</span>);                <span class="comment">// 1. 从 Kafka 读取订单数据</span>        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();        props.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;kafka1:9092,kafka2:9092&quot;</span>);        props.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;order-monitor&quot;</span>);                FlinkKafkaConsumer&lt;OrderEvent&gt; source = <span class="keyword">new</span> <span class="title class_">FlinkKafkaConsumer</span>&lt;&gt;(            <span class="string">&quot;orders&quot;</span>,            <span class="keyword">new</span> <span class="title class_">JsonDeserializationSchema</span>&lt;&gt;(OrderEvent.class),            props        );                source.setStartFromLatest();                DataStream&lt;OrderEvent&gt; orderStream = env.addSource(source)            .assignTimestampsAndWatermarks(                WatermarkStrategy                    .&lt;OrderEvent&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">10</span>))                    .withTimestampAssigner((event, timestamp) -&gt; event.getTimestamp())            );                <span class="comment">// 2. 实时统计：每分钟各地区订单量和金额</span>        DataStream&lt;RegionOrderStats&gt; regionStats = orderStream            .keyBy(OrderEvent::getRegion)            .window(TumblingEventTimeWindows.of(Time.minutes(<span class="number">1</span>)))            .aggregate(<span class="keyword">new</span> <span class="title class_">OrderAggregator</span>(), <span class="keyword">new</span> <span class="title class_">OrderWindowProcessor</span>());                <span class="comment">// 3. 异常检测：检测异常大额订单</span>        OutputTag&lt;OrderEvent&gt; largeOrderTag = <span class="keyword">new</span> <span class="title class_">OutputTag</span>&lt;OrderEvent&gt;(<span class="string">&quot;large-orders&quot;</span>) &#123;&#125;;                SingleOutputStreamOperator&lt;OrderEvent&gt; normalOrders = orderStream            .process(<span class="keyword">new</span> <span class="title class_">FraudDetectionProcessFunction</span>(largeOrderTag));                DataStream&lt;OrderEvent&gt; largeOrders = normalOrders.getSideOutput(largeOrderTag);                <span class="comment">// 4. 输出结果</span>        regionStats.print(<span class="string">&quot;Region Statistics&quot;</span>);        largeOrders.print(<span class="string">&quot;Large Orders Alert&quot;</span>);                <span class="comment">// 5. 将统计结果写入数据库</span>        regionStats.addSink(<span class="keyword">new</span> <span class="title class_">JdbcSink</span>&lt;&gt;(            <span class="string">&quot;INSERT INTO region_order_stats (region, window_start, window_end, order_count, total_amount, avg_amount) &quot;</span> +            <span class="string">&quot;VALUES (?, ?, ?, ?, ?, ?) ON DUPLICATE KEY UPDATE &quot;</span> +            <span class="string">&quot;order_count=VALUES(order_count), total_amount=VALUES(total_amount), avg_amount=VALUES(avg_amount)&quot;</span>,            (statement, stats) -&gt; &#123;                statement.setString(<span class="number">1</span>, stats.getRegion());                statement.setTimestamp(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">Timestamp</span>(stats.getWindowStart()));                statement.setTimestamp(<span class="number">3</span>, <span class="keyword">new</span> <span class="title class_">Timestamp</span>(stats.getWindowEnd()));                statement.setLong(<span class="number">4</span>, stats.getOrderCount());                statement.setDouble(<span class="number">5</span>, stats.getTotalAmount());                statement.setDouble(<span class="number">6</span>, stats.getAvgAmount());            &#125;,            JdbcExecutionOptions.builder()                .withBatchSize(<span class="number">1000</span>)                .withBatchIntervalMs(<span class="number">200</span>)                .build(),            JdbcConnectionOptions.builder()                .withUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/ecommerce&quot;</span>)                .withDriverName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>)                .withUsername(<span class="string">&quot;flink&quot;</span>)                .withPassword(<span class="string">&quot;password&quot;</span>)                .build()        ));                env.execute(<span class="string">&quot;E-commerce Order Monitor&quot;</span>);    &#125;        <span class="comment">// 聚合函数：累加订单数量和金额</span>    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OrderAggregator</span> <span class="keyword">implements</span> <span class="title class_">AggregateFunction</span>&lt;OrderEvent, Tuple3&lt;Long, Double, Long&gt;, Tuple3&lt;Long, Double, Long&gt;&gt; &#123;        <span class="meta">@Override</span>        <span class="keyword">public</span> Tuple3&lt;Long, Double, Long&gt; <span class="title function_">createAccumulator</span><span class="params">()</span> &#123;            <span class="keyword">return</span> Tuple3.of(<span class="number">0L</span>, <span class="number">0.0</span>, <span class="number">0L</span>); <span class="comment">// count, amount, timestamp</span>        &#125;                <span class="meta">@Override</span>        <span class="keyword">public</span> Tuple3&lt;Long, Double, Long&gt; <span class="title function_">add</span><span class="params">(OrderEvent value, Tuple3&lt;Long, Double, Long&gt; accumulator)</span> &#123;            <span class="keyword">return</span> Tuple3.of(                accumulator.f0 + <span class="number">1</span>,                accumulator.f1 + value.getAmount(),                Math.max(accumulator.f2, value.getTimestamp())            );        &#125;                <span class="meta">@Override</span>        <span class="keyword">public</span> Tuple3&lt;Long, Double, Long&gt; <span class="title function_">getResult</span><span class="params">(Tuple3&lt;Long, Double, Long&gt; accumulator)</span> &#123;            <span class="keyword">return</span> accumulator;        &#125;                <span class="meta">@Override</span>        <span class="keyword">public</span> Tuple3&lt;Long, Double, Long&gt; <span class="title function_">merge</span><span class="params">(Tuple3&lt;Long, Double, Long&gt; a, Tuple3&lt;Long, Double, Long&gt; b)</span> &#123;            <span class="keyword">return</span> Tuple3.of(a.f0 + b.f0, a.f1 + b.f1, Math.max(a.f2, b.f2));        &#125;    &#125;        <span class="comment">// 窗口处理函数：生成统计结果</span>    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OrderWindowProcessor</span> <span class="keyword">extends</span> <span class="title class_">ProcessWindowFunction</span>&lt;        Tuple3&lt;Long, Double, Long&gt;, RegionOrderStats, String, TimeWindow&gt; &#123;                <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String region, Context context, </span><span class="params">                          Iterable&lt;Tuple3&lt;Long, Double, Long&gt;&gt; elements,</span><span class="params">                          Collector&lt;RegionOrderStats&gt; out)</span> &#123;            Tuple3&lt;Long, Double, Long&gt; result = elements.iterator().next();                        <span class="type">RegionOrderStats</span> <span class="variable">stats</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegionOrderStats</span>(                region,                context.window().getStart(),                context.window().getEnd(),                result.f0, <span class="comment">// orderCount</span>                result.f1, <span class="comment">// totalAmount</span>                result.f0 &gt; <span class="number">0</span> ? result.f1 / result.f0 : <span class="number">0.0</span> <span class="comment">// avgAmount</span>            );                        out.collect(stats);        &#125;    &#125;        <span class="comment">// 欺诈检测处理函数</span>    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FraudDetectionProcessFunction</span> <span class="keyword">extends</span> <span class="title class_">ProcessFunction</span>&lt;OrderEvent, OrderEvent&gt; &#123;        <span class="keyword">private</span> <span class="keyword">final</span> OutputTag&lt;OrderEvent&gt; largeOrderTag;        <span class="keyword">private</span> <span class="keyword">transient</span> ValueState&lt;Double&gt; userTotalState;        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Double</span> <span class="variable">LARGE_ORDER_THRESHOLD</span> <span class="operator">=</span> <span class="number">10000.0</span>;        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Double</span> <span class="variable">USER_HOURLY_THRESHOLD</span> <span class="operator">=</span> <span class="number">50000.0</span>;                <span class="keyword">public</span> <span class="title function_">FraudDetectionProcessFunction</span><span class="params">(OutputTag&lt;OrderEvent&gt; largeOrderTag)</span> &#123;            <span class="built_in">this</span>.largeOrderTag = largeOrderTag;        &#125;                <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(Configuration parameters)</span> &#123;            ValueStateDescriptor&lt;Double&gt; descriptor =                 <span class="keyword">new</span> <span class="title class_">ValueStateDescriptor</span>&lt;&gt;(<span class="string">&quot;user-total&quot;</span>, Double.class);                        <span class="comment">// 设置状态 TTL：1小时</span>            <span class="type">StateTtlConfig</span> <span class="variable">ttlConfig</span> <span class="operator">=</span> StateTtlConfig                .newBuilder(Time.hours(<span class="number">1</span>))                .setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite)                .setStateVisibility(StateTtlConfig.StateVisibility.NeverReturnExpired)                .build();                        descriptor.enableTimeToLive(ttlConfig);            userTotalState = getRuntimeContext().getState(descriptor);        &#125;                <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processElement</span><span class="params">(OrderEvent event, Context ctx, </span><span class="params">                                 Collector&lt;OrderEvent&gt; out)</span> <span class="keyword">throws</span> Exception &#123;                        <span class="comment">// 检测单笔大额订单</span>            <span class="keyword">if</span> (event.getAmount() &gt; LARGE_ORDER_THRESHOLD) &#123;                ctx.output(largeOrderTag, event);            &#125;                        <span class="comment">// 检测用户累计金额异常</span>            <span class="type">Double</span> <span class="variable">userTotal</span> <span class="operator">=</span> userTotalState.value();            <span class="keyword">if</span> (userTotal == <span class="literal">null</span>) &#123;                userTotal = <span class="number">0.0</span>;            &#125;                        userTotal += event.getAmount();            userTotalState.update(userTotal);                        <span class="keyword">if</span> (userTotal &gt; USER_HOURLY_THRESHOLD) &#123;                ctx.output(largeOrderTag, event);            &#125;                        <span class="comment">// 正常订单继续向下游传递</span>            out.collect(event);        &#125;    &#125;&#125;</code></pre><h4 id="物联网设备监控"><a class="markdownIt-Anchor" href="#物联网设备监控"></a> 物联网设备监控</h4><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IoTDeviceMonitor</span> &#123;        <span class="meta">@Data</span>    <span class="meta">@NoArgsConstructor</span>    <span class="meta">@AllArgsConstructor</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SensorData</span> &#123;        <span class="keyword">private</span> String deviceId;        <span class="keyword">private</span> String sensorType;        <span class="keyword">private</span> Double value;        <span class="keyword">private</span> Long timestamp;        <span class="keyword">private</span> Double latitude;        <span class="keyword">private</span> Double longitude;    &#125;        <span class="meta">@Data</span>    <span class="meta">@NoArgsConstructor</span>    <span class="meta">@AllArgsConstructor</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DeviceAlert</span> &#123;        <span class="keyword">private</span> String deviceId;        <span class="keyword">private</span> String alertType;        <span class="keyword">private</span> Double currentValue;        <span class="keyword">private</span> Double threshold;        <span class="keyword">private</span> String message;        <span class="keyword">private</span> Long timestamp;    &#125;        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();                <span class="comment">// 1. 从 MQTT/Kafka 读取传感器数据</span>        DataStream&lt;SensorData&gt; sensorStream = env            .addSource(<span class="keyword">new</span> <span class="title class_">MQTTSource</span>(<span class="string">&quot;tcp://mqtt-server:1883&quot;</span>, <span class="string">&quot;sensors/#&quot;</span>))            .map(message -&gt; parseSensorData(message))            .assignTimestampsAndWatermarks(                WatermarkStrategy                    .&lt;SensorData&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">5</span>))                    .withTimestampAssigner((event, timestamp) -&gt; event.getTimestamp())            );                <span class="comment">// 2. 温度异常检测：连续3次超过阈值</span>        OutputTag&lt;DeviceAlert&gt; temperatureAlertTag = <span class="keyword">new</span> <span class="title class_">OutputTag</span>&lt;DeviceAlert&gt;(<span class="string">&quot;temperature-alert&quot;</span>) &#123;&#125;;                DataStream&lt;SensorData&gt; temperatureStream = sensorStream            .filter(data -&gt; <span class="string">&quot;temperature&quot;</span>.equals(data.getSensorType()));                SingleOutputStreamOperator&lt;SensorData&gt; normalTempStream = temperatureStream            .keyBy(SensorData::getDeviceId)            .process(<span class="keyword">new</span> <span class="title class_">TemperatureAnomalyDetector</span>(temperatureAlertTag));                DataStream&lt;DeviceAlert&gt; temperatureAlerts = normalTempStream            .getSideOutput(temperatureAlertTag);                <span class="comment">// 3. 设备离线检测：5分钟无数据上报</span>        OutputTag&lt;DeviceAlert&gt; offlineAlertTag = <span class="keyword">new</span> <span class="title class_">OutputTag</span>&lt;DeviceAlert&gt;(<span class="string">&quot;offline-alert&quot;</span>) &#123;&#125;;                SingleOutputStreamOperator&lt;SensorData&gt; onlineDevices = sensorStream            .keyBy(SensorData::getDeviceId)            .process(<span class="keyword">new</span> <span class="title class_">DeviceOfflineDetector</span>(offlineAlertTag, Time.minutes(<span class="number">5</span>)));                DataStream&lt;DeviceAlert&gt; offlineAlerts = onlineDevices            .getSideOutput(offlineAlertTag);                <span class="comment">// 4. 实时统计：每10分钟设备平均指标</span>        DataStream&lt;DeviceStats&gt; deviceStats = sensorStream            .keyBy(SensorData::getDeviceId)            .window(TumblingEventTimeWindows.of(Time.minutes(<span class="number">10</span>)))            .aggregate(<span class="keyword">new</span> <span class="title class_">DeviceStatsAggregator</span>());                <span class="comment">// 5. 输出和存储</span>        temperatureAlerts.print(<span class="string">&quot;Temperature Alerts&quot;</span>);        offlineAlerts.print(<span class="string">&quot;Offline Alerts&quot;</span>);        deviceStats.print(<span class="string">&quot;Device Statistics&quot;</span>);                <span class="comment">// 将告警写入时序数据库</span>        temperatureAlerts.addSink(<span class="keyword">new</span> <span class="title class_">InfluxDBSink</span>&lt;&gt;());        offlineAlerts.addSink(<span class="keyword">new</span> <span class="title class_">InfluxDBSink</span>&lt;&gt;());                env.execute(<span class="string">&quot;IoT Device Monitor&quot;</span>);    &#125;        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TemperatureAnomalyDetector</span> <span class="keyword">extends</span> <span class="title class_">KeyedProcessFunction</span>&lt;String, SensorData, SensorData&gt; &#123;        <span class="keyword">private</span> <span class="keyword">final</span> OutputTag&lt;DeviceAlert&gt; alertTag;        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Double</span> <span class="variable">TEMP_THRESHOLD</span> <span class="operator">=</span> <span class="number">85.0</span>;        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONSECUTIVE_COUNT</span> <span class="operator">=</span> <span class="number">3</span>;                <span class="keyword">private</span> <span class="keyword">transient</span> ListState&lt;Double&gt; recentTemperatures;        <span class="keyword">private</span> <span class="keyword">transient</span> ValueState&lt;Long&gt; lastAlertTime;                <span class="keyword">public</span> <span class="title function_">TemperatureAnomalyDetector</span><span class="params">(OutputTag&lt;DeviceAlert&gt; alertTag)</span> &#123;            <span class="built_in">this</span>.alertTag = alertTag;        &#125;                <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(Configuration parameters)</span> &#123;            ListStateDescriptor&lt;Double&gt; tempDescriptor =                 <span class="keyword">new</span> <span class="title class_">ListStateDescriptor</span>&lt;&gt;(<span class="string">&quot;recent-temps&quot;</span>, Double.class);            recentTemperatures = getRuntimeContext().getListState(tempDescriptor);                        ValueStateDescriptor&lt;Long&gt; alertDescriptor =                 <span class="keyword">new</span> <span class="title class_">ValueStateDescriptor</span>&lt;&gt;(<span class="string">&quot;last-alert&quot;</span>, Long.class);            lastAlertTime = getRuntimeContext().getState(alertDescriptor);        &#125;                <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processElement</span><span class="params">(SensorData data, Context ctx, </span><span class="params">                                 Collector&lt;SensorData&gt; out)</span> <span class="keyword">throws</span> Exception &#123;                        <span class="comment">// 添加到最近温度列表</span>            Iterable&lt;Double&gt; temps = recentTemperatures.get();            List&lt;Double&gt; tempList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();            temps.forEach(tempList::add);                        tempList.add(data.getValue());                        <span class="comment">// 只保留最近 CONSECUTIVE_COUNT 次温度</span>            <span class="keyword">if</span> (tempList.size() &gt; CONSECUTIVE_COUNT) &#123;                tempList = tempList.subList(tempList.size() - CONSECUTIVE_COUNT, tempList.size());            &#125;                        recentTemperatures.update(tempList);                        <span class="comment">// 检查是否连续超过阈值</span>            <span class="type">boolean</span> <span class="variable">allAboveThreshold</span> <span class="operator">=</span> tempList.stream()                .allMatch(temp -&gt; temp &gt; TEMP_THRESHOLD);                        <span class="type">Long</span> <span class="variable">lastAlert</span> <span class="operator">=</span> lastAlertTime.value();            <span class="type">Long</span> <span class="variable">currentTime</span> <span class="operator">=</span> ctx.timestamp();                        <span class="comment">// 避免频繁告警：至少间隔1分钟</span>            <span class="keyword">if</span> (allAboveThreshold &amp;&amp;                 (lastAlert == <span class="literal">null</span> || currentTime - lastAlert &gt; <span class="number">60000</span>)) &#123;                                <span class="type">DeviceAlert</span> <span class="variable">alert</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeviceAlert</span>(                    data.getDeviceId(),                    <span class="string">&quot;HIGH_TEMPERATURE&quot;</span>,                    data.getValue(),                    TEMP_THRESHOLD,                    String.format(<span class="string">&quot;设备温度连续%d次超过阈值&quot;</span>, CONSECUTIVE_COUNT),                    currentTime                );                                ctx.output(alertTag, alert);                lastAlertTime.update(currentTime);            &#125;                        out.collect(data);        &#125;    &#125;        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DeviceOfflineDetector</span> <span class="keyword">extends</span> <span class="title class_">KeyedProcessFunction</span>&lt;String, SensorData, SensorData&gt; &#123;        <span class="keyword">private</span> <span class="keyword">final</span> OutputTag&lt;DeviceAlert&gt; alertTag;        <span class="keyword">private</span> <span class="keyword">final</span> Time offlineThreshold;                <span class="keyword">private</span> <span class="keyword">transient</span> ValueState&lt;Long&gt; lastSeenTime;        <span class="keyword">private</span> <span class="keyword">transient</span> ValueState&lt;Long&gt; timerState;                <span class="keyword">public</span> <span class="title function_">DeviceOfflineDetector</span><span class="params">(OutputTag&lt;DeviceAlert&gt; alertTag, Time offlineThreshold)</span> &#123;            <span class="built_in">this</span>.alertTag = alertTag;            <span class="built_in">this</span>.offlineThreshold = offlineThreshold;        &#125;                <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(Configuration parameters)</span> &#123;            ValueStateDescriptor&lt;Long&gt; lastSeenDescriptor =                 <span class="keyword">new</span> <span class="title class_">ValueStateDescriptor</span>&lt;&gt;(<span class="string">&quot;last-seen&quot;</span>, Long.class);            lastSeenTime = getRuntimeContext().getState(lastSeenDescriptor);                        ValueStateDescriptor&lt;Long&gt; timerDescriptor =                 <span class="keyword">new</span> <span class="title class_">ValueStateDescriptor</span>&lt;&gt;(<span class="string">&quot;timer&quot;</span>, Long.class);            timerState = getRuntimeContext().getState(timerDescriptor);        &#125;                <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processElement</span><span class="params">(SensorData data, Context ctx, </span><span class="params">                                 Collector&lt;SensorData&gt; out)</span> <span class="keyword">throws</span> Exception &#123;                        <span class="type">Long</span> <span class="variable">currentTime</span> <span class="operator">=</span> ctx.timestamp();            <span class="type">Long</span> <span class="variable">lastSeen</span> <span class="operator">=</span> lastSeenTime.value();                        <span class="comment">// 更新最后看到时间</span>            lastSeenTime.update(currentTime);                        <span class="comment">// 取消之前的定时器</span>            <span class="type">Long</span> <span class="variable">currentTimer</span> <span class="operator">=</span> timerState.value();            <span class="keyword">if</span> (currentTimer != <span class="literal">null</span>) &#123;                ctx.timerService().deleteEventTimeTimer(currentTimer);            &#125;                        <span class="comment">// 注册新的定时器</span>            <span class="type">Long</span> <span class="variable">newTimer</span> <span class="operator">=</span> currentTime + offlineThreshold.toMilliseconds();            ctx.timerService().registerEventTimeTimer(newTimer);            timerState.update(newTimer);                        out.collect(data);        &#125;                <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTimer</span><span class="params">(<span class="type">long</span> timestamp, OnTimerContext ctx, </span><span class="params">                          Collector&lt;SensorData&gt; out)</span> <span class="keyword">throws</span> Exception &#123;                        <span class="type">Long</span> <span class="variable">lastSeen</span> <span class="operator">=</span> lastSeenTime.value();                        <span class="comment">// 如果最后看到时间加上阈值小于当前时间，说明设备离线</span>            <span class="keyword">if</span> (lastSeen != <span class="literal">null</span> &amp;&amp;                 lastSeen + offlineThreshold.toMilliseconds() &lt;= timestamp) &#123;                                <span class="type">DeviceAlert</span> <span class="variable">alert</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeviceAlert</span>(                    ctx.getCurrentKey(),                    <span class="string">&quot;DEVICE_OFFLINE&quot;</span>,                    <span class="literal">null</span>,                    <span class="literal">null</span>,                    String.format(<span class="string">&quot;设备已离线超过%d分钟&quot;</span>, offlineThreshold.toMinutes()),                    timestamp                );                                ctx.output(alertTag, alert);            &#125;        &#125;    &#125;&#125;</code></pre>]]>
    </content>
    <id>http://example.com/2024/09/10/Flink/</id>
    <link href="http://example.com/2024/09/10/Flink/"/>
    <published>2024-09-10T04:00:00.000Z</published>
    <summary>Apache Flink 是一个开源的分布式流处理和批处理框架，以其低延迟、高吞吐和精确一次（Exactly-Once）语义而闻名。Flink 支持真正的流批一体计算，能够同时处理无界流数据（实时数据）和有界流数据（批处理数据）</summary>
    <title>Flink</title>
    <updated>2026-02-27T09:27:49.610Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="大数据" scheme="http://example.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    <category term="Spark" scheme="http://example.com/tags/Spark/"/>
    <content>
      <![CDATA[<h1 id="湖仓一体delta-lake-iceberg-hudi"><a class="markdownIt-Anchor" href="#湖仓一体delta-lake-iceberg-hudi"></a> 湖仓一体Delta Lake、Iceberg、Hudi</h1><p>最近系统梳理了湖仓一体这块，把 Delta Lake、Iceberg、Hudi、Databricks 的来龙去脉、使用场景、怎么搭建、怎么用都整理了一遍。内容比较长，建议收藏慢慢看。</p><h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>传统大数据架构分两层：数据湖和数据仓库。<br />数据湖（HDFS / S3）的问题是：文件堆在一起，没有事务，没有索引，写一半失败了数据就乱，也没办法改历史数据，查询性能差，治理困难。<br />数据仓库（Hive / Redshift）的问题是：贵，格式封闭，数据要经过 ETL 才能进来，实时性差，灵活度低。<br />湖仓一体（Lakehouse）的思路是：在数据湖的文件存储之上加一层「元数据 + 事务日志」，让数据湖具备数据仓库的能力，同时保留数据湖的低成本和开放性。<br />Delta Lake、Iceberg、Hudi 就是实现这一层的三种开放表格式。</p><h2 id="delta-lake"><a class="markdownIt-Anchor" href="#delta-lake"></a> Delta Lake</h2><h3 id="是什么"><a class="markdownIt-Anchor" href="#是什么"></a> 是什么</h3><p>Databricks 2019 年开源的存储层框架。核心是在 Parquet 文件之上维护一个事务日志目录 <code>_delta_log</code>，所有写操作先记日志，通过日志保证 ACID 事务。</p><pre><code class="highlight plaintext">s3://my-bucket/events/├── _delta_log/              ← 事务日志，Delta 的核心│   ├── 00000000000000000000.json│   ├── 00000000000000000001.json│   └── 00000000000000000002.checkpoint.parquet├── part-00000-xxx.parquet└── part-00001-xxx.parquet</code></pre><h3 id="核心能力"><a class="markdownIt-Anchor" href="#核心能力"></a> 核心能力</h3><p>ACID 事务：多个并发写操作不会互相覆盖，写失败自动回滚。<br />时间旅行（Time Travel）：每次写操作都有版本号，可以查询任意历史版本。</p><pre><code class="highlight sql"><span class="comment">-- 查某个时间点的数据</span><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> events <span class="type">TIMESTAMP</span> <span class="keyword">AS</span> <span class="keyword">OF</span> <span class="string">&#x27;2024-01-01 12:00:00&#x27;</span><span class="comment">-- 查特定版本号</span><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> events VERSION <span class="keyword">AS</span> <span class="keyword">OF</span> <span class="number">5</span><span class="comment">-- 查看历史版本列表</span><span class="keyword">DESCRIBE</span> HISTORY events</code></pre><p>Upsert（MERGE INTO）：支持根据条件更新或插入，传统数据湖做不到这个。</p><pre><code class="highlight sql"><span class="keyword">MERGE</span> <span class="keyword">INTO</span> target t<span class="keyword">USING</span> source s <span class="keyword">ON</span> t.id <span class="operator">=</span> s.id<span class="keyword">WHEN</span> MATCHED <span class="keyword">THEN</span>  <span class="keyword">UPDATE</span> <span class="keyword">SET</span> t.value <span class="operator">=</span> s.value, t.updated_at <span class="operator">=</span> s.updated_at<span class="keyword">WHEN</span> <span class="keyword">NOT</span> MATCHED <span class="keyword">THEN</span>  <span class="keyword">INSERT</span> (id, <span class="keyword">value</span>, updated_at) <span class="keyword">VALUES</span> (s.id, s.value, s.updated_at)</code></pre><p>Schema 演化：表结构变化不用重建表，自动兼容历史数据。<br />小文件合并（OPTIMIZE）：流式写入会产生大量小文件，OPTIMIZE 合并它们提升查询性能。</p><pre><code class="highlight sql">OPTIMIZE eventsZORDER <span class="keyword">BY</span> (user_id, event_time)  <span class="comment">-- Z-Order 索引，加速多维查询</span></code></pre><h3 id="适合什么场景"><a class="markdownIt-Anchor" href="#适合什么场景"></a> 适合什么场景</h3><ul><li>已经在用 Spark / Databricks 的团队，Delta Lake 和 Spark 生态集成最深</li><li>需要频繁 upsert 的场景，比如订单状态更新、用户画像更新</li><li>需要数据审计或者版本回溯的场景</li></ul><h3 id="怎么搭建和使用"><a class="markdownIt-Anchor" href="#怎么搭建和使用"></a> 怎么搭建和使用</h3><p>本地 PySpark 环境：</p><pre><code class="highlight bash">pip install pyspark delta-spark</code></pre><pre><code class="highlight python"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSessionspark = SparkSession.builder \    .appName(<span class="string">&quot;DeltaLake&quot;</span>) \    .config(<span class="string">&quot;spark.jars.packages&quot;</span>, <span class="string">&quot;io.delta:delta-core_2.12:2.4.0&quot;</span>) \    .config(<span class="string">&quot;spark.sql.extensions&quot;</span>, <span class="string">&quot;io.delta.sql.DeltaSparkSessionExtension&quot;</span>) \    .config(<span class="string">&quot;spark.sql.catalog.spark_catalog&quot;</span>, <span class="string">&quot;org.apache.spark.sql.delta.catalog.DeltaCatalog&quot;</span>) \    .getOrCreate()<span class="comment"># 写入 Delta 表，相当于创建</span>df = spark.<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100</span>)df.write.<span class="built_in">format</span>(<span class="string">&quot;delta&quot;</span>).save(<span class="string">&quot;/tmp/delta-table&quot;</span>)<span class="comment"># 读取</span>df2 = spark.read.<span class="built_in">format</span>(<span class="string">&quot;delta&quot;</span>).load(<span class="string">&quot;/tmp/delta-table&quot;</span>)<span class="comment"># 时间旅行</span>df_old = spark.read.<span class="built_in">format</span>(<span class="string">&quot;delta&quot;</span>) \    .option(<span class="string">&quot;versionAsOf&quot;</span>, <span class="number">0</span>) \    .load(<span class="string">&quot;/tmp/delta-table&quot;</span>)    <span class="comment"># 读取上一个版本的表 (版本号 -1) </span>df_v1 = spark.read.<span class="built_in">format</span>(<span class="string">&quot;delta&quot;</span>).option(<span class="string">&quot;versionAsOf&quot;</span>, <span class="number">0</span>).load(<span class="string">&quot;/tmp/my-delta-table&quot;</span>) <span class="comment"># 读取特定时间点的表 (例如，昨天) </span>df_time_travel = spark.read.<span class="built_in">format</span>(<span class="string">&quot;delta&quot;</span>).option(<span class="string">&quot;timestampAsOf&quot;</span>, <span class="string">&quot;2023-10-27 10:00:00&quot;</span>).load(<span class="string">&quot;/tmp/my-delta-table&quot;</span>)</code></pre><p>云上（AWS S3）：</p><pre><code class="highlight python">spark = SparkSession.builder \    .config(<span class="string">&quot;spark.jars.packages&quot;</span>, <span class="string">&quot;io.delta:delta-core_2.12:2.4.0,org.apache.hadoop:hadoop-aws:3.3.4&quot;</span>) \    .config(<span class="string">&quot;spark.hadoop.fs.s3a.access.key&quot;</span>, <span class="string">&quot;YOUR_ACCESS_KEY&quot;</span>) \    .config(<span class="string">&quot;spark.hadoop.fs.s3a.secret.key&quot;</span>, <span class="string">&quot;YOUR_SECRET_KEY&quot;</span>) \    .getOrCreate()df.write.<span class="built_in">format</span>(<span class="string">&quot;delta&quot;</span>).save(<span class="string">&quot;s3a://your-bucket/delta/events&quot;</span>)</code></pre><p>用 SQL 操作：</p><pre><code class="highlight python">spark.sql(<span class="string">&quot;CREATE TABLE events USING DELTA LOCATION &#x27;/tmp/events&#x27;&quot;</span>)spark.sql(<span class="string">&quot;INSERT INTO events VALUES (1, &#x27;click&#x27;, &#x27;2024-01-01&#x27;)&quot;</span>)spark.sql(<span class="string">&quot;UPDATE events SET event_type = &#x27;view&#x27; WHERE id = 1&quot;</span>)spark.sql(<span class="string">&quot;DELETE FROM events WHERE id = 1&quot;</span>)</code></pre><h3 id="kafka流入delta-lake"><a class="markdownIt-Anchor" href="#kafka流入delta-lake"></a> Kafka流入Delta Lake</h3><pre><code class="highlight python"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession<span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> col, from_json, current_timestamp<span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> StructType, StringType, LongType <span class="comment"># 根据你的实际数据调整</span><span class="comment"># --- 1. 初始化 SparkSession ---</span><span class="comment"># 注意：这里必须配置 Delta Lake 相关的扩展和目录</span>spark = SparkSession.builder \    .appName(<span class="string">&quot;KafkaToDeltaLakePipeline&quot;</span>) \    .config(<span class="string">&quot;spark.jars.packages&quot;</span>, <span class="string">&quot;io.delta:delta-core_2.12:2.4.0,org.apache.spark:spark-sql-kafka-0-10_2.12:3.4.0&quot;</span>) \    .config(<span class="string">&quot;spark.sql.extensions&quot;</span>, <span class="string">&quot;io.delta.sql.DeltaSparkSessionExtension&quot;</span>) \    .config(<span class="string">&quot;spark.sql.catalog.spark_catalog&quot;</span>, <span class="string">&quot;org.apache.spark.sql.delta.catalog.DeltaCatalog&quot;</span>) \    .getOrCreate()spark.sparkContext.setLogLevel(<span class="string">&quot;WARN&quot;</span>) <span class="comment"># 减少日志输出</span><span class="comment"># --- 2. 定义数据 Schema ---</span><span class="comment"># 假设 Kafka 中的消息是 JSON 格式的，包含 event_id, user_id, action, timestamp</span>json_schema = StructType() \    .add(<span class="string">&quot;event_id&quot;</span>, StringType()) \    .add(<span class="string">&quot;user_id&quot;</span>, StringType()) \    .add(<span class="string">&quot;action&quot;</span>, StringType()) \    .add(<span class="string">&quot;original_timestamp&quot;</span>, StringType()) <span class="comment"># 假设源数据里有个时间戳</span><span class="comment"># --- 3. 从 Kafka 创建流式 DataFrame ---</span>kafka_brokers = <span class="string">&quot;your_kafka_broker_address:9092&quot;</span> <span class="comment"># 替换为你的 Kafka 地址</span>input_topic = <span class="string">&quot;input-topic&quot;</span>df_kafka = spark \    .readStream \    .<span class="built_in">format</span>(<span class="string">&quot;kafka&quot;</span>) \    .option(<span class="string">&quot;kafka.bootstrap.servers&quot;</span>, kafka_brokers) \    .option(<span class="string">&quot;subscribe&quot;</span>, input_topic) \    .option(<span class="string">&quot;startingOffsets&quot;</span>, <span class="string">&quot;latest&quot;</span>) <span class="comment"># 或 &quot;earliest&quot; # 根据需求选择从哪里开始读</span>    .load()<span class="comment"># --- 4. 解析 Kafka 消息 (value 字段) ---</span><span class="comment"># Kafka 消息的 value 是二进制的，需要转换成字符串，再解析 JSON</span>df_with_json = df_kafka.select(    col(<span class="string">&quot;key&quot;</span>).cast(StringType()), <span class="comment"># 如果需要 key</span>    from_json(col(<span class="string">&quot;value&quot;</span>).cast(StringType()), json_schema).alias(<span class="string">&quot;parsed_value&quot;</span>),    col(<span class="string">&quot;topic&quot;</span>),    col(<span class="string">&quot;partition&quot;</span>),    col(<span class="string">&quot;offset&quot;</span>),    current_timestamp().alias(<span class="string">&quot;processing_time&quot;</span>) <span class="comment"># 添加 Spark 处理的时间</span>)<span class="comment"># 展开解析后的结构体字段</span>df_events = df_with_json.select(    col(<span class="string">&quot;parsed_value.event_id&quot;</span>),    col(<span class="string">&quot;parsed_value.user_id&quot;</span>),    col(<span class="string">&quot;parsed_value.action&quot;</span>),    col(<span class="string">&quot;parsed_value.original_timestamp&quot;</span>),    col(<span class="string">&quot;processing_time&quot;</span>),    col(<span class="string">&quot;topic&quot;</span>),    col(<span class="string">&quot;partition&quot;</span>),    col(<span class="string">&quot;offset&quot;</span>))<span class="comment"># --- 5. (可选) 数据转换 ---</span><span class="comment"># 在这里可以进行各种 ETL 操作，比如过滤、聚合、Join 等</span><span class="comment"># 示例：过滤掉空的 event_id</span>df_processed = df_events.<span class="built_in">filter</span>(col(<span class="string">&quot;event_id&quot;</span>).isNotNull())<span class="comment"># --- 6. 将处理后的数据流写入 Delta Lake ---</span>output_path = <span class="string">&quot;/path/to/delta/events_table&quot;</span> <span class="comment"># 替换为你的实际路径</span><span class="comment"># 使用 foreachBatch 写入 Delta Table 是推荐方式，因为它能更好地处理事务</span><span class="keyword">def</span> <span class="title function_">write_to_delta</span>(<span class="params">batch_df, batch_id</span>):    <span class="string">&quot;&quot;&quot;</span><span class="string">    这个函数会在每个微批次 (micro-batch) 结束时被调用</span><span class="string">    batch_df: 当前批次的 DataFrame</span><span class="string">    batch_id: 批次的唯一 ID</span><span class="string">    &quot;&quot;&quot;</span>    <span class="built_in">print</span>(<span class="string">f&quot;Writing batch <span class="subst">&#123;batch_id&#125;</span> with <span class="subst">&#123;batch_df.count()&#125;</span> records to Delta...&quot;</span>)    <span class="comment"># mode(&quot;append&quot;) 表示追加数据</span>    <span class="comment"># format(&quot;delta&quot;) 指定格式</span>    batch_df.write \             .<span class="built_in">format</span>(<span class="string">&quot;delta&quot;</span>) \             .mode(<span class="string">&quot;append&quot;</span>) \             .save(output_path) <span class="comment"># 可以选择 saveAsTable(&quot;db.table_name&quot;) 如果使用 Hive Metastore</span>    <span class="built_in">print</span>(<span class="string">f&quot;Successfully wrote batch <span class="subst">&#123;batch_id&#125;</span>&quot;</span>)query = df_processed.writeStream \    .foreachBatch(write_to_delta) \    .option(<span class="string">&quot;checkpointLocation&quot;</span>, <span class="string">&quot;/path/to/checkpoint/dir/events_pipeline&quot;</span>) \    .trigger(processingTime=<span class="string">&#x27;10 seconds&#x27;</span>) \    .start()<span class="comment"># 等待查询结束 (通常是手动停止)</span>query.awaitTermination()</code></pre><h3 id="下游消费数据"><a class="markdownIt-Anchor" href="#下游消费数据"></a> 下游消费数据</h3><h4 id="批处理查询"><a class="markdownIt-Anchor" href="#批处理查询"></a> 批处理查询</h4><pre><code class="highlight py"><span class="comment"># 查询最新的所有数据</span>latest_df = spark.read.<span class="built_in">format</span>(<span class="string">&quot;delta&quot;</span>).load(<span class="string">&quot;/path/to/delta/events_table&quot;</span>)latest_df.show()<span class="comment"># 查询特定条件的数据</span>recent_user_actions = spark.read.<span class="built_in">format</span>(<span class="string">&quot;delta&quot;</span>).load(<span class="string">&quot;/path/to/delta/events_table&quot;</span>) \                               .<span class="built_in">filter</span>(col(<span class="string">&quot;user_id&quot;</span>) == <span class="string">&quot;some_user_id&quot;</span>) \                               .orderBy(col(<span class="string">&quot;original_timestamp&quot;</span>))recent_user_actions.show()</code></pre><h4 id="流式消费"><a class="markdownIt-Anchor" href="#流式消费"></a> 流式消费</h4><pre><code class="highlight py"><span class="comment"># --- 下游流式消费者 ---</span><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession<span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> colspark_downstream = SparkSession.builder \    .appName(<span class="string">&quot;DownstreamDeltaConsumer&quot;</span>) \    .config(<span class="string">&quot;spark.jars.packages&quot;</span>, <span class="string">&quot;io.delta:delta-core_2.12:2.4.0&quot;</span>) \    .config(<span class="string">&quot;spark.sql.extensions&quot;</span>, <span class="string">&quot;io.delta.sql.DeltaSparkSessionExtension&quot;</span>) \    .config(<span class="string">&quot;spark.sql.catalog.spark_catalog&quot;</span>, <span class="string">&quot;org.apache.spark.sql.delta.catalog.DeltaCatalog&quot;</span>) \    .getOrCreate()<span class="comment"># 从 Delta 表创建一个流式 DataFrame</span>df_from_delta_stream = spark_downstream \    .readStream \    .<span class="built_in">format</span>(<span class="string">&quot;delta&quot;</span>) \    .option(<span class="string">&quot;path&quot;</span>, <span class="string">&quot;/path/to/delta/events_table&quot;</span>) \    .load()<span class="comment"># 对流进行处理，例如，只关心特定用户的动作</span>filtered_stream = df_from_delta_stream.<span class="built_in">filter</span>(col(<span class="string">&quot;user_id&quot;</span>).startswith(<span class="string">&quot;VIP&quot;</span>))<span class="comment"># 将结果写入另一个 Kafka Topic 或打印出来</span>query_downstream = filtered_stream \    .select(<span class="string">&quot;user_id&quot;</span>, <span class="string">&quot;action&quot;</span>, <span class="string">&quot;processing_time&quot;</span>) \    .writeStream \    .outputMode(<span class="string">&quot;append&quot;</span>) \    .<span class="built_in">format</span>(<span class="string">&quot;console&quot;</span>) \    .option(<span class="string">&quot;truncate&quot;</span>, <span class="literal">False</span>) \    .trigger(processingTime=<span class="string">&#x27;5 seconds&#x27;</span>) \    .start()query_downstream.awaitTermination()</code></pre><hr /><h2 id="apache-iceberg"><a class="markdownIt-Anchor" href="#apache-iceberg"></a> Apache Iceberg</h2><h3 id="是什么-2"><a class="markdownIt-Anchor" href="#是什么-2"></a> 是什么</h3><p>Netflix 2018 年开发，后捐给 Apache 基金会。解决的核心问题和 Delta Lake 类似，但设计理念更偏向引擎无关和大规模数据管理。</p><p>Apache Iceberg 是一个开源的高性能表格式（Table Format），专为分析型数据湖设计。它提供了一个结构化的元数据层，将数据文件的物理存储与逻辑表结构解耦，从而实现了强大的功能，如 ACID 事务、隐藏分区、模式演进和高效的数据管理。</p><p>Iceberg 把表的元数据设计成树形结构：</p><pre><code class="highlight plaintext">catalog（目录）  └── metadata.json（当前快照指针）        └── snapshot（快照，每次写操作一个）              └── manifest list（清单列表）                    └── manifest file（记录数据文件信息）                          └── data files（实际 Parquet / ORC 文件）</code></pre><p>这个树形设计让元数据操作（比如列出所有文件）变得非常高效，不需要扫描整个目录，百亿级文件的表也能快速管理。</p><h3 id="比-delta-lake-多的特性"><a class="markdownIt-Anchor" href="#比-delta-lake-多的特性"></a> 比 Delta Lake 多的特性</h3><p>隐藏分区（Hidden Partitioning）：查询时不需要在 SQL 里写分区过滤条件，Iceberg 自动把时间函数映射到分区，减少了大量人为错误。</p><pre><code class="highlight sql"><span class="comment">-- 建表时定义分区转换</span><span class="keyword">CREATE TABLE</span> orders (    order_id <span class="type">BIGINT</span>,    customer_id <span class="type">BIGINT</span>,    order_time <span class="type">TIMESTAMP</span>,    amount <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>)) <span class="keyword">USING</span> icebergPARTITIONED <span class="keyword">BY</span> (days(order_time))<span class="comment">-- 查询时直接写时间条件，不需要手动写分区字段</span><span class="comment">-- Iceberg 自动知道去哪个分区找</span><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_time <span class="operator">&gt;=</span> <span class="string">&#x27;2024-01-01&#x27;</span></code></pre><p>分区演化（Partition Evolution）：分区策略可以随时修改，历史数据不需要重写。</p><pre><code class="highlight sql"><span class="comment">-- 业务增长后，从按天分区改为按小时，历史数据不动</span><span class="keyword">ALTER TABLE</span> orders REPLACE <span class="keyword">PARTITION</span> FIELD days(order_time) <span class="keyword">WITH</span> hours(order_time)</code></pre><p>多引擎支持：这是 Iceberg 最大的优势，同一张表可以被不同引擎同时读写，不和任何一个框架绑定。</p><pre><code class="highlight plaintext">Flink（实时写入）       ↓  Iceberg 表（S3/OSS）   ↑           ↑          ↑Spark(ETL)  Trino(BI)  Hive(兼容)</code></pre><h3 id="适合什么场景-2"><a class="markdownIt-Anchor" href="#适合什么场景-2"></a> 适合什么场景</h3><ul><li>多引擎混用的数据平台，Flink 写、Spark 处理、Trino 查</li><li>数据量极大、需要精细分区管理的场景</li><li>想避免被云厂商绑定，追求开放标准的团队</li><li>国内上云项目，阿里云、腾讯云对 Iceberg 支持最好</li></ul><h3 id="怎么搭建和使用-2"><a class="markdownIt-Anchor" href="#怎么搭建和使用-2"></a> 怎么搭建和使用</h3><p>Spark + Iceberg：</p><pre><code class="highlight python"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSessionspark = SparkSession.builder \    .config(<span class="string">&quot;spark.jars.packages&quot;</span>, <span class="string">&quot;org.apache.iceberg:iceberg-spark-runtime-3.4_2.12:1.4.0&quot;</span>) \    .config(<span class="string">&quot;spark.sql.extensions&quot;</span>, <span class="string">&quot;org.apache.iceberg.spark.extensions.IcebergSparkSessionExtensions&quot;</span>) \    .config(<span class="string">&quot;spark.sql.catalog.local&quot;</span>, <span class="string">&quot;org.apache.iceberg.spark.SparkCatalog&quot;</span>) \    .config(<span class="string">&quot;spark.sql.catalog.local.type&quot;</span>, <span class="string">&quot;hadoop&quot;</span>) \    .config(<span class="string">&quot;spark.sql.catalog.local.warehouse&quot;</span>, <span class="string">&quot;/tmp/iceberg-warehouse&quot;</span>) \    .getOrCreate()<span class="comment"># 建表</span>spark.sql(<span class="string">&quot;&quot;&quot;</span><span class="string">    CREATE TABLE local.db.events (</span><span class="string">        id BIGINT,</span><span class="string">        event_type STRING,</span><span class="string">        user_id BIGINT,</span><span class="string">        event_time TIMESTAMP</span><span class="string">    ) USING iceberg</span><span class="string">    PARTITIONED BY (days(event_time))</span><span class="string">&quot;&quot;&quot;</span>)<span class="comment"># 写数据</span>spark.sql(<span class="string">&quot;INSERT INTO local.db.events VALUES (1, &#x27;click&#x27;, 100, current_timestamp())&quot;</span>)<span class="comment"># 查询快照历史</span>spark.sql(<span class="string">&quot;SELECT * FROM local.db.events.snapshots&quot;</span>).show()<span class="comment"># 时间旅行</span>spark.sql(<span class="string">&quot;SELECT * FROM local.db.events TIMESTAMP AS OF &#x27;2024-01-01 00:00:00&#x27;&quot;</span>)<span class="comment"># 查看数据文件分布</span>spark.sql(<span class="string">&quot;SELECT * FROM local.db.events.files&quot;</span>).show()</code></pre><p>Flink + Iceberg 实时写入：</p><pre><code class="highlight java"><span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();<span class="type">StreamTableEnvironment</span> <span class="variable">tableEnv</span> <span class="operator">=</span> StreamTableEnvironment.create(env);<span class="comment">// 注册 Iceberg catalog</span>tableEnv.executeSql(    <span class="string">&quot;CREATE CATALOG iceberg_catalog WITH (&quot;</span> +    <span class="string">&quot;&#x27;type&#x27;=&#x27;iceberg&#x27;,&quot;</span> +    <span class="string">&quot;&#x27;catalog-type&#x27;=&#x27;hadoop&#x27;,&quot;</span> +    <span class="string">&quot;&#x27;warehouse&#x27;=&#x27;s3://your-bucket/warehouse&#x27;&quot;</span> +    <span class="string">&quot;)&quot;</span>);<span class="comment">// 建目标表</span>tableEnv.executeSql(    <span class="string">&quot;CREATE TABLE IF NOT EXISTS iceberg_catalog.db.events (&quot;</span> +    <span class="string">&quot;id BIGINT, event_type STRING, event_time TIMESTAMP(3)&quot;</span> +    <span class="string">&quot;) PARTITIONED BY (days(event_time))&quot;</span>);<span class="comment">// Kafka source 实时写入 Iceberg</span>tableEnv.executeSql(<span class="string">&quot;INSERT INTO iceberg_catalog.db.events SELECT * FROM kafka_source&quot;</span>);</code></pre><hr /><h2 id="apache-hudi"><a class="markdownIt-Anchor" href="#apache-hudi"></a> Apache Hudi</h2><h3 id="是什么-3"><a class="markdownIt-Anchor" href="#是什么-3"></a> 是什么</h3><p>Uber 2016 年开发，Hadoop Upsert Delete and Incremental 的缩写，专门为增量数据处理设计。<br />Hudi 的核心场景是 CDC（Change Data Capture）：把 MySQL / PostgreSQL 的增删改实时同步到数据湖，保持数据湖和数据库的一致性。</p><p>Apache Hudi (Hadoop Upserts Deletes and Incrementals) 是一个开源的数据湖框架，旨在简化增量数据处理和数据管道的管理。它通过提供 upserts（插入/更新）、deletes（删除）、change streams（变更流）、原子性提交和数据版本控制等核心功能，使数据湖具备了近似实时的能力。</p><p><strong>特点</strong></p><ol><li>增量数据摄取 (Incremental Data Ingestion): Hudi 的核心优势之一是能够高效地处理增量数据。它只处理自上次写入以来发生更改的部分，而不是全量重写，这大大提高了效率。</li><li>Upserts (插入/更新) 和 Deletes (删除): 原生支持基于主键的 upsert 操作（如果记录存在则更新，否则插入）和 delete 操作，这对于维护数据准确性至关重要。</li><li>两种表类型:<ol><li>Copy-on-Write (COW): 写时复制。每次写入都会生成新的文件版本，旧版本文件保留。适合读多写少的场景，提供更好的读性能，因为读取时不需要合并操作。</li><li>Merge-on-Read (MOR): 读时合并。写入时会将增量数据（deltalog files）快速追加到基础文件（base files）旁。读取时可以选择返回最新快照（需要合并）或仅基础文件数据。适合写多读少、对写入延迟要求高的场景。</li></ol></li><li>数据版本控制 (Timeline): Hudi 维护一个时间轴（Timeline），记录了所有在表上执行的操作（如 commits, cleanups, rollbacks 等），支持数据回滚和时间旅行查询。</li><li>可插拔索引 (Pluggable Indexing): 为了快速定位记录所在的文件，Hudi 支持多种索引机制（如 Bloom Filter, HBase, Global BLOOM, etc.），这对于 upsert 性能至关重要。</li><li>原子性与并发控制 (Atomicity &amp; Concurrency Control): 所有写入操作都是原子性的，要么完全成功，要么完全失败。Hudi 还支持乐观并发控制，允许多个写入器同时写入同一张表。</li><li>流式处理支持: 可以与 Spark Streaming、Flink 等流处理引擎集成，支持流式数据的摄取和查询。</li></ol><h3 id="两种存储类型"><a class="markdownIt-Anchor" href="#两种存储类型"></a> 两种存储类型</h3><p>COW（Copy On Write，写时复制）：写入时直接复写 Parquet 文件，读性能好，但写入较慢，适合读多写少的场景。<br />MOR（Merge On Read，读时合并）：写入时先写增量日志文件（.log），定期合并到 Parquet，写入极快，读时需要合并，适合高频写入的场景。</p><pre><code class="highlight plaintext">MOR 表文件结构：base_file_20240101.parquet    ← 基础文件（快照）.20240101_delta_1.log         ← 增量日志 1.20240101_delta_2.log         ← 增量日志 2读取时：base + delta1 + delta2 合并后返回最新数据</code></pre><h3 id="核心特性"><a class="markdownIt-Anchor" href="#核心特性"></a> 核心特性</h3><p>增量查询（Incremental Query）：只查某个时间点之后变化的数据，不用全表扫，ETL 效率极高。</p><pre><code class="highlight python"><span class="comment"># 只读取过去 1 小时变化的数据</span>incremental_df = spark.read.<span class="built_in">format</span>(<span class="string">&quot;hudi&quot;</span>) \    .option(<span class="string">&quot;hoodie.datasource.query.type&quot;</span>, <span class="string">&quot;incremental&quot;</span>) \    .option(<span class="string">&quot;hoodie.datasource.read.begin.instanttime&quot;</span>, <span class="string">&quot;20240101120000&quot;</span>) \    .load(<span class="string">&quot;/path/to/hudi-table&quot;</span>)</code></pre><h3 id="经典-cdc-入湖架构"><a class="markdownIt-Anchor" href="#经典-cdc-入湖架构"></a> 经典 CDC 入湖架构</h3><pre><code class="highlight plaintext">MySQL（业务数据库）  ↓ Debezium（捕获 binlog 变更）Kafka（消息队列）  ↓ Flink（实时消费处理）Hudi 表（MOR 模式，毫秒级入湖）  ↓ 定期 Compaction（合并小文件）Parquet 文件（供 Spark / Hive 分析查询）</code></pre><h3 id="怎么搭建和使用-3"><a class="markdownIt-Anchor" href="#怎么搭建和使用-3"></a> 怎么搭建和使用</h3><p>Spark 写入 Hudi：</p><pre><code class="highlight python"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSessionspark = SparkSession.builder \    .config(<span class="string">&quot;spark.jars.packages&quot;</span>, <span class="string">&quot;org.apache.hudi:hudi-spark3.4-bundle_2.12:0.14.0&quot;</span>) \    .config(<span class="string">&quot;spark.serializer&quot;</span>, <span class="string">&quot;org.apache.spark.serializer.KryoSerializer&quot;</span>) \    .getOrCreate()data = [(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">25</span>, <span class="string">&quot;2024-01-01&quot;</span>), (<span class="number">2</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">30</span>, <span class="string">&quot;2024-01-01&quot;</span>)]df = spark.createDataFrame(data, [<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;ts&quot;</span>])hudi_options = &#123;    <span class="string">&quot;hoodie.table.name&quot;</span>: <span class="string">&quot;users&quot;</span>,    <span class="string">&quot;hoodie.datasource.write.recordkey.field&quot;</span>: <span class="string">&quot;id&quot;</span>,        <span class="comment"># 主键</span>    <span class="string">&quot;hoodie.datasource.write.precombine.field&quot;</span>: <span class="string">&quot;ts&quot;</span>,        <span class="comment"># 去重时间戳</span>    <span class="string">&quot;hoodie.datasource.write.operation&quot;</span>: <span class="string">&quot;upsert&quot;</span>,    <span class="string">&quot;hoodie.datasource.write.table.type&quot;</span>: <span class="string">&quot;COPY_ON_WRITE&quot;</span>,&#125;<span class="comment"># 初次写入</span>df.write.<span class="built_in">format</span>(<span class="string">&quot;hudi&quot;</span>).options(**hudi_options).mode(<span class="string">&quot;append&quot;</span>).save(<span class="string">&quot;/tmp/hudi/users&quot;</span>)<span class="comment"># upsert：id=1 已存在则更新，不存在则插入</span>update_data = [(<span class="number">1</span>, <span class="string">&quot;张三新名字&quot;</span>, <span class="number">26</span>, <span class="string">&quot;2024-01-02&quot;</span>)]update_df = spark.createDataFrame(update_data, [<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;ts&quot;</span>])update_df.write.<span class="built_in">format</span>(<span class="string">&quot;hudi&quot;</span>).options(**hudi_options).mode(<span class="string">&quot;append&quot;</span>).save(<span class="string">&quot;/tmp/hudi/users&quot;</span>)<span class="comment"># 读取最新数据</span>spark.read.<span class="built_in">format</span>(<span class="string">&quot;hudi&quot;</span>).load(<span class="string">&quot;/tmp/hudi/users&quot;</span>).show()<span class="comment"># 增量读取（只读 2024-01-02 之后的变更）</span>spark.read.<span class="built_in">format</span>(<span class="string">&quot;hudi&quot;</span>) \    .option(<span class="string">&quot;hoodie.datasource.query.type&quot;</span>, <span class="string">&quot;incremental&quot;</span>) \    .option(<span class="string">&quot;hoodie.datasource.read.begin.instanttime&quot;</span>, <span class="string">&quot;20240102000000&quot;</span>) \    .load(<span class="string">&quot;/tmp/hudi/users&quot;</span>).show()</code></pre><h2 id="三者横向对比"><a class="markdownIt-Anchor" href="#三者横向对比"></a> 三者横向对比</h2><table><thead><tr><th>对比项</th><th>Delta Lake</th><th>Iceberg</th><th>Hudi</th></tr></thead><tbody><tr><td>发起方</td><td>Databricks</td><td>Netflix</td><td>Uber</td></tr><tr><td>开源时间</td><td>2019</td><td>2018</td><td>2016</td></tr><tr><td>最强场景</td><td>Spark 生态、upsert</td><td>多引擎兼容</td><td>CDC 增量同步</td></tr><tr><td>引擎支持</td><td>Spark 最佳</td><td>全引擎</td><td>Spark / Flink</td></tr><tr><td>分区管理</td><td>手动</td><td>隐藏分区（自动）</td><td>手动</td></tr><tr><td>国内云支持</td><td>一般</td><td>最好</td><td>支持</td></tr><tr><td>社区活跃度</td><td>高</td><td>最高（上升最快）</td><td>中</td></tr><tr><td>学习难度</td><td>低</td><td>中</td><td>中</td></tr><tr><td>选型建议：</td><td></td><td></td><td></td></tr></tbody></table><ul><li>已经在用 Databricks / Spark，直接用 Delta Lake，生态最完整</li><li>新建数据平台、需要多引擎，优先选 Iceberg，社区趋势最明显</li><li>核心场景是 MySQL 实时同步入湖，选 Hudi</li><li>实在纠结，Iceberg 现在是最安全的选择，云厂商和社区都在重点投入</li></ul><hr /><h2 id="完整数据链路架构"><a class="markdownIt-Anchor" href="#完整数据链路架构"></a> 完整数据链路架构</h2><p>把上面所有东西串起来，一个典型的现代数据湖架构长这样：</p><pre><code class="highlight plaintext">数据源层MySQL / PostgreSQL / 日志文件 / 埋点数据        ↓                    ↓  CDC（Debezium）         批量导入 / 实时埋点        ↓                    ↓消息队列层：Kafka（缓冲 + 解耦）        ↓ Flink（实时）  ↓ Spark（批量）存储层（湖仓）Iceberg / Delta Lake / Hudi存储在 HDFS / S3 / OSS        ↓ Spark SQL  ↓ Trino  ↓ Hive计算层数仓分层：ODS → DWD → DWS → ADS        ↓应用层BI 报表 / 机器学习 / 数据 API</code></pre>]]>
    </content>
    <id>http://example.com/2024/08/02/lakehouse/</id>
    <link href="http://example.com/2024/08/02/lakehouse/"/>
    <published>2024-08-02T04:00:00.000Z</published>
    <summary>湖仓一体（Lakehouse）的思路是：在数据湖的文件存储之上加一层「元数据 + 事务日志」，让数据湖具备数据仓库的能力，同时保留数据湖的低成本和开放性。Delta Lake、Iceberg、Hudi 就是实现这一层的三种开放表格式。</summary>
    <title>湖仓一体Delta Lake、Iceberg、Hudi</title>
    <updated>2026-02-27T08:54:36.209Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Go" scheme="http://example.com/tags/Go/"/>
    <content>
      <![CDATA[<h1 id="go"><a class="markdownIt-Anchor" href="#go"></a> Go</h1><p>最近在系统整理 Go 的知识，顺手写成文章。有 Java 基础的话上手会很快，语法比 Java 精简不少，但有几个地方思维要转换一下，后面会重点说。</p><h2 id="环境搭建"><a class="markdownIt-Anchor" href="#环境搭建"></a> 环境搭建</h2><p>安装没什么好说的，三个平台都支持。</p><pre><code class="highlight bash"><span class="comment"># Mac</span>brew install go<span class="comment"># Linux</span>wget https://go.dev/dl/go1.22.linux-amd64.tar.gztar -C /usr/local -xzf go1.22.linux-amd64.tar.gz<span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/go/bin<span class="comment"># 验证</span>go version</code></pre><p>编辑器推荐 VS Code 装 Go 插件，免费够用。如果你用惯了 JetBrains 系列，GoLand 也行，界面和 IDEA 基本一样。<br />跑个 Hello World 试试：</p><pre><code class="highlight go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    fmt.Println(<span class="string">&quot;Hello, Go!&quot;</span>)&#125;</code></pre><pre><code class="highlight bash">go run hello.go    <span class="comment"># 开发时直接跑</span>go build hello.go  <span class="comment"># 编译成二进制，发布用这个</span></code></pre><p><code>go run</code> 背后也是先编译再执行，只是不保留编译产物。平时开发用 <code>go run</code> 方便，上线打包用 <code>go build</code>。</p><h2 id="基础语法"><a class="markdownIt-Anchor" href="#基础语法"></a> 基础语法</h2><h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3><p>Go 变量声明有几种写法，最常用的是 <code>:=</code>，编译器自动推断类型，不用像 Java 那样每次都写类型名。</p><pre><code class="highlight go"><span class="comment">// 标准写法</span><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;张三&quot;</span><span class="keyword">var</span> age <span class="type">int</span> = <span class="number">25</span><span class="comment">// 类型推断</span><span class="keyword">var</span> city = <span class="string">&quot;北京&quot;</span><span class="comment">// 短变量声明，最常用，只能在函数内部用</span>score := <span class="number">99.5</span>isActive := <span class="literal">true</span><span class="comment">// 多变量一起声明</span>a, b, c := <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></code></pre><p>注意 <code>:=</code> 只能在函数里用，包级别的变量必须用 <code>var</code>。Go 还有一个规则：声明了的变量必须使用，否则编译不过。这个设计强迫你不留垃圾变量，代码整洁很多。</p><h3 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h3><p>日常用得最多的就是 <code>int</code>、<code>float64</code>、<code>string</code>、<code>bool</code> 这几个，Go 的数字类型要指定位数，不像 Java 有默认的 int/long。</p><pre><code class="highlight go"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">10</span><span class="keyword">var</span> i8 <span class="type">int8</span> = <span class="number">127</span>      <span class="comment">// -128 ~ 127</span><span class="keyword">var</span> i64 <span class="type">int64</span> = <span class="number">9999999</span><span class="comment">// 浮点推荐用 float64，精度更高</span><span class="keyword">var</span> f64 <span class="type">float64</span> = <span class="number">3.1415926</span><span class="comment">// 反引号可以写多行字符串，不用转义</span>s2 := <span class="string">`第一行</span><span class="string">第二行`</span><span class="keyword">var</span> b <span class="type">bool</span> = <span class="literal">true</span><span class="comment">// byte 是 uint8 的别名，处理字节数据时会用到</span><span class="keyword">var</span> by <span class="type">byte</span> = <span class="string">&#x27;A&#x27;</span></code></pre><p>Go 没有隐式类型转换，不同类型必须显式转换，不然编译报错。这点比 Java 严格。</p><pre><code class="highlight go"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">42</span><span class="keyword">var</span> f <span class="type">float64</span> = <span class="type">float64</span>(i)  <span class="comment">// 必须显式转换</span><span class="keyword">var</span> u <span class="type">uint</span> = <span class="type">uint</span>(f)</code></pre><h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h3><p>Go 函数最有意思的地方是支持多返回值，这在 Java 里要么用对象包装，要么抛异常，Go 直接返回两个值就解决了。</p><pre><code class="highlight go"><span class="comment">// 参数类型写在变量名后面，和 Java 顺序相反</span><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;    <span class="keyword">return</span> a + b&#125;<span class="comment">// 多返回值，一般把 error 放最后</span><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(a, b <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;    <span class="keyword">if</span> b == <span class="number">0</span> &#123;        <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;除数不能为0&quot;</span>)    &#125;    <span class="keyword">return</span> a / b, <span class="literal">nil</span>  <span class="comment">// nil 表示没有错误</span>&#125;<span class="comment">// 调用时两个返回值都要接</span>result, err := divide(<span class="number">10</span>, <span class="number">3</span>)<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;    fmt.Println(<span class="string">&quot;错误:&quot;</span>, err)    <span class="keyword">return</span>&#125;fmt.Println(result)<span class="comment">// 可变参数，... 接受任意数量的同类型参数</span><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;    total := <span class="number">0</span>    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;        total += n    &#125;    <span class="keyword">return</span> total&#125;</code></pre><p>Go 还支持<strong>命名返回值</strong>，把返回值提前在函数签名里命名，然后裸 return，代码简洁但可读性要看情况，不滥用。</p><pre><code class="highlight go"><span class="function"><span class="keyword">func</span> <span class="title">minMax</span><span class="params">(nums []<span class="type">int</span>)</span></span> (min, max <span class="type">int</span>) &#123;    min, max = nums[<span class="number">0</span>], nums[<span class="number">0</span>]    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums[<span class="number">1</span>:] &#123;        <span class="keyword">if</span> n &lt; min &#123; min = n &#125;        <span class="keyword">if</span> n &gt; max &#123; max = n &#125;    &#125;    <span class="keyword">return</span>  <span class="comment">// 裸 return，返回已命名的 min 和 max</span>&#125;</code></pre><h3 id="流程控制"><a class="markdownIt-Anchor" href="#流程控制"></a> 流程控制</h3><p>if 和 switch 的条件不用加括号，这点和 Java 不一样。Go 只有 <code>for</code> 循环，没有 <code>while</code>，但可以用 for 模拟。</p><pre><code class="highlight go"><span class="comment">// if 不加括号</span><span class="keyword">if</span> age &gt;= <span class="number">18</span> &#123;    fmt.Println(<span class="string">&quot;成年&quot;</span>)&#125; <span class="keyword">else</span> <span class="keyword">if</span> age &gt;= <span class="number">12</span> &#123;    fmt.Println(<span class="string">&quot;青少年&quot;</span>)&#125; <span class="keyword">else</span> &#123;    fmt.Println(<span class="string">&quot;儿童&quot;</span>)&#125;<span class="comment">// if 里可以带一个初始化语句，score 的作用域只在这个 if 块里</span><span class="keyword">if</span> score := getScore(); score &gt;= <span class="number">60</span> &#123;    fmt.Println(<span class="string">&quot;及格&quot;</span>)&#125;<span class="comment">// 普通 for</span><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;    fmt.Println(i)&#125;<span class="comment">// 模拟 while</span>n := <span class="number">0</span><span class="keyword">for</span> n &lt; <span class="number">5</span> &#123;    n++&#125;<span class="comment">// 无限循环</span><span class="keyword">for</span> &#123;    <span class="comment">// break 退出</span>&#125;<span class="comment">// switch 不需要写 break，每个 case 执行完自动退出</span><span class="keyword">switch</span> day &#123;<span class="keyword">case</span> <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>:    fmt.Println(<span class="string">&quot;工作日&quot;</span>)<span class="keyword">case</span> <span class="string">&quot;Saturday&quot;</span>, <span class="string">&quot;Sunday&quot;</span>:    fmt.Println(<span class="string">&quot;周末&quot;</span>)<span class="keyword">default</span>:    fmt.Println(<span class="string">&quot;其他&quot;</span>)&#125;</code></pre><p>switch 还有一种不带条件的写法，等价于 if-else if 链，有时候更清晰：</p><pre><code class="highlight go"><span class="keyword">switch</span> &#123;<span class="keyword">case</span> score &gt;= <span class="number">90</span>:    fmt.Println(<span class="string">&quot;优秀&quot;</span>)<span class="keyword">case</span> score &gt;= <span class="number">60</span>:    fmt.Println(<span class="string">&quot;及格&quot;</span>)<span class="keyword">default</span>:    fmt.Println(<span class="string">&quot;不及格&quot;</span>)&#125;</code></pre><h3 id="defer"><a class="markdownIt-Anchor" href="#defer"></a> defer</h3><p><code>defer</code> 是 Go 里一个很有特色的关键字，作用是把一个函数调用推迟到当前函数返回前执行。不管函数是正常返回还是 panic，defer 都会执行，所以常用来做资源清理。</p><pre><code class="highlight go"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(path <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;    f, err := os.Open(path)    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;        <span class="keyword">return</span> err    &#125;    <span class="keyword">defer</span> f.Close()  <span class="comment">// 不管后面怎么返回，文件一定会关闭</span>    <span class="comment">// 读文件操作...</span>    <span class="keyword">return</span> <span class="literal">nil</span>&#125;</code></pre><p>多个 defer 按<strong>后进先出</strong>的顺序执行，类似栈。</p><pre><code class="highlight go"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;第三个执行&quot;</span>)    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;第二个执行&quot;</span>)    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;第一个执行&quot;</span>)    fmt.Println(<span class="string">&quot;函数体&quot;</span>)&#125;<span class="comment">// 输出顺序：函数体 → 第一个执行 → 第二个执行 → 第三个执行</span></code></pre><h3 id="panic-和-recover"><a class="markdownIt-Anchor" href="#panic-和-recover"></a> panic 和 recover</h3><p>Go 没有 try-catch，但有 <code>panic</code> 和 <code>recover</code>。<code>panic</code> 相当于抛出一个不可恢复的错误，程序会中断；<code>recover</code> 只能在 defer 里调用，用来捕获 panic，防止程序崩溃。<br />一般来说，业务代码里用 error 返回值处理可预期的错误，panic 留给真正的程序异常（比如数组越界、nil 指针）。</p><pre><code class="highlight go"><span class="function"><span class="keyword">func</span> <span class="title">safeDivide</span><span class="params">(a, b <span class="type">int</span>)</span></span> (result <span class="type">int</span>, err <span class="type">error</span>) &#123;    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;            err = fmt.Errorf(<span class="string">&quot;捕获到 panic: %v&quot;</span>, r)        &#125;    &#125;()    <span class="keyword">if</span> b == <span class="number">0</span> &#123;        <span class="built_in">panic</span>(<span class="string">&quot;除数为零&quot;</span>)  <span class="comment">// 触发 panic</span>    &#125;    <span class="keyword">return</span> a / b, <span class="literal">nil</span>&#125;result, err := safeDivide(<span class="number">10</span>, <span class="number">0</span>)<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;    fmt.Println(err)  <span class="comment">// 输出：捕获到 panic: 除数为零</span>&#125;</code></pre><p>Web 框架比如 Gin，默认的 Recovery 中间件就是用这个原理防止某个请求的 panic 把整个服务搞挂。</p><h2 id="复合数据类型"><a class="markdownIt-Anchor" href="#复合数据类型"></a> 复合数据类型</h2><h3 id="切片slice"><a class="markdownIt-Anchor" href="#切片slice"></a> 切片（Slice）</h3><p>Go 里数组用得很少，因为长度固定。实际开发几乎都用切片，可以理解成 Java 的 <code>ArrayList</code>，动态长度。</p><pre><code class="highlight go"><span class="comment">// 数组，长度固定，基本不用</span>arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;<span class="comment">// 切片，长度可变</span>nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;<span class="comment">// 追加元素，注意结果要重新赋值给原变量，这是个容易漏掉的点</span>nums = <span class="built_in">append</span>(nums, <span class="number">6</span>, <span class="number">7</span>)<span class="comment">// 切片操作，左闭右开</span>sub := nums[<span class="number">1</span>:<span class="number">4</span>]   <span class="comment">// [2, 3, 4]</span>head := nums[:<span class="number">3</span>]   <span class="comment">// [1, 2, 3]</span>tail := nums[<span class="number">3</span>:]   <span class="comment">// [4, 5, 6, 7]</span><span class="comment">// make 创建切片，第二个参数是长度，第三个是容量</span>s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">10</span>)<span class="comment">// range 遍历</span><span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;    fmt.Printf(<span class="string">&quot;索引:%d 值:%d\n&quot;</span>, i, v)&#125;</code></pre><p><strong>切片的底层原理值得搞清楚</strong>，不然会踩坑。切片本质上是一个结构体，包含三个字段：指向底层数组的指针、长度（len）、容量（cap）。</p><pre><code class="highlight plaintext">slice = &#123; ptr *array, len int, cap int &#125;</code></pre><p>所以从同一个数组切出来的切片，共享底层数据，修改一个会影响另一个：</p><pre><code class="highlight go">a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;b := a[<span class="number">1</span>:<span class="number">3</span>]   <span class="comment">// b = [2, 3]，和 a 共享底层数组</span>b[<span class="number">0</span>] = <span class="number">99</span>fmt.Println(a) <span class="comment">// [1, 99, 3, 4, 5]，a 也被改了</span></code></pre><p>如果不想共享，用 <code>copy</code> 或者三索引切片强制限制容量：</p><pre><code class="highlight go"><span class="comment">// copy 完全独立</span>b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>)<span class="built_in">copy</span>(b, a[<span class="number">1</span>:<span class="number">3</span>])<span class="comment">// 三索引切片，限制容量，append 时会触发复制</span>b := a[<span class="number">1</span>:<span class="number">3</span>:<span class="number">3</span>]</code></pre><p>append 超出容量时会重新分配内存，一般是原容量的两倍（大切片有所不同）。这个扩容操作有开销，已知大小的情况下最好提前用 make 指定容量。</p><h3 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h3><p>和 Java 的 HashMap 类似。查询时返回两个值，第二个是 bool，用来判断 key 是否存在，这样就不会把&quot;值不存在&quot;和&quot;值恰好是零&quot;混淆。</p><pre><code class="highlight go">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;    <span class="string">&quot;alice&quot;</span>: <span class="number">90</span>,    <span class="string">&quot;bob&quot;</span>:   <span class="number">85</span>,&#125;m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)m[<span class="string">&quot;charlie&quot;</span>] = <span class="number">95</span><span class="built_in">delete</span>(m, <span class="string">&quot;bob&quot;</span>)score, exists := m[<span class="string">&quot;alice&quot;</span>]<span class="keyword">if</span> exists &#123;    fmt.Println(score)&#125;<span class="comment">// 遍历顺序是随机的，每次跑结果可能不一样</span><span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;    fmt.Printf(<span class="string">&quot;%s: %d\n&quot;</span>, key, value)&#125;</code></pre><p>有几个坑要注意。第一，map 不是并发安全的，多个 goroutine 同时读写会 panic，需要加锁或用 <code>sync.Map</code>。第二，对 nil map 读是安全的（返回零值），但写会 panic，所以 map 一定要用 make 初始化再写。</p><pre><code class="highlight go"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>  <span class="comment">// nil map</span>_ = m[<span class="string">&quot;key&quot;</span>]          <span class="comment">// 安全，返回 0</span>m[<span class="string">&quot;key&quot;</span>] = <span class="number">1</span>          <span class="comment">// panic: assignment to entry in nil map</span></code></pre><h3 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h3><p>Go 没有 class，用 struct 来组织数据，再给 struct 绑定方法，效果类似。</p><pre><code class="highlight go"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;    ID    <span class="type">int</span>    Name  <span class="type">string</span>    Email <span class="type">string</span>    Age   <span class="type">int</span>&#125;u1 := User&#123;ID: <span class="number">1</span>, Name: <span class="string">&quot;张三&quot;</span>, Email: <span class="string">&quot;zs@example.com&quot;</span>, Age: <span class="number">25</span>&#125;u3 := &amp;User&#123;ID: <span class="number">3</span>, Name: <span class="string">&quot;王五&quot;</span>&#125;fmt.Println(u1.Name)u1.Age = <span class="number">26</span><span class="comment">// 值接收者，操作的是副本</span><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span></span> String() <span class="type">string</span> &#123;    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;User&#123;%d, %s&#125;&quot;</span>, u.ID, u.Name)&#125;<span class="comment">// 指针接收者，可以修改原始数据</span><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> UpdateAge(age <span class="type">int</span>) &#123;    u.Age = age&#125;</code></pre><p>Go 通过<strong>组合</strong>来复用代码，没有继承。把一个 struct 嵌入另一个 struct，外层可以直接访问内层的字段和方法，效果类似继承但更灵活。</p><pre><code class="highlight go"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;    Name <span class="type">string</span>&#125;<span class="function"><span class="keyword">func</span> <span class="params">(a Animal)</span></span> Breathe() &#123;    fmt.Println(a.Name, <span class="string">&quot;在呼吸&quot;</span>)&#125;<span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;    Animal        <span class="comment">// 嵌入 Animal，不需要字段名</span>    Breed <span class="type">string</span>&#125;d := Dog&#123;    Animal: Animal&#123;Name: <span class="string">&quot;旺财&quot;</span>&#125;,    Breed:  <span class="string">&quot;拉布拉多&quot;</span>,&#125;d.Breathe()       <span class="comment">// 直接调用 Animal 的方法</span>fmt.Println(d.Name)  <span class="comment">// 直接访问 Animal 的字段</span></code></pre><hr /><h2 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h2><p>Go 的接口是隐式实现的，不用写 <code>implements</code>，只要一个类型实现了接口定义的所有方法，它就自动满足这个接口。好处是解耦更彻底，定义接口的人和实现接口的人不需要提前约定。</p><pre><code class="highlight go"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;    Sound() <span class="type">string</span>    Name() <span class="type">string</span>&#125;<span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123; name <span class="type">string</span> &#125;<span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span></span> Sound() <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;汪汪&quot;</span> &#125;<span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span></span> Name() <span class="type">string</span>  &#123; <span class="keyword">return</span> d.name &#125;<span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123; name <span class="type">string</span> &#125;<span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span></span> Sound() <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;喵喵&quot;</span> &#125;<span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span></span> Name() <span class="type">string</span>  &#123; <span class="keyword">return</span> c.name &#125;<span class="function"><span class="keyword">func</span> <span class="title">makeSound</span><span class="params">(a Animal)</span></span> &#123;    fmt.Printf(<span class="string">&quot;%s 说: %s\n&quot;</span>, a.Name(), a.Sound())&#125;makeSound(Dog&#123;name: <span class="string">&quot;旺财&quot;</span>&#125;)makeSound(Cat&#123;name: <span class="string">&quot;咪咪&quot;</span>&#125;)</code></pre><p><strong>类型断言</strong>用来从接口值里取出具体类型，有两种写法：</p><pre><code class="highlight go"><span class="keyword">var</span> a Animal = Dog&#123;name: <span class="string">&quot;旺财&quot;</span>&#125;<span class="comment">// 直接断言，断言失败会 panic</span>d := a.(Dog)fmt.Println(d.name)<span class="comment">// 带 ok 的安全断言，推荐用这个</span>d, ok := a.(Dog)<span class="keyword">if</span> ok &#123;    fmt.Println(d.name)&#125;</code></pre><p><strong>类型 switch</strong> 可以同时判断多种类型，比一堆 if-else 清晰很多：</p><pre><code class="highlight go"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i any)</span></span> &#123;    <span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;    <span class="keyword">case</span> <span class="type">int</span>:        fmt.Printf(<span class="string">&quot;整数: %d\n&quot;</span>, v)    <span class="keyword">case</span> <span class="type">string</span>:        fmt.Printf(<span class="string">&quot;字符串: %s\n&quot;</span>, v)    <span class="keyword">case</span> <span class="type">bool</span>:        fmt.Printf(<span class="string">&quot;布尔: %v\n&quot;</span>, v)    <span class="keyword">default</span>:        fmt.Printf(<span class="string">&quot;未知类型: %T\n&quot;</span>, v)    &#125;&#125;</code></pre><p>Go 里有几个常用的内置接口值得了解：<code>error</code> 接口只有一个 <code>Error() string</code> 方法，<code>Stringer</code> 接口（<code>fmt.Stringer</code>）实现了 <code>String() string</code> 后，fmt 打印时会自动调用。</p><h2 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h2><p>这是 Go 最值得学的部分，也是它和其他语言拉开差距的地方。<br />Go 的并发核心思想是：<strong>不要通过共享内存来通信，而要通过通信来共享内存</strong>。</p><h3 id="goroutine"><a class="markdownIt-Anchor" href="#goroutine"></a> Goroutine</h3><p>Goroutine 是 Go 的并发执行单元，比系统线程轻量得多，几十万个同时跑都没问题。启动方式极简单，函数调用前加个 <code>go</code> 关键字就行。</p><pre><code class="highlight go"><span class="function"><span class="keyword">func</span> <span class="title">fetchData</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;    time.Sleep(time.Second)    fmt.Println(<span class="string">&quot;获取到:&quot;</span>, url)&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    <span class="keyword">go</span> fetchData(<span class="string">&quot;https://api1.example.com&quot;</span>)    <span class="keyword">go</span> fetchData(<span class="string">&quot;https://api2.example.com&quot;</span>)    <span class="keyword">go</span> fetchData(<span class="string">&quot;https://api3.example.com&quot;</span>)    time.Sleep(<span class="number">2</span> * time.Second)&#125;</code></pre><h3 id="waitgroup"><a class="markdownIt-Anchor" href="#waitgroup"></a> WaitGroup</h3><p>生产代码里等待 goroutine 完成要用 <code>sync.WaitGroup</code>，不能靠 Sleep 猜时间。</p><pre><code class="highlight go"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    <span class="keyword">var</span> wg sync.WaitGroup    urls := []<span class="type">string</span>&#123;<span class="string">&quot;url1&quot;</span>, <span class="string">&quot;url2&quot;</span>, <span class="string">&quot;url3&quot;</span>&#125;    <span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;        wg.Add(<span class="number">1</span>)        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(u <span class="type">string</span>)</span></span> &#123;            <span class="keyword">defer</span> wg.Done()            fetchData(u)        &#125;(url)  <span class="comment">// 把 url 作为参数传进去，不要在闭包里直接用外部变量</span>    &#125;    wg.Wait()    fmt.Println(<span class="string">&quot;全部完成&quot;</span>)&#125;</code></pre><h3 id="channel"><a class="markdownIt-Anchor" href="#channel"></a> Channel</h3><p>Channel 是 goroutine 之间传数据的管道，不需要手动加锁，天然并发安全。</p><pre><code class="highlight go"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;        ch &lt;- i    &#125;    <span class="built_in">close</span>(ch)&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)    <span class="keyword">go</span> producer(ch)    <span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;        fmt.Println(v)    &#125;&#125;</code></pre><p><code>select</code> 同时监听多个 channel：</p><pre><code class="highlight go"><span class="keyword">select</span> &#123;<span class="keyword">case</span> msg := &lt;-ch1:    fmt.Println(<span class="string">&quot;ch1:&quot;</span>, msg)<span class="keyword">case</span> msg := &lt;-ch2:    fmt.Println(<span class="string">&quot;ch2:&quot;</span>, msg)<span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):    fmt.Println(<span class="string">&quot;超时退出&quot;</span>)&#125;</code></pre><h3 id="mutex"><a class="markdownIt-Anchor" href="#mutex"></a> Mutex</h3><p>不是所有并发场景都适合用 channel，有时候就是需要多个 goroutine 共享一块数据，这时候要用互斥锁 <code>sync.Mutex</code>。</p><pre><code class="highlight go"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;    mu    sync.Mutex    count <span class="type">int</span>&#125;<span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Increment() &#123;    c.mu.Lock()    <span class="keyword">defer</span> c.mu.Unlock()  <span class="comment">// defer 确保锁一定释放</span>    c.count++&#125;<span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Value() <span class="type">int</span> &#123;    c.mu.Lock()    <span class="keyword">defer</span> c.mu.Unlock()    <span class="keyword">return</span> c.count&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    counter := &amp;SafeCounter&#123;&#125;    <span class="keyword">var</span> wg sync.WaitGroup    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;        wg.Add(<span class="number">1</span>)        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;            <span class="keyword">defer</span> wg.Done()            counter.Increment()        &#125;()    &#125;    wg.Wait()    fmt.Println(counter.Value())  <span class="comment">// 稳定输出 1000</span>&#125;</code></pre><p>读多写少的场景可以用 <code>sync.RWMutex</code>，读锁可以并发持有，写锁是独占的，性能更好。</p><pre><code class="highlight go"><span class="keyword">var</span> rwmu sync.RWMutex<span class="keyword">var</span> data = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)<span class="comment">// 读操作用读锁</span><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;    rwmu.RLock()    <span class="keyword">defer</span> rwmu.RUnlock()    <span class="keyword">return</span> data[key]&#125;<span class="comment">// 写操作用写锁</span><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(key, value <span class="type">string</span>)</span></span> &#123;    rwmu.Lock()    <span class="keyword">defer</span> rwmu.Unlock()    data[key] = value&#125;</code></pre><h3 id="context"><a class="markdownIt-Anchor" href="#context"></a> Context</h3><p><code>context</code> 是 Go 并发里非常重要的一个包，用来在 goroutine 之间传递取消信号、超时、截止时间和请求范围的值。<br />最常见的场景是 HTTP 请求处理：客户端断开连接后，应该取消所有还在跑的后台查询，不然白白浪费资源。</p><pre><code class="highlight go"><span class="comment">// 带超时的 context，超时后自动取消</span>ctx, cancel := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)<span class="keyword">defer</span> cancel()  <span class="comment">// 函数退出时释放资源，养成习惯</span><span class="comment">// 把 ctx 传给可能耗时的操作</span>result, err := queryDatabase(ctx, <span class="string">&quot;SELECT ...&quot;</span>)<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;    <span class="keyword">if</span> errors.Is(err, context.DeadlineExceeded) &#123;        fmt.Println(<span class="string">&quot;查询超时&quot;</span>)    &#125;&#125;</code></pre><p>自己写的函数如果可能耗时，第一个参数应该接收 ctx：</p><pre><code class="highlight go"><span class="function"><span class="keyword">func</span> <span class="title">queryDatabase</span><span class="params">(ctx context.Context, query <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;    <span class="comment">// 模拟一个可以被取消的操作</span>    <span class="keyword">select</span> &#123;    <span class="keyword">case</span> &lt;-time.After(<span class="number">5</span> * time.Second):  <span class="comment">// 正常操作耗时 5 秒</span>        <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>, <span class="literal">nil</span>    <span class="keyword">case</span> &lt;-ctx.Done():                    <span class="comment">// 如果 context 被取消</span>        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, ctx.Err()    &#125;&#125;</code></pre><p>context 还可以用来传递请求 ID 这类全链路透传的值，但不要滥用，业务参数该老老实实用函数参数传，别什么都往 ctx 里塞。</p><h2 id="泛型go-118"><a class="markdownIt-Anchor" href="#泛型go-118"></a> 泛型（Go 1.18+）</h2><p>Go 1.18 引入了泛型，在这之前写通用代码只能用 <code>any</code> + 类型断言，既没有类型安全，也没有代码提示。现在可以用类型参数解决这个问题。</p><pre><code class="highlight go"><span class="comment">// 没有泛型之前，只能写 any</span><span class="function"><span class="keyword">func</span> <span class="title">containsOld</span><span class="params">(slice []any, item any)</span></span> <span class="type">bool</span> &#123;    <span class="keyword">for</span> _, v := <span class="keyword">range</span> slice &#123;        <span class="keyword">if</span> v == item &#123;            <span class="keyword">return</span> <span class="literal">true</span>        &#125;    &#125;    <span class="keyword">return</span> <span class="literal">false</span>&#125;<span class="comment">// 有了泛型，类型安全，也有代码提示</span><span class="function"><span class="keyword">func</span> <span class="title">Contains</span>[<span class="title">T</span> <span class="title">comparable</span>]<span class="params">(slice []T, item T)</span></span> <span class="type">bool</span> &#123;    <span class="keyword">for</span> _, v := <span class="keyword">range</span> slice &#123;        <span class="keyword">if</span> v == item &#123;            <span class="keyword">return</span> <span class="literal">true</span>        &#125;    &#125;    <span class="keyword">return</span> <span class="literal">false</span>&#125;<span class="comment">// 调用时编译器自动推断类型</span>fmt.Println(Contains([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, <span class="number">2</span>))         <span class="comment">// true</span>fmt.Println(Contains([]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;, <span class="string">&quot;c&quot;</span>))   <span class="comment">// false</span></code></pre><p><code>comparable</code> 是 Go 内置的约束，表示可以用 <code>==</code> 比较的类型。也可以用 <code>any</code>（无约束）或自定义约束：</p><pre><code class="highlight go"><span class="comment">// 自定义约束，限制只能是数字类型</span><span class="keyword">type</span> Number <span class="keyword">interface</span> &#123;    <span class="type">int</span> | <span class="type">int64</span> | <span class="type">float32</span> | <span class="type">float64</span>&#125;<span class="function"><span class="keyword">func</span> <span class="title">Sum</span>[<span class="title">T</span> <span class="title">Number</span>]<span class="params">(nums []T)</span></span> T &#123;    <span class="keyword">var</span> total T    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;        total += n    &#125;    <span class="keyword">return</span> total&#125;fmt.Println(Sum([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;))         <span class="comment">// 6</span>fmt.Println(Sum([]<span class="type">float64</span>&#123;<span class="number">1.1</span>, <span class="number">2.2</span>&#125;))   <span class="comment">// 3.3</span></code></pre><p>泛型对写工具库很有用，业务代码里不用刻意去用，够用就好。</p><h2 id="web-开发"><a class="markdownIt-Anchor" href="#web-开发"></a> Web 开发</h2><h3 id="标准库"><a class="markdownIt-Anchor" href="#标准库"></a> 标准库</h3><p>Go 内置的 <code>net/http</code> 已经够用了，不用引入任何框架就能跑一个 HTTP 服务。</p><pre><code class="highlight go"><span class="keyword">package</span> main<span class="keyword">import</span> (    <span class="string">&quot;encoding/json&quot;</span>    <span class="string">&quot;fmt&quot;</span>    <span class="string">&quot;net/http&quot;</span>)<span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;    Code    <span class="type">int</span>    <span class="string">`json:&quot;code&quot;`</span>    Message <span class="type">string</span> <span class="string">`json:&quot;message&quot;`</span>    Data    any    <span class="string">`json:&quot;data&quot;`</span>&#125;<span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;    w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)    json.NewEncoder(w).Encode(Response&#123;        Code:    <span class="number">200</span>,        Message: <span class="string">&quot;success&quot;</span>,        Data:    <span class="string">&quot;Hello Go!&quot;</span>,    &#125;)&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, helloHandler)    fmt.Println(<span class="string">&quot;服务启动: http://localhost:8080&quot;</span>)    http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)&#125;</code></pre><h3 id="gin"><a class="markdownIt-Anchor" href="#gin"></a> Gin</h3><p>复杂项目推荐用 Gin，Go 生态里用得最广的 Web 框架，性能很高，API 设计也简洁。有 Spring MVC 基础的话大概看半天就能上手。</p><pre><code class="highlight bash">go mod init myappgo get github.com/gin-gonic/gin</code></pre><pre><code class="highlight go"><span class="keyword">package</span> main<span class="keyword">import</span> (    <span class="string">&quot;net/http&quot;</span>    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span>)<span class="keyword">type</span> User <span class="keyword">struct</span> &#123;    ID   <span class="type">int</span>    <span class="string">`json:&quot;id&quot;`</span>    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span>&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    r := gin.Default()  <span class="comment">// 自带日志和 panic 恢复中间件</span>    r.GET(<span class="string">&quot;/users/:id&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;        id := c.Param(<span class="string">&quot;id&quot;</span>)        _ = id        c.JSON(http.StatusOK, User&#123;ID: <span class="number">1</span>, Name: <span class="string">&quot;张三&quot;</span>&#125;)    &#125;)    r.POST(<span class="string">&quot;/users&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;        <span class="keyword">var</span> user User        <span class="keyword">if</span> err := c.ShouldBindJSON(&amp;user); err != <span class="literal">nil</span> &#123;            c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)            <span class="keyword">return</span>        &#125;        c.JSON(http.StatusCreated, user)    &#125;)    api := r.Group(<span class="string">&quot;/api/v1&quot;</span>)    &#123;        api.GET(<span class="string">&quot;/health&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;            c.JSON(<span class="number">200</span>, gin.H&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;ok&quot;</span>&#125;)        &#125;)    &#125;    r.Run(<span class="string">&quot;:8080&quot;</span>)&#125;</code></pre><h3 id="gin-中间件"><a class="markdownIt-Anchor" href="#gin-中间件"></a> Gin 中间件</h3><p>中间件是 Gin 里很重要的概念，可以在请求处理前后插入逻辑，类似 Spring 的拦截器。认证、日志、限流都可以用中间件实现。</p><pre><code class="highlight go"><span class="comment">// 自定义认证中间件</span><span class="function"><span class="keyword">func</span> <span class="title">AuthMiddleware</span><span class="params">()</span></span> gin.HandlerFunc &#123;    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;        token := c.GetHeader(<span class="string">&quot;Authorization&quot;</span>)        <span class="keyword">if</span> token == <span class="string">&quot;&quot;</span> &#123;            c.JSON(http.StatusUnauthorized, gin.H&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;缺少 token&quot;</span>&#125;)            c.Abort()  <span class="comment">// 终止后续处理，不调用 Next</span>            <span class="keyword">return</span>        &#125;        <span class="comment">// 验证 token，这里简化处理</span>        userID, err := parseToken(token)        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;            c.JSON(http.StatusUnauthorized, gin.H&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;token 无效&quot;</span>&#125;)            c.Abort()            <span class="keyword">return</span>        &#125;        <span class="comment">// 把用户 ID 存到 context，后续 handler 可以取到</span>        c.Set(<span class="string">&quot;userID&quot;</span>, userID)        c.Next()  <span class="comment">// 继续往下走</span>    &#125;&#125;<span class="comment">// 请求耗时日志中间件</span><span class="function"><span class="keyword">func</span> <span class="title">LoggerMiddleware</span><span class="params">()</span></span> gin.HandlerFunc &#123;    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;        start := time.Now()        c.Next()        duration := time.Since(start)        log.Printf(<span class="string">&quot;%s %s 耗时 %v&quot;</span>, c.Request.Method, c.Request.URL.Path, duration)    &#125;&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    r := gin.New()  <span class="comment">// 不用 Default，自己组装中间件</span>    <span class="comment">// 全局中间件</span>    r.Use(LoggerMiddleware())    <span class="comment">// 只对特定路由组生效的中间件</span>    auth := r.Group(<span class="string">&quot;/api&quot;</span>)    auth.Use(AuthMiddleware())    &#123;        auth.GET(<span class="string">&quot;/profile&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;            userID := c.GetString(<span class="string">&quot;userID&quot;</span>)            c.JSON(<span class="number">200</span>, gin.H&#123;<span class="string">&quot;userID&quot;</span>: userID&#125;)        &#125;)    &#125;    r.Run(<span class="string">&quot;:8080&quot;</span>)&#125;</code></pre><h3 id="参数绑定和验证"><a class="markdownIt-Anchor" href="#参数绑定和验证"></a> 参数绑定和验证</h3><p>Gin 支持用 struct tag 做参数验证，配合 <code>binding</code> tag 省去大量手动校验代码。</p><pre><code class="highlight go"><span class="comment">// go get github.com/go-playground/validator/v10  (Gin 自带，不用额外安装)</span><span class="keyword">type</span> CreateUserRequest <span class="keyword">struct</span> &#123;    Name     <span class="type">string</span> <span class="string">`json:&quot;name&quot; binding:&quot;required,min=2,max=20&quot;`</span>    Email    <span class="type">string</span> <span class="string">`json:&quot;email&quot; binding:&quot;required,email&quot;`</span>    Age      <span class="type">int</span>    <span class="string">`json:&quot;age&quot; binding:&quot;required,gte=1,lte=150&quot;`</span>    Password <span class="type">string</span> <span class="string">`json:&quot;password&quot; binding:&quot;required,min=8&quot;`</span>&#125;r.POST(<span class="string">&quot;/users&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;    <span class="keyword">var</span> req CreateUserRequest    <span class="keyword">if</span> err := c.ShouldBindJSON(&amp;req); err != <span class="literal">nil</span> &#123;        <span class="comment">// err 里包含具体哪个字段不合法</span>        c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)        <span class="keyword">return</span>    &#125;    <span class="comment">// req 已经验证通过，直接用</span>    c.JSON(http.StatusCreated, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;创建成功&quot;</span>&#125;)&#125;)</code></pre><hr /><h2 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h2><h3 id="gorm"><a class="markdownIt-Anchor" href="#gorm"></a> GORM</h3><p>Go 里最成熟的 ORM，支持 MySQL、PostgreSQL、SQLite，有 MyBatis 或 Hibernate 基础的话上手很快。</p><pre><code class="highlight bash">go get gorm.io/gormgo get gorm.io/driver/mysql</code></pre><pre><code class="highlight go"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;    gorm.Model  <span class="comment">// 自动有 id、created_at、updated_at、deleted_at</span>    Name  <span class="type">string</span> <span class="string">`gorm:&quot;size:100;not null&quot;`</span>    Email <span class="type">string</span> <span class="string">`gorm:&quot;uniqueIndex&quot;`</span>    Age   <span class="type">int</span>&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    dsn := <span class="string">&quot;root:password@tcp(127.0.0.1:3306)/mydb?charset=utf8mb4&amp;parseTime=True&quot;</span>    db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;        <span class="built_in">panic</span>(<span class="string">&quot;数据库连接失败&quot;</span>)    &#125;    db.AutoMigrate(&amp;User&#123;&#125;)    <span class="comment">// 增</span>    db.Create(&amp;User&#123;Name: <span class="string">&quot;张三&quot;</span>, Email: <span class="string">&quot;zs@test.com&quot;</span>, Age: <span class="number">25</span>&#125;)    <span class="comment">// 查</span>    <span class="keyword">var</span> user User    db.First(&amp;user, <span class="number">1</span>)    db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;张三&quot;</span>).First(&amp;user)    <span class="keyword">var</span> users []User    db.Where(<span class="string">&quot;age &gt; ?&quot;</span>, <span class="number">20</span>).Find(&amp;users)    <span class="comment">// 改</span>    db.Model(&amp;user).Update(<span class="string">&quot;age&quot;</span>, <span class="number">26</span>)    db.Model(&amp;user).Updates(User&#123;Name: <span class="string">&quot;新名字&quot;</span>, Age: <span class="number">27</span>&#125;)    <span class="comment">// 删（软删除）</span>    db.Delete(&amp;user, <span class="number">1</span>)&#125;</code></pre><h3 id="gorm-事务"><a class="markdownIt-Anchor" href="#gorm-事务"></a> GORM 事务</h3><p>涉及多表操作必须用事务，GORM 的事务 API 很干净。</p><pre><code class="highlight go"><span class="comment">// 方式一：手动控制</span>tx := db.Begin()<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;    <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;        tx.Rollback()    &#125;&#125;()<span class="keyword">if</span> err := tx.Create(&amp;user).Error; err != <span class="literal">nil</span> &#123;    tx.Rollback()    <span class="keyword">return</span> err&#125;<span class="keyword">if</span> err := tx.Create(&amp;order).Error; err != <span class="literal">nil</span> &#123;    tx.Rollback()    <span class="keyword">return</span> err&#125;tx.Commit()<span class="comment">// 方式二：Transaction 方法，更简洁，推荐用这个</span>err := db.Transaction(<span class="function"><span class="keyword">func</span><span class="params">(tx *gorm.DB)</span></span> <span class="type">error</span> &#123;    <span class="keyword">if</span> err := tx.Create(&amp;user).Error; err != <span class="literal">nil</span> &#123;        <span class="keyword">return</span> err  <span class="comment">// 返回 error 自动回滚</span>    &#125;    <span class="keyword">if</span> err := tx.Create(&amp;order).Error; err != <span class="literal">nil</span> &#123;        <span class="keyword">return</span> err    &#125;    <span class="keyword">return</span> <span class="literal">nil</span>  <span class="comment">// 返回 nil 自动提交</span>&#125;)</code></pre><h3 id="连接池配置"><a class="markdownIt-Anchor" href="#连接池配置"></a> 连接池配置</h3><p>生产环境要配连接池，不然高并发下会挂。</p><pre><code class="highlight go">sqlDB, err := db.DB()  <span class="comment">// 拿到底层的 *sql.DB</span><span class="comment">// 最大空闲连接数</span>sqlDB.SetMaxIdleConns(<span class="number">10</span>)<span class="comment">// 最大打开连接数</span>sqlDB.SetMaxOpenConns(<span class="number">100</span>)<span class="comment">// 连接最大存活时间，超时会被回收</span>sqlDB.SetConnMaxLifetime(time.Hour)</code></pre><hr /><h2 id="项目结构"><a class="markdownIt-Anchor" href="#项目结构"></a> 项目结构</h2><h3 id="go-modules"><a class="markdownIt-Anchor" href="#go-modules"></a> Go Modules</h3><p>Go 的包管理工具，类似 Maven。<code>go.mod</code> 记录依赖版本，<code>go.sum</code> 做哈希校验，两个文件都要提交到 git。</p><pre><code class="highlight bash">go mod init github.com/yourname/myappgo get github.com/gin-gonic/gingo get github.com/gin-gonic/gin@v1.9.0go mod tidy  <span class="comment"># 清理多余依赖，补上缺失依赖</span></code></pre><h3 id="目录结构"><a class="markdownIt-Anchor" href="#目录结构"></a> 目录结构</h3><p>Go 社区有一套通用的项目布局，按这个来就行。</p><pre><code class="highlight plaintext">myapp/├── cmd/│   └── main.go          # 入口，保持简洁，只管启动├── internal/            # 内部包，编译器保证外部模块无法引用│   ├── handler/         # 处理 HTTP 请求│   ├── service/         # 业务逻辑│   ├── repository/      # 数据库操作│   └── model/           # 数据结构定义├── pkg/                 # 可以被外部引用的公共包├── config/              # 配置文件├── go.mod└── go.sum</code></pre><h3 id="错误处理"><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h3><p>这是和 Java 差异最大的地方。Go 没有 try-catch，用多返回值传递错误，调用方必须显式处理。<br />初看会觉得到处都是 <code>if err != nil</code> 很啰嗦，但好处是错误处理强制可见，不会出现异常被某层吞掉然后莫名其妙出 bug 的情况。</p><pre><code class="highlight go"><span class="function"><span class="keyword">func</span> <span class="title">getUser</span><span class="params">(id <span class="type">int</span>)</span></span> (*User, <span class="type">error</span>) &#123;    <span class="keyword">if</span> id &lt;= <span class="number">0</span> &#123;        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;无效的 ID: %d&quot;</span>, id)    &#125;    <span class="keyword">return</span> &amp;User&#123;&#125;, <span class="literal">nil</span>&#125;user, err := getUser(<span class="number">1</span>)<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;    log.Printf(<span class="string">&quot;获取用户失败: %v&quot;</span>, err)    <span class="keyword">return</span>&#125;fmt.Println(user.Name)</code></pre><p>Go 1.13 引入了错误包装，可以用 <code>%w</code> 把原始错误包进去，调用方用 <code>errors.Is</code> 和 <code>errors.As</code> 来判断和提取具体错误：</p><pre><code class="highlight go"><span class="comment">// 包装错误，保留原始信息</span><span class="function"><span class="keyword">func</span> <span class="title">getUser</span><span class="params">(id <span class="type">int</span>)</span></span> (*User, <span class="type">error</span>) &#123;    user, err := db.QueryUser(id)    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;getUser 失败: %w&quot;</span>, err)  <span class="comment">// %w 包装</span>    &#125;    <span class="keyword">return</span> user, <span class="literal">nil</span>&#125;<span class="comment">// 调用方判断具体错误类型</span>_, err := getUser(<span class="number">1</span>)<span class="keyword">if</span> errors.Is(err, sql.ErrNoRows) &#123;    fmt.Println(<span class="string">&quot;用户不存在&quot;</span>)&#125;<span class="comment">// 提取自定义错误类型</span><span class="keyword">var</span> dbErr *DatabaseError<span class="keyword">if</span> errors.As(err, &amp;dbErr) &#123;    fmt.Println(<span class="string">&quot;数据库错误码:&quot;</span>, dbErr.Code)&#125;</code></pre><hr /><h2 id="性能分析"><a class="markdownIt-Anchor" href="#性能分析"></a> 性能分析</h2><p>Go 内置了性能分析工具 <code>pprof</code>，不需要任何第三方依赖。线上遇到内存泄漏或者 CPU 占用高，直接接入就能分析。</p><pre><code class="highlight go"><span class="keyword">import</span> _ <span class="string">&quot;net/http/pprof&quot;</span>  <span class="comment">// 注册 pprof 路由</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    <span class="comment">// pprof 会自动注册到 /debug/pprof/</span>    <span class="keyword">go</span> http.ListenAndServe(<span class="string">&quot;:6060&quot;</span>, <span class="literal">nil</span>)    <span class="comment">// 你的主服务</span>    <span class="comment">// ...</span>&#125;</code></pre><p>然后用命令行采集和分析：</p><pre><code class="highlight bash"><span class="comment"># 采集 30 秒的 CPU profile</span>go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30<span class="comment"># 分析内存</span>go tool pprof http://localhost:6060/debug/pprof/heap<span class="comment"># 进入交互模式后常用命令</span>top       <span class="comment"># 按占用排序，看哪些函数消耗最多</span>list 函数名  <span class="comment"># 看具体哪一行代码占用多</span>web       <span class="comment"># 生成可视化调用图（需要安装 graphviz）</span></code></pre><p>Go 还内置了 benchmark 测试，可以精确测量一段代码的性能：</p><pre><code class="highlight go"><span class="comment">// xxx_test.go</span><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkContains</span><span class="params">(b *testing.B)</span></span> &#123;    data := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>)    <span class="keyword">for</span> i := <span class="keyword">range</span> data &#123;        data[i] = i    &#125;    b.ResetTimer()  <span class="comment">// 重置计时器，排除初始化时间</span>    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;        Contains(data, <span class="number">9999</span>)    &#125;&#125;</code></pre><pre><code class="highlight bash">go <span class="built_in">test</span> -bench=. -benchmem  <span class="comment"># -benchmem 同时显示内存分配情况</span></code></pre><hr />]]>
    </content>
    <id>http://example.com/2024/04/29/go/</id>
    <link href="http://example.com/2024/04/29/go/"/>
    <published>2024-04-29T04:00:00.000Z</published>
    <summary>Go 语言（又称 Golang）是由 Google 开发的一种开源、静态类型的编程语言。它于 2007 年开始构思，2009 年正式对外发布。Go 语言的设计目标是简洁、高效、可靠，并特别注重现代硬件特性和网络编程的需求，尤其是在并发处理方面表现出色。如今，Go 已成为云原生、微服务、DevOps 工具等领域最受欢迎的语言之一。</summary>
    <title>Go</title>
    <updated>2026-02-27T07:35:33.207Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    <content>
      <![CDATA[<h1 id="java-虚拟线程virtual-threads"><a class="markdownIt-Anchor" href="#java-虚拟线程virtual-threads"></a> Java 虚拟线程（Virtual Threads）</h1><blockquote><p>Java 21 正式引入了虚拟线程，这是 Java 并发编程近十年来最重要的一次变革。本文从原理到实战，带你彻底搞懂虚拟线程。</p></blockquote><hr /><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B">为什么需要虚拟线程</a></li><li><a href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88">虚拟线程是什么</a></li><li><a href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B-vs-%E5%B9%B3%E5%8F%B0%E7%BA%BF%E7%A8%8B">虚拟线程 vs 平台线程</a></li><li><a href="#%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B">快速上手</a></li><li><a href="#%E4%B8%8E-spring-boot-%E9%9B%86%E6%88%90">与 Spring Boot 集成</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">使用场景与注意事项</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA">常见误区</a></li><li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li></ul><hr /><h2 id="为什么需要虚拟线程"><a class="markdownIt-Anchor" href="#为什么需要虚拟线程"></a> 为什么需要虚拟线程</h2><p>在聊虚拟线程之前，先看看传统线程模型有什么问题。</p><h3 id="传统线程的瓶颈"><a class="markdownIt-Anchor" href="#传统线程的瓶颈"></a> 传统线程的瓶颈</h3><p>Java 的传统线程（也叫平台线程）是对操作系统线程的直接封装，一个 Java 线程对应一个 OS 线程。这带来了几个根本性的限制：<br /><strong>创建成本高</strong>。每个平台线程默认会分配约 1MB 的栈内存，创建和销毁都需要系统调用，开销不小。<br /><strong>数量有上限</strong>。正因为资源占用高，一台普通服务器能维持的线程数通常在几千个左右，超过这个数量系统就会吃不消。<br /><strong>阻塞时浪费资源</strong>。这是最大的问题。当线程在等待数据库响应、HTTP 调用、读写文件时，它什么都不做，却依然占着 OS 线程不放。<br />举个实际场景：一个普通的 Web 接口，处理一次请求需要查两次数据库，每次数据库查询耗时 50ms。在这 100ms 里，线程大部分时间都在阻塞等待，真正执行业务逻辑的时间可能只有几毫秒。</p><pre><code class="highlight plaintext">请求进来 → [查数据库，等待 50ms] → [查缓存，等待 30ms] → [计算，5ms] → 返回               ↑ 线程在睡觉              ↑ 线程在睡觉        ↑ 真正在干活</code></pre><p>为了应对高并发，我们只能加线程、加机器，但这条路是有尽头的。</p><h3 id="响应式编程的代价"><a class="markdownIt-Anchor" href="#响应式编程的代价"></a> 响应式编程的代价</h3><p>为了解决这个问题，社区推出了响应式编程（Reactive），比如 WebFlux、RxJava。响应式的思路是用少量线程处理大量请求，线程不再等待，而是注册回调，IO 完成后再继续。<br />理论上很美好，但实际写起来：</p><pre><code class="highlight java"><span class="comment">// 响应式风格，光是读懂就需要一会儿</span>userService.findById(id)    .flatMap(user -&gt; orderService.findByUserId(user.getId()))    .flatMap(orders -&gt; inventoryService.checkStock(orders))    .map(result -&gt; ResponseEntity.ok(result))    .onErrorResume(e -&gt; Mono.just(ResponseEntity.status(<span class="number">500</span>).build()))    .subscribe();</code></pre><p>代码的可读性、调试难度、错误排查成本都大幅上升。响应式是用代码复杂度换取性能，不是所有团队都愿意接受这笔交易。<br /><strong>虚拟线程的出现，让我们可以用最朴素的同步写法，获得接近响应式的并发性能。</strong></p><h2 id="虚拟线程是什么"><a class="markdownIt-Anchor" href="#虚拟线程是什么"></a> 虚拟线程是什么</h2><p>虚拟线程是由 JVM 管理的轻量级线程，不直接对应 OS 线程。</p><h3 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h3><p>JVM 内部维护了一个平台线程池（称为 Carrier Threads，载体线程），虚拟线程运行在载体线程之上。关键在于：</p><ul><li>当虚拟线程发生阻塞（比如等待 IO），JVM 会自动把它从载体线程上<strong>卸载</strong>，载体线程立刻去执行其他虚拟线程</li><li>当阻塞结束，虚拟线程会被<strong>重新挂载</strong>到某个可用的载体线程上继续执行</li></ul><pre><code class="highlight plaintext">载体线程 1:  [虚拟线程A执行] → [A阻塞，切换] → [虚拟线程B执行] → [B阻塞，切换] → [虚拟线程A继续]载体线程 2:  [虚拟线程C执行] → [虚拟线程D执行] → ...</code></pre><p>整个切换过程发生在 JVM 内部，不需要系统调用，成本极低。<br />这样一来，几个载体线程就能调度数百万个虚拟线程，IO 等待时间被充分利用起来，吞吐量大幅提升。</p><h2 id="虚拟线程-vs-平台线程"><a class="markdownIt-Anchor" href="#虚拟线程-vs-平台线程"></a> 虚拟线程 vs 平台线程</h2><table><thead><tr><th>对比项</th><th>平台线程</th><th>虚拟线程</th></tr></thead><tbody><tr><td>对应关系</td><td>1:1 对应 OS 线程</td><td>多:1 挂载在载体线程上</td></tr><tr><td>创建成本</td><td>高（约 1MB 栈内存）</td><td>极低（KB 级别，按需扩展）</td></tr><tr><td>可创建数量</td><td>通常几千个</td><td>轻松达到数百万</td></tr><tr><td>阻塞时</td><td>占用 OS 线程，白白浪费</td><td>自动挂起，释放载体线程</td></tr><tr><td>上下文切换</td><td>需要系统调用，成本较高</td><td>JVM 内部调度，成本极低</td></tr><tr><td>适合场景</td><td>CPU 密集型计算</td><td>IO 密集型（数据库、网络请求）</td></tr><tr><td>代码改造成本</td><td>—</td><td>几乎为零，同步写法照常用</td></tr></tbody></table><hr /><h2 id="快速上手"><a class="markdownIt-Anchor" href="#快速上手"></a> 快速上手</h2><p>虚拟线程在 Java 21 中正式发布，API 设计上刻意保持了向下兼容，学习成本很低。</p><h3 id="环境要求"><a class="markdownIt-Anchor" href="#环境要求"></a> 环境要求</h3><pre><code class="highlight plaintext">JDK 21+</code></pre><h3 id="创建虚拟线程的几种方式"><a class="markdownIt-Anchor" href="#创建虚拟线程的几种方式"></a> 创建虚拟线程的几种方式</h3><p><strong>方式一：Thread.ofVirtual()</strong></p><pre><code class="highlight java"><span class="comment">// 创建并启动一个虚拟线程</span><span class="type">Thread</span> <span class="variable">vThread</span> <span class="operator">=</span> Thread.ofVirtual().start(() -&gt; &#123;    System.out.println(<span class="string">&quot;当前线程是否为虚拟线程: &quot;</span> + Thread.currentThread().isVirtual());    System.out.println(<span class="string">&quot;线程名: &quot;</span> + Thread.currentThread().getName());&#125;);vThread.join(); <span class="comment">// 等待执行完毕</span></code></pre><p><strong>方式二：虚拟线程工厂</strong></p><pre><code class="highlight java"><span class="type">ThreadFactory</span> <span class="variable">factory</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;worker-&quot;</span>, <span class="number">0</span>).factory();<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> factory.newThread(() -&gt; System.out.println(<span class="string">&quot;任务1&quot;</span>));<span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> factory.newThread(() -&gt; System.out.println(<span class="string">&quot;任务2&quot;</span>));t1.start();t2.start();</code></pre><p><strong>方式三：ExecutorService（最常用）</strong></p><pre><code class="highlight java"><span class="comment">// 每提交一个任务，就创建一个虚拟线程来执行</span><span class="keyword">try</span> (<span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;        executor.submit(() -&gt; &#123;            <span class="comment">// 模拟 IO 操作</span>            Thread.sleep(Duration.ofMillis(<span class="number">100</span>));            System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 完成，线程: &quot;</span> + Thread.currentThread());            <span class="keyword">return</span> taskId;        &#125;);    &#125;&#125; <span class="comment">// try-with-resources 会自动 shutdown 并等待所有任务完成</span></code></pre><p>注意这里提交了 10000 个任务，每个任务都会阻塞 100ms，用平台线程池根本撑不住，但虚拟线程完全没有压力。</p><h3 id="一个直观的性能对比"><a class="markdownIt-Anchor" href="#一个直观的性能对比"></a> 一个直观的性能对比</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadComparison</span> &#123;    <span class="comment">// 用平台线程池跑 10000 个任务</span>    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">withPlatformThreads</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();               <span class="keyword">try</span> (<span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">200</span>)) &#123;            List&lt;Future&lt;?&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;                futures.add(executor.submit(() -&gt; &#123;                    Thread.sleep(Duration.ofMillis(<span class="number">50</span>)); <span class="comment">// 模拟 IO</span>                    <span class="keyword">return</span> <span class="literal">null</span>;                &#125;));            &#125;            <span class="keyword">for</span> (Future&lt;?&gt; f : futures) f.get();        &#125;               System.out.println(<span class="string">&quot;平台线程耗时: &quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;ms&quot;</span>);        <span class="comment">// 预期耗时：约 2500ms（10000 / 200 * 50ms）</span>    &#125;    <span class="comment">// 用虚拟线程跑同样的 10000 个任务</span>    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">withVirtualThreads</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();               <span class="keyword">try</span> (<span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;            List&lt;Future&lt;?&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;                futures.add(executor.submit(() -&gt; &#123;                    Thread.sleep(Duration.ofMillis(<span class="number">50</span>)); <span class="comment">// 模拟 IO</span>                    <span class="keyword">return</span> <span class="literal">null</span>;                &#125;));            &#125;            <span class="keyword">for</span> (Future&lt;?&gt; f : futures) f.get();        &#125;               System.out.println(<span class="string">&quot;虚拟线程耗时: &quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;ms&quot;</span>);        <span class="comment">// 预期耗时：约 50~100ms（几乎所有任务并行执行）</span>    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        withPlatformThreads();        withVirtualThreads();    &#125;&#125;</code></pre><h3 id="结构化并发structured-concurrency"><a class="markdownIt-Anchor" href="#结构化并发structured-concurrency"></a> 结构化并发（Structured Concurrency）</h3><p>Java 21 同期引入了结构化并发 API，配合虚拟线程使用体验非常好。它的核心思想是：<strong>多个并发任务作为一个整体来管理，任意一个失败则整体失败，不会出现任务泄漏。</strong></p><pre><code class="highlight java"><span class="keyword">import</span> java.util.concurrent.StructuredTaskScope;<span class="keyword">record</span> <span class="title class_">UserProfile</span><span class="params">(User user, List&lt;Order&gt; orders, List&lt;Address&gt; addresses)</span> &#123;&#125;UserProfile <span class="title function_">fetchUserProfile</span><span class="params">(<span class="type">long</span> userId)</span> <span class="keyword">throws</span> Exception &#123;    <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;               <span class="comment">// 三个任务并发执行，每个都跑在独立的虚拟线程上</span>        StructuredTaskScope.Subtask&lt;User&gt; userTask =            scope.fork(() -&gt; userService.findById(userId));               StructuredTaskScope.Subtask&lt;List&lt;Order&gt;&gt; orderTask =            scope.fork(() -&gt; orderService.findByUserId(userId));               StructuredTaskScope.Subtask&lt;List&lt;Address&gt;&gt; addressTask =            scope.fork(() -&gt; addressService.findByUserId(userId));        scope.join();           <span class="comment">// 等待所有任务完成</span>        scope.throwIfFailed();  <span class="comment">// 任意一个失败则抛异常，其余任务自动取消</span>        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserProfile</span>(            userTask.get(),            orderTask.get(),            addressTask.get()        );    &#125;&#125;</code></pre><p>对比一下传统的 <code>CompletableFuture</code> 写法，结构化并发的代码意图更清晰，错误处理也更可靠。</p><h2 id="与-spring-boot-集成"><a class="markdownIt-Anchor" href="#与-spring-boot-集成"></a> 与 Spring Boot 集成</h2><p>Spring Boot 3.2 之后对虚拟线程提供了完整支持，开启方式非常简单。</p><h3 id="一行配置开启"><a class="markdownIt-Anchor" href="#一行配置开启"></a> 一行配置开启</h3><pre><code class="highlight properties"><span class="comment"># application.properties</span><span class="attr">spring.threads.virtual.enabled</span>=<span class="string">true</span></code></pre><p>加上这一行，Spring Boot 会自动将 Tomcat、定时任务等组件切换到虚拟线程模式，无需改动任何业务代码。</p><h3 id="手动配置需要精细控制时"><a class="markdownIt-Anchor" href="#手动配置需要精细控制时"></a> 手动配置（需要精细控制时）</h3><pre><code class="highlight java"><span class="meta">@Configuration</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadConfig</span> &#123;    <span class="comment">// 将 Tomcat 切换为虚拟线程</span>    <span class="meta">@Bean</span>    <span class="keyword">public</span> TomcatProtocolHandlerCustomizer&lt;?&gt; virtualThreadsProtocolHandlerCustomizer() &#123;        <span class="keyword">return</span> protocolHandler -&gt;            protocolHandler.setExecutor(Executors.newVirtualThreadPerTaskExecutor());    &#125;    <span class="comment">// 提供一个虚拟线程的 TaskExecutor，供 @Async 使用</span>    <span class="meta">@Bean</span>    <span class="keyword">public</span> AsyncTaskExecutor <span class="title function_">applicationTaskExecutor</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TaskExecutorAdapter</span>(Executors.newVirtualThreadPerTaskExecutor());    &#125;    <span class="comment">// 定时任务也走虚拟线程</span>    <span class="meta">@Bean</span>    <span class="keyword">public</span> TaskScheduler <span class="title function_">taskScheduler</span><span class="params">()</span> &#123;        <span class="type">ThreadPoolTaskScheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskScheduler</span>();        scheduler.setVirtualThreads(<span class="literal">true</span>);        <span class="keyword">return</span> scheduler;    &#125;&#125;</code></pre><h3 id="实战示例高并发接口"><a class="markdownIt-Anchor" href="#实战示例高并发接口"></a> 实战示例：高并发接口</h3><pre><code class="highlight java"><span class="meta">@RestController</span><span class="meta">@RequestMapping(&quot;/api&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> UserService userService;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> OrderService orderService;    <span class="comment">// 开启虚拟线程后，即使这个接口有大量并发请求</span>    <span class="comment">// 每个请求都能分配到独立的虚拟线程，数据库等待不再成为瓶颈</span>    <span class="meta">@GetMapping(&quot;/users/&#123;id&#125;/profile&quot;)</span>    <span class="keyword">public</span> UserProfileVO <span class="title function_">getUserProfile</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;        <span class="comment">// 同步写法，清晰直观</span>        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findById(id);           <span class="comment">// 可能阻塞 20ms</span>        List&lt;Order&gt; orders = orderService.findByUserId(id); <span class="comment">// 可能阻塞 30ms</span>        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserProfileVO</span>(user, orders);    &#125;&#125;</code></pre><hr /><h2 id="使用场景与注意事项"><a class="markdownIt-Anchor" href="#使用场景与注意事项"></a> 使用场景与注意事项</h2><h3 id="最适合的场景"><a class="markdownIt-Anchor" href="#最适合的场景"></a> 最适合的场景</h3><p>虚拟线程在 IO 密集型场景下收益最大：</p><ul><li><strong>Web 服务</strong>：处理大量并发 HTTP 请求</li><li><strong>数据库访问</strong>：大量 SQL 查询、事务操作</li><li><strong>微服务调用</strong>：服务间的 HTTP/RPC 调用</li><li><strong>文件读写</strong>：批量处理文件</li><li><strong>消息消费</strong>：消费 Kafka、RocketMQ 等消息队列</li></ul><h3 id="不适合的场景"><a class="markdownIt-Anchor" href="#不适合的场景"></a> 不适合的场景</h3><p><strong>CPU 密集型任务</strong>不适合用虚拟线程。图像处理、加解密、大量数值计算这类任务，线程几乎不阻塞，虚拟线程的优势发挥不出来，这时候老老实实用固定大小的平台线程池反而更合适。</p><pre><code class="highlight java"><span class="comment">// CPU 密集型，用平台线程池</span><span class="type">ExecutorService</span> <span class="variable">cpuPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(    Runtime.getRuntime().availableProcessors());<span class="comment">// IO 密集型，用虚拟线程</span><span class="type">ExecutorService</span> <span class="variable">ioExecutor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor();</code></pre><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3><p><strong>1. 不要池化虚拟线程</strong><br />虚拟线程的创建成本已经极低，不需要也不应该用线程池来复用它们。每个任务直接新建一个虚拟线程即可。</p><pre><code class="highlight java"><span class="comment">// ❌ 错误做法，失去了虚拟线程的意义</span><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">100</span>); <span class="comment">// 还是平台线程池</span><span class="comment">// ✅ 正确做法</span><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor();</code></pre><p><strong>2. 注意 synchronized 的 pinning 问题</strong><br />当虚拟线程在 <code>synchronized</code> 块内发生阻塞时，它无法从载体线程上卸载，会导致载体线程被&quot;钉住&quot;（pinning），影响性能。</p><pre><code class="highlight java"><span class="comment">// ❌ 可能导致 pinning</span><span class="keyword">synchronized</span> (lock) &#123;    <span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> database.query(sql); <span class="comment">// IO 阻塞，但虚拟线程无法卸载</span>&#125;<span class="comment">// ✅ 改用 ReentrantLock</span><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();lock.lock();<span class="keyword">try</span> &#123;    <span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> database.query(sql); <span class="comment">// IO 阻塞，虚拟线程可以正常卸载</span>&#125; <span class="keyword">finally</span> &#123;    lock.unlock();&#125;</code></pre><p>Java 24 之后这个限制已经被移除，但如果你用的是 Java 21，需要留意这一点。<br /><strong>3. ThreadLocal 谨慎使用</strong><br />虚拟线程数量可能达到百万级别，如果每个虚拟线程都往 <code>ThreadLocal</code> 里存大对象，内存压力会很大。Java 21 引入了 <code>ScopedValue</code> 作为更安全的替代方案。</p><pre><code class="highlight java"><span class="comment">// 传统 ThreadLocal（虚拟线程多时要谨慎）</span>ThreadLocal&lt;UserContext&gt; userContext = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();<span class="comment">// ScopedValue（虚拟线程友好，不可变，自动清理）</span><span class="keyword">static</span> <span class="keyword">final</span> ScopedValue&lt;UserContext&gt; USER_CONTEXT = ScopedValue.newInstance();ScopedValue.where(USER_CONTEXT, <span class="keyword">new</span> <span class="title class_">UserContext</span>(userId)).run(() -&gt; &#123;    <span class="comment">// 在这个作用域内可以访问 USER_CONTEXT.get()</span>    processRequest();&#125;);</code></pre><hr /><h2 id="常见误区"><a class="markdownIt-Anchor" href="#常见误区"></a> 常见误区</h2><p><strong>误区一：虚拟线程会让所有程序变快</strong><br />不是的。虚拟线程解决的是 IO 等待造成的线程资源浪费问题。如果你的程序本来就是 CPU 密集型，或者并发量不高，虚拟线程带来的提升非常有限。<br /><strong>误区二：用了虚拟线程就不用关心并发安全</strong><br />虚拟线程只是改变了线程的调度方式，共享状态的并发安全问题依然存在，该加锁的地方还是要加锁。<br /><strong>误区三：虚拟线程可以替代异步编程的所有场景</strong><br />对于需要精细控制背压（Backpressure）、流式处理的场景，响应式编程仍然有其优势。两者并不是非此即彼的关系。</p><hr /><h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2><p>虚拟线程最让人欣慰的地方在于，它几乎没有学习成本和迁移成本。不需要引入新的编程范式，不需要改写业务代码，只需要换一种方式创建线程，就能获得接近响应式的并发能力。<br />对于绝大多数以 IO 操作为主的 Java 后端服务来说，升级到 Java 21 并开启虚拟线程，是一件性价比极高的事情。</p><hr />]]>
    </content>
    <id>http://example.com/2024/03/09/Java-Virtual-Threads/</id>
    <link href="http://example.com/2024/03/09/Java-Virtual-Threads/"/>
    <published>2024-03-09T04:00:00.000Z</published>
    <summary>Java 21 正式引入了虚拟线程，这是 Java 并发编程近十年来最重要的一次变革。虚拟线程是由 JVM 管理的轻量级线程，不直接对应 OS 线程。</summary>
    <title>Java Virtual Threads</title>
    <updated>2026-02-27T06:55:48.969Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Debezium" scheme="http://example.com/tags/Debezium/"/>
    <category term="CDC" scheme="http://example.com/tags/CDC/"/>
    <content>
      <![CDATA[<h1 id="debezium"><a class="markdownIt-Anchor" href="#debezium"></a> Debezium</h1><h2 id="简介与核心概念"><a class="markdownIt-Anchor" href="#简介与核心概念"></a> 简介与核心概念</h2><h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3><p>Debezium 是一个开源的分布式 CDC（变更数据捕获）平台，由 Red Hat 开发并开源。它通过读取数据库的事务日志（如 MySQL 的 binlog、PostgreSQL 的 WAL）来捕获数据变更事件，并将这些事件发布到消息队列（如 Kafka）中，实现实时数据同步。</p><h3 id="cdc捕获变更数据"><a class="markdownIt-Anchor" href="#cdc捕获变更数据"></a> CDC(捕获变更数据)</h3><p>传统数据同步方案的痛点：</p><ul><li>延迟严重：批量处理导致数据延迟</li><li>资源浪费：频繁查询数据库增加负载</li><li>数据不一致：难以保证实时一致性</li><li>复杂维护：自定义脚本难以管理和扩展</li></ul><p>Debezium 通过以下方式解决这些问题：</p><ul><li>实时捕获：毫秒级延迟的变更数据捕获</li><li>低影响：基于数据库日志，不增加数据库负载</li><li>可靠性高：基于成熟的消息队列技术</li><li>易于扩展：支持多种数据库和输出目标</li></ul><h3 id="核心特征"><a class="markdownIt-Anchor" href="#核心特征"></a> 核心特征</h3><ul><li><p>多数据库支持：MySQL、PostgreSQL、MongoDB、Oracle、SQL Server、Db2 等</p></li><li><p>实时性强：基于事务日志捕获，延迟可低至毫秒级</p></li><li><p>低侵入性：仅读取数据库日志，不影响正常业务</p></li><li><p>Exactly-Once 语义：通过 Kafka 事务机制保证数据一致性</p></li><li><p>完整数据变更：捕获 INSERT、UPDATE、DELETE 操作及变更前后镜像</p></li><li><p>Schema 变更同步：自动同步表结构变更事件</p></li><li><p>快照模式：支持初始全量快照 + 增量变更捕获</p></li></ul><h3 id="核心架构"><a class="markdownIt-Anchor" href="#核心架构"></a> 核心架构</h3><p>Debezium 提供三种部署架构：</p><table><thead><tr><th>部署方式</th><th>适用场景</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Apache Kafka Connect​</td><td>生产环境、大规模部署</td><td>高可用、可扩展、与 Kafka 生态集成</td><td>需要维护 Kafka 集群</td></tr><tr><td>独立服务器​</td><td>无 Kafka 环境</td><td>支持多种消息平台（Redis、Kinesis、Pub/Sub）</td><td>功能相对有限</td></tr><tr><td>嵌入式引擎​</td><td>轻量级应用</td><td>无需外部依赖、部署简单</td><td>缺乏高可用保障</td></tr></tbody></table><h3 id="工作流程"><a class="markdownIt-Anchor" href="#工作流程"></a> 工作流程：</h3><ul><li>连接数据库：通过数据库专属连接器获取事务日志读取权限</li><li>实时捕获变更：持续监听数据库事务日志</li><li>生成标准化事件：将变更解析为统一格式的事件</li><li>分发事件流：将事件写入消息队列供下游消费</li></ul><h2 id="部署"><a class="markdownIt-Anchor" href="#部署"></a> 部署</h2><h3 id="docker"><a class="markdownIt-Anchor" href="#docker"></a> docker</h3><p>快速开始：Docker Compose 部署</p><pre><code class="highlight yaml"><span class="comment"># docker-compose.yml</span><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span><span class="attr">services:</span>  <span class="attr">zookeeper:</span>    <span class="attr">image:</span> <span class="string">debezium/zookeeper:2.5</span>    <span class="attr">ports:</span>      <span class="bullet">-</span> <span class="string">&quot;2181:2181&quot;</span>    <span class="attr">kafka:</span>    <span class="attr">image:</span> <span class="string">debezium/kafka:2.5</span>    <span class="attr">ports:</span>      <span class="bullet">-</span> <span class="string">&quot;9092:9092&quot;</span>    <span class="attr">environment:</span>      <span class="bullet">-</span> <span class="string">ZOOKEEPER_CONNECT=zookeeper:2181</span>    <span class="attr">depends_on:</span>      <span class="bullet">-</span> <span class="string">zookeeper</span>    <span class="attr">mysql:</span>    <span class="attr">image:</span> <span class="string">debezium/example-mysql:2.5</span>    <span class="attr">ports:</span>      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span>    <span class="attr">environment:</span>      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span>      <span class="bullet">-</span> <span class="string">MYSQL_USER=dbz</span>      <span class="bullet">-</span> <span class="string">MYSQL_PASSWORD=dbz</span>    <span class="attr">connect:</span>    <span class="attr">image:</span> <span class="string">debezium/connect:2.5</span>    <span class="attr">ports:</span>      <span class="bullet">-</span> <span class="string">&quot;8083:8083&quot;</span>    <span class="attr">environment:</span>      <span class="bullet">-</span> <span class="string">BOOTSTRAP_SERVERS=kafka:9092</span>      <span class="bullet">-</span> <span class="string">GROUP_ID=1</span>      <span class="bullet">-</span> <span class="string">CONFIG_STORAGE_TOPIC=my_connect_configs</span>      <span class="bullet">-</span> <span class="string">OFFSET_STORAGE_TOPIC=my_connect_offsets</span>    <span class="attr">depends_on:</span>      <span class="bullet">-</span> <span class="string">kafka</span>      <span class="bullet">-</span> <span class="string">mysql</span></code></pre><p>启动</p><pre><code class="highlight plaintext">docker-compose up -d</code></pre><h3 id="手动部署"><a class="markdownIt-Anchor" href="#手动部署"></a> 手动部署</h3><p>安装 Kafka Connect</p><pre><code class="highlight bash"><span class="comment"># 下载 Apache Kafka（包含 Kafka Connect）</span>wget https://downloads.apache.org/kafka/3.5.0/kafka_2.13-3.5.0.tgztar -xzf kafka_2.13-3.5.0.tgz<span class="built_in">cd</span> kafka_2.13-3.5.0<span class="comment"># 启动 Zookeeper</span>bin/zookeeper-server-start.sh config/zookeeper.properties &amp;<span class="comment"># 启动 Kafka</span>bin/kafka-server-start.sh config/server.properties &amp;<span class="comment"># 启动 Kafka Connect（独立模式）</span>bin/connect-standalone.sh config/connect-standalone.properties</code></pre><p>安装 Debezium 连接器</p><pre><code class="highlight bash"><span class="comment"># 下载 Debezium MySQL 连接器</span>wget https://repo1.maven.org/maven2/io/debezium/debezium-connector-mysql/2.5.0.Final/debezium-connector-mysql-2.5.0.Final-plugin.tar.gz<span class="comment"># 解压到 Kafka Connect 插件目录</span>tar -xzf debezium-connector-mysql-2.5.0.Final-plugin.tar.gz -C /path/to/kafka/plugins/<span class="comment"># 配置 Kafka Connect 插件路径</span><span class="comment"># 编辑 config/connect-standalone.properties</span>plugin.path=/path/to/kafka/plugins</code></pre><h2 id="数据库配置"><a class="markdownIt-Anchor" href="#数据库配置"></a> 数据库配置</h2><h3 id="mysql"><a class="markdownIt-Anchor" href="#mysql"></a> mysql</h3><pre><code class="highlight sql"><span class="comment">-- 1. 创建 Debezium 用户</span><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;debezium&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;dbz&#x27;</span>;<span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, RELOAD, <span class="keyword">SHOW</span> DATABASES, REPLICATION SLAVE, REPLICATION CLIENT <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;debezium&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;<span class="comment">-- 2. 检查 binlog 配置</span><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;log_bin&#x27;</span>;  <span class="comment">-- 应为 ON</span><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;binlog_format&#x27;</span>;  <span class="comment">-- 应为 ROW</span><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;binlog_row_image&#x27;</span>;  <span class="comment">-- 应为 FULL</span><span class="comment">-- 3. 修改 MySQL 配置文件（my.cnf）</span>[mysqld]server<span class="operator">-</span>id         <span class="operator">=</span> <span class="number">223344</span>log_bin           <span class="operator">=</span> mysql<span class="operator">-</span>binbinlog_format     <span class="operator">=</span> <span class="type">ROW</span>binlog_row_image  <span class="operator">=</span> <span class="keyword">FULL</span>expire_logs_days  <span class="operator">=</span> <span class="number">10</span></code></pre><h3 id="pg"><a class="markdownIt-Anchor" href="#pg"></a> pg</h3><pre><code class="highlight sql"><span class="comment">-- 1. 修改 postgresql.conf</span>wal_level <span class="operator">=</span> logicalmax_replication_slots <span class="operator">=</span> <span class="number">10</span>max_wal_senders <span class="operator">=</span> <span class="number">10</span><span class="comment">-- 2. 创建复制用户</span><span class="keyword">CREATE</span> <span class="keyword">USER</span> debezium <span class="keyword">WITH</span> REPLICATION LOGIN PASSWORD <span class="string">&#x27;dbz&#x27;</span>;<span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> debezium;<span class="comment">-- 3. 设置表 REPLICA IDENTITY（用于 UPDATE/DELETE）</span><span class="keyword">ALTER TABLE</span> your_table REPLICA <span class="keyword">IDENTITY</span> <span class="keyword">FULL</span>;</code></pre><h2 id="debezium-核心配置与使用"><a class="markdownIt-Anchor" href="#debezium-核心配置与使用"></a> Debezium 核心配置与使用</h2><h3 id="连接器配置详解"><a class="markdownIt-Anchor" href="#连接器配置详解"></a> 连接器配置详解</h3><p>MySQL 连接器配置</p><pre><code class="highlight json"><span class="punctuation">&#123;</span>  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inventory-connector&quot;</span><span class="punctuation">,</span>  <span class="attr">&quot;config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>    <span class="attr">&quot;connector.class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;io.debezium.connector.mysql.MySqlConnector&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;tasks.max&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.hostname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3306&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;debezium&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dbz&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.server.id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;184054&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.server.name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dbserver1&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.include.list&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inventory&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;table.include.list&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inventory.customers,inventory.orders&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;topic.prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mysql&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;schema.history.internal.kafka.bootstrap.servers&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost:9092&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;schema.history.internal.kafka.topic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;schema-changes.inventory&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;include.schema.changes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;true&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;snapshot.mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;initial&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;snapshot.locking.mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;minimal&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;decimal.handling.mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;double&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;time.precision.mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;connect&quot;</span>  <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></code></pre><p>pg连接器配置</p><pre><code class="highlight json"><span class="punctuation">&#123;</span>  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;postgres-connector&quot;</span><span class="punctuation">,</span>  <span class="attr">&quot;config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>    <span class="attr">&quot;connector.class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;io.debezium.connector.postgresql.PostgresConnector&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;tasks.max&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.hostname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5432&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;debezium&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dbz&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.dbname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;postgres&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.server.name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;postgres-server&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;plugin.name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pgoutput&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;slot.name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;debezium_slot&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;publication.name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;debezium_pub&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;table.include.list&quot;</span><span class="punctuation">:</span> <span class="string">&quot;public.users,public.orders&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;schema.history.internal.kafka.bootstrap.servers&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost:9092&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;schema.history.internal.kafka.topic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;schema-changes.postgres&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;snapshot.mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;initial&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;tombstones.on.delete&quot;</span><span class="punctuation">:</span> <span class="string">&quot;true&quot;</span>  <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></code></pre><h3 id="注册连接器"><a class="markdownIt-Anchor" href="#注册连接器"></a> 注册连接器</h3><pre><code class="highlight java"># 使用 REST API 注册连接器curl -i -X POST -H <span class="string">&quot;Accept:application/json&quot;</span> \  -H <span class="string">&quot;Content-Type:application/json&quot;</span> \  http:<span class="comment">//localhost:8083/connectors/ \</span>  -d <span class="string">&#x27;&#123;</span><span class="string">    &quot;name&quot;: &quot;inventory-connector&quot;,</span><span class="string">    &quot;config&quot;: &#123;</span><span class="string">      &quot;connector.class&quot;: &quot;io.debezium.connector.mysql.MySqlConnector&quot;,</span><span class="string">      &quot;tasks.max&quot;: &quot;1&quot;,</span><span class="string">      &quot;database.hostname&quot;: &quot;mysql&quot;,</span><span class="string">      &quot;database.port&quot;: &quot;3306&quot;,</span><span class="string">      &quot;database.user&quot;: &quot;dbz&quot;,</span><span class="string">      &quot;database.password&quot;: &quot;dbz&quot;,</span><span class="string">      &quot;database.server.id&quot;: &quot;184054&quot;,</span><span class="string">      &quot;topic.prefix&quot;: &quot;dbserver1&quot;,</span><span class="string">      &quot;schema.history.internal.kafka.bootstrap.servers&quot;: &quot;kafka:9092&quot;,</span><span class="string">      &quot;schema.history.internal.kafka.topic&quot;: &quot;schema-changes.inventory&quot;</span><span class="string">    &#125;</span><span class="string">  &#125;&#x27;</span></code></pre><h3 id="快照模式"><a class="markdownIt-Anchor" href="#快照模式"></a> 快照模式</h3><table><thead><tr><th>快照模式</th><th>描述</th><th>适用场景</th></tr></thead><tbody><tr><td>initial（默认）</td><td>首次启动时执行全量快照，然后切换到增量捕获</td><td>首次同步，需要历史数据</td></tr><tr><td>initial_only​</td><td>只执行全量快照，不进行增量捕获</td><td>一次性数据导出</td></tr><tr><td>schema_only​</td><td>只捕获表结构，不捕获数据</td><td>仅需表结构同步</td></tr><tr><td>schema_only_recovery​</td><td>恢复丢失的 schema 历史记录</td><td>故障恢复</td></tr><tr><td>never​</td><td>不执行快照，只捕获启动后的变更</td><td>仅需增量数据</td></tr><tr><td>when_needed​</td><td>仅在需要时执行快照</td><td>灵活控制</td></tr></tbody></table><h3 id="事件数据结构"><a class="markdownIt-Anchor" href="#事件数据结构"></a> 事件数据结构</h3><p>Debezium 生成的变更事件采用标准化的 JSON 格式：</p><p>关键字段说明：</p><ul><li>before：变更前的数据（DELETE 和 UPDATE 操作）</li><li>after：变更后的数据（INSERT 和 UPDATE 操作）</li><li>op：操作类型（c=CREATE, u=UPDATE, d=DELETE, r=READ）</li><li>source：源数据库元数据</li><li>ts_ms：事件时间戳</li></ul><pre><code class="highlight json"><span class="punctuation">&#123;</span>  <span class="attr">&quot;before&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1004</span><span class="punctuation">,</span>    <span class="attr">&quot;first_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Anne&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;last_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Kretchmar&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;annek@noanswer.org&quot;</span>  <span class="punctuation">&#125;</span><span class="punctuation">,</span>  <span class="attr">&quot;after&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1004</span><span class="punctuation">,</span>    <span class="attr">&quot;first_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Anne&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;last_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Kretchmar&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;anne@example.com&quot;</span>  <span class="punctuation">&#125;</span><span class="punctuation">,</span>  <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.5.0.Final&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;connector&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mysql&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dbserver1&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;ts_ms&quot;</span><span class="punctuation">:</span> <span class="number">1704067200000</span><span class="punctuation">,</span>    <span class="attr">&quot;snapshot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;db&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inventory&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;customers&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;server_id&quot;</span><span class="punctuation">:</span> <span class="number">223344</span><span class="punctuation">,</span>    <span class="attr">&quot;gtid&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>    <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mysql-bin.000003&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;pos&quot;</span><span class="punctuation">:</span> <span class="number">154</span><span class="punctuation">,</span>    <span class="attr">&quot;row&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span>    <span class="attr">&quot;thread&quot;</span><span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span>    <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span>  <span class="punctuation">&#125;</span><span class="punctuation">,</span>  <span class="attr">&quot;op&quot;</span><span class="punctuation">:</span> <span class="string">&quot;u&quot;</span><span class="punctuation">,</span>  <span class="attr">&quot;ts_ms&quot;</span><span class="punctuation">:</span> <span class="number">1704067201000</span><span class="punctuation">,</span>  <span class="attr">&quot;transaction&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">&#125;</span></code></pre><h2 id="常用场景"><a class="markdownIt-Anchor" href="#常用场景"></a> 常用场景</h2><h3 id="mysql-到-kafka-实时数据同步"><a class="markdownIt-Anchor" href="#mysql-到-kafka-实时数据同步"></a> MySQL 到 Kafka 实时数据同步</h3><p>环境准备</p><pre><code class="highlight sql"><span class="comment">-- 创建测试数据库和表</span><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> inventory;USE inventory;<span class="keyword">CREATE TABLE</span> customers (  id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,  first_name <span class="type">VARCHAR</span>(<span class="number">50</span>),  last_name <span class="type">VARCHAR</span>(<span class="number">50</span>),  email <span class="type">VARCHAR</span>(<span class="number">100</span>),  created_at <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,  updated_at <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>);<span class="keyword">CREATE TABLE</span> orders (  id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,  customer_id <span class="type">INT</span>,  order_date <span class="type">DATE</span>,  total_amount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),  status <span class="type">VARCHAR</span>(<span class="number">20</span>),  <span class="keyword">FOREIGN KEY</span> (customer_id) <span class="keyword">REFERENCES</span> customers(id));</code></pre><p>连接器配置</p><pre><code class="highlight json"><span class="punctuation">&#123;</span>  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mysql-inventory-connector&quot;</span><span class="punctuation">,</span>  <span class="attr">&quot;config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>    <span class="attr">&quot;connector.class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;io.debezium.connector.mysql.MySqlConnector&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;tasks.max&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.hostname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3306&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;debezium&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dbz&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.server.id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;184054&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.server.name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mysql-server&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.include.list&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inventory&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;table.include.list&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inventory.customers,inventory.orders&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;topic.prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mysql&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;schema.history.internal.kafka.bootstrap.servers&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost:9092&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;schema.history.internal.kafka.topic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;schema-history.inventory&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;include.schema.changes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;true&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;snapshot.mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;initial&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;snapshot.locking.mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;minimal&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;decimal.handling.mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;double&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;time.precision.mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;connect&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;transforms&quot;</span><span class="punctuation">:</span> <span class="string">&quot;unwrap&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;transforms.unwrap.type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;io.debezium.transforms.ExtractNewRecordState&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;transforms.unwrap.drop.tombstones&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;transforms.unwrap.delete.handling.mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rewrite&quot;</span>  <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></code></pre><p>验证</p><pre><code class="highlight bash"><span class="comment"># 查看 Kafka Topic</span>./kafka-topics.sh --list --bootstrap-server localhost:9092<span class="comment"># 消费变更事件</span>./kafka-console-consumer.sh \  --bootstrap-server localhost:9092 \  --topic mysql.inventory.customers \  --from-beginning<span class="comment"># 在 MySQL 中执行操作</span>INSERT INTO customers (first_name, last_name, email) VALUES (<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Doe&#x27;</span>, <span class="string">&#x27;john.doe@example.com&#x27;</span>);UPDATE customers SET email = <span class="string">&#x27;john.new@example.com&#x27;</span> WHERE <span class="built_in">id</span> = 1;DELETE FROM customers WHERE <span class="built_in">id</span> = 1;</code></pre><h3 id="嵌入式-debeziumjava-应用集成"><a class="markdownIt-Anchor" href="#嵌入式-debeziumjava-应用集成"></a> 嵌入式 Debezium（Java 应用集成）</h3><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.debezium<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>debezium-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.debezium<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>debezium-embedded<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.debezium<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>debezium-connector-mysql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><pre><code class="highlight java"><span class="keyword">import</span> io.debezium.engine.ChangeEvent;<span class="keyword">import</span> io.debezium.engine.DebeziumEngine;<span class="keyword">import</span> io.debezium.engine.format.Json;<span class="keyword">import</span> org.apache.kafka.connect.source.SourceRecord;<span class="keyword">import</span> java.io.IOException;<span class="keyword">import</span> java.util.Properties;<span class="keyword">import</span> java.util.concurrent.ExecutorService;<span class="keyword">import</span> java.util.concurrent.Executors;<span class="keyword">import</span> java.util.concurrent.TimeUnit;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmbeddedDebeziumExample</span> &#123;        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;        <span class="comment">// 配置属性</span>        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();        props.setProperty(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;embedded-engine&quot;</span>);        props.setProperty(<span class="string">&quot;connector.class&quot;</span>, <span class="string">&quot;io.debezium.connector.mysql.MySqlConnector&quot;</span>);                <span class="comment">// 偏移量存储配置</span>        props.setProperty(<span class="string">&quot;offset.storage&quot;</span>, <span class="string">&quot;org.apache.kafka.connect.storage.FileOffsetBackingStore&quot;</span>);        props.setProperty(<span class="string">&quot;offset.storage.file.filename&quot;</span>, <span class="string">&quot;/tmp/offsets.dat&quot;</span>);        props.setProperty(<span class="string">&quot;offset.flush.interval.ms&quot;</span>, <span class="string">&quot;60000&quot;</span>);                <span class="comment">// MySQL 连接配置</span>        props.setProperty(<span class="string">&quot;database.hostname&quot;</span>, <span class="string">&quot;localhost&quot;</span>);        props.setProperty(<span class="string">&quot;database.port&quot;</span>, <span class="string">&quot;3306&quot;</span>);        props.setProperty(<span class="string">&quot;database.user&quot;</span>, <span class="string">&quot;debezium&quot;</span>);        props.setProperty(<span class="string">&quot;database.password&quot;</span>, <span class="string">&quot;dbz&quot;</span>);        props.setProperty(<span class="string">&quot;database.server.id&quot;</span>, <span class="string">&quot;85744&quot;</span>);        props.setProperty(<span class="string">&quot;database.server.name&quot;</span>, <span class="string">&quot;embedded-mysql&quot;</span>);        props.setProperty(<span class="string">&quot;database.include.list&quot;</span>, <span class="string">&quot;inventory&quot;</span>);        props.setProperty(<span class="string">&quot;table.include.list&quot;</span>, <span class="string">&quot;inventory.customers&quot;</span>);                <span class="comment">// 历史记录存储</span>        props.setProperty(<span class="string">&quot;database.history&quot;</span>, <span class="string">&quot;io.debezium.relational.history.FileDatabaseHistory&quot;</span>);        props.setProperty(<span class="string">&quot;database.history.file.filename&quot;</span>, <span class="string">&quot;/tmp/dbhistory.dat&quot;</span>);                <span class="comment">// 快照配置</span>        props.setProperty(<span class="string">&quot;snapshot.mode&quot;</span>, <span class="string">&quot;initial&quot;</span>);        props.setProperty(<span class="string">&quot;snapshot.locking.mode&quot;</span>, <span class="string">&quot;minimal&quot;</span>);                <span class="comment">// 创建 Debezium 引擎</span>        <span class="keyword">try</span> (DebeziumEngine&lt;ChangeEvent&lt;String, String&gt;&gt; engine = DebeziumEngine                .create(Json.class)                .using(props)                .notifying(record -&gt; &#123;                    <span class="comment">// 处理变更事件</span>                    System.out.println(<span class="string">&quot;Key: &quot;</span> + record.key());                    System.out.println(<span class="string">&quot;Value: &quot;</span> + record.value());                    System.out.println(<span class="string">&quot;Destination: &quot;</span> + record.destination());                                        <span class="comment">// 解析 JSON 事件</span>                    <span class="comment">// 这里可以添加业务逻辑，如写入本地文件、调用API等</span>                    processChangeEvent(record.value());                &#125;)                .using((success, message, error) -&gt; &#123;                    <span class="comment">// 完成回调</span>                    <span class="keyword">if</span> (error != <span class="literal">null</span>) &#123;                        System.err.println(<span class="string">&quot;Engine failed: &quot;</span> + message + <span class="string">&quot;, error: &quot;</span> + error);                    &#125; <span class="keyword">else</span> &#123;                        System.out.println(<span class="string">&quot;Engine completed: &quot;</span> + message);                    &#125;                &#125;)                .build()) &#123;                        <span class="comment">// 异步执行引擎</span>            <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();            executor.execute(engine);                        <span class="comment">// 等待终止信号</span>            Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                System.out.println(<span class="string">&quot;Requesting engine to stop...&quot;</span>);                <span class="keyword">try</span> &#123;                    engine.close();                &#125; <span class="keyword">catch</span> (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;));                        <span class="comment">// 保持主线程运行</span>            <span class="keyword">while</span> (!executor.isTerminated()) &#123;                <span class="keyword">try</span> &#123;                    executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    Thread.currentThread().interrupt();                    <span class="keyword">break</span>;                &#125;            &#125;        &#125;    &#125;        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processChangeEvent</span><span class="params">(String jsonEvent)</span> &#123;        <span class="comment">// 解析和处理变更事件的业务逻辑</span>        <span class="comment">// 示例：将事件发送到消息队列、更新缓存、写入文件等</span>        System.out.println(<span class="string">&quot;Processing event: &quot;</span> + jsonEvent);                <span class="comment">// 这里可以添加具体的业务处理逻辑</span>        <span class="comment">// 例如：解析JSON，提取关键信息，调用其他服务等</span>    &#125;&#125;</code></pre><h3 id="spring-boot集成"><a class="markdownIt-Anchor" href="#spring-boot集成"></a> Spring Boot集成</h3><pre><code class="highlight java"><span class="keyword">import</span> io.debezium.engine.ChangeEvent;<span class="keyword">import</span> io.debezium.engine.DebeziumEngine;<span class="keyword">import</span> io.debezium.engine.format.Json;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;<span class="keyword">import</span> org.springframework.boot.CommandLineRunner;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.context.annotation.Bean;<span class="keyword">import</span> org.springframework.stereotype.Component;<span class="keyword">import</span> java.io.IOException;<span class="keyword">import</span> java.util.Properties;<span class="keyword">import</span> java.util.concurrent.Executor;<span class="keyword">import</span> java.util.concurrent.Executors;<span class="meta">@SpringBootApplication</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebeziumApplication</span> &#123;        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(DebeziumApplication.class, args);    &#125;        <span class="meta">@Bean</span>    <span class="keyword">public</span> Executor <span class="title function_">debeziumExecutor</span><span class="params">()</span> &#123;        <span class="keyword">return</span> Executors.newSingleThreadExecutor();    &#125;&#125;<span class="meta">@Component</span><span class="keyword">class</span> <span class="title class_">DebeziumRunner</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;        <span class="meta">@Value(&quot;$&#123;debezium.database.hostname&#125;&quot;)</span>    <span class="keyword">private</span> String dbHostname;        <span class="meta">@Value(&quot;$&#123;debezium.database.port&#125;&quot;)</span>    <span class="keyword">private</span> String dbPort;        <span class="meta">@Value(&quot;$&#123;debezium.database.user&#125;&quot;)</span>    <span class="keyword">private</span> String dbUser;        <span class="meta">@Value(&quot;$&#123;debezium.database.password&#125;&quot;)</span>    <span class="keyword">private</span> String dbPassword;        <span class="meta">@Value(&quot;$&#123;debezium.database.name&#125;&quot;)</span>    <span class="keyword">private</span> String dbName;        <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;    <span class="keyword">private</span> DebeziumEngine&lt;?&gt; engine;        <span class="keyword">public</span> <span class="title function_">DebeziumRunner</span><span class="params">(Executor executor)</span> &#123;        <span class="built_in">this</span>.executor = executor;    &#125;        <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();        props.setProperty(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;spring-debezium-engine&quot;</span>);        props.setProperty(<span class="string">&quot;connector.class&quot;</span>, <span class="string">&quot;io.debezium.connector.mysql.MySqlConnector&quot;</span>);        props.setProperty(<span class="string">&quot;offset.storage&quot;</span>, <span class="string">&quot;org.apache.kafka.connect.storage.FileOffsetBackingStore&quot;</span>);        props.setProperty(<span class="string">&quot;offset.storage.file.filename&quot;</span>, <span class="string">&quot;/tmp/spring-offsets.dat&quot;</span>);        props.setProperty(<span class="string">&quot;offset.flush.interval.ms&quot;</span>, <span class="string">&quot;60000&quot;</span>);                props.setProperty(<span class="string">&quot;database.hostname&quot;</span>, dbHostname);        props.setProperty(<span class="string">&quot;database.port&quot;</span>, dbPort);        props.setProperty(<span class="string">&quot;database.user&quot;</span>, dbUser);        props.setProperty(<span class="string">&quot;database.password&quot;</span>, dbPassword);        props.setProperty(<span class="string">&quot;database.server.id&quot;</span>, <span class="string">&quot;85745&quot;</span>);        props.setProperty(<span class="string">&quot;database.server.name&quot;</span>, <span class="string">&quot;spring-mysql&quot;</span>);        props.setProperty(<span class="string">&quot;database.include.list&quot;</span>, dbName);                props.setProperty(<span class="string">&quot;database.history&quot;</span>, <span class="string">&quot;io.debezium.relational.history.FileDatabaseHistory&quot;</span>);        props.setProperty(<span class="string">&quot;database.history.file.filename&quot;</span>, <span class="string">&quot;/tmp/spring-dbhistory.dat&quot;</span>);        props.setProperty(<span class="string">&quot;snapshot.mode&quot;</span>, <span class="string">&quot;initial&quot;</span>);                <span class="comment">// 创建引擎</span>        engine = DebeziumEngine.create(Json.class)                .using(props)                .notifying(<span class="built_in">this</span>::handleChangeEvent)                .using((success, message, error) -&gt; &#123;                    <span class="keyword">if</span> (error != <span class="literal">null</span>) &#123;                        System.err.println(<span class="string">&quot;Debezium engine failed: &quot;</span> + message);                        error.printStackTrace();                    &#125;                &#125;)                .build();                <span class="comment">// 异步执行</span>        executor.execute(engine);    &#125;        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleChangeEvent</span><span class="params">(ChangeEvent&lt;String, String&gt; event)</span> &#123;        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> event.key();        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> event.value();        <span class="type">String</span> <span class="variable">destination</span> <span class="operator">=</span> event.destination();                System.out.println(<span class="string">&quot;Destination: &quot;</span> + destination);        System.out.println(<span class="string">&quot;Key: &quot;</span> + key);        System.out.println(<span class="string">&quot;Value: &quot;</span> + value);                <span class="comment">// 业务处理逻辑</span>        <span class="comment">// 可以注入Spring Bean进行业务处理</span>    &#125;        <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="keyword">if</span> (engine != <span class="literal">null</span>) &#123;            <span class="keyword">try</span> &#123;                engine.close();            &#125; <span class="keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="夺标合并到单一topic"><a class="markdownIt-Anchor" href="#夺标合并到单一topic"></a> 夺标合并到单一Topic</h3><pre><code class="highlight json"><span class="punctuation">&#123;</span>  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;multi-table-connector&quot;</span><span class="punctuation">,</span>  <span class="attr">&quot;config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>    <span class="attr">&quot;connector.class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;io.debezium.connector.mysql.MySqlConnector&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;tasks.max&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.hostname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3306&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;debezium&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dbz&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.server.id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;184055&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.server.name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;multi-table-server&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.include.list&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ecommerce&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;table.include.list&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ecommerce.orders,ecommerce.customers,ecommerce.products&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;topic.prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ecommerce&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;transforms&quot;</span><span class="punctuation">:</span> <span class="string">&quot;route&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;transforms.route.type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.apache.kafka.connect.transforms.RegexRouter&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;transforms.route.regex&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ecommerce\\.(.*)&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;transforms.route.replacement&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ecommerce-all-changes&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;transforms.route.by.field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;table&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;key.converter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.apache.kafka.connect.json.JsonConverter&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;key.converter.schemas.enable&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;value.converter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.apache.kafka.connect.json.JsonConverter&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;value.converter.schemas.enable&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span>  <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></code></pre><p>事件路由处理器</p><pre><code class="highlight java"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonNode;<span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;<span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;<span class="keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;<span class="keyword">import</span> java.time.Duration;<span class="keyword">import</span> java.util.Collections;<span class="keyword">import</span> java.util.Properties;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiTableConsumer</span> &#123;        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);        props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;multi-table-consumer&quot;</span>);        props.put(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);        props.put(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);        props.put(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;earliest&quot;</span>);                <span class="keyword">try</span> (KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(props)) &#123;            consumer.subscribe(Collections.singletonList(<span class="string">&quot;ecommerce-all-changes&quot;</span>));                        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;                ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">100</span>));                                <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;                    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> record.value();                    <span class="type">JsonNode</span> <span class="variable">event</span> <span class="operator">=</span> mapper.readTree(value);                                        <span class="comment">// 根据表名路由处理</span>                    <span class="type">String</span> <span class="variable">tableName</span> <span class="operator">=</span> event.path(<span class="string">&quot;source&quot;</span>).path(<span class="string">&quot;table&quot;</span>).asText();                    <span class="type">String</span> <span class="variable">operation</span> <span class="operator">=</span> event.path(<span class="string">&quot;op&quot;</span>).asText();                                        <span class="keyword">switch</span> (tableName) &#123;                        <span class="keyword">case</span> <span class="string">&quot;orders&quot;</span>:                            processOrderEvent(event, operation);                            <span class="keyword">break</span>;                        <span class="keyword">case</span> <span class="string">&quot;customers&quot;</span>:                            processCustomerEvent(event, operation);                            <span class="keyword">break</span>;                        <span class="keyword">case</span> <span class="string">&quot;products&quot;</span>:                            processProductEvent(event, operation);                            <span class="keyword">break</span>;                        <span class="keyword">default</span>:                            System.out.println(<span class="string">&quot;Unknown table: &quot;</span> + tableName);                    &#125;                &#125;            &#125;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processOrderEvent</span><span class="params">(JsonNode event, String operation)</span> &#123;        <span class="type">JsonNode</span> <span class="variable">after</span> <span class="operator">=</span> event.path(<span class="string">&quot;after&quot;</span>);        <span class="type">JsonNode</span> <span class="variable">before</span> <span class="operator">=</span> event.path(<span class="string">&quot;before&quot;</span>);                <span class="keyword">switch</span> (operation) &#123;            <span class="keyword">case</span> <span class="string">&quot;c&quot;</span>: <span class="comment">// CREATE</span>                System.out.println(<span class="string">&quot;New order created: &quot;</span> + after);                <span class="comment">// 发送订单创建通知、更新库存等</span>                <span class="keyword">break</span>;            <span class="keyword">case</span> <span class="string">&quot;u&quot;</span>: <span class="comment">// UPDATE</span>                System.out.println(<span class="string">&quot;Order updated: &quot;</span> + before + <span class="string">&quot; -&gt; &quot;</span> + after);                <span class="comment">// 处理订单状态变更</span>                <span class="keyword">break</span>;            <span class="keyword">case</span> <span class="string">&quot;d&quot;</span>: <span class="comment">// DELETE</span>                System.out.println(<span class="string">&quot;Order deleted: &quot;</span> + before);                <span class="comment">// 处理订单删除逻辑</span>                <span class="keyword">break</span>;        &#125;    &#125;        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processCustomerEvent</span><span class="params">(JsonNode event, String operation)</span> &#123;        <span class="comment">// 客户信息变更处理逻辑</span>        System.out.println(<span class="string">&quot;Customer event: &quot;</span> + operation + <span class="string">&quot; - &quot;</span> + event);    &#125;        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processProductEvent</span><span class="params">(JsonNode event, String operation)</span> &#123;        <span class="comment">// 商品信息变更处理逻辑</span>        System.out.println(<span class="string">&quot;Product event: &quot;</span> + operation + <span class="string">&quot; - &quot;</span> + event);    &#125;&#125;</code></pre><h2 id="高可用配置"><a class="markdownIt-Anchor" href="#高可用配置"></a> 高可用配置</h2><p>Kafka Connect 集群部署</p><pre><code class="highlight properties"><span class="comment"># config/connect-distributed.properties</span><span class="attr">bootstrap.servers</span>=<span class="string">kafka1:9092,kafka2:9092,kafka3:9092</span><span class="attr">group.id</span>=<span class="string">connect-cluster</span><span class="attr">key.converter</span>=<span class="string">org.apache.kafka.connect.json.JsonConverter</span><span class="attr">value.converter</span>=<span class="string">org.apache.kafka.connect.json.JsonConverter</span><span class="attr">key.converter.schemas.enable</span>=<span class="string">true</span><span class="attr">value.converter.schemas.enable</span>=<span class="string">true</span><span class="attr">offset.storage.topic</span>=<span class="string">connect-offsets</span><span class="attr">config.storage.topic</span>=<span class="string">connect-configs</span><span class="attr">status.storage.topic</span>=<span class="string">connect-status</span><span class="attr">offset.storage.replication.factor</span>=<span class="string">3</span><span class="attr">config.storage.replication.factor</span>=<span class="string">3</span><span class="attr">status.storage.replication.factor</span>=<span class="string">3</span><span class="attr">plugin.path</span>=<span class="string">/usr/share/java,/usr/share/kafka/plugins</span></code></pre><p>连接器高可用配置</p><pre><code class="highlight json"><span class="punctuation">&#123;</span>  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ha-mysql-connector&quot;</span><span class="punctuation">,</span>  <span class="attr">&quot;config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>    <span class="attr">&quot;connector.class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;io.debezium.connector.mysql.MySqlConnector&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;tasks.max&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3&quot;</span><span class="punctuation">,</span>  <span class="comment">// 增加任务数提高并行度</span>    <span class="attr">&quot;database.hostname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mysql-cluster&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3306&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;debezium&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dbz&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.server.id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;184054&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.server.name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ha-mysql-server&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.history.kafka.bootstrap.servers&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kafka1:9092,kafka2:9092,kafka3:9092&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.history.kafka.topic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;schema-history.ha&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.history.kafka.recovery.poll.interval.ms&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5000&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.history.skip.unparseable.ddl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;true&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;snapshot.mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;when_needed&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;snapshot.locking.mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;minimal&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;snapshot.delay.ms&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10000&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;heartbeat.interval.ms&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5000&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;heartbeat.topics.prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;__debezium-heartbeat&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;max.batch.size&quot;</span><span class="punctuation">:</span> <span class="string">&quot;20480&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;max.queue.size&quot;</span><span class="punctuation">:</span> <span class="string">&quot;81920&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;poll.interval.ms&quot;</span><span class="punctuation">:</span> <span class="string">&quot;500&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;connect.keep.alive&quot;</span><span class="punctuation">:</span> <span class="string">&quot;true&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;connect.timeout.ms&quot;</span><span class="punctuation">:</span> <span class="string">&quot;30000&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;connection.timeout.ms&quot;</span><span class="punctuation">:</span> <span class="string">&quot;30000&quot;</span>  <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></code></pre><h2 id="性能优化"><a class="markdownIt-Anchor" href="#性能优化"></a> 性能优化</h2><p>MySQL 性能优化</p><pre><code class="highlight sql"><span class="comment">-- 优化 binlog 设置</span><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> binlog_row_image <span class="operator">=</span> <span class="string">&#x27;MINIMAL&#x27;</span>;  <span class="comment">-- 只记录变更的列</span><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> binlog_rows_query_log_events <span class="operator">=</span> <span class="keyword">ON</span>;  <span class="comment">-- 记录原始SQL</span><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> binlog_cache_size <span class="operator">=</span> <span class="number">32768</span>;  <span class="comment">-- 增加缓存大小</span><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> max_binlog_size <span class="operator">=</span> <span class="number">1073741824</span>;  <span class="comment">-- 1GB</span><span class="comment">-- 监控 binlog 状态</span><span class="keyword">SHOW</span> <span class="type">BINARY</span> LOGS;<span class="keyword">SHOW</span> BINLOG EVENTS;<span class="keyword">SHOW</span> SLAVE STATUS;</code></pre><p>Debezium连接器优化</p><pre><code class="highlight json"><span class="punctuation">&#123;</span>  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;optimized-mysql-connector&quot;</span><span class="punctuation">,</span>  <span class="attr">&quot;config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>    <span class="attr">&quot;connector.class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;io.debezium.connector.mysql.MySqlConnector&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;tasks.max&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.hostname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mysql&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3306&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;debezium&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;database.password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dbz&quot;</span><span class="punctuation">,</span>        <span class="comment">// 性能优化参数</span>    <span class="attr">&quot;max.batch.size&quot;</span><span class="punctuation">:</span> <span class="string">&quot;20480&quot;</span><span class="punctuation">,</span>  <span class="comment">// 每批最大记录数</span>    <span class="attr">&quot;max.queue.size&quot;</span><span class="punctuation">:</span> <span class="string">&quot;81920&quot;</span><span class="punctuation">,</span>  <span class="comment">// 队列最大容量</span>    <span class="attr">&quot;poll.interval.ms&quot;</span><span class="punctuation">:</span> <span class="string">&quot;100&quot;</span><span class="punctuation">,</span>  <span class="comment">// 轮询间隔</span>    <span class="attr">&quot;snapshot.fetch.size&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2000&quot;</span><span class="punctuation">,</span>  <span class="comment">// 快照批次大小</span>        <span class="comment">// 内存优化</span>    <span class="attr">&quot;binary.handling.mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bytes&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;decimal.handling.mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;double&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;time.precision.mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;connect&quot;</span><span class="punctuation">,</span>        <span class="comment">// 网络优化</span>    <span class="attr">&quot;connect.timeout.ms&quot;</span><span class="punctuation">:</span> <span class="string">&quot;30000&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;connection.timeout.ms&quot;</span><span class="punctuation">:</span> <span class="string">&quot;30000&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;keep.alive&quot;</span><span class="punctuation">:</span> <span class="string">&quot;true&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;keep.alive.interval.ms&quot;</span><span class="punctuation">:</span> <span class="string">&quot;60000&quot;</span><span class="punctuation">,</span>        <span class="comment">// 容错配置</span>    <span class="attr">&quot;errors.tolerance&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span><span class="punctuation">,</span>  <span class="comment">// 容忍所有错误</span>    <span class="attr">&quot;errors.log.enable&quot;</span><span class="punctuation">:</span> <span class="string">&quot;true&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;errors.log.include.messages&quot;</span><span class="punctuation">:</span> <span class="string">&quot;true&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;errors.retry.delay.max.ms&quot;</span><span class="punctuation">:</span> <span class="string">&quot;60000&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;errors.retry.timeout&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span>  <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></code></pre><h2 id="监控"><a class="markdownIt-Anchor" href="#监控"></a> 监控</h2><p>JMX监控配置</p><pre><code class="highlight properties"><span class="comment"># Kafka Connect JMX 配置</span><span class="attr">JMX_PORT</span>=<span class="string">9999</span><span class="attr">KAFKA_JMX_OPTS</span>=<span class="string">&quot;-Dcom.sun.management.jmxremote \</span><span class="string">  -Dcom.sun.management.jmxremote.authenticate=false \</span><span class="string">  -Dcom.sun.management.jmxremote.ssl=false \</span><span class="string">  -Dcom.sun.management.jmxremote.port=9999 \</span><span class="string">  -Djava.rmi.server.hostname=localhost&quot;</span></code></pre><p>关键监控指标</p><pre><code class="highlight bash"><span class="comment"># 查看连接器状态</span>curl -s http://localhost:8083/connectors | jq .<span class="comment"># 查看特定连接器状态</span>curl -s http://localhost:8083/connectors/mysql-connector/status | jq .<span class="comment"># 查看任务状态</span>curl -s http://localhost:8083/connectors/mysql-connector/tasks | jq .<span class="comment"># 重启连接器</span>curl -X POST http://localhost:8083/connectors/mysql-connector/restart<span class="comment"># 暂停连接器</span>curl -X PUT http://localhost:8083/connectors/mysql-connector/pause<span class="comment"># 恢复连接器</span>curl -X PUT http://localhost:8083/connectors/mysql-connector/resume</code></pre><p>Prometheus监控配置</p><pre><code class="highlight yaml"><span class="comment"># prometheus.yml</span><span class="attr">scrape_configs:</span>  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;kafka-connect&#x27;</span>    <span class="attr">static_configs:</span>      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;connect1:8083&#x27;</span>, <span class="string">&#x27;connect2:8083&#x27;</span>, <span class="string">&#x27;connect3:8083&#x27;</span>]    <span class="attr">metrics_path:</span> <span class="string">&#x27;/metrics&#x27;</span>      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;debezium-metrics&#x27;</span>    <span class="attr">static_configs:</span>      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;localhost:9999&#x27;</span>]    <span class="attr">relabel_configs:</span>      <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__address__</span>]        <span class="attr">target_label:</span> <span class="string">instance</span>        <span class="attr">regex:</span> <span class="string">&#x27;(.*):.*&#x27;</span>        <span class="attr">replacement:</span> <span class="string">&#x27;$&#123;1&#125;&#x27;</span></code></pre>]]>
    </content>
    <id>http://example.com/2024/03/01/Debezium/</id>
    <link href="http://example.com/2024/03/01/Debezium/"/>
    <published>2024-03-01T04:00:00.000Z</published>
    <summary>Debezium 是一个开源的分布式 CDC（变更数据捕获）平台，由 Red Hat 开发并开源。它通过读取数据库的事务日志（如 MySQL 的 binlog、PostgreSQL 的 WAL）来捕获数据变更事件，并将这些事件发布到消息队列（如 Kafka）中，实现实时数据同步。</summary>
    <title>Debezium(CDC)</title>
    <updated>2026-02-27T09:59:50.584Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    <category term="Quarkus" scheme="http://example.com/tags/Quarkus/"/>
    <content>
      <![CDATA[<h1 id="quarkus"><a class="markdownIt-Anchor" href="#quarkus"></a> Quarkus</h1><h2 id="什么是quarkus"><a class="markdownIt-Anchor" href="#什么是quarkus"></a> 什么是Quarkus</h2><p>Quarkus 是一个专门为云原生和 GraalVM Native Image 设计的 Java 框架。<br />它的核心思想是把传统框架在运行期做的事情（比如依赖注入、注解扫描、反射）提前到编译期完成，这样生成的代码天然就对 Native Image 友好，不需要大量额外配置。<br />同时 Quarkus 即使不用 Native Image，用普通 JVM 运行也比 Spring Boot 启动更快。</p><h2 id="环境准备"><a class="markdownIt-Anchor" href="#环境准备"></a> 环境准备</h2><p><strong>需要安装：</strong></p><ul><li>JDK 17+（推荐 21）</li><li>Maven 3.9+ 或 Gradle</li><li>GraalVM（如果需要编译 Native Image）</li><li>Quarkus CLI（可选但推荐）</li></ul><pre><code class="highlight bash"><span class="comment"># 安装 Quarkus CLI（Mac/Linux）</span>curl -Ls https://sh.jbang.dev | bash -s - trust add https://repo1.maven.org/maven2/io/quarkus/quarkus-cli/curl -Ls https://sh.jbang.dev | bash -s - app install --fresh --verbose quarkus@quarkusio</code></pre><hr /><h2 id="创建第一个项目"><a class="markdownIt-Anchor" href="#创建第一个项目"></a> 创建第一个项目</h2><p><strong>方式一：Quarkus CLI</strong></p><pre><code class="highlight bash">quarkus create app com.example:my-quarkus-app \  --extension=<span class="string">&#x27;resteasy-reactive,jackson&#x27;</span><span class="built_in">cd</span> my-quarkus-app</code></pre><p><strong>方式二：Maven</strong></p><pre><code class="highlight bash">mvn io.quarkus.platform:quarkus-maven-plugin:3.8.0:create \  -DprojectGroupId=com.example \  -DprojectArtifactId=my-quarkus-app \  -Dextensions=<span class="string">&quot;resteasy-reactive,jackson&quot;</span></code></pre><p><strong>方式三：网页生成（推荐新手）</strong></p><p>直接访问 <a href="https://code.quarkus.io">https://code.quarkus.io</a> 勾选需要的扩展，下载项目。</p><hr /><h2 id="项目结构"><a class="markdownIt-Anchor" href="#项目结构"></a> 项目结构</h2><pre><code class="highlight plaintext">my-quarkus-app/├── src/│   ├── main/│   │   ├── java/com/example/│   │   │   └── GreetingResource.java   # 默认生成的接口│   │   ├── resources/│   │   │   ├── application.properties  # 配置文件│   │   │   └── META-INF/resources/     # 静态资源│   └── test/├── pom.xml</code></pre><hr /><h2 id="核心概念"><a class="markdownIt-Anchor" href="#核心概念"></a> 核心概念</h2><h3 id="1-第一个-rest-接口"><a class="markdownIt-Anchor" href="#1-第一个-rest-接口"></a> 1. 第一个 REST 接口</h3><pre><code class="highlight java"><span class="keyword">import</span> jakarta.ws.rs.GET;<span class="keyword">import</span> jakarta.ws.rs.Path;<span class="keyword">import</span> jakarta.ws.rs.Produces;<span class="keyword">import</span> jakarta.ws.rs.core.MediaType;<span class="meta">@Path(&quot;/hello&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingResource</span> &#123;    <span class="meta">@GET</span>    <span class="meta">@Produces(MediaType.TEXT_PLAIN)</span>    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Hello Quarkus!&quot;</span>;    &#125;        <span class="meta">@GET</span>    <span class="meta">@Path(&quot;/&#123;name&#125;&quot;)</span>    <span class="meta">@Produces(MediaType.TEXT_PLAIN)</span>    <span class="keyword">public</span> String <span class="title function_">helloName</span><span class="params">(String name)</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + name + <span class="string">&quot;!&quot;</span>;    &#125;&#125;</code></pre><h3 id="2-依赖注入cdi"><a class="markdownIt-Anchor" href="#2-依赖注入cdi"></a> 2. 依赖注入（CDI）</h3><pre><code class="highlight java"><span class="comment">// Service 层</span><span class="keyword">import</span> jakarta.enterprise.context.ApplicationScoped;<span class="meta">@ApplicationScoped</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingService</span> &#123;    <span class="keyword">public</span> String <span class="title function_">greet</span><span class="params">(String name)</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>;    &#125;&#125;<span class="comment">// 注入使用</span><span class="meta">@Path(&quot;/hello&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingResource</span> &#123;    <span class="meta">@Inject</span>    GreetingService greetingService;    <span class="meta">@GET</span>    <span class="meta">@Path(&quot;/&#123;name&#125;&quot;)</span>    <span class="meta">@Produces(MediaType.TEXT_PLAIN)</span>    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String name)</span> &#123;        <span class="keyword">return</span> greetingService.greet(name);    &#125;&#125;</code></pre><p><strong>常用作用域注解：</strong></p><ul><li><code>@ApplicationScoped</code> — 整个应用单例</li><li><code>@RequestScoped</code> — 每次请求新建</li><li><code>@Singleton</code> — 类似 ApplicationScoped，但更轻量</li></ul><h3 id="3-配置文件"><a class="markdownIt-Anchor" href="#3-配置文件"></a> 3. 配置文件</h3><pre><code class="highlight properties"><span class="comment"># application.properties</span><span class="attr">quarkus.http.port</span>=<span class="string">8080</span><span class="attr">quarkus.http.host</span>=<span class="string">0.0.0.0</span><span class="comment"></span><span class="comment"># 自定义配置</span><span class="attr">greeting.message</span>=<span class="string">Hello</span><span class="attr">greeting.name</span>=<span class="string">World</span></code></pre><p>读取配置：</p><pre><code class="highlight java"><span class="keyword">import</span> org.eclipse.microprofile.config.inject.ConfigProperty;<span class="meta">@ApplicationScoped</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingService</span> &#123;    <span class="meta">@ConfigProperty(name = &quot;greeting.message&quot;, defaultValue = &quot;Hi&quot;)</span>    String message;    <span class="meta">@ConfigProperty(name = &quot;greeting.name&quot;)</span>    String name;    <span class="keyword">public</span> String <span class="title function_">greet</span><span class="params">()</span> &#123;        <span class="keyword">return</span> message + <span class="string">&quot;, &quot;</span> + name + <span class="string">&quot;!&quot;</span>;    &#125;&#125;</code></pre><h3 id="4-返回-json"><a class="markdownIt-Anchor" href="#4-返回-json"></a> 4. 返回 JSON</h3><pre><code class="highlight java"><span class="comment">// 实体类（用 Record 更简洁）</span><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;&#125;<span class="meta">@Path(&quot;/person&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonResource</span> &#123;    <span class="meta">@GET</span>    <span class="meta">@Produces(MediaType.APPLICATION_JSON)</span>    <span class="keyword">public</span> Person <span class="title function_">getPerson</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>);    &#125;        <span class="meta">@POST</span>    <span class="meta">@Consumes(MediaType.APPLICATION_JSON)</span>    <span class="meta">@Produces(MediaType.APPLICATION_JSON)</span>    <span class="keyword">public</span> Person <span class="title function_">createPerson</span><span class="params">(Person person)</span> &#123;        <span class="comment">// 处理逻辑</span>        <span class="keyword">return</span> person;    &#125;&#125;</code></pre><hr /><h2 id="数据库操作"><a class="markdownIt-Anchor" href="#数据库操作"></a> 数据库操作</h2><h3 id="添加依赖panache-mysql"><a class="markdownIt-Anchor" href="#添加依赖panache-mysql"></a> 添加依赖（Panache + MySQL）</h3><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.quarkus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quarkus-hibernate-orm-panache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.quarkus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quarkus-jdbc-mysql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><p>配置数据库：</p><pre><code class="highlight properties"><span class="attr">quarkus.datasource.db-kind</span>=<span class="string">mysql</span><span class="attr">quarkus.datasource.username</span>=<span class="string">root</span><span class="attr">quarkus.datasource.password</span>=<span class="string">123456</span><span class="attr">quarkus.datasource.jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/mydb</span><span class="attr">quarkus.hibernate-orm.database.generation</span>=<span class="string">update</span></code></pre><h3 id="entityactive-record-模式"><a class="markdownIt-Anchor" href="#entityactive-record-模式"></a> Entity（Active Record 模式）</h3><pre><code class="highlight java"><span class="keyword">import</span> io.quarkus.hibernate.orm.panache.PanacheEntity;<span class="keyword">import</span> jakarta.persistence.Entity;<span class="keyword">import</span> jakarta.persistence.Column;<span class="meta">@Entity</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">PanacheEntity</span> &#123;    <span class="comment">// id 字段由 PanacheEntity 自动提供</span>        <span class="keyword">public</span> String name;        <span class="meta">@Column(unique = true)</span>    <span class="keyword">public</span> String email;        <span class="keyword">public</span> <span class="type">int</span> age;        <span class="comment">// 可以直接在 Entity 里写查询方法</span>    <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">findByEmail</span><span class="params">(String email)</span> &#123;        <span class="keyword">return</span> find(<span class="string">&quot;email&quot;</span>, email).firstResult();    &#125;        <span class="keyword">public</span> <span class="keyword">static</span> List&lt;User&gt; <span class="title function_">findAdults</span><span class="params">()</span> &#123;        <span class="keyword">return</span> list(<span class="string">&quot;age &gt;= ?1&quot;</span>, <span class="number">18</span>);    &#125;&#125;</code></pre><h3 id="repository-模式推荐"><a class="markdownIt-Anchor" href="#repository-模式推荐"></a> Repository 模式（推荐）</h3><pre><code class="highlight java"><span class="keyword">import</span> io.quarkus.hibernate.orm.panache.PanacheRepository;<span class="keyword">import</span> jakarta.enterprise.context.ApplicationScoped;<span class="meta">@ApplicationScoped</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepository</span> <span class="keyword">implements</span> <span class="title class_">PanacheRepository</span>&lt;User&gt; &#123;        <span class="keyword">public</span> User <span class="title function_">findByEmail</span><span class="params">(String email)</span> &#123;        <span class="keyword">return</span> find(<span class="string">&quot;email&quot;</span>, email).firstResult();    &#125;        <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findByAge</span><span class="params">(<span class="type">int</span> minAge)</span> &#123;        <span class="keyword">return</span> list(<span class="string">&quot;age &gt;= ?1&quot;</span>, minAge);    &#125;&#125;</code></pre><h3 id="crud-接口"><a class="markdownIt-Anchor" href="#crud-接口"></a> CRUD 接口</h3><pre><code class="highlight java"><span class="meta">@Path(&quot;/users&quot;)</span><span class="meta">@Produces(MediaType.APPLICATION_JSON)</span><span class="meta">@Consumes(MediaType.APPLICATION_JSON)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserResource</span> &#123;    <span class="meta">@Inject</span>    UserRepository userRepository;    <span class="meta">@GET</span>    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">listAll</span><span class="params">()</span> &#123;        <span class="keyword">return</span> userRepository.listAll();    &#125;    <span class="meta">@GET</span>    <span class="meta">@Path(&quot;/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> User <span class="title function_">getById</span><span class="params">(Long id)</span> &#123;        <span class="keyword">return</span> userRepository.findById(id);    &#125;    <span class="meta">@POST</span>    <span class="meta">@Transactional</span>    <span class="keyword">public</span> Response <span class="title function_">create</span><span class="params">(User user)</span> &#123;        userRepository.persist(user);        <span class="keyword">return</span> Response.status(<span class="number">201</span>).entity(user).build();    &#125;    <span class="meta">@PUT</span>    <span class="meta">@Path(&quot;/&#123;id&#125;&quot;)</span>    <span class="meta">@Transactional</span>    <span class="keyword">public</span> User <span class="title function_">update</span><span class="params">(Long id, User updated)</span> &#123;        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepository.findById(id);        user.name = updated.name;        user.email = updated.email;        <span class="keyword">return</span> user;    &#125;    <span class="meta">@DELETE</span>    <span class="meta">@Path(&quot;/&#123;id&#125;&quot;)</span>    <span class="meta">@Transactional</span>    <span class="keyword">public</span> Response <span class="title function_">delete</span><span class="params">(Long id)</span> &#123;        userRepository.deleteById(id);        <span class="keyword">return</span> Response.noContent().build();    &#125;&#125;</code></pre><hr /><h2 id="响应式编程reactive"><a class="markdownIt-Anchor" href="#响应式编程reactive"></a> 响应式编程（Reactive）</h2><p>Quarkus 推荐使用响应式方式处理高并发：</p><pre><code class="highlight java"><span class="keyword">import</span> io.smallrye.mutiny.Uni;<span class="meta">@Path(&quot;/reactive&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReactiveResource</span> &#123;    <span class="meta">@GET</span>    <span class="meta">@Path(&quot;/hello&quot;)</span>    <span class="keyword">public</span> Uni&lt;String&gt; <span class="title function_">hello</span><span class="params">()</span> &#123;        <span class="keyword">return</span> Uni.createFrom().item(<span class="string">&quot;Hello Reactive!&quot;</span>);    &#125;    <span class="meta">@GET</span>    <span class="meta">@Path(&quot;/users&quot;)</span>    <span class="keyword">public</span> Multi&lt;User&gt; <span class="title function_">listUsers</span><span class="params">()</span> &#123;        <span class="keyword">return</span> Multi.createFrom().items(            <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>),            <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">30</span>)        );    &#125;&#125;</code></pre><hr /><h2 id="开发模式dev-mode-核心亮点"><a class="markdownIt-Anchor" href="#开发模式dev-mode-核心亮点"></a> 开发模式（Dev Mode）— 核心亮点</h2><pre><code class="highlight bash"><span class="comment"># 启动开发模式，支持热重载</span>./mvnw quarkus:dev</code></pre><p>开发模式下：</p><ul><li>修改代码<strong>自动热重载</strong>，无需重启</li><li>访问 <a href="http://localhost:8080/q/dev">http://localhost:8080/q/dev</a> 进入 <strong>Dev UI</strong>，可以看到所有配置、扩展、接口文档</li><li>内置 <strong>Dev Services</strong>：自动启动 Docker 容器提供数据库、Kafka 等，零配置</li></ul><hr /><h2 id="打包-部署"><a class="markdownIt-Anchor" href="#打包-部署"></a> 打包 &amp; 部署</h2><h3 id="普通-jvm-打包"><a class="markdownIt-Anchor" href="#普通-jvm-打包"></a> 普通 JVM 打包</h3><pre><code class="highlight bash">./mvnw packagejava -jar target/quarkus-app/quarkus-run.jar</code></pre><h3 id="native-image-打包"><a class="markdownIt-Anchor" href="#native-image-打包"></a> Native Image 打包</h3><pre><code class="highlight bash"><span class="comment"># 需要安装 GraalVM</span>./mvnw package -Pnative<span class="comment"># 或用 Docker 编译（不需要本地装 GraalVM）</span>./mvnw package -Pnative -Dquarkus.native.container-build=<span class="literal">true</span></code></pre><h3 id="docker-镜像"><a class="markdownIt-Anchor" href="#docker-镜像"></a> Docker 镜像</h3><pre><code class="highlight bash"><span class="comment"># 项目自动生成了 Dockerfile</span>docker build -f src/main/docker/Dockerfile.jvm -t my-app .<span class="comment"># 或 native 版本</span>docker build -f src/main/docker/Dockerfile.native -t my-app-native .</code></pre><hr /><h2 id="常用扩展速查"><a class="markdownIt-Anchor" href="#常用扩展速查"></a> 常用扩展速查</h2><table><thead><tr><th>功能</th><th>扩展名</th></tr></thead><tbody><tr><td>REST 接口</td><td><code>quarkus-resteasy-reactive</code></td></tr><tr><td>JSON</td><td><code>quarkus-jackson</code></td></tr><tr><td>数据库 ORM</td><td><code>quarkus-hibernate-orm-panache</code></td></tr><tr><td>MySQL</td><td><code>quarkus-jdbc-mysql</code></td></tr><tr><td>Redis</td><td><code>quarkus-redis-client</code></td></tr><tr><td>Kafka</td><td><code>quarkus-smallrye-reactive-messaging-kafka</code></td></tr><tr><td>定时任务</td><td><code>quarkus-scheduler</code></td></tr><tr><td>健康检查</td><td><code>quarkus-smallrye-health</code></td></tr><tr><td>接口文档</td><td><code>quarkus-smallrye-openapi</code></td></tr><tr><td>安全认证</td><td><code>quarkus-oidc</code> / <code>quarkus-smallrye-jwt</code></td></tr></tbody></table><p>添加扩展：</p><pre><code class="highlight bash">quarkus ext add redis-client<span class="comment"># 或</span>./mvnw quarkus:add-extension -Dextensions=<span class="string">&quot;redis-client&quot;</span></code></pre><hr /><h2 id="学习路径建议"><a class="markdownIt-Anchor" href="#学习路径建议"></a> 学习路径建议</h2><ol><li><strong>入门</strong>：创建项目 → REST 接口 → 依赖注入 → 配置读取</li><li><strong>进阶</strong>：数据库操作（Panache）→ 响应式编程（Mutiny）→ Kafka 集成</li><li><strong>生产</strong>：Native Image 打包 → Docker/K8s 部署 → 健康检查 &amp; 监控</li></ol><p><strong>官方资源：</strong></p><ul><li>官方文档：<a href="https://quarkus.io/guides/">https://quarkus.io/guides/</a></li><li>在线代码生成：<a href="https://code.quarkus.io">https://code.quarkus.io</a></li><li>官方示例：<a href="https://github.com/quarkusio/quarkus-quickstarts">https://github.com/quarkusio/quarkus-quickstarts</a></li></ul>]]>
    </content>
    <id>http://example.com/2024/01/10/quarkus/</id>
    <link href="http://example.com/2024/01/10/quarkus/"/>
    <published>2024-01-10T04:00:00.000Z</published>
    <summary>Quarkus 是一个专门为云原生和 GraalVM Native Image 设计的 Java 框架。它的核心思想是把传统框架在运行期做的事情（比如依赖注入、注解扫描、反射）提前到编译期完成，这样生成的代码天然就对 Native Image 友好，不需要大量额外配置。同时 Quarkus 即使不用 Native Image，用普通 JVM 运行也比 Spring Boot 启动更快。</summary>
    <title>Quarkus</title>
    <updated>2026-02-27T05:48:12.125Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    <category term="GraalVM" scheme="http://example.com/tags/GraalVM/"/>
    <content>
      <![CDATA[<h1 id="graalvm-native-image"><a class="markdownIt-Anchor" href="#graalvm-native-image"></a> GraalVM Native Image</h1><p>GraalVM是一个高性能的运行时环境，它不仅支持Java，还兼容JavaScript、Python等多种语言。其中，Native Image是其核心组件之一，它利用即时编译（AOT）技术，在应用程序部署前将其及其依赖转换为机器码，从而消除JVM的启动时间和内存开销。</p><p>Native Image 是由 GraalVM 提供的一种技术，可以将 Java 应用直接编译为机器码的可执行文件（而不是 .jar）。 这意味着运行时不需要 JVM，也不会有 JIT 编译延迟。</p><h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3><ul><li>启动更快</li><li>内存占用更低</li><li>直接打包为单一二进制文件，部署简单</li></ul><h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3><ul><li>构建时间长</li><li>反射、动态代理支持差</li><li>调试困难</li><li>很多库不兼容</li></ul><h2 id="什么是native-image"><a class="markdownIt-Anchor" href="#什么是native-image"></a> 什么是Native Image</h2><p>传统 JVM 执行流程：</p><ol><li>启动 JVM。</li><li>加载 .class 字节码文件。</li><li>解析类、初始化静态变量。</li><li>在运行时，通过解释器执行字节码。</li><li>性能热点代码会被 HotSpot JIT（Just-In-Time）编译器动态编译成机器码以提高性能。</li><li>执行垃圾回收（GC）等运行时任务。</li></ol><p>Native Image AOT 流程：</p><ol><li>构建时分析： 在构建阶段，native-image 工具会启动一个临时的 JVM 来执行你的应用程序的引导代码（通常是 main 方法）。在此期间，它会进行静态分析和可达性分析，跟踪所有可能被执行的代码路径，确定哪些类、方法、字段会在运行时被加载和使用。</li><li>Substrate VM: 这个分析过程由 GraalVM 的 Substrate VM 完成，它是用于构建原生镜像的特殊运行时环境。</li><li>元数据提取： 分析过程中收集到的所有信息（如所有可达的类、方法、反射信息、资源文件等）都会被提取出来。</li><li>代码生成： GraalVM 编译器（基于 Graal JIT 编译器）将收集到的 Java 字节码和 GraalVM 自身的运行时组件（包括内存管理、线程调度等）一起，通过 LLVM 等后端编译成特定平台的本地机器码。</li><li>链接： 所有生成的目标文件被链接在一起，最终形成一个独立的可执行文件。</li></ol><p>Native Image 的<strong>核心优势</strong></p><ol><li>闪电般的启动速度： 由于跳过了 JVM 启动、类加载、JIT 预热等一系列步骤，原生应用的启动时间可以从数秒甚至数十秒缩短到毫秒级。这对于需要快速响应的 Serverless 函数或需要频繁伸缩的微服务至关重要。</li><li>更低的内存占用： 没有了 JVM 的运行时开销（如庞大的 GC 堆、方法区/元空间、JIT 编译器本身等），原生镜像的内存 Footprint 显著降低，通常只有传统 JVM 应用的几分之一。</li><li>即时性能： 构建时的 AOT 编译已经对代码进行了深度优化，因此应用在启动后立即就能达到接近峰值的性能，无需等待 JIT 编译器优化热点代码。</li><li>精简部署： 最终产物是一个单一的、包含所有依赖的可执行文件，部署变得极其简单，无需在目标机器上安装 JVM。</li></ol><p>Native Image 的<strong>缺点</strong></p><ol><li>构建时间长且资源消耗大： Native Image 的构建过程非常复杂，涉及深度的静态分析和代码优化，因此耗时很长（可能从几分钟到几十分钟不等），并且需要消耗大量 CPU 和内存。</li><li>动态特性受限： 由于是静态分析，对于反射（Reflection）、动态代理（Dynamic Proxy）、运行时类加载（Runtime Class Loading）、资源文件动态查找等动态特性，必须在构建前通过配置文件（如 reflect-config.json）明确告知 native-image 工具哪些类和方法可能会被动态使用，否则在运行时会失败。</li><li>生态系统兼容性： 并非所有 Java 库都能完美兼容 Native Image。一些过度依赖 JVM 动态特性的框架或库可能无法正常工作，或者需要特殊的适配或配置。例如，Spring Framework 推出了 Spring Native 项目来解决此问题。</li></ol><h2 id="从-java-应用到原生镜像"><a class="markdownIt-Anchor" href="#从-java-应用到原生镜像"></a> 从 Java 应用到原生镜像</h2><h3 id="环境准备"><a class="markdownIt-Anchor" href="#环境准备"></a> 环境准备</h3><p>GraalVM JDK: 从 GraalVM 官网 下载并安装适合你操作系统的 GraalVM JDK。推荐使用最新稳定版（例如，对应 Java 17 或 21 的版本）。</p><p>设置 JAVA_HOME: 将你的 JAVA_HOME 环境变量指向 GraalVM JDK 的安装目录。例如，在 Linux/macOS 上，你可能需要在 ~/.bashrc 文件中添加：</p><pre><code class="highlight plaintext">export JAVA_HOME=/path/to/your/graalvm-jdk</code></pre><p>安装 native-image 组件: 打开终端，执行以下命令来安装 native-image 工具：</p><pre><code class="highlight plaintext">gu install native-image</code></pre><h3 id="创建一个简单的java应用"><a class="markdownIt-Anchor" href="#创建一个简单的java应用"></a> 创建一个简单的Java应用</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);    &#125;&#125;</code></pre><h3 id="编译java代码"><a class="markdownIt-Anchor" href="#编译java代码"></a> 编译Java代码</h3><p>在终端中，进入 HelloNative.java 所在的目录，使用 GraalVM JDK 编译源码：</p><pre><code class="highlight plaintext">javac HelloWorld.java</code></pre><h3 id="构建native-image"><a class="markdownIt-Anchor" href="#构建native-image"></a> 构建Native Image</h3><p>现在，我们尝试直接将 HelloNative.class 编译成原生镜像：</p><pre><code class="highlight plaintext">./native-image HelloWorld</code></pre><h3 id="执行"><a class="markdownIt-Anchor" href="#执行"></a> 执行</h3><p>构建成功后，可以直接执行</p><p>几乎是瞬间启动并完成输出的，这体现了 Native Image 的启动速度优势。</p><pre><code class="highlight plaintext">./hello-world</code></pre>]]>
    </content>
    <id>http://example.com/2024/01/04/GraalVM-Native-Image/</id>
    <link href="http://example.com/2024/01/04/GraalVM-Native-Image/"/>
    <published>2024-01-04T04:00:00.000Z</published>
    <summary>GraalVM是一个高性能的运行时环境，它不仅支持Java，还兼容JavaScript、Python等多种语言。其中，Native Image是其核心组件之一，它利用即时编译（AOT）技术，在应用程序部署前将其及其依赖转换为机器码，从而消除JVM的启动时间和内存开销。</summary>
    <title>GraalVM-Native-Image</title>
    <updated>2026-02-27T05:46:38.859Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    <content>
      <![CDATA[<h1 id="java821新特性总结"><a class="markdownIt-Anchor" href="#java821新特性总结"></a> Java8→21新特性总结</h1><hr /><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><ul><li><a href="#java-8">Java 8（2014）— 划时代版本</a></li><li><a href="#java-9">Java 9（2017）— 模块化时代</a></li><li><a href="#java-10">Java 10（2018）— 局部变量推断</a></li><li><a href="#java-11">Java 11（2018）— 第二个 LTS</a></li><li><a href="#java-12-14">Java 12 ~ 14 — 过渡版本</a></li><li><a href="#java-15-16">Java 15 ~ 16（2020~2021）— 特性逐渐成熟</a></li><li><a href="#java-17">Java 17（2021）— 第三个 LTS</a></li><li><a href="#java-18-20">Java 18 ~ 20（2022~2023）— 过渡版本</a></li><li><a href="#java-21">Java 21（2023）— 第四个 LTS，最重磅</a></li><li><a href="#%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9%E5%BB%BA%E8%AE%AE">版本选择建议</a></li></ul><hr /><h2 id="java-8"><a class="markdownIt-Anchor" href="#java-8"></a> Java 8</h2><blockquote><p><strong>2014 年发布，目前仍是使用最广泛的版本，引入了函数式编程思想</strong></p></blockquote><h3 id="lambda-表达式"><a class="markdownIt-Anchor" href="#lambda-表达式"></a> Lambda 表达式</h3><p>Lambda 是 Java 8 最重要的特性，让代码更简洁。</p><pre><code class="highlight java"><span class="comment">// 旧写法</span>List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>);Collections.sort(names, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String a, String b)</span> &#123;        <span class="keyword">return</span> a.compareTo(b);    &#125;&#125;);<span class="comment">// Lambda 写法</span>Collections.sort(names, (a, b) -&gt; a.compareTo(b));<span class="comment">// 更简洁</span>names.sort(String::compareTo);</code></pre><h3 id="stream-api"><a class="markdownIt-Anchor" href="#stream-api"></a> Stream API</h3><p>对集合进行链式操作，告别大量 for 循环。</p><pre><code class="highlight java">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;赵六&quot;</span>);<span class="comment">// 过滤 + 转换 + 收集</span>List&lt;String&gt; result = names.stream()    .filter(name -&gt; name.startsWith(<span class="string">&quot;张&quot;</span>))   <span class="comment">// 过滤</span>    .map(String::toUpperCase)               <span class="comment">// 转换</span>    .sorted()                               <span class="comment">// 排序</span>    .collect(Collectors.toList());          <span class="comment">// 收集</span><span class="comment">// 聚合操作</span><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> names.stream().filter(n -&gt; n.length() &gt; <span class="number">1</span>).count();Optional&lt;String&gt; first = names.stream().findFirst();<span class="comment">// 并行流（多核加速）</span><span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> LongStream.rangeClosed(<span class="number">1</span>, <span class="number">1_000_000</span>)    .parallel()    .sum();</code></pre><h3 id="optional"><a class="markdownIt-Anchor" href="#optional"></a> Optional</h3><p>优雅处理 null，避免 NullPointerException。</p><pre><code class="highlight java"><span class="comment">// 旧写法</span><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> user != <span class="literal">null</span> ? user.getName() : <span class="string">&quot;默认名&quot;</span>;<span class="comment">// Optional 写法</span>Optional&lt;User&gt; user = userRepository.findById(id);<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> user.map(User::getName).orElse(<span class="string">&quot;默认名&quot;</span>);<span class="comment">// 链式处理</span><span class="type">String</span> <span class="variable">city</span> <span class="operator">=</span> Optional.ofNullable(user)    .map(User::getAddress)    .map(Address::getCity)    .orElse(<span class="string">&quot;未知城市&quot;</span>);</code></pre><h3 id="函数式接口"><a class="markdownIt-Anchor" href="#函数式接口"></a> 函数式接口</h3><p>四大核心函数式接口：</p><pre><code class="highlight java"><span class="comment">// Function&lt;T, R&gt;：输入 T，返回 R</span>Function&lt;String, Integer&gt; strLen = String::length;System.out.println(strLen.apply(<span class="string">&quot;Hello&quot;</span>));  <span class="comment">// 5</span><span class="comment">// Predicate&lt;T&gt;：输入 T，返回 boolean</span>Predicate&lt;String&gt; isEmpty = String::isEmpty;System.out.println(isEmpty.test(<span class="string">&quot;&quot;</span>));  <span class="comment">// true</span><span class="comment">// Consumer&lt;T&gt;：输入 T，无返回</span>Consumer&lt;String&gt; print = System.out::println;print.accept(<span class="string">&quot;Hello&quot;</span>);<span class="comment">// Supplier&lt;T&gt;：无输入，返回 T</span>Supplier&lt;List&lt;String&gt;&gt; listFactory = ArrayList::<span class="keyword">new</span>;</code></pre><h3 id="新的日期时间-api"><a class="markdownIt-Anchor" href="#新的日期时间-api"></a> 新的日期时间 API</h3><p>终于告别 <code>Date</code> 和 <code>Calendar</code> 的混乱。</p><pre><code class="highlight java"><span class="comment">// 日期</span><span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();<span class="type">LocalDate</span> <span class="variable">birthday</span> <span class="operator">=</span> LocalDate.of(<span class="number">1995</span>, <span class="number">6</span>, <span class="number">15</span>);<span class="type">long</span> <span class="variable">age</span> <span class="operator">=</span> ChronoUnit.YEARS.between(birthday, today);<span class="comment">// 时间</span><span class="type">LocalTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalTime.now();<span class="type">LocalTime</span> <span class="variable">meeting</span> <span class="operator">=</span> LocalTime.of(<span class="number">14</span>, <span class="number">30</span>);<span class="comment">// 日期时间</span><span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.now();<span class="comment">// 带时区</span><span class="type">ZonedDateTime</span> <span class="variable">shanghaiTime</span> <span class="operator">=</span> ZonedDateTime.now(ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>));<span class="comment">// 格式化</span><span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<span class="type">String</span> <span class="variable">formatted</span> <span class="operator">=</span> dateTime.format(formatter);</code></pre><h3 id="接口默认方法"><a class="markdownIt-Anchor" href="#接口默认方法"></a> 接口默认方法</h3><p>接口可以有默认实现了。</p><pre><code class="highlight java"><span class="keyword">interface</span> <span class="title class_">Greeting</span> &#123;    String <span class="title function_">greet</span><span class="params">(String name)</span>;    <span class="comment">// 默认方法，实现类可以不覆写</span>    <span class="keyword">default</span> String <span class="title function_">greetLoudly</span><span class="params">(String name)</span> &#123;        <span class="keyword">return</span> greet(name).toUpperCase();    &#125;    <span class="comment">// 静态方法</span>    <span class="keyword">static</span> Greeting <span class="title function_">formal</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name -&gt; <span class="string">&quot;您好，&quot;</span> + name;    &#125;&#125;</code></pre><hr /><h2 id="java-9"><a class="markdownIt-Anchor" href="#java-9"></a> Java 9</h2><blockquote><p><strong>2017 年发布，引入模块化系统，改变了 Java 平台结构</strong></p></blockquote><h3 id="模块化系统jpms"><a class="markdownIt-Anchor" href="#模块化系统jpms"></a> 模块化系统（JPMS）</h3><p>将 JDK 自身拆分成模块，应用也可以声明依赖。</p><pre><code class="highlight java"><span class="comment">// module-info.java</span><span class="keyword">module</span> com.myapp &#123;    <span class="keyword">requires</span> java.sql;          <span class="comment">// 依赖 java.sql 模块</span>    <span class="keyword">requires</span> spring.core;       <span class="comment">// 依赖 Spring</span>    <span class="keyword">exports</span> com.myapp.api;      <span class="comment">// 对外暴露的包</span>&#125;</code></pre><h3 id="集合工厂方法"><a class="markdownIt-Anchor" href="#集合工厂方法"></a> 集合工厂方法</h3><p>创建不可变集合更方便。</p><pre><code class="highlight java"><span class="comment">// 旧写法（繁琐）</span>List&lt;String&gt; list = Collections.unmodifiableList(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>));<span class="comment">// 新写法</span>List&lt;String&gt; list = List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);Set&lt;String&gt; set = Set.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);Map&lt;String, Integer&gt; map = Map.of(<span class="string">&quot;key1&quot;</span>, <span class="number">1</span>, <span class="string">&quot;key2&quot;</span>, <span class="number">2</span>);</code></pre><h3 id="stream-增强"><a class="markdownIt-Anchor" href="#stream-增强"></a> Stream 增强</h3><pre><code class="highlight java"><span class="comment">// takeWhile：取满足条件的前缀元素</span>List&lt;Integer&gt; result = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>)    .takeWhile(n -&gt; n &lt; <span class="number">4</span>)    .collect(Collectors.toList());  <span class="comment">// [1, 2, 3]</span><span class="comment">// dropWhile：丢弃满足条件的前缀元素</span>List&lt;Integer&gt; result2 = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)    .dropWhile(n -&gt; n &lt; <span class="number">3</span>)    .collect(Collectors.toList());  <span class="comment">// [3, 4, 5]</span><span class="comment">// Stream.iterate 增强（可以指定终止条件）</span>Stream.iterate(<span class="number">1</span>, n -&gt; n &lt; <span class="number">100</span>, n -&gt; n * <span class="number">2</span>)    .forEach(System.out::println);  <span class="comment">// 1, 2, 4, 8, ...</span></code></pre><h3 id="optional-增强"><a class="markdownIt-Anchor" href="#optional-增强"></a> Optional 增强</h3><pre><code class="highlight java">Optional&lt;String&gt; opt = Optional.of(<span class="string">&quot;hello&quot;</span>);<span class="comment">// ifPresentOrElse</span>opt.ifPresentOrElse(    v -&gt; System.out.println(<span class="string">&quot;有值: &quot;</span> + v),    () -&gt; System.out.println(<span class="string">&quot;没有值&quot;</span>));<span class="comment">// or：为空时提供另一个 Optional</span>Optional&lt;String&gt; result = opt.or(() -&gt; Optional.of(<span class="string">&quot;默认值&quot;</span>));<span class="comment">// stream：转成 Stream</span>opt.stream().forEach(System.out::println);</code></pre><hr /><h2 id="java-10"><a class="markdownIt-Anchor" href="#java-10"></a> Java 10</h2><blockquote><p><strong>2018 年发布，主要带来了局部变量类型推断</strong></p></blockquote><h3 id="var-局部变量类型推断"><a class="markdownIt-Anchor" href="#var-局部变量类型推断"></a> var 局部变量类型推断</h3><pre><code class="highlight java"><span class="comment">// 旧写法</span>HashMap&lt;String, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;Integer&gt;&gt;();Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();<span class="comment">// var 写法（编译器自动推断类型）</span><span class="type">var</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;Integer&gt;&gt;();<span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();<span class="type">var</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;  <span class="comment">// 推断为 String</span><span class="comment">// 在循环中使用</span><span class="keyword">for</span> (<span class="keyword">var</span> entry : map.entrySet()) &#123;    System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());&#125;</code></pre><blockquote><p><strong>注意：</strong> <code>var</code> 只能用于局部变量，不能用于方法参数、返回值、字段。</p></blockquote><hr /><h2 id="java-11"><a class="markdownIt-Anchor" href="#java-11"></a> Java 11</h2><blockquote><p><strong>2018 年发布，第二个 LTS 版本，企业升级的主要目标之一</strong></p></blockquote><h3 id="string-新方法"><a class="markdownIt-Anchor" href="#string-新方法"></a> String 新方法</h3><pre><code class="highlight java"><span class="comment">// isBlank：判断是否空白（比 isEmpty 更严格）</span><span class="string">&quot;  &quot;</span>.isBlank();   <span class="comment">// true</span><span class="string">&quot;&quot;</span>.isBlank();     <span class="comment">// true</span><span class="string">&quot; a&quot;</span>.isBlank();   <span class="comment">// false</span><span class="comment">// strip：去除 Unicode 空白（比 trim 更强）</span><span class="string">&quot;  hello  &quot;</span>.strip();       <span class="comment">// &quot;hello&quot;</span><span class="string">&quot;  hello  &quot;</span>.stripLeading(); <span class="comment">// &quot;hello  &quot;</span><span class="string">&quot;  hello  &quot;</span>.stripTrailing();<span class="comment">// &quot;  hello&quot;</span><span class="comment">// lines：按行分割成 Stream</span><span class="string">&quot;line1\nline2\nline3&quot;</span>.lines()    .forEach(System.out::println);<span class="comment">// repeat：重复字符串</span><span class="string">&quot;ha&quot;</span>.repeat(<span class="number">3</span>);  <span class="comment">// &quot;hahaha&quot;</span></code></pre><h3 id="直接运行-java-文件"><a class="markdownIt-Anchor" href="#直接运行-java-文件"></a> 直接运行 Java 文件</h3><pre><code class="highlight bash"><span class="comment"># Java 11 之前需要先编译再运行</span>javac Hello.javajava Hello<span class="comment"># Java 11 可以直接运行</span>java Hello.java</code></pre><h3 id="httpclient-正式发布"><a class="markdownIt-Anchor" href="#httpclient-正式发布"></a> HttpClient 正式发布</h3><pre><code class="highlight java"><span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClient.newHttpClient();<span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> HttpRequest.newBuilder()    .uri(URI.create(<span class="string">&quot;https://api.example.com/users&quot;</span>))    .GET()    .build();HttpResponse&lt;String&gt; response = client.send(    request, HttpResponse.BodyHandlers.ofString());System.out.println(response.statusCode());System.out.println(response.body());</code></pre><hr /><h2 id="java-12~14"><a class="markdownIt-Anchor" href="#java-12~14"></a> Java 12~14</h2><blockquote><p><strong>过渡版本，主要以预览特性为主</strong></p></blockquote><h3 id="switch-表达式java-14-正式"><a class="markdownIt-Anchor" href="#switch-表达式java-14-正式"></a> Switch 表达式（Java 14 正式）</h3><pre><code class="highlight java"><span class="comment">// 旧 switch（容易忘写 break，还只能做语句）</span>String result;<span class="keyword">switch</span> (day) &#123;    <span class="keyword">case</span> MONDAY:    <span class="keyword">case</span> FRIDAY:        result = <span class="string">&quot;工作日&quot;</span>;        <span class="keyword">break</span>;    <span class="keyword">case</span> SATURDAY:    <span class="keyword">case</span> SUNDAY:        result = <span class="string">&quot;周末&quot;</span>;        <span class="keyword">break</span>;    <span class="keyword">default</span>:        result = <span class="string">&quot;其他&quot;</span>;&#125;<span class="comment">// 新 switch 表达式（简洁、安全、可以有返回值）</span><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">switch</span> (day) &#123;    <span class="keyword">case</span> MONDAY, FRIDAY -&gt; <span class="string">&quot;工作日&quot;</span>;    <span class="keyword">case</span> SATURDAY, SUNDAY -&gt; <span class="string">&quot;周末&quot;</span>;    <span class="keyword">default</span> -&gt; <span class="string">&quot;其他&quot;</span>;&#125;;</code></pre><h3 id="文本块-text-blockjava-13-预览14-继续预览"><a class="markdownIt-Anchor" href="#文本块-text-blockjava-13-预览14-继续预览"></a> 文本块 Text Block（Java 13 预览，14 继续预览）</h3><pre><code class="highlight java"><span class="comment">// 旧写法（拼接 JSON/HTML/SQL 很痛苦）</span><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +              <span class="string">&quot;  \&quot;name\&quot;: \&quot;张三\&quot;,\n&quot;</span> +              <span class="string">&quot;  \&quot;age\&quot;: 25\n&quot;</span> +              <span class="string">&quot;&#125;&quot;</span>;<span class="comment">// 文本块写法（Java 15 正式）</span><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span><span class="string">        &#123;</span><span class="string">          &quot;name&quot;: &quot;张三&quot;,</span><span class="string">          &quot;age&quot;: 25</span><span class="string">        &#125;</span><span class="string">        &quot;&quot;&quot;</span>;</code></pre><hr /><h2 id="java-15~16"><a class="markdownIt-Anchor" href="#java-15~16"></a> Java 15~16</h2><blockquote><p><strong>特性逐渐从预览转为正式</strong></p></blockquote><h3 id="文本块正式发布java-15"><a class="markdownIt-Anchor" href="#文本块正式发布java-15"></a> 文本块正式发布（Java 15）</h3><p>见上方示例，Java 15 正式发布，可以放心使用。</p><h3 id="recordsjava-16-正式"><a class="markdownIt-Anchor" href="#recordsjava-16-正式"></a> Records（Java 16 正式）</h3><p>不可变数据类，自动生成构造器、getter、equals、hashCode、toString。</p><pre><code class="highlight java"><span class="comment">// 旧写法（一个简单的数据类需要写几十行）</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;    <span class="keyword">private</span> <span class="keyword">final</span> String name;    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123; <span class="built_in">this</span>.name = name; <span class="built_in">this</span>.age = age; &#125;    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="keyword">return</span> age; &#125;    <span class="comment">// equals, hashCode, toString...</span>&#125;<span class="comment">// Record 写法（一行搞定）</span><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;&#125;<span class="comment">// 使用</span><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>);System.out.println(user.name());  <span class="comment">// 张三</span>System.out.println(user.age());   <span class="comment">// 25</span>System.out.println(user);         <span class="comment">// User[name=张三, age=25]</span><span class="comment">// 可以添加自定义方法</span><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;    <span class="comment">// 紧凑构造器（做参数校验）</span>    <span class="keyword">public</span> User &#123;        <span class="keyword">if</span> (age &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;年龄不能为负&quot;</span>);    &#125;        <span class="keyword">public</span> String <span class="title function_">greeting</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;我叫&quot;</span> + name + <span class="string">&quot;，今年&quot;</span> + age + <span class="string">&quot;岁&quot;</span>;    &#125;&#125;</code></pre><h3 id="instanceof-pattern-matchingjava-16-正式"><a class="markdownIt-Anchor" href="#instanceof-pattern-matchingjava-16-正式"></a> instanceof Pattern Matching（Java 16 正式）</h3><pre><code class="highlight java"><span class="comment">// 旧写法</span><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) obj;  <span class="comment">// 需要强转</span>    System.out.println(s.length());&#125;<span class="comment">// 新写法（自动绑定变量）</span><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;    System.out.println(s.length());  <span class="comment">// 直接使用 s，无需强转</span>&#125;</code></pre><hr /><h2 id="java-17"><a class="markdownIt-Anchor" href="#java-17"></a> Java 17</h2><blockquote><p><strong>2021 年发布，第三个 LTS，目前很多企业的升级目标</strong></p></blockquote><h3 id="sealed-classes-密封类"><a class="markdownIt-Anchor" href="#sealed-classes-密封类"></a> Sealed Classes 密封类</h3><p>限制哪些类可以继承或实现，让类层级更可控。</p><pre><code class="highlight java"><span class="comment">// 只有 Circle、Rectangle、Triangle 能实现 Shape</span><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> <span class="keyword">permits</span> Circle, Rectangle, Triangle &#123;    <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span>;&#125;<span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span> &#123; <span class="keyword">return</span> Math.PI * radius * radius; &#125;&#125;<span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Rectangle</span><span class="params">(<span class="type">double</span> width, <span class="type">double</span> height)</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span> &#123; <span class="keyword">return</span> width * height; &#125;&#125;<span class="comment">// 配合 Pattern Matching 使用非常强大</span><span class="type">double</span> <span class="title function_">describe</span><span class="params">(Shape shape)</span> &#123;    <span class="keyword">return</span> <span class="keyword">switch</span> (shape) &#123;        <span class="keyword">case</span> Circle c    -&gt; c.area();        <span class="keyword">case</span> Rectangle r -&gt; r.area();        <span class="keyword">case</span> Triangle t  -&gt; t.area();        <span class="comment">// 编译器知道 Shape 只有这三种，不需要 default！</span>    &#125;;&#125;</code></pre><h3 id="增强的伪随机数生成器"><a class="markdownIt-Anchor" href="#增强的伪随机数生成器"></a> 增强的伪随机数生成器</h3><pre><code class="highlight java"><span class="comment">// 统一的接口，支持多种算法</span><span class="type">RandomGenerator</span> <span class="variable">rng</span> <span class="operator">=</span> RandomGeneratorFactory.of(<span class="string">&quot;L64X128MixRandom&quot;</span>).create();<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> rng.nextInt(<span class="number">100</span>);<span class="comment">// 支持流式操作</span>rng.ints(<span class="number">10</span>, <span class="number">1</span>, <span class="number">100</span>).forEach(System.out::println);</code></pre><hr /><h2 id="java-18~20"><a class="markdownIt-Anchor" href="#java-18~20"></a> Java 18~20</h2><blockquote><p><strong>过渡版本，引入了多个重要预览特性</strong></p></blockquote><h3 id="虚拟线程预览java-19"><a class="markdownIt-Anchor" href="#虚拟线程预览java-19"></a> 虚拟线程预览（Java 19）</h3><pre><code class="highlight java"><span class="comment">// 预览版（Java 21 正式，见下文）</span><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;    executor.submit(() -&gt; System.out.println(<span class="string">&quot;运行在虚拟线程中&quot;</span>));&#125;</code></pre><h3 id="structured-concurrency-结构化并发预览java-19"><a class="markdownIt-Anchor" href="#structured-concurrency-结构化并发预览java-19"></a> Structured Concurrency 结构化并发预览（Java 19）</h3><pre><code class="highlight java"><span class="comment">// 多个并发任务作为一个整体管理</span><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;    Future&lt;String&gt; user  = scope.fork(() -&gt; fetchUser(id));    Future&lt;String&gt; order = scope.fork(() -&gt; fetchOrder(id));        scope.join();           <span class="comment">// 等待所有任务</span>    scope.throwIfFailed();  <span class="comment">// 任意一个失败则抛异常</span>        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>(user.get(), order.get());&#125;</code></pre><hr /><h2 id="java-21"><a class="markdownIt-Anchor" href="#java-21"></a> Java 21</h2><blockquote><p><strong>2023 年 9 月发布，第四个 LTS，目前最新 LTS，特性最丰富</strong></p></blockquote><h3 id="虚拟线程正式发布-最重磅特性"><a class="markdownIt-Anchor" href="#虚拟线程正式发布-最重磅特性"></a> 🌟 虚拟线程（正式发布）— 最重磅特性</h3><p>虚拟线程是 Java 并发模型的重大变革，可以轻松创建百万级别线程。</p><pre><code class="highlight java"><span class="comment">// 方式一：直接创建虚拟线程</span><span class="type">Thread</span> <span class="variable">vThread</span> <span class="operator">=</span> Thread.ofVirtual().start(() -&gt; &#123;    System.out.println(<span class="string">&quot;这是虚拟线程: &quot;</span> + Thread.currentThread().isVirtual());&#125;);<span class="comment">// 方式二：虚拟线程执行器（推荐）</span><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;    <span class="comment">// 提交 100 万个任务，完全不用担心资源耗尽</span>    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1_000_000</span>; i++) &#123;        executor.submit(() -&gt; &#123;            Thread.sleep(Duration.ofSeconds(<span class="number">1</span>));  <span class="comment">// 阻塞也没关系</span>            <span class="keyword">return</span> <span class="string">&quot;done&quot;</span>;        &#125;);    &#125;&#125;<span class="comment">// 方式三：Spring Boot 3.2 一行配置开启</span><span class="comment">// application.properties</span><span class="comment">// spring.threads.virtual.enabled=true</span></code></pre><p><strong>为什么虚拟线程是革命性的？</strong></p><table><thead><tr><th>对比项</th><th>平台线程（OS Thread）</th><th>虚拟线程（Virtual Thread）</th></tr></thead><tbody><tr><td>创建成本</td><td>高（约 1MB 栈内存）</td><td>极低（KB 级别）</td></tr><tr><td>数量限制</td><td>通常几千个</td><td>可达数百万</td></tr><tr><td>阻塞时</td><td>占用 OS 线程</td><td>自动挂起，释放 OS 线程</td></tr><tr><td>适用场景</td><td>CPU 密集型</td><td>IO 密集型（Web 请求、数据库）</td></tr></tbody></table><h3 id="pattern-matching-for-switch正式发布"><a class="markdownIt-Anchor" href="#pattern-matching-for-switch正式发布"></a> 🌟 Pattern Matching for Switch（正式发布）</h3><pre><code class="highlight java"><span class="comment">// 强大的模式匹配 + switch 组合</span><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="number">42</span>;<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">switch</span> (obj) &#123;    <span class="keyword">case</span> Integer i <span class="keyword">when</span> i &gt; <span class="number">0</span> -&gt; <span class="string">&quot;正整数: &quot;</span> + i;    <span class="keyword">case</span> Integer i            -&gt; <span class="string">&quot;非正整数: &quot;</span> + i;    <span class="keyword">case</span> String s             -&gt; <span class="string">&quot;字符串: &quot;</span> + s;    <span class="keyword">case</span> <span class="literal">null</span>                 -&gt; <span class="string">&quot;空值&quot;</span>;    <span class="keyword">default</span>                   -&gt; <span class="string">&quot;其他类型&quot;</span>;&#125;;</code></pre><h3 id="sequenced-collections"><a class="markdownIt-Anchor" href="#sequenced-collections"></a> 🌟 Sequenced Collections</h3><p>新增有序集合接口，统一操作第一个/最后一个元素。</p><pre><code class="highlight java"><span class="comment">// 新接口：SequencedCollection</span>List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>));list.getFirst();  <span class="comment">// &quot;a&quot;</span>list.getLast();   <span class="comment">// &quot;c&quot;</span>list.addFirst(<span class="string">&quot;z&quot;</span>);list.addLast(<span class="string">&quot;z&quot;</span>);list.removeFirst();list.removeLast();<span class="comment">// 反转视图</span>List&lt;String&gt; reversed = list.reversed();</code></pre><h3 id="record-patterns正式发布"><a class="markdownIt-Anchor" href="#record-patterns正式发布"></a> Record Patterns（正式发布）</h3><p>解构 Record 对象，配合 Pattern Matching 使用。</p><pre><code class="highlight java"><span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;<span class="keyword">record</span> <span class="title class_">Line</span><span class="params">(Point start, Point end)</span> &#123;&#125;<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Line</span>(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>, <span class="number">4</span>));<span class="comment">// 直接解构嵌套 Record</span><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title function_">Line</span><span class="params">(Point(<span class="type">int</span> x1, <span class="type">int</span> y1)</span>, Point(<span class="type">int</span> x2, <span class="type">int</span> y2))) &#123;    System.out.println(<span class="string">&quot;起点: (&quot;</span> + x1 + <span class="string">&quot;, &quot;</span> + y1 + <span class="string">&quot;)&quot;</span>);    System.out.println(<span class="string">&quot;终点: (&quot;</span> + x2 + <span class="string">&quot;, &quot;</span> + y2 + <span class="string">&quot;)&quot;</span>);&#125;</code></pre><h3 id="string-templates预览"><a class="markdownIt-Anchor" href="#string-templates预览"></a> String Templates（预览）</h3><pre><code class="highlight java"><span class="comment">// 类似其他语言的字符串插值（Java 21 预览，未来正式）</span><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;<span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">25</span>;<span class="comment">// 预览语法（需要开启预览特性）</span><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> STR.<span class="string">&quot;姓名：\&#123;name&#125;，年龄：\&#123;age&#125;&quot;</span>;<span class="comment">// 输出：姓名：张三，年龄：25</span></code></pre><hr /><h2 id="版本选择建议"><a class="markdownIt-Anchor" href="#版本选择建议"></a> 版本选择建议</h2><h3 id="lts-版本一览"><a class="markdownIt-Anchor" href="#lts-版本一览"></a> LTS 版本一览</h3><table><thead><tr><th>版本</th><th>发布时间</th><th>支持至</th><th>推荐程度</th></tr></thead><tbody><tr><td>Java 8</td><td>2014</td><td>2030</td><td>老项目维护</td></tr><tr><td>Java 11</td><td>2018</td><td>2032</td><td>逐步迁移</td></tr><tr><td>Java 17</td><td>2021</td><td>2029</td><td>新项目推荐</td></tr><tr><td><strong>Java 21</strong></td><td><strong>2023</strong></td><td><strong>2031</strong></td><td><strong>最推荐</strong></td></tr></tbody></table><h3 id="迁移路线建议"><a class="markdownIt-Anchor" href="#迁移路线建议"></a> 迁移路线建议</h3><pre><code class="highlight plaintext">Java 8 用户  →  先升 Java 17（改动最小的 LTS）  →  再升 Java 21</code></pre><p><strong>升级注意事项：</strong></p><ul><li>Java 9 引入了模块化，<code>sun.*</code> 内部 API 可能无法访问</li><li>Java 17 强制封装了 JDK 内部 API，部分旧框架可能有兼容问题</li><li>Spring Boot 3.x 要求 Java 17+</li><li>Spring Boot 3.2+ 可以一行配置开启虚拟线程</li></ul><h3 id="各特性重要程度速览"><a class="markdownIt-Anchor" href="#各特性重要程度速览"></a> 各特性重要程度速览</h3><table><thead><tr><th>特性</th><th>版本</th><th>重要程度</th></tr></thead><tbody><tr><td>Lambda / Stream / Optional</td><td>Java 8</td><td>⭐⭐⭐ 核心基础</td></tr><tr><td>var 类型推断</td><td>Java 10</td><td>⭐⭐ 日常实用</td></tr><tr><td>文本块</td><td>Java 15</td><td>⭐⭐ 日常实用</td></tr><tr><td>Record</td><td>Java 16</td><td>⭐⭐⭐ 强烈推荐</td></tr><tr><td>instanceof Pattern Matching</td><td>Java 16</td><td>⭐⭐ 日常实用</td></tr><tr><td>Sealed Classes</td><td>Java 17</td><td>⭐⭐ 设计利器</td></tr><tr><td>虚拟线程</td><td>Java 21</td><td>⭐⭐⭐ 重大变革</td></tr><tr><td>Sequenced Collections</td><td>Java 21</td><td>⭐ 了解即可</td></tr><tr><td>Record Patterns</td><td>Java 21</td><td>⭐⭐ 值得掌握</td></tr></tbody></table><hr />]]>
    </content>
    <id>http://example.com/2023/12/29/java-new-features/</id>
    <link href="http://example.com/2023/12/29/java-new-features/"/>
    <published>2023-12-29T04:00:00.000Z</published>
    <summary>
      <![CDATA[<h1 id="java821新特性总结"><a class="markdownIt-Anchor" href="#java821新特性总结"></a> Java8→21新特性总结</h1>
<hr />
<h2 id="目录"><a class="markdownIt-Anch]]>
    </summary>
    <title>Java-New-Features</title>
    <updated>2026-02-27T06:45:26.514Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    <category term="ZFS" scheme="http://example.com/tags/ZFS/"/>
    <content>
      <![CDATA[<h1 id="zfs"><a class="markdownIt-Anchor" href="#zfs"></a> zfs</h1><p>ZFS（Zettabyte File System）是一种高级的文件系统和卷管理器，最初由Sun Microsystems开发。它具有许多先进的功能，旨在提供高性能、数据完整性、可扩展性和先进的存储管理功能。ZFS最初是为Solaris操作系统设计的，但现在也可在其他操作系统上使用，包括各种Linux发行版和FreeBSD。</p><p>以下是ZFS的一些关键特点和功能：</p><ol><li><strong>数据完整性</strong>： ZFS以数据完整性为中心，可以检测和修复存储介质上的数据损坏。它使用称为校验和的技术来验证数据的完整性，并可以自动修复损坏的数据，以确保数据的一致性和可靠性。</li><li><strong>快照</strong>： ZFS支持快照，允许您在不影响当前数据的情况下捕获文件系统的快照。这对于备份、版本控制和数据还原非常有用。</li><li><strong>克隆</strong>： 您可以使用ZFS克隆功能创建文件系统的副本，这些副本与原始文件系统共享相同的数据块。这对于测试和开发环境非常有用。</li><li><strong>自动扩展</strong>： ZFS可以动态增加存储池的大小，而无需离线或重新分区。这使得存储管理更加灵活。</li><li><strong>数据压缩</strong>： ZFS支持数据压缩，可以减少存储空间的使用，并提高读取和写入性能。</li><li><strong>快速快照和克隆</strong>： ZFS的快照和克隆操作非常快速，因为它们不涉及实际数据复制。</li><li><strong>RAID-Z</strong>： 类似于RAID，ZFS提供了一种称为RAID-Z的数据保护机制，可以在硬件RAID的情况下提供更高的可靠性和性能。</li><li><strong>灵活的存储池</strong>： ZFS允许您创建存储池，将多个磁盘组合在一起，以提供容错性和性能。总之，ZFS是一个强大的文件系统和存储管理系统，具有出色的数据完整性、快照、克隆和自动扩展等功能。它在大规模数据存储、虚拟化环境和高性能计算等领域广泛使用。许多操作系统和存储设备都支持ZFS，因此它在各种平台上都有广泛的应用。</li></ol><h2 id="zfs使用"><a class="markdownIt-Anchor" href="#zfs使用"></a> zfs使用</h2><blockquote><p>注意：在使用ZFS时，请小心谨慎，特别是在生产环境中。不正确的操作可能导致数据丢失。请根据您的需求和环境，调整这些命令。</p></blockquote><ol><li>创建ZFS存储池：</li></ol><p>首先，让我们创建一个名为&quot;myzpool&quot;的ZFS存储池，并使用两个硬盘作为存储设备。</p><pre><code class="highlight shell">sudo zpool create myzpool /dev/sdb /dev/sdc</code></pre><ol start="2"><li>创建ZFS文件系统：</li></ol><p>在存储池上创建一个ZFS文件系统，命名为&quot;myfilesystem&quot;。</p><pre><code class="highlight sh"><span class="built_in">sudo</span> zfs create myzpool/myfilesystem</code></pre><ol start="3"><li>设置数据压缩：</li></ol><p>启用数据压缩以节省存储空间。</p><pre><code class="highlight sh"><span class="built_in">sudo</span> zfs <span class="built_in">set</span> compression=on myzpool/myfilesystem</code></pre><ol start="4"><li>创建快照：</li></ol><p>创建一个名为&quot;snapshot1&quot;的ZFS快照。</p><pre><code class="highlight sh"><span class="built_in">sudo</span> zfs snapshot myzpool/myfilesystem@snapshot1<span class="comment">#回滚到快照</span><span class="built_in">sudo</span> zfs rollback myzpool/myfilesystem@snapshot1</code></pre><ol start="5"><li>查看快照列表：</li></ol><p>查看所有快照的列表。</p><pre><code class="highlight plaintext">sudo zfs list -t snapshot</code></pre><ol start="6"><li>创建克隆：</li></ol><p>创建一个名为&quot;clone1&quot;的克隆，基于&quot;snapshot1&quot;。</p><pre><code class="highlight plaintext">sudo zfs clone myzpool/myfilesystem@snapshot1 myzpool/clone1</code></pre><ol start="7"><li>扩展存储池：</li></ol><p>添加一个新的硬盘来扩展存储池。</p><pre><code class="highlight plaintext">sudo zpool add myzpool /dev/sdd</code></pre><ol start="8"><li>显示存储池信息：</li></ol><p>查看存储池的信息，包括使用量、可用空间等。</p><pre><code class="highlight plaintext">sudo zpool status myzpool</code></pre><ol start="9"><li>卸载存储池：</li></ol><p>在不再需要存储池时，可以卸载它。</p><pre><code class="highlight plaintext">sudo zpool destroy myzpool</code></pre><h2 id="共享挂载"><a class="markdownIt-Anchor" href="#共享挂载"></a> 共享挂载</h2><p>要将ZFS文件系统目录挂载到另一台机器上，通常使用<strong>NFS</strong>（Network File System）来实现网络共享。您可以将ZFS文件系统目录导出为NFS共享，并在远程机器上挂载该共享。以下是一些简单的步骤来实现这一目标：</p><h3 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h3><ol><li>安装和配置NFS服务器：</li></ol><p>如果尚未安装NFS服务器，您需要在ZFS服务器上安装并配置它。具体安装方法取决于您使用的操作系统。例如，在Ubuntu上，您可以使用以下命令安装NFS服务器：</p><pre><code class="highlight plaintext">sudo apt-get install nfs-kernel-server</code></pre><ol start="2"><li>创建ZFS文件系统：</li></ol><p>如果还没有创建ZFS文件系统，可以使用以下命令创建它：</p><pre><code class="highlight plaintext">sudo zfs create myzpool/myfilesystem</code></pre><ol start="3"><li>配置NFS共享：</li></ol><p>编辑NFS服务器的配置文件以指定共享。<strong>打开/etc/exports</strong>文件并添加要共享的目录，例如：</p><ul><li><code>/myzpool/myfilesystem</code> 是您要共享的ZFS文件系统目录的路径。</li><li><code>*</code> 允许所有主机访问共享。</li><li><code>rw</code> 允许读写访问。</li><li><code>sync</code> 使用同步写入模式。</li><li><code>no_root_squash</code> 允许远程root用户访问。</li><li><code>no_subtree_check</code> 禁用子目录检查。</li><li><code>all_squash</code>：将所有远程客户端的用户映射为匿名用户。这意味着无论哪个客户端连接，都将以匿名用户的身份进行访问，而不会考虑其实际用户身份。</li><li><code>insecure</code>：允许不安全的访问，通常用于允许非特权端口的客户端连接。这可以在某些情况下提高兼容性，但可能会降低安全性。</li><li><code>anonuid=0</code>：将匿名用户的UID设置为0，即root用户。这意味着远程客户端以root用户的身份访问共享。</li><li><code>anongid=0</code>：将匿名用户的GID设置为0，即root用户的组。</li></ul><pre><code class="highlight plaintext">/myzpool/myfilesystem *(rw,sync,no_root_squash,no_subtree_check)</code></pre><ol start="4"><li>重新加载NFS配置： 在编辑完/etc/exports文件后，重新加载NFS服务器配置以使更改生效：</li></ol><pre><code class="highlight plaintext">sudo exportfs -ra</code></pre><ol start="5"><li>启动NFS服务： 启动NFS服务器服务：</li></ol><pre><code class="highlight plaintext">sudo systemctl start nfs-kernel-server # 对于基于systemd的系统</code></pre><h3 id="远端机器"><a class="markdownIt-Anchor" href="#远端机器"></a> 远端机器</h3><ol><li>安装NFS客户端：</li></ol><p>如果尚未安装NFS客户端，您需要在远程机器上安装它。具体安装方法取决于您使用的操作系统。例如，在Ubuntu上，您可以使用以下命令安装NFS客户端：bash</p><pre><code class="highlight plaintext">sudo apt-get install nfs-common</code></pre><ol start="2"><li>创建本地挂载点：</li></ol><p>在远程机器上创建一个本地挂载点，用于将ZFS共享挂载到远程机器上。例如：</p><pre><code class="highlight plaintext">sudo mkdir /mnt/zfs_share # 替换成您喜欢的本地挂载点路径</code></pre><ol start="3"><li>挂载ZFS共享：</li></ol><p>使用mount命令将ZFS共享挂载到本地挂载点。例如：</p><pre><code class="highlight plaintext">sudo mount -t nfs &lt;ZFS服务器IP或主机名&gt;:/myzpool/myfilesystem /mnt/zfs_share</code></pre><blockquote><p>请替换&lt;ZFS服务器IP或主机名&gt;、/myzpool/myfilesystem和/mnt/zfs_share为实际的值。</p></blockquote>]]>
    </content>
    <id>http://example.com/2023/09/03/ZFS/</id>
    <link href="http://example.com/2023/09/03/ZFS/"/>
    <published>2023-09-03T04:00:00.000Z</published>
    <summary>ZFS（Zettabyte File System）是一种高级的文件系统和卷管理器，最初由Sun Microsystems开发。它具有许多先进的功能，旨在提供高性能、数据完整性、可扩展性和先进的存储管理功能。ZFS最初是为Solaris操作系统设计的，但现在也可在其他操作系统上使用，包括各种Linux发行版和FreeBSD。</summary>
    <title>ZFS</title>
    <updated>2026-02-27T01:39:31.319Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Spring Cloud" scheme="http://example.com/tags/Spring-Cloud/"/>
    <content>
      <![CDATA[<h1 id="微服务框架-spring-cloud"><a class="markdownIt-Anchor" href="#微服务框架-spring-cloud"></a> 微服务框架 Spring Cloud</h1><p>[toc]</p><hr /><h2 id="spring-cloud入门"><a class="markdownIt-Anchor" href="#spring-cloud入门"></a> Spring Cloud入门</h2><h3 id="微服务与微服务架构"><a class="markdownIt-Anchor" href="#微服务与微服务架构"></a> 微服务与微服务架构</h3><p>做服务架构是一种新型的系统架构。其设计思路是。<strong>将单体架构系统拆分为多个可以相互调用、配合的独立运行的小程序</strong>。这每个小程序对整体系统所提供的功能就称为一个微服务。</p><p>由于每个微服务都是独立运行的，所以每个教服务都独自占用一个进程。<strong>微服务间采用轻量级的HTTP RESTful协议通信，每个微服务程序不受编程语言的限制，整个系统关心的是微服务程序所提供的具体服务，并不关心其具体的实现</strong>。每个微服务可以有自己独立的数据库。即可以操作自己的独立数据库，也可以操作整体系统的数据库。</p><h3 id="spring-cloud简介"><a class="markdownIt-Anchor" href="#spring-cloud简介"></a> Spring Cloud简介</h3><h4 id="百度百科"><a class="markdownIt-Anchor" href="#百度百科"></a> 百度百科</h4><p><strong>Spring Cloud是一系列框架的有序集合</strong>。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者提供了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><p>简单来说，Spring Cloud就是将现有的分布式开发技术整合到了Spring Boot中。形象地讲，Spring Boot就是火锅，而现有的分布式开发技术就是要吃的“涮菜、测肉&quot;，而学习SpringCloud就是在“吃火锅”</p><p>截止到目前，Spring Cloud已经集成了至少24种技术框架。在Spring Cloud官网首页可以一目了然这24种技术。<br /><a href="https://spring.io/projects/spring-cloud">Spring Cloud 官 网</a></p><h4 id="官网介绍"><a class="markdownIt-Anchor" href="#官网介绍"></a> 官网介绍</h4><p><a href="http://spring.io">打开spring官网：http://spring.io</a></p><p>翻译：构建分布式系统不需要复杂和容易出错，Spring Cloud为最常见的分布式系统模式提供了一种简单且易于接受的编程模型，帮助开发人员构建有弹性的、可靠的、协调的应用程序，Spring Cloud构建于Spring Boot之上，使得开发者很容易入手并快速应用于生产中。</p><p>该简介下方即为官方提供的Spring Cloud项目的体系结构图，从中可以看到，其为N多种技术的综合体</p><blockquote><p>IoT ：Internet of Things 物联网</p></blockquote><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p>Spring Cloud是什么？</p><p><strong>Spring Cloud是微服务系统架构的一站式解决方案</strong></p><p>Spring Cloud和Spring Boot是什么关系呢？</p><p><strong>Spring Boot为Spring Cloud提供了代码实现环境</strong>，使用Spring Boot将其他组件有机融合到了Spring Cloud的体系架构中了，所以说，springCloud是基于Spring Boot的，微服务系统架构的一站式解决方案</p><h4 id="spring-cloud-在线资源"><a class="markdownIt-Anchor" href="#spring-cloud-在线资源"></a> Spring Cloud 在线资源</h4><p><a href="https://spring.io/projects/spring-cloud">Spring Cloud 官网：https://spring.io/projects/spring-cloud</a></p><p><a href="https://springcloud.cc/">Spring Cloud中文网：https://springcloud.cc/</a></p><p><a href="http://springcloud.cn/">Spring Cloud中国社区：http:/springcloud.cn/</a></p><h3 id="spring-clouddubbo"><a class="markdownIt-Anchor" href="#spring-clouddubbo"></a> Spring Cloud/Dubbo</h3><p><strong>Spring Cloud与Dubbo均为微服务框架</strong>，开发团队在进行技术选型时，总会将它们进行对比，考虑应该选择哪一个。其实这两个概架没有可比性</p><p>与Spring Cloud相比，Dubbo 的架构完整度不够，其本身仅仅提供了服务注册中心与服务治理两个模块，而Sping Cloud到目前为止已经提供了服务注册中心服务治理等24个模块，并且现在还在增加中。，</p><p>Dubbo本身仅仅提供了服务注册中心与服务治理两个模块，并不是说其它功能其就不能够实现，Dubbo的设计是开放型的，其可通过整合第三方的相关功能框架。但也正因为如此，搭建出的Dubbo架构可能就存在兼容性问题。而Spring Cloud不存在这个问题，其出品的每一个模块都是经过严格测试的，几乎不存在兼容性问题。所以，若将Spring Cloud比作品牌电脑的话，Dubbo就是一台自己动手组装的电脑。</p><p>与Spring Cloud相比，Dubbo的社区活跃度太低。对于团队来说，社区活跃度高低将会影响整个项目的维护成本。当社区活跃度很高时，在一般性的工程中遇到的问题，在社区中基本都可找到相应的解决方案</p><p><strong>Dubbo服务间的通讯采用的是RPC</strong>,而<strong>Spring Cloud则采用的是HTTP的REST</strong>. RPC对于业务接口具有强依赖性，必须要保证通讯双方具有相同的业务接口。而这个保证就必须要通过严格的业务接口版本管理来实现。这种强依赖在大型的微服务项目中将会成为一个很大的问题。相比RPC, REST更为轻量化。服务提供者和调用者间的依赖仅仅是一纸契约，一段文本，不存在代码级别的强依赖。</p><p>对于国内开发团队来说，可能选择Dubbo的一个很重要原因就是官方文档。Dubbo 提供了高质量的中文版官方文档，而Spring Cloud的文档都是英文版的。Spring Cloud文档在体量上比Dubbo多很多，文档内容更多的是偏向模块整合，对于每个模块更深入的方法，两要用户查看其更为详细文档。对于中小型开发团队来说，对于英文文档的阅读成本，是必须要考虑的。</p><h3 id="服务提供者消费者项目"><a class="markdownIt-Anchor" href="#服务提供者消费者项目"></a> 服务提供者/消费者项目</h3><p>该项目为后续学习Spring Cloud的基础项目，也是前提准备</p><h4 id="服务提供者项目"><a class="markdownIt-Anchor" href="#服务提供者项目"></a> 服务提供者项目</h4><p><strong>项目创建</strong></p><p>创建一个基础的Spring Boot项目：</p><p>项目名：</p><p>导入项目基础jar包：</p><p>项目目录如下：</p><hr /><p><strong>pom依赖</strong></p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>provider<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!--修改MySQL驱动版本--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p><strong>主配置文件application.properties</strong></p><pre><code class="highlight properties"><span class="comment">#指定端口号</span><span class="attr">server.port</span>=<span class="string">8081</span><span class="comment">#更改访问上下文路径/访问路径 localhost:8088/leeBoot/...</span><span class="comment">#server.servlet.context-path=/leeBoot</span><span class="comment"></span><span class="comment">#开启启动时自动建表</span><span class="attr">spring.jpa.generate-ddl</span>=<span class="string">true</span><span class="comment">#是否在控制台显示sql语句</span><span class="attr">spring.jpa.show-sql</span>=<span class="string">true</span><span class="comment">#设置应用启动时不重新建表</span><span class="attr">spring.jpa.hibernate.ddl-auto</span>=<span class="string">none</span><span class="comment"></span><span class="comment">#配置数据源</span><span class="attr">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/leetest?characterEncoding=UTF-8</span><span class="attr">spring.datasource.username</span>=<span class="string">root</span><span class="attr">spring.datasource.password</span>=<span class="string">123456</span><span class="comment"></span><span class="comment"></span><span class="comment"></span><span class="comment">#配置日志输出格式</span><span class="attr">logging.pattern.console</span>=<span class="string">%level %msg%n</span><span class="comment">#设置spring boot启动时的日志级别</span><span class="attr">logging.level.root</span>=<span class="string">info</span><span class="comment">#hibernate运行日志级别   org.gibernate表示类名</span><span class="attr">logging.level.org.hibernate</span>=<span class="string">info</span><span class="comment">#在show-sql为true时显示sql中的动态参数值</span><span class="attr">logging.level.org.hibernate.type.descriptor.sql.BasicBinder</span>=<span class="string">trace</span><span class="comment">#在show-sql为true时显示查询结果</span><span class="attr">logging.level.org.hibernate.type.descriptor.sql.BasicExtractor</span>=<span class="string">trace</span><span class="comment">#控制自己代码运行时显示的日志级别</span><span class="attr">logging.level.com.lee</span>=<span class="string">debug</span></code></pre><hr /><p><strong>编写bean</strong></p><ul><li>因为我们使用Spring Data JPA，所以我们不需要建表，框架会帮我们建好数据库表</li><li>@<code>Entity</code>：数据库名与实体类名一一映射</li><li>@<code>JsonIgnoreProperties</code>：<ul><li>忽略掉hebernate的延迟加载，防止要json序列化值时其值为空</li><li>用来在json序列化时将java bean中的一些属性忽略掉</li></ul></li><li>@<code>Id</code>：用在成员变量，表示该字段时主键</li><li>@<code>GeneratedValue</code>：用在成员变量，可设置字段自增</li><li>@<code>Column</code>：用在成员变量，表明对应的数据库字段名</li></ul><blockquote><p>controller处理器方法的返回值是作为json数据响应给浏览器的，这个数据转换工作是由SpringMVC的HttpMessageConverter接口完成的，确切的说，是由该接口的一个实现类Jackson完成的</p></blockquote><blockquote><p>但默认情况下，Hibernate对所有对象的查询采用了延迟加载策略，由Hibernate延迟初始化器hibernateLazyInitializer完成，其首先会将javasist，动态代理对象先传递给了Jackson，在访问详情时在做查询，但Jackson在拿到代理对象后马上就要将其转换为json而不等待，所以我们要使用@JsonIgnoreProperties注解忽略掉hebernate的延迟加载</p></blockquote><pre><code class="highlight java"><span class="keyword">package</span> com.lee.provider.bean;<span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonIgnoreProperties;<span class="keyword">import</span> lombok.Data;<span class="keyword">import</span> javax.persistence.*;<span class="comment">/**</span><span class="comment"> * 这里先不使用mybatis,使用Spring Data JPA</span><span class="comment"> * jpa可以自动根据该类在数据库中生成表</span><span class="comment"> */</span><span class="meta">@Data</span>   <span class="comment">//lombok用来生成getter和setter方法的</span><span class="comment">//用来将该实体类与数据库表进行一对一映射,不写name表示和数据库表depart一对一映射</span><span class="meta">@Entity(name = &quot;t_depart&quot;)</span><span class="comment">//忽略掉hebernate的延迟加载</span><span class="comment">//还可以用来在json序列化时将java bean中的一些属性忽略掉</span><span class="meta">@JsonIgnoreProperties(&#123;&quot;hibernateLazyInitializer&quot;,&quot;handler&quot;,&quot;fieldHandler&quot;&#125;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Depart</span> &#123;    <span class="comment">//表示主键</span>    <span class="meta">@Id</span>    <span class="comment">//设置字段自增</span>    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>    <span class="keyword">private</span> Integer id;    <span class="comment">//表明对应的数据库字段名</span>    <span class="meta">@Column(name = &quot;name&quot;)</span>    <span class="keyword">private</span> String name;    <span class="meta">@Column(name = &quot;dbase&quot;)</span>    <span class="keyword">private</span> String dbase;&#125;</code></pre><hr /><p><strong>编写dao层</strong></p><p>对于spring Data来说，dao层默认名字为Repository</p><ul><li>JpaRepository继承自PagingAndSortingRepository接口，JpaRepository基于JPA的Repository接口，极大减少了JPA作为数据访问的代码，JpaRepository是实现Spring Data JPA技术访问数据库的关键接口</li><li>当我们需要定义自己的Repository的时候，我们可以继承JpaRepository，从而获得Spring为我们预先定义的多种基本数据操作方法</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.provider.repository;<span class="keyword">import</span> com.lee.provider.bean.Depart;<span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;<span class="comment">/**</span><span class="comment"> * 这个类相当于mybatis时的dao</span><span class="comment"> *</span><span class="comment"> * 第一个泛型:当前Repository的操作对象类型</span><span class="comment"> * 第二个泛型:当前Repository的操作对象的id类型</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DepartRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Depart, Integer&gt; &#123;&#125;</code></pre><hr /><p><strong>编写service层</strong></p><p>service层接口</p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.provider.service;<span class="keyword">import</span> com.lee.provider.bean.Depart;<span class="keyword">import</span> java.util.List;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DepartService</span> &#123;    <span class="type">boolean</span> <span class="title function_">saveDepart</span><span class="params">(Depart depart)</span>;    <span class="type">boolean</span> <span class="title function_">removeDepartById</span><span class="params">(<span class="type">int</span> id)</span>;    <span class="type">boolean</span> <span class="title function_">modifyDepart</span><span class="params">(Depart depart)</span>;    Depart <span class="title function_">getDepartById</span><span class="params">(<span class="type">int</span> id)</span>;    List&lt;Depart&gt; <span class="title function_">listAllDeparts</span><span class="params">()</span>;&#125;</code></pre><p>service层实现：</p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.provider.service;<span class="keyword">import</span> com.lee.provider.bean.Depart;<span class="keyword">import</span> com.lee.provider.repository.DepartRepository;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.stereotype.Service;<span class="keyword">import</span> java.util.List;<span class="meta">@Service</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">DepartService</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> DepartRepository repository;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveDepart</span><span class="params">(Depart depart)</span> &#123;        <span class="comment">//如果这个depart的id在数据库中存在，就执行update</span>        <span class="comment">//如果这个depart的id字数据库中不存在，就执行insert</span>        <span class="comment">//返回值就是你插入的对象</span>        <span class="type">Depart</span> <span class="variable">result</span> <span class="operator">=</span> repository.save(depart);        <span class="keyword">if</span> (result!=<span class="literal">null</span>) &#123;            <span class="keyword">return</span> <span class="literal">true</span>;        &#125;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeDepartById</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="comment">//判断数据库是否有id</span>        <span class="keyword">if</span> (repository.existsById(id)) &#123;            <span class="comment">//如果数据库有id，就会给删除掉，如果没有该id,执行就会抛异常</span>            repository.deleteById(id);            <span class="keyword">return</span> <span class="literal">true</span>;        &#125;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">modifyDepart</span><span class="params">(Depart depart)</span> &#123;        <span class="comment">//如果这个depart的id在数据库中存在，就执行update</span>        <span class="comment">//如果这个depart的id字数据库中不存在，就执行insert</span>        <span class="comment">//返回值就是你插入的对象</span>        <span class="type">Depart</span> <span class="variable">result</span> <span class="operator">=</span> repository.save(depart);        <span class="keyword">if</span> (result!=<span class="literal">null</span>) &#123;            <span class="keyword">return</span> <span class="literal">true</span>;        &#125;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> Depart <span class="title function_">getDepartById</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="comment">//判断数据库是否有id</span>        <span class="keyword">if</span> (repository.existsById(id)) &#123;            <span class="comment">//如果id不存在，会抛出异常</span>            <span class="keyword">return</span> repository.getOne(id);        &#125;        <span class="comment">//尽量避免给返回null</span>        <span class="type">Depart</span> <span class="variable">depart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Depart</span>();        depart.setName(<span class="string">&quot;no this depart&quot;</span>);        <span class="keyword">return</span> depart;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> List&lt;Depart&gt; <span class="title function_">listAllDeparts</span><span class="params">()</span> &#123;        <span class="keyword">return</span> repository.findAll();    &#125;&#125;</code></pre><hr /><p><strong>编写Controller</strong></p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.provider.Controller;<span class="keyword">import</span> com.lee.provider.bean.Depart;<span class="keyword">import</span> com.lee.provider.service.DepartService;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.web.bind.annotation.*;<span class="keyword">import</span> java.util.List;<span class="meta">@RequestMapping(&quot;/provider/depart&quot;)</span><span class="meta">@RestController</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartController</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> DepartService service;    <span class="meta">@PostMapping(&quot;/save&quot;)</span>    <span class="comment">//@RequestBody表示传过来的数据时json数据</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveHandle</span><span class="params">(<span class="meta">@RequestBody</span> Depart depart)</span> &#123;        <span class="keyword">return</span> service.saveDepart(depart);    &#125;    <span class="meta">@DeleteMapping(&quot;/del/&#123;id&#125;&quot;)</span>    <span class="comment">//@PathVariable 表示获取url中的&#123;id&#125;的值</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteHandle</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;        <span class="keyword">return</span> service.removeDepartById(id);    &#125;    <span class="meta">@PutMapping(&quot;/update&quot;)</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateHandle</span><span class="params">(<span class="meta">@RequestBody</span> Depart depart)</span>&#123;        <span class="keyword">return</span> service.modifyDepart(depart);    &#125;    <span class="meta">@GetMapping(&quot;/get/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> Depart <span class="title function_">GetHandle</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span>&#123;        <span class="keyword">return</span> service.getDepartById(id);    &#125;    <span class="meta">@GetMapping(&quot;/list&quot;)</span>    <span class="keyword">public</span> List&lt;Depart&gt; <span class="title function_">listHandle</span><span class="params">()</span> &#123;        <span class="keyword">return</span> service.listAllDeparts();    &#125;&#125;</code></pre><h4 id="消费者项目"><a class="markdownIt-Anchor" href="#消费者项目"></a> 消费者项目</h4><p><strong>项目创建</strong></p><p>创建一个基础的Spring Boot项目：</p><p>项目名：</p><p>添加相关jar包：</p><p>项目目录如下：</p><hr /><p><strong>pom依赖</strong></p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p><strong>spring boot主配置文件</strong></p><pre><code class="highlight properties"><span class="comment">#指定端口号</span><span class="attr">server.port</span>=<span class="string">8080</span></code></pre><hr /><p><strong>编写bean</strong></p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer.bean;<span class="keyword">import</span> lombok.Data;<span class="meta">@Data</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Depart</span> &#123;    <span class="keyword">private</span> Integer id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> String dbase;&#125;</code></pre><hr /><p><strong>编写Configuration文件</strong></p><ul><li>传统情况下在java代码里访问restful服务，一般使用Apache的HttpClient。不过此种方法使用起来太过繁琐。spring提供了一种简单便捷的模板类来进行操作，这就是<strong>RestTemplate</strong></li><li>调用远程服务时就必须使用HTTP客户端,主要有四种：JDK原生的URLConnection、Apache的Http Client、Netty的异步HTTP Client, Spring的RestTemplate。</li><li>restTemplate是spring提供的可以提供访问rest服务的客户端工具类，提供多种快捷的访问远程的方法，大大提高了客户端的编程效率。解放了原先HttpClient的复杂提交，java中调用RESTful服务很典型的是使用HttpClient，对于常用的REST操作，这些方法属于低等级的操作。使用HttpClient我们需要自己封装Post请求，再根据响应的状态码判断从响应中获取header和body，有时候还需要自己做json转换</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer.codeconfig;<span class="keyword">import</span> org.springframework.context.annotation.Bean;<span class="keyword">import</span> org.springframework.context.annotation.Configuration;<span class="keyword">import</span> org.springframework.web.client.RestTemplate;<span class="meta">@Configuration</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartCodeConfig</span> &#123;    <span class="meta">@Bean</span>    <span class="comment">//bean的名称就相当于方法名</span>    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();    &#125;&#125;</code></pre><hr /><p><strong>编写Controller</strong></p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer.Controller;<span class="keyword">import</span> com.lee.consumer.bean.Depart;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.web.bind.annotation.*;<span class="keyword">import</span> org.springframework.web.client.RestTemplate;<span class="keyword">import</span> java.util.List;<span class="meta">@RestController</span><span class="meta">@RequestMapping(&quot;/consumer/depart&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartController</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> RestTemplate restTemplate;    <span class="meta">@PostMapping(&quot;/save&quot;)</span>    <span class="comment">//@RequestBody表示传过来的数据时json数据</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveHandle</span><span class="params">(Depart depart)</span> &#123;        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081/provider/depart/save&quot;</span>;        <span class="comment">//url/传入参数/调用方法返回值</span>        <span class="keyword">return</span> restTemplate.postForObject(url, depart, Boolean.class);    &#125;    <span class="meta">@DeleteMapping(&quot;/del/&#123;id&#125;&quot;)</span>    <span class="comment">//@PathVariable 表示获取url中的&#123;id&#125;的值</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteHandle</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081/provider/depart/del/&quot;</span>+id;        restTemplate.delete(url);    &#125;    <span class="meta">@PutMapping(&quot;/update&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateHandle</span><span class="params">(Depart depart)</span> &#123;        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081/provider/depart/update&quot;</span>;        restTemplate.put(url,depart);    &#125;    <span class="meta">@GetMapping(&quot;/get/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> Depart <span class="title function_">GetHandle</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span> &#123;        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081/provider/depart/get/&quot;</span>+id;        <span class="keyword">return</span> restTemplate.getForObject(url,Depart.class);    &#125;    <span class="meta">@GetMapping(&quot;/list&quot;)</span>    <span class="keyword">public</span> List&lt;Depart&gt; <span class="title function_">listHandle</span><span class="params">()</span> &#123;        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081/provider/depart/list&quot;</span>;        <span class="keyword">return</span> restTemplate.getForObject(url, List.class);    &#125;&#125;</code></pre><h2 id="相关注解详解"><a class="markdownIt-Anchor" href="#相关注解详解"></a> 相关注解详解</h2><h3 id="json序列化相关注解"><a class="markdownIt-Anchor" href="#json序列化相关注解"></a> JSON序列化相关注解</h3><p><strong>问题由来：</strong><br />springboot项目中定义了很多类，我们在rest返回中直接返回或者在返回对象中使用这些类，spring已经使用jackson自动帮我们完成这些的to json。但是有时候自动转的json内容太多，或者格式不符合我们的期望，因此需要调整类的to json过程，或者说希望自定义类的json过程。</p><p><strong>问题解决</strong></p><p>使用@JsonIgnoreProperties、@JsonIgnore、@JsonForma。</p><ul><li><p>@<strong>JsonIgnore</strong>注解用来忽略某些字段，可以用在变量或者Getter方法上，用在Setter方法时，和变量效果一样。这个注解一般用在我们要忽略的字段上。</p></li><li><p>@<strong>JsonIgnoreProperties</strong>(ignoreUnknown = true)，将这个注解写在类上之后，就会忽略类中不存在的字段。这个注解还可以指定要忽略的字段，例如@JsonIgnoreProperties({ “password”, “secretKey” })</p></li><li><p>@<strong>JsonFormat</strong>可以帮我们完成格式转换。例如对于Date类型字段，如果不适用JsonFormat默认在rest返回的是long，如果我们使用@JsonFormat(timezone = “GMT+8”, pattern = “yyyy-MM-dd HH:mm:ss”)，就返回&quot;2018-11-16 22:58:15&quot;</p></li></ul><p><a href="https://fasterxml.github.io/jackson-annotations/javadoc/2.6/com/fasterxml/jackson/annotation/JsonIgnoreProperties.html">具体可以参考官方文档</a></p><blockquote><p>@JsonIgnoreProperties与@JsonIgnore的主要区别在于， @JsonIgnoreProperties是类级别的， 而@JsonIgnore是变量和方法级别的。</p></blockquote><p><strong>代码示例</strong><br />代码简要说明， User类的fullName 和comment字段会被@JsonIgnoreProperties注解忽略。address字段会被@JsonIgnore注解忽略。regDate会按照@JsonFormat(timezone = “GMT+8”, pattern = “yyyy-MM-dd HH:mm:ss”)进行格式转</p><pre><code class="highlight java"><span class="meta">@Data</span><span class="meta">@JsonIgnoreProperties(value = &#123;&quot;fullName&quot;, &quot;comment&quot;&#125;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;    <span class="keyword">private</span> String id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> String fullName;    <span class="keyword">private</span> String comment;    <span class="keyword">private</span> String mail;    <span class="meta">@JsonIgnore</span>    <span class="keyword">private</span> String address;    <span class="meta">@JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span>    <span class="keyword">private</span> Date regDate;    <span class="keyword">private</span> Date reg2Date;&#125;</code></pre><p>Controller代码</p><pre><code class="highlight java"><span class="meta">@ApiOperation(value = &quot;按用户id删除&quot;, notes=&quot;private&quot;)</span><span class="meta">@ApiImplicitParams(&#123;</span><span class="meta">        @ApiImplicitParam(name = &quot;userId&quot;, defaultValue = &quot;2&quot;, value = &quot;userID&quot;, required = true, dataType = &quot;string&quot;, paramType = &quot;path&quot;),</span><span class="meta">&#125;)</span><span class="meta">@DeleteMapping(value = &quot;/users/&#123;userId&#125;&quot;, produces = &quot;application/json;charset=UTF-8&quot;)</span><span class="keyword">public</span> User <span class="title function_">delUser</span><span class="params">(<span class="meta">@PathVariable</span> String userId)</span> &#123;    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)userSvc.deleteById(userId);    log.info(<span class="string">&quot;rest del user=&#123;&#125; by id=&#123;&#125;&quot;</span>, user, userId);    <span class="keyword">return</span> user;&#125;</code></pre><p>可以看到返回的对象是User，然后comment、fullName、address属性被忽略了，regDate的格式进行转换</p><h3 id="generatedvalue"><a class="markdownIt-Anchor" href="#generatedvalue"></a> @GeneratedValue</h3><p>@GeneratedValue注解存在的意义主要就是<strong>为一个实体生成一个唯一标识的主键</strong>、@GeneratedValue提供了主键的生成策略</p><p>@GeneratedValue注解有两个属性,分别是strategy和generator,</p><ul><li>generator属性：<ul><li>generator属性的值是一个字符串,默认为&quot;&quot;,其声明了主键生成器的名称(对应于同名的主键生成器@SequenceGenerator和@TableGenerator)</li></ul></li></ul><hr /><ul><li><strong>strategy属性</strong>：提供四种值:<ul><li>AUTO：主键由程序控制, 是默认选项 ,不设置就是这个</li><li>IDENTITY ：主键由数据库生成, 采用数据库自增长, Oracle不支持这种方式</li><li>SEQUENCE： 通过数据库的序列产生主键, MYSQL  不支持</li><li>Table ：提供特定的数据库产生主键, 该方式更有利于数据库的移植</li></ul></li></ul><blockquote><p>默认SpringBoot的@GeneratedValue 是不需要加参数的,但是如果数据库控制主键自增(auto_increment), 不加参数就会报错</p></blockquote><h3 id="spring-data-jpa之jparepository"><a class="markdownIt-Anchor" href="#spring-data-jpa之jparepository"></a> Spring Data JPA之JpaRepository</h3><p><strong>使用Spring Data JPA CrudRepository 和JpaRepository 的好处</strong>：</p><ul><li>继承这些接口，可以使Spring找到自定义的数据库操作接口，并生成代理类，后续可以注入到Spring容器中；</li><li>可以不写相关的sql操作，由代理类生成</li></ul><p><strong>JpaRepository接口的官方定义如下</strong>：</p><pre><code class="highlight plaintext">public interface JpaRepository&lt;T, ID&gt; extends PagingAndSortingRepository&lt;T, ID&gt;, QueryByExampleExecutor&lt;T&gt;</code></pre><p>可以看出JpaRepository继承了接口PagingAndSortingRepository和QueryByExampleExecutor。而，PagingAndSortingRepository又继承CrudRepository。</p><p>也就是说， CrudRepository 提供基本的增删改查；PagingAndSortingRepository 提供分页和排序方法；JpaRepository 提供JPA需要的方法</p><p><strong>当我们需要定义自己的Repository的时候，我们可以继承JpaRepository</strong>，从而获得Spring为我们预先定义的多种基本数据操作方法。</p><pre><code class="highlight plaintext">public interface UserRepository extends JpaRepository&lt;User, Integer&gt; &#123;&#125;</code></pre><p><strong>各函数说明</strong></p><pre><code class="highlight java"> <span class="comment">/**</span><span class="comment">    * 保存一个实体。</span><span class="comment">    */</span>   &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; S <span class="title function_">save</span><span class="params">(S entity)</span>;   <span class="comment">/**</span><span class="comment">    * 保存提供的所有实体。</span><span class="comment">    */</span>   &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; Iterable&lt;S&gt; <span class="title function_">saveAll</span><span class="params">(Iterable&lt;S&gt; entities)</span>;   <span class="comment">/**</span><span class="comment">    * 根据id查询对应的实体。</span><span class="comment">    */</span>   Optional&lt;T&gt; <span class="title function_">findById</span><span class="params">(ID id)</span>;   <span class="comment">/**</span><span class="comment">    * 根据id查询对应的实体是否存在。</span><span class="comment">    */</span>   <span class="type">boolean</span> <span class="title function_">existsById</span><span class="params">(ID id)</span>;   <span class="comment">/**</span><span class="comment">    * 查询所有的实体。</span><span class="comment">    */</span>   Iterable&lt;T&gt; <span class="title function_">findAll</span><span class="params">()</span>;   <span class="comment">/**</span><span class="comment">    * 根据给定的id集合查询所有对应的实体，返回实体集合。</span><span class="comment">    */</span>   Iterable&lt;T&gt; <span class="title function_">findAllById</span><span class="params">(Iterable&lt;ID&gt; ids)</span>;   <span class="comment">/**</span><span class="comment">    * 统计现存实体的个数。</span><span class="comment">    */</span>   <span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;   <span class="comment">/**</span><span class="comment">    * 根据id删除对应的实体。</span><span class="comment">    */</span>   <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(ID id)</span>;   <span class="comment">/**</span><span class="comment">    * 删除给定的实体。</span><span class="comment">    */</span>   <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(T entity)</span>;   <span class="comment">/**</span><span class="comment">    * 删除给定的实体集合。</span><span class="comment">    */</span>   <span class="keyword">void</span> <span class="title function_">deleteAll</span><span class="params">(Iterable&lt;? extends T&gt; entities)</span>;   <span class="comment">/**</span><span class="comment">    * 删除所有的实体。</span><span class="comment">    */</span>   <span class="keyword">void</span> <span class="title function_">deleteAll</span><span class="params">()</span>;  <span class="comment">/**</span><span class="comment">    * 返回所有的实体，根据Sort参数提供的规则排序。</span><span class="comment">    */</span>   Iterable&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Sort sort)</span>;   <span class="comment">/**</span><span class="comment">    * 返回一页实体，根据Pageable参数提供的规则进行过滤。</span><span class="comment">    */</span>   Page&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Pageable pageable)</span>;<span class="comment">/**</span><span class="comment">    * 将所有未决的更改刷新到数据库。</span><span class="comment">    */</span>   <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>;   <span class="comment">/**</span><span class="comment">    * 保存一个实体并立即将更改刷新到数据库。</span><span class="comment">    */</span>   &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; S <span class="title function_">saveAndFlush</span><span class="params">(S entity)</span>;   <span class="comment">/**</span><span class="comment">    * 在一个批次中删除给定的实体集合，这意味着将产生一条单独的Query。</span><span class="comment">    */</span>   <span class="keyword">void</span> <span class="title function_">deleteInBatch</span><span class="params">(Iterable&lt;T&gt; entities)</span>;   <span class="comment">/**</span><span class="comment">    * 在一个批次中删除所有的实体。</span><span class="comment">    */</span>   <span class="keyword">void</span> <span class="title function_">deleteAllInBatch</span><span class="params">()</span>;   <span class="comment">/**</span><span class="comment">    * 根据给定的id标识符，返回对应实体的引用。</span><span class="comment">    */</span>   T <span class="title function_">getOne</span><span class="params">(ID id)</span>;</code></pre><h3 id="hystrixcommand"><a class="markdownIt-Anchor" href="#hystrixcommand"></a> @HystrixCommand</h3><pre><code class="highlight java"><span class="keyword">package</span> com.example.demo.service;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.stereotype.Service;<span class="keyword">import</span> org.springframework.web.client.RestTemplate;<span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;<span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;<span class="meta">@Service</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerService</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> RestTemplate restTemplate;    <span class="meta">@HystrixCommand(commandKey = &quot;testCommand&quot;, groupKey = &quot;testGroup&quot;, threadPoolKey = &quot;testThreadKey&quot;,</span><span class="meta">            fallbackMethod = &quot;hiConsumerFallBack&quot;, ignoreExceptions = &#123;NullPointerException.class&#125;,</span><span class="meta">            threadPoolProperties = &#123;</span><span class="meta">                    @HystrixProperty(name = &quot;coreSize&quot;, value = &quot;30&quot;),</span><span class="meta">                    @HystrixProperty(name = &quot;maxQueueSize&quot;, value = &quot;101&quot;),</span><span class="meta">                    @HystrixProperty(name = &quot;keepAliveTimeMinutes&quot;, value = &quot;2&quot;),</span><span class="meta">                    @HystrixProperty(name = &quot;queueSizeRejectionThreshold&quot;, value = &quot;15&quot;),</span><span class="meta">                    @HystrixProperty(name = &quot;metrics.rollingStats.numBuckets&quot;, value = &quot;12&quot;),</span><span class="meta">                    @HystrixProperty(name = &quot;metrics.rollingStats.timeInMilliseconds&quot;, value = &quot;1440&quot;)</span><span class="meta">            &#125;</span><span class="meta">            )</span>    <span class="keyword">public</span> String <span class="title function_">hiConsumer</span><span class="params">(String id)</span> &#123;                <span class="comment">//SERVICE_HI是服务端的spring.application.name，并且大写，hi为服务端提供的接口</span>        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">&quot;http://SERVICE_HI/hi&quot;</span>, String.class).getBody();    &#125;        <span class="keyword">public</span> String <span class="title function_">hiConsumerFallBack</span><span class="params">(String id, Throwable e)</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;This is a error&quot;</span>;    &#125;&#125;</code></pre><p>让我们来逐个介绍下@HystrixCommand注解的各个参数：</p><p>1：<strong>commandKey</strong>：配置全局唯一标识服务的名称，比如，库存系统有一个获取库存服务，那么就可以为这个服务起一个名字来唯一识别该服务，如果不配置，则默认是@HystrixCommand注解修饰的函数的函数名。</p><p>2：<strong>groupKey</strong>：一个比较重要的注解，配置全局唯一标识服务分组的名称，比如，库存系统就是一个服务分组。通过设置分组，Hystrix会根据组来组织和统计命令的告、仪表盘等信息。Hystrix命令默认的线程划分也是根据命令组来实现。默认情况下，Hystrix会让相同组名的命令使用同一个线程池，所以我们需要在创建Hystrix命令时为其指定命令组来实现默认的线程池划分。此外，Hystrix还提供了通过设置threadPoolKey来对线程池进行设置。建议最好设置该参数，使用threadPoolKey来控制线程池组。</p><p>3：<strong>threadPoolKey</strong>：对线程池进行设定，细粒度的配置，相当于对单个服务的线程池信息进行设置，也可多个服务设置同一个threadPoolKey构成线程组。</p><p>4：<strong>fallbackMethod</strong>：@HystrixCommand注解修饰的函数的回调函数，@HystrixCommand修饰的函数必须和这个回调函数定义在同一个类中，因为定义在了同一个类中，所以fackback method可以是public/private均可。</p><p>5：<strong>commandProperties</strong>：配置该命令的一些参数，如executionIsolationStrategy配置执行隔离策略，默认是使用线程隔离，此处我们配置为THREAD，即线程池隔离。参见：com.netflix.hystrix.HystrixCommandProperties中各个参数的定义。</p><p>6：<strong>threadPoolProperties</strong>：线程池相关参数设置，具体可以设置哪些参数请见：com.netflix.hystrix.HystrixThreadPoolProperties</p><p>7：<strong>ignoreExceptions</strong>：调用服务时，除了HystrixBadRequestException之外，其他@HystrixCommand修饰的函数抛出的异常均会被Hystrix认为命令执行失败而触发服务降级的处理逻辑（调用fallbackMethod指定的回调函数），所以当需要在命令执行中抛出不触发降级的异常时来使用它，通过这个参数指定，哪些异常抛出时不触发降级（不去调用fallbackMethod），而是将异常向上抛出。</p><p>8：<strong>observableExecutionMode</strong>：定义hystrix observable command的模式；</p><p>9：<strong>raiseHystrixExceptions</strong>：任何不可忽略的异常都包含在HystrixRuntimeException中；</p><p>10：<strong>defaultFallback</strong>：默认的回调函数，该函数的函数体不能有入参，返回值类型与@HystrixCommand修饰的函数体的返回值一致。如果指定了fallbackMethod，则fallbackMethod优先级更高</p><h3 id="cacheresult注解"><a class="markdownIt-Anchor" href="#cacheresult注解"></a> @CacheResult注解</h3><table><thead><tr><th>注解</th><th>描述</th><th>属性</th></tr></thead><tbody><tr><td>@CacheResult</td><td>该注解用来标记请求命令返回的结果应该被缓存，它必须与@HystrixCommand注解结合使用</td><td>cacheKeyMethod</td></tr><tr><td>@CacheRemove</td><td>该注解用来让请求命令的缓存失效，失效的缓存根据定义Key决定</td><td>commandKey,cacheKeyMethod</td></tr><tr><td>@CacheKey</td><td>该注解用来在请求命令的参数上标记，使其作为缓存的Key值，如果没有标注则会使用所有参数。如果同事还是使用了@CacheResult和@CacheRemove注解的cacheKeyMethod方法指定缓存Key的生成，那么该注解将不会起作用</td><td>value</td></tr></tbody></table><p>该注解标记结果需要被缓存，并且<strong>这个注解需要结合@HystrixCommand注解一起使用</strong>。该注解有一个参数cacheKeyMethod，用来指定获取cacheKey的方法名。Hystrix会根据获取到的cacheKey值来区分是否是重复请求，如果他们的cacheKey相同，那么该依赖服务只会在第一个请求到达时被真实的调用一次，另外一个请求则是直接从请求缓存中根据这个cacheKey来获取到的结果。所以开启请求缓存可以让我们实现的Hystrix命令具备下面几项好处：</p><ul><li>减少重复的请求数，降低依赖服务的并发度；</li><li>在同一个用户请求的上下文，想同依赖服务的返回数据始终保持一致。</li><li>请求缓存在run()和contruct()执行之前生效，所以可以有效减少不必要的线程开销；</li></ul><p>使用@CacheResult开启缓存代码示例：</p><pre><code class="highlight java"><span class="keyword">package</span> com.example.demo; <span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.stereotype.Service;<span class="keyword">import</span> org.springframework.web.client.RestTemplate; <span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.cache.annotation.CacheResult;<span class="keyword">import</span> com.example.demo.entity.User;<span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand; <span class="meta">@Service</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheResultDemo</span> &#123;     <span class="meta">@Autowired</span>    <span class="keyword">private</span> RestTemplate restTemplate;     <span class="meta">@CacheResult(cacheKeyMethod = &quot;getUserId&quot;)</span>    <span class="meta">@HystrixCommand(fallbackMethod = &quot;hiConsumerFallBack&quot;)</span>    <span class="keyword">public</span> User <span class="title function_">hiConsumer</span><span class="params">(String id)</span> &#123;                <span class="comment">//SERVICE_HI是服务端的spring.application.name，并且大写，hi为服务端提供的接口</span>        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">&quot;http://SERVICE_HI/hi&quot;</span>, User.class).getBody();    &#125;        <span class="keyword">public</span> String <span class="title function_">hiConsumerFallBack</span><span class="params">(String id, Throwable e)</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;This is a error&quot;</span>;    &#125;        <span class="keyword">public</span> String <span class="title function_">getUserId</span><span class="params">(String id)</span> &#123;        <span class="keyword">return</span> id;    &#125; &#125;</code></pre><p>使用CacheKey开启缓存代码示例：</p><pre><code class="highlight java"><span class="keyword">package</span> com.example.demo;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.stereotype.Service;<span class="keyword">import</span> org.springframework.web.client.RestTemplate;importcom.netflix.hystrix.contrib.javanica.cache.annotation.CacheKey;<span class="keyword">import</span> com.example.demo.entity.User;importcom.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;<span class="meta">@Service</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheKeyDemo</span> &#123;      <span class="meta">@Autowired</span>      <span class="keyword">private</span> RestTemplate restTemplate;      <span class="meta">@HystrixCommand(fallbackMethod = &quot;hiConsumerFallBack&quot;)</span>      <span class="keyword">public</span> User <span class="title function_">hiConsumer</span><span class="params">(<span class="meta">@CacheKey(&quot;id&quot;)</span> String id)</span> &#123;                        <span class="comment">//SERVICE_HI是服务端的spring.application.name，并且大写，hi为服务端提供的接口</span>            <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">&quot;http://SERVICE_HI/hi&quot;</span>, User.class).getBody();      &#125;            <span class="keyword">public</span> String <span class="title function_">hiConsumerFallBack</span><span class="params">(String id, Throwable e)</span> &#123;            <span class="keyword">return</span> <span class="string">&quot;This is a error&quot;</span>;      &#125;&#125;</code></pre><p>其中@CacheKey除了可以指定方法参数为缓存key之外，还可以指定对象中的属性作为缓存Key，如下：</p><pre><code class="highlight java"><span class="keyword">package</span> com.example.demo; <span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.stereotype.Service;<span class="keyword">import</span> org.springframework.web.client.RestTemplate; <span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.cache.annotation.CacheKey;<span class="keyword">import</span> com.example.demo.entity.User;<span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand; <span class="meta">@Service</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheKeyDemo2</span> &#123;     <span class="meta">@Autowired</span>    <span class="keyword">private</span> RestTemplate restTemplate;     <span class="meta">@HystrixCommand(fallbackMethod = &quot;hiConsumerFallBack&quot;)</span>    <span class="keyword">public</span> User <span class="title function_">hiConsumer</span><span class="params">(<span class="meta">@CacheKey(&quot;id&quot;)</span> User user)</span> &#123;                <span class="comment">//SERVICE_HI是服务端的spring.application.name，并且大写，hi为服务端提供的接口</span>        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">&quot;http://SERVICE_HI/hi&quot;</span>, User.class, user.getId()).getBody();    &#125;        <span class="keyword">public</span> String <span class="title function_">hiConsumerFallBack</span><span class="params">(String id, Throwable e)</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;This is a error&quot;</span>;    &#125; &#125;</code></pre><p>清理失效缓存功能：</p><p>使用请求缓存时，如果只是读操作，那么不需要考虑缓存中的内容是否正确的问题，但是如果请求命令中还有更新数据的写操作，那么缓存中的数据就需要我们在进行写操作时进行及时处理，以防止读操作的请求命令获取到了失效的数据。</p><p>通过@CacheRemove注解来实现失效缓存清理功能：</p><pre><code class="highlight java"><span class="keyword">package</span> com.example.demo;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.stereotype.Service;<span class="keyword">import</span> org.springframework.web.client.RestTemplate;importcom.netflix.hystrix.contrib.javanica.cache.annotation.CacheKey;importcom.netflix.hystrix.contrib.javanica.cache.annotation.CacheRemove;<span class="keyword">import</span> com.example.demo.entity.User;importcom.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;<span class="meta">@Service</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheRemoveDemo</span> &#123;      <span class="meta">@Autowired</span>      <span class="keyword">private</span> RestTemplate restTemplate;      <span class="meta">@CacheRemove(commandKey = &quot;getUserId&quot;)</span>      <span class="meta">@HystrixCommand(fallbackMethod = &quot;hiConsumerFallBack&quot;)</span>      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="meta">@CacheKey(&quot;id&quot;)</span> User user)</span> &#123;                        <span class="comment">//SERVICE_HI是服务端的spring.application.name，并且大写，hi为服务端提供的接口</span>            restTemplate.postForObject(<span class="string">&quot;http://SERVICE_HI/hi&quot;</span>, user, User.class);            <span class="keyword">return</span>;      &#125;            <span class="keyword">public</span> String <span class="title function_">hiConsumerFallBack</span><span class="params">(String id, Throwable e)</span> &#123;            <span class="keyword">return</span> <span class="string">&quot;This is a error&quot;</span>;      &#125;            <span class="keyword">public</span> String <span class="title function_">getUserId</span><span class="params">(String id)</span> &#123;            <span class="keyword">return</span> id;      &#125;&#125;</code></pre><h2 id="微服务中心eureka"><a class="markdownIt-Anchor" href="#微服务中心eureka"></a> 微服务中心Eureka</h2><p><a href="https://github.com/Netflix/eureka">官方网址：https://github.com/Netflix/eureka</a></p><h3 id="eureka引入"><a class="markdownIt-Anchor" href="#eureka引入"></a> Eureka引入</h3><p>前面的例子存在一个问题:消费者直接连接的提供者。这样做的问题是，若提供者出现宕机，或消费者存在高并发情况，那么消费者就会出现问题。所以，我们就需要一个服务注册中心，就像之前的zokeeper一样。提供者对于消费者来说是透明的，不固定的。。</p><p>所有提供者将自己提供服务的名称及自己主机详情(IP、端口、版本等)写入到另一台主机中，这台主机称为服务注册中心。所有消费者需要哪种服务只需向注册中心提交服务名称，注册中心就会根据该服务的所有提供者当前的运行情况(繁忙度、健康状态等)，将一个合适的提供者信息发送给消费者，由消费者访问提供者提供的服务。</p><p>可以充当Spring Cloud服务注册中心的服务器很多，如Zookeeper、Eureka、Consul<br />Template and Nginx.但目前在实际生产环境中使用最多，Spring Cloud支持最好的就是Eurekae</p><h4 id="eureka概述"><a class="markdownIt-Anchor" href="#eureka概述"></a> Eureka概述</h4><p>Eureka，古希腊词语，意思是“我找到了!我发现了!”</p><p>Eureka是Netfix(美国一家视频网络平台公司)开发的服务发现框架，本身是一个基于REST的服务，主要用于定位运行在AwS (Amazon Web Serices, |亚马逊网络服务，一种类似于阿里云的云计算服务)域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。Springcloud将它集成在其子项目spring doud-.etfix中，实现SpringCloud 的<strong>服务发现功能</strong>。</p><p>Eureka包含两个组件:<strong>Eureka Server</strong>和<strong>Eureka Client</strong></p><p><strong>Eureka Server</strong>提供<strong>服务注册功能</strong>，提供者节点启动后，会在Eureka Server中进行注册,这样Eureka Server的服务注册表中将会存储所有可用服务节点的信息。然后各提供者将会向Eureka Server发送<strong>心跳</strong>，以告知Eureka Server自己的健康状况，默认<strong>周期为30秒</strong>。如果在多个心跳周期内(默认3个周期90秒没有接收到某个提供者节点的心跳，Eureka Server会认为其已无法提供服务，会将该提供者节点从服务注册表中移除。Eureka Server之间通过复制的方式完成数据的同步。工</p><p><strong>Eureka Client</strong>是一个java客户端，用于<strong>简化消费者与Eureka Server的交证</strong>。同时，EurekaClient还内置有<strong>负载7种均衡器</strong>，为消费者从Fureka Server的服务注册表中选择合适的提供者.</p><p>Eureka提供了<strong>客户端缓存机制</strong>（因为他把注册表信息都下载到了自己本地），即使所有的Eureka Server都挂掉，客户端依然可以利用缓存中的信息为消费者提供服务发现功能。不过，此时不再接受服务注册，因为EurekaServer已经全部挂掉了。这就是<strong>AP原则（可用性）</strong>（zookeeper遵循的CP原则（一致性））的体现。</p><p>综上，Eureka通过心跳检查、客户端缓存等机制，确保了系统的高可用性、灵活性和可伸缩性。</p><h4 id="eureka体系结构"><a class="markdownIt-Anchor" href="#eureka体系结构"></a> Eureka体系结构</h4><h3 id="创建eureka服务中心"><a class="markdownIt-Anchor" href="#创建eureka服务中心"></a> 创建Eureka服务中心</h3><p>只需三步即可创建一个Eureka服务中心</p><ul><li>导入EurekaServer依赖</li><li>在主配置文件中配置EurekaServer</li><li>在启动类中添加注解@<strong>EnableEurekaServer</strong> 开启EurekaServer</li></ul><h4 id="创建工程"><a class="markdownIt-Anchor" href="#创建工程"></a> 创建工程</h4><p>创建一个spring boot工程：</p><p>工程名：</p><p>导入Eureka依赖：</p><h4 id="pom依赖主配置文件"><a class="markdownIt-Anchor" href="#pom依赖主配置文件"></a> pom依赖/主配置文件</h4><p>pom依赖：</p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>eurekaserver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>eurekaserver<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR3<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p><strong>如果使用的是jdk 8以上的高版本，还需导入下列依赖</strong></p><blockquote><p>注意，这里要导入的依赖并非是Spring Cloud工程要直接依赖的，而是由于Eureka Server所依赖的。但在JDK9之前，这些依赖是包含在JDK中的，从JDK9开始，JAXB API被划归到了Java EE API,从JDK中踢除了出去。由于本例运行的主机使用的是JDK为10,所以需要导入这些JAXB API依赖。若你使用的是JDK6、7、8，那么这些依赖无需导入。</p></blockquote><blockquote><p>JAXB (Java Architecture for XML Binding, XML绑定的Java技术)是一个业界的标准，是一项可以根据XML Schema产生Java类的技术。该过程中，JAXB也提供了将XML实例文档反向生成Java对象树的方法，并能将Java对象树的内容重新写到XML实例文档。从另一方面来讲，JAXB提供了快速而简便的方法将XML模式绑定到Java表示，从而使得Java开发者在Java应用程序中能方便地结合XML数据和处理函数。</p></blockquote><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.activation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><hr /><p><strong>主配置文件：</strong></p><pre><code class="highlight properties"><span class="attr">server.port</span>=<span class="string">8000</span><span class="comment"></span><span class="comment">#指定Eureka主机</span><span class="attr">eureka.instance.hostname</span>=<span class="string">localhost</span><span class="comment"></span><span class="comment"># 指定当前主机是否需要向注册中心注册（不用，因为当前主机是Server，不是client）</span><span class="attr">eureka.client.register-with-eureka</span>=<span class="string">false</span><span class="comment"></span><span class="comment">#指定当前主机是否需要获取注册信息（不用，因为当前主机是Server,不是client）</span><span class="attr">eureka.client.fetch-registry</span>=<span class="string">false</span><span class="comment"></span><span class="comment">#暴露服务中心地址</span><span class="comment">#使用占位符方式</span><span class="attr">eureka.client.service-url.defaultZone</span>=<span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka</span><span class="comment">#普通方式</span><span class="comment">#eureka.client.service-url.defaultZone=http://localhost:8000/eureka</span></code></pre><h4 id="定义spring-boot启动类"><a class="markdownIt-Anchor" href="#定义spring-boot启动类"></a> 定义spring boot启动类</h4><p>添加@EnableEurekaServer注解，开启EurekaServer</p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.eurekaserver;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;<span class="meta">@SpringBootApplication</span><span class="meta">@EnableEurekaServer</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaserverApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(EurekaserverApplication.class, args);    &#125;&#125;</code></pre><h4 id="启动测试"><a class="markdownIt-Anchor" href="#启动测试"></a> 启动测试</h4><p>访问：</p><pre><code class="highlight plaintext">http://localhost:8000/</code></pre><h3 id="修改提供者工程"><a class="markdownIt-Anchor" href="#修改提供者工程"></a> 修改提供者工程</h3><p>只需完成三步即可创建一个Eureka服务提供者</p><ul><li>添加Eureka客户端依赖</li><li>在配置文件中指定要注册的Eureka注册中心</li><li>在启动类上添加@<strong>EnableEurekaClient</strong>注解</li></ul><h4 id="pom依赖主配置文件-2"><a class="markdownIt-Anchor" href="#pom依赖主配置文件-2"></a> pom依赖/主配置文件</h4><p>pom依赖：</p><ul><li>添加Eureka客户端依赖和spring cloud dependencyManagement</li></ul><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>provider<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="comment">&lt;!--Eureka客户端依赖--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!--修改MySQL驱动版本--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!--data数据源阿里巴巴连接池--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p><strong>主配置文件：</strong></p><ul><li><strong>instance-id</strong>：为客户端微服务在Eureka状态显示栏中显示的名称，若不指定，则默认显示的是该服务提供者 <code>主机名：应用名称：端口号</code></li><li><strong><a href="http://spring.application.name">spring.application.name</a></strong>：指定微服务的名称。若不指定，在Eureka中应用名称位置默认显示Unknown，此名称即为提供者对外暴露的微服务名称，<strong>将来服务消费者就是依据此名称来消费服务的</strong></li></ul><pre><code class="highlight properties"><span class="comment">#指定端口号</span><span class="attr">server.port</span>=<span class="string">8081</span><span class="comment">#更改访问上下文路径/访问路径 localhost:8088/leeBoot/...</span><span class="comment">#server.servlet.context-path=/springcloudprovider</span><span class="comment"></span><span class="comment">#开启启动时自动建表</span><span class="attr">spring.jpa.generate-ddl</span>=<span class="string">true</span><span class="comment">#是否在控制台显示sql语句</span><span class="attr">spring.jpa.show-sql</span>=<span class="string">true</span><span class="comment">#设置应用启动时不重新建表</span><span class="attr">spring.jpa.hibernate.ddl-auto</span>=<span class="string">none</span><span class="comment"></span><span class="comment">#配置数据源</span><span class="attr">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/leetest?characterEncoding=UTF-8</span><span class="attr">spring.datasource.username</span>=<span class="string">root</span><span class="attr">spring.datasource.password</span>=<span class="string">123456</span><span class="comment"></span><span class="comment">#配置日志输出格式</span><span class="attr">logging.pattern.console</span>=<span class="string">%level %msg%n</span><span class="comment">#设置spring boot启动时的日志级别</span><span class="attr">logging.level.root</span>=<span class="string">info</span><span class="comment">#hibernate运行日志级别   org.gibernate表示类名</span><span class="attr">logging.level.org.hibernate</span>=<span class="string">info</span><span class="comment">#在show-sql为true时显示sql中的动态参数值</span><span class="attr">logging.level.org.hibernate.type.descriptor.sql.BasicBinder</span>=<span class="string">trace</span><span class="comment">#在show-sql为true时显示查询结果</span><span class="attr">logging.level.org.hibernate.type.descriptor.sql.BasicExtractor</span>=<span class="string">trace</span><span class="comment">#控制自己代码运行时显示的日志级别</span><span class="attr">logging.level.com.lee</span>=<span class="string">debug</span><span class="comment"></span><span class="comment">#指定Eureka服务中心（就是eurekaserver项目中的eureka.client.service-url.defaultZone）</span><span class="attr">eureka.client.service-url.defaultZone</span>:<span class="string">http://localhost:8000/eureka</span><span class="comment">#指定当前客户端在注册中心的名称</span><span class="attr">eureka.instance.instance-id</span>=<span class="string">lee-msc-provider-depart-8081</span><span class="comment"></span><span class="comment">#指定微服务的名称(应用名称)</span><span class="attr">spring.application.name</span>=<span class="string">leemsc-provider-depart</span></code></pre><h4 id="修改启动类"><a class="markdownIt-Anchor" href="#修改启动类"></a> 修改启动类</h4><p>添加@EnableEurekaClient注解：</p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.provider;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;<span class="meta">@SpringBootApplication</span><span class="meta">@EnableEurekaClient</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(ProviderApplication.class, args);    &#125;&#125;</code></pre><h4 id="启动测试-2"><a class="markdownIt-Anchor" href="#启动测试-2"></a> 启动测试</h4><h3 id="actuator完善微服务info"><a class="markdownIt-Anchor" href="#actuator完善微服务info"></a> actuator完善微服务info</h3><p>在微服务状态的超链接上点击，可以看到404错误页面，通过地址栏可以看到：<u><a href="http://localhost:8081/actuator/info">http://localhost:8081/actuator/info</a></u>，因为是由于在配置文件中没有设置actuator的info监控终端所致</p><h4 id="提供者添加依赖"><a class="markdownIt-Anchor" href="#提供者添加依赖"></a> 提供者添加依赖</h4><p>添加actuator依赖</p><pre><code class="highlight xml"><span class="comment">&lt;!--添加actuator依赖--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h4 id="提供者配置文件"><a class="markdownIt-Anchor" href="#提供者配置文件"></a> 提供者配置文件</h4><p>在eureka客户端工程中，为服务提供者工程在配置文件的最后添加如下内容：</p><ul><li>info：是不能变化的，表示这里定义的是info页面内容</li><li>二级内容分为key与value，key与value可以任意指定，其显示到页面是以JSON数据的形式出现</li><li>二级内容key若只有一级，则其为JSON的key，value为JSON的value</li><li>二级内容key若为两级，则第一集为JSON的key，而该JSON的值为JSON数组</li></ul><pre><code class="highlight properties"><span class="comment">#指定端口号</span><span class="attr">server.port</span>=<span class="string">8081</span><span class="comment">#更改访问上下文路径/访问路径 localhost:8088/leeBoot/...</span><span class="comment">#server.servlet.context-path=/springcloudprovider</span><span class="comment"></span><span class="comment">#开启启动时自动建表</span><span class="attr">spring.jpa.generate-ddl</span>=<span class="string">true</span><span class="comment">#是否在控制台显示sql语句</span><span class="attr">spring.jpa.show-sql</span>=<span class="string">true</span><span class="comment">#设置应用启动时不重新建表</span><span class="attr">spring.jpa.hibernate.ddl-auto</span>=<span class="string">none</span><span class="comment"></span><span class="comment">#配置数据源</span><span class="attr">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/leetest?characterEncoding=UTF-8</span><span class="attr">spring.datasource.username</span>=<span class="string">root</span><span class="attr">spring.datasource.password</span>=<span class="string">123456</span><span class="comment"></span><span class="comment">#配置日志输出格式</span><span class="attr">logging.pattern.console</span>=<span class="string">%level %msg%n</span><span class="comment">#设置spring boot启动时的日志级别</span><span class="attr">logging.level.root</span>=<span class="string">info</span><span class="comment">#hibernate运行日志级别   org.gibernate表示类名</span><span class="attr">logging.level.org.hibernate</span>=<span class="string">info</span><span class="comment">#在show-sql为true时显示sql中的动态参数值</span><span class="attr">logging.level.org.hibernate.type.descriptor.sql.BasicBinder</span>=<span class="string">trace</span><span class="comment">#在show-sql为true时显示查询结果</span><span class="attr">logging.level.org.hibernate.type.descriptor.sql.BasicExtractor</span>=<span class="string">trace</span><span class="comment">#控制自己代码运行时显示的日志级别</span><span class="attr">logging.level.com.lee</span>=<span class="string">debug</span><span class="comment"></span><span class="comment">#指定Eureka服务中心（就是eurekaserver项目中的eureka.client.service-url.defaultZone）</span><span class="attr">eureka.client.service-url.defaultZone</span>:<span class="string">http://localhost:8000/eureka</span><span class="comment">#指定当前客户端在注册中心的名称</span><span class="comment">#eureka.instance.instance-id=lee-msc-provider-depart-8081</span><span class="comment"></span><span class="comment">#指定微服务的名称(应用名称)</span><span class="attr">spring.application.name</span>=<span class="string">leemsc-provider-depart</span><span class="comment"></span><span class="comment">#info后面的内容可以随便写</span><span class="attr">info.company.name</span>=<span class="string">leeboer.xyz</span><span class="attr">info.company.address</span>=<span class="string">xian</span><span class="attr">info.company.tel</span>=<span class="string">123456798</span><span class="attr">info.app.name</span>=<span class="string">leemsc-provider-depart</span><span class="attr">info.app.people</span>=<span class="string">leeboer</span></code></pre><h4 id="运行测试"><a class="markdownIt-Anchor" href="#运行测试"></a> 运行测试</h4><h3 id="self-preservation机制"><a class="markdownIt-Anchor" href="#self-preservation机制"></a> Self Preservation机制</h3><p>Self Preservation机制即自我保护机制，在Eureka服务页面中看到如下红色字体内容，表示当前EurekaServer启动了自我保护机制，进入了自我保护模式</p><p>[翻译]紧急情况!当微服务主机联系不上时，Eureka 不能够正确判断它们是否处于up状态。当更新(指收到的微服务主机的心跳)小于阈值时，为了安全，微服务主机将不再失效。</p><p>默认情况下，EurekaServer在90秒内没有检测到服务列表中的某微服务，则会自动将该微服务从服务列表中删除。但很多情况下并不是该微服务节点（主机)出了问题，而是由于网络故障或网速等原因使该微服务无法被EurekaServer发现，即无法检测到该微服务主机的心跳。若在短暂时间内网络恢复正常，但由于EurekaServer 的服务列表中已经没有该微服务，所以该微服务已经无法提供服务了。</p><p>在短时间内若EurekaServer丢失较多微服务( EurekaServer收到的心跳数量小于阙值)，那么其会自动进入自我保护模式:服务列表只可读取、写入，不可执行删除操作。当EurekaServer收到的心跳数量恢复到阈值以上时，其会自动退出Self Preservation模式(翻译自官网)</p><p><strong>Self Preservation机制默认是开启的，可以通过修改EurekaServer中配置文件来关闭</strong>。但建议不关闭</p><pre><code class="highlight properties"><span class="attr">server.port</span>=<span class="string">8000</span><span class="comment"></span><span class="comment">#指定Eureka主机</span><span class="attr">eureka.instance.hostname</span>=<span class="string">localhost</span><span class="comment"></span><span class="comment">#关闭自我保护机制</span><span class="attr">eureka.server.enable-self-preservation</span>=<span class="string">false</span><span class="comment"></span><span class="comment"># 指定当前主机是否需要向注册中心注册（不用，因为当前主机是Server，不是client）</span><span class="attr">eureka.client.register-with-eureka</span>=<span class="string">false</span><span class="comment"></span><span class="comment">#指定当前主机是否需要获取注册信息（不用，因为当前主机是Server,不是client）</span><span class="attr">eureka.client.fetch-registry</span>=<span class="string">false</span><span class="comment"></span><span class="comment">#暴露服务中心地址</span><span class="comment">#使用占位符方式</span><span class="attr">eureka.client.service-url.defaultZone</span>=<span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka</span><span class="comment">#普通方式</span><span class="comment">#eureka.client.service-url.defaultZone=http://localhost:8000/eureka</span></code></pre><h3 id="修改消费者工程"><a class="markdownIt-Anchor" href="#修改消费者工程"></a> 修改消费者工程</h3><p>消费者将使用提供者暴露的服务名称（<a href="http://spring.application.name">spring.application.name</a>）来消费服务</p><p>完成以下四个步骤即可创建一个Eureka服务消费者</p><ul><li>添加Eureka客户端依赖</li><li>在配置文件中指定要注册的Eureka注册中心</li><li>在CodeConfig类中为RestTemplate添加@LoadBalanced注解</li><li>在启动类上添加@EnableEurekaClient</li></ul><h4 id="添加依赖修改主配置文件"><a class="markdownIt-Anchor" href="#添加依赖修改主配置文件"></a> 添加依赖/修改主配置文件</h4><p>pom依赖：</p><ul><li>添加Eureka客户端依赖和spring cloud dependencyManagement</li></ul><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="comment">&lt;!--Eureka客户端依赖--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!--添加actuator依赖--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p>主配置文件：</p><pre><code class="highlight properties"><span class="comment">#指定端口号</span><span class="attr">server.port</span>=<span class="string">8080</span><span class="comment"></span><span class="comment">#指定微服务对外暴露的名称</span><span class="attr">spring.application.name</span>=<span class="string">leemsc-consumer-depart</span><span class="comment"></span><span class="comment">#指定Eureka服务注册中心</span><span class="attr">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:8000/eureka</span></code></pre><h4 id="修改configuration类启动类"><a class="markdownIt-Anchor" href="#修改configuration类启动类"></a> 修改Configuration类/启动类</h4><p>修改Configuration类:</p><ul><li>@LoadBalanced：开启消费端的负载均衡功能，默认是轮询策略</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer.codeconfig;<span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;<span class="keyword">import</span> org.springframework.context.annotation.Bean;<span class="keyword">import</span> org.springframework.context.annotation.Configuration;<span class="keyword">import</span> org.springframework.web.client.RestTemplate;<span class="meta">@Configuration</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartCodeConfig</span> &#123;    <span class="comment">//开启消费端的负载均衡功能，默认是轮询策略</span>    <span class="meta">@LoadBalanced</span>    <span class="meta">@Bean</span>    <span class="comment">//bean的名称就相当于方法名</span>    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();    &#125;&#125;</code></pre><p>修改启动类：</p><ul><li>添加@EnableEurekaClient注解</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;<span class="meta">@SpringBootApplication</span><span class="meta">@EnableEurekaClient</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(ConsumerApplication.class, args);    &#125;&#125;</code></pre><h4 id="运行测试-2"><a class="markdownIt-Anchor" href="#运行测试-2"></a> 运行测试</h4><h3 id="服务发现discovery"><a class="markdownIt-Anchor" href="#服务发现discovery"></a> 服务发现discovery</h3><p>服务发现，即通过“服务发现客户端”，<strong>读取EurekaServer中的服务列表</strong>，获取指定名称的微服务详情</p><h4 id="修改处理器"><a class="markdownIt-Anchor" href="#修改处理器"></a> 修改处理器</h4><p>在<strong>任何</strong>微服务的<strong>提供者或者消费者</strong>处理器中，只要获取到“服务发现Client”，即可读取到EurekaServer的微服务列表</p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.provider.Controller;<span class="keyword">import</span> com.lee.provider.bean.Depart;<span class="keyword">import</span> com.lee.provider.service.DepartService;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.cloud.client.ServiceInstance;<span class="keyword">import</span> org.springframework.cloud.client.discovery.DiscoveryClient;<span class="keyword">import</span> org.springframework.web.bind.annotation.*;<span class="keyword">import</span> java.util.List;<span class="meta">@RequestMapping(&quot;/provider/depart&quot;)</span><span class="meta">@RestController</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartController</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> DepartService service;    <span class="comment">//获取服务发现客户端</span>    <span class="meta">@Autowired</span>    <span class="keyword">private</span> DiscoveryClient client;    <span class="meta">@PostMapping(&quot;/save&quot;)</span>    <span class="comment">//@RequestBody表示传过来的数据时json数据</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveHandle</span><span class="params">(<span class="meta">@RequestBody</span> Depart depart)</span> &#123;        <span class="keyword">return</span> service.saveDepart(depart);    &#125;    <span class="meta">@DeleteMapping(&quot;/del/&#123;id&#125;&quot;)</span>    <span class="comment">//@PathVariable 表示获取url中的&#123;id&#125;的值</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteHandle</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;        <span class="keyword">return</span> service.removeDepartById(id);    &#125;    <span class="meta">@PutMapping(&quot;/update&quot;)</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateHandle</span><span class="params">(<span class="meta">@RequestBody</span> Depart depart)</span>&#123;        <span class="keyword">return</span> service.modifyDepart(depart);    &#125;    <span class="meta">@GetMapping(&quot;/get/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> Depart <span class="title function_">GetHandle</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span>&#123;        <span class="keyword">return</span> service.getDepartById(id);    &#125;    <span class="meta">@GetMapping(&quot;/list&quot;)</span>    <span class="keyword">public</span> List&lt;Depart&gt; <span class="title function_">listHandle</span><span class="params">()</span> &#123;        <span class="keyword">return</span> service.listAllDeparts();    &#125;    <span class="meta">@GetMapping(&quot;/discovery&quot;)</span>    <span class="keyword">public</span> Object <span class="title function_">discoverHandler</span><span class="params">()</span>&#123;        <span class="comment">//获取服务注册列表中所有微服务名称</span>        List&lt;String&gt; springApplicationNames = client.getServices();        <span class="keyword">for</span> (String name : springApplicationNames) &#123;            <span class="comment">//获取提供指定微服务名称服务的所有提供者主机（因为服务提供者的主机不仅仅是一台）</span>            List&lt;ServiceInstance&gt; instances = client.getInstances(name);            <span class="keyword">for</span> (ServiceInstance instance : instances) &#123;                System.out.println(instance.getHost()+<span class="string">&quot; : &quot;</span>+instance.getPort());            &#125;        &#125;        <span class="keyword">return</span> springApplicationNames;    &#125;&#125;</code></pre><h4 id="启动类添加注解"><a class="markdownIt-Anchor" href="#启动类添加注解"></a> 启动类添加注解</h4><p>添加@EnableDiscoveryClient，开启服务发现客户端</p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.provider;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;<span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;<span class="meta">@SpringBootApplication</span><span class="meta">@EnableEurekaClient</span><span class="meta">@EnableDiscoveryClient</span>  <span class="comment">//开启服务发现客户端</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(ProviderApplication.class, args);    &#125;&#125;</code></pre><h4 id="运行测试-3"><a class="markdownIt-Anchor" href="#运行测试-3"></a> 运行测试</h4><p>浏览器输出：</p><p>控制台输出:</p><h3 id="eurekaserver集群"><a class="markdownIt-Anchor" href="#eurekaserver集群"></a> EurekaServer集群</h3><p>单个EurekaServer不仅吞吐量有限，还存在单点问题，所以我们会使用EurekaServer集群，这里要搭建的EurekaServer集群中包含三个EurekaServer节点，其端口号分别为8100，8200，8300</p><h4 id="修改eurekaserver"><a class="markdownIt-Anchor" href="#修改eurekaserver"></a> 修改EurekaServer</h4><p>要想搭建EurekaServer，需在三台服务器启动EurekaServer，EurekaServer的改动如下：</p><ul><li>只需在<code>eureka.client.service-url.defaultZone</code>中指定所有的服务中心的地址即可，每个服务中心之间用逗号隔开</li></ul><pre><code class="highlight properties"><span class="attr">server.port</span>=<span class="string">8000</span><span class="comment"></span><span class="comment">#指定Eureka主机</span><span class="attr">eureka.instance.hostname</span>=<span class="string">192.168.1.1</span><span class="comment"></span><span class="comment">#关闭自我保护机制</span><span class="comment">#eureka.server.enable-self-preservation=false</span><span class="comment"></span><span class="comment"># 指定当前主机是否需要向注册中心注册（不用，因为当前主机是Server，不是client）</span><span class="attr">eureka.client.register-with-eureka</span>=<span class="string">false</span><span class="comment"></span><span class="comment">#指定当前主机是否需要获取注册信息（不用，因为当前主机是Server,不是client）</span><span class="attr">eureka.client.fetch-registry</span>=<span class="string">false</span><span class="comment"></span><span class="comment">#暴露服务中心地址</span><span class="attr">eureka.client.service-url.defaultZone</span>=<span class="string">http://192.168.1.1:8000/eureka,http://192.168.1.2:8000/eureka,http://192.168.1.3:8000/eureka</span></code></pre><h4 id="服务提供者服务消费者"><a class="markdownIt-Anchor" href="#服务提供者服务消费者"></a> 服务提供者/服务消费者</h4><p>服务提供者/服务消费者要想访问集群，也只需修改<code>eureka.client.service-url.defaultZone</code>即可</p><pre><code class="highlight properties"><span class="comment">#指定Eureka服务注册中心</span><span class="attr">eureka.client.service-url.defaultZone</span>=<span class="string">http://192.168.1.1:8000/eureka,http://192.168.1.2:8000/eureka,http://192.168.1.3:8000/eureka</span></code></pre><h3 id="eureka与zookeeper对比"><a class="markdownIt-Anchor" href="#eureka与zookeeper对比"></a> Eureka与Zookeeper对比</h3><h4 id="eureka与ap原则"><a class="markdownIt-Anchor" href="#eureka与ap原则"></a> eureka与AP原则</h4><p>Eureka在CAP原则中遵循的是AP原则，即保证了可用性，牺牲了一致性。</p><p>Eureka Server集群中各个节点都是平等的，不像zk集群中还存在Leader与Follower.每个Eureka Server节点都具有向客户端响应读写操作的功能。只要不是出现集群中所有节点都宕机的情况，Eureka的服务注册与发现功能就不会停止。即使所有Eureka Server都宕机了，Eureka Client通过其缓存机制仍可对外提供服务发现功能，虽然此时已经不能再进行服务注册了。这保证了可用性。</p><p>当某一个Eureka集群节点中数据更新了，其会向其它节点发出广播，让其同步数据。但同步数据之前及之间，尚未更新数据的节点并不会停止服务，其依然可以进行服务的注册与发现。只不过其服务列表中的数据不能保证是最新的。从这点可知，Eureka通过牺牲一致性，保证了可用性。</p><p>Eureka为了保证可用性，启用了Self Preservation自我保护机制。自我保护机制一旦启动，Eureka将不再从服务列表中删除长时间没有收到心跳的服务:此时的Eureka虽然仍可以接受新的服务注册与发现，但不会被同步到其它节点。当网络稳定时，当前Eureka实例新的数据信息就会被同步到其它节点中。</p><h4 id="zookeer与cp原则"><a class="markdownIt-Anchor" href="#zookeer与cp原则"></a> Zookeer与CP原则</h4><p>zk遵循的是CP原则，即保证了一致性，但牺牲了可用性。体现在哪里呢?</p><p>当Leader宕机后，zk集群会马上进行新的Leader的选举。但选举选举时长在30-120秒间，整个选举期间zk集群是不接受客户端的读写操作的，即zk集群是处于瘫痪状态的。所以，其不满足可用性。</p><p>为什么Leader的选举需要这么长的时间呢?为了保证zk集群各个节点中数据的一致性，zk集群做了两类数据同步:初始化同步与更新同步。当新的Leader被选举出后，各个Follower需要将新Leader的数据同步到自己的缓存中，这是初始化同步，当Leader的数据被客户端修改后，其会向Follower发出广播，然后各个Follower会主动同步Leader的更新数据，这是更新同步。无论是初始化同步还是更新同步，zk集群为了保证数据的一致性，若发现超过半数的Follower同步超时，则其会再次进行同步，而这个过程中zk集群是处于不对外提供服务状态。</p><h2 id="声明式rest客户端openfeign"><a class="markdownIt-Anchor" href="#声明式rest客户端openfeign"></a> 声明式REST客户端OpenFeign</h2><h3 id="openfeign概述"><a class="markdownIt-Anchor" href="#openfeign概述"></a> OpenFeign概述</h3><p>本项目通过自动配置和绑定到Spring环境和其他Spring编程模型习惯用法，为Spring引导应用程序提供OpenFeign集成</p><p><strong>功能</strong></p><p>声明式REST客户端：Feign创建一个使用JAX-RS或Spring MVC注解修饰的接口的动态实现</p><h4 id="openfeign与feign"><a class="markdownIt-Anchor" href="#openfeign与feign"></a> OpenFeign与Feign</h4><p>Spring Boot 1.x及Spring Cloud之前的版本环境下使用的是Feign，而该项目现已更新了OpenFeign，所以后续使用的依赖也发生了变化</p><pre><code class="highlight xml"><span class="comment">&lt;!--openfeign依赖--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!--feign依赖--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h4 id="ribbon简介"><a class="markdownIt-Anchor" href="#ribbon简介"></a> Ribbon简介</h4><p>Ribbon是Netflix公司开源的一个负载均衡的项目，是一个客户端负载均衡器，运行在消费者端，当然，一定是Eureka客户端</p><p><strong>Ribbon与OpenFeign</strong></p><p>OpenFeign中使用Ribbon进行负载均衡，所以OpenFeign直接内置了Ribbon，即在导入OpenFeign依赖后，无需再专门导入Ribbon依赖了</p><h3 id="修改消费者工程-2"><a class="markdownIt-Anchor" href="#修改消费者工程-2"></a> 修改消费者工程</h3><p>这里无需修改提供者工程，只需修改消费者工程即可</p><p>需完成四部即可使用feign接口消费微服务：</p><ul><li>添加openfeign依赖</li><li>定义Service接口，并用@FeignClient指定其所绑定的微服务名（即服务提供者的applicationName）</li><li>修改处理器，通过Service接口消费微服务</li><li>在启动类上添加@EnableFeignClients注解</li></ul><blockquote><p>不要忘记在主配置文件修改<strong>统一</strong>的服务提供者和服务消费者的服务注册中心</p></blockquote><p><strong>pom依赖</strong></p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="comment">&lt;!--Eureka客户端依赖--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!--添加actuator依赖--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!--添加OpenFeign依赖--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p><strong>定义Service接口</strong></p><ul><li>@FeignClient：指定当前service所绑定的提供者微服务的名称</li><li>所有的@XXXMapping相关注解与服务提供者的Controller一一对应，就相当于我们消费者的接口实现是服务提供者的Controller</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer.service;<span class="keyword">import</span> com.lee.consumer.bean.Depart;<span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;<span class="keyword">import</span> org.springframework.web.bind.annotation.*;<span class="keyword">import</span> java.util.List;<span class="comment">//指定当前service所绑定的提供者微服务的名称</span><span class="meta">@FeignClient(&quot;leemsc-provider-depart&quot;)</span><span class="meta">@RequestMapping(&quot;/provider/depart&quot;)</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DepartService</span> &#123;    <span class="meta">@PostMapping(&quot;/save&quot;)</span>    <span class="type">boolean</span> <span class="title function_">saveDepart</span><span class="params">(Depart depart)</span>;    <span class="meta">@DeleteMapping(&quot;/del/&#123;id&#125;&quot;)</span>    <span class="type">boolean</span> <span class="title function_">removeDepartById</span><span class="params">(<span class="meta">@PathVariable</span>  <span class="type">int</span> id)</span>;    <span class="meta">@PutMapping(&quot;/update&quot;)</span>    <span class="type">boolean</span> <span class="title function_">modifyDepart</span><span class="params">(Depart depart)</span>;    <span class="meta">@GetMapping(&quot;/get/&#123;id&#125;&quot;)</span>    Depart <span class="title function_">getDepartById</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span>;    <span class="meta">@GetMapping(&quot;/list&quot;)</span>    List&lt;Depart&gt; <span class="title function_">listAllDeparts</span><span class="params">()</span>;&#125;</code></pre><p><strong>修改处理器类</strong></p><ul><li>使用feign风格的service，不再使用RestTemplate</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer.Controller;<span class="keyword">import</span> com.lee.consumer.bean.Depart;<span class="keyword">import</span> com.lee.consumer.service.DepartService;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.web.bind.annotation.*;<span class="keyword">import</span> org.springframework.web.client.RestTemplate;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * 使用openFeign后，不用再使用RestTemplate，编程风格和以前一样了</span><span class="comment"> */</span><span class="meta">@RestController</span><span class="meta">@RequestMapping(&quot;/consumer/depart&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartController</span> &#123;    <span class="meta">@Autowired</span>    <span class="comment">//这里不再注入RestTemplate，注入service接口</span>    <span class="keyword">private</span> DepartService service;    <span class="meta">@PostMapping(&quot;/save&quot;)</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveHandle</span><span class="params">(Depart depart)</span> &#123;        <span class="keyword">return</span> service.saveDepart(depart);    &#125;    <span class="meta">@DeleteMapping(&quot;/del/&#123;id&#125;&quot;)</span>    <span class="comment">//@PathVariable 表示获取url中的&#123;id&#125;的值</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteHandle</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;        <span class="keyword">return</span> service.removeDepartById(id);    &#125;    <span class="meta">@PutMapping(&quot;/update&quot;)</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateHandle</span><span class="params">(Depart depart)</span> &#123;        <span class="keyword">return</span> service.modifyDepart(depart);    &#125;    <span class="meta">@GetMapping(&quot;/get/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> Depart <span class="title function_">GetHandle</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span> &#123;        <span class="keyword">return</span> service.getDepartById(id);    &#125;    <span class="meta">@GetMapping(&quot;/list&quot;)</span>    <span class="keyword">public</span> List&lt;Depart&gt; <span class="title function_">listHandle</span><span class="params">()</span> &#123;        <span class="keyword">return</span> service.listAllDeparts();    &#125;&#125;</code></pre><p><strong>修改启动类</strong></p><ul><li>@EnableFeignClients：开启feign客户端，指定service接口所在包</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;<span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;<span class="comment">//开启feign客户端，指定service接口所在包</span><span class="meta">@EnableFeignClients(basePackages = &quot;com.lee.consumer.service&quot;)</span><span class="meta">@SpringBootApplication</span><span class="meta">@EnableEurekaClient</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(ConsumerApplication.class, args);    &#125;&#125;</code></pre><p><strong>运行测试</strong></p><h3 id="ribbon负载均衡展示"><a class="markdownIt-Anchor" href="#ribbon负载均衡展示"></a> Ribbon负载均衡展示</h3><p>前面的消费者例子是通过feign接口来消费微服务的，但没体现出负载均衡的功能，所以，下面将进行Feign负载均衡的功能展示</p><h4 id="系统结构"><a class="markdownIt-Anchor" href="#系统结构"></a> 系统结构</h4><p>负载均衡能力的展示需要搭建出多个服务提供者。下面将构建这样一一个系统:一一个微服务由三个提供者提供，而消费者使用Ribbon对这三个提供者进行负载均衡访问。Ribbon 首先会选择同一区域内访问量较少的EurekaServer,然后再从该EurekaServer中获取到服务列表，然后再根据用户指定的负载均衡策略选择-一个服务提供者。</p><h4 id="项目搭建"><a class="markdownIt-Anchor" href="#项目搭建"></a> 项目搭建</h4><p>首先我们需要创建三个服务名相同，使用数据库不同的服务提供者，我们只需要把之前的服务提供者复制三分，然后分别修改以下内容</p><ul><li><strong>创建数据库</strong>：让每一个服务提供者都访问自己的数据库（即分别创建三个database）</li><li><strong>修改配置文件</strong>：<ul><li>当前工程的端口号，8080，8081，8082</li><li>自己要连接的数据库database名</li></ul></li></ul><blockquote><p>注意：服务名称不可以修改，因为消费者是通过该名称来进行负载均衡服务消费的</p></blockquote><p><strong>测试</strong></p><p>分别启动三个服务提供者，启动一个eurekaserver，再启动服务消费者，查看Eureka服务中心：</p><p>我们调用服务消费者（Eureka client端）的Controller时，可以发现，默认负载均衡算法时分别调用三个服务提供者，因为<strong>默认负载均衡算法为轮询算法</strong></p><h3 id="ribbon负载均衡算法irule"><a class="markdownIt-Anchor" href="#ribbon负载均衡算法irule"></a> Ribbon负载均衡算法IRule</h3><p>Ribbon提供了多种负载均衡策略算法，例如轮询算法、随机算法、响应时间加权算法等。默认采用的是轮询算法。当然，我们也可以指定Ribbon所要采用的负载均衡算法。</p><h4 id="ribbon接口"><a class="markdownIt-Anchor" href="#ribbon接口"></a> Ribbon接口</h4><p>IRule接口的实现类就是Ribbon默认的几种负载均衡算法；</p><p><strong>choose0方法</strong></p><p><strong>Ribbon的负载均衡算法需要实现lRule接口</strong>，而该接口中的核心方法即choose()方法，即对提供者的选择方式就是在该方法中体现的。</p><p>查看该方法的注释，其意思是“根据key的值从alservers或upServers集合中选择一个可用的Server”。allServers是所有提供者集合，而upServers则是所有可用的提供者集合。choose()方法的参数key是集合选择的标准。</p><pre><code class="highlight java"><span class="keyword">package</span> com.netflix.loadbalancer;<span class="comment">/**</span><span class="comment"> * Interface that defines a &quot;Rule&quot; for a LoadBalancer. A Rule can be thought of</span><span class="comment"> * as a Strategy for loadbalacing. Well known loadbalancing strategies include</span><span class="comment"> * Round Robin, Response Time based etc.</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@author</span> stonse</span><span class="comment"> * </span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRule</span>&#123;    <span class="comment">/*</span><span class="comment">     * choose one alive server from lb.allServers or</span><span class="comment">     * lb.upServers according to key</span><span class="comment">     * </span><span class="comment">     * @return choosen Server object. NULL is returned if none</span><span class="comment">     *  server is available </span><span class="comment">     */</span>    <span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(Object key)</span>;        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span>;        <span class="keyword">public</span> ILoadBalancer <span class="title function_">getLoadBalancer</span><span class="params">()</span>;    &#125;</code></pre><blockquote><p>不过，从ribbon2.0开始，该key就被固定为“default”了，即该参数已经失去了实际的意义了，打开iRibbonLoadBalanceClient类的getServer()方法，可以看到其调用了loadBalancer的choose()方法，实参为&quot;default&quot;</p></blockquote><h4 id="ribbon自带算法"><a class="markdownIt-Anchor" href="#ribbon自带算法"></a> Ribbon自带算法</h4><p>Ribbon的内置可用负载均衡算法有七种</p><p><strong>RoundRobinRule</strong></p><p>轮询算法，Ribbon默认采用的策略</p><p><strong>BestAvailableRule</strong></p><p>选择并发量最小的provider，即连接的消费者数量最少的provider，其会遍历服务列表中的每一个provide，选择当前连接数量minimalConcurrentConnections最小的provider</p><p><strong>AvailabilityFilteringRule</strong></p><p>过滤掉由于连续连接或读故障而处于断路器跳闸状态的provide，或已经超过连接极限的provide，对剩余provide采用轮询策略</p><p><strong>ZoneAvoidanceRule</strong></p><p>复合判断provider所在区域的性能及provider的可用性选择服务器</p><p><strong>RandomRule</strong></p><p>随机策略，从所有可用的provide中随机选择一个</p><p><strong>RetryRule</strong></p><p>先按照RoundRobinRule策略获取provider，若获取失败，则再指定的时限内重试，默认的时限为500毫秒</p><p><strong>WeightedResponseTimeRule</strong></p><p>&quot;权重响应时间&quot;策略，根据每个provide的平均响应时间计算其权重，响应时间越快权重越大，被选中的几率就越高，再刚启动时采用轮询策略，后面就会根据权重进行选择了</p><h4 id="更换默认策略"><a class="markdownIt-Anchor" href="#更换默认策略"></a> 更换默认策略</h4><p>Ribbon默认采用的是RoundRobinRule，即轮询策略，但通过修改消费者的启动类或者codeConfig类可以实现更换负载均衡策略的目的：只需添加如下代码即可：</p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer;<span class="keyword">import</span> com.netflix.loadbalancer.IRule;<span class="keyword">import</span> com.netflix.loadbalancer.RandomRule;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;<span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;<span class="keyword">import</span> org.springframework.context.annotation.Bean;<span class="comment">//开启feign客户端，指定service接口所在包</span><span class="meta">@EnableFeignClients(basePackages = &quot;com.lee.consumer.service&quot;)</span><span class="meta">@SpringBootApplication</span><span class="meta">@EnableEurekaClient</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(ConsumerApplication.class, args);    &#125;    <span class="comment">//指定Ribbon使用&quot;随机算法策略&quot;</span>    <span class="meta">@Bean</span>    <span class="keyword">public</span> IRule <span class="title function_">LoadBalanceRule</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();    &#125;&#125;</code></pre><h4 id="自定义负载均衡策略"><a class="markdownIt-Anchor" href="#自定义负载均衡策略"></a> 自定义负载均衡策略</h4><p>该负载均衡策略的思路是：从所有可用的provider中排除掉指定端口号的provider，剩余的provide随机选择</p><pre><code class="highlight java"><span class="keyword">package</span> rule;<span class="keyword">import</span> com.netflix.loadbalancer.ILoadBalancer;<span class="keyword">import</span> com.netflix.loadbalancer.IRule;<span class="keyword">import</span> com.netflix.loadbalancer.Server;<span class="keyword">import</span> java.util.Iterator;<span class="keyword">import</span> java.util.List;<span class="keyword">import</span> java.util.Random;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRule</span> <span class="keyword">implements</span> <span class="title class_">IRule</span> &#123;    ILoadBalancer lb;    <span class="comment">//要排除的提供者端口号集合</span>    <span class="keyword">private</span> List&lt;Integer&gt; excludePorts;    <span class="keyword">public</span> <span class="title function_">CustomRule</span><span class="params">()</span> &#123;    &#125;    <span class="comment">//从构造函数中传入要排除的端口号集合</span>    <span class="keyword">public</span> <span class="title function_">CustomRule</span><span class="params">(List&lt;Integer&gt; excludePorts)</span> &#123;        <span class="built_in">this</span>.excludePorts = excludePorts;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(Object key)</span> &#123;        <span class="comment">//获取所有可用的提供者</span>        List&lt;Server&gt; servers = lb.getReachableServers();        <span class="comment">//获取所有排除了指定端口号的提供者</span>        List&lt;Server&gt; availableServices = <span class="built_in">this</span>.getAvailableServices(servers);        <span class="comment">//从剩余的提供者中随机获取可用的提供者</span>        <span class="keyword">return</span> <span class="built_in">this</span>.getAvailableRandomServices(availableServices);    &#125;    <span class="comment">//获取所有排除了指定端口号的提供者</span>    <span class="keyword">private</span> List&lt;Server&gt; <span class="title function_">getAvailableServices</span><span class="params">(List&lt;Server&gt; servers)</span> &#123;        <span class="keyword">if</span> (excludePorts == <span class="literal">null</span> || excludePorts.size() == <span class="number">0</span>) &#123;            <span class="keyword">return</span> servers;        &#125;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; servers.size(); i++) &#123;            <span class="keyword">for</span> (Integer port : excludePorts) &#123;                <span class="keyword">if</span> (port.equals(servers.get(i).getPort())) &#123;                    servers.remove(i);                    <span class="keyword">break</span>;                &#125;            &#125;        &#125;        <span class="keyword">return</span> servers;    &#125;    <span class="comment">//从剩余的提供者中随机获取可用的提供者</span>    <span class="keyword">private</span> Server <span class="title function_">getAvailableRandomServices</span><span class="params">(List&lt;Server&gt; servers)</span> &#123;        <span class="comment">//获取一个[0，servers.size() )的随机整数</span>        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(servers.size());        <span class="keyword">return</span> servers.get(index);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span> &#123;        <span class="built_in">this</span>.lb = lb;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> ILoadBalancer <span class="title function_">getLoadBalancer</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="built_in">this</span>.lb;    &#125;&#125;</code></pre><p>然后再启动类或者@Configuration声明的类给spring注入我们自定义的负载均衡规则</p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer;<span class="keyword">import</span> com.netflix.loadbalancer.IRule;<span class="keyword">import</span> com.netflix.loadbalancer.RandomRule;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;<span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;<span class="keyword">import</span> org.springframework.context.annotation.Bean;<span class="keyword">import</span> rule.CustomRule;<span class="keyword">import</span> java.util.ArrayList;<span class="keyword">import</span> java.util.List;<span class="comment">//开启feign客户端，指定service接口所在包</span><span class="meta">@EnableFeignClients(basePackages = &quot;com.lee.consumer.service&quot;)</span><span class="meta">@SpringBootApplication</span><span class="meta">@EnableEurekaClient</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(ConsumerApplication.class, args);    &#125;<span class="comment">//    //指定Ribbon使用&quot;随机算法策略&quot;</span><span class="comment">//    @Bean</span><span class="comment">//    public IRule LoadBalanceRule()&#123;</span><span class="comment">//        return new RandomRule();</span><span class="comment">//    &#125;</span>    <span class="comment">//指定Ribbon使用&quot;自定义的负载均衡算法策略&quot;</span>    <span class="meta">@Bean</span>    <span class="keyword">public</span> IRule <span class="title function_">LoadBalanceRule</span><span class="params">()</span>&#123;        List&lt;Integer&gt; ports = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();        ports.add(<span class="number">8081</span>);        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomRule</span>(ports);    &#125;&#125;</code></pre><h2 id="hystrix熔断机制与服务降级"><a class="markdownIt-Anchor" href="#hystrix熔断机制与服务降级"></a> Hystrix熔断机制与服务降级</h2><h3 id="服务熔断简介"><a class="markdownIt-Anchor" href="#服务熔断简介"></a> 服务熔断简介</h3><p>若要了解服务熔断，需要先了解雪崩效应和服务雪崩</p><p><strong>雪崩效应</strong></p><p>分布式系统中很容易出现雪崩效应</p><p>在IO型服务中，假设服务A依赖服务B和服务C，而B服务和C服务有可能继续依赖其他的服务，继续下去会使得调用链路过长，技术上称1-&gt;N扇出</p><p>如果在A的链路上某个或几个被调用的子服务不可用或延迟较高，则会导致调用A服务的请求被堵住。</p><p>堵住的A请求会消耗占用系统的线程、10等资源，当对A服务的请求越来越多，占用的计算机资源越来越多的时候，会导致系统瓶颈出现，造成其他的请求同样不可用，最终导致业务系统崩溃，这种现象称为雪崩效应。</p><p>例如一个汽车生产线，生产不同的汽车，需要使用不同的零件。如果某个零件因为种种原因无法及时供给，而没有该零件，则后续的好多已经到货的零件也无法安装。一个零件的缺失造成整台车无法装配，陷入等待零件的状态，直到零件到位，才能继续组装。</p><p>此时如果有很多个车型都需要这个零件，那么整个工厂都将陷入等待的状态，而前述已经生成好的汽车部件，及暂不能安装的其它零件,将由于等待而占用大量资金、厂地等资源。一个零件最终导致所有的生产陷入瘫痪，这就是雪崩效应。</p><p><strong>服务雪崩</strong></p><p>雪崩效应发生在分布式（Service-Oriented Architecture，面向服务的架构）系统中，则称为服务雪崩</p><p>上图是用户请求多个服务（A,H,I,P）均能正常访问并返回的情况</p><p>上图为请求服务I出现问题时，一个用户请求被阻塞的情况</p><p>上图为大量用户请求服务I出现异常全部陷入阻塞的情况，即发生服务血崩的情况</p><p>举个例子，一个依赖30个微服务的系统，每个服务99 99%可用。则整个系统的可用性为99.99%的30次方，约为99.7%。为什么是30次方呢?若系统依赖于2个微服务，个微服务的可用率为99.99%，那么，两个微服务的组合的可用率为99.99%* 99.99%，同理，30个微服务，每个微服务的可用率为99.99%，则这30个微服务组合后的可用性为99.99%的30次方。</p><p>也就是说，整个系统会存在0.3%的失败率。若存在一亿次请求，那么将会有30万次失败。随着随着服务依赖数量的增多，服务不稳定的概率会成指数性升高。</p><p><strong>熔断机制</strong></p><p>熔断机制是服务雪崩的一种有效解决方案。当服务消费者所请求的提供者暂不能提供服务时，消费者会被阻塞，且长时间占用请求链路。为I防止这种情况的发生，当在设定阈值时限到达时仍未获得提供者的服务，则系统将通过断路器直接将此请求链路断开。这种像熔断“保险丝”一样的解决方案称为熔断机制。</p><h3 id="hystrix简介"><a class="markdownIt-Anchor" href="#hystrix简介"></a> Hystrix简介</h3><p><a href="https://github.com/netflix/hystrix">官网：https://github.com/netflix/hystrix</a></p><p>在分布式环境中，其所依赖的一些服务出现失败是不可避免的。Hystrix是一一个通过添加容延逻辑与容错逻辑来控制这些分布式服务间相互影响的库。Hystrix通过隔离服务间的访问点、停止服务间的级联失败，及提供回退选项，来提升系统的整体弹性。</p><p><strong>综合说明</strong></p><p>在一个分布式系统里,许多服务不可避免的会出现调用失败的情况，比如超时、异常等。如何能够保证在一个服务出问题的情况下，不会导致整个系统瘫痪，这个就是Hystrix需要做的事情。Hystrix提供了熔断、隔离、Fallback、cache、 监控等功能，能够在-一个或多个服务同时出现问题时保证系统依然可用。</p><p>Hystrix是种开关装置， 类似于熔断保险丝。当Hystrix 监控到某个服务发生故障后，其不会让该服务的消费者阻塞，或向消费者抛出异常，而是向消费者返回一个符合预期的、可处理的备选响应（FallBack）,这样就避免了服务雪崩的发生</p><h3 id="服务降级简介"><a class="markdownIt-Anchor" href="#服务降级简介"></a> 服务降级简介</h3><p>在访问分布式系统中，经常会发生以下两种情况:</p><ul><li>当整个微服务架构整体的负载超出了预设的上限阈值，或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，我们可以将一些不重要或不紧急的服务进行延迟使用或暂停使用。这就是服务熔断，类似于主动拉电闸的服务熔断。此时，若有消费者消费这些延迟/暂停使用的服务则会出现阻塞，等待提供者的响应</li><li>当消费者访问某微服务时，由于网络或其它原因，提供者向消费者响应过慢，出现服务超时或根本就没有响应时，这也是一种服务熔断，类似于保险丝自动熔断的服务熔断。此时消费者会被迫阻塞，等待提供者的响应。</li></ul><p>在发生服务熔断时，不仅用户体验很差，其还占用了大量的系统资源。为了解决这个问题，在编写消费者端代码时就设置了预案:在消费者端给出一种默认的、临时的处理方案，能够给出消费者一个可以接受的结果。即，对于用户(指的是人，并非指消费者端)来说，其所消费的服务并非由应当提供服务的提供者端给出，而是由服务消费者临时给出，服务质量降级了。这就是“服务降级”，提供者端的&quot;服务熔断&quot;与消费者端的&quot;本地服务&quot;共同构成了&quot;服务降级&quot;</p><p><strong>简单来说服务降级指的是</strong>：当服务的提供者无法正常提供服务时，为了增加用户体验，保证整个系统能够正常运行，由服务消费者端调用本地操作，暂时给出用户响应结果的情况.</p><h3 id="hystrix服务降级方法级别"><a class="markdownIt-Anchor" href="#hystrix服务降级方法级别"></a> Hystrix服务降级（方法级别）</h3><p><strong>服务降级是针对消费者端的，和提供者没有任何关系</strong></p><p>无论消费者是通过RestTemplate消费微服务的，还是通过Feign接口消费微服务的，使用Hystrix的方法都一样，Hystrix与Feign之间并没有依赖关系</p><ul><li>添加hystrix依赖</li><li>修改处理器，在<strong>处理器方法</strong>上添加@HystrixCommand注解，并添加相应的Hystrix处理方法</li><li>在启动类上添加@EnableCircuitBreaker注解</li></ul><p><strong>pom依赖</strong></p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="comment">&lt;!--Eureka客户端依赖--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!--添加actuator依赖--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!--添加OpenFeign依赖--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!--hystrix依赖--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p><strong>处理器方法：</strong></p><ul><li>断路打开后，可用避免连锁故障，fallback方法可以直接返回一个固定值</li><li>方法上加上@HystrixCommand注解。该注解对该方法创建了熔断器的功能，并指定了fallbackMethod熔断方法</li><li>这就说明当服务提供者工程不可用的时候，消费者调用服务提供者的API接口时，会执行快速失败，直接返回一组字符串，而不是等待响应超时，这很好的控制了容器的线程阻塞</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer.Controller;<span class="keyword">import</span> com.lee.consumer.bean.Depart;<span class="keyword">import</span> com.lee.consumer.service.DepartService;<span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.web.bind.annotation.*;<span class="keyword">import</span> org.springframework.web.client.RestTemplate;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * 使用openFeign后，不用再使用RestTemplate，编程风格和以前一样了</span><span class="comment"> */</span><span class="meta">@RestController</span><span class="meta">@RequestMapping(&quot;/consumer/depart&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartController</span> &#123;    <span class="meta">@Autowired</span>    <span class="comment">//这里不再注入RestTemplate，注入service接口</span>    <span class="keyword">private</span> DepartService service;    <span class="meta">@PostMapping(&quot;/save&quot;)</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveHandle</span><span class="params">(Depart depart)</span> &#123;        <span class="keyword">return</span> service.saveDepart(depart);    &#125;    <span class="meta">@DeleteMapping(&quot;/del/&#123;id&#125;&quot;)</span>    <span class="comment">//@PathVariable 表示获取url中的&#123;id&#125;的值</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteHandle</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;        <span class="keyword">return</span> service.removeDepartById(id);    &#125;    <span class="meta">@PutMapping(&quot;/update&quot;)</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateHandle</span><span class="params">(Depart depart)</span> &#123;        <span class="keyword">return</span> service.modifyDepart(depart);    &#125;    <span class="comment">//方法级别的服务降级</span>    <span class="meta">@HystrixCommand(fallbackMethod = &quot;getHystrixHandle&quot;)</span>    <span class="meta">@GetMapping(&quot;/get/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> Depart <span class="title function_">GetHandle</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">Depart</span> <span class="variable">depart</span> <span class="operator">=</span>  service.getDepartById(id);        <span class="comment">//如果是服务端产生的异常则由类级别进行服务降级</span>        <span class="comment">//在这个方法中抛出的异常由方法级别进行服务降级</span>        <span class="comment">//模拟服务端调用延时，测试服务降级</span>        Thread.sleep(<span class="number">5100</span>);        <span class="keyword">return</span> depart;    &#125;    <span class="meta">@GetMapping(&quot;/list&quot;)</span>    <span class="keyword">public</span> List&lt;Depart&gt; <span class="title function_">listHandle</span><span class="params">()</span> &#123;        <span class="keyword">return</span> service.listAllDeparts();    &#125;    <span class="comment">//当@HystrixCommand标注的方法不能正常访问时调用此方法</span>    <span class="keyword">public</span> Depart <span class="title function_">getHystrixHandle</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span>&#123;        <span class="type">Depart</span> <span class="variable">depart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Depart</span>();        depart.setId(id);        depart.setName(<span class="string">&quot;no this depart&quot;</span>);        depart.setDbase(<span class="string">&quot;no this db&quot;</span>);        System.out.println(<span class="string">&quot;方法降级++++&quot;</span>);        <span class="keyword">return</span> depart;    &#125;&#125;</code></pre><p><strong>修改启动类：</strong></p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer;<span class="keyword">import</span> com.netflix.loadbalancer.IRule;<span class="keyword">import</span> com.netflix.loadbalancer.RandomRule;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;<span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;<span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;<span class="keyword">import</span> org.springframework.context.annotation.Bean;<span class="keyword">import</span> rule.CustomRule;<span class="keyword">import</span> java.util.ArrayList;<span class="keyword">import</span> java.util.List;<span class="comment">//开启服务降级</span><span class="meta">@EnableCircuitBreaker</span><span class="comment">//开启feign客户端，指定service接口所在包</span><span class="meta">@EnableFeignClients(basePackages = &quot;com.lee.consumer.service&quot;)</span><span class="meta">@SpringBootApplication</span><span class="meta">@EnableEurekaClient</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(ConsumerApplication.class, args);    &#125;&#125;</code></pre><h3 id="hystrix-feign服务降级类级别"><a class="markdownIt-Anchor" href="#hystrix-feign服务降级类级别"></a> Hystrix-Feign服务降级（类级别）</h3><p>前面所讲的HystrixCommon的fallbackMethod就是一种服务降级的方式，而这里我们要讲的是使用Feign对Hystrix的支持功能所实现的两一种服务降级的方式。</p><ul><li>在Feign接口所在包下定义降级处理类</li><li>在Feign接口中指定要使用的降级处理类</li><li>在配置文件中开启Feign对Hystrix的支持</li></ul><p><strong>Controller</strong></p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer.Controller;<span class="keyword">import</span> com.lee.consumer.bean.Depart;<span class="keyword">import</span> com.lee.consumer.service.DepartService;<span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.web.bind.annotation.*;<span class="keyword">import</span> org.springframework.web.client.RestTemplate;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * 使用openFeign后，不用再使用RestTemplate，编程风格和以前一样了</span><span class="comment"> */</span><span class="meta">@RestController</span><span class="meta">@RequestMapping(&quot;/consumer/depart&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartController</span> &#123;    <span class="meta">@Autowired</span>    <span class="comment">//这里不再注入RestTemplate，注入service接口</span>    <span class="keyword">private</span> DepartService service;    <span class="meta">@PostMapping(&quot;/save&quot;)</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveHandle</span><span class="params">(Depart depart)</span> &#123;        <span class="keyword">return</span> service.saveDepart(depart);    &#125;    <span class="meta">@DeleteMapping(&quot;/del/&#123;id&#125;&quot;)</span>    <span class="comment">//@PathVariable 表示获取url中的&#123;id&#125;的值</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteHandle</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;        <span class="keyword">return</span> service.removeDepartById(id);    &#125;    <span class="meta">@PutMapping(&quot;/update&quot;)</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateHandle</span><span class="params">(Depart depart)</span> &#123;        <span class="keyword">return</span> service.modifyDepart(depart);    &#125;    <span class="comment">//方法级别的服务降级</span>    <span class="meta">@HystrixCommand(fallbackMethod = &quot;getHystrixHandle&quot;)</span>    <span class="meta">@GetMapping(&quot;/get/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> Depart <span class="title function_">GetHandle</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">Depart</span> <span class="variable">depart</span> <span class="operator">=</span>  service.getDepartById(id);        <span class="comment">//如果是服务端产生的异常则由类级别进行服务降级</span>        <span class="comment">//在这个方法中抛出的异常由方法级别进行服务降级</span>        <span class="comment">//模拟服务端调用延时，测试服务降级</span>        Thread.sleep(<span class="number">5100</span>);        <span class="keyword">return</span> depart;    &#125;    <span class="meta">@GetMapping(&quot;/list&quot;)</span>    <span class="keyword">public</span> List&lt;Depart&gt; <span class="title function_">listHandle</span><span class="params">()</span> &#123;        <span class="keyword">return</span> service.listAllDeparts();    &#125;    <span class="comment">//当@HystrixCommand标注的方法不能正常访问时调用此方法</span>    <span class="keyword">public</span> Depart <span class="title function_">getHystrixHandle</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span>&#123;        <span class="type">Depart</span> <span class="variable">depart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Depart</span>();        depart.setId(id);        depart.setName(<span class="string">&quot;no this depart&quot;</span>);        depart.setDbase(<span class="string">&quot;no this db&quot;</span>);        System.out.println(<span class="string">&quot;方法降级++++&quot;</span>);        <span class="keyword">return</span> depart;    &#125;&#125;</code></pre><p><strong>定义降级处理类</strong></p><ul><li>降级处理类需要实现FallbackFactory接口，该接口的泛型为Feign接口，该类可以定义在任意包下，不过，一般会与Feign接口定义在同一包下，本例在DepartService接口所在包中定义降级处理类DepartFallbackFactory</li><li>该类需要使用@Component注解，表示要将其交给Spring容器来管理</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer.service;<span class="keyword">import</span> com.lee.consumer.bean.Depart;<span class="keyword">import</span> feign.hystrix.FallbackFactory;<span class="keyword">import</span> org.springframework.stereotype.Component;<span class="keyword">import</span> java.util.List;<span class="comment">//服务降级处理类</span><span class="comment">//FallbackFactory&lt;&gt;的泛型是Feign的Service接口</span><span class="meta">@Component</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartFallbackFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;DepartService&gt; &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> DepartService <span class="title function_">create</span><span class="params">(Throwable throwable)</span> &#123;        <span class="comment">//返回一个DeparteService()接口的对象</span>        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DepartService</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveDepart</span><span class="params">(Depart depart)</span> &#123;                System.out.println(<span class="string">&quot;服务降级++++++saveDepart+++++++++&quot;</span>);                <span class="keyword">return</span> <span class="literal">false</span>;            &#125;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeDepartById</span><span class="params">(<span class="type">int</span> id)</span> &#123;                System.out.println(<span class="string">&quot;服务降级++++++removeDepartById+++++++++&quot;</span>);                <span class="keyword">return</span> <span class="literal">false</span>;            &#125;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">modifyDepart</span><span class="params">(Depart depart)</span> &#123;                System.out.println(<span class="string">&quot;服务降级++++++modifyDepart+++++++++&quot;</span>);                <span class="keyword">return</span> <span class="literal">false</span>;            &#125;            <span class="meta">@Override</span>            <span class="keyword">public</span> Depart <span class="title function_">getDepartById</span><span class="params">(<span class="type">int</span> id)</span> &#123;                System.out.println(<span class="string">&quot;服务降级++++++getDepartById+++++++++&quot;</span>);                <span class="type">Depart</span> <span class="variable">depart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Depart</span>();                depart.setId(id);                depart.setName(<span class="string">&quot;no this depart&quot;</span>);                depart.setDbase(<span class="string">&quot;no this db&quot;</span>);                <span class="keyword">return</span> depart;            &#125;            <span class="meta">@Override</span>            <span class="keyword">public</span> List&lt;Depart&gt; <span class="title function_">listAllDeparts</span><span class="params">()</span> &#123;                System.out.println(<span class="string">&quot;服务降级++++++listAllDeparts+++++++++&quot;</span>);                <span class="keyword">return</span> <span class="literal">null</span>;            &#125;        &#125;;    &#125;&#125;</code></pre><p><strong>在Feign接口指定服务降级类</strong></p><ul><li>@FeignClient的fallbackFactory属性指定服务降级类</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer.service;<span class="keyword">import</span> com.lee.consumer.bean.Depart;<span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;<span class="keyword">import</span> org.springframework.stereotype.Service;<span class="keyword">import</span> org.springframework.web.bind.annotation.*;<span class="keyword">import</span> java.util.List;<span class="comment">//指定当前service所绑定的提供者微服务的名称,指定服务降级处理类</span><span class="meta">@FeignClient(value=&quot;leemsc-provider-depart&quot;,fallbackFactory=DepartFallbackFactory.class)</span><span class="meta">@RequestMapping(&quot;/provider/depart&quot;)</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DepartService</span> &#123;    <span class="meta">@PostMapping(&quot;/save&quot;)</span>    <span class="type">boolean</span> <span class="title function_">saveDepart</span><span class="params">(Depart depart)</span>;    <span class="meta">@DeleteMapping(&quot;/del/&#123;id&#125;&quot;)</span>    <span class="type">boolean</span> <span class="title function_">removeDepartById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>  <span class="type">int</span> id)</span>;    <span class="meta">@PutMapping(&quot;/update&quot;)</span>    <span class="type">boolean</span> <span class="title function_">modifyDepart</span><span class="params">(Depart depart)</span>;    <span class="meta">@GetMapping(&quot;/get/&#123;id&#125;&quot;)</span>    Depart <span class="title function_">getDepartById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span>;    <span class="meta">@GetMapping(&quot;/list&quot;)</span>    List&lt;Depart&gt; <span class="title function_">listAllDeparts</span><span class="params">()</span>;&#125;</code></pre><p><strong>修改主配置文件</strong></p><pre><code class="highlight properties"><span class="comment">#指定端口号</span><span class="attr">server.port</span>=<span class="string">8080</span><span class="comment"></span><span class="comment">#指定微服务对外暴露的名称</span><span class="attr">spring.application.name</span>=<span class="string">leemsc-consumer-depart</span><span class="comment"></span><span class="comment">#指定Eureka服务注册中心</span><span class="attr">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:8000/eureka</span><span class="comment"></span><span class="comment">#开启Feign对Hystrix的支持</span><span class="attr">feign.hystrix.enabled</span>=<span class="string">true</span><span class="comment">#设置服务熔断时限，默认为5000毫秒（即等待响应的时间）</span><span class="attr">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</span>=<span class="string">5000</span></code></pre><p><strong>运行：</strong></p><p>由于改代码中同时出现了两种降级方式</p><ul><li>所以运行时如果只是服务端出现了问题，那么返回的是fallbackFactory的响应结果，fallbackMethod则未执行</li><li>如果运行时服务端调用没问题，消费者处理器执行过程中有异常，则fallbackFactory不执行，fallbackMethod执行</li><li>如果运行时服务端出现了问题，消费者处理器执行过程中也有异常，则两个都执行</li></ul><h3 id="两种降级同时使用"><a class="markdownIt-Anchor" href="#两种降级同时使用"></a> 两种降级同时使用</h3><p>一般情况下这两种方式同时使用，fallbackMethod方式用于解决处理器执行过程中的异常问题，而服务降级类方式用于解决未获取到服务问题</p><h2 id="网关服务zuul"><a class="markdownIt-Anchor" href="#网关服务zuul"></a> 网关服务zuul</h2><p>zuul时从设备和web站点到Netflix流应用后端的所有请求的前门，作为边界服务应用，zuul实现类动态路由，监视，弹性和安全性而构建的，它还具有根据情况将请求路由到多个Amazon Auto Scaling Groups的能力</p><h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3><p>Zuul主要提供了对请求的路由与过滤功能。路由功能主要指，将外部请求转发到具体的微服务实例上，是外部访问微服务的统一入口。 过滤功能主要指，对请求的处理过程进行干预，对请求进行校验、服务聚合等处理。</p><p>Zuul与Eureka进行整合,将Zuul自身注册为Eureka服务治理下的应用，从Eureka Server中获取到其它微服务信息，使外部对于微服务的访问都是通过Zuul进行转发的。</p><p>那么，具体怎么使用呢?服务提供者是消费者通过EurekaServer进行访问的，即相当于EurekaSenver是服务提供者的统一入口。那么服务消费者很多，用户怎样访问这些消费者工程呢?当然可以像之前那样直接访问这些工程。但这种方式没有统一的消费者工程调用入口，不便于访问与管理，而Zuul就是这样的一个对于消费者的统一入口。这点，从Spring官网<a href="http://spring.xn--io-uv2c6e61b4sr2mpsekzi208b75a679g0xhu73j">http://spring.io最下面的图中可以体现出来</a>。</p><h3 id="基本用法"><a class="markdownIt-Anchor" href="#基本用法"></a> 基本用法</h3><p><strong>创建一个springboot工程</strong><br />创建一个Spring boot工程</p><p>项目名称：</p><p>添加依赖：</p><p><strong>pom依赖</strong></p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zuulserver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>zuulserver<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR3<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p><strong>主配置文件</strong></p><pre><code class="highlight properties"><span class="attr">server.port</span>=<span class="string">9000</span><span class="comment">#设置服务注册中心</span><span class="attr">eureka.client.service-url.defaultZone</span>:<span class="string">http://localhost:8000/eureka</span><span class="comment"></span><span class="comment">#设置spring应用名</span><span class="attr">spring.application.name</span>=<span class="string">leemsc-zuul-depart</span></code></pre><p><strong>启动类</strong></p><ul><li>启动类使用@EnableZuulProxy开启zuul代理模式</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.zuulserver;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cloud.netflix.zuul.EnableZuulProxy;<span class="comment">//开启zuul代理模式</span><span class="meta">@EnableZuulProxy</span><span class="meta">@SpringBootApplication</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZuulserverApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(ZuulserverApplication.class, args);    &#125;&#125;</code></pre><p><strong>访问测试</strong></p><ul><li>通过zuul来访问consumer</li></ul><pre><code class="highlight plaintext">http://localhost:9000/leemsc-consumer-depart/consumer/depart/get/2</code></pre><h3 id="路由访问映射规则"><a class="markdownIt-Anchor" href="#路由访问映射规则"></a> 路由访问映射规则</h3><p><strong>修改主配置文件</strong></p><ul><li>leedepart可以随意命名，但service-id与path是关键字，不能更改</li><li>leedepart.service-id指定要被替换掉的微服务名称</li><li>leedepart.path指定用于替换指定微服务名称的路径</li></ul><pre><code class="highlight properties"><span class="attr">server.port</span>=<span class="string">9000</span><span class="comment">#设置服务注册中心</span><span class="attr">eureka.client.service-url.defaultZone</span>:<span class="string">http://localhost:8000/eureka</span><span class="comment"></span><span class="comment">#设置spring应用名</span><span class="attr">spring.application.name</span>=<span class="string">leemsc-zuul-depart</span><span class="comment"></span><span class="comment">#设置zuul路由规则</span><span class="comment">#设置要被替换的微服务名称</span><span class="attr">zuul.routes.leedepart.service-id</span>=<span class="string">leemsc-consumer-depart</span><span class="comment">#指定替换使用的路径</span><span class="attr">zuul.routes.leedepart.path</span>=<span class="string">/condep/**</span></code></pre><p><strong>测试</strong></p><ul><li>访问路径修改成了替换的名字，可以隐藏真正的consumer名</li></ul><h3 id="忽略服务名称"><a class="markdownIt-Anchor" href="#忽略服务名称"></a> 忽略服务名称</h3><p>以上配置虽然可以使用映射路径访问微服务，但通过原来的服务名称仍然可以访问到微服务，即以上的配置并没有隐藏和保护原来的微服务名称，可以在配置文件中设置忽略微服务属性，禁掉原来所有的微服务名称使用，有两种设置方式，忽略指定微服务，与忽略所有微服务</p><p><strong>忽略指定微服务名称</strong></p><ul><li>在配置文件中指定要忽略的微服务</li></ul><pre><code class="highlight properties"><span class="attr">server.port</span>=<span class="string">9000</span><span class="comment">#设置服务注册中心</span><span class="attr">eureka.client.service-url.defaultZone</span>:<span class="string">http://localhost:8000/eureka</span><span class="comment"></span><span class="comment">#设置spring应用名</span><span class="attr">spring.application.name</span>=<span class="string">leemsc-zuul-depart</span><span class="comment"></span><span class="comment">#设置zuul路由规则</span><span class="comment">#设置要被替换的微服务名称</span><span class="attr">zuul.routes.leedepart.service-id</span>=<span class="string">leemsc-consumer-depart</span><span class="comment">#指定替换使用的路径</span><span class="attr">zuul.routes.leedepart.path</span>=<span class="string">/condep/**</span><span class="comment"></span><span class="comment">#指定要忽略的微服务(即通过此名称无法访问，只可以使用替换的路径)</span><span class="attr">zuul.ignored-services</span>=<span class="string">leemsc-consumer-depart</span></code></pre><blockquote><p>此时再通过微服务名称已经无法访问到微服务了，但通过映射路径是可以访问到的</p></blockquote><p><strong>忽略所有微服务名称</strong></p><ul><li>指定所有的微服务名称都无法访问，只能通过替换的名称</li></ul><pre><code class="highlight properties"><span class="comment">#指定所有的微服务名称都无法访问，只能通过替换的名称</span><span class="attr">zuul.ignored-services</span>=<span class="string">*</span></code></pre><p><strong>测试访问</strong><br />通过别名可以访问：</p><p>通过微服务全称无法访问：</p><h3 id="为映射路径配置统一前缀"><a class="markdownIt-Anchor" href="#为映射路径配置统一前缀"></a> 为映射路径配置统一前缀</h3><p>一般情况下我们会在映射路径前添加一个前缀用于表示模块信息或公司名称等，而前缀对于各个微服务来说一般都是需要的，我们可以为映射路径统一配置前缀</p><p><strong>修改主配置文件</strong></p><pre><code class="highlight properties"><span class="attr">server.port</span>=<span class="string">9000</span><span class="comment">#设置服务注册中心</span><span class="attr">eureka.client.service-url.defaultZone</span>:<span class="string">http://localhost:8000/eureka</span><span class="comment"></span><span class="comment">#设置spring应用名</span><span class="attr">spring.application.name</span>=<span class="string">leemsc-zuul-depart</span><span class="comment"></span><span class="comment">#设置zuul路由规则</span><span class="comment">#设置要被替换的微服务名称</span><span class="attr">zuul.routes.leedepart.service-id</span>=<span class="string">leemsc-consumer-depart</span><span class="comment">#指定替换使用的路径</span><span class="attr">zuul.routes.leedepart.path</span>=<span class="string">/condep/**</span><span class="comment"></span><span class="comment">#指定要忽略的微服务(即通过此名称无法访问，只可以使用替换的路径)</span><span class="comment">#zuul.ignored-services=leemsc-consumer-depart</span><span class="comment"></span><span class="comment">#指定所有的微服务名称都无法访问，只能通过替换的名称</span><span class="attr">zuul.ignored-services</span>=<span class="string">*</span><span class="comment"></span><span class="comment">#指定访问的统一前缀</span><span class="attr">zuul.prefix</span>=<span class="string">/depart</span></code></pre><p><strong>测试访问</strong></p><h2 id="spring-cloud-config分布式配置中心"><a class="markdownIt-Anchor" href="#spring-cloud-config分布式配置中心"></a> Spring Cloud Config分布式配置中心</h2><p>SpringCloudConfig的原理是,我们首先需要将各个微服务公共的配置信息推送到GitHub远程版本库。然后我们再定义一个Spring Cloud Config Server,其会连接上这个GitHub远程库。这样我们就可以定义Config版的Eureka Server、 提供者与消费者了。这些都将作为SpringCloudConfig Client出现，它们都会通过连接Spring Cloud Config server连接上GitHub上的远程库，以读取到指定配置文件中的内容。</p><h3 id="github远程库设置"><a class="markdownIt-Anchor" href="#github远程库设置"></a> github远程库设置</h3><h4 id="前提准备"><a class="markdownIt-Anchor" href="#前提准备"></a> 前提准备</h4><p><strong>非对称加密原理</strong></p><p><strong>设置github免密登录</strong><br />使用gitBash输入命令生成私/公钥</p><pre><code class="highlight plaintext">ssh-keygen</code></pre><p>然后再<code>C:\Users\leeboer\.ssh</code>文件夹找到公钥，打开，复制里面的内容放到github上</p><p><strong>建立远程库</strong></p><p><strong>clone远程库到本地</strong></p><pre><code class="highlight plaintext">git clone https://github.com/leeboer/SpringConfigTest.git</code></pre><h4 id="创建本地配置文件并推送到远程库"><a class="markdownIt-Anchor" href="#创建本地配置文件并推送到远程库"></a> 创建本地配置文件并推送到远程库</h4><blockquote><p><strong>spring cloud config工程必须使用yml文件，使用其他配置文件在git无法读取</strong></p></blockquote><p><strong>创建本地配置文件</strong></p><p>我们需要定义并推送三个配置文件，这三个配置文件分别是为了后续EurekaServer，provider，与consumer使用的</p><p>多环境测试文件：application.yml</p><ul><li>yml多配置之间要使用 “—” 分割</li></ul><pre><code class="highlight yml"><span class="attr">spring:</span>  <span class="attr">profiles:</span>    <span class="attr">active:</span> <span class="string">dev</span><span class="meta">---</span><span class="comment">#dev配置</span><span class="attr">spring:</span>  <span class="attr">application:</span>    <span class="attr">name:</span> <span class="string">leemsc-config-dev</span>  <span class="attr">profiles:</span>    <span class="attr">active:</span> <span class="string">dev</span><span class="meta">---</span><span class="comment">#test配置</span><span class="attr">spring:</span>  <span class="attr">application:</span>    <span class="attr">name:</span> <span class="string">leemsc-config-test</span>  <span class="attr">profiles:</span>    <span class="attr">active:</span> <span class="string">test</span></code></pre><p>application-consumer-config.properties</p><pre><code class="highlight properties"><span class="comment">#配置dev环境</span><span class="attr">server</span>:<span class="string"></span>  <span class="attr">port</span>: <span class="string">7070</span><span class="attr">spring</span>:<span class="string"></span>  <span class="attr">application</span>:<span class="string"></span>    <span class="attr">name</span>: <span class="string">leemsc-consumer-depart</span>  <span class="attr">profiles</span>: <span class="string">dev</span><span class="attr">eureka</span>:<span class="string"></span>  <span class="attr">client</span>:<span class="string"></span>    <span class="attr">service-url</span>:<span class="string"></span>      <span class="attr">defaultZone</span>: <span class="string">http://localhost:8100/eureka</span><span class="attr">feign</span>:<span class="string"></span>  <span class="attr">hystrix</span>:<span class="string"></span>    <span class="attr">enabled</span>: <span class="string">true</span><span class="attr">hystrix</span>:<span class="string"></span>  <span class="attr">command</span>:<span class="string"></span>    <span class="attr">default</span>:<span class="string"></span>      <span class="attr">execution</span>:<span class="string"></span>        <span class="attr">isolation</span>:<span class="string"></span>          <span class="attr">thread</span>:<span class="string"></span>            <span class="attr">timeoutInMilliseconds</span>: <span class="string">5000</span><span class="attr">---</span><span class="comment">#配置test环境</span><span class="attr">server</span>:<span class="string"></span>  <span class="attr">port</span>: <span class="string">9090</span><span class="attr">spring</span>:<span class="string"></span>  <span class="attr">application</span>:<span class="string"></span>    <span class="attr">name</span>: <span class="string">leemsc-consumer-depart</span>  <span class="attr">profiles</span>: <span class="string">test</span><span class="attr">eureka</span>:<span class="string"></span>  <span class="attr">client</span>:<span class="string"></span>    <span class="attr">service-url</span>:<span class="string"></span>      <span class="attr">defaultZone</span>: <span class="string">http://localhost:8200/eureka</span><span class="attr">feign</span>:<span class="string"></span>  <span class="attr">hystrix</span>:<span class="string"></span>    <span class="attr">enabled</span>: <span class="string">true</span><span class="attr">hystrix</span>:<span class="string"></span>  <span class="attr">command</span>:<span class="string"></span>    <span class="attr">default</span>:<span class="string"></span>      <span class="attr">execution</span>:<span class="string"></span>        <span class="attr">isolation</span>:<span class="string"></span>          <span class="attr">thread</span>:<span class="string"></span>            <span class="attr">timeoutInMilliseconds</span>: <span class="string">5000</span></code></pre><p>application-provider-config.properties</p><pre><code class="highlight properties"><span class="comment">#dev环境</span><span class="attr">server</span>:<span class="string"></span>  <span class="attr">port</span>: <span class="string">8082</span><span class="attr">spring</span>:<span class="string"></span>  <span class="attr">profiles</span>: <span class="string">dev</span>  <span class="attr">application</span>:<span class="string"></span>    <span class="attr">name</span>: <span class="string">leemsc-provider-depart</span>  <span class="attr">datasource</span>:<span class="string"></span>    <span class="attr">driver-class-name</span>: <span class="string">com.mysql.jdbc.Driver</span>    <span class="attr">password</span>: <span class="string">123456</span>    <span class="attr">type</span>: <span class="string">com.alibaba.druid.pool.DruidDataSource</span>    <span class="attr">url</span>: <span class="string">jdbc:mysql://127.0.0.1:3306/leetest01?characterEncoding=UTF-8</span>    <span class="attr">username</span>: <span class="string">root</span>  <span class="attr">jpa</span>:<span class="string"></span>    <span class="attr">generate-ddl</span>: <span class="string">true</span>    <span class="attr">hibernate</span>:<span class="string"></span>      <span class="attr">ddl-auto</span>: <span class="string">none</span>    <span class="attr">show-sql</span>: <span class="string">true</span><span class="attr">eureka</span>:<span class="string"></span>  <span class="attr">client</span>:<span class="string"></span>    <span class="attr">service-url</span>:<span class="string"></span>      <span class="attr">defaultZone</span>: <span class="string">http://localhost:8100/eureka</span><span class="attr">logging</span>:<span class="string"></span>  <span class="attr">level</span>:<span class="string"></span>    <span class="attr">com</span>:<span class="string"></span>      <span class="attr">lee</span>: <span class="string">debug</span>    <span class="attr">org</span>:<span class="string"></span>      <span class="attr">hibernate</span>: <span class="string">info</span>      <span class="attr">hibernate.type.descriptor.sql.BasicBinder</span>: <span class="string">trace</span>    <span class="attr">root</span>: <span class="string">info</span>  <span class="attr">pattern</span>:<span class="string"></span>    <span class="attr">console</span>: <span class="string">&#x27;%level %msg%n&#x27;</span><span class="attr">info</span>:<span class="string"></span>  <span class="attr">app</span>:<span class="string"></span>    <span class="attr">name</span>: <span class="string">leemsc-provider-depart</span>    <span class="attr">people</span>: <span class="string">leeboer</span>  <span class="attr">company</span>:<span class="string"></span>    <span class="attr">address</span>: <span class="string">xian</span>    <span class="attr">name</span>: <span class="string">leeboer.xyz</span>    <span class="attr">tel</span>: <span class="string">123456798</span><span class="attr">---</span><span class="comment">#test环境</span><span class="attr">server</span>:<span class="string"></span>  <span class="attr">port</span>: <span class="string">8083</span><span class="attr">spring</span>:<span class="string"></span>  <span class="attr">profiles</span>: <span class="string">test</span>  <span class="attr">application</span>:<span class="string"></span>    <span class="attr">name</span>: <span class="string">leemsc-provider-depart</span>  <span class="attr">datasource</span>:<span class="string"></span>    <span class="attr">driver-class-name</span>: <span class="string">com.mysql.jdbc.Driver</span>    <span class="attr">password</span>: <span class="string">123456</span>    <span class="attr">type</span>: <span class="string">com.alibaba.druid.pool.DruidDataSource</span>    <span class="attr">url</span>: <span class="string">jdbc:mysql://127.0.0.1:3306/leetest?characterEncoding=UTF-8</span>    <span class="attr">username</span>: <span class="string">root</span>  <span class="attr">jpa</span>:<span class="string"></span>    <span class="attr">generate-ddl</span>: <span class="string">true</span>    <span class="attr">hibernate</span>:<span class="string"></span>      <span class="attr">ddl-auto</span>: <span class="string">none</span>    <span class="attr">show-sql</span>: <span class="string">true</span><span class="attr">eureka</span>:<span class="string"></span>  <span class="attr">client</span>:<span class="string"></span>    <span class="attr">service-url</span>:<span class="string"></span>      <span class="attr">defaultZone</span>: <span class="string">http://localhost:8200/eureka</span><span class="attr">logging</span>:<span class="string"></span>  <span class="attr">level</span>:<span class="string"></span>    <span class="attr">com</span>:<span class="string"></span>      <span class="attr">lee</span>: <span class="string">debug</span>    <span class="attr">org</span>:<span class="string"></span>      <span class="attr">hibernate</span>: <span class="string">info</span>      <span class="attr">hibernate.type.descriptor.sql.BasicBinder</span>: <span class="string">trace</span>    <span class="attr">root</span>: <span class="string">info</span>  <span class="attr">pattern</span>:<span class="string"></span>    <span class="attr">console</span>: <span class="string">&#x27;%level %msg%n&#x27;</span><span class="attr">info</span>:<span class="string"></span>  <span class="attr">app</span>:<span class="string"></span>    <span class="attr">name</span>: <span class="string">leemsc-provider-depart</span>    <span class="attr">people</span>: <span class="string">leeboer</span>  <span class="attr">company</span>:<span class="string"></span>    <span class="attr">address</span>: <span class="string">xian</span>    <span class="attr">name</span>: <span class="string">leeboer.xyz</span>    <span class="attr">tel</span>: <span class="string">123456798</span></code></pre><p>application-eureka-config.properties</p><pre><code class="highlight yml"><span class="comment">#dev环境</span><span class="attr">spring:</span>  <span class="attr">application:</span>    <span class="attr">name:</span> <span class="string">leemsc-eurekaServer-config</span>  <span class="attr">profiles:</span> <span class="string">dev</span><span class="attr">server:</span>  <span class="attr">port:</span> <span class="number">8100</span><span class="attr">eureka:</span>  <span class="attr">instance:</span>    <span class="attr">hostname:</span> <span class="string">localhost</span> <span class="comment">#指定Eureka主机</span>  <span class="attr">client:</span>    <span class="attr">fetch-registry:</span> <span class="literal">false</span> <span class="comment">#指定当前主机是否需要获取注册信息</span>    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#指定当前主机是否需要向注册中心注册</span>    <span class="attr">service-url:</span>      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8100/eureka</span> <span class="comment">#暴露服务中心地址</span><span class="meta">---</span><span class="comment">#test测试环境</span><span class="attr">spring:</span>  <span class="attr">application:</span>    <span class="attr">name:</span> <span class="string">leemsc-eurekaServer-config</span>  <span class="attr">profiles:</span> <span class="string">test</span><span class="attr">server:</span>  <span class="attr">port:</span> <span class="number">8200</span><span class="attr">eureka:</span>  <span class="attr">instance:</span>    <span class="attr">hostname:</span> <span class="string">localhost</span>  <span class="attr">client:</span>    <span class="attr">fetch-registry:</span> <span class="literal">false</span>    <span class="attr">register-with-eureka:</span> <span class="literal">false</span>    <span class="attr">service-url:</span>      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8200/eureka</span></code></pre><p><strong>把本地配置文件推送到远程库</strong></p><pre><code class="highlight plaintext">$ git add *$ git commit -m &quot;first one&quot;$ git push</code></pre><h3 id="创建spring-cloud-config工程"><a class="markdownIt-Anchor" href="#创建spring-cloud-config工程"></a> 创建Spring Cloud Config工程</h3><p>该工程将存放当前项目中所有EurekaServer的配置文件，服务提供者，服务消费者等工程的配置文件公共服务</p><h4 id="环境搭建"><a class="markdownIt-Anchor" href="#环境搭建"></a> 环境搭建</h4><p><strong>创建spring boot工程</strong></p><p>定义一个基础的spring boot工程：</p><p>项目名：</p><p>添加config server依赖：</p><p><strong>pom依赖</strong></p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>configserver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>configserver<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR3<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p><strong>定义配置文件</strong></p><ul><li>指定当前工程所关联的git远程库地址</li></ul><pre><code class="highlight properties"><span class="attr">server.port</span>=<span class="string">9999</span><span class="comment"></span><span class="comment">#指定当前工程所关联的git远程库地址</span><span class="attr">spring.cloud.config.server.git.uri</span>=<span class="string">git@github.com:leeboer/SpringConfigTest.git</span></code></pre><p><strong>定义启动类</strong></p><ul><li>加上@EnableConfigServer注解</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.configserver;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cloud.config.server.EnableConfigServer;<span class="comment">//开启ConfigServer服务</span><span class="meta">@EnableConfigServer</span><span class="meta">@SpringBootApplication</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigserverApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(ConfigserverApplication.class, args);    &#125;&#125;</code></pre><h4 id="运行访问"><a class="markdownIt-Anchor" href="#运行访问"></a> 运行访问</h4><p>此时，Config Server服务器就已经定义完毕了，为了证明通过该服务器可以成功访问到Github的远程库的文件，现以之前上传到远程库中的多环境选择配置文件为例，查看多环境的切换</p><p><strong>1 完成多环境切换</strong></p><p>注意，下面的操作是通过读取远程库中的application.properties文件，并完成多环境的切换，并非简单的读取远程库文件</p><ul><li>A-切换到dev环境</li></ul><p>地址栏中输入的是可以完成多环境选择的application-dev.properties，并非是上传到远程库的application.properties，并会切换至配置文件中存在的dev环境，页面显示的dev环境信息及工共配置信息，并未显示test环境信息</p><ul><li>B-切换到test环境</li></ul><p>切换至配置文件的test环境，页面显示的是test的环境信息和工共配置信息，但并未显示dev的环境信息</p><ul><li>C-切换到不同存在的环境</li></ul><p>切换到不存在的环境，则页面显示公共配置信息，其他多环境信息不显示。</p><p><strong>2 切换到指定分支的指定环境</strong></p><p>切换到master分支的dev环境，默认即为master分支，即前面的切换都是切换到了默认master分支的多环境</p><p><strong>3 读取master分支上有关dev的配置信息</strong></p><h3 id="定义config版的eureka-server服务器"><a class="markdownIt-Anchor" href="#定义config版的eureka-server服务器"></a> 定义config版的Eureka Server服务器</h3><p>只需要三步：</p><ul><li>添加spring-cloud-starter-config依赖</li><li>删除旧的application.properties</li><li>添加bootstrap.yml文件</li></ul><p><strong>pom依赖</strong></p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>eurekaserver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>eurekaserver<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR3<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="comment">&lt;!--添加spring cloud config客户端依赖--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p><strong>定义bootstrap.yml</strong></p><p>下面的配置必须定义在bootstrap.yml文件中，若定义在application中，则Eureka无法启动（因为我们的配置文件是远程加载的，所以删掉原来的application）</p><p>bootstrapyml文件是在应用程序启动时加载的，而其中的配置一般也都是应用程序启动时所必须的数据。application.xml中配置 数据则是应用程序启动后在执行过程中要读取的数据。例如，本例的Eureka若要启动，则必须要在启动过程中读取到指定的GitHub中配置文件的数据，否则无法启动。所以，这些信息需要配置在bootstrap.yml中，若配置在applicationyml中，应用在启动时是读取不到的。</p><pre><code class="highlight yml"><span class="attr">spring:</span>  <span class="attr">cloud:</span>    <span class="attr">config:</span>      <span class="comment">#指定configServer的地址</span>      <span class="attr">uri:</span> <span class="string">http://localhost:9999</span>      <span class="comment">#指定要访问远程库的分支</span>      <span class="attr">label:</span> <span class="string">master</span>      <span class="comment">#指定要从远程库读取的配置文件名（无需加yml扩展名，因为只能使用yml文件）</span>      <span class="attr">name:</span> <span class="string">application-eureka-config</span>      <span class="comment">#选择环境</span>      <span class="attr">profile:</span> <span class="string">dev</span></code></pre><blockquote><p>由于当前主机要运行的真正自己需要的配置文件信息需要从远程库中读取，所以这里的application.yml文件就不再需要了，将其<strong>删除</strong></p></blockquote><p><strong>启动</strong></p><p>若配置文件修改了，则需要将修改的配置文件提交到远程库，然后还需要重启config server工程</p><p><strong>运行</strong></p><p>如果不指定读取的环境，则<u>默认读取的是dev</u></p><p>运行成功</p><blockquote><p>默认是dev，那么如何切换到test呢？其并不能像普通的spring boot工程那样，在运行jar文件时通过添加参数进行切换，因为环境配置信息均是从远程仓库拉取的，本地是没有要切换的环境信息的，而要获取这些信息，只能通过修改配置文件中的环境选择属性，然后将修改推送到远程库，重启Config Server，这样才能切换环境</p></blockquote><h3 id="定义config版的provider服务器"><a class="markdownIt-Anchor" href="#定义config版的provider服务器"></a> 定义config版的provider服务器</h3><p>只需要三步：</p><ul><li>添加spring-cloud-starter-config依赖</li></ul><pre><code class="highlight xml"><span class="comment">&lt;!--添加spring cloud config客户端依赖--&gt;</span>       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><ul><li>删除旧的application.properties</li><li>添加bootstrap.yml文件</li></ul><pre><code class="highlight yml"><span class="attr">spring:</span>  <span class="attr">cloud:</span>    <span class="attr">config:</span>      <span class="comment">#指定configServer的地址</span>      <span class="attr">uri:</span> <span class="string">http://localhost:9999</span>      <span class="comment">#指定要访问远程库的分支</span>      <span class="attr">label:</span> <span class="string">master</span>      <span class="comment">#指定要从远程库读取的配置文件名（无需加yml扩展名，因为只能使用yml文件）</span>      <span class="attr">name:</span> <span class="string">application-provider-config</span>      <span class="comment">#选择环境</span>      <span class="attr">profile:</span> <span class="string">dev</span></code></pre><h3 id="定义config版的consumer服务器"><a class="markdownIt-Anchor" href="#定义config版的consumer服务器"></a> 定义config版的consumer服务器</h3><p>只需要三步：</p><ul><li>添加spring-cloud-starter-config依赖</li></ul><pre><code class="highlight xml"><span class="comment">&lt;!--添加spring cloud config客户端依赖--&gt;</span>       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><ul><li>删除旧的application.properties</li><li>添加bootstrap.yml文件</li></ul><pre><code class="highlight yml"><span class="attr">spring:</span>  <span class="attr">cloud:</span>    <span class="attr">config:</span>      <span class="comment">#指定configServer的地址</span>      <span class="attr">uri:</span> <span class="string">http://localhost:9999</span>      <span class="comment">#指定要访问远程库的分支</span>      <span class="attr">label:</span> <span class="string">master</span>      <span class="comment">#指定要从远程库读取的配置文件名（无需加yml扩展名，因为只能使用yml文件）</span>      <span class="attr">name:</span> <span class="string">application-consumer-config</span>      <span class="comment">#选择环境</span>      <span class="attr">profile:</span> <span class="string">dev</span></code></pre>]]>
    </content>
    <id>http://example.com/2023/08/03/Spring-Cloud/</id>
    <link href="http://example.com/2023/08/03/Spring-Cloud/"/>
    <published>2023-08-03T11:00:00.000Z</published>
    <summary>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者提供了一套简单易懂、易部署和易维护的分布式系统开发工具包。</summary>
    <title>Spring Cloud</title>
    <updated>2026-02-27T01:26:26.632Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    <category term="String-Boot" scheme="http://example.com/tags/String-Boot/"/>
    <content>
      <![CDATA[<h1 id="spring-boot"><a class="markdownIt-Anchor" href="#spring-boot"></a> Spring Boot</h1><p>[toc]</p><h2 id="spring-boot基础"><a class="markdownIt-Anchor" href="#spring-boot基础"></a> Spring Boot基础</h2><p>SSM需要做大量的配置工作，其实很多配置行为本身只是手段，并不是目的。 基于这个考虑，把该简化的简化，该省略的省略，开发人员只用关心提供业务功能就行了，这就是 SpringBoot</p><p>Spring Boot是一个基于Spring的套件，它帮我们预组装了Spring的一系列组件，以便以尽可能少的代码和配置来开发基于Spring的Java应用程序。</p><p>以汽车为例，如果我们想组装一辆汽车，我们需要发动机、传动、轮胎、底盘、外壳、座椅、内饰等各种部件，然后把它们装配起来。Spring就相当于提供了一系列这样的部件，但是要装好汽车上路，还需要我们自己动手。而Spring Boot则相当于已经帮我们预装好了一辆可以上路的汽车，如果有特殊的要求，例如把发动机从普通款换成涡轮增压款，可以通过修改配置或编写少量代码完成。</p><p>因此，Spring Boot和Spring的关系就是整车和零部件的关系，它们不是取代关系，试图跳过Spring直接学习Spring Boot是不可能的。</p><p><strong>Spring Boot的目标就是提供一个开箱即用的应用程序架构，我们基于Spring Boot的预置结构继续开发，省时省力</strong>。</p><p>换言之，SpringBoot可以简单地看成<strong>简化</strong>了的、按照<strong>约定开发</strong>的SSM(H)</p><p>快速开发框架Spring Boot</p><h3 id="创建工程运行"><a class="markdownIt-Anchor" href="#创建工程运行"></a> 创建工程/运行</h3><h4 id="创建项目"><a class="markdownIt-Anchor" href="#创建项目"></a> 创建项目</h4><h5 id="官网创建"><a class="markdownIt-Anchor" href="#官网创建"></a> 官网创建</h5><p>可以使用网站去创建一个工程，解压后放到idea的工程目录，然后添加model</p><p><a href="start.spring.io">start.spring.io</a></p><p><strong>idea添加model</strong></p><blockquote><p>idea中删除Model需要删除两次，第一次是逻辑删除，第二次才是真正的物理文件的删除</p></blockquote><h5 id="idea创建-jar"><a class="markdownIt-Anchor" href="#idea创建-jar"></a> idea创建-jar</h5><p>Create New Project -&gt; Spring Initializr</p><p>填写对应的名称参数</p><p>创建一个基础的Web项目</p><p>指定项目路径 -&gt; Finish</p><p>创建好之后，会自带一个<code>SpringbootApplication</code>类，其被<code>@SpringBootApplication</code>所标记，表示这个是一个springboot应用</p><h5 id="idea创建-war"><a class="markdownIt-Anchor" href="#idea创建-war"></a> idea创建-war</h5><p>前面创建的Spring Boot工程最终被打为了Jar包，是以可执行文件的形式出现的，其使用了Spring Boot内嵌的Tomcat作为Web服务器来运行web应用的。新版Dubbo的监控中心工程就是典型的应用。但在实际生产环境下，对于Web工程，很多时候我们需要的是war包，然后部署到企业级Web服务器中。所以，下面我们来看一下如何使用Spring Boot将工程打为war包。</p><p><strong>创建一个基于war的spring boot工程</strong></p><p><strong>war工程解析</strong></p><p>war工程比jar工程多了一个<code>ServletInitializer</code>类</p><ul><li>在该工程中我们发现其自动增加了一个类ServletInitializer，该类重写了父类的configure()方法。该方法用于完成web环境的配置，即web环境的初始化工作。</li></ul><p>打开SpringBootServletInitializer类，查看其configure()方法的注释可知，该方法已经完成了所有应用程序配置的默认设置，用户只需要写代码即可。</p><blockquote><p>翻译如下：配置应用程序。通常情况下(Normally)，所有你需要做的仅仅是添加源码，因为其它配置已经具有了合理(sensible)</p></blockquote><p>由于这是一个war包工程，将来需要部署到服务器，即在打包时无需ServletAPI。然而在编译时是需要的，所以在工程的pom文件中专门添加了<scope>provided</scope>范围的<strong>ServletAPI依赖</strong>。</p><p><strong>打包</strong><br />运行Maven的package命令，将其打为war</p><p><strong>部署</strong><br />找到该war包，将其部署到Tomcat的webapps目录中，启动Tomcat。</p><p><strong>访问</strong><br />在浏览器中可以访问到该工程。注意，由于工程是部署到了Tomcat的webapps中，不是部署到webapps/ROOT中，所以在访问时需要指定工程名。</p><h4 id="helloworld"><a class="markdownIt-Anchor" href="#helloworld"></a> helloWorld</h4><p>新写的类必须在@SpringBootApplication标记类的包或子包下面，否则扫描不到</p><p><a href="http://xn--com-k82eq06crpj.leeboer.springboot.web">新建包com.leeboer.springboot.web</a>，然后在其下新建类<strong>HelloController</strong></p><p>这个类就是Spring MVC里的一个普通的<strong>控制器</strong></p><ul><li><code>@RestController</code>使spring4里的新注解，是 <code>@ResponseBody</code>和<code>@Controller</code>的缩写</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.web;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="comment">//这个注解使spring4中的新注解，使@Controller和@ResponseBody的缩写</span><span class="meta">@RestController</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Hello Spring Boot!&quot;</span>;    &#125;&#125;</code></pre><h4 id="测试运行"><a class="markdownIt-Anchor" href="#测试运行"></a> 测试运行</h4><p>运行SpringbootApplication.java</p><p>然后访问地址</p><pre><code class="highlight plaintext">http://127.0.0.1:8080/hello</code></pre><blockquote><p>为什么不用启动tomcat了呢？<br />这是因为com.leeboer.springboot.SpringbootApplication类的主方法就把tomcat嵌进去了，不需要手动启动tomcat了</p></blockquote><blockquote><p>使用spring boot构建一个web项目就是如此简单</p></blockquote><h3 id="部署"><a class="markdownIt-Anchor" href="#部署"></a> 部署</h3><p>spring boot和之前的web应用程序不一样，其本质是一个Java应用程序</p><p>通常来说，spring boot部署会采用两种方式，全部打包为jar，或者打包为一个war</p><h4 id="idea中打包"><a class="markdownIt-Anchor" href="#idea中打包"></a> idea中打包</h4><p>双击该按钮即可打包</p><p>打包存储的路径位置：（BUILD SUCCESS表示构建成功）</p><p>然后就可以直接在cmd命令中启动该工程：</p><pre><code class="highlight plaintext">java -jar D:\LeeGit\springbootdemo\target\springbootdemo-0.0.1-SNAPSHOT.jar</code></pre><p>启动成功：</p><h4 id="jar-方式"><a class="markdownIt-Anchor" href="#jar-方式"></a> jar 方式</h4><p><strong>打包</strong></p><pre><code class="highlight plaintext">cd D:\leeGit\springbootdemomvn install</code></pre><blockquote><p>这会导致在cd D:\leeGit\springbootdemo\target目录下生成一个jar文件</p></blockquote><blockquote><p>或者也可以使用idea进行打包，详情自行百度</p></blockquote><p><strong>运行</strong><br />输入命令：</p><pre><code class="highlight plaintext">java -jar target/springboot-0.0.1-SNAPSHOT.jar</code></pre><blockquote><p>就启动这个jar了</p></blockquote><blockquote><p>通过这个方式，把jar上传到服务器并运行，就可以达到部署效果了</p></blockquote><p><strong>保持linux运行</strong></p><pre><code class="highlight plaintext">nohup java -jar xxxx.jar &amp;</code></pre><h4 id="war-方式"><a class="markdownIt-Anchor" href="#war-方式"></a> war 方式</h4><p><strong>Application</strong><br />Application修改如下代码，新加：</p><p><code>@ServletComponentScan</code>注解，并且继承<code>SpringBootServletInitializer</code></p><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer;<span class="keyword">import</span> javafx.application.Application;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;<span class="keyword">import</span> org.springframework.boot.web.servlet.ServletComponentScan;<span class="keyword">import</span> org.springframework.boot.web.support.SpringBootServletInitializer;<span class="meta">@SpringBootApplication</span><span class="meta">@ServletComponentScan</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootdemoApplication</span> <span class="keyword">extends</span> <span class="title class_">SpringBootServletInitializer</span> &#123;<span class="meta">@Override</span><span class="keyword">protected</span> SpringApplicationBuilder <span class="title function_">configure</span><span class="params">(SpringApplicationBuilder application)</span> &#123;<span class="keyword">return</span> application.sources(SpringbootdemoApplication.class);&#125;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;SpringApplication.run(SpringbootdemoApplication.class, args);&#125;&#125;</code></pre><p><strong>pom.xml</strong><br />新增打包成war的声明：</p><pre><code class="highlight plaintext">&lt;packaging&gt;war&lt;/packaging&gt;</code></pre><p>spring-boot-starter-tomcat修改为 provided方式，以避免和独立 tomcat 容器的冲突.</p><blockquote><p>表示provided 只在编译和测试的时候使用，打包的时候就没它了</p></blockquote><pre><code class="highlight xml"><span class="comment">&lt;!--这个表示springboot的内置tomcat只在测试的时候用，打包部署的时候就没有它--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><p><strong>pom.xml</strong></p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span><span class="tag">&lt;<span class="name">parent</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.21.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span><span class="tag">&lt;/<span class="name">parent</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leeboer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springbootdemo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;<span class="name">name</span>&gt;</span>springbootdemo<span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span><span class="tag">&lt;<span class="name">properties</span>&gt;</span><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!--这个表示springboot的内置tomcat只在测试的时候用，打包部署的时候就没有它--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span><span class="tag">&lt;<span class="name">build</span>&gt;</span><span class="tag">&lt;<span class="name">plugins</span>&gt;</span><span class="tag">&lt;<span class="name">plugin</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span><span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p><strong>创建war包</strong></p><pre><code class="highlight plaintext">cd D:\leeGit\springbootdemomvn clean package</code></pre><blockquote><p>这样就在target目录下生成了一个<code>springboot-0.0.1-SNAPSHOT.war</code>文件</p></blockquote><p><strong>部署</strong></p><p>如果用 <code>springboot-0.0.1-SNAPSHOT.war</code> 这个文件名部署，那么访问的时候就要在路径上加上springboot-0.0.1-SNAPSHOT。 所以把这个文件重命名为 ROOT.war</p><blockquote><p>ROOT.war　并不是指访问的时候要使用 /ROOT/hello ,而是直接使用/hello 进行访问，ROOT表示根路径</p></blockquote><p>也可以命名为lee.war，访问就要改为localhost:8080/lee/hello</p><p>然后把它放进<strong>tomcat 的webapps</strong>目录下</p><p><strong>运行</strong><br />运行tomcat下bin目录的startup.bat，然后就可以启动了，访问：</p><pre><code class="highlight plaintext">http://127.0.0.1:8080/hello</code></pre><h3 id="工程结构详解"><a class="markdownIt-Anchor" href="#工程结构详解"></a> 工程结构详解</h3><h4 id="spring-boot-pomxml详解"><a class="markdownIt-Anchor" href="#spring-boot-pomxml详解"></a> spring boot pom.xml详解</h4><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springbootdemo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>springbootdemo<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><ul><li><p>这里的pom.xml文件中没有版本号是因为在<strong>父工程中进行了选择性继承</strong></p></li><li><p>我们打开父工程：</p></li><li><p>如果要更改spring的版本号，可以直接这样修改</p></li></ul><p><strong>springboot进行了二次打包</strong></p><ul><li><p>spring boot使用该插件，对maven package打的包进行了二次打包:</p></li><li><p>二次打包后才变成可执行文件，第一次打包的文件中并没有.MF文件</p></li><li><p>jar是在original的基础上进行的二次打包</p></li></ul><h4 id="manifestmf文件"><a class="markdownIt-Anchor" href="#manifestmf文件"></a> MANIFEST.MF文件</h4><p><strong>把启动jar文件用编辑器打开：可以找到MANIFEST.MF文件</strong></p><p>在Java编译的jar文件中，一定会有一个一个META-INF目录， 这个目录下会有一些文件，其中必有一个MANIFEST.MF</p><pre><code class="highlight bash">Manifest-Version: 1.0Implementation-Title: springbootdemoImplementation-Version: 0.0.1-SNAPSHOTStart-Class: com.lee.springbootdemo.SpringbootdemoApplication   <span class="comment">#我们的springboot启动类，入口类调用了该启动类</span>Spring-Boot-Classes: BOOT-INF/classes/Spring-Boot-Lib: BOOT-INF/lib/Build-Jdk-Spec: 1.8Spring-Boot-Version: 2.1.9.RELEASECreated-By: Maven Archiver 3.4.0Main-Class: org.springframework.boot.loader.JarLauncher      <span class="comment">#定义jar文件的入口类，该类必须是一个可执行的类，一旦定义了该属性即可通过 java -jar x.jar来运行该jar文件</span></code></pre><h3 id="热部署"><a class="markdownIt-Anchor" href="#热部署"></a> 热部署</h3><p>目前的spring boot，当发生了任何修改之后，必须关闭后再启动Application类才能够生效，显得略微麻烦，spring boot提供了热部署的方式，当发现任何类发生了改变，马上通过jvm类加载的方式，加载最新的类到虚拟机当中，这样就不需要重新启动也可以看到修改后的效果</p><h4 id="eclipse"><a class="markdownIt-Anchor" href="#eclipse"></a> eclipse</h4><p>依赖</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span> <span class="comment">&lt;!-- 这个需要为 true 热部署才有效 --&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><p>插件</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></code></pre><p><strong>重启测试</strong><br />重新启动application，然后随便修改一下任意代码，就会看到控制台自动重启</p><h4 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> idea</h4><p>ldea中的SpringBoot工程若要使用热部署，需要完成两个步骤。</p><ul><li><strong>导入devtools依赖</strong>，</li><li><strong>编辑当前工程的配置信息</strong>。</li></ul><p>这两个步骤是在每一个使用热部署的Spring Boot工程中均要设置的。</p><blockquote><p>需要注意，Spring Boot工程在ldea中的热部署与Eclipse中的热部署，工程修改后的重新启动时机是不同的。Eclipse中只要修改过的文件被保存了，则工程会马上重新部署。而ldea则不同，其对文件修改后的保存是自动的，所以其重新部署的时机是ldea整个IDE窗口被钝化时，即Windows 窗口切换到其它窗口时，工程会重新部署。</p></blockquote><p><strong>导入devtools依赖</strong></p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springbootdemo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>springbootdemo<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span>        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span><span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p><strong>编辑当前工程的配置信息</strong></p><blockquote><p>默认配置下，针对/static、/public和/templates目录中的文件修改，不会自动重启，因为禁用缓存后，这些文件的修改可以实时更新。</p></blockquote><h3 id="spring-boot主配置文件"><a class="markdownIt-Anchor" href="#spring-boot主配置文件"></a> Spring boot主配置文件</h3><p>Spring Boot的主配置文件也可使用application.yml文件。yml,也可写为yaml.</p><p>在开发之初YAML的本意是Yet Another Markup Language (仍是一种标记语言)。后来为了强调这种语言是以数据为中心，而不是以标记为中心，所以将YAML解释为Yami Ain’tMarkup Language (Yaml不是一种标记语言)。 它是一种直观的能够被电脑识别的数据序列化格式，是一个可读性高并且容易被人阅读，容易和脚本语言交互，用来表达多级资源序列的编程语言。</p><p><strong>yml与properties</strong>文件的主要区别是对于多级属性，即key的显示方式不同。yml文件在输入时，只需按照点(.)的方式输出key即可，输入完毕后回车即出现了如下形式。该形式要求冒号后与值之间要有一个空格。</p><pre><code class="highlight properties"><span class="comment">#配置端口号</span><span class="attr">server.port</span>=<span class="string">8080</span><span class="comment">#配置项目访问名称，上下文路径</span><span class="attr">server.servlet.context-path</span>=<span class="string">/leeboer</span></code></pre><hr /><h4 id="端口和上下文路径"><a class="markdownIt-Anchor" href="#端口和上下文路径"></a> 端口和上下文路径</h4><p>可以通过修改application.properties，修改访问的端口号和上下文路径</p><pre><code class="highlight properties"><span class="attr">spring.mvc.view.prefix</span>=<span class="string">/WEB-INF/jsp/</span><span class="attr">spring.mvc.view.suffix</span>=<span class="string">.jsp</span><span class="comment">#更改端口号</span><span class="attr">server.port</span>=<span class="string">8888</span><span class="comment">#更改上下文路径</span><span class="comment">#新版本spring boot使用server.servlet.context-path</span><span class="attr">server.context-path</span>=<span class="string">/test</span></code></pre><h4 id="yml配置文件"><a class="markdownIt-Anchor" href="#yml配置文件"></a> yml配置文件</h4><p>yml也是配置文件的一种写法格式，于properties的区别如下图所示</p><p><strong>注意事项</strong></p><ol><li>不同“等级” 用冒号隔开</li><li>次等级的前面是空格，不能使用制表符(tab)</li><li>冒号之后如果有值，那么冒号和值之间至少有一个空格，不能紧贴着</li></ol><pre><code class="highlight yml"><span class="attr">spring:</span>    <span class="attr">mvc:</span>        <span class="attr">view:</span>            <span class="attr">prefix:</span> <span class="string">/WEB-INF/jsp/</span>            <span class="attr">suffix:</span> <span class="string">.jsp</span><span class="attr">server:</span>    <span class="attr">port:</span> <span class="number">8888</span>    <span class="attr">context-path:</span> <span class="string">/test</span></code></pre><blockquote><p>要么用application.properties 要么用 application.yml，不要都用，spring只会选择其一</p></blockquote><h3 id="actuato"><a class="markdownIt-Anchor" href="#actuato"></a> Actuato</h3><p>Actuator是Spring Boot提供的对应用系统的自省和监控的集成功能，可以对应用系统进行配置查看、相关功能统计等。在SpringCloud中主要是完成微服务的监控，完成监控治理。可以查看微服务间的数据处理和调用，当它们之间出现了异常，就可以快速定位到出现问题的地方。。</p><p>其功能与Dubbo的监控中心类似，不同的是，Dubbo的监控中心是需要专门部署的，而Spring Boot的Actuator 是存在于每一个工程中的。</p><h4 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h4><p><strong>添加依赖</strong></p><pre><code class="highlight xml"><span class="comment">&lt;!--actuator监控依赖--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><p><strong>配置application.properties</strong></p><pre><code class="highlight properties"><span class="comment">#配置端口号</span><span class="attr">server.port</span>=<span class="string">8080</span><span class="comment">#配置项目访问名称，上下文路径</span><span class="attr">server.servlet.context-path</span>=<span class="string">/leeboer</span><span class="comment"></span><span class="comment">#actuator监控端口号和上下文路径</span><span class="attr">management.server.port</span>=<span class="string">9999</span><span class="attr">management.server.servlet.context-path</span>=<span class="string">/xxx</span></code></pre><p><strong>访问该路径</strong></p><pre><code class="highlight plaintext">http://localhost:9999/xxx/actuator/health</code></pre><p><strong>自定义info信息</strong></p><pre><code class="highlight properties"><span class="comment">#配置端口号</span><span class="attr">server.port</span>=<span class="string">8080</span><span class="comment">#配置项目访问名称，上下文路径</span><span class="attr">server.servlet.context-path</span>=<span class="string">/leeboer</span><span class="comment"></span><span class="comment">#actuator监控端口号和上下文路径</span><span class="attr">management.server.port</span>=<span class="string">9999</span><span class="attr">management.server.servlet.context-path</span>=<span class="string">/xxx</span><span class="comment">#指定监控终端的基本访问路径,默认为/actuator</span><span class="attr">management.endpoints.web.base-path</span>=<span class="string">/actuator</span><span class="comment"></span><span class="comment">#自定义info信息</span><span class="attr">info.company.name</span>=<span class="string">lee</span><span class="attr">info.company.url</span>=<span class="string">www.leeboer.xyz</span><span class="attr">info.company.addr</span>=<span class="string">china beijing</span><span class="comment"></span><span class="comment">#从properties中读取信息</span><span class="attr">info.project.groupid</span>=<span class="string">@project.groupId@</span><span class="attr">info.project.artifactid</span>=<span class="string">@project.artifactId@</span><span class="attr">info.project.version</span>=<span class="string">@project.version@</span><span class="attr">info.project.name</span>=<span class="string">@project.name@</span></code></pre><p><strong>开放所有的监控终端</strong></p><pre><code class="highlight properties"><span class="comment">#actuator监控端口号和上下文路径</span><span class="attr">management.server.port</span>=<span class="string">9999</span><span class="attr">management.server.servlet.context-path</span>=<span class="string">/xxx</span><span class="comment">#指定监控终端的基本访问路径,默认为/actuator</span><span class="attr">management.endpoints.web.base-path</span>=<span class="string">/actuator</span><span class="comment">#开放所有的监控终端</span><span class="attr">management.endpoints.web.exposure.include</span>=<span class="string">*</span><span class="comment"></span><span class="comment">#关闭部分监控终端</span><span class="attr">management.endpoints.web.exposure.wxclude</span>=<span class="string">evn,beans</span></code></pre><h4 id="监控终端访问测试"><a class="markdownIt-Anchor" href="#监控终端访问测试"></a> 监控终端访问测试</h4><p><strong>mappings终端</strong><br />下面是使用mappings终端，可以看到当前工程中所有的URI与处理器的映射关系，及详细的处理器方法及其映射规则。很实用。</p><p><strong>beans终端</strong></p><p><strong>env终端</strong><br />可以看到当前应用程序运行主机的所有软硬件环境信息。</p><h4 id="常用监控终端"><a class="markdownIt-Anchor" href="#常用监控终端"></a> 常用监控终端</h4><table><thead><tr><th>id</th><th>desc</th><th>Sensitive</th></tr></thead><tbody><tr><td>auditevents</td><td>显示当前应用程序的审计事件信息</td><td>Yes</td></tr><tr><td>beans</td><td>显示应用Spring Beans的完整列表</td><td>Yes</td></tr><tr><td>caches</td><td>显示可用缓存信息</td><td>Yes</td></tr><tr><td>conditions</td><td>显示自动装配类的状态及及应用信息</td><td>Yes</td></tr><tr><td>configprops</td><td>显示所有 @ConfigurationProperties 列表</td><td>Yes</td></tr><tr><td>env</td><td>显示 ConfigurableEnvironment 中的属性</td><td>Yes</td></tr><tr><td>flyway</td><td>显示 Flyway 数据库迁移信息</td><td>Yes</td></tr><tr><td>health</td><td>显示应用的健康信息（未认证只显示status，认证显示全部信息详情）</td><td>No</td></tr><tr><td>info</td><td>显示任意的应用信息（在资源文件写info.xxx即可）</td><td>No</td></tr><tr><td>liquibase</td><td>展示Liquibase 数据库迁移</td><td>Yes</td></tr><tr><td>metrics</td><td>展示当前应用的 metrics 信息</td><td>Yes</td></tr><tr><td>mappings</td><td>显示所有 @RequestMapping 路径集列表</td><td>Yes</td></tr><tr><td>scheduledtasks</td><td>显示应用程序中的计划任务</td><td>Yes</td></tr><tr><td>sessions</td><td>允许从Spring会话支持的会话存储中检索和删除用户会话。</td><td>Yes</td></tr><tr><td>shutdown</td><td>允许应用以优雅的方式关闭（默认情况下不启用）</td><td>Yes</td></tr><tr><td>threaddump</td><td>执行一个线程dump</td><td>Yes</td></tr><tr><td>httptrace</td><td>显示HTTP跟踪信息（默认显示最后100个HTTP请求 - 响应交换）</td><td>Yes</td></tr></tbody></table><h3 id="导入spring-boot项目"><a class="markdownIt-Anchor" href="#导入spring-boot项目"></a> 导入spring boot项目</h3><p><strong>idea导入springboot项目</strong></p><p>IDEA 导入Springboot 项目办法：</p><ol><li>菜单-&gt;File-&gt;New-&gt;Project From Existing Sources</li><li>如图粘贴右上角springboot.rar 解压出来之后的目录,并选中 pom.xml</li><li>点击OK，然后后面就一路 Next 就行了</li></ol><h3 id="打包"><a class="markdownIt-Anchor" href="#打包"></a> 打包</h3><p>我们在Maven的使用插件一节中介绍了如何使用maven-shade-plugin打包一个可执行的jar包。在Spring Boot应用中，打包更加简单，因为Spring Boot自带一个更简单的spring-boot-maven-plugin插件用来打包，我们只需要在pom.xml中加入以下配置：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span>    ...    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p>无需任何配置，Spring Boot的这款插件会自动定位应用程序的入口Class，我们执行以下Maven命令即可打包：</p><pre><code class="highlight plaintext">$ mvn clean package</code></pre><p>以springboot-exec-jar项目为例，打包后我们在target目录下可以看到两个jar文件：</p><pre><code class="highlight plaintext">$ lsclassesgenerated-sourcesmaven-archivermaven-statusspringboot-exec-jar-1.0-SNAPSHOT.jarspringboot-exec-jar-1.0-SNAPSHOT.jar.original</code></pre><p>其中，springboot-exec-jar-1.0-SNAPSHOT.jar.original是Maven标准打包插件打的jar包，它只包含我们自己的Class，不包含依赖，而springboot-exec-jar-1.0-SNAPSHOT.jar是Spring Boot打包插件创建的包含依赖的jar，可以直接运行：</p><pre><code class="highlight plaintext">$ java -jar springboot-exec-jar-1.0-SNAPSHOT.jar</code></pre><p>这样，部署一个Spring Boot应用就非常简单，无需预装任何服务器，只需要上传jar包即可。</p><p>在打包的时候，因为打包后的Spring Boot应用不会被修改，因此，默认情况下，spring-boot-devtools这个依赖不会被打包进去。但是要注意，使用早期的Spring Boot版本时，需要配置一下才能排除spring-boot-devtools这个依赖：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>        <span class="tag">&lt;<span class="name">excludeDevtools</span>&gt;</span>true<span class="tag">&lt;/<span class="name">excludeDevtools</span>&gt;</span>    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></code></pre><p>如果不喜欢默认的项目名+版本号作为文件名，可以加一个配置指定文件名：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span>    ...    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>awesome-app<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span>        ...    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p>这样打包后的文件名就是awesome-app.jar</p><h3 id="瘦身spring-boot"><a class="markdownIt-Anchor" href="#瘦身spring-boot"></a> 瘦身Spring Boot</h3><p>在上一节中，我们使用Spring Boot提供的spring-boot-maven-plugin打包Spring Boot应用，可以直接获得一个完整的可运行的jar包，把它上传到服务器上再运行就极其方便。</p><p>但是这种方式也不是没有缺点。最大的缺点就是包太大了，动不动几十MB，在网速不给力的情况下，上传服务器非常耗时。并且，其中我们引用到的Tomcat、Spring和其他第三方组件，只要版本号不变，这些jar就相当于每次都重复打进去，再重复上传了一遍。</p><p>真正经常改动的代码其实是我们自己编写的代码。如果只打包我们自己编写的代码，通常jar包也就几百KB。但是，运行的时候，classpath中没有依赖的jar包，肯定会报错。</p><p>所以问题来了：如何只打包我们自己编写的代码，同时又自动把依赖包下载到某处，并自动引入到classpath中。解决方案就是使用<strong>spring-boot-thin-launcher</strong>。</p><h4 id="使用spring-boot-thin-launcher"><a class="markdownIt-Anchor" href="#使用spring-boot-thin-launcher"></a> 使用spring-boot-thin-launcher</h4><p>我们先演示如何使用spring-boot-thin-launcher，再详细讨论它的工作原理。首先复制一份上一节的Maven项目，并重命名为springboot-thin-jar：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span>    ...    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-thin-jar<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    ...</code></pre><p>然后，修改<build>-<plugins>-<plugin>，给原来的spring-boot-maven-plugin增加一个<dependency>如下：</p><pre><code class="highlight java">&lt;project ...&gt;    ...    &lt;build&gt;        &lt;finalName&gt;awesome-app&lt;/finalName&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;dependencies&gt;                    &lt;dependency&gt;                        &lt;groupId&gt;org.springframework.boot.experimental&lt;/groupId&gt;                        &lt;artifactId&gt;spring-boot-thin-layout&lt;/artifactId&gt;                        &lt;version&gt;<span class="number">1.0</span><span class="number">.27</span>.RELEASE&lt;/version&gt;                    &lt;/dependency&gt;                &lt;/dependencies&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>不需要任何其他改动了，我们直接按正常的流程打包，执行mvn clean package，观察target目录最终生成的可执行awesome-app.jar，只有79KB左右。</p><p>直接运行java -jar awesome-app.jar，效果和上一节完全一样。显然，79KB的jar肯定无法放下Tomcat和Spring这样的大块头。那么，运行时这个awesome-app.jar又是怎么找到它自己依赖的jar包呢？</p><p>实际上spring-boot-thin-launcher这个插件改变了spring-boot-maven-plugin的默认行为。它输出的jar包只包含我们自己代码编译后的class，一个很小的ThinJarWrapper，以及解析pom.xml后得到的所有依赖jar的列表。</p><p>运行的时候，入口实际上是ThinJarWrapper，它会先在指定目录搜索看看依赖的jar包是否都存在，如果不存在，先从Maven中央仓库下载到本地，然后，再执行我们自己编写的main()入口方法。这种方式有点类似很多在线安装程序：用户下载后得到的是一个很小的exe安装程序，执行安装程序时，会首先在线下载所需的若干巨大的文件，再进行真正的安装。</p><p>这个spring-boot-thin-launcher在启动时搜索的默认目录是用户主目录的.m2，我们也可以指定下载目录，例如，将下载目录指定为当前目录：</p><pre><code class="highlight plaintext">$ java -Dthin.root=. -jar awesome-app.jar</code></pre><p>上述命令通过环境变量thin.root传入当前目录，执行后发现当前目录下自动生成了一个repository目录，这和Maven的默认下载目录~/.m2/repository的结构是完全一样的，只是它仅包含awesome-app.jar所需的运行期依赖项。</p><blockquote><p>注意：只有首次运行时会自动下载依赖项，再次运行时由于无需下载，所以启动速度会大大加快。如果删除了repository目录，再次运行时就会再次触发下载。</p></blockquote><p>把79KB大小的awesome-app.jar直接扔到服务器执行，上传过程就非常快。但是，第一次在服务器上运行awesome-app.jar时，仍需要从Maven中央仓库下载大量的jar包，所以，spring-boot-thin-launcher还提供了一个dryrun选项，专门用来下载依赖项而不执行实际代码：</p><pre><code class="highlight plaintext">java -Dthin.dryrun=true -Dthin.root=. -jar awesome-app.jar</code></pre><p>执行上述代码会在当前目录创建repository目录，并下载所有依赖项，但并不会运行我们编写的main()方法。此过程称之为“预热”（warm up）。</p><p>如果服务器由于安全限制不允许从外网下载文件，那么可以在本地预热，然后把awesome-app.jar和repository目录上传到服务器。只要依赖项没有变化，后续改动只需要上传awesome-app.jar即可。</p><h2 id="spring-boot重要用法"><a class="markdownIt-Anchor" href="#spring-boot重要用法"></a> Spring boot重要用法</h2><h3 id="自定义异常页面"><a class="markdownIt-Anchor" href="#自定义异常页面"></a> 自定义异常页面</h3><h4 id="简单的替换异常页面"><a class="markdownIt-Anchor" href="#简单的替换异常页面"></a> 简单的替换异常页面</h4><p>我们可以使用简单的方式自定义异常页面，并将默认状态页面进行替换</p><p>在<code>resources</code>目录下新建<code>public.error</code>包</p><ul><li>编写404.html/500.html即可</li></ul><blockquote><p>在error目录中定义异常页面。这些异常页面的名称必须为相应的状态码，扩展名为html。</p></blockquote><h4 id="自定义编写抛错逻辑"><a class="markdownIt-Anchor" href="#自定义编写抛错逻辑"></a> 自定义编写抛错逻辑</h4><h5 id="增加抛错"><a class="markdownIt-Anchor" href="#增加抛错"></a> 增加抛错</h5><p>修改HelloController，使得访问你/hello一定会产生异常</p><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.web;<span class="keyword">import</span> org.springframework.stereotype.Controller;<span class="keyword">import</span> org.springframework.ui.Model;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;<span class="keyword">import</span> java.text.DateFormat;<span class="keyword">import</span> java.util.Date;<span class="comment">//这个注解使spring4中的新注解，使@Controller和@ResponseBody的缩写</span><span class="comment">//@RestController</span><span class="comment">//修改RestController为controller</span><span class="comment">//这时返回的“hello”就不是字符串，而是根据application.properties中的视图重定向，在WEB-IND/jsp中去寻找hello.jsp文件</span><span class="meta">@Controller</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(Model m)</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//ModelAndView类中包含了Model和View，在这里只使用Model,返回字符串，让框架去寻址</span>        m.addAttribute(<span class="string">&quot;now&quot;</span>, DateFormat.getDateTimeInstance().format(<span class="keyword">new</span> <span class="title class_">Date</span>()));        <span class="comment">//故意抛错，验证错误处理        </span>        <span class="keyword">if</span>(<span class="literal">true</span>)&#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;some exception&quot;</span>);        &#125;        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;    &#125;&#125;</code></pre><h5 id="globalexceptionhandler"><a class="markdownIt-Anchor" href="#globalexceptionhandler"></a> GlobalExceptionHandler</h5><p>新怎加一个类<code>GlobalExceptionHandler</code>，用于捕捉Exception异常以及其子类</p><p>捕捉到异常后，把异常信息，发出异常的地址放进ModelAndView里，然后跳转到errorPage.jsp</p><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.exception;<span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;<span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;<span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;<span class="keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="meta">@ControllerAdvice</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;    <span class="meta">@ExceptionHandler(value = Exception.class)</span>    <span class="keyword">public</span> ModelAndView <span class="title function_">defaultErrorHandler</span><span class="params">(HttpServletRequest req, Exception e)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();        mav.addObject(<span class="string">&quot;exception&quot;</span>, e);        mav.addObject(<span class="string">&quot;url&quot;</span>, req.getRequestURL());        mav.setViewName(<span class="string">&quot;errorPage&quot;</span>);        <span class="keyword">return</span> mav;    &#125;&#125;</code></pre><p><strong>@ControllerAdvice</strong>是Spring 3.2新增的注解，作用<strong>控制器增强</strong>，主要是用来Controller的一些公共的需求的低侵入性增强提供辅助，作用于<code>@RequestMapping</code>标注的方法上</p><ol><li><strong>@ExceptionHandler</strong>   自定义的错误处理器</li><li><strong>@ModelAttribute</strong>      全局的对所有的controller的Model添加属性</li><li><strong>@InitBinder</strong>  对表单数据绑定</li></ol><p>所以结合上面我们可以知道,使用@ExceptionHandler，可以处理异常, 但是仅限于当前Controller中处理异常, @ControllerAdvice可以配置basePackage下的所有controller. 所以结合两者使用,就可以处理全局的异常了</p><p>自定义异常类</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomGenericException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;    <span class="keyword">private</span> String errCode;    <span class="keyword">private</span> String errMsg;    <span class="keyword">public</span> String <span class="title function_">getErrCode</span><span class="params">()</span> &#123;        <span class="keyword">return</span> errCode;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setErrCode</span><span class="params">(String errCode)</span> &#123;        <span class="built_in">this</span>.errCode = errCode;    &#125;    <span class="keyword">public</span> String <span class="title function_">getErrMsg</span><span class="params">()</span> &#123;        <span class="keyword">return</span> errMsg;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setErrMsg</span><span class="params">(String errMsg)</span> &#123;        <span class="built_in">this</span>.errMsg = errMsg;    &#125;    <span class="keyword">public</span> <span class="title function_">CustomGenericException</span><span class="params">(String errCode, String errMsg)</span> &#123;        <span class="built_in">this</span>.errCode = errCode;        <span class="built_in">this</span>.errMsg = errMsg;    &#125;&#125;</code></pre><p>使用示例</p><pre><code class="highlight java"><span class="meta">@ControllerAdvice</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionsHandler</span> &#123;    <span class="meta">@ExceptionHandler(CustomGenericException.class)</span><span class="comment">//可以直接写@ExceptionHandler,不指明异常类，会自动映射</span>    <span class="keyword">public</span> ModelAndView <span class="title function_">customGenericExceptionHnadler</span><span class="params">(CustomGenericException exception)</span>&#123; <span class="comment">//还可以声明接收其他任意参数</span>        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;generic_error&quot;</span>);        modelAndView.addObject(<span class="string">&quot;errCode&quot;</span>,exception.getErrCode());        modelAndView.addObject(<span class="string">&quot;errMsg&quot;</span>,exception.getErrMsg());        <span class="keyword">return</span> modelAndView;    &#125;    <span class="comment">//可以通过ResponseStatus配置返回的状态码</span>    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span>    <span class="meta">@ExceptionHandler(Exception.class)</span><span class="comment">//可以直接写@EceptionHandler，IOExeption继承于Exception</span>    <span class="keyword">public</span> ModelAndView <span class="title function_">allExceptionHandler</span><span class="params">(Exception exception)</span>&#123;        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;generic_error&quot;</span>);        modelAndView.addObject(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;this is Exception.class&quot;</span>);        <span class="keyword">return</span> modelAndView;    &#125;&#125;</code></pre><blockquote><p>此时<code>ExceptionsHandler</code>类就会捕获Controller中的所有异常</p></blockquote><h5 id="errorpagejsp"><a class="markdownIt-Anchor" href="#errorpagejsp"></a> errorPage.jsp</h5><pre><code class="highlight xml">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:500px;border:1px solid lightgray;margin:200px auto;padding:80px&quot;</span>&gt;</span> 系统 出现了异常，异常原因是：    $&#123;exception&#125;    <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span>    出现异常的地址是：    $&#123;url&#125;    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><h5 id="重启测试"><a class="markdownIt-Anchor" href="#重启测试"></a> 重启测试</h5><pre><code class="highlight plaintext">http://127.0.0.1:8080/hello</code></pre><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><p><strong>添加依赖</strong></p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><p><strong>定义测试类</strong></p><ul><li><code>@RunWith(SpringRunner.class)</code></li><li><code>@SpringBootTest(classes=SpringbootdemoApplication.class)</code></li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.springbootdemo;<span class="keyword">import</span> org.junit.Test;<span class="keyword">import</span> org.junit.runner.RunWith;<span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<span class="meta">@RunWith(SpringRunner.class)</span><span class="meta">@SpringBootTest(classes=SpringbootdemoApplication.class)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootdemoApplicationTests</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> ISomeService service;        <span class="meta">@Test</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;        service.doSome();    &#125;&#125;</code></pre><h3 id="多环境选择"><a class="markdownIt-Anchor" href="#多环境选择"></a> 多环境选择</h3><p>在开发应用时，通常同一套程序会被运行在多个不同的环境，例如，开发、测试、生产环境等。每个环境的数据库地址、服务器端口号等配置都会不同。若在不同环境下运行时将配置文件修改为不同内容，那么，这种做法不仅非常繁琐，而且很容易发生错误。</p><p>在开发应用时，有时不同的环境，其需要运行的接口的实现类也是不同的。例如，若要开发一个具有短信发送功能的应用，开发环境中要执行的send()方法仅需调用短信模拟器即可，而生产环境中要执行的send()则需要调用短信运营商所提供的短信发送接口。这种情况下，就需要开发两个相关接口的实现类去实现send()方法。</p><p>对于不同的环境，需要使用不同的配置文件，执行不同的类。而<strong>这个选择只需在SpringBoot的主配置文件中指定即可</strong>。</p><p>下面以不同的环境“使用配置有不同的端口号的配置文件，及调用不同接口实现类”为例来演示多环境选择问题的解决</p><p>有时候在本地测试使用8080端口，可是上线使用的又是80端口，此时就可以通过多配置文件实现多配置支持的灵活切换</p><h4 id="多配置文件"><a class="markdownIt-Anchor" href="#多配置文件"></a> 多配置文件</h4><p><strong>3个配置文件：</strong></p><p>核心配置文件：<code>application.properties</code><br />开发环境用的配置文件：<code>application-dev.properties</code><br />生产环境用的配置文件：<code>application-pro.properties</code></p><p><strong>通过spring.profiles.active 灵活地来切换使用环境</strong></p><ul><li>该命令指定即为运行和编译要使用的配置文件</li><li>填写的值为其他application-之后，后缀名之前的简写名</li></ul><hr /><ul><li>application.properties</li></ul><pre><code class="highlight properties"><span class="attr">spring.profiles.active</span>=<span class="string">pro</span><span class="attr">spring.mvc.view.prefix</span>=<span class="string">/WEB-INF/jsp/</span><span class="attr">spring.mvc.view.suffix</span>=<span class="string">.jsp</span></code></pre><ul><li>application-dev.properties</li></ul><pre><code class="highlight properties"><span class="comment">#开发环境</span><span class="attr">server.port</span>=<span class="string">8088</span><span class="attr">server.context-path</span>=<span class="string">/test</span></code></pre><ul><li>application-pro.properties</li></ul><pre><code class="highlight properties"><span class="comment">#生产环境</span><span class="attr">server.port</span>=<span class="string">80</span><span class="attr">server.context-path</span>=<span class="string">/</span></code></pre><p>@<strong>Profile</strong>注释</p><ul><li>该注释可以标记在类上或方法上</li><li>即标记在哪个配置文件环境下生效</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MsgService</span>&#123;    String <span class="title function_">send</span><span class="params">()</span>;&#125;</code></pre><pre><code class="highlight java"><span class="meta">@Service</span><span class="meta">@Profile(&quot;dev&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DevMsgServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MsgService</span>&#123;    String <span class="title function_">send</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="string">&quot;dev&quot;</span>;    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="meta">@Service</span><span class="meta">@Profile(&quot;pro&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProMsgServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MsgService</span>&#123;    String <span class="title function_">send</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="string">&quot;pro&quot;</span>;    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="meta">@RestController</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgController</span>&#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> MsgService service;        <span class="meta">@GitMapping(&quot;/send&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">sendHandler</span><span class="params">()</span>&#123;        <span class="keyword">return</span> service.send();    &#125;&#125;</code></pre><h4 id="部署-2"><a class="markdownIt-Anchor" href="#部署-2"></a> 部署</h4><p>不仅可以通过修改application.properties文件进行切换，还可以在部署环境下，指定不同的参数来确保生产环境总是使用的希望的那套配置</p><p>构建</p><pre><code class="highlight plaintext">cd C:\Users\X7TI\Downloads\springbootmvn install</code></pre><p>运行</p><pre><code class="highlight plaintext">java -jar target/springboot-0.0.1-SNAPSHOT.jar --spring.profiles.active=pro</code></pre><pre><code class="highlight plaintext">java -jar target/springboot-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev</code></pre><blockquote><p>这样就可以保证在开发环境总是用的8080端口，而到了生产环境总是用的80端口，免去了每次上线还要修改端口号的麻烦</p></blockquote><h3 id="禁用自动配置"><a class="markdownIt-Anchor" href="#禁用自动配置"></a> 禁用自动配置</h3><p>Spring Boot大量使用自动配置和默认配置，极大地减少了代码，通常只需要加上几个注解，并按照默认规则设定一下必要的配置即可。例如，配置JDBC，默认情况下，只需要配置一个spring.datasource：</p><pre><code class="highlight plaintext">spring:  datasource:    url: jdbc:hsqldb:file:testdb    username: sa    password:    dirver-class-name: org.hsqldb.jdbc.JDBCDriver</code></pre><p>Spring Boot就会自动创建出DataSource、JdbcTemplate、DataSourceTransactionManager，非常方便。</p><p>但是，有时候，我们又必须要禁用某些自动配置。例如，系统有主从两个数据库，而Spring Boot的自动配置只能配一个，怎么办？</p><p>这个时候，针对DataSource相关的自动配置，就必须关掉。我们需要用exclude指定需要关掉的自动配置：</p><pre><code class="highlight java"><span class="meta">@SpringBootApplication</span><span class="comment">// 启动自动配置，但排除指定的自动配置:</span><span class="meta">@EnableAutoConfiguration(exclude = DataSourceAutoConfiguration.class)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;    ...&#125;</code></pre><p>现在，Spring Boot不再给我们自动创建DataSource、JdbcTemplate和DataSourceTransactionManager了，要实现主从数据库支持，怎么办？</p><p>让我们一步一步开始编写支持主从数据库的功能。首先，我们需要把主从数据库配置写到application.yml中，仍然按照Spring Boot默认的格式写，但datasource改为datasource-master和datasource-slave：</p><pre><code class="highlight yml"><span class="attr">spring:</span>  <span class="attr">datasource-master:</span>    <span class="attr">url:</span> <span class="string">jdbc:hsqldb:file:testdb</span>    <span class="attr">username:</span> <span class="string">sa</span>    <span class="attr">password:</span>    <span class="attr">dirver-class-name:</span> <span class="string">org.hsqldb.jdbc.JDBCDriver</span>  <span class="attr">datasource-slave:</span>    <span class="attr">url:</span> <span class="string">jdbc:hsqldb:file:testdb</span>    <span class="attr">username:</span> <span class="string">sa</span>    <span class="attr">password:</span>    <span class="attr">dirver-class-name:</span> <span class="string">org.hsqldb.jdbc.JDBCDriver</span></code></pre><p>注意到两个数据库实际上是同一个库。如果使用MySQL，可以创建一个只读用户，作为datasource-slave的用户来模拟一个从库。</p><p>下一步，我们分别创建两个HikariCP的DataSource：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MasterDataSourceConfiguration</span> &#123;    <span class="meta">@Bean(&quot;masterDataSourceProperties&quot;)</span>    <span class="meta">@ConfigurationProperties(&quot;spring.datasource-master&quot;)</span>    DataSourceProperties <span class="title function_">dataSourceProperties</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProperties</span>();    &#125;    <span class="meta">@Bean(&quot;masterDataSource&quot;)</span>    DataSource <span class="title function_">dataSource</span><span class="params">(<span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;masterDataSourceProperties&quot;)</span> DataSourceProperties props)</span> &#123;        <span class="keyword">return</span> props.initializeDataSourceBuilder().build();    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlaveDataSourceConfiguration</span> &#123;    <span class="meta">@Bean(&quot;slaveDataSourceProperties&quot;)</span>    <span class="meta">@ConfigurationProperties(&quot;spring.datasource-slave&quot;)</span>    DataSourceProperties <span class="title function_">dataSourceProperties</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProperties</span>();    &#125;    <span class="meta">@Bean(&quot;slaveDataSource&quot;)</span>    DataSource <span class="title function_">dataSource</span><span class="params">(<span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;slaveDataSourceProperties&quot;)</span> DataSourceProperties props)</span> &#123;        <span class="keyword">return</span> props.initializeDataSourceBuilder().build();    &#125;&#125;</code></pre><p>注意到上述class并未添加@Configuration和@Component，要使之生效，可以使用@Import导入：</p><pre><code class="highlight java"><span class="meta">@SpringBootApplication</span><span class="meta">@EnableAutoConfiguration(exclude = DataSourceAutoConfiguration.class)</span><span class="meta">@Import(&#123; MasterDataSourceConfiguration.class, SlaveDataSourceConfiguration.class&#125;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;    ...&#125;</code></pre><p>此外，上述两个DataSource的Bean名称分别为masterDataSource和slaveDataSource，我们还需要一个最终的@Primary标注的DataSource，它采用Spring提供的AbstractRoutingDataSource，代码实现如下：</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">RoutingDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">protected</span> Object <span class="title function_">determineCurrentLookupKey</span><span class="params">()</span> &#123;        <span class="comment">// 从ThreadLocal中取出key:</span>        <span class="keyword">return</span> RoutingDataSourceContext.getDataSourceRoutingKey();    &#125;&#125;</code></pre><p>RoutingDataSource本身并不是真正的DataSource，它通过Map关联一组DataSource，下面的代码创建了包含两个DataSource的RoutingDataSource，关联的key分别为masterDataSource和slaveDataSource：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoutingDataSourceConfiguration</span> &#123;    <span class="meta">@Primary</span>    <span class="meta">@Bean</span>    DataSource <span class="title function_">dataSource</span><span class="params">(</span><span class="params">            <span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;masterDataSource&quot;)</span> DataSource masterDataSource,</span><span class="params">            <span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;slaveDataSource&quot;)</span> DataSource slaveDataSource)</span> &#123;        <span class="type">var</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoutingDataSource</span>();        <span class="comment">// 关联两个DataSource:</span>        ds.setTargetDataSources(Map.of(                <span class="string">&quot;masterDataSource&quot;</span>, masterDataSource,                <span class="string">&quot;slaveDataSource&quot;</span>, slaveDataSource));        <span class="comment">// 默认使用masterDataSource:</span>        ds.setDefaultTargetDataSource(masterDataSource);        <span class="keyword">return</span> ds;    &#125;    <span class="meta">@Bean</span>    JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);    &#125;    <span class="meta">@Bean</span>    DataSourceTransactionManager <span class="title function_">dataSourceTransactionManager</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);    &#125;&#125;</code></pre><p>仍然需要自己创建JdbcTemplate和PlatformTransactionManager，注入的是标记为@Primary的RoutingDataSource。这样，我们通过如下的代码就可以切换RoutingDataSource底层使用的真正的DataSource：</p><pre><code class="highlight java">RoutingDataSourceContext.setDataSourceRoutingKey(<span class="string">&quot;slaveDataSource&quot;</span>);jdbcTemplate.query(...);</code></pre><p>只不过写代码切换DataSource即麻烦又容易出错，更好的方式是通过注解配合AOP实现自动切换，这样，客户端代码实现如下：</p><pre><code class="highlight java"><span class="meta">@Controllerpublic</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;        <span class="meta">@RoutingWithSlave</span> <span class="comment">// &lt;-- 指示在此方法中使用slave数据库</span>        <span class="meta">@GetMapping(&quot;/profile&quot;)</span>        <span class="keyword">public</span> ModelAndView <span class="title function_">profile</span><span class="params">(HttpSession session)</span> &#123;        ...    &#125;&#125;</code></pre><p>实现上述功能需要编写一个@RoutingWithSlave注解，一个AOP织入和一个ThreadLocal来保存key。由于代码比较简单，这里我们不再详述。</p><p>如果我们想要确认是否真的切换了DataSource，可以覆写determineTargetDataSource()方法并打印出DataSource的名称：</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">RoutingDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> &#123;    ...    <span class="meta">@Override</span>    <span class="keyword">protected</span> DataSource <span class="title function_">determineTargetDataSource</span><span class="params">()</span> &#123;        <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="built_in">super</span>.determineTargetDataSource();        logger.info(<span class="string">&quot;determin target datasource: &#123;&#125;&quot;</span>, ds);        <span class="keyword">return</span> ds;    &#125;&#125;</code></pre><p>访问不同的URL，可以在日志中看到两个DataSource，分别是HikariPool-1和hikariPool-2：</p><pre><code class="highlight plaintext">2020-06-14 17:55:21.676  INFO 91561 --- [nio-8080-exec-7] c.i.learnjava.config.RoutingDataSource   : determin target datasource: HikariDataSource (HikariPool-1)2020-06-14 17:57:08.992  INFO 91561 --- [io-8080-exec-10] c.i.learnjava.config.RoutingDataSource   : determin target datasource: HikariDataSource (HikariPool-2)</code></pre><p>我们用一个图来表示创建的DataSource以及相关Bean的关系：</p><p>注意到DataSourceTransactionManager和JdbcTemplate引用的都是RoutingDataSource，所以，这种设计的一个限制就是：在一个请求中，一旦切换了内部数据源，在同一个事务中，不能再切到另一个，否则，DataSourceTransactionManager和JdbcTemplate操作的就不是同一个数据库连接。</p><h3 id="使用profiles"><a class="markdownIt-Anchor" href="#使用profiles"></a> 使用Profiles</h3><p>Profile本身是Spring提供的功能，我们在使用条件装配中已经讲到了，Profile表示一个环境的概念，如开发、测试和生产这3个环境：</p><ul><li>native</li><li>test</li><li>production</li></ul><p>或者按git分支定义master、dev这些环境：</p><ul><li>master</li><li>dev在启动一个Spring应用程序的时候，可以传入一个或多个环境，例如：</li></ul><pre><code class="highlight plaintext">-Dspring.profiles.active=test,master</code></pre><p>大多数情况下，使用一个环境就足够了。</p><p>Spring Boot对Profiles的支持在于，可以在application.yml中为每个环境进行配置。下面是一个示例配置：</p><pre><code class="highlight yml"><span class="attr">spring:</span>  <span class="attr">application:</span>    <span class="attr">name:</span> <span class="string">$&#123;APP_NAME:unnamed&#125;</span>  <span class="attr">datasource:</span>    <span class="attr">url:</span> <span class="string">jdbc:hsqldb:file:testdb</span>    <span class="attr">username:</span> <span class="string">sa</span>    <span class="attr">password:</span>    <span class="attr">dirver-class-name:</span> <span class="string">org.hsqldb.jdbc.JDBCDriver</span>    <span class="attr">hikari:</span>      <span class="attr">auto-commit:</span> <span class="literal">false</span>      <span class="attr">connection-timeout:</span> <span class="number">3000</span>      <span class="attr">validation-timeout:</span> <span class="number">3000</span>      <span class="attr">max-lifetime:</span> <span class="number">60000</span>      <span class="attr">maximum-pool-size:</span> <span class="number">20</span>      <span class="attr">minimum-idle:</span> <span class="number">1</span><span class="attr">pebble:</span>  <span class="attr">suffix:</span>  <span class="attr">cache:</span> <span class="literal">false</span><span class="attr">server:</span>  <span class="attr">port:</span> <span class="string">$&#123;APP_PORT:8080&#125;</span><span class="meta">---</span><span class="meta"></span><span class="attr">spring:</span>  <span class="attr">config:</span>    <span class="attr">activate:</span>      <span class="attr">on-profile:</span> <span class="string">test</span><span class="attr">server:</span>  <span class="attr">port:</span> <span class="number">8000</span><span class="meta">---</span><span class="meta"></span><span class="attr">spring:</span>  <span class="attr">config:</span>    <span class="attr">activate:</span>      <span class="attr">on-profile:</span> <span class="string">production</span><span class="attr">server:</span>  <span class="attr">port:</span> <span class="number">80</span><span class="attr">pebble:</span>  <span class="attr">cache:</span> <span class="literal">true</span></code></pre><p>注意到分隔符—，最前面的配置是默认配置，不需要指定Profile，后面的每段配置都必须以spring.config.activate.on-profile.profiles: xxx开头，表示一个Profile。上述配置默认使用8080端口，但是在test环境下，使用8000端口，在production环境下，使用80端口，并且启用Pebble的缓存。</p><p>如果我们不指定任何Profile，直接启动应用程序，那么Profile实际上就是default，可以从Spring Boot启动日志看出：</p><pre><code class="highlight plaintext">...2022-11-25T11:10:34.006+08:00  INFO 13537 --- [           main] com.itranswarp.learnjava.Application     : No active profile set, falling back to 1 default profile: &quot;default&quot;</code></pre><p>上述日志显示未设置Profile，使用默认的Profile为default。</p><p>要以test环境启动，可输入如下命令：</p><pre><code class="highlight plaintext">$ java -Dspring.profiles.active=test -jar springboot-profiles-1.0-SNAPSHOT.jar...2022-11-25T11:09:02.946+08:00  INFO 13510 --- [           main] com.itranswarp.learnjava.Application     : The following 1 profile is active: &quot;test&quot;...2022-11-25T11:09:05.124+08:00  INFO 13510 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8000 (http) with context path &#x27;&#x27;...</code></pre><p>从日志看到活动的Profile是test，Tomcat的监听端口是8000。</p><p>通过Profile可以实现一套代码在不同环境启用不同的配置和功能。假设我们需要一个存储服务，在本地开发时，直接使用文件存储即可，但是，在测试和生产环境，需要存储到云端如S3上，如何通过Profile实现该功能？</p><p>首先，我们要定义存储接口StorageService：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StorageService</span> &#123;    <span class="comment">// 根据URI打开InputStream:</span>    InputStream <span class="title function_">openInputStream</span><span class="params">(String uri)</span> <span class="keyword">throws</span> IOException;    <span class="comment">// 根据扩展名+InputStream保存并返回URI:</span>    String <span class="title function_">store</span><span class="params">(String extName, InputStream input)</span> <span class="keyword">throws</span> IOException;&#125;</code></pre><p>本地存储可通过LocalStorageService实现：</p><pre><code class="highlight java"><span class="meta">@Component</span><span class="meta">@Profile(&quot;default&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalStorageService</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;    <span class="meta">@Value(&quot;$&#123;storage.local:/var/static&#125;&quot;)</span>    String localStorageRootDir;    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());    <span class="keyword">private</span> File localStorageRoot;    <span class="meta">@PostConstruct</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;        logger.info(<span class="string">&quot;Intializing local storage with root dir: &#123;&#125;&quot;</span>, <span class="built_in">this</span>.localStorageRootDir);        <span class="built_in">this</span>.localStorageRoot = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="built_in">this</span>.localStorageRootDir);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> InputStream <span class="title function_">openInputStream</span><span class="params">(String uri)</span> <span class="keyword">throws</span> IOException &#123;        <span class="type">File</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="built_in">this</span>.localStorageRoot, uri);        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(targetFile));    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">store</span><span class="params">(String extName, InputStream input)</span> <span class="keyword">throws</span> IOException &#123;        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + <span class="string">&quot;.&quot;</span> + extName;        <span class="type">File</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="built_in">this</span>.localStorageRoot, fileName);        <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(targetFile))) &#123;            input.transferTo(output);        &#125;        <span class="keyword">return</span> fileName;    &#125;&#125;</code></pre><p>而云端存储可通过CloudStorageService实现：</p><pre><code class="highlight java"><span class="meta">@Component</span><span class="meta">@Profile(&quot;!default&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloudStorageService</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;    <span class="meta">@Value(&quot;$&#123;storage.cloud.bucket:&#125;&quot;)</span>    String bucket;    <span class="meta">@Value(&quot;$&#123;storage.cloud.access-key:&#125;&quot;)</span>    String accessKey;    <span class="meta">@Value(&quot;$&#123;storage.cloud.access-secret:&#125;&quot;)</span>    String accessSecret;    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());    <span class="meta">@PostConstruct</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;        <span class="comment">// <span class="doctag">TODO:</span></span>        logger.info(<span class="string">&quot;Initializing cloud storage...&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> InputStream <span class="title function_">openInputStream</span><span class="params">(String uri)</span> <span class="keyword">throws</span> IOException &#123;        <span class="comment">// <span class="doctag">TODO:</span></span>        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;File not found: &quot;</span> + uri);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">store</span><span class="params">(String extName, InputStream input)</span> <span class="keyword">throws</span> IOException &#123;        <span class="comment">// <span class="doctag">TODO:</span></span>        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Unable to access cloud storage.&quot;</span>);    &#125;&#125;</code></pre><p>注意到LocalStorageService使用了条件装配@Profile(“default”)，即默认启用LocalStorageService，而CloudStorageService使用了条件装配@Profile(“!default”)，即非default环境时，自动启用CloudStorageService。这样，一套代码，就实现了不同环境启用不同的配置。</p><h3 id="使用conditional"><a class="markdownIt-Anchor" href="#使用conditional"></a> 使用Conditional</h3><p>使用Profile能根据不同的Profile进行条件装配，但是Profile控制比较糙，如果想要精细控制，例如，配置本地存储，AWS存储和阿里云存储，将来很可能会增加Azure存储等，用Profile就很难实现。</p><p>Spring本身提供了条件装配@Conditional，但是要自己编写比较复杂的Condition来做判断，比较麻烦。Spring Boot则为我们准备好了几个非常有用的条件：</p><ul><li>@ConditionalOnProperty：如果有指定的配置，条件生效；</li><li>@ConditionalOnBean：如果有指定的Bean，条件生效；</li><li>@ConditionalOnMissingBean：如果没有指定的Bean，条件生效；</li><li>@ConditionalOnMissingClass：如果没有指定的Class，条件生效；</li><li>@ConditionalOnWebApplication：在Web环境中条件生效；</li><li>@ConditionalOnExpression：根据表达式判断条件是否生效。</li></ul><p>我们以最常用的@ConditionalOnProperty为例，把上一节的StorageService改写如下。首先，定义配置storage.type=xxx，用来判断条件，默认为local：</p><pre><code class="highlight plaintext">storage:  type: $&#123;STORAGE_TYPE:local&#125;</code></pre><p>设定为local时，启用LocalStorageService：</p><pre><code class="highlight java"><span class="meta">@Component</span><span class="meta">@ConditionalOnProperty(value = &quot;storage.type&quot;, havingValue = &quot;local&quot;, matchIfMissing = true)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalStorageService</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;    ...&#125;</code></pre><p>设定为aws时，启用AwsStorageService：</p><pre><code class="highlight java"><span class="meta">@Component</span><span class="meta">@ConditionalOnProperty(value = &quot;storage.type&quot;, havingValue = &quot;aws&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AwsStorageService</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;    ...&#125;</code></pre><p>设定为aliyun时，启用AliyunStorageService：</p><pre><code class="highlight java"><span class="meta">@Component</span><span class="meta">@ConditionalOnProperty(value = &quot;storage.type&quot;, havingValue = &quot;aliyun&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliyunStorageService</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;    ...&#125;</code></pre><p>注意到LocalStorageService的注解，当指定配置为local，或者配置不存在，均启用LocalStorageService。</p><h3 id="lombok"><a class="markdownIt-Anchor" href="#lombok"></a> Lombok</h3><p>lombok是一个自动生成getter/setter/toString等方法的一个idea插件</p><p><strong>lombok插件安装</strong></p><p><strong>添加依赖</strong></p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><p><strong>使用</strong></p><ul><li>添加<code>@Data</code>注解即可</li></ul><pre><code class="highlight java"><span class="meta">@Data</span><span class="meta">@NoArgsConstructor</span>     <span class="comment">//没有参数的构造方法</span><span class="meta">@AllArgsConstructor</span>     <span class="comment">//全部参数的构造方法</span><span class="keyword">public</span> <span class="keyword">void</span> Student&#123;    <span class="keyword">private</span> <span class="type">int</span> id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> <span class="type">int</span> age;        <span class="comment">//剩下的代码lombok会自动生成</span>&#125;</code></pre><h3 id="读取自定义配置"><a class="markdownIt-Anchor" href="#读取自定义配置"></a> 读取自定义配置</h3><p>自定义配置，可以是定义在主配置文件application.properties中的自定义属性，也可以是自定义配置文件中的属性。</p><ul><li>通过@Value(“${ }”)读取指定的自定义属性</li><li>若要读取自定义配置文件，则需要在该读取类上添加@PropertySource注解</li><li>自定义配置文件不能是yml文件，只能是properties</li></ul><h4 id="读取配置文件中的属性"><a class="markdownIt-Anchor" href="#读取配置文件中的属性"></a> 读取配置文件中的属性</h4><p>修改主配置文件：<code>application.properties</code></p><pre><code class="highlight plaintext">student.name=张三</code></pre><p>在类中读取：</p><pre><code class="highlight java"><span class="meta">@Controller</span><span class="meta">@RequestMapping(&quot;/test&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeHandler</span>&#123;    <span class="meta">@Value(&quot;$&#123;student.name&#125;&quot;)</span>    <span class="keyword">private</span> String name;    <span class="meta">@GetMapping(&quot;some&quot;)</span>    <span class="meta">@ResponseBody</span>    <span class="keyword">public</span> String <span class="title function_">someHandler</span><span class="params">()</span>&#123;        <span class="keyword">return</span> name;    &#125;&#125;</code></pre><h4 id="读取指定配置文件中的属性"><a class="markdownIt-Anchor" href="#读取指定配置文件中的属性"></a> 读取指定配置文件中的属性</h4><p>一般情况下，主配置文件中存放系统中定义好的属性设置，而自定义属性一般会写入自定义的配置文件中。也就是说，Java代码除了可以读取主配置文件中的属性外，还可以读取指定配置文件中的属性，可以通过@PropertySource注解加载指定的配置文件。</p><blockquote><p>spring boot官网给出说明，@PropertySource注解不能加载yml文件。所以其建议自定快速开发框架 自定义配置文件就使用属性文件。</p></blockquote><p><strong>自定义配置文件</strong></p><p>定义配置文件<code>myapp.properties</code>，存放在src/main/resource目录中</p><pre><code class="highlight plaintext">student.name=张三</code></pre><p><strong>类中取值</strong></p><p>使用<code>@PropertySource</code>注解，若属性的值存在中文，则需要添加encoding属性</p><pre><code class="highlight java"><span class="meta">@Controller</span><span class="meta">@RequestMapping(&quot;/test&quot;)</span><span class="meta">@PropertySource(value=&quot;classpath:myapp.properties&quot;,encoding=&quot;utf-8&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeHandler</span>&#123;    <span class="meta">@Value(&quot;$&#123;student.name&#125;&quot;)</span>    <span class="keyword">private</span> String name;    <span class="meta">@GetMapping(&quot;some&quot;)</span>    <span class="meta">@ResponseBody</span>    <span class="keyword">public</span> String <span class="title function_">someHandler</span><span class="params">()</span>&#123;        <span class="keyword">return</span> name;    &#125;&#125;</code></pre><h4 id="读取对象属性"><a class="markdownIt-Anchor" href="#读取对象属性"></a> 读取对象属性</h4><p><code>myapp.properties</code></p><pre><code class="highlight plaintext">student.name=zhangsanstudent.age=24student.score=93.5</code></pre><p><strong>类中读取值</strong></p><ul><li><code>@ProertySource</code>用于指定要读取的配置文件</li><li><code>@ConfigurationProperties</code>用于指定要读取配置文件中的对象属性</li><li><code>@Component</code>表示当前从配置文件读取来的对象，由Spring容器创建</li></ul><blockquote><p>这里的类名可以随便起，不用和配置文件相同，但是成员变量名必须相同</p></blockquote><pre><code class="highlight java"><span class="meta">@Component</span><span class="meta">@PropertySource(value=&quot;classpath:myapp.properties&quot;,encoding=&quot;utf-8&quot;)</span><span class="meta">@ConfigurationProperties(&quot;student&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;        <span class="keyword">private</span> String name;    <span class="keyword">private</span> <span class="type">int</span> age;    <span class="keyword">private</span> <span class="type">double</span> score;    <span class="comment">//getter and setter</span>&#125;</code></pre><h4 id="读取list-string"><a class="markdownIt-Anchor" href="#读取list-string"></a> 读取List-String</h4><p><code>myapp.properties</code></p><pre><code class="highlight properties"><span class="attr">country.cities[0]</span>=<span class="string">beijing</span><span class="attr">country.cities[1]</span>=<span class="string">shanghai</span><span class="attr">country.cities[2]</span>=<span class="string">xian</span></code></pre><p><strong>在类中取值</strong></p><pre><code class="highlight java"><span class="meta">@Component</span> <span class="meta">@PropertySource(value=&quot;classpath:myapp.properties&quot;,encoding=&quot;utf-8&quot;)</span> <span class="meta">@ConfigurationProperties(&quot;country&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Country</span>&#123;    <span class="keyword">private</span> List&lt;String&gt; cities;        <span class="comment">//getter and setter</span>&#125;</code></pre><h4 id="读取list-object"><a class="markdownIt-Anchor" href="#读取list-object"></a> 读取List-Object</h4><p><code>myapp.properties</code></p><pre><code class="highlight properties"><span class="attr">group.students[0].name</span>=<span class="string">zhangdan</span><span class="attr">group.students[0].age</span>=<span class="string">23</span><span class="attr">group.students[0].score</span>=<span class="string">93</span><span class="attr">group.students[1].name</span>=<span class="string">lisi</span><span class="attr">group.students[1].age</span>=<span class="string">25</span><span class="attr">group.students[1].score</span>=<span class="string">80</span><span class="attr">group.students[2].name</span>=<span class="string">wangwu</span><span class="attr">group.students[2].age</span>=<span class="string">26</span><span class="attr">group.students[2].score</span>=<span class="string">99</span></code></pre><p><strong>在类中取值</strong></p><blockquote><p>Student类无需任何注解</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> <span class="type">int</span> age;    <span class="keyword">private</span> <span class="type">double</span> score;        <span class="comment">//getter and setter</span>&#125;</code></pre><pre><code class="highlight java"><span class="meta">@Component</span> <span class="meta">@PropertySource(value=&quot;classpath:myapp.properties&quot;,encoding=&quot;utf-8&quot;)</span> <span class="meta">@ConfigurationProperties(&quot;group&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Country</span>&#123;    <span class="keyword">private</span> List&lt;Student&gt; student;        <span class="comment">//getter and setter</span>&#125;</code></pre><h3 id="jsp"><a class="markdownIt-Anchor" href="#jsp"></a> JSP</h3><p>在Spring Boot下直接使用JSP文件，其是无法解析的，需要做专门的配置。</p><p>spring boot的默认视图支持使Thymeleaf</p><ul><li>在pom文件中注册JSP解析器依赖</li><li>在pom文件中注册资源目录</li><li>在主配置文件中注册视图前辍与后辍（不是必须的）</li></ul><h4 id="1-直接添加jsp文件"><a class="markdownIt-Anchor" href="#1-直接添加jsp文件"></a> 1 直接添加JSP文件</h4><p><strong>创建webapp目录</strong></p><p>在src/main下创建webapp目录，用于存放jsp文件。这就是一个普通的目录，无需执行Mark Directory As。</p><p><strong>创建index.jsp</strong></p><p>在spring boot工程中若要创建jsp文件，一般是需要在src/main下创建webapp目录，然后在该目录下创建jsp文件。但通过Alt + Insert发现没有创建jsp文件的选项。此时，需要打开Project Structrue窗口，将webapp目录指定为web资源目录，然后才可以创建jsp文件</p><p>指定后便可看到下面的窗口情况。</p><p>此时，便可在webapp中找到jsp的创建选项了。</p><p>创建index页面</p><p>此时启动工程后在浏览器直接访问，发现其并没有显示index页面。因为当前工程不能识别jsp文件</p><h4 id="2-使用物理视图"><a class="markdownIt-Anchor" href="#2-使用物理视图"></a> 2 使用物理视图</h4><p><strong>添加jasper依赖</strong></p><p>在pom中添加一个Tomcat内嵌的jsp引擎jasper依赖。jsp引擎是用于解析jsp文件的，即将jsp文件解析为Servlet是由jsp引擎完成的。embed，嵌入。</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><p><strong>注册webapp目录</strong></p><p>在pom文件中将webapp目录注册为资源目录。</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">build</span>&gt;</span>    <span class="comment">&lt;!--spring提供的打包插件--&gt;</span>    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="comment">&lt;!--注册webapp目录为资源目录--&gt;</span>    <span class="tag">&lt;<span class="name">resources</span>&gt;</span>        <span class="tag">&lt;<span class="name">resource</span>&gt;</span>            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/webapp<span class="tag">&lt;/<span class="name">directory</span>&gt;</span>            <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>META-INF/resource<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span>            <span class="tag">&lt;<span class="name">includes</span>&gt;</span>                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span>            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span>        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span>    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span><span class="tag">&lt;/<span class="name">build</span>&gt;</span></code></pre><p>不过，我们一般会注册两个目录：还会注册dao包下的mybatis映射文件为资源目录</p><pre><code class="highlight xml"><span class="comment">&lt;!--注册dao包下mybatis映射文件为资源目录--&gt;</span><span class="tag">&lt;<span class="name">resource</span>&gt;</span>    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span>    <span class="tag">&lt;<span class="name">includes</span>&gt;</span>        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span>    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></code></pre><p><strong>创建welcome.jsp</strong></p><p>在webapp目录下再创建一个子目录jsp，在其中创建welcome.jsp文件。</p><p><strong>编写controller类</strong></p><p><strong>访问</strong></p><h4 id="3-使用逻辑视图"><a class="markdownIt-Anchor" href="#3-使用逻辑视图"></a> 3 使用逻辑视图</h4><p>修改主配置文件<code>application.properties</code></p><pre><code class="highlight properties"><span class="attr">spring.mvc.view.prefix</span>=<span class="string">/</span><span class="attr">spring.mvc.view.suffix</span>=<span class="string">.jsp</span></code></pre><p>修改Controller</p><blockquote><p><strong>关于静态资源请求</strong></p></blockquote><p>查看控制台的启动日志，DispatcherServlet的<url-pattern>为/。我们之前在学习SpringMVC时强调过，若DispatcherServlet的<url-pattern>为/，则中央调度器会拦截静态资源，即所有静态资源是无法访问的，若要访问，则需要再行配置。但，通过前面的运行可知，Spring Boot对于静态资源的访问是没有问题的。即，Spring Boot已经处理好了静态资源访问问题。</p><h3 id="mybatis"><a class="markdownIt-Anchor" href="#mybatis"></a> MyBatis</h3><p>在Spring Boot中使用MyBatis无需定义MyBatis的主配置文件，需要完成以下三个步骤：</p><ul><li>在pom文件中导入三个依赖：MyBatis与Spring Boot整合依赖、MySQL驱动依赖，及Druid依赖</li><li>在Spring Boot主配置文件中注册三个信息：映射文件、实体类别名，及数据源</li><li>在Dao接口上添加@Mapper注解</li></ul><p><strong>pom.xml依赖</strong></p><blockquote><p>注意，<code>spring boot与mybaits整合依赖</code>这个依赖是由mybatis开发，并非由Spring开发，所以这里需要指明版本号。因为父工程中没有定义该版本号。</p></blockquote><blockquote><p>注意，<code>mysql驱动依赖</code>该依赖要指定版本号，若不指定其也会从父工程中继承，但版本过高，代码运行</p></blockquote><pre><code class="highlight xml"><span class="comment">&lt;!--spring boot与mybaits整合依赖--&gt;</span> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> <span class="comment">&lt;!--mysql驱动依赖--&gt;</span> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>     <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> <span class="comment">&lt;!--阿里连接池--&gt;</span> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><p><strong>注册dao包下mybatis映射文件为资源目录</strong></p><pre><code class="highlight xml"><span class="comment">&lt;!--注册dao包下mybatis映射文件为资源目录--&gt;</span><span class="tag">&lt;<span class="name">build</span>&gt;</span>    <span class="tag">&lt;<span class="name">resource</span>&gt;</span>        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span>        <span class="tag">&lt;<span class="name">includes</span>&gt;</span>            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span>        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span>    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span><span class="tag">&lt;/<span class="name">build</span>&gt;</span></code></pre><p><strong>定义Service接口及实现类</strong></p><p>service接口</p><p>service实现类</p><p><strong>定义实体类和数据库表</strong></p><p>定义实体类</p><p>在DB的test数据库中定义student</p><p><strong>定义Dao接口和映射文件</strong></p><p>Dao接口上要添加@Mapper注解。</p><p>映射文件</p><p><strong>定义Controller</strong></p><p><strong>修改主配置文件</strong></p><ul><li>注册映射文件</li><li>注册实体类别名</li><li>注册数据源</li></ul><p><code>application.properties</code></p><pre><code class="highlight properties"><span class="comment"># 配置jsp的寻找路径 </span><span class="attr">spring.mvc.view.prefix</span>=<span class="string">/ </span><span class="attr">spring.mvc.view.suffix</span>=<span class="string">.jsp </span><span class="comment"></span><span class="comment">#注册映射文件</span><span class="attr">mybatis.mapper-locations</span>=<span class="string">classpath:com/abc/primary/dao/*.xml</span><span class="comment">#注册实体类别名</span><span class="attr">mybatis.type-aliases-package</span>=<span class="string">com.abc.primary.beans</span><span class="comment"></span><span class="comment"></span><span class="comment">#datasource数据源 </span><span class="attr">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver </span><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/lee_test?characterEncoding=UTF-8 </span><span class="attr">spring.datasource.username</span>=<span class="string">root </span><span class="attr">spring.datasource.password</span>=<span class="string">admin </span><span class="comment"></span><span class="comment"></span><span class="comment">#新增数据库链接必须的参数 </span><span class="attr">spring.jpa.properties.hibernate.hbm2ddl.auto</span>=<span class="string">update</span></code></pre><h3 id="对事务的支持"><a class="markdownIt-Anchor" href="#对事务的支持"></a> 对事务的支持</h3><p>Spring Boot对于事务的支持，只需完成两个步骤：</p><ul><li>在<strong>启动类</strong>上添加<code>@EnableTransactionManagement</code>注解，开启事务</li><li>在Service<strong>实现类</strong>的方法上添加<code>@Transactional</code>注解</li></ul><p><strong>修改启动类</strong></p><pre><code class="highlight java"><span class="meta">@SpringBootApplication</span><span class="meta">@EnableTransactionManagement</span>   <span class="comment">//开启事务</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootdemoApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(SpringbootdemoApplication.class, args);    &#125;&#125;</code></pre><p><strong>修改Service启动类</strong></p><pre><code class="highlight java"><span class="meta">@Service</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ISomeService</span> &#123;        <span class="meta">@Autowired</span>    <span class="keyword">private</span> IStudentDao dao;        <span class="meta">@Transactional</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span>&#123;        <span class="comment">//该插入会发生回滚，无法插入到db</span>        dao.insertStudent(student);        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span> / <span class="number">0</span>;      <span class="comment">//抛出异常语句</span>        dao.insertStudent(student);    &#125;&#125;</code></pre><p><strong>正常测试</strong></p><p>以上代码运行后，页面与代码均会显示报错，查看DB表，没有任何记录插入。</p><p><strong>对比测试</strong></p><p>将Service实现类中的@Transactional注解注释掉，再运行，页面与代码仍均会显示报错，但查看DB表，会发现插入了一条记录，即异常前的插入语句没有回滚。</p><h3 id="对日志的控制"><a class="markdownIt-Anchor" href="#对日志的控制"></a> 对日志的控制</h3><p>Spring Boot中使用的日志技术为logback。其与Log4J都出自同一人，性能要优于Log4J，是Log4J的替代者。</p><p>在Spring Boot中若要使用logback，则需要具有spring-boot-starter-logging依赖，而该依赖被spring-boot-starter-web所依赖，即不用直接导入spring-boot-starter-logging依赖。</p><p><strong>方式一：添加配置属性</strong></p><pre><code class="highlight properties"><span class="comment">#日志显示格式</span><span class="attr">logging.pattern.console</span>:<span class="string">%level %msg%n</span><span class="comment">#减少项目启动时的日志输出</span><span class="attr">logging.level.root</span>:<span class="string">warn</span><span class="comment">#显示Dao层执行的sql语句</span><span class="attr">logging.level.com.bjpowernode.primary.dao</span>:<span class="string">debug</span></code></pre><blockquote><p>注意，在日志显示格式的属性值前面的xxx:是随意内容。在yml文件中的属性值若以%开头会报错，所以添加一些随意字符。在properties文件中不存在该问题。</p></blockquote><p><strong>方式二：添加配置文件</strong></p><p>该文件名为logback.xml，且必须要放在src/main/resources类路径下。</p><pre><code class="highlight xml"><span class="meta">&lt;?xml version= <span class="string">&quot;1.0&quot;</span> encoding= <span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;myConsoLe&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoLeAppender&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span>            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%-5level - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span>        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span>    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span>    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;WARN&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;myConsole&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">root</span>&gt;</span>    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.bjpowernode.primary.dao&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></code></pre><p><strong>使用</strong></p><h3 id="redis"><a class="markdownIt-Anchor" href="#redis"></a> Redis</h3><p>使用Redis缓存的数据划分为两类：</p><ul><li>DB中相关表更新后，Redis缓存中的存放的相关数据要清除，否则客户端获取到的就不是最新数据，这是一类数据；</li><li>还有一类数据是，对数据的准确性要求不是很高的数据，其可以与DB中数据不一致，但差别不能太大，所以该类数据一般会设置过期时效。</li></ul><p>Spring Boot对于以上两类数据，均可使用API方式与注解方式进行缓存。但Spring Boot使用注解方式在对指定缓存空间设置缓存时效时非常麻烦，所以对于两类数据的缓存可以分别使用两种方式实现。</p><h4 id="注解详解"><a class="markdownIt-Anchor" href="#注解详解"></a> 注解详解</h4><h5 id="cacheable"><a class="markdownIt-Anchor" href="#cacheable"></a> @Cacheable</h5><p>@Cacheable可以标记在一个<strong>方法</strong>上，也可以标记在一个<strong>类</strong>上。当标记在一个方法上时表示该方法是<strong>支持缓存</strong>的，当标记在一个类上时则表示该类所有的方法都是支持缓存的。对于一个支持缓存的方法，<strong>Spring会在其被调用后将其返回值缓存起来，以保证下次利用同样的参数来执行该方法时可以直接从缓存中获取结果，而不需要再次执行该方法</strong>。Spring在缓存方法的返回值时是以键值对进行缓存的，值就是方法的返回结果，至于键的话，Spring又支持两种策略，默认策略和自定义策略，这个稍后会进行说明。需要注意的是当一个支持缓存的方法在对象内部被调用时是不会触发缓存功能的。@Cacheable可以指定三个属性，value、key和condition。</p><table><thead><tr><th>参数</th><th>解释</th><th>例子</th></tr></thead><tbody><tr><td>value</td><td>缓存的名称，在 spring 配置文件中定义，必须指定至少一个</td><td>例如: @Cacheable(value=”mycache”) @Cacheable(value={”cache1”,”cache2”}</td></tr><tr><td>key</td><td>缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合</td><td>@Cacheable(value=”testcache”,key=”#userName”)</td></tr><tr><td>condition</td><td>缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存</td><td><code>@Cacheable(value=”testcache”,condition=”#userName.length()&gt;2”)</code></td></tr></tbody></table><p><strong>value属性指定Cache名称</strong></p><p>value属性是必须指定的，其表示当前方法的返回值是会被缓存在哪个Cache上的，对应Cache的名称。其可以是一个Cache也可以是多个Cache，当需要指定多个Cache时其是一个数组。</p><pre><code class="highlight java"><span class="meta">@Cacheable(&quot;cache1&quot;)</span><span class="comment">//Cache是发生在cache1上的</span>   <span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(Integer id)</span> &#123;      returnnull;   &#125;  <span class="meta">@Cacheable(&#123;&quot;cache1&quot;, &quot;cache2&quot;&#125;)</span><span class="comment">//Cache是发生在cache1和cache2上的</span>   <span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(Integer id)</span> &#123;      returnnull;   &#125;</code></pre><p><strong>key使用示例</strong></p><p>key属性是用来指定Spring缓存方法的返回结果时对应的key的。该属性支持SpringEL表达式。当我们没有指定该属性时，Spring将使用默认策略生成key。我们这里先来看看自定义策略，至于默认策略会在后文单独介绍。<br />自定义策略是指我们可以通过Spring的EL表达式来指定我们的key。这里的EL表达式可以使用方法参数及它们对应的属性。使用方法参数时我们可以直接使用“#参数名”或者“#p参数index”。下面是几个使用参数作为key的示例。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">* key 是指传入时的参数</span><span class="comment">*</span><span class="comment">*/</span>   <span class="meta">@Cacheable(value=&quot;users&quot;, key=&quot;#id&quot;)</span>   <span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(Integer id)</span> &#123;      returnnull;   &#125;<span class="comment">// 表示第一个参数</span>  <span class="meta">@Cacheable(value=&quot;users&quot;, key=&quot;#p0&quot;)</span>   <span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(Integer id)</span> &#123;      returnnull;   &#125;<span class="comment">// 表示User中的id值</span>   <span class="meta">@Cacheable(value=&quot;users&quot;, key=&quot;#user.id&quot;)</span>   <span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(User user)</span> &#123;      returnnull;   &#125; <span class="comment">// 表示第一个参数里的id属性值</span>   <span class="meta">@Cacheable(value=&quot;users&quot;, key=&quot;#p0.id&quot;)</span>   <span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(User user)</span> &#123;      returnnull;   &#125;</code></pre><blockquote><p>除了上述使用方法参数作为key之外，Spring还为我们提供了一个root对象可以用来生成key。通过该root对象我们可以获取到以下信息。</p></blockquote><table><thead><tr><th>属性名称</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>methodName</td><td>当前方法名</td><td>#root.methodName</td></tr><tr><td>method</td><td>当前方法</td><td>#<a href="http://root.method.name">root.method.name</a></td></tr><tr><td>target</td><td>当前被调用的对象</td><td>#root.target</td></tr><tr><td>targetClass</td><td>当前被调用的对象的class</td><td>#root.targetClass</td></tr><tr><td>args</td><td>当前方法参数组成的数组</td><td>#root.args[0]</td></tr><tr><td>caches</td><td>当前被调用的方法使用的Cache</td><td>#root.caches[0].name</td></tr></tbody></table><blockquote><p>当我们要使用root对象的属性作为key时我们也可以将“#root”省略，因为Spring默认使用的就是root对象的属性</p></blockquote><p><strong>自定义key值的默认值</strong></p><pre><code class="highlight java"><span class="meta">@Configuration</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCacheConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;    <span class="comment">//自动生成key的结构，类名_方法名_参数值</span>    <span class="keyword">public</span> KeyGenerator <span class="title function_">keyGenerator</span><span class="params">()</span> &#123;        <span class="comment">//函数式接口的写法</span>        <span class="keyword">return</span> (target,method, params) -&gt;&#123;            <span class="comment">//获取注解所标方法所在的类名</span>            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> target.getClass().getName();            <span class="comment">//获取注解所标方法的方法名</span>            <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();            <span class="keyword">return</span> className+<span class="string">&quot;_&quot;</span>+methodName+<span class="string">&quot;_&quot;</span>+params[<span class="number">0</span>].toString();        &#125;;    &#125;&#125;</code></pre><p><strong>condition属性指定发生的条件</strong></p><p>有的时候我们可能并不希望缓存一个方法所有的返回结果。通过condition属性可以实现这一功能。condition属性默认为空，表示将缓存所有的调用情形。其值是通过SpringEL表达式来指定的，当为true时表示进行缓存处理；当为false时表示不进行缓存处理，即每次调用该方法时该方法都会执行一次。如下示例表示只有当user的id为偶数时才会进行缓存</p><pre><code class="highlight java"><span class="comment">// 根据条件判断是否缓存</span> <span class="meta">@Cacheable(value=&#123;&quot;users&quot;&#125;, key=&quot;#user.id&quot;, condition=&quot;#user.id%2==0&quot;)</span><span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(User user)</span> &#123;   System.out.println(<span class="string">&quot;find user by user &quot;</span> + user);   <span class="keyword">return</span> user;&#125;</code></pre><h5 id="cacheput"><a class="markdownIt-Anchor" href="#cacheput"></a> @CachePut</h5><p>在支持Spring Cache的环境下，对于使用@Cacheable标注的方法，Spring在每次执行前都会检查Cache中是否存在相同key的缓存元素，如果存在就不再执行该方法，而是直接从缓存中获取结果进行返回，否则才会执行并将返回结果存入指定的缓存中。@CachePut也可以声明一个方法支持缓存功能。<strong>与@Cacheable不同的是使用@CachePut标注的方法在执行前不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中</strong></p><pre><code class="highlight java"><span class="comment">//@CachePut也可以标注在类上和方法上。使用@CachePut时我们可以指定的属性跟@Cacheable是一样的。</span>   <span class="meta">@CachePut(&quot;users&quot;)</span><span class="comment">//每次都会执行方法，并将结果存入指定的缓存中</span>   <span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(Integer id)</span> &#123;      returnnull;   &#125;</code></pre><h5 id="cacheevict"><a class="markdownIt-Anchor" href="#cacheevict"></a> @CacheEvict</h5><p>@CacheEvict是用来标注在需要清除缓存元素的方法或类上的。当标记在一个类上时表示其中所有的方法的<strong>执行都会触发缓存的清除操作</strong>。@CacheEvict可以指定的属性有value、key、condition、allEntries和beforeInvocation。其中value、key和condition的语义与@Cacheable对应的属性类似。即<strong>value表示清除操作是发生在哪些Cache上的</strong>（对应Cache的名称）；<strong>key表示需要清除的是哪个key</strong>，如未指定则会使用默认策略生成的key；condition表示清除操作发生的条件。下面我们来介绍一下新出现的两个属性allEntries和beforeInvocation。</p><p><strong>allEntries属性</strong></p><p>allEntries是boolean类型，表示是否需要清除缓存中的所有元素。默认为false，表示不需要。当指定了allEntries为true时，Spring Cache将忽略指定的key。有的时候我们需要Cache一下清除所有的元素，这比一个一个清除元素更有效率。</p><pre><code class="highlight java"><span class="meta">@CacheEvict(value=&quot;users&quot;, allEntries=true)</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;    System.out.println(<span class="string">&quot;delete user by id: &quot;</span> + id);&#125;</code></pre><p><strong>beforeInvocation属性</strong></p><p>清除操作默认是在对应方法成功执行之后触发的，即方法如果因为抛出异常而未能成功返回时也不会触发清除操作。使用beforeInvocation可以改变触发清除操作的时间，当我们指定该属性值为true时，Spring会在调用该方法之前清除缓存中的指定元素。</p><pre><code class="highlight java"><span class="meta">@CacheEvict(value=&quot;users&quot;, beforeInvocation=true)</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;   System.out.println(<span class="string">&quot;delete user by id: &quot;</span> + id);&#125;</code></pre><h5 id="caching"><a class="markdownIt-Anchor" href="#caching"></a> @Caching</h5><p>@Caching注解可以让我们在一个方法或者类上同时指定多个Spring Cache相关的注解。其拥有三个属性：cacheable、put和evict，分别用于指定@Cacheable、@CachePut和@CacheEvict。</p><pre><code class="highlight java"><span class="meta">@Caching(cacheable = @Cacheable(&quot;users&quot;), evict = &#123; @CacheEvict(&quot;cache2&quot;),</span><span class="meta">@CacheEvict(value = &quot;cache3&quot;, allEntries = true) &#125;)</span><span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(Integer id)</span> &#123;  returnnull;&#125;</code></pre><h4 id="总步骤"><a class="markdownIt-Anchor" href="#总步骤"></a> 总步骤</h4><p>（1） <strong>都需要的步骤</strong></p><ul><li>在pom文件中添加spring boot与redis整合依赖</li><li>在主配置文件中注册redis连接信息、MyBatis中实体类的别名</li><li>由于要将查询的实体类对象缓存到Redis，Redis要求实体类必须序列化。所以需要实体类实现序列化接口</li></ul><p>（2） <strong>使用注解方式还需要的步骤</strong></p><ul><li>在工程入口类上添加<code>@EnableCaching</code>注解</li><li>在查询方法上添加<code>@Cacheable</code>注解，在增删改方法上添加<code>@CacheEvict</code>注解</li><li>在主配置文件中注册缓存空间名称</li></ul><p>（3） <strong>使用API方式还需要的步骤</strong></p><ul><li>Service中被自动注入的RedisTemplate需要的泛型，key与value要求类型相同，要么都是String，要么都是Object。建议使用Object，其通用性更好</li><li>在Service的查询方法中通过RedisTemplate对象获取到Redis的操作对象，然后再对Redis进行读写操作</li></ul><h4 id="依赖配置"><a class="markdownIt-Anchor" href="#依赖配置"></a> 依赖/配置</h4><p><strong>pom依赖</strong></p><p>在pom中添加spring boot与Redis整合依赖</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><p><strong>修改主配置文件</strong></p><pre><code class="highlight properties"><span class="comment">#连接单机Redis</span><span class="attr">spring.redis.host</span>=<span class="string">osRedis</span><span class="attr">spring.redis.port</span>=<span class="string">6379</span><span class="attr">spring.redis.password</span>=<span class="string">111</span><span class="comment">#连接redis高可用集群</span><span class="comment">#spring.redis.sentinel.master=mymaster</span><span class="comment">#spring.redis.sentinel.nodes=sentinel1:26379,sentinel2:26379,sentinel3:26379</span><span class="comment"></span><span class="comment">#开启缓存，指定cache类型</span><span class="attr">spring.cache.type</span>=<span class="string">redis</span><span class="comment">#缓存区域名</span><span class="attr">spring.cache.cache-names</span>=<span class="string">realTimeCache</span></code></pre><h4 id="类编写"><a class="markdownIt-Anchor" href="#类编写"></a> 类编写</h4><p>当前工程完成让用户在页面中输入要查询学生的id，其首先会查看Redis缓存中是否存在，若存在，则直接从Redis中读取；若不存在，则先从DB中查询出来，然后再存放到Redis缓存中。但用户也可以通过页面注册学生，一旦有新的学生注册，则需要将缓存中的学生信息清空。根据id查询出的学生信息要求必须是实时性的，其适合使用注解方式的Redis缓存。</p><p>同时，通过页面还可以查看到总学生数，但对其要求是差不多就行，无需是实时性的。对于Spring Boot工程，其适合使用API方式的Redis缓存，该方式方便设置缓存的到期时限。</p><p><strong>工程入口类添加@EnableCaching注解</strong></p><pre><code class="highlight java"><span class="meta">@SpringBootApplication</span><span class="meta">@EnableCaching</span>          <span class="comment">//开启缓存</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootwarApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(SpringbootwarApplication.class, args);    &#125;&#125;</code></pre><p><strong>修改实体类Student</strong></p><p>由于要将查询的实体类对象缓存到Redis，Redis要求实体类必须<strong>序列化</strong>。所以需要实体类实现序列化接口</p><p><strong>修改index页面</strong></p><p><strong>修改Controller</strong><br />在其中添加两个处理器方法。</p><p><strong>修改Service接口</strong></p><p><strong>修改Service实现类</strong>注解方式</p><ul><li>在<strong>查询方法上</strong>添加@<strong>Cacheable</strong>注解，在<strong>增删改方法</strong>上添加@<strong>CacheEvict</strong>注解</li><li>value值为 在主配置文件中注册缓存空间名称</li></ul><blockquote><p>@Cacheable会先用&quot;student_id&quot;从缓存中查询，如果有值，则直接返回，不会调用方法内部的语句</p></blockquote><blockquote><p>@CacheEvict会清掉realTimeCache缓存空间中的所有值（allEntries=true表示所有）</p></blockquote><blockquote><p>所以建议尽量让缓存空间小，一个表对应一个缓存空间</p></blockquote><p><strong>修改Service实现类</strong>代码方式</p><p><em>count数据并不需要实时的更新，只需要确保它相对准确就可以</em></p><blockquote><p>只要我们为一个缓存设置了缓存时间，就要考虑热点缓存问题（即时间到期后会有大量的并发访问该条记录）</p></blockquote><blockquote><p>我们可以用双重检测机制防止解决热点缓存</p></blockquote><p>redisTemplate对象我们直接注入就可以：</p><p>双重检测锁：</p><blockquote><p>这里使用<strong>synchronized的前提是该类是单例</strong>，因为我们的类都交给了spring管理，所以是单例的</p></blockquote><p><strong>修改Dao接口</strong></p><p><strong>修改映射文件</strong></p><h4 id="启动redis"><a class="markdownIt-Anchor" href="#启动redis"></a> 启动Redis</h4><p><strong>启动redis</strong></p><p><strong>启动Redis集群</strong><br />该示例需要启动三台Redis主机，三台Redis哨兵主机。</p><p>逐台启动三台Redis主机，即启动Redis</p><p><strong>登录Redis</strong><br />逐台登录三台Redis</p><p><strong>查看Redis角色</strong></p><p>逐台查看Redis的角色。</p><p><strong>启动sentinel集群</strong><br />逐台启动三台Sentinel主机，即启动Sentinel集群。</p><h3 id="拦截器"><a class="markdownIt-Anchor" href="#拦截器"></a> 拦截器</h3><p>在非Spring Boot工程中若要使用SpringMVC的拦截器，在定义好拦截器后，需要在Spring配置文件中对其进行注册。但Spring Boot工程中没有了Spring配置文件，那么如何使用拦截器呢？</p><p>Spring Boot对于原来在配置文件配置的内容，现在全部体现在一个类中，该类需要继承自WebMvcConfigurationSupport类，并使用@Configuration进行注解，表示该类为一个JavaConfig/CodeConfig类，其充当配置文件的角色。</p><p><strong>定义拦截器</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,Object handler)</span> <span class="keyword">throws</span> Exception&#123;        System.out.println(<span class="string">&quot;执行拦截器&quot;</span> + request.getRequestURI());        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;&#125;</code></pre><p><strong>定义处理器</strong></p><p><strong>定义配置文件类</strong></p><ul><li><code>*表示只有一级目录，**表示后面所有的目录</code></li></ul><pre><code class="highlight java"><span class="comment">//表示该文件相当于配置文件</span><span class="meta">@Configuration</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span>&#123;        SomeInterceptor si= <span class="keyword">new</span> <span class="title class_">SomeInterceptor</span>();        <span class="comment">//拦截first开头的路径，不拦截second开头的路径</span>        registry.addInterceptor(si).addPathPatterns(<span class="string">&quot;/first/**&quot;</span>).excludePathPatterns(<span class="string">&quot;/second/**&quot;</span>);    &#125;&#125;</code></pre><h3 id="servlet"><a class="markdownIt-Anchor" href="#servlet"></a> Servlet</h3><p>在Spring Boot中使用Servlet，根据Servlet注册方式的不同，有两种使用方式。若使用的Servlet3.0+版本，则两种方式均可使用；若使用的是Servlet2.5版本，则只能使用配置</p><h4 id="注解方式"><a class="markdownIt-Anchor" href="#注解方式"></a> 注解方式</h4><p>若使用的是Servlet3.0+版本，可以直接使用Servlet的注解对Servlet进行注册。其总步骤有两步：</p><ul><li>在定义好的Servlet上使用<code>@WebServlet</code>注解</li><li>在入口类上添加<code>@ServletComponentScan</code>注解</li></ul><p><strong>创建Servlet</strong><br />这里在创建Servlet时需要注意，不能直接使用Eclipse中的向导直接创建Servlet，无法创建。需要通过创建一个class，让其继承自HttpServlet方式创建。然后在Servlet上添加@WebServlet注解。</p><p><strong>修改入口类</strong></p><p>在入口类中添加Servlet扫描注解。</p><h4 id="配置类方式"><a class="markdownIt-Anchor" href="#配置类方式"></a> 配置类方式</h4><p>若使用的是Servlet2.5版本，没有Servlet注解，此时只能使用配置类方式。其总步骤有两步，无需在入口类上添加@ServletComponentScan注解。</p><ul><li>定义Servlet</li><li>定义配置类</li></ul><p><strong>定义Servlet</strong></p><p><strong>定义配置类</strong></p><h3 id="filter过滤器"><a class="markdownIt-Anchor" href="#filter过滤器"></a> Filter过滤器</h3><p>在Spring Boot中使用Filter与前面的使用Servlet相似，根据Filter注册方式的不同，有两种使用方式。若使用的是Servlet3.0+版本，则两种方式均可使用；若使用的是Servlet2.5版本，则只能使用配置类方式。</p><h4 id="注解方式-2"><a class="markdownIt-Anchor" href="#注解方式-2"></a> 注解方式</h4><p>若使用的是Servlet3.0+版本，可以直接使用Filter的注解对Filter进行注册。其总步骤有两步：</p><ul><li>在定义好的Filter上使用<code>@WebFilter</code>注解</li><li>在入口类上添加<code>@ServletComponentScan</code>注解</li></ul><p><strong>创建Filter</strong><br />这里在创建Filter时需要注意，不能直接使用Eclipse中的向导直接创建Filter，无法创建。需要通过创建一个class，让其实现Filter接口方式创建。然后在Filter上添加@WebFilter注解。</p><p><strong>修改入口类</strong><br />在@ServletComponentScan注解中注册Filter所在的包，当然，Spring Boot支持通配符的使用。</p><h4 id="配置类方式-2"><a class="markdownIt-Anchor" href="#配置类方式-2"></a> 配置类方式</h4><p>若使用的是Servlet2.5版本，没有Filter注解，此时只能使用配置类方式。其总步骤有两步，与@ServletComponentScan注解无关。</p><ul><li>定义Filter</li><li>定义配置类</li></ul><p><strong>定义Filter</strong></p><p><strong>修改配置类</strong><br />在配置类中添加如下方法</p><h2 id="持久层支持"><a class="markdownIt-Anchor" href="#持久层支持"></a> 持久层支持</h2><h3 id="jpa"><a class="markdownIt-Anchor" href="#jpa"></a> JPA</h3><p>JPA（Java persistence API）是Sun官方提出的Java持久化规范，用来方便大家操作数据库。</p><p>真正干活的可能是hibernate，tomlink等等实现了JPA规范的不同的厂商</p><h4 id="数据库准备"><a class="markdownIt-Anchor" href="#数据库准备"></a> 数据库准备</h4><p>创建表</p><pre><code class="highlight sql">use lee_test;<span class="keyword">CREATE TABLE</span> category (  id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT,  name <span class="type">varchar</span>(<span class="number">30</span>),  <span class="keyword">PRIMARY KEY</span> (id)) <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>UTF8;</code></pre><p>准备数据</p><pre><code class="highlight sql"><span class="keyword">insert into</span> category <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;category 1&#x27;</span>);<span class="keyword">insert into</span> category <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;category 2&#x27;</span>);<span class="keyword">insert into</span> category <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;category 3&#x27;</span>);<span class="keyword">insert into</span> category <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;category 4&#x27;</span>);</code></pre><h4 id="applicationproperties"><a class="markdownIt-Anchor" href="#applicationproperties"></a> application.properties</h4><pre><code class="highlight properties"><span class="comment"># 配置jsp的寻找路径</span><span class="attr">spring.mvc.view.prefix</span>=<span class="string">/WEB-INF/jsp/</span><span class="attr">spring.mvc.view.suffix</span>=<span class="string">.jsp</span><span class="comment">#更改tomcat默认端口号</span><span class="attr">server.port</span>=<span class="string">8088</span><span class="comment">#更改访问上下文路径/访问路径 localhost:8088/leeBoot/...</span><span class="attr">server.context-path</span>=<span class="string">/leeBoot</span><span class="comment"></span><span class="comment">#datasource数据源</span><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/lee_test?characterEncoding=UTF-8</span><span class="attr">spring.datasource.username</span>=<span class="string">root</span><span class="attr">spring.datasource.password</span>=<span class="string">admin</span><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span><span class="comment">#新增数据库链接必须的参数</span><span class="attr">spring.jpa.properties.hibernate.hbm2ddl.auto</span>=<span class="string">update</span></code></pre><h4 id="pomxml"><a class="markdownIt-Anchor" href="#pomxml"></a> pom.xml</h4><p>增加对MySQL和 jpa的支持</p><pre><code class="highlight xml"><span class="comment">&lt;!-- mysql--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!-- jpa--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h4 id="实体类"><a class="markdownIt-Anchor" href="#实体类"></a> 实体类</h4><ul><li><code>@Entity</code> 注解表示这是个实体类</li><li><code>@Table(name = &quot;category&quot;)</code> 表示这个类对应的表名是 category_ ，注意有下划线哦</li><li><code>@Id</code> 表明主键</li><li><code>@GeneratedValue(strategy = GenerationType.IDENTITY)</code> 表明自增长方式</li><li><code>@Column(name = &quot;id&quot;)</code> 表明对应的数据库字段名</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.pojo;<span class="keyword">import</span> javax.persistence.*;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/7/5.</span><span class="comment"> */</span><span class="comment">//表示这是个实体类</span><span class="meta">@Entity</span><span class="comment">//表示这个实体类对应的表为category</span><span class="meta">@Table(name=&quot;category&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Category</span> &#123;    <span class="comment">//表明主键</span>    <span class="meta">@Id</span>    <span class="comment">//表示自增长方式</span>    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>    <span class="comment">//表示对应的数据库字段名</span>    <span class="meta">@Column(name=&quot;id&quot;)</span>    <span class="keyword">private</span> <span class="type">int</span> id;    <span class="meta">@Column(name=&quot;name&quot;)</span>    <span class="keyword">private</span> String name;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;&#125;</code></pre><h4 id="dao"><a class="markdownIt-Anchor" href="#dao"></a> DAO</h4><p>创建dao接口CategoryDAO，继承了JpaRespository，并且提供泛型&lt;Category,Integer&gt;表示这个是针对Category类的DAO，Integer表示主键是Integer类型</p><p>JpaRespository这个父接口，就提供了CRUD，分页等等一系列的查询了，直接拿来用</p><p><strong>JpaRespository</strong>是一个接口，<code>org.springframework.data.jpa.repository.support</code>包有一个实现类<strong>SimpleJpaRepository</strong>，会纳入spring bean管理，所以所有继承了该接口的Dao类，实际传入的对象都是该实现类对象</p><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.dao;<span class="keyword">import</span> com.leeboer.springboot.pojo.Category;<span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/7/5.</span><span class="comment"> */</span><span class="comment">//泛型&lt;Category,Integer&gt; 表示这个是针对Category类的DAO,Integer表示主键是Integer类型</span><span class="comment">//JpaRepository 这个父接口，就提供了CRUD, 分页等等一系列的查询了，直接拿来用，都不需要二次开发的了</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CategoryDAO</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Category,Integer&gt; &#123;&#125;</code></pre><h4 id="controller"><a class="markdownIt-Anchor" href="#controller"></a> Controller</h4><p>创建CategoryController 类</p><pre><code>1. 接受listCategory映射2. 然后获取所有的分类数据3. 接着放入Model中4. 跳转到listCategory.jsp中</code></pre><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.web;<span class="keyword">import</span> com.leeboer.springboot.dao.CategoryDAO;<span class="keyword">import</span> com.leeboer.springboot.pojo.Category;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.stereotype.Controller;<span class="keyword">import</span> org.springframework.ui.Model;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/7/5.</span><span class="comment"> */</span><span class="meta">@Controller</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryController</span> &#123;    <span class="meta">@Autowired</span>    CategoryDAO categoryDAO;    <span class="meta">@RequestMapping(&quot;/listCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">listCategory</span><span class="params">(Model model)</span>&#123;        List&lt;Category&gt; list = categoryDAO.findAll();        <span class="keyword">for</span>(Category c:list)&#123;            System.out.println(c.getName());        &#125;        model.addAttribute(<span class="string">&quot;cs&quot;</span>,list);        <span class="keyword">return</span> <span class="string">&quot;listCategory&quot;</span>;    &#125;&#125;</code></pre><h4 id="jsp-2"><a class="markdownIt-Anchor" href="#jsp-2"></a> JSP</h4><pre><code class="highlight html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;   <span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">&#x27;center&#x27;</span> <span class="attr">border</span>=<span class="string">&#x27;1&#x27;</span> <span class="attr">cellspacing</span>=<span class="string">&#x27;0&#x27;</span>&gt;</span>    <span class="tag">&lt;<span class="name">tr</span>&gt;</span>        <span class="tag">&lt;<span class="name">td</span>&gt;</span>id<span class="tag">&lt;/<span class="name">td</span>&gt;</span>        <span class="tag">&lt;<span class="name">td</span>&gt;</span>name<span class="tag">&lt;/<span class="name">td</span>&gt;</span>    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>    <span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">items</span>=<span class="string">&quot;$&#123;cs&#125;&quot;</span> <span class="attr">var</span>=<span class="string">&quot;c&quot;</span> <span class="attr">varStatus</span>=<span class="string">&quot;st&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">tr</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;c.id&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;c.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span>                        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>    <span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></code></pre><h4 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h4><pre><code class="highlight plaintext">http://127.0.0.1:8088/leeBoot/listCategory</code></pre><h3 id="mybatis-注解方式"><a class="markdownIt-Anchor" href="#mybatis-注解方式"></a> MyBatis-注解方式</h3><h4 id="applicationproperties-2"><a class="markdownIt-Anchor" href="#applicationproperties-2"></a> application.properties</h4><pre><code class="highlight properties"><span class="comment"># 配置jsp的寻找路径</span><span class="attr">spring.mvc.view.prefix</span>=<span class="string">/WEB-INF/jsp/</span><span class="attr">spring.mvc.view.suffix</span>=<span class="string">.jsp</span><span class="comment">#更改tomcat默认端口号</span><span class="attr">server.port</span>=<span class="string">8088</span><span class="comment">#更改访问上下文路径/访问路径 localhost:8088/leeBoot/...</span><span class="attr">server.context-path</span>=<span class="string">/leeBoot</span><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/lee_test?characterEncoding=UTF-8</span><span class="attr">spring.datasource.username</span>=<span class="string">root</span><span class="attr">spring.datasource.password</span>=<span class="string">admin</span><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span><span class="comment">#新增数据库链接必须的参数（jpa方式要加，mybatis方式不用加）</span><span class="comment">#spring.jpa.properties.hibernate.hbm2ddl.auto=update</span></code></pre><h4 id="pomxml-2"><a class="markdownIt-Anchor" href="#pomxml-2"></a> pom.xml</h4><p>增加对MySQL和mybatis的支持</p><pre><code class="highlight xml"><span class="comment">&lt;!-- mysql--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!-- mybatis --&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h4 id="mapper"><a class="markdownIt-Anchor" href="#mapper"></a> Mapper</h4><p>其他与JPA方式相同，只需把dao改为Mapper即可</p><p>使用注解@Mapper表示这是一个Mybatis Mapper接口<br />使用@Select注解表示调用findAll方法会执行对应的sql语句</p><blockquote><p><strong>在工程主类application.java 上面添加注解<code>@MapperScan(&quot;com.leeboer.springboot.mapper&quot;)</code>，这样就可以省去在每个接口Mapper中添加<code>@Mapper</code>注解</strong></p></blockquote><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.dao;<span class="comment">/**</span><span class="comment"> * mybatis方式</span><span class="comment"> */</span><span class="keyword">import</span> com.leeboer.springboot.pojo.Category;<span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;<span class="keyword">import</span> org.apache.ibatis.annotations.Select;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/7/5.</span><span class="comment"> */</span><span class="meta">@Mapper</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CategoryMapper</span> &#123;    <span class="meta">@Select(&quot;select * from category&quot;)</span>    List&lt;Category&gt; <span class="title function_">findAll</span><span class="params">()</span>;&#125;</code></pre><h4 id="测试-2"><a class="markdownIt-Anchor" href="#测试-2"></a> 测试</h4><p>测试会发现，两种方式的执行效果相同</p><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.web;<span class="keyword">import</span> com.leeboer.springboot.dao.CategoryDAO;<span class="keyword">import</span> com.leeboer.springboot.dao.CategoryMapper;<span class="keyword">import</span> com.leeboer.springboot.pojo.Category;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.stereotype.Controller;<span class="keyword">import</span> org.springframework.ui.Model;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/7/5.</span><span class="comment"> */</span><span class="meta">@Controller</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryController</span> &#123;    <span class="comment">//jpa方式</span>    <span class="meta">@Autowired</span>    CategoryDAO categoryDAO;    <span class="comment">//Mapper方式</span>    <span class="meta">@Autowired</span>    CategoryMapper categoryMapper;    <span class="meta">@RequestMapping(&quot;/listCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">listCategory</span><span class="params">(Model model)</span>&#123;        List&lt;Category&gt; list = categoryDAO.findAll();        List&lt;Category&gt; list2 = categoryMapper.findAll();        <span class="keyword">for</span>(Category c:list2)&#123;            System.out.println(c.getName());        &#125;        model.addAttribute(<span class="string">&quot;cs&quot;</span>,list2);        <span class="keyword">return</span> <span class="string">&quot;listCategory&quot;</span>;    &#125;&#125;</code></pre><h3 id="mybatis-xml方式"><a class="markdownIt-Anchor" href="#mybatis-xml方式"></a> MyBatis-xml方式</h3><p>基于上一个例子的基础上</p><h4 id="categorymapper"><a class="markdownIt-Anchor" href="#categorymapper"></a> CategoryMapper</h4><pre><code class="highlight java"><span class="keyword">import</span> java.util.List; <span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;<span class="keyword">import</span> org.apache.ibatis.annotations.Select; <span class="keyword">import</span> com.how2java.springboot.pojo.Category; <span class="meta">@Mapper</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CategoryMapper</span> &#123;     List&lt;Category&gt; <span class="title function_">findAll</span><span class="params">()</span>; &#125;</code></pre><h4 id="categoryxml"><a class="markdownIt-Anchor" href="#categoryxml"></a> Category.xml</h4><p>在Mapper类旁边，新增加Category.xml文件</p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span><span class="meta">    <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="meta">    <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>      <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.leeboer.springboot.mapper.CategoryMapper&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Category&quot;</span>&gt;</span>            select * from category        <span class="tag">&lt;/<span class="name">select</span>&gt;</span>       <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></code></pre><h4 id="applicationproperties-3"><a class="markdownIt-Anchor" href="#applicationproperties-3"></a> application.properties</h4><pre><code class="highlight properties"><span class="comment"># 配置jsp的寻找路径</span><span class="attr">spring.mvc.view.prefix</span>=<span class="string">/WEB-INF/jsp/</span><span class="attr">spring.mvc.view.suffix</span>=<span class="string">.jsp</span><span class="comment">#更改tomcat默认端口号</span><span class="attr">server.port</span>=<span class="string">8088</span><span class="comment">#更改访问上下文路径/访问路径 localhost:8088/leeBoot/...</span><span class="attr">server.context-path</span>=<span class="string">/leeBoot</span><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/lee_test?characterEncoding=UTF-8</span><span class="attr">spring.datasource.username</span>=<span class="string">root</span><span class="attr">spring.datasource.password</span>=<span class="string">admin</span><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span><span class="comment">#新增数据库链接必须的参数（jpa方式要加，mybatis方式不用加）</span><span class="comment">#spring.jpa.properties.hibernate.hbm2ddl.auto=update</span><span class="comment"></span><span class="comment">#mybaits基于注解要额外加两条配置</span><span class="attr">mybatis.mapper-locations</span>=<span class="string">classpath:com/leeboer/springboot/mapper/*.xml</span><span class="attr">mybatis.type-aliases-package</span>=<span class="string">com.leeboer.springboot.pojo</span></code></pre><h4 id="测试-3"><a class="markdownIt-Anchor" href="#测试-3"></a> 测试</h4><p>调用方法与抢两个类似，不在概述</p><h2 id="crud分页"><a class="markdownIt-Anchor" href="#crud分页"></a> CRUD/分页</h2><h3 id="jpa-2"><a class="markdownIt-Anchor" href="#jpa-2"></a> JPA</h3><p>该种方式实现分页无需修改其他代码，只需在<code>controller</code>层增加相应响应即可，因为<code>CategoryDao</code>实现了<code>JpaRepository</code>接口，该接口的实现类<code>SimpleJpaRepository</code>基本实现了要用的所有方法</p><h4 id="controller-2"><a class="markdownIt-Anchor" href="#controller-2"></a> Controller</h4><p>Sort：表示一个排序对象，设置倒排序</p><pre><code class="highlight java"><span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sort</span>(Sort.Direction.DESC, <span class="string">&quot;id&quot;</span>);</code></pre><p>Pageable：分页对象</p><pre><code class="highlight java"><span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageRequest</span>(start, size, sort);</code></pre><p>CategoryDAO通过分页对象获取结果page</p><pre><code class="highlight java">Page&lt;Category&gt; page =categoryDAO.findAll(pageable);</code></pre><blockquote><p>在这个page对象里，不仅包含了分页信息，还包含了数据信息，即有哪些分类数据。 这个可以通过getContent()获取出来</p></blockquote><p>CategoryController.java</p><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.web;<span class="keyword">import</span> com.leeboer.springboot.Mapper.CategoryMapper;<span class="keyword">import</span> com.leeboer.springboot.dao.CategoryDAO;<span class="keyword">import</span> com.leeboer.springboot.pojo.Category;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.data.domain.Page;<span class="keyword">import</span> org.springframework.data.domain.PageRequest;<span class="keyword">import</span> org.springframework.data.domain.Pageable;<span class="keyword">import</span> org.springframework.data.domain.Sort;<span class="keyword">import</span> org.springframework.stereotype.Controller;<span class="keyword">import</span> org.springframework.ui.Model;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/7/5.</span><span class="comment"> */</span><span class="meta">@Controller</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryController</span> &#123;    <span class="comment">//jpa方式</span>    <span class="meta">@Autowired</span>    CategoryDAO categoryDAO;    <span class="comment">//Mapper方式</span>    <span class="meta">@Autowired</span>    CategoryMapper categoryMapper;    <span class="meta">@RequestMapping(&quot;/listCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">listCategory</span><span class="params">(Model model,<span class="meta">@RequestParam(value = &quot;start&quot;, defaultValue = &quot;0&quot;)</span> <span class="type">int</span> start,<span class="meta">@RequestParam(value = &quot;size&quot;, defaultValue = &quot;5&quot;)</span> <span class="type">int</span> size)</span>&#123;        <span class="comment">//分页</span>        <span class="comment">//如果首页开始坐标小于0则返回0</span>        start = start&lt;<span class="number">0</span>?<span class="number">0</span>:start;        <span class="comment">//设置倒序排序</span>        <span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sort</span>(Sort.Direction.DESC, <span class="string">&quot;id&quot;</span>);        <span class="comment">//根据start,size,sort创建分页对象</span>        <span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageRequest</span>(start, size, sort);        <span class="comment">//dao根据分页对象获取结果page</span>        <span class="comment">//在这个page对象里，不仅包含了分页信息，还包含了数据信息，即有哪些分类数据。 这个可以通过getContent()获取出来</span>        Page&lt;Category&gt; page =categoryDAO.findAll(pageable);        model.addAttribute(<span class="string">&quot;page&quot;</span>, page);        <span class="keyword">return</span> <span class="string">&quot;listCategory&quot;</span>;    &#125;    <span class="comment">//增</span>    <span class="meta">@RequestMapping(&quot;/addCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">addCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryDAO.save(c);<span class="comment">//JPA 新增和修改用的都是save. 它根据实体类的id是否为0来判断是进行增加还是修改</span>        <span class="keyword">return</span> <span class="string">&quot;redirect:listCategory&quot;</span>;    &#125;    <span class="comment">//删</span>    <span class="meta">@RequestMapping(&quot;/deleteCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">deleteCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryDAO.delete(c);        <span class="keyword">return</span> <span class="string">&quot;redirect:listCategory&quot;</span>;    &#125;    <span class="comment">//改</span>    <span class="meta">@RequestMapping(&quot;/updateCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">updateCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryDAO.save(c);<span class="comment">//JPA 新增和修改用的都是save. 它根据实体类的id是否为0来判断是进行增加还是修改</span>        <span class="keyword">return</span> <span class="string">&quot;redirect:listCategory&quot;</span>;    &#125;    <span class="comment">//查</span>    <span class="meta">@RequestMapping(&quot;/editCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">editCategory</span><span class="params">(<span class="type">int</span> id,Model m)</span> <span class="keyword">throws</span> Exception &#123;        Category c= categoryDAO.getOne(id);        m.addAttribute(<span class="string">&quot;c&quot;</span>, c);        <span class="keyword">return</span> <span class="string">&quot;editCategory&quot;</span>;    &#125;&#125;</code></pre><h4 id="jsp-3"><a class="markdownIt-Anchor" href="#jsp-3"></a> jsp</h4><p>通过page.getContent遍历当前页面的Category对象</p><p>在分页的时候通过page.number获取当前页面，page.totalPages获取总页面数</p><blockquote><p>page.getContent会返回一个泛型是Category的集合</p></blockquote><p>listCategory.jsp</p><pre><code class="highlight html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;         pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:500px;margin:20px auto;text-align: center&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">&#x27;center&#x27;</span> <span class="attr">border</span>=<span class="string">&#x27;1&#x27;</span> <span class="attr">cellspacing</span>=<span class="string">&#x27;0&#x27;</span>&gt;</span>        <span class="tag">&lt;<span class="name">tr</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>id<span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>name<span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">td</span>&gt;</span>        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>        <span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">items</span>=<span class="string">&quot;$&#123;page.content&#125;&quot;</span> <span class="attr">var</span>=<span class="string">&quot;c&quot;</span> <span class="attr">varStatus</span>=<span class="string">&quot;st&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">tr</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;c.id&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;c.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;editCategory?id=$&#123;c.id&#125;&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;deleteCategory?id=$&#123;c.id&#125;&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>        <span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span>    <span class="tag">&lt;/<span class="name">table</span>&gt;</span>    <span class="tag">&lt;<span class="name">br</span>&gt;</span>    <span class="tag">&lt;<span class="name">div</span>&gt;</span>        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=0&quot;</span>&gt;</span>[首  页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=$&#123;page.number-1&#125;&quot;</span>&gt;</span>[上一页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=$&#123;page.number+1&#125;&quot;</span>&gt;</span>[下一页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=$&#123;page.totalPages-1&#125;&quot;</span>&gt;</span>[末  页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>    <span class="tag">&lt;<span class="name">br</span>&gt;</span>    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;addCategory&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span>        name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span>        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span>    <span class="tag">&lt;/<span class="name">form</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><p>editCategory.jsp</p><pre><code class="highlight html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isELIgnored=&quot;false&quot;%&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin:0px auto; width:500px&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;updateCategory&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span> name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;c.name&#125;&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;c.id&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;/<span class="name">form</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><h3 id="mybatis-2"><a class="markdownIt-Anchor" href="#mybatis-2"></a> MyBatis</h3><h4 id="pomxml-3"><a class="markdownIt-Anchor" href="#pomxml-3"></a> pom.xml</h4><p>增加对PageHelper的支持</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h4 id="pagehelperconfig"><a class="markdownIt-Anchor" href="#pagehelperconfig"></a> PageHelperConfig</h4><p>添加一个类PageHelperConfig ，其中进行PageHelper相关配置</p><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.config;<span class="keyword">import</span> java.util.Properties;<span class="keyword">import</span> org.springframework.context.annotation.Bean;<span class="keyword">import</span> org.springframework.context.annotation.Configuration;<span class="keyword">import</span> com.github.pagehelper.PageHelper;<span class="meta">@Configuration</span><span class="comment">//表示该类是spring容器配置类，相当于基于xml启动的spring的application.xml配置文件</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageHelperConfig</span> &#123;    <span class="meta">@Bean</span>    <span class="comment">//表示application.xml中的一个&lt;bean&gt;&lt;/bean&gt;元素，改bean元素的id为pageHelper</span>    <span class="keyword">public</span> PageHelper <span class="title function_">pageHelper</span><span class="params">()</span> &#123;        <span class="type">PageHelper</span> <span class="variable">pageHelper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageHelper</span>();        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();        <span class="comment">//offsetAsPageNum:设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用</span>        p.setProperty(<span class="string">&quot;offsetAsPageNum&quot;</span>, <span class="string">&quot;true&quot;</span>);        <span class="comment">//rowBoundsWithCount:设置为true时，使用RowBounds分页会进行count查询</span>        p.setProperty(<span class="string">&quot;rowBoundsWithCount&quot;</span>, <span class="string">&quot;true&quot;</span>);        <span class="comment">//reasonable：启用合理化时，如果pageNum&lt;1会查询第一页，如果pageNum&gt;pages会查询最后一页</span>        p.setProperty(<span class="string">&quot;reasonable&quot;</span>, <span class="string">&quot;true&quot;</span>);        pageHelper.setProperties(p);        <span class="keyword">return</span> pageHelper;    &#125;&#125;</code></pre><h4 id="mapper-2"><a class="markdownIt-Anchor" href="#mapper-2"></a> Mapper</h4><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.Mapper;<span class="comment">/**</span><span class="comment"> * mybatis 注解方式（xml方式删掉Mapper注解和select注解新增xml文件即可）</span><span class="comment"> */</span><span class="keyword">import</span> com.leeboer.springboot.pojo.Category;<span class="keyword">import</span> org.apache.ibatis.annotations.*;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/7/5.</span><span class="comment"> */</span><span class="meta">@Mapper</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CategoryMapper</span> &#123;    <span class="meta">@Select(&quot;select * from category &quot;)</span>    List&lt;Category&gt; <span class="title function_">findAll</span><span class="params">()</span>;    <span class="meta">@Insert(&quot; insert into category ( name ) values (#&#123;name&#125;) &quot;)</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">save</span><span class="params">(Category category)</span>;    <span class="meta">@Delete(&quot; delete from category where id= #&#123;id&#125; &quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>;    <span class="meta">@Select(&quot;select * from category where id= #&#123;id&#125; &quot;)</span>    <span class="keyword">public</span> Category <span class="title function_">get</span><span class="params">(<span class="type">int</span> id)</span>;    <span class="meta">@Update(&quot;update category set name=#&#123;name&#125; where id=#&#123;id&#125; &quot;)</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Category category)</span>;&#125;</code></pre><h4 id="controller-3"><a class="markdownIt-Anchor" href="#controller-3"></a> Controller</h4><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.web;<span class="keyword">import</span> com.github.pagehelper.PageHelper;<span class="keyword">import</span> com.github.pagehelper.PageInfo;<span class="keyword">import</span> com.leeboer.springboot.Mapper.CategoryMapper;<span class="keyword">import</span> com.leeboer.springboot.dao.CategoryDAO;<span class="keyword">import</span> com.leeboer.springboot.pojo.Category;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.data.domain.Page;<span class="keyword">import</span> org.springframework.data.domain.PageRequest;<span class="keyword">import</span> org.springframework.data.domain.Pageable;<span class="keyword">import</span> org.springframework.data.domain.Sort;<span class="keyword">import</span> org.springframework.stereotype.Controller;<span class="keyword">import</span> org.springframework.ui.Model;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/7/5.</span><span class="comment"> */</span><span class="meta">@Controller</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryController</span> &#123;    <span class="comment">//jpa方式</span>    <span class="meta">@Autowired</span>    CategoryDAO categoryDAO;    <span class="comment">//Mapper方式</span>    <span class="meta">@Autowired</span>    CategoryMapper categoryMapper;    <span class="comment">//mybatis-PageHelper增删该查和注解的使用</span>    <span class="meta">@RequestMapping(&quot;/addCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">listCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryMapper.save(c);        <span class="keyword">return</span> <span class="string">&quot;redirect:listCategory&quot;</span>;    &#125;    <span class="meta">@RequestMapping(&quot;/deleteCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">deleteCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryMapper.delete(c.getId());        <span class="keyword">return</span> <span class="string">&quot;redirect:listCategory&quot;</span>;    &#125;    <span class="meta">@RequestMapping(&quot;/updateCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">updateCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryMapper.update(c);        <span class="keyword">return</span> <span class="string">&quot;redirect:listCategory&quot;</span>;    &#125;    <span class="meta">@RequestMapping(&quot;/editCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">listCategory</span><span class="params">(<span class="type">int</span> id,Model m)</span> <span class="keyword">throws</span> Exception &#123;        Category c= categoryMapper.get(id);        m.addAttribute(<span class="string">&quot;c&quot;</span>, c);        <span class="keyword">return</span> <span class="string">&quot;listCategory&quot;</span>;    &#125;    <span class="meta">@RequestMapping(&quot;/listCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">listCategory</span><span class="params">(Model m,<span class="meta">@RequestParam(value = &quot;start&quot;, defaultValue = &quot;0&quot;)</span> <span class="type">int</span> start,<span class="meta">@RequestParam(value = &quot;size&quot;, defaultValue = &quot;5&quot;)</span> <span class="type">int</span> size)</span> <span class="keyword">throws</span> Exception &#123;        PageHelper.startPage(start,size,<span class="string">&quot;id desc&quot;</span>);        List&lt;Category&gt; cs=categoryMapper.findAll();        PageInfo&lt;Category&gt; page = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(cs);        m.addAttribute(<span class="string">&quot;page&quot;</span>, page);        <span class="keyword">return</span> <span class="string">&quot;listCategoryPageHelper&quot;</span>;    &#125;&#125;</code></pre><h4 id="jsp-4"><a class="markdownIt-Anchor" href="#jsp-4"></a> jsp</h4><p>通过page.getList遍历当前页面的Category对象。<br />在分页的时候通过page.pageNum获取当前页面，page.pages获取总页面数。</p><blockquote><p>注：page.getList会返回一个泛型是Category的集合</p></blockquote><p>listCategory.jsp</p><pre><code class="highlight html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;  &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;    <span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:500px;margin:20px auto;text-align: center&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">&#x27;center&#x27;</span> <span class="attr">border</span>=<span class="string">&#x27;1&#x27;</span> <span class="attr">cellspacing</span>=<span class="string">&#x27;0&#x27;</span>&gt;</span>        <span class="tag">&lt;<span class="name">tr</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>id<span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>name<span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">td</span>&gt;</span>        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>        <span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">items</span>=<span class="string">&quot;$&#123;page.list&#125;&quot;</span> <span class="attr">var</span>=<span class="string">&quot;c&quot;</span> <span class="attr">varStatus</span>=<span class="string">&quot;st&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">tr</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;c.id&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;c.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;editCategory?id=$&#123;c.id&#125;&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;deleteCategory?id=$&#123;c.id&#125;&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>        <span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span>              <span class="tag">&lt;/<span class="name">table</span>&gt;</span>    <span class="tag">&lt;<span class="name">br</span>&gt;</span>    <span class="tag">&lt;<span class="name">div</span>&gt;</span>                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=1&quot;</span>&gt;</span>[首  页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=$&#123;page.pageNum-1&#125;&quot;</span>&gt;</span>[上一页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=$&#123;page.pageNum+1&#125;&quot;</span>&gt;</span>[下一页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=$&#123;page.pages&#125;&quot;</span>&gt;</span>[末  页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>    <span class="tag">&lt;<span class="name">br</span>&gt;</span>    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;addCategory&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span>          name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span>    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span>          <span class="tag">&lt;/<span class="name">form</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><h4 id="测试运行-2"><a class="markdownIt-Anchor" href="#测试运行-2"></a> 测试运行</h4><h3 id="sqlite"><a class="markdownIt-Anchor" href="#sqlite"></a> SQLite</h3><p>SQLite 是一种数据库，它是跑在 JVM里面的，所以不需要像 mysql 那样得独立安装配置，而是直接拿来就用</p><h4 id="pomxml-4"><a class="markdownIt-Anchor" href="#pomxml-4"></a> pom.xml</h4><p>增加sqlite依赖</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xerial<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sqlite-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h4 id="配置sqlite方言"><a class="markdownIt-Anchor" href="#配置sqlite方言"></a> 配置SQLite方言</h4><p>因为是使用 JPA 来链接 SQlite, 而 JPA 默认用的是 Hibernate，所以要为 Hibernate 配置专门的方言</p><p>方便 Hibernate和 Sqlite打交道。 方言的英文是 Dialect， 所以就有了SQLiteDialect 这个类了</p><h5 id="sqlitedialect"><a class="markdownIt-Anchor" href="#sqlitedialect"></a> SQLiteDialect</h5><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.sqlite;<span class="keyword">import</span> java.sql.SQLException;<span class="keyword">import</span> java.sql.Types;<span class="keyword">import</span> org.hibernate.JDBCException;<span class="keyword">import</span> org.hibernate.ScrollMode;<span class="keyword">import</span> org.hibernate.dialect.Dialect;<span class="keyword">import</span> org.hibernate.dialect.function.AbstractAnsiTrimEmulationFunction;<span class="keyword">import</span> org.hibernate.dialect.function.NoArgSQLFunction;<span class="keyword">import</span> org.hibernate.dialect.function.SQLFunction;<span class="keyword">import</span> org.hibernate.dialect.function.SQLFunctionTemplate;<span class="keyword">import</span> org.hibernate.dialect.function.StandardSQLFunction;<span class="keyword">import</span> org.hibernate.dialect.function.VarArgsSQLFunction;<span class="keyword">import</span> org.hibernate.dialect.identity.IdentityColumnSupport;<span class="keyword">import</span> org.hibernate.dialect.pagination.AbstractLimitHandler;<span class="keyword">import</span> org.hibernate.dialect.pagination.LimitHandler;<span class="keyword">import</span> org.hibernate.dialect.pagination.LimitHelper;<span class="keyword">import</span> org.hibernate.dialect.unique.DefaultUniqueDelegate;<span class="keyword">import</span> org.hibernate.dialect.unique.UniqueDelegate;<span class="keyword">import</span> org.hibernate.engine.spi.RowSelection;<span class="keyword">import</span> org.hibernate.exception.DataException;<span class="keyword">import</span> org.hibernate.exception.JDBCConnectionException;<span class="keyword">import</span> org.hibernate.exception.LockAcquisitionException;<span class="keyword">import</span> org.hibernate.exception.spi.SQLExceptionConversionDelegate;<span class="keyword">import</span> org.hibernate.exception.spi.TemplatedViolatedConstraintNameExtracter;<span class="keyword">import</span> org.hibernate.exception.spi.ViolatedConstraintNameExtracter;<span class="keyword">import</span> org.hibernate.internal.util.JdbcExceptionHelper;<span class="keyword">import</span> org.hibernate.mapping.Column;<span class="keyword">import</span> org.hibernate.type.StandardBasicTypes;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SQLiteDialect</span> <span class="keyword">extends</span> <span class="title class_">Dialect</span> &#123;    <span class="keyword">private</span> <span class="keyword">final</span> UniqueDelegate uniqueDelegate;    <span class="keyword">public</span> <span class="title function_">SQLiteDialect</span><span class="params">()</span> &#123;        registerColumnType(Types.BIT, <span class="string">&quot;boolean&quot;</span>);        registerColumnType(Types.DECIMAL, <span class="string">&quot;decimal&quot;</span>);        registerColumnType(Types.CHAR, <span class="string">&quot;char&quot;</span>);        registerColumnType(Types.LONGVARCHAR, <span class="string">&quot;longvarchar&quot;</span>);        registerColumnType(Types.TIMESTAMP, <span class="string">&quot;datetime&quot;</span>);        registerColumnType(Types.BINARY, <span class="string">&quot;blob&quot;</span>);        registerColumnType(Types.VARBINARY, <span class="string">&quot;blob&quot;</span>);        registerColumnType(Types.LONGVARBINARY, <span class="string">&quot;blob&quot;</span>);        registerFunction(<span class="string">&quot;concat&quot;</span>, <span class="keyword">new</span> <span class="title class_">VarArgsSQLFunction</span>(StandardBasicTypes.STRING, <span class="string">&quot;&quot;</span>, <span class="string">&quot;||&quot;</span>, <span class="string">&quot;&quot;</span>));        registerFunction(<span class="string">&quot;mod&quot;</span>, <span class="keyword">new</span> <span class="title class_">SQLFunctionTemplate</span>(StandardBasicTypes.INTEGER, <span class="string">&quot;?1 % ?2&quot;</span>));        registerFunction(<span class="string">&quot;quote&quot;</span>, <span class="keyword">new</span> <span class="title class_">StandardSQLFunction</span>(<span class="string">&quot;quote&quot;</span>, StandardBasicTypes.STRING));        registerFunction(<span class="string">&quot;random&quot;</span>, <span class="keyword">new</span> <span class="title class_">NoArgSQLFunction</span>(<span class="string">&quot;random&quot;</span>, StandardBasicTypes.INTEGER));        registerFunction(<span class="string">&quot;round&quot;</span>, <span class="keyword">new</span> <span class="title class_">StandardSQLFunction</span>(<span class="string">&quot;round&quot;</span>));        registerFunction(<span class="string">&quot;substr&quot;</span>, <span class="keyword">new</span> <span class="title class_">StandardSQLFunction</span>(<span class="string">&quot;substr&quot;</span>, StandardBasicTypes.STRING));        registerFunction(<span class="string">&quot;trim&quot;</span>, <span class="keyword">new</span> <span class="title class_">AbstractAnsiTrimEmulationFunction</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">protected</span> SQLFunction <span class="title function_">resolveBothSpaceTrimFunction</span><span class="params">()</span> &#123;                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQLFunctionTemplate</span>(StandardBasicTypes.STRING, <span class="string">&quot;trim(?1)&quot;</span>);            &#125;            <span class="meta">@Override</span>            <span class="keyword">protected</span> SQLFunction <span class="title function_">resolveBothSpaceTrimFromFunction</span><span class="params">()</span> &#123;                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQLFunctionTemplate</span>(StandardBasicTypes.STRING, <span class="string">&quot;trim(?2)&quot;</span>);            &#125;            <span class="meta">@Override</span>            <span class="keyword">protected</span> SQLFunction <span class="title function_">resolveLeadingSpaceTrimFunction</span><span class="params">()</span> &#123;                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQLFunctionTemplate</span>(StandardBasicTypes.STRING, <span class="string">&quot;ltrim(?1)&quot;</span>);            &#125;            <span class="meta">@Override</span>            <span class="keyword">protected</span> SQLFunction <span class="title function_">resolveTrailingSpaceTrimFunction</span><span class="params">()</span> &#123;                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQLFunctionTemplate</span>(StandardBasicTypes.STRING, <span class="string">&quot;rtrim(?1)&quot;</span>);            &#125;            <span class="meta">@Override</span>            <span class="keyword">protected</span> SQLFunction <span class="title function_">resolveBothTrimFunction</span><span class="params">()</span> &#123;                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQLFunctionTemplate</span>(StandardBasicTypes.STRING, <span class="string">&quot;trim(?1, ?2)&quot;</span>);            &#125;            <span class="meta">@Override</span>            <span class="keyword">protected</span> SQLFunction <span class="title function_">resolveLeadingTrimFunction</span><span class="params">()</span> &#123;                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQLFunctionTemplate</span>(StandardBasicTypes.STRING, <span class="string">&quot;ltrim(?1, ?2)&quot;</span>);            &#125;            <span class="meta">@Override</span>            <span class="keyword">protected</span> SQLFunction <span class="title function_">resolveTrailingTrimFunction</span><span class="params">()</span> &#123;                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQLFunctionTemplate</span>(StandardBasicTypes.STRING, <span class="string">&quot;rtrim(?1, ?2)&quot;</span>);            &#125;        &#125;);        uniqueDelegate = <span class="keyword">new</span> <span class="title class_">SQLiteUniqueDelegate</span>(<span class="built_in">this</span>);    &#125;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SQLiteDialectIdentityColumnSupport</span> <span class="variable">IDENTITY_COLUMN_SUPPORT</span> <span class="operator">=</span> <span class="keyword">new</span>            <span class="title class_">SQLiteDialectIdentityColumnSupport</span>(<span class="keyword">new</span> <span class="title class_">SQLiteDialect</span>());    <span class="meta">@Override</span>    <span class="keyword">public</span> IdentityColumnSupport <span class="title function_">getIdentityColumnSupport</span><span class="params">()</span> &#123;        <span class="keyword">return</span> IDENTITY_COLUMN_SUPPORT;    &#125;    <span class="comment">// limit/offset support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AbstractLimitHandler</span> <span class="variable">LIMIT_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbstractLimitHandler</span>() &#123;        <span class="meta">@Override</span>        <span class="keyword">public</span> String <span class="title function_">processSql</span><span class="params">(String sql, RowSelection selection)</span> &#123;            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">hasOffset</span> <span class="operator">=</span> LimitHelper.hasFirstRow(selection);            <span class="keyword">return</span> sql + (hasOffset ? <span class="string">&quot; limit ? offset ?&quot;</span> : <span class="string">&quot; limit ?&quot;</span>);        &#125;        <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsLimit</span><span class="params">()</span> &#123;            <span class="keyword">return</span> <span class="literal">true</span>;        &#125;        <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">bindLimitParametersInReverseOrder</span><span class="params">()</span> &#123;            <span class="keyword">return</span> <span class="literal">true</span>;        &#125;    &#125;;    <span class="meta">@Override</span>    <span class="keyword">public</span> LimitHandler <span class="title function_">getLimitHandler</span><span class="params">()</span> &#123;        <span class="keyword">return</span> LIMIT_HANDLER;    &#125;    <span class="comment">// lock acquisition support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsLockTimeouts</span><span class="params">()</span> &#123;        <span class="comment">// may be http://sqlite.org/c3ref/db_mutex.html ?</span>        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getForUpdateString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsOuterJoinForUpdate</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="comment">// current timestamp support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsCurrentTimestampSelection</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCurrentTimestampSelectStringCallable</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getCurrentTimestampSelectString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;select current_timestamp&quot;</span>;    &#125;    <span class="comment">// SQLException support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_BUSY</span> <span class="operator">=</span> <span class="number">5</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_LOCKED</span> <span class="operator">=</span> <span class="number">6</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_IOERR</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_CORRUPT</span> <span class="operator">=</span> <span class="number">11</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_NOTFOUND</span> <span class="operator">=</span> <span class="number">12</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_FULL</span> <span class="operator">=</span> <span class="number">13</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_CANTOPEN</span> <span class="operator">=</span> <span class="number">14</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_PROTOCOL</span> <span class="operator">=</span> <span class="number">15</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_TOOBIG</span> <span class="operator">=</span> <span class="number">18</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_CONSTRAINT</span> <span class="operator">=</span> <span class="number">19</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_MISMATCH</span> <span class="operator">=</span> <span class="number">20</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_NOTADB</span> <span class="operator">=</span> <span class="number">26</span>;    <span class="meta">@Override</span>    <span class="keyword">public</span> SQLExceptionConversionDelegate <span class="title function_">buildSQLExceptionConversionDelegate</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQLExceptionConversionDelegate</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> JDBCException <span class="title function_">convert</span><span class="params">(SQLException sqlException, String message, String sql)</span> &#123;                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">errorCode</span> <span class="operator">=</span> JdbcExceptionHelper.extractErrorCode(sqlException) &amp; <span class="number">0xFF</span>;                <span class="keyword">if</span> (errorCode == SQLITE_TOOBIG || errorCode == SQLITE_MISMATCH) &#123;                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataException</span>(message, sqlException, sql);                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errorCode == SQLITE_BUSY || errorCode == SQLITE_LOCKED) &#123;                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LockAcquisitionException</span>(message, sqlException, sql);                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((errorCode &gt;= SQLITE_IOERR &amp;&amp; errorCode &lt;= SQLITE_PROTOCOL) || errorCode == SQLITE_NOTADB) &#123;                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JDBCConnectionException</span>(message, sqlException, sql);                &#125;                <span class="comment">// returning null allows other delegates to operate</span>                <span class="keyword">return</span> <span class="literal">null</span>;            &#125;        &#125;;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> ViolatedConstraintNameExtracter <span class="title function_">getViolatedConstraintNameExtracter</span><span class="params">()</span> &#123;        <span class="keyword">return</span> EXTRACTER;    &#125;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ViolatedConstraintNameExtracter</span> <span class="variable">EXTRACTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatedViolatedConstraintNameExtracter</span>() &#123;        <span class="meta">@Override</span>        <span class="keyword">protected</span> String <span class="title function_">doExtractConstraintName</span><span class="params">(SQLException sqle)</span> <span class="keyword">throws</span> NumberFormatException &#123;            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">errorCode</span> <span class="operator">=</span> JdbcExceptionHelper.extractErrorCode(sqle) &amp; <span class="number">0xFF</span>;            <span class="keyword">if</span> (errorCode == SQLITE_CONSTRAINT) &#123;                <span class="keyword">return</span> extractUsingTemplate(<span class="string">&quot;constraint &quot;</span>, <span class="string">&quot; failed&quot;</span>, sqle.getMessage());            &#125;            <span class="keyword">return</span> <span class="literal">null</span>;        &#125;    &#125;;    <span class="comment">// union subclass support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsUnionAll</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="comment">// DDL support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canCreateSchema</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasAlterTable</span><span class="params">()</span> &#123;        <span class="comment">// As specified in NHibernate dialect</span>        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dropConstraints</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">qualifyIndexName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getAddColumnString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;add column&quot;</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getDropForeignKeyString</span><span class="params">()</span> &#123;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;No drop foreign key syntax supported by SQLiteDialect&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getAddForeignKeyConstraintString</span><span class="params">(String constraintName,</span><span class="params">                                                   String[] foreignKey, String referencedTable, String[] primaryKey,</span><span class="params">                                                   <span class="type">boolean</span> referencesPrimaryKey)</span> &#123;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;No add foreign key syntax supported by SQLiteDialect&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getAddPrimaryKeyConstraintString</span><span class="params">(String constraintName)</span> &#123;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;No add primary key syntax supported by SQLiteDialect&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsCommentOn</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsIfExistsBeforeTableName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doesReadCommittedCauseWritersToBlockReaders</span><span class="params">()</span> &#123;        <span class="comment">// TODO Validate (WAL mode...)</span>        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doesRepeatableReadCauseReadersToBlockWriters</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsTupleDistinctCounts</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getInExpressionCountLimit</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="number">1000</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> UniqueDelegate <span class="title function_">getUniqueDelegate</span><span class="params">()</span> &#123;        <span class="keyword">return</span> uniqueDelegate;    &#125;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SQLiteUniqueDelegate</span> <span class="keyword">extends</span> <span class="title class_">DefaultUniqueDelegate</span> &#123;        <span class="keyword">public</span> <span class="title function_">SQLiteUniqueDelegate</span><span class="params">(Dialect dialect)</span> &#123;            <span class="built_in">super</span>(dialect);        &#125;        <span class="meta">@Override</span>        <span class="keyword">public</span> String <span class="title function_">getColumnDefinitionUniquenessFragment</span><span class="params">(Column column)</span> &#123;            <span class="keyword">return</span> <span class="string">&quot; unique&quot;</span>;        &#125;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getSelectGUIDString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;select hex(randomblob(16))&quot;</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> ScrollMode <span class="title function_">defaultScrollMode</span><span class="params">()</span> &#123;        <span class="keyword">return</span> ScrollMode.FORWARD_ONLY;    &#125;&#125;</code></pre><h5 id="sqlitedialectidentitycolumnsupport"><a class="markdownIt-Anchor" href="#sqlitedialectidentitycolumnsupport"></a> SQLiteDialectIdentityColumnSupport</h5><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.sqlite;<span class="keyword">import</span> org.hibernate.dialect.Dialect;<span class="keyword">import</span> org.hibernate.dialect.identity.IdentityColumnSupportImpl;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SQLiteDialectIdentityColumnSupport</span> <span class="keyword">extends</span> <span class="title class_">IdentityColumnSupportImpl</span> &#123;    <span class="keyword">public</span> <span class="title function_">SQLiteDialectIdentityColumnSupport</span><span class="params">(Dialect dialect)</span> &#123;        <span class="built_in">super</span>(dialect);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsIdentityColumns</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasDataTypeInIdentityColumn</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getIdentitySelectString</span><span class="params">(String table, String column, <span class="type">int</span> type)</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;select last_insert_rowid()&quot;</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getIdentityColumnString</span><span class="params">(<span class="type">int</span> type)</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;integer&quot;</span>;    &#125;&#125;</code></pre><h5 id="sqlitemetadatabuilderinitializer"><a class="markdownIt-Anchor" href="#sqlitemetadatabuilderinitializer"></a> SQLiteMetadataBuilderInitializer</h5><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.sqlite;<span class="keyword">import</span> org.hibernate.boot.MetadataBuilder;<span class="keyword">import</span> org.hibernate.boot.registry.StandardServiceRegistry;<span class="keyword">import</span> org.hibernate.boot.spi.MetadataBuilderInitializer;<span class="keyword">import</span> org.hibernate.engine.jdbc.dialect.internal.DialectResolverSet;<span class="keyword">import</span> org.hibernate.engine.jdbc.dialect.spi.DialectResolver;<span class="keyword">import</span> org.jboss.logging.Logger;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SQLiteMetadataBuilderInitializer</span> <span class="keyword">implements</span> <span class="title class_">MetadataBuilderInitializer</span> &#123;    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(SQLiteMetadataBuilderInitializer.class);    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contribute</span><span class="params">(MetadataBuilder metadataBuilder, StandardServiceRegistry serviceRegistry)</span> &#123;        <span class="type">DialectResolver</span> <span class="variable">dialectResolver</span> <span class="operator">=</span> serviceRegistry.getService(DialectResolver.class);        <span class="keyword">if</span> (!(dialectResolver <span class="keyword">instanceof</span> DialectResolverSet)) &#123;            logger.warnf(<span class="string">&quot;DialectResolver &#x27;%s&#x27; is not an instance of DialectResolverSet, not registering SQLiteDialect&quot;</span>,                    dialectResolver);            <span class="keyword">return</span>;        &#125;        ((DialectResolverSet) dialectResolver).addResolver(resolver);    &#125;    <span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">SQLiteDialect</span> <span class="variable">dialect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SQLiteDialect</span>();    <span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">DialectResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> (DialectResolver) info -&gt; &#123;        <span class="keyword">if</span> (info.getDatabaseName().equals(<span class="string">&quot;SQLite&quot;</span>)) &#123;            <span class="keyword">return</span> dialect;        &#125;        <span class="keyword">return</span> <span class="literal">null</span>;    &#125;;&#125;</code></pre><h4 id="applicationproperties-4"><a class="markdownIt-Anchor" href="#applicationproperties-4"></a> application.properties</h4><p>对 mysql 的配置，修改到了对 sqlite 的配置</p><pre><code class="highlight properties"><span class="comment"># 配置jsp的寻找路径</span><span class="attr">spring.mvc.view.prefix</span>=<span class="string">/WEB-INF/jsp/</span><span class="attr">spring.mvc.view.suffix</span>=<span class="string">.jsp</span><span class="comment">#更改tomcat默认端口号</span><span class="attr">server.port</span>=<span class="string">8088</span><span class="comment">#更改访问上下文路径/访问路径 localhost:8088/leeBoot/...</span><span class="attr">server.context-path</span>=<span class="string">/leeBoot</span><span class="comment">#配置mysql数据源</span><span class="comment">#spring.datasource.url=jdbc:mysql://127.0.0.1:3306/lee_test?characterEncoding=UTF-8</span><span class="comment">#spring.datasource.username=root</span><span class="comment">#spring.datasource.password=admin</span><span class="comment">#spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><span class="comment">#新增数据库链接必须的参数（jpa方式要加，mybatis方式不用加）</span><span class="comment">#spring.jpa.properties.hibernate.hbm2ddl.auto=update</span><span class="comment"></span><span class="comment">#mybaits基于xml要额外加两条配置</span><span class="comment">#mybatis.mapper-locations=classpath:com/leeboer/springboot/mapper/*.xml</span><span class="comment">#mybatis.type-aliases-package=com.leeboer.springboot.pojo</span><span class="comment"></span><span class="comment">#SQLite数据库配置</span><span class="attr">spring.jpa.database-platform</span>=<span class="string">com.leeboer.sqlite.SQLiteDialect</span><span class="comment">#表结构由hibernate根据实体类来帮你创建</span><span class="attr">spring.jpa.generate-ddl</span>=<span class="string">true</span><span class="comment">#自动根据Entity配置创建表</span><span class="attr">spring.jpa.hibernate.ddl-auto</span>=<span class="string">update</span><span class="comment">#数据库文件位置,该文件没有的话会自动创建</span><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:sqlite:leeboer.db</span><span class="comment">#驱动名称</span><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">org.sqlite.JDBC</span></code></pre><h4 id="sqlite创建表添加数据"><a class="markdownIt-Anchor" href="#sqlite创建表添加数据"></a> sqlite创建表/添加数据</h4><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.sqlite;<span class="keyword">import</span> java.sql.Connection;<span class="keyword">import</span> java.sql.DriverManager;<span class="keyword">import</span> java.sql.ResultSet;<span class="keyword">import</span> java.sql.Statement;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/7/5.</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateTableCategory</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">try</span> &#123;            <span class="comment">// 加载驱动,连接sqlite的jdbc</span>            Class.forName(<span class="string">&quot;org.sqlite.JDBC&quot;</span>);            <span class="comment">// 连接数据库how2j.db,不用手动创建。。。</span>            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:sqlite:leeboer.db&quot;</span>);            <span class="comment">// 创建连接对象，是Java的一个操作数据库的重要接口</span>            <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();            <span class="comment">// 判断是否有表tables的存在。有则删除</span>            statement.executeUpdate(<span class="string">&quot;drop table if exists Category&quot;</span>);            <span class="comment">// 创建表</span>            statement.executeUpdate(<span class="string">&quot;create table Category(id int,name varchar(20))&quot;</span>);            <span class="comment">//插入数据</span>            statement.executeUpdate(<span class="string">&quot;insert into Category values(1,&#x27;Gareen&#x27;)&quot;</span>);            statement.executeUpdate(<span class="string">&quot;insert into Category values(2,&#x27;yellow&#x27;)&quot;</span>);            statement.executeUpdate(<span class="string">&quot;insert into Category values(3,&#x27;red&#x27;)&quot;</span>);            statement.executeUpdate(<span class="string">&quot;insert into Category values(4,&#x27;black&#x27;)&quot;</span>);            <span class="comment">// 搜索数据库，将搜索的放入数据集ResultSet中</span>            <span class="type">ResultSet</span> <span class="variable">rSet</span> <span class="operator">=</span> statement.executeQuery(<span class="string">&quot;select * from Category&quot;</span>);            <span class="keyword">while</span> (rSet.next()) &#123; <span class="comment">// 遍历这个数据集</span>                System.out.println(<span class="string">&quot;id：&quot;</span> + rSet.getInt(<span class="number">1</span>));                System.out.println(<span class="string">&quot;姓名：&quot;</span> + rSet.getString(<span class="number">2</span>));            &#125;            rSet.close();<span class="comment">// 关闭数据集</span>            connection.close();<span class="comment">// 关闭数据库连接</span>        &#125; <span class="keyword">catch</span> (Exception e) &#123;            <span class="comment">// TODO Auto-generated catch block</span>            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h4 id="测试运行-3"><a class="markdownIt-Anchor" href="#测试运行-3"></a> 测试运行</h4><p>配置好之后，即可基于之前的例子访问localhost:8088/leeBoot/listCategory可得到相同的结果</p><h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2><h3 id="单元测试-2"><a class="markdownIt-Anchor" href="#单元测试-2"></a> 单元测试</h3><p><u>该案例基于前面的jpa案例</u></p><p>有时候，springboot里要做单元测试，而不是直接跑起来，比如jpa章节的查询数据，想跑个测试，看看数据库里的数据，接下来讲该怎么做</p><h4 id="pomxml-5"><a class="markdownIt-Anchor" href="#pomxml-5"></a> pom.xml</h4><ol><li>修改junit版本为4.12</li><li>增加spring-boot-starter-test</li></ol><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!-- springboot test --&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h4 id="测试类"><a class="markdownIt-Anchor" href="#测试类"></a> 测试类</h4><ol><li>需要加上2个注解<ul><li>@RunWith(SpringRunner.class)</li><li>@SpringBooTest(classes=Application.class)</li></ul></li><li>自动装配CategoryDAO dao，以便使用</li><li>test方法加上@test注解，然后就可以使用dao来工作了</li><li>运行的时候选择JUnit Test方式</li></ol><pre><code class="highlight java"><span class="keyword">package</span> com.how2java.springboot.test; <span class="keyword">import</span> java.util.List; <span class="keyword">import</span> org.junit.Test;<span class="keyword">import</span> org.junit.runner.RunWith;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<span class="keyword">import</span> com.how2java.springboot.Application;<span class="keyword">import</span> com.how2java.springboot.dao.CategoryDAO;<span class="keyword">import</span> com.how2java.springboot.pojo.Category; <span class="meta">@RunWith(SpringRunner.class)</span><span class="meta">@SpringBootTest(classes = Application.class)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJPA</span> &#123;     <span class="meta">@Autowired</span> CategoryDAO dao;         <span class="meta">@Test</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;        List&lt;Category&gt; cs=  dao.findAll();        <span class="keyword">for</span> (Category c : cs) &#123;            System.out.println(<span class="string">&quot;c.getName():&quot;</span>+ c.getName());        &#125;             &#125;&#125;</code></pre><h3 id="jpa条件查询"><a class="markdownIt-Anchor" href="#jpa条件查询"></a> JPA条件查询</h3><h4 id="jpa条件查询方式"><a class="markdownIt-Anchor" href="#jpa条件查询方式"></a> JPA条件查询方式</h4><p>JPA 条件查询方式很有意思，是不需要写 SQL 语句的，只需要在 dao 接口里按照规范的命名定义对应的方法名，及可达到查询相应字段的效果了。<br />在如下代码里做了如下事情：</p><ol><li>首先通过 @Before 把 Category表里所有数据都删除了，并新增了10条。</li><li>然后 test1() 查询所有数据，看看新增的10条数据。</li><li>接着，test2() 通过自定义的接口方法 findByName，根据name 查询分类表</li><li>接着，test3() 通过自定义的接口方法 findByNameLikeAndIdGreaterThanOrderByNameAsc，根据名称模糊查询，id 大于某值, 并且名称正排序查询。</li></ol><p><strong>Category.java</strong></p><pre><code class="highlight java"><span class="keyword">import</span> javax.persistence.Column;<span class="keyword">import</span> javax.persistence.Entity;<span class="keyword">import</span> javax.persistence.GeneratedValue;<span class="keyword">import</span> javax.persistence.GenerationType;<span class="keyword">import</span> javax.persistence.Id;<span class="keyword">import</span> javax.persistence.Table; <span class="meta">@Entity</span><span class="meta">@Table(name = &quot;category_&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Category</span> &#123;     <span class="meta">@Id</span>    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>    <span class="meta">@Column(name = &quot;id&quot;)</span>    <span class="keyword">private</span> <span class="type">int</span> id;         <span class="meta">@Column(name = &quot;name&quot;)</span>    <span class="keyword">private</span> String name;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Category [id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;    &#125;     &#125;</code></pre><p><strong>CategoryDAO.java</strong></p><pre><code class="highlight java"><span class="keyword">import</span> java.util.List; <span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository; <span class="keyword">import</span> com.how2java.springboot.pojo.Category; <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CategoryDAO</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Category,Integer&gt;&#123;     <span class="keyword">public</span> List&lt;Category&gt; <span class="title function_">findByName</span><span class="params">(String name)</span>;         <span class="keyword">public</span> List&lt;Category&gt; <span class="title function_">findByNameLikeAndIdGreaterThanOrderByNameAsc</span><span class="params">(String name, <span class="type">int</span> id)</span>;&#125;</code></pre><p><strong>TestJPA.java</strong></p><pre><code class="highlight java"><span class="keyword">import</span> java.util.List; <span class="keyword">import</span> org.junit.Before;<span class="keyword">import</span> org.junit.Test;<span class="keyword">import</span> org.junit.runner.RunWith;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner; <span class="keyword">import</span> com.how2java.springboot.Application;<span class="keyword">import</span> com.how2java.springboot.dao.CategoryDAO;<span class="keyword">import</span> com.how2java.springboot.pojo.Category; <span class="meta">@RunWith(SpringRunner.class)</span><span class="meta">@SpringBootTest(classes = Application.class)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJPA</span> &#123;     <span class="meta">@Autowired</span> CategoryDAO dao;         <span class="meta">@Before</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;        List&lt;Category&gt; cs=  dao.findAll();        <span class="keyword">for</span> (Category c : cs) &#123;            dao.delete(c);        &#125;                 <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;            <span class="type">Category</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Category</span>();            c.setName(<span class="string">&quot;category &quot;</span> + i);            dao.save(c);        &#125;             &#125;         <span class="meta">@Test</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;        List&lt;Category&gt; cs=  dao.findAll();        System.out.println(<span class="string">&quot;所有的分类信息：&quot;</span>);        <span class="keyword">for</span> (Category c : cs) &#123;            System.out.println(c.getName());        &#125;        System.out.println();    &#125;         <span class="meta">@Test</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;查询名称是 \&quot;category 1 \&quot;的分类:&quot;</span>);        List&lt;Category&gt; cs=  dao.findByName(<span class="string">&quot;category 1&quot;</span>);        <span class="keyword">for</span> (Category c : cs) &#123;            System.out.println(<span class="string">&quot;c.getName():&quot;</span>+ c.getName());        &#125;        System.out.println();    &#125;    <span class="meta">@Test</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;根据名称模糊查询，id 大于5, 并且名称正排序查询&quot;</span>);        List&lt;Category&gt; cs=  dao.findByNameLikeAndIdGreaterThanOrderByNameAsc(<span class="string">&quot;%3%&quot;</span>,<span class="number">5</span>);        <span class="keyword">for</span> (Category c : cs) &#123;            System.out.println(c);        &#125;        System.out.println();             &#125;&#125;</code></pre><h4 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h4><p>虽然JPA没有自己动手写sql语句，但是通过反射获取自定义的接口方法里提供的信息，就知道用户希望根据什么条件查询了，然后 JPA 底层再偷偷摸摸地拼装对应的 sql 语句，丢给数据库，就达到了条件查询的效果啦</p><h4 id="条件查询规范"><a class="markdownIt-Anchor" href="#条件查询规范"></a> 条件查询规范</h4><p>JPA条件查询方式只是个别举例，下表把jpa做的各种查询规范都列出来了，如果要做其他相关查询，按照表格中的规范设计接口方法即可。</p><h3 id="上传文件"><a class="markdownIt-Anchor" href="#上传文件"></a> 上传文件</h3><p>先讲解一个上传图片的案例</p><h4 id="jsp-5"><a class="markdownIt-Anchor" href="#jsp-5"></a> jsp</h4><p>在jsp目录下新建uploadPage.jsp需要注意几点：</p><ol><li><code>method=&quot;post&quot;</code>是必须的</li><li><code>enctype=&quot;multipart/form-data&quot;</code>是必须的，表示提交二进制文件</li><li><code>name=&quot;file&quot;</code>是必须的，和后续服务端对应</li><li><code>accept=&quot;image/*&quot;</code>表示只选择图片</li></ol><pre><code class="highlight html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt; <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span>  选择图片:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">accept</span>=<span class="string">&quot;image/*&quot;</span> /&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span>  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></code></pre><h4 id="controller-4"><a class="markdownIt-Anchor" href="#controller-4"></a> Controller</h4><ol><li>接收上传的 文件</li></ol><pre><code class="highlight java"><span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file</code></pre><ol start="2"><li>根据时间戳创建新的文件名，防止覆盖</li></ol><pre><code class="highlight java"><span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> System.currentTimeMillis()+file.getOriginalFilename();</code></pre><ol start="3"><li>通过req.getServletContext().getRealPath(“”)获取当前项目真实路劲，然后拼接前面的文件名</li></ol><pre><code class="highlight java">String destFileName=req.getServletContext().getRealPath(<span class="string">&quot;&quot;</span>)+<span class="string">&quot;uploaded&quot;</span>+File.separator+fileName;</code></pre><ol start="4"><li>第一次运行的时候，这个文件所在的目录往往是不存在的，这里需要创建一下目录</li></ol><pre><code class="highlight java"><span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destFileName);destFile.getParentFile().mkdirs();</code></pre><ol start="5"><li>把浏览器上传的文件复制到希望的位置</li></ol><pre><code class="highlight java">file.transferTo(destFile);</code></pre><ol start="6"><li>把文件名放在model里，方便后续使用</li></ol><pre><code class="highlight java">m.addAttribute(<span class="string">&quot;fileName&quot;</span>,fileName);</code></pre><pre><code class="highlight java"><span class="keyword">package</span> com.how2java.springboot.web;<span class="keyword">import</span> java.io.File;<span class="keyword">import</span> java.io.FileNotFoundException;<span class="keyword">import</span> java.io.IOException; <span class="keyword">import</span> javax.servlet.http.HttpServletRequest; <span class="keyword">import</span> org.springframework.stereotype.Controller;<span class="keyword">import</span> org.springframework.ui.Model;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;  <span class="meta">@Controller</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;      <span class="meta">@RequestMapping(&quot;/uploadPage&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">uploadPage</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;uploadPage&quot;</span>;    &#125;         <span class="meta">@RequestMapping(value = &quot;/upload&quot;, method = RequestMethod.POST)</span>    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(HttpServletRequest req, <span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file,Model m)</span> &#123;            <span class="keyword">try</span> &#123;                <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> System.currentTimeMillis()+file.getOriginalFilename();                String destFileName=req.getServletContext().getRealPath(<span class="string">&quot;&quot;</span>)+<span class="string">&quot;uploaded&quot;</span>+File.separator+fileName;                                 <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destFileName);                destFile.getParentFile().mkdirs();                file.transferTo(destFile);                                 m.addAttribute(<span class="string">&quot;fileName&quot;</span>,fileName);            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;                e.printStackTrace();                <span class="keyword">return</span> <span class="string">&quot;上传失败,&quot;</span> + e.getMessage();            &#125; <span class="keyword">catch</span> (IOException e) &#123;                e.printStackTrace();                <span class="keyword">return</span> <span class="string">&quot;上传失败,&quot;</span> + e.getMessage();            &#125;                         <span class="keyword">return</span> <span class="string">&quot;showImg&quot;</span>;    &#125;   &#125;</code></pre><h4 id="设置上传文件的大小"><a class="markdownIt-Anchor" href="#设置上传文件的大小"></a> 设置上传文件的大小</h4><p>默认是1m，修改application.properties</p><pre><code class="highlight properties"><span class="attr">spring.mvc.view.prefix</span>=<span class="string">/WEB-INF/jsp/</span><span class="attr">spring.mvc.view.suffix</span>=<span class="string">.jsp</span><span class="attr">spring.http.multipart.maxFileSize</span>=<span class="string">100Mb</span><span class="attr">spring.http.multipart.maxRequestSize</span>=<span class="string">100Mb</span></code></pre><h3 id="restful"><a class="markdownIt-Anchor" href="#restful"></a> Restful</h3><h4 id="restful风格是什么"><a class="markdownIt-Anchor" href="#restful风格是什么"></a> Restful风格是什么</h4><p>大家在做Web开发的过程中，method常用的值是get和post. 可事实上，method值还可以是put和delete等等其他值。<br />既然method值如此丰富，那么就可以考虑使用同一个url，但是约定不同的method来实施不同的业务，这就是Restful的基本考虑。<br />CRUD是最常见的操作，在使用Restful 风格之前，通常的增加做法是这样的：</p><pre><code class="highlight plaintext">/addCategory?name=xxx</code></pre><p>可是使用了Restful风格之后，增加就变成了：</p><pre><code class="highlight plaintext">/categories</code></pre><p>CRUD如下表所示，URL就都使用一样的 “/categories”，区别只是在于method不同，服务器根据method的不同来判断浏览器期望做的业务行为</p><h4 id="listcategoryjsp"><a class="markdownIt-Anchor" href="#listcategoryjsp"></a> listCategory.jsp</h4><p>对之前的listCategory.jsp做出如下修改</p><ol><li><p>增加<br />1.1. action修改为&quot;categories&quot;</p></li><li><p>删除<br />2.1. url修改为categories/id<br />2.2 点击超链接后，会使用form提交，并且提交_method的值为delete，以达到和增加类似的效果</p></li></ol><pre><code class="highlight JavaScript">$(<span class="keyword">function</span>(<span class="params"></span>)&#123;    $(<span class="string">&quot;.delete&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;    <span class="keyword">var</span> href=$(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;href&quot;</span>);    $(<span class="string">&quot;#formdelete&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;action&quot;</span>,href).<span class="title function_">submit</span>();    <span class="keyword">return</span> <span class="literal">false</span>;    &#125;)&#125;)</code></pre><ol start="3"><li>获取<br />3.1. url修改为了/categories/id</li><li>在最开始增加了jQuery.main.js的引入</li></ol><pre><code class="highlight plaintext">&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;</code></pre><pre><code class="highlight html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;   <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>     <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">       <span class="comment">/*将post method 改变为delete*/</span></span><span class="language-javascript">      $(<span class="keyword">function</span>(<span class="params"></span>)&#123;                    </span><span class="language-javascript">           $(<span class="string">&quot;.delete&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><span class="language-javascript">               <span class="keyword">var</span> href=$(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;href&quot;</span>);</span><span class="language-javascript">               $(<span class="string">&quot;#formdelete&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;action&quot;</span>,href).<span class="title function_">submit</span>();</span><span class="language-javascript">               <span class="keyword">return</span> <span class="literal">false</span>;</span><span class="language-javascript">           &#125;)</span><span class="language-javascript">       &#125;)</span><span class="language-javascript">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>      <span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:500px;margin:20px auto;text-align: center&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">&#x27;center&#x27;</span> <span class="attr">border</span>=<span class="string">&#x27;1&#x27;</span> <span class="attr">cellspacing</span>=<span class="string">&#x27;0&#x27;</span>&gt;</span>        <span class="tag">&lt;<span class="name">tr</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>id<span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>name<span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">td</span>&gt;</span>        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>        <span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">items</span>=<span class="string">&quot;$&#123;page.content&#125;&quot;</span> <span class="attr">var</span>=<span class="string">&quot;c&quot;</span> <span class="attr">varStatus</span>=<span class="string">&quot;st&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">tr</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;c.id&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;c.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;categories/$&#123;c.id&#125;&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">href</span>=<span class="string">&quot;categories/$&#123;c.id&#125;&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>        <span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span>             <span class="tag">&lt;/<span class="name">table</span>&gt;</span>    <span class="tag">&lt;<span class="name">br</span>&gt;</span>    <span class="tag">&lt;<span class="name">div</span>&gt;</span>                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=0&quot;</span>&gt;</span>[首  页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=$&#123;page.number-1&#125;&quot;</span>&gt;</span>[上一页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=$&#123;page.number+1&#125;&quot;</span>&gt;</span>[下一页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=$&#123;page.totalPages-1&#125;&quot;</span>&gt;</span>[末  页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>    <span class="tag">&lt;<span class="name">br</span>&gt;</span>    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;categories&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span>    name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span>    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span>         <span class="tag">&lt;/<span class="name">form</span>&gt;</span>         <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;formdelete&quot;</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> &gt;</span>       <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;DELETE&quot;</span>&gt;</span>   <span class="tag">&lt;/<span class="name">form</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><h4 id="editcategoryjsp"><a class="markdownIt-Anchor" href="#editcategoryjsp"></a> editCategory.jsp</h4><p>action修改为了categories/id</p><blockquote><p>注意：form 下增加 filed, 虽然这个form的method是post, 但是springmvc看到这个_method的值是put后，会把其修改为put.</p></blockquote><pre><code class="highlight plaintext">&lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt;</code></pre><pre><code class="highlight html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isELIgnored=&quot;false&quot;%&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin:0px auto; width:500px&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;../categories/$&#123;c.id&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PUT&quot;</span>&gt;</span>name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;c.name&#125;&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;/<span class="name">form</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><h4 id="categorycontroller"><a class="markdownIt-Anchor" href="#categorycontroller"></a> CategoryController</h4><p>CRUD的RequestMapping都修改为了/categories,以前用的注解叫做@RequestMapper,现在分别叫做 GetMapper, PutMapper, PostMapper 和 DeleteMapper 用于表示接受对应的Method</p><pre><code class="highlight java"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.data.domain.Page;<span class="keyword">import</span> org.springframework.data.domain.PageRequest;<span class="keyword">import</span> org.springframework.data.domain.Pageable;<span class="keyword">import</span> org.springframework.data.domain.Sort;<span class="keyword">import</span> org.springframework.stereotype.Controller;<span class="keyword">import</span> org.springframework.ui.Model;<span class="keyword">import</span> org.springframework.web.bind.annotation.DeleteMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.PutMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam; <span class="keyword">import</span> com.how2java.springboot.dao.CategoryDAO;<span class="keyword">import</span> com.how2java.springboot.pojo.Category;  <span class="meta">@Controller</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryController</span> &#123;    <span class="meta">@Autowired</span> CategoryDAO categoryDAO;         <span class="meta">@GetMapping(&quot;/categories&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">listCategory</span><span class="params">(Model m,<span class="meta">@RequestParam(value = &quot;start&quot;, defaultValue = &quot;0&quot;)</span> <span class="type">int</span> start,<span class="meta">@RequestParam(value = &quot;size&quot;, defaultValue = &quot;5&quot;)</span> <span class="type">int</span> size)</span> <span class="keyword">throws</span> Exception &#123;        start = start&lt;<span class="number">0</span>?<span class="number">0</span>:start;        <span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sort</span>(Sort.Direction.DESC, <span class="string">&quot;id&quot;</span>);        <span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageRequest</span>(start, size, sort);        Page&lt;Category&gt; page =categoryDAO.findAll(pageable);        m.addAttribute(<span class="string">&quot;page&quot;</span>, page);        <span class="keyword">return</span> <span class="string">&quot;listCategory&quot;</span>;    &#125;     <span class="meta">@PostMapping(&quot;/categories&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">addCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryDAO.save(c);        <span class="keyword">return</span> <span class="string">&quot;redirect:/categories&quot;</span>;    &#125;    <span class="meta">@DeleteMapping(&quot;/categories/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">deleteCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryDAO.delete(c);        <span class="keyword">return</span> <span class="string">&quot;redirect:/categories&quot;</span>;    &#125;    <span class="meta">@PutMapping(&quot;/categories/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">updateCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryDAO.save(c);        <span class="keyword">return</span> <span class="string">&quot;redirect:/categories&quot;</span>;    &#125;    <span class="meta">@GetMapping(&quot;/categories/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">getCategory</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id,Model m)</span> <span class="keyword">throws</span> Exception &#123;        Category c= categoryDAO.getOne(id);        m.addAttribute(<span class="string">&quot;c&quot;</span>, c);        <span class="keyword">return</span> <span class="string">&quot;editCategory&quot;</span>;    &#125;&#125;</code></pre><h3 id="json"><a class="markdownIt-Anchor" href="#json"></a> JSON</h3><p>分别使用json的方式，提交，获取单个和获取多个</p><pre><code class="highlight plaintext">http://localhost:8080/submit.html</code></pre><pre><code class="highlight plaintext">http://localhost:8080/getOne.html</code></pre><pre><code class="highlight plaintext">http://localhost:8080/getMany.html</code></pre><h4 id="entity实体类"><a class="markdownIt-Anchor" href="#entity实体类"></a> Entity实体类</h4><p>增加一个注解：@JsonIgnoreProperties({<br />“handler”,“hibernateLazyInitializer”})，否则会出错</p><pre><code class="highlight java"> <span class="keyword">import</span> javax.persistence.Column;<span class="keyword">import</span> javax.persistence.Entity;<span class="keyword">import</span> javax.persistence.GeneratedValue;<span class="keyword">import</span> javax.persistence.GenerationType;<span class="keyword">import</span> javax.persistence.Id;<span class="keyword">import</span> javax.persistence.Table; <span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonIgnoreProperties; <span class="meta">@Entity</span><span class="meta">@Table(name = &quot;category_&quot;)</span><span class="meta">@JsonIgnoreProperties(&#123; &quot;handler&quot;,&quot;hibernateLazyInitializer&quot; &#125;)</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Category</span> &#123;     <span class="meta">@Id</span>    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>    <span class="meta">@Column(name = &quot;id&quot;)</span>    <span class="keyword">private</span> <span class="type">int</span> id;         <span class="meta">@Column(name = &quot;name&quot;)</span>    <span class="keyword">private</span> String name;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Category [id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;    &#125;     &#125;</code></pre><h4 id="controller-5"><a class="markdownIt-Anchor" href="#controller-5"></a> Controller</h4><p>控制器里提供三个方法，分别用来处理json提交，json获取单个对象，json获取多个对象</p><p><strong>@RestController</strong> 表示@ResponseBody<br />和@Controller两个注解的结合，前者的作用是标注框架，该controller中返回的http数据包不是http页面，是json或者是xml等其他数据格式（即修改http数据包包头中的相关字段）</p><p><strong>@ResquestBody</strong> 如果要接受json或xml数据，给Controller的方法参数注释该注解，根据HTTP Request Header的content-Type的内容,通过适当的HttpMessageConverter转换为JAVA类</p><pre><code class="highlight java"><span class="keyword">import</span> java.util.List; <span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.data.domain.Page;<span class="keyword">import</span> org.springframework.data.domain.PageRequest;<span class="keyword">import</span> org.springframework.data.domain.Pageable;<span class="keyword">import</span> org.springframework.data.domain.Sort;<span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<span class="keyword">import</span> org.springframework.web.bind.annotation.PutMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<span class="keyword">import</span> org.springframework.web.bind.annotation.RestController; <span class="keyword">import</span> com.how2java.springboot.dao.CategoryDAO;<span class="keyword">import</span> com.how2java.springboot.pojo.Category;  <span class="meta">@RestController</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryController</span> &#123;    <span class="meta">@Autowired</span> CategoryDAO categoryDAO;         <span class="meta">@GetMapping(&quot;/category&quot;)</span>    <span class="keyword">public</span> List&lt;Category&gt; <span class="title function_">listCategory</span><span class="params">(<span class="meta">@RequestParam(value = &quot;start&quot;, defaultValue = &quot;0&quot;)</span> <span class="type">int</span> start,<span class="meta">@RequestParam(value = &quot;size&quot;, defaultValue = &quot;5&quot;)</span> <span class="type">int</span> size)</span> <span class="keyword">throws</span> Exception &#123;        start = start&lt;<span class="number">0</span>?<span class="number">0</span>:start;        <span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sort</span>(Sort.Direction.DESC, <span class="string">&quot;id&quot;</span>);        <span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageRequest</span>(start, size, sort);        Page&lt;Category&gt; page =categoryDAO.findAll(pageable);        <span class="keyword">return</span> page.getContent();    &#125;         <span class="meta">@GetMapping(&quot;/category/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> Category <span class="title function_">getCategory</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span> <span class="keyword">throws</span> Exception &#123;        Category c= categoryDAO.getOne(id);        System.out.println(c);        <span class="keyword">return</span> c;    &#125;    <span class="meta">@PutMapping(&quot;/category&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCategory</span><span class="params">(<span class="meta">@RequestBody</span> Category category)</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;springboot接受到浏览器以JSON格式提交的数据：&quot;</span>+category);    &#125;&#125;</code></pre><h4 id="ajax"><a class="markdownIt-Anchor" href="#ajax"></a> Ajax</h4><h5 id="submithtml"><a class="markdownIt-Anchor" href="#submithtml"></a> submit.html</h5><p>访问地址</p><pre><code class="highlight plaintext">http://localhost:8080/submit.html</code></pre><p>提交成功后，在springboot控制台查看使用json方式提交的数据</p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>用AJAX以JSON方式提交数据<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>    <span class="tag">&lt;<span class="name">form</span> &gt;</span>       id：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span>       名称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;category xxx&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span>        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sender&quot;</span>&gt;</span>     <span class="tag">&lt;/<span class="name">form</span>&gt;</span>    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;messageDiv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>             <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    $(<span class="string">&#x27;#sender&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><span class="language-javascript">        <span class="keyword">var</span> id=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;id&#x27;</span>).<span class="property">value</span>;</span><span class="language-javascript">        <span class="keyword">var</span> name=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;name&#x27;</span>).<span class="property">value</span>;</span><span class="language-javascript">        <span class="keyword">var</span> category=&#123;<span class="string">&quot;name&quot;</span>:name,<span class="string">&quot;id&quot;</span>:id&#125;;</span><span class="language-javascript">        <span class="keyword">var</span> jsonData = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(category);</span><span class="language-javascript">        <span class="keyword">var</span> page=<span class="string">&quot;category&quot;</span>;</span><span class="language-javascript">          </span><span class="language-javascript">        $.<span class="title function_">ajax</span>(&#123;</span><span class="language-javascript">               <span class="attr">type</span>:<span class="string">&quot;put&quot;</span>,</span><span class="language-javascript">               <span class="attr">url</span>: page,</span><span class="language-javascript">               <span class="attr">data</span>:jsonData,</span><span class="language-javascript">               <span class="attr">dataType</span>:<span class="string">&quot;json&quot;</span>,</span><span class="language-javascript">               contentType : <span class="string">&quot;application/json;charset=UTF-8&quot;</span>,</span><span class="language-javascript">               <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">result</span>)&#123;</span><span class="language-javascript">               &#125;</span><span class="language-javascript">            &#125;);</span><span class="language-javascript">           <span class="title function_">alert</span>(<span class="string">&quot;提交成功，请在springboot控制台查看服务端接收到的数据&quot;</span>);</span><span class="language-javascript">  </span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span>     <span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><h5 id="getonehtml"><a class="markdownIt-Anchor" href="#getonehtml"></a> getOne.html</h5><p>访问地址：</p><pre><code class="highlight plaintext">http://localhost:8080/getOne.html</code></pre><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>用AJAX以JSON方式获取数据<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;通过AJAX获取一个Hero对象---&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sender&quot;</span>&gt;</span>          <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;messageDiv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>             <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    $(<span class="string">&#x27;#sender&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><span class="language-javascript">        <span class="keyword">var</span> url=<span class="string">&quot;category/10&quot;</span>;</span><span class="language-javascript">        $.<span class="title function_">get</span>(</span><span class="language-javascript">                url,</span><span class="language-javascript">                <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><span class="language-javascript">                     <span class="keyword">var</span> json=data;</span><span class="language-javascript">                     <span class="keyword">var</span> name =json.<span class="property">name</span>;</span><span class="language-javascript">                     <span class="keyword">var</span> id = json.<span class="property">id</span>;</span><span class="language-javascript">                     $(<span class="string">&quot;#messageDiv&quot;</span>).<span class="title function_">html</span>(<span class="string">&quot;分类id：&quot;</span>+ id + <span class="string">&quot;&lt;br&gt;分类名称:&quot;</span> +name );</span><span class="language-javascript">                        </span><span class="language-javascript">         &#125;); </span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span>     <span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><h5 id="getmanyhtml"><a class="markdownIt-Anchor" href="#getmanyhtml"></a> getMany.html</h5><p>访问测试地址：</p><pre><code class="highlight plaintext">http://localhost:8080/getMany.html</code></pre><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>用AJAX以JSON方式获取数据<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;通过AJAX获取多个分类对象&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sender&quot;</span>&gt;</span>          <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;messageDiv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>             <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    $(<span class="string">&#x27;#sender&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><span class="language-javascript">        <span class="keyword">var</span> url=<span class="string">&quot;category?start=0&amp;size=100&quot;</span>;</span><span class="language-javascript">        $.<span class="title function_">get</span>(</span><span class="language-javascript">                url,</span><span class="language-javascript">                <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><span class="language-javascript">                    <span class="keyword">var</span> categorys = data;</span><span class="language-javascript">                     <span class="keyword">for</span>(i <span class="keyword">in</span> categorys)&#123;</span><span class="language-javascript">                         <span class="keyword">var</span> old = $(<span class="string">&quot;#messageDiv&quot;</span>).<span class="title function_">html</span>();</span><span class="language-javascript">                         <span class="keyword">var</span> category = categorys[i];</span><span class="language-javascript">                         $(<span class="string">&quot;#messageDiv&quot;</span>).<span class="title function_">html</span>(old + <span class="string">&quot;&lt;br&gt;&quot;</span>+category.<span class="property">id</span>+<span class="string">&quot;   -----   &quot;</span>+category.<span class="property">name</span>);</span><span class="language-javascript">                     &#125;</span><span class="language-javascript">         &#125;); </span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span>     <span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><h3 id="redis-2"><a class="markdownIt-Anchor" href="#redis-2"></a> Redis</h3><p>下面的案例基于上述JPA分页教程</p><h4 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h4><p>Redis是一套key-value高性能数据库</p><h4 id="运行redis服务器"><a class="markdownIt-Anchor" href="#运行redis服务器"></a> 运行Redis服务器</h4><h4 id="pomxml-6"><a class="markdownIt-Anchor" href="#pomxml-6"></a> pom.xml</h4><p>增加对Redis支持的包</p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.how2java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  <span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  <span class="tag">&lt;<span class="name">description</span>&gt;</span>springboot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>       <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>              <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>              <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!-- servlet依赖. --&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>              <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>              <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!-- tomcat的支持.--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span> <span class="comment">&lt;!-- 这个需要为 true 热部署才有效 --&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>                 <span class="comment">&lt;!-- mysql--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>         <span class="comment">&lt;!-- jpa--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!-- redis --&gt;</span>               <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>               <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>               <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>          <span class="tag">&lt;<span class="name">version</span>&gt;</span> 4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>           <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>     <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>     <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span> <span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><h4 id="applicationproperties-5"><a class="markdownIt-Anchor" href="#applicationproperties-5"></a> application.properties</h4><p>增加redis相关配置<br />同时让hibernate的sql语句显示出来，这样才知道到底是通过Redis取到2的数据，还是依然从数据库中取得数据</p><pre><code class="highlight properties"><span class="attr">spring.mvc.view.prefix</span>=<span class="string">/WEB-INF/jsp/</span><span class="attr">spring.mvc.view.suffix</span>=<span class="string">.jsp</span><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8</span><span class="attr">spring.datasource.username</span>=<span class="string">root</span><span class="attr">spring.datasource.password</span>=<span class="string">admin</span><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span><span class="attr">spring.jpa.properties.hibernate.hbm2ddl.auto</span>=<span class="string">update</span><span class="comment"> </span><span class="comment">###########################redis#########################</span><span class="comment">#Redis数据库索引（默认为0）</span><span class="attr">spring.redis.database</span>=<span class="string">0</span><span class="comment">#Redis服务器地址</span><span class="attr">spring.redis.host</span>=<span class="string">127.0.0.1</span><span class="comment">#Redis服务器连接端口</span><span class="attr">spring.redis.port</span>=<span class="string">6379</span><span class="comment">#Redis服务器连接密码（默认为空）</span><span class="attr">spring.redis.password</span>=<span class="string"></span><span class="comment">#连接池最大连接数（使用负值表示没有限制）</span><span class="attr">spring.redis.pool.max-active</span>=<span class="string">10</span><span class="comment">#连接池最大阻塞等待时间（使用负值表示没有限制）</span><span class="attr">spring.redis.pool.max-wait</span>=<span class="string">-1</span><span class="comment">#连接池中的最大空闲连接</span><span class="attr">spring.redis.pool.max-idle</span>=<span class="string">8</span><span class="comment">#连接池中的最小空闲连接</span><span class="attr">spring.redis.pool.min-idle</span>=<span class="string">0</span><span class="comment">#连接超时时间（毫秒）</span><span class="attr">spring.redis.timeout</span>=<span class="string">0</span> <span class="attr">spring.jpa.show-sql</span>=<span class="string">true</span></code></pre><h4 id="application"><a class="markdownIt-Anchor" href="#application"></a> Application</h4><p>增加注解，以开启缓存</p><pre><code class="highlight plaintext">@EnableCaching</code></pre><pre><code class="highlight java"><span class="keyword">package</span> com.how2java.springboot;  <span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;  <span class="meta">@SpringBootApplication</span><span class="meta">@EnableCaching</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(Application.class, args);    &#125;  &#125;</code></pre><h4 id="redisconfigjava"><a class="markdownIt-Anchor" href="#redisconfigjava"></a> RedisConfig.java</h4><p>Redis缓存配置类<br />这个配置，一个作用：让保存到Redis里的key和value都转换为刻度的json格式，否则会是二进制格式，通过RedisClient工具也无法识别</p><pre><code class="highlight java"><span class="keyword">package</span> com.how2java.springboot.config;<span class="keyword">import</span> org.springframework.cache.CacheManager;<span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;<span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;<span class="keyword">import</span> org.springframework.context.annotation.Bean;<span class="keyword">import</span> org.springframework.context.annotation.Configuration;<span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;<span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;<span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;<span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer; <span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;<span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;<span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper; <span class="comment">//该注解的意思是表示该类是一个spring配置类，相当于给spriApplication.xml中加一句话</span><span class="meta">@Configuration</span><span class="meta">@EnableCaching</span><span class="comment">//Redis 缓存配置类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;     <span class="meta">@Bean</span>    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisTemplate&lt;?,?&gt; redisTemplate)</span> &#123;        <span class="type">RedisSerializer</span> <span class="variable">stringSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.PUBLIC_ONLY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        redisTemplate.setKeySerializer(stringSerializer);        redisTemplate.setHashKeySerializer(stringSerializer);                   redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);                 redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);        <span class="type">CacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisCacheManager</span>(redisTemplate);        <span class="keyword">return</span> cacheManager;      &#125;&#125;</code></pre><h4 id="page4navigator"><a class="markdownIt-Anchor" href="#page4navigator"></a> Page4Navigator</h4><p>创建一个工具类 Page4Navigator 用以替换 原本分页查询要返回的 org.springframework.data.domain.Page 类。 原因是 Page 类对json 还原不支持，在放如 Redis 之后，再拿出来，就会报错失败。</p><p>使用 Page4Navigator 对其包裹，就解决了这个问题了。</p><pre><code class="highlight java"><span class="keyword">package</span> com.how2java.springboot.util; <span class="keyword">import</span> java.util.List; <span class="keyword">import</span> org.springframework.data.domain.Page; <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Page4Navigator</span>&lt;T&gt; &#123;    Page&lt;T&gt; page4jpa;    <span class="type">int</span> navigatePages;         <span class="type">int</span> totalPages;     <span class="type">int</span> number;         <span class="type">long</span> totalElements;         <span class="type">int</span> size;     <span class="type">int</span> numberOfElements;     List&lt;T&gt; content;     <span class="type">boolean</span> isHasContent;     <span class="type">boolean</span> first;     <span class="type">boolean</span> last;         <span class="type">boolean</span> isHasNext;     <span class="type">boolean</span> isHasPrevious;         <span class="type">int</span>[] navigatepageNums;         <span class="keyword">public</span> <span class="title function_">Page4Navigator</span><span class="params">()</span> &#123;        <span class="comment">//这个空的分页是为了 Redis 从 json格式转换为 Page4Navigator 对象而专门提供的</span>    &#125;         <span class="keyword">public</span> <span class="title function_">Page4Navigator</span><span class="params">(Page&lt;T&gt; page4jpa,<span class="type">int</span> navigatePages)</span> &#123;        <span class="built_in">this</span>.page4jpa = page4jpa;        <span class="built_in">this</span>.navigatePages = navigatePages;                 totalPages = page4jpa.getTotalPages();                 number  = page4jpa.getNumber() ;                 totalElements = page4jpa.getTotalElements();                 size = page4jpa.getSize();                 numberOfElements = page4jpa.getNumberOfElements();                 content = page4jpa.getContent();                 isHasContent = page4jpa.hasContent();                         first = page4jpa.isFirst();                 last = page4jpa.isLast();                 isHasNext = page4jpa.hasNext();                 isHasPrevious  = page4jpa.hasPrevious();                        calcNavigatepageNums();             &#125;     <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">calcNavigatepageNums</span><span class="params">()</span> &#123;        <span class="type">int</span> navigatepageNums[];        <span class="type">int</span> <span class="variable">totalPages</span> <span class="operator">=</span> getTotalPages();        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> getNumber();        <span class="comment">//当总页数小于或等于导航页码数时</span>        <span class="keyword">if</span> (totalPages &lt;= navigatePages) &#123;            navigatepageNums = <span class="keyword">new</span> <span class="title class_">int</span>[totalPages];            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalPages; i++) &#123;                navigatepageNums[i] = i + <span class="number">1</span>;            &#125;        &#125; <span class="keyword">else</span> &#123; <span class="comment">//当总页数大于导航页码数时</span>            navigatepageNums = <span class="keyword">new</span> <span class="title class_">int</span>[navigatePages];            <span class="type">int</span> <span class="variable">startNum</span> <span class="operator">=</span> num - navigatePages / <span class="number">2</span>;            <span class="type">int</span> <span class="variable">endNum</span> <span class="operator">=</span> num + navigatePages / <span class="number">2</span>;             <span class="keyword">if</span> (startNum &lt; <span class="number">1</span>) &#123;                startNum = <span class="number">1</span>;                <span class="comment">//(最前navigatePages页</span>                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; navigatePages; i++) &#123;                    navigatepageNums[i] = startNum++;                &#125;            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (endNum &gt; totalPages) &#123;                endNum = totalPages;                <span class="comment">//最后navigatePages页</span>                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> navigatePages - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;                    navigatepageNums[i] = endNum--;                &#125;            &#125; <span class="keyword">else</span> &#123;                <span class="comment">//所有中间页</span>                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; navigatePages; i++) &#123;                    navigatepageNums[i] = startNum++;                &#125;            &#125;        &#125;          <span class="built_in">this</span>.navigatepageNums = navigatepageNums;    &#125;     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNavigatePages</span><span class="params">()</span> &#123;        <span class="keyword">return</span> navigatePages;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNavigatePages</span><span class="params">(<span class="type">int</span> navigatePages)</span> &#123;        <span class="built_in">this</span>.navigatePages = navigatePages;    &#125;     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTotalPages</span><span class="params">()</span> &#123;        <span class="keyword">return</span> totalPages;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTotalPages</span><span class="params">(<span class="type">int</span> totalPages)</span> &#123;        <span class="built_in">this</span>.totalPages = totalPages;    &#125;     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span> &#123;        <span class="keyword">return</span> number;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">(<span class="type">int</span> number)</span> &#123;        <span class="built_in">this</span>.number = number;    &#125;     <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTotalElements</span><span class="params">()</span> &#123;        <span class="keyword">return</span> totalElements;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTotalElements</span><span class="params">(<span class="type">long</span> totalElements)</span> &#123;        <span class="built_in">this</span>.totalElements = totalElements;    &#125;     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;        <span class="keyword">return</span> size;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSize</span><span class="params">(<span class="type">int</span> size)</span> &#123;        <span class="built_in">this</span>.size = size;    &#125;     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumberOfElements</span><span class="params">()</span> &#123;        <span class="keyword">return</span> numberOfElements;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNumberOfElements</span><span class="params">(<span class="type">int</span> numberOfElements)</span> &#123;        <span class="built_in">this</span>.numberOfElements = numberOfElements;    &#125;     <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">getContent</span><span class="params">()</span> &#123;        <span class="keyword">return</span> content;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(List&lt;T&gt; content)</span> &#123;        <span class="built_in">this</span>.content = content;    &#125;     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHasContent</span><span class="params">()</span> &#123;        <span class="keyword">return</span> isHasContent;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHasContent</span><span class="params">(<span class="type">boolean</span> isHasContent)</span> &#123;        <span class="built_in">this</span>.isHasContent = isHasContent;    &#125;     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFirst</span><span class="params">()</span> &#123;        <span class="keyword">return</span> first;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(<span class="type">boolean</span> first)</span> &#123;        <span class="built_in">this</span>.first = first;    &#125;     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLast</span><span class="params">()</span> &#123;        <span class="keyword">return</span> last;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLast</span><span class="params">(<span class="type">boolean</span> last)</span> &#123;        <span class="built_in">this</span>.last = last;    &#125;     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHasNext</span><span class="params">()</span> &#123;        <span class="keyword">return</span> isHasNext;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHasNext</span><span class="params">(<span class="type">boolean</span> isHasNext)</span> &#123;        <span class="built_in">this</span>.isHasNext = isHasNext;    &#125;     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHasPrevious</span><span class="params">()</span> &#123;        <span class="keyword">return</span> isHasPrevious;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHasPrevious</span><span class="params">(<span class="type">boolean</span> isHasPrevious)</span> &#123;        <span class="built_in">this</span>.isHasPrevious = isHasPrevious;    &#125;     <span class="keyword">public</span> <span class="type">int</span>[] getNavigatepageNums() &#123;        <span class="keyword">return</span> navigatepageNums;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNavigatepageNums</span><span class="params">(<span class="type">int</span>[] navigatepageNums)</span> &#123;        <span class="built_in">this</span>.navigatepageNums = navigatepageNums;    &#125; &#125;</code></pre><h4 id="categoryserviceimpl"><a class="markdownIt-Anchor" href="#categoryserviceimpl"></a> CategoryServiceImpl</h4><p>实现类CategoryService做了以下工作：</p><ol><li>实现CategoryService接口，提供crud</li><li>在相应方法实现的时候，都是通过调用dao实现的</li><li>CacheConfig，表示分类数据在redis中都放在category这个分组里</li></ol><pre><code class="highlight plaintext">@CacheConfig(cacheNames=&quot;category&quot;)</code></pre><ol start="4"><li>list方法讲解<br /><strong>#p0是指在加有@Cacheable注解的方法中的第一个参数，比如上述list(Pageable pageable)中第一个参数就是pageable。#p0.offset相当于pageable.offset的意思</strong></li></ol><pre><code class="highlight plaintext">@Cacheable(key=&quot;&#x27;category &#x27;+#p0.offset + &#x27;-&#x27; + #p0.pageSize &quot;)</code></pre><p>假如是第一页，即offset=0，pageSize=5，那么会创建一个 key: “category 0-5”<br />首先根据这个key 到 redis中查询数据。 第一次是不会有数据的，那么就会从数据库中取到这5条数据，然后以这个 key: “category 0-5” 保存到 redis 数据库中。<br />下一次再次访问的时候，根据这个key，就可以从 redis 里取到数据了</p><ol start="5"><li>get方法注解</li></ol><pre><code class="highlight plaintext">@Cacheable(key=&quot;&#x27;category &#x27;+ #p0&quot;)</code></pre><p>假如是获取id=71的数据，那么就会以 key= “category 71” 到reids中去获取，如果没有就会从数据库中拿到，然后再以 key= “category 71” 这个值存放到 redis 当中。</p><p>下一次再次访问的时候，根据这个key，就可以从 redis 里取到数据了</p><ol start="6"><li>add方法讲解</li></ol><pre><code class="highlight plaintext">@CacheEvict(allEntries=true)// @CachePut(key=&quot;&#x27;category &#x27;+ #p0&quot;)</code></pre><p>可以看到，本来有个 CachePut，但是被注释掉了。 按理说，本来是应该用这个的。 这样会到在，在增加数据之后，就会在Redis 中以 key= “category 71” 缓存一条数据。 但是为什么被注释掉不用呢？</p><p>因为加入这样做了，那么 list 对应的数据，在缓存在对应的数据，并没有发生变化呀？ 因为 list 对应的数据是这样的 key: “category 0-5”。 如果用这种方式，就会导致数据不同步，即，虽然增加了，并且也增加到缓存中了，但是因为 key 不一样，通过查询拿到的数据，是不会包含新的这一条的。</p><p>所以，才会使用CacheEvict 这个注解，这个注解就表示清除掉缓存。 allEntries= true 是表示清除掉 category 分组 下所有的keys. 注意看截图，里面有一个 category~keys ，里面就表明了都有哪些 keys,都会被清除掉。</p><p>假如这个时候，还有一个分组 cacheNames=“product”, 那么它下面对应的缓存，都是不会被影响到的。 这样就保证了，只清楚当前分组下的缓存，而不是清除 redis 所有的数据了<br />7. delete方法讲解</p><pre><code class="highlight plaintext">@CacheEvict(allEntries=true)// @CacheEvict(key=&quot;&#x27;category &#x27;+ #p0&quot;)</code></pre><p>这个道理和 add 是一样的，仅仅删除 key= “category 71” ，没有什么意义， key: “category 0-5” 里面的数据没有影响呀。 所以还是通过 CacheEvict删除掉所有的缓存就好了</p><pre><code class="highlight java"><span class="keyword">package</span> com.how2java.springboot.service.impl; <span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.cache.annotation.CacheConfig;<span class="keyword">import</span> org.springframework.cache.annotation.CacheEvict;<span class="keyword">import</span> org.springframework.cache.annotation.CachePut;<span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;<span class="keyword">import</span> org.springframework.data.domain.Page;<span class="keyword">import</span> org.springframework.data.domain.Pageable;<span class="keyword">import</span> org.springframework.stereotype.Service; <span class="keyword">import</span> com.how2java.springboot.dao.CategoryDAO;<span class="keyword">import</span> com.how2java.springboot.pojo.Category;<span class="keyword">import</span> com.how2java.springboot.service.CategoryService;<span class="keyword">import</span> com.how2java.springboot.util.Page4Navigator; <span class="meta">@Service</span><span class="meta">@CacheConfig(cacheNames=&quot;category&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CategoryService</span>&#123;     <span class="meta">@Autowired</span> CategoryDAO categoryDAO;         <span class="meta">@Override</span>    <span class="meta">@Cacheable(key=&quot;&#x27;category &#x27;+#p0.offset + &#x27;-&#x27; + #p0.pageSize &quot;)</span>    <span class="keyword">public</span> Page4Navigator&lt;Category&gt; <span class="title function_">list</span><span class="params">(Pageable pageable)</span> &#123;        Page&lt;Category&gt; pageFromJPA=  categoryDAO.findAll(pageable);        Page4Navigator&lt;Category&gt; page = <span class="keyword">new</span> <span class="title class_">Page4Navigator</span>&lt;&gt;(pageFromJPA,<span class="number">5</span>);        <span class="keyword">return</span> page;    &#125;     <span class="meta">@Override</span>    <span class="meta">@Cacheable(key=&quot;&#x27;category &#x27;+ #p0&quot;)</span>    <span class="keyword">public</span> Category <span class="title function_">get</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="type">Category</span> <span class="variable">c</span> <span class="operator">=</span>categoryDAO.findOne(id);        <span class="keyword">return</span> c;    &#125;           <span class="meta">@Override</span>    <span class="meta">@CacheEvict(allEntries=true)</span><span class="comment">//  @CachePut(key=&quot;&#x27;category &#x27;+ #p0&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Category category)</span> &#123;        <span class="comment">// TODO Auto-generated method stub</span>        categoryDAO.save(category);    &#125;         <span class="meta">@Override</span>    <span class="meta">@CacheEvict(allEntries=true)</span><span class="comment">//  @CacheEvict(key=&quot;&#x27;category &#x27;+ #p0&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="comment">// TODO Auto-generated method stub</span>        categoryDAO.delete(id);    &#125; &#125;</code></pre><h4 id="categorycontroller-2"><a class="markdownIt-Anchor" href="#categorycontroller-2"></a> CategoryController</h4><p>由原来的从dao获取，变为了从Service获取</p><pre><code class="highlight java"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.data.domain.PageRequest;<span class="keyword">import</span> org.springframework.data.domain.Pageable;<span class="keyword">import</span> org.springframework.data.domain.Sort;<span class="keyword">import</span> org.springframework.stereotype.Controller;<span class="keyword">import</span> org.springframework.ui.Model;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam; <span class="keyword">import</span> com.how2java.springboot.pojo.Category;<span class="keyword">import</span> com.how2java.springboot.service.CategoryService;<span class="keyword">import</span> com.how2java.springboot.util.Page4Navigator;  <span class="meta">@Controller</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryController</span> &#123;    <span class="meta">@Autowired</span> CategoryService categoryService;         <span class="meta">@RequestMapping(&quot;/listCategory&quot;)</span>         <span class="keyword">public</span> String <span class="title function_">listCategory</span><span class="params">(Model m,<span class="meta">@RequestParam(value = &quot;start&quot;, defaultValue = &quot;0&quot;)</span> <span class="type">int</span> start,<span class="meta">@RequestParam(value = &quot;size&quot;, defaultValue = &quot;5&quot;)</span> <span class="type">int</span> size)</span> <span class="keyword">throws</span> Exception &#123;        start = start&lt;<span class="number">0</span>?<span class="number">0</span>:start;        <span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sort</span>(Sort.Direction.DESC, <span class="string">&quot;id&quot;</span>);        <span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageRequest</span>(start, size, sort);        Page4Navigator&lt;Category&gt; page =categoryService.list(pageable);        m.addAttribute(<span class="string">&quot;page&quot;</span>, page);        <span class="keyword">return</span> <span class="string">&quot;listCategory&quot;</span>;    &#125;     <span class="meta">@RequestMapping(&quot;/addCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">addCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryService.save(c);        <span class="keyword">return</span> <span class="string">&quot;redirect:listCategory&quot;</span>;    &#125;    <span class="meta">@RequestMapping(&quot;/deleteCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">deleteCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryService.delete(c.getId());        <span class="keyword">return</span> <span class="string">&quot;redirect:listCategory&quot;</span>;    &#125;    <span class="meta">@RequestMapping(&quot;/updateCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">updateCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryService.save(c);        <span class="keyword">return</span> <span class="string">&quot;redirect:listCategory&quot;</span>;    &#125;    <span class="meta">@RequestMapping(&quot;/editCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">ediitCategory</span><span class="params">(<span class="type">int</span> id,Model m)</span> <span class="keyword">throws</span> Exception &#123;        Category c= categoryService.get(id);        m.addAttribute(<span class="string">&quot;c&quot;</span>, c);        <span class="keyword">return</span> <span class="string">&quot;editCategory&quot;</span>;    &#125;&#125;</code></pre>]]>
    </content>
    <id>http://example.com/2023/07/02/Spring-Boot/</id>
    <link href="http://example.com/2023/07/02/Spring-Boot/"/>
    <published>2023-07-02T04:00:00.000Z</published>
    <summary>Spring Boot是一个基于Spring的套件，它帮我们预组装了Spring的一系列组件，以便以尽可能少的代码和配置来开发基于Spring的Java应用程序。</summary>
    <title>Spring Boot</title>
    <updated>2026-02-27T01:23:04.125Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    <content>
      <![CDATA[<h1 id="spring-aop"><a class="markdownIt-Anchor" href="#spring-aop"></a> $Spring AOP</h1><h1 id="spring-aop-2"><a class="markdownIt-Anchor" href="#spring-aop-2"></a> Spring AOP</h1><ul><li><a href="">Spring AOP</a><ul><li><a href="">AOP</a><ul><li><a href="">意图</a></li><li><a href="">实现原理</a></li><li><a href="">作用/优势</a></li><li><a href="">Spring 框架的AOP</a><ul><li><a href="">AOP术语</a></li></ul></li></ul></li><li><a href="">AOP实现类型</a><ul><li><a href="">类型</a><ul><li><a href="">Spring自身实现</a></li><li><a href="">AspectJ实现</a></li></ul></li><li><a href="">AOP实现之AspectJ</a></li><li><a href="">AOP实现之Spring AOP</a><ul><li><a href="">代理模式实现步骤</a></li><li><a href="">动态代理技术</a><ul><li><a href="">JDK动态代理</a></li><li><a href="">CGLib动态代理</a></li></ul></li><li><a href="">Spring AOP：简化代理模式实现步骤</a></li></ul></li></ul></li><li><a href="">Spring AOP 使用</a><ul><li><a href="">编程式AOP ProxyFactory</a><ul><li><a href="">创建代理工厂，设置被代理对象，添加通知</a></li></ul></li><li><a href="">声明式AOP ProxyFactoryBean</a><ul><li><a href="">Advice</a><ul><li><a href="">定义接口</a></li><li><a href="">实现接口</a></li><li><a href="">定义Advice</a></li><li><a href="">使用IOC配置的方式实现代理</a></li><li><a href="">小结</a></li></ul></li><li><a href="">Advisor 顾问</a><ul><li><a href="">声明接口</a></li><li><a href="">接口实现</a></li><li><a href="">切面Advice</a></li><li><a href="">ClassFilter 类拦截器</a></li><li><a href="">MethodMatcher 方法拦截器</a></li><li><a href="">PointCut</a></li><li><a href="">PointCutAdvisor</a></li><li><a href="">spring配置文件</a></li></ul></li></ul></li></ul></li><li><a href="">AspectJ AOP（一般使用该方式）</a><ul><li><a href="">AspectJ的XML实现AOP</a><ul><li><a href="">实现步骤</a><ul><li><a href="">编写目标类</a></li><li><a href="">maven依赖</a></li><li><a href="">编写一个advice（通知）</a></li><li><a href="">配置通知</a></li><li><a href="">配置AOP切面</a></li></ul></li><li><a href="">切入点表达式</a></li><li><a href="">通知类型</a></li><li><a href="">XML实现Spring AOP 案例</a></li></ul></li><li><a href="">AspectJ的注解实现AOP</a><ul><li><a href="">实现步骤</a><ul><li><a href="">编写目标类</a></li><li><a href="">开启AOP自动代理</a></li><li><a href="">编写Aspect（切面）类</a></li><li><a href="">配置切面类</a></li></ul></li><li><a href="">其他注解使用方式</a></li><li><a href="">环绕通知注解配置（特殊）</a></li><li><a href="">定义通用切入点</a></li><li><a href="">零注解配置</a></li><li><a href="">原理</a></li><li><a href="">案例:注解配置AOP</a></li><li><a href="">AspectJ切点函数</a><ul><li><a href="">表达式类型</a></li><li><a href="">使用示例，案例</a></li><li><a href="">表达式组合</a></li></ul></li><li><a href="">自定义注解装配AOP</a></li></ul></li></ul></li></ul></li></ul><h2 id="aop"><a class="markdownIt-Anchor" href="#aop"></a> AOP</h2><p>在软件业，AOP意为面向切面编程，通过<strong>预编译方式</strong>或<strong>运行期动态代理</strong>实现程序功能的统一维护的一种技术，AOP是OOP的延续，是软件开发中的一个热点，也是spring框架中的一个重要内容，是函数式编程的一种衍生泛型，利用AOP可以对业务逻辑的各个部分进行隔离，从而是的业务逻辑各部分之间耦合度降低，提高程序的可重用性，同时提高了开发的效率</p><h3 id="意图"><a class="markdownIt-Anchor" href="#意图"></a> 意图</h3><ul><li>将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码</li></ul><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>AOP可以说是对OOP的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码，属于静态代理</p><p>在Java平台上，对于AOP的织入，有3种方式：</p><ul><li>编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ就扩展了Java编译器，使用关键字aspect来实现织入；</li><li>类加载器：在目标类被装载到JVM时，通过一个特殊的类加载器，对目标类的字节码重新“增强”；</li><li>运行期：目标对象和切面都是普通Java类，通过JVM的动态代理功能或者第三方库实现运行期动态织入。</li></ul><p>最简单的方式是第三种，Spring的AOP实现就是基于JVM的动态代理。由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过CGLIB或者Javassist这些第三方库实现。</p><h3 id="作用优势"><a class="markdownIt-Anchor" href="#作用优势"></a> 作用/优势</h3><p><strong>作用：</strong></p><p>AOP采取横向抽取机制，取代了传统纵向继承体系的重复性代码（性能监视，事务管理，安全检查，缓存）</p><p>在程序运行期间，不修改源码对已有方法进行增强</p><p>将业务逻辑和系统处理的代码（关闭连接，事务管理，操作日志记录）解耦</p><p><strong>优势：</strong></p><ul><li>减少重复代码</li><li>提高开发效率</li><li>维护方便</li></ul><h3 id="spring-框架的aop"><a class="markdownIt-Anchor" href="#spring-框架的aop"></a> Spring 框架的AOP</h3><ul><li>Spring 框架的一个关键组件是<strong>面向方面的编程</strong>(AOP)框架。面向方面的编程需要把程序逻辑分解成不同的部分称为所谓的关注点。跨一个应用程序的多个点的功能被称为<strong>横切关注点</strong>，这些横切关注点在概念上独立于应用程序的业务逻辑。有各种各样的常见的很好的方面的例子，如日志记录、审计、声明式事务、安全性和缓存等。</li><li>在 OOP 中，关键单元模块度是类，而在 AOP 中单元模块度是方面。依赖注入帮助你对应用程序对象相互解耦和 AOP 可以帮助你从它们所影响的对象中对横切关注点解耦。</li><li><strong>横切关注点：</strong> 跨越应用程序的多个模块的方法或功能。（软件系统，可以看做由一组关注点即业务或功能或方法组成，其中，直接的业务关注点是直切关注点，而为直切关注点服务的，就是横切关注点），即与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点</li></ul><h4 id="aop术语"><a class="markdownIt-Anchor" href="#aop术语"></a> AOP术语</h4><table><thead><tr><th>顶</th><th>描述</th></tr></thead><tbody><tr><td>切面(Aspect)</td><td>是切入点和通知的结合</td></tr><tr><td>目标(Target)</td><td>被通知的对象，即业务类的对象</td></tr><tr><td>代理(Proxy)</td><td>一个类被AOP织入增强后，就产生一个结果代理类</td></tr><tr><td>切入点(PointCut)</td><td>切面通知执行的“地点”的定义；目标对象中真正被切面织入的方法，切入点一定是连接点，但连接点不一定是切入点，被标记为final的方法是不能作用连接点与切入点的</td></tr><tr><td>连接点(JointPoint)</td><td>与切入点匹配的执行点，即目标对象中可以被切面（次要业务）织入的方法，所有要监控的方法都称为连接点，就是<strong>接口中的方法</strong></td></tr><tr><td>通知(Advice)</td><td>通知是切面（次要业务）的一种，可以完成简单的织入功能。通知可以定义切面织入的时间点，切入点定义了切面织入的位置；<strong>针对一个接口中的所有方法，不够灵活</strong></td></tr><tr><td>顾问(Advisor)</td><td>顾问是切面（次要业务）的一种，能够将通知以更为复杂的的方式织入到目标对象中，是将通知包装为更复杂的切面的装配器</td></tr></tbody></table><h2 id="aop实现类型"><a class="markdownIt-Anchor" href="#aop实现类型"></a> AOP实现类型</h2><h3 id="类型"><a class="markdownIt-Anchor" href="#类型"></a> 类型</h3><h4 id="spring自身实现"><a class="markdownIt-Anchor" href="#spring自身实现"></a> Spring自身实现</h4><ol><li><strong>ProxyFactory</strong>：编程式使用AOP</li><li><strong>ProxyFactoryBean</strong>：声明式使用AOP，专门生成代理对象的工厂<ul><li><strong>Advice通知</strong> 使用更简单</li><li><strong>Advisor顾问</strong> 操纵更灵活</li></ul></li></ol><blockquote><p>底层又分为<strong>JDK动态代理实现</strong> 和 <strong>CGLib动态代理实现</strong></p></blockquote><h4 id="aspectj实现"><a class="markdownIt-Anchor" href="#aspectj实现"></a> AspectJ实现</h4><ol><li><strong>AspectJProxyFactory</strong>：集成spring与Aspect实现AOP</li></ol><ul><li><strong>这三个类都继承自</strong><ul><li>ProxyConfig：提供配置属性</li><li>AdvisedSupport：封装了通知与通知器</li><li>ProxyCreatorSupport：代理对象创建的辅助类</li></ul></li></ul><h3 id="aop实现之aspectj"><a class="markdownIt-Anchor" href="#aop实现之aspectj"></a> AOP实现之AspectJ</h3><p>AspectJ是一个java实现的AOP框架，它能够对java代码进行AOP编译（一般在编译期进行），让java代码具有AspectJ的AOP功能（当然需要特殊的编译器）</p><p>可以这样说AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言，更幸运的是，AspectJ与java程序完全兼容，几乎是无缝关联，因此对于有java编程基础的工程师，上手和使用都非常容易。</p><p>了解AspectJ应用到java代码的过程（这个过程称为织入），对于织入这个概念，可以简单理解为aspect(切面)应用到目标函数(类)的过程。</p><p>对于这个过程，<strong>一般分为动态织入和静态织入，动态织入的方式是在运行时动态将要增强的代码织入到目标类中</strong>，这样往往是通过动态代理技术完成的，如Java JDK的动态代理(Proxy，底层通过反射实现)或者CGLIB的动态代理(底层通过继承实现)，Spring AOP采用的就是基于运行时增强的代理技术</p><p><strong>ApectJ采用的就是静态织入的方式</strong>。ApectJ主要采用的是编译期织入，在这个期间使用AspectJ的acj编译器(类似javac)把aspect类编译成class字节码后，在java目标类编译时织入，即先编译aspect类再编译目标类。</p><p><strong>spring整合了ApectJ框架，但是底层没有使用acj编译器，而是使用动态代理技术</strong></p><h3 id="aop实现之spring-aop"><a class="markdownIt-Anchor" href="#aop实现之spring-aop"></a> AOP实现之Spring AOP</h3><p><strong>本质目的就是对代理模式的简化，为了方便开发人员简化代理模式的实现，统一管理</strong></p><p>spring AOP是通过<strong>动态代理技术实现</strong>的</p><ul><li>动态代理技术（反射）：<strong>基于JDK的动态代理</strong>和使用<strong>CGLib的动态代理</strong></li><li>动态代理方式选择：根据是否实现接口来选择哪种代理方式</li></ul><h4 id="代理模式实现步骤"><a class="markdownIt-Anchor" href="#代理模式实现步骤"></a> 代理模式实现步骤</h4><ol><li>声明接口：注册需要被监听行为的名称</li><li>接口实现类：扮演被监控的类，负责被监听方法实现细节</li><li>InvocationHanler接口实现类：<ul><li>次要业务/增强业务</li><li>将次要业务与被监听方法绑定执行</li></ul></li><li>代理监控对象：<ul><li>被监控类内存地址，被监控类实现的接口，InvocationHanler实现类的实例对象</li></ul></li></ol><h4 id="动态代理技术"><a class="markdownIt-Anchor" href="#动态代理技术"></a> 动态代理技术</h4><ol><li>基于JDK（实现接口）</li><li>使用CGLib（都可以使用）</li></ol><p>Spring两种动态代理技术都有使用，通过是否实现接口来判断用哪个动态代理技术</p><h5 id="jdk动态代理"><a class="markdownIt-Anchor" href="#jdk动态代理"></a> JDK动态代理</h5><p><strong>目标对象必须实现接口</strong></p><p>使用Proxy类来生成代理对象的代码如下：</p><pre><code class="highlight plaintext">    /**     * 使用JDK的方式生成代理对象     * @author Administrator     */    public class MyProxyUtils &#123;        public static UserService getProxy(final UserService service) &#123;//Porxy是JDK中的API类//第一个参数：目标队形的类加载器//第二个参数：目标对象的接口//第三个参数：代理对象的执行处理器            // 使用Proxy类生成代理对象            UserService proxy =                  (UserService) Proxy.newProxyInstance(                    service.getClass().getClassLoader(),                    service.getClass().getInterfaces(),                     new InvocationHandler() &#123;                        // 代理对象方法一执行，invoke方法就会执行一次                        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                            if(&quot;save&quot;.equals(method.getName()))&#123;                                System.out.println(&quot;记录日志...&quot;);                                // 开启事务                            &#125;                            // 提交事务                            // 让service类的save或者update方法正常的执行下去                            return method.invoke(service, args);                        &#125;                    &#125;);            // 返回代理对象            return proxy;        &#125;    &#125;</code></pre><h5 id="cglib动态代理"><a class="markdownIt-Anchor" href="#cglib动态代理"></a> CGLib动态代理</h5><p><strong>目标对象不需要实现接口</strong></p><p>底层是通过继承目标对象产生代理子对象（代理子对象中继承了目标对象的方法并可以对该方法进行增强）</p><pre><code class="highlight plaintext">public static UserService getProxy()&#123;        // 创建CGLIB核心的类        Enhancer enhancer = new Enhancer();        // 设置父类        enhancer.setSuperclass(UserServiceImpl.class);        // 设置回调函数        enhancer.setCallback(new MethodInterceptor() &#123;            @Override            public Object intercept(Object obj, Method method, Object[] args,                    MethodProxy methodProxy) throws Throwable &#123;                if(&quot;save&quot;.equals(method.getName()))&#123;                    // 记录日志                    System.out.println(&quot;记录日志了...&quot;);                &#125;                return methodProxy.invokeSuper(obj, args);            &#125;        &#125;);        // 生成增强之后的代理对象        UserService proxy = (UserService) enhancer.create();        return proxy;    &#125;</code></pre><h4 id="spring-aop简化代理模式实现步骤"><a class="markdownIt-Anchor" href="#spring-aop简化代理模式实现步骤"></a> Spring AOP：简化代理模式实现步骤</h4><ol><li>声明接口：注册需要被监听行为名称</li><li>接口实现类：扮演被监控的类，负责被监听方法的实现细节</li><li>次要业务/增强业务</li></ol><p><strong>所以说spring AOP吧代理模式的5个步骤省略为3个步骤，只需实现相关的接口和类，再加以配置，就可以实现代理模式</strong></p><p>Spring AOP中的新增名词也基本都是为了上述代理模式的实现而服务的，它的<strong>本质就是为了简化代理模式的实现</strong></p><h2 id="spring-aop-使用"><a class="markdownIt-Anchor" href="#spring-aop-使用"></a> Spring AOP 使用</h2><p>Spring AOP是指Spring自身对AOP的实现，与AspectJ无关系</p><h3 id="编程式aop-proxyfactory"><a class="markdownIt-Anchor" href="#编程式aop-proxyfactory"></a> 编程式AOP ProxyFactory</h3><h4 id="创建代理工厂设置被代理对象添加通知"><a class="markdownIt-Anchor" href="#创建代理工厂设置被代理对象添加通知"></a> 创建代理工厂，设置被代理对象，添加通知</h4><pre><code class="highlight plaintext">package com.zhangguo.Spring041.aop05;import org.springframework.aop.framework.ProxyFactory;public class Test &#123;    @org.junit.Test    public void test01()    &#123;        //实例化Spring代理工厂        ProxyFactory factory=new ProxyFactory();        //设置被代理的对象        factory.setTarget(new Math());        //添加通知，横切逻辑        factory.addAdvice(new BeforeAdvice());        factory.addAdvice(new AfterAdvice());        factory.addAdvice(new SurroundAdvice());        //从代理工厂中获得代理对象        IMath math=(IMath) factory.getProxy();        int n1=100,n2=5;        math.add(n1, n2);        math.sub(n1, n2);        math.mut(n1, n2);        math.div(n1, n2);    &#125;    @org.junit.Test    public void test02()    &#123;        //message.message();    &#125;&#125;</code></pre><ul><li>运行结果</li></ul><h3 id="声明式aop-proxyfactorybean"><a class="markdownIt-Anchor" href="#声明式aop-proxyfactorybean"></a> 声明式AOP ProxyFactoryBean</h3><h4 id="advice"><a class="markdownIt-Anchor" href="#advice"></a> Advice</h4><p><strong>通知Advice的类型</strong></p><ul><li>springAOP中，通过Advice定义横切逻辑，Spring中支持5中类型的Advice</li></ul><table><thead><tr><th>通知</th><th>连接点</th><th>实现接口</th></tr></thead><tbody><tr><td>前置通知</td><td>方法前</td><td>org.springframework.aop.MethodBeforeAdvice</td></tr><tr><td>后置通知</td><td>方法后</td><td>org.springframework.aop.AfterReturningAdvice</td></tr><tr><td>环绕通知</td><td>方法前后</td><td>org.aopalliance.intercept.MethodInterceptor</td></tr><tr><td>抛出异常后通知</td><td>方法抛出异常</td><td>org.springframework.aop.ThrowsAdvice</td></tr><tr><td>引介通知</td><td>类中增加新的方法属性</td><td>org.springframework.aop.IntroductionInterceptor</td></tr></tbody></table><p><strong>前置通知</strong></p><pre><code class="highlight plaintext">package com.zhangguo.Spring041.aop05;import java.lang.reflect.Method;import org.springframework.aop.MethodBeforeAdvice;/** * 前置通知 ，就相当于InvocationHandler类 */public class BeforeAdvice implements MethodBeforeAdvice &#123;    /**     * method 方法信息     * args 参数     * target 被代理的目标对象     * 该切面一定是在执行主要业务之前执行，所以方法中不需要对Method做什么操作     */    public void before(Method method, Object[] args, Object target) throws Throwable &#123;        System.out.println(&quot;-----------------前置通知-----------------&quot;);    &#125;&#125;</code></pre><p><strong>后置通知</strong></p><pre><code class="highlight plaintext">package com.zhangguo.Spring041.aop05;import java.lang.reflect.Method;import org.springframework.aop.AfterReturningAdvice;/** * 后置通知 * */public class AfterAdvice implements AfterReturningAdvice &#123;    /*     * returnValue 返回值     * method 被调用的方法     * args 方法参数     * target 被代理对象     */    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123;        System.out.println(&quot;-----------------后置通知-----------------&quot;);    &#125;&#125;</code></pre><p><strong>环绕通知</strong></p><pre><code class="highlight plaintext">package com.zhangguo.Spring041.aop05;import org.aopalliance.intercept.MethodInterceptor;import org.aopalliance.intercept.MethodInvocation;/** * 环绕通知 * 方法拦截器 * */public class SurroundAdvice implements MethodInterceptor &#123;    public Object invoke(MethodInvocation i) throws Throwable &#123;        //前置横切逻辑        System.out.println(&quot;方法&quot; + i.getMethod() + &quot; 被调用在对象&quot; + i.getThis() + &quot;上，参数 &quot; + i.getArguments());        //方法调用        Object ret = i.proceed();        //后置横切逻辑        System.out.println(&quot;返回值：&quot;+ ret);        return ret;    &#125;&#125;</code></pre><h5 id="定义接口"><a class="markdownIt-Anchor" href="#定义接口"></a> 定义接口</h5><pre><code class="highlight plaintext">/** * 接口 * 抽象主题 */public interface IMath &#123;    //加    int add(int n1, int n2);//JoinCut 连接点    //减    int sub(int n1, int n2);//JoinCut 连接点    //乘    int mut(int n1, int n2);//JoinCut 连接点    //除    int div(int n1, int n2);//JoinCut 连接点&#125;</code></pre><h5 id="实现接口"><a class="markdownIt-Anchor" href="#实现接口"></a> 实现接口</h5><pre><code class="highlight plaintext">/** * 被代理的目标对象 *真实主题 */public class Math implements IMath &#123;    //加    public int add(int n1,int n2)&#123;//切入点 PointCut  主要业务方法        int result=n1+n2;        System.out.println(n1+&quot;+&quot;+n2+&quot;=&quot;+result);        return result;    &#125;    //减    public int sub(int n1,int n2)&#123;//切入点 PointCut  主要业务方法        int result=n1-n2;        System.out.println(n1+&quot;-&quot;+n2+&quot;=&quot;+result);        return result;    &#125;    //乘    public int mut(int n1,int n2)&#123;//切入点 PointCut  主要业务方法        int result=n1*n2;        System.out.println(n1+&quot;X&quot;+n2+&quot;=&quot;+result);        return result;    &#125;    //除    public int div(int n1,int n2)&#123;//切入点 PointCut  主要业务方法        int result=n1/n2;        System.out.println(n1+&quot;/&quot;+n2+&quot;=&quot;+result);        return result;    &#125;&#125;</code></pre><h5 id="定义advice"><a class="markdownIt-Anchor" href="#定义advice"></a> 定义Advice</h5><p>使用基础代理模式InvocationHandler</p><pre><code class="highlight plaintext">/* *   public class Agent implements InvocationHandler&#123; *    *      private BaseService obj;//当前具体被监控对象 *      public Agent(BasseSercie param)&#123; *          this.obj = param; *      &#125; *      public Object invoke(Object proxy,Method method,Object[] args)&#123; *             //织入顺序 *      &#125; *      //次要业务 *      public wash()&#123; *      &#125; *   &#125; *  * */</code></pre><p><strong>后置通知</strong></p><pre><code class="highlight plaintext">import java.lang.reflect.Method;import org.springframework.aop.AfterReturningAdvice;/** * 后置通知 * */public class AfterAdvice implements AfterReturningAdvice &#123;    /*     * returnValue 返回值     * method 被调用的方法     * args 方法参数     * target 被代理对象     * 切面，次要业务     */    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123;        System.out.println(&quot;共用时：time&quot;);    &#125;&#125;</code></pre><h5 id="使用ioc配置的方式实现代理"><a class="markdownIt-Anchor" href="#使用ioc配置的方式实现代理"></a> 使用IOC配置的方式实现代理</h5><ul><li>引入spring IOC的核心jar包</li><li>创建IOC的配置文件beans.xml</li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- 被代理的目标对象 ，注册被监控实现类--&gt;    &lt;bean id=&quot;target&quot; class=&quot;com.zhangguo.Spring041.aop06.Math&quot;&gt;&lt;/bean&gt;    &lt;!--通知、横切逻辑，注册通知实现类--&gt;    &lt;bean id=&quot;advice&quot; class=&quot;com.zhangguo.Spring041.aop06.AfterAdvice&quot;&gt;&lt;/bean&gt;    &lt;!--代理对象,注册代理监控对象生产工厂 --&gt;    &lt;!--interceptorNames 通知数组 --&gt;    &lt;!--p:target-ref 被代理的对象--&gt;    &lt;!--p:proxyTargetClass 被代理对象是否为一个没有实现接口的类，如果是则使用cglib,否则使用jdk动态代理  --&gt;    &lt;bean id=&quot;proxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;        p:interceptorNames=&quot;advice&quot;        p:target-ref=&quot;target&quot;        p:proxyTargetClass=&quot;true&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;    &lt;!--    p:interceptorNames=&quot;advice&quot;等价于&lt;property name=&quot;interceptorNames&quot; value=&quot;advice&quot;&gt;&lt;/property&gt;    p:target-ref=&quot;target&quot;等价于&lt;property name=&quot;target&quot; ref=&quot;target&quot;&gt;&lt;/bean&gt;    --&gt;</code></pre><ul><li>获取代理类并执行</li></ul><pre><code class="highlight plaintext">package com.zhangguo.Spring041.aop06;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123;    @org.junit.Test    public void test01()    &#123;        //容器        ApplicationContext ctx=new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        //从代理工厂中获得代理对象        IMath math=(IMath)ctx.getBean(&quot;proxy&quot;);        int n1=100,n2=5;        math.add(n1, n2);        math.sub(n1, n2);        math.mut(n1, n2);        math.div(n1, n2);    &#125;&#125;</code></pre><ul><li>输出</li></ul><h5 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h5><ul><li><strong>这里有个值得注意的问题</strong>：从容器中获得proxy对象时应该是org.springframework.aop.framework.ProxyFactoryBean类型的对象(如下代码所示)，但这里直接就转换成IMath类型了，这是因为：ProxyFactoryBean本质上是一个用来生产Proxy的FactoryBean。如果容器中的某个对象持有某个FactoryBean的引用它取得的不是FactoryBean本身而是 FactoryBean的getObject()方法所返回的对象。所以如果容器中某个对象依赖于ProxyFactoryBean那么它将会使用到 ProxyFactoryBean的getObject()方法所返回的代理对象这就是ProxyFactryBean得以在容器中使用的原因</li></ul><blockquote><p><strong>通知Advice的弊端是，它只可以对接口中的所有方法进行织入切面</strong></p><p>会强行的与接口中的所有方法进行绑定</p></blockquote><h4 id="advisor-顾问"><a class="markdownIt-Anchor" href="#advisor-顾问"></a> Advisor 顾问</h4><p>此种方式比advice更加灵活，只需多实现几个接口，其他配置方法相同，就可以实现更加灵活的实现</p><h5 id="声明接口"><a class="markdownIt-Anchor" href="#声明接口"></a> 声明接口</h5><pre><code class="highlight plaintext">public interface BaseService &#123;       public void eat();//JoinCut 连接点       public void wc();//JoinCut 连接点&#125;</code></pre><h5 id="接口实现"><a class="markdownIt-Anchor" href="#接口实现"></a> 接口实现</h5><pre><code class="highlight plaintext">import com.kaikeba.service.BaseService;public class Person implements BaseService &#123;public void eat() &#123;//切入点 PointCut  主要业务方法           System.out.println(&quot;吃泡面&quot;);&#125;public void wc() &#123;//切入点 PointCut   主要业务方法 System.out.println(&quot;上厕所&quot;);&#125;&#125;</code></pre><h5 id="切面advice"><a class="markdownIt-Anchor" href="#切面advice"></a> 切面Advice</h5><p>次要方法</p><pre><code class="highlight plaintext">import java.lang.reflect.Method;import org.springframework.aop.Advisor;import org.springframework.aop.MethodBeforeAdvice;import org.springframework.aop.framework.ProxyFactoryBean;/* *  *   public class Agent implements InvocationHandler&#123; *    *      private BaseService obj;//当前具体被监控对象 *       *      public Agent(BasseSercie param)&#123; *          this.obj = param; *      &#125; *    *      public Object invoke(Object proxy,Method method,Object[] args)&#123; *             //织入顺序 *      &#125; *       *      //次要业务 *      public wash()&#123; *       *      &#125; *   &#125; *  * */public class MyBeforeAdvice implements MethodBeforeAdvice &#123;//切面：次要业务public void before(Method arg0, Object[] arg1, Object arg2) throws Throwable &#123;System.out.println(&quot;-----洗手-----&quot;);        &#125;&#125;</code></pre><h5 id="classfilter-类拦截器"><a class="markdownIt-Anchor" href="#classfilter-类拦截器"></a> ClassFilter 类拦截器</h5><p>判断当前被拦截对象是不是当前顾问需要管理对象</p><pre><code class="highlight plaintext">import org.springframework.aop.ClassFilter;import com.kaikeba.serviceImpl.Person;public class MyClassFilter implements ClassFilter &#123; /*  *  1.一个接口下会有多个实现类  *  2.判断当前实现类是不是我们织入方式关心的目标类  *  BaseService接口我们现在只想管理Person.  *  参数：就是当前被拦截类：可能Person，可能Gog  * */public boolean matches(Class&lt;?&gt; clazz) &#123;    if(clazz == Person.class)&#123;    return true;//告诉顾问，当前类是需要我们提供织入服务    &#125;    //Gogreturn false;&#125;&#125;</code></pre><h5 id="methodmatcher-方法拦截器"><a class="markdownIt-Anchor" href="#methodmatcher-方法拦截器"></a> MethodMatcher 方法拦截器</h5><p>当前被拦截的方法是不是我们所需要主要业务方法</p><pre><code class="highlight plaintext">import java.lang.reflect.Method;import org.springframework.aop.MethodMatcher;public class MyMethodMatcher implements MethodMatcher &#123;/* *  被监控接口比如（BaseService），没有重载方法 *  每一个方法名称都是以唯一 *  此时可以采用 static检测方式，只根据方法名称判断 * 参数：method: 接口中某一个方法 *     targetClass: 接口中一个实现类 *      *  业务：只想为Person类中eat方法提供织入    */public boolean matches(Method method, Class&lt;?&gt; targetClass) &#123;String methodName = method.getName();if(&quot;eat&quot;.equals(methodName))&#123;return true;&#125;return false;&#125;public boolean isRuntime() &#123;// TODO Auto-generated method stubreturn false;&#125;public boolean matches(Method method, Class&lt;?&gt; targetClass, Object... args) &#123;// TODO Auto-generated method stubreturn false;&#125;&#125;</code></pre><h5 id="pointcut"><a class="markdownIt-Anchor" href="#pointcut"></a> PointCut</h5><p>目标对象和目标方法</p><pre><code class="highlight plaintext">import org.springframework.aop.ClassFilter;import org.springframework.aop.MethodMatcher;import org.springframework.aop.Pointcut;public class MyPointCut implements Pointcut &#123;/* * InvocationHandler接口 *    invoke()&#123; *        if(obj.getClass ！= person.class)&#123; *              return *        &#125; *         *        if(!methodObj.getName.equals(&quot;eat&quot;))&#123; *               return  *        &#125; *        //织入方式:次要业务方法和 Peson.eat()执行顺序 *        //前置通知 *          wash（）； *          Person.eat() *    &#125; *  * *///使用依赖注入private ClassFilter classFilter;private MethodMatcher metodMatcher;public void setClassFilter(ClassFilter classFilter) &#123;this.classFilter = classFilter;&#125;public void setMetodMatcher(MethodMatcher metodMatcher) &#123;this.metodMatcher = metodMatcher;&#125;public ClassFilter getClassFilter() &#123;// TODO Auto-generated method stubreturn this.classFilter;&#125;public MethodMatcher getMethodMatcher() &#123;// TODO Auto-generated method stubreturn this.metodMatcher;&#125;&#125;</code></pre><h5 id="pointcutadvisor"><a class="markdownIt-Anchor" href="#pointcutadvisor"></a> PointCutAdvisor</h5><p>可以灵活的指定当前接口下的哪一个实现类中哪一个方法与次要业务进行绑定</p><pre><code class="highlight plaintext">import org.aopalliance.aop.Advice;import org.springframework.aop.Pointcut;import org.springframework.aop.PointcutAdvisor;public class MyPointCutAdvisor implements PointcutAdvisor &#123;//采用依赖注入 set    private Advice advice;//次要业务以及次要业务与主要业务执行顺序    private Pointcut pointcut;//当前拦截对象和对象调用主要业务方法 person对象.eat()            public void setAdvice(Advice advice) &#123;this.advice = advice;&#125;public void setPointcut(Pointcut pointcut) &#123;this.pointcut = pointcut;&#125;public Advice getAdvice() &#123;// TODO Auto-generated method stubreturn this.advice;&#125;public boolean isPerInstance() &#123;// TODO Auto-generated method stubreturn false;&#125;public Pointcut getPointcut() &#123;// TODO Auto-generated method stubreturn this.pointcut;&#125;&#125;</code></pre><h5 id="spring配置文件"><a class="markdownIt-Anchor" href="#spring配置文件"></a> spring配置文件</h5><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;    xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context         http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;          &lt;!-- 注册被监控实现类 --&gt;       &lt;bean id=&quot;person&quot; class=&quot;com.kaikeba.serviceImpl.Person&quot;&gt;&lt;/bean&gt;       &lt;bean id=&quot;dog&quot; class=&quot;com.kaikeba.serviceImpl.Gog&quot;&gt;&lt;/bean&gt;              &lt;!-- 注册通知实现类 --&gt;       &lt;bean id=&quot;before&quot; class=&quot;com.kaikeba.advice.MyBeforeAdvice&quot;&gt;&lt;/bean&gt;              &lt;!-- 注册类型过滤器 --&gt;       &lt;bean id=&quot;classFilter&quot; class=&quot;com.kaikeba.util.MyClassFilter&quot;&gt;&lt;/bean&gt;       &lt;!-- 注册方法匹配器 --&gt;       &lt;bean id=&quot;methodMatcher&quot; class=&quot;com.kaikeba.util.MyMethodMatcher&quot;&gt;&lt;/bean&gt;              &lt;!-- 注册切入点 --&gt;       &lt;bean id=&quot;pointCut&quot; class=&quot;com.kaikeba.util.MyPointCut&quot; &gt;          &lt;property name=&quot;classFilter&quot; ref=&quot;classFilter&quot;&gt;&lt;/property&gt;          &lt;property name=&quot;metodMatcher&quot; ref=&quot;methodMatcher&quot;&gt;&lt;/property&gt;       &lt;/bean&gt;              &lt;!-- 注册顾问 --&gt;       &lt;bean id=&quot;myAdvisor&quot; class=&quot;com.kaikeba.util.MyPointCutAdvisor&quot;&gt;           &lt;property name=&quot;advice&quot; ref=&quot;before&quot;&gt;&lt;/property&gt;           &lt;property name=&quot;pointcut&quot; ref=&quot;pointCut&quot;&gt;&lt;/property&gt;       &lt;/bean&gt;              &lt;!-- 注册代理对象工厂 --&gt;       &lt;!--                              此时生成代理对象，只会负责person.eat方法监控                             与Advice不同，不会对BaseService所有的方法进行监控                        --&gt;       &lt;bean id=&quot;personProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;              &lt;property name=&quot;target&quot; ref=&quot;person&quot;&gt;&lt;/property&gt;              &lt;property name=&quot;interceptorNames&quot; value=&quot;myAdvisor&quot;&gt;&lt;/property&gt;       &lt;/bean&gt;&lt;/beans&gt;</code></pre><h2 id="aspectj-aop一般使用该方式"><a class="markdownIt-Anchor" href="#aspectj-aop一般使用该方式"></a> AspectJ AOP（一般使用该方式）</h2><p><strong>AspectJ 是AOP单独的一个实现框架，和spring并无关系</strong></p><p><strong>下述步骤是AspectJ+Spring的结合使用（spring自身实现的aop是<code>ProxyFactoryBean</code>）</strong></p><p>AspectJ是一个java实现的AOP框架，它能够对java代码进行AOP编译（一般在编译期进行），让java代码具有AspectJ的AOP功能（当然需要特殊的编译器）</p><p>可以这样说AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言，更幸运的是，AspectJ与java程序完全兼容，几乎是无缝关联，因此对于有java编程基础的工程师，上手和使用都非常容易。</p><p>了解AspectJ应用到java代码的过程（这个过程称为织入），对于织入这个概念，可以简单理解为aspect(切面)应用到目标函数(类)的过程。</p><p>对于这个过程，<strong>一般分为动态织入和静态织入，动态织入的方式是在运行时动态将要增强的代码织入到目标类中</strong>，这样往往是通过动态代理技术完成的，如Java JDK的动态代理(Proxy，底层通过反射实现)或者CGLIB的动态代理(底层通过继承实现)，Spring AOP采用的就是基于运行时增强的代理技术</p><p><strong>ApectJ采用的就是静态织入的方式</strong>。ApectJ主要采用的是编译期织入，在这个期间使用AspectJ的acj编译器(类似javac)把aspect类编译成class字节码后，在java目标类编译时织入，即先编译aspect类再编译目标类。</p><p><strong>spring整合了ApectJ框架，但是底层没有使用acj编译器，而是使用动态代理技术</strong></p><h3 id="aspectj的xml实现aop"><a class="markdownIt-Anchor" href="#aspectj的xml实现aop"></a> AspectJ的XML实现AOP</h3><h4 id="实现步骤"><a class="markdownIt-Anchor" href="#实现步骤"></a> 实现步骤</h4><h5 id="编写目标类"><a class="markdownIt-Anchor" href="#编写目标类"></a> 编写目标类</h5><p>编写接口和实现类（目标对象）</p><ul><li>UserService接口</li><li>UserServiceImpl实现类</li></ul><blockquote><p>配置目标类，将目标类交给spring IoC容器管理</p></blockquote><h5 id="maven依赖"><a class="markdownIt-Anchor" href="#maven依赖"></a> maven依赖</h5><pre><code class="highlight plaintext">&lt;!-- 基于AspectJ的aop依赖 --&gt;&lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;      &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--&lt;dependency&gt;      &lt;groupId&gt;aopalliance&lt;/groupId&gt;      &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;      &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt;--&gt;</code></pre><h5 id="编写一个advice通知"><a class="markdownIt-Anchor" href="#编写一个advice通知"></a> 编写一个advice（通知）</h5><ul><li>定义一个bean<ul><li>该通知不再需要实现任何接口或继承抽象类，一个普通的bean即可，方法<strong>可以</strong>（也可不带）带一个JoinPoint连接点参数，用于获得连接点信息，如方法名，参数，代理对象等</li></ul></li></ul><pre><code class="highlight plaintext">package com.zhangguo.Spring041.aop08;import org.aspectj.lang.JoinPoint;/** * 通知 */public class Advices &#123;    //前置通知    public void before(JoinPoint jp)    &#123;        System.out.println(&quot;--------------------bofore--------------------&quot;);        System.out.println(&quot;方法名：&quot;+jp.getSignature()+&quot;，参数：&quot;+jp.getArgs().length+&quot;，代理对象：&quot;+jp.getTarget());    &#125;    //后置通知    public void after(JoinPoint jp)&#123;        System.out.println(&quot;--------------------after--------------------&quot;);    &#125;&#125;</code></pre><ul><li>通知类型有很多种，有些参数不一样，特别是环绕通知<ul><li><strong>下列方法名可以随意编写</strong></li></ul></li></ul><pre><code class="highlight plaintext">//前置通知public void beforeMethod(JoinPoint joinPoint)//后置通知public void afterMethod(JoinPoint joinPoint)//返回值通知public void afterReturning(JoinPoint joinPoint, Object result)//抛出异常通知//在方法出现异常时会执行的代码可以访问到异常对象，可以指定在出现特定异常时在执行通知代码public void afterThrowing(JoinPoint joinPoint, Exception ex)//环绕通知//环绕通知需要携带ProceedingJoinPoint类型的参数//环绕通知类似于动态代理的全过程：ProceedingJoinPoint类型的参数可以决定是否执行目标方法。//而且环绕通知必须有返回值，返回值即为目标方法的返回值public Object aroundMethod(ProceedingJoinPoint pjd)&#123;    System.out.println(&quot;环绕通知前&quot;);    //调用目标对象的方法    Object proceed = pjd.proceed();     System.out.println(&quot;环绕通知前&quot;);    return proceed;&#125;</code></pre><h5 id="配置通知"><a class="markdownIt-Anchor" href="#配置通知"></a> 配置通知</h5><ul><li>xml配置通知，就是一个普通的bean</li></ul><pre><code class="highlight plaintext">&lt;bean id=&quot;advices&quot; class=&quot;com.zhangguo.Spring041.aop08.Advices&quot;&gt;&lt;/bean&gt;...&lt;/bean&gt;</code></pre><h5 id="配置aop切面"><a class="markdownIt-Anchor" href="#配置aop切面"></a> 配置AOP切面</h5><ul><li>就是指明你的切面中的方法要在哪些类方法执行的前后执行<ul><li>下面的案例指明了是将切面切入service类中的所有方法，即该类中的所有方法只要一执行就调用切面中定义的通知方法，至于要执行哪些通知方法，需要后续步骤继续配置</li></ul></li></ul><pre><code class="highlight plaintext">&lt;aop:config&gt;   &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;aBean&quot;&gt;      &lt;aop:pointcut id=&quot;businessService&quot;         expression=&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;/&gt;      &lt;!-- 前置通知 --&gt;      &lt;aop:before pointcut-ref=&quot;businessService&quot;          method=&quot;doRequiredTask&quot;/&gt;      &lt;!-- 最终通知 --&gt;      &lt;aop:after pointcut-ref=&quot;businessService&quot;          method=&quot;doRequiredTask&quot;/&gt;      &lt;!-- 后置通知 --&gt;      &lt;aop:after-returning pointcut-ref=&quot;businessService&quot;         returning=&quot;retVal&quot;         method=&quot;doRequiredTask&quot;/&gt;      &lt;!-- 异常抛出通知--&gt;      &lt;aop:after-throwing pointcut-ref=&quot;businessService&quot;         throwing=&quot;ex&quot;         method=&quot;doRequiredTask&quot;/&gt;      &lt;!-- 环绕通知 --&gt;      &lt;aop:around pointcut-ref=&quot;businessService&quot;          method=&quot;doRequiredTask&quot;/&gt;   ...   &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;bean id=&quot;aBean&quot; class=&quot;...&quot;&gt;...&lt;/bean&gt;</code></pre><h4 id="切入点表达式"><a class="markdownIt-Anchor" href="#切入点表达式"></a> 切入点表达式</h4><p>切入点表达式的格式：</p><p><em>单个点用来分割包名，类名，方法名</em></p><p><strong>execution([修饰符] 返回值类型 包名.类名.方法名(参数))</strong></p><ul><li>execution：必须要</li><li>修饰符：可省略</li><li>返回值类型：必须要，但是可以使用*通配符</li><li><strong>包名 ：</strong><ul><li>多级包之间使用.分割</li><li>包名可以使用 * 代替，多级包名可以使用多个 * 代替</li><li>如果想省略中间的包名可以使用 …</li></ul></li><li><strong>类名：</strong><ul><li>可以使用 * 代替</li><li>也可以写成 * DaoImpl</li></ul></li><li><strong>方法名：</strong><ul><li>也可以使用 * 好代替</li><li>也可以写成add *</li></ul></li><li><strong>参数：</strong><ul><li>参数使用 * 代替</li><li>如果有多个参数，可以使用 …代替</li></ul></li></ul><h4 id="通知类型"><a class="markdownIt-Anchor" href="#通知类型"></a> 通知类型</h4><p>通知类型（五种）：<strong>前置通知、后置通知、最终通知、环绕通知、异常抛出通知</strong></p><p><strong>前置通知：</strong></p><ul><li>执行时机：目标对象方法之前执行通知</li><li>配置文件：&lt;aop:before method=“before” pointcut-ref=“myPointcut”/&gt;</li><li>应用场景：方法开始时可以进行校验</li></ul><p><strong>后置通知：</strong></p><ul><li>执行时机：目标对象方法之后执行通知，有异常则不执行了</li><li>配置文件：&lt;aop:after-returning method=“afterReturning”<br />pointcut-ref=“myPointcut”/&gt;</li><li>应用场景：可以修改方法的返回值</li></ul><p><strong>最终通知：</strong></p><ul><li>执行时机：目标对象方法之后执行通知，有没有异常都会执行</li><li>配置文件：&lt;aop:after method=“after” pointcut-ref=“myPointcut”/&gt;</li><li>应用场景：例如像释放资源</li></ul><p><strong>异常抛出通知：</strong></p><ul><li>执行时机：在抛出异常后通知</li><li>配置文件：&lt;aop:after-throwing method=&quot; afterThrowing &quot; pointcut-<br />ref=“myPointcut”/&gt;</li><li>应用场景：包装异常</li></ul><p><strong>环绕通知：（使用环绕通知可以替代其他四个通知）</strong></p><ul><li>执行时机：目标对象方法之前和之后都会执行，抛出异常后不会执行</li><li>配置文件：&lt;aop:around method=“around” pointcut-ref=“myPointcut”/&gt;</li><li>应用场景：事务、统计代码执行时机</li></ul><h4 id="xml实现spring-aop-案例"><a class="markdownIt-Anchor" href="#xml实现spring-aop-案例"></a> XML实现Spring AOP 案例</h4><p><strong>要被代理的Math类</strong></p><pre><code class="highlight plaintext">package com.zhangguo.Spring052.aop01;/** * 被代理的目标类 */public class Math&#123;    //加    public int add(int n1,int n2)&#123;        int result=n1+n2;        System.out.println(n1+&quot;+&quot;+n2+&quot;=&quot;+result);        return result;    &#125;        //减    public int sub(int n1,int n2)&#123;        int result=n1-n2;        System.out.println(n1+&quot;-&quot;+n2+&quot;=&quot;+result);        return result;    &#125;        //乘    public int mut(int n1,int n2)&#123;        int result=n1*n2;        System.out.println(n1+&quot;X&quot;+n2+&quot;=&quot;+result);        return result;    &#125;        //除    public int div(int n1,int n2)&#123;        int result=n1/n2;        System.out.println(n1+&quot;/&quot;+n2+&quot;=&quot;+result);        return result;    &#125;&#125;</code></pre><p><strong>编辑通知类Advice</strong></p><pre><code class="highlight plaintext">package com.zhangguo.Spring052.aop01;import org.aspectj.lang.JoinPoint;/** * 通知类，横切逻辑 * */public class Advices &#123;        public void before(JoinPoint jp)&#123;        System.out.println(&quot;----------前置通知----------&quot;);        System.out.println(jp.getSignature().getName());    &#125;        public void after(JoinPoint jp)&#123;        System.out.println(&quot;----------最终通知----------&quot;);    &#125;&#125;</code></pre><p><strong>配置AOP XML文件</strong></p><ul><li>加粗部分的内容是在原IOC内容中新增的，主要是为AOP服务，如果引入失败则没有智能提示。xmlns:是xml namespace的简写。xmlns:xsi：其xsd文件是xml需要遵守的规范，通过URL可以看到，是w3的统一规范，后面通过xsi:schemaLocation来定位所有的解析文件，这里只能成偶数对出现。</li><li><code>&lt;bean &gt;&lt;/bean&gt;</code>表示通知bean，也就是横切逻辑bean</li><li><code>&lt;aop:config proxy-target-&gt;</code>用于AOP配置，proxy-target-class属性表示被代理的类是否为一个没有实现接口的类，Spring会依据实现了接口则使用JDK内置的动态代理，如果未实现接口则使用cblib；在Bean配置文件中，所有的Spring AOP配置都必须定义在<a href="">aop:config</a>元素内部。</li><li><code>&lt;aop:aspect&gt;</code>元素来为具体的切面实现引用后端Bean实例。因此，切面Bean必须有一个标识符，供<a href="">aop:aspect</a>元素引用。aop:aspect表示切面配置， ref表示通知对象的引用；</li><li><code>aop:pointcut</code>是配置切入点，就是横切逻辑将注入的精确位置，那些包，类，方法需要拦截注入横切逻辑</li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop-4.3.xsd&quot;&gt;         &lt;!--被代理的目标对象 --&gt;    &lt;bean id=&quot;math&quot; class=&quot;com.zhangguo.Spring041.aop08.Math&quot;&gt;&lt;/bean&gt;    &lt;!-- 通知 --&gt;    &lt;bean id=&quot;advice&quot; class=&quot;com.zhangguo.Spring041.aop08.Advices&quot;&gt;&lt;/bean&gt;    &lt;!-- AOP配置 --&gt;    &lt;!-- proxy-target-class属性表示被代理的类是否为一个没有实现接口的类，Spring会依据实现了接口则使用JDK内置的动态代理，如果未实现接口则使用cblib --&gt;    &lt;aop:config proxy-target-class=&quot;true&quot;&gt;        &lt;!-- 切面配置 --&gt;        &lt;!--ref表示通知对象的引用 --&gt;        &lt;aop:aspect ref=&quot;advice&quot;&gt;            &lt;!-- 配置切入点(横切逻辑将注入的精确位置) --&gt;            &lt;aop:pointcut expression=&quot;execution(* com.zhangguo.Spring041.aop08.Math.*(..))&quot; id=&quot;pointcut1&quot;/&gt;            &lt;!--声明通知，method指定通知类型，pointcut指定切点，就是该通知应该注入那些方法中 --&gt;            &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;            &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;&lt;/beans&gt;</code></pre><ul><li>aop:before用于声明通知，method指定通知类型，pointcut指定切点，就是该通知应该注入那些方法中。在aop Schema中，每种通知类型都对应一个特定地XML元素。通知元素需要pointcut-ref属性来引用切入点，或者用pointcut属性直接嵌入切入点表达式。method属性指定切面类中通知方法的名称。有如下几种：</li></ul><pre><code class="highlight plaintext">&lt;!-- 前置通知 --&gt;&lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;&lt;!-- 后置通知 --&gt;&lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;&lt;!--环绕通知 --&gt;&lt;aop:around method=&quot;around&quot; pointcut=&quot;execution(* com.zhangguo.Spring041.aop08.Math.s*(..))&quot;/&gt;&lt;!--异常通知 --&gt;&lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut=&quot;execution(* com.zhangguo.Spring041.aop08.Math.d*(..))&quot;  throwing=&quot;exp&quot;/&gt;&lt;!-- 返回值通知 --&gt;&lt;aop:after-returning method=&quot;afterReturning&quot; pointcut=&quot;execution(* com.zhangguo.Spring041.aop08.Math.m*(..))&quot; returning=&quot;result&quot;/&gt;</code></pre><p><strong>测试运行</strong></p><pre><code class="highlight plaintext">package com.zhangguo.Spring052.aop01;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123;    public static void main(String[] args) &#123;        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;aop01.xml&quot;);        Math math = ctx.getBean(&quot;math&quot;, Math.class);        int n1 = 100, n2 = 5;        math.add(n1, n2);        math.sub(n1, n2);        math.mut(n1, n2);        math.div(n1, n2);    &#125;&#125;</code></pre><p><strong>结果</strong></p><hr /><h3 id="aspectj的注解实现aop"><a class="markdownIt-Anchor" href="#aspectj的注解实现aop"></a> AspectJ的注解实现AOP</h3><h4 id="实现步骤-2"><a class="markdownIt-Anchor" href="#实现步骤-2"></a> 实现步骤</h4><h5 id="编写目标类-2"><a class="markdownIt-Anchor" href="#编写目标类-2"></a> 编写目标类</h5><p>编写接口和实现类（目标对象）</p><ul><li>UserService接口</li><li>UserServiceImpl实现类</li></ul><blockquote><p>配置目标类，将目标类交给spring IoC容器管理</p></blockquote><h5 id="开启aop自动代理"><a class="markdownIt-Anchor" href="#开启aop自动代理"></a> 开启AOP自动代理</h5><ul><li>在spring的xml文件中加入</li></ul><pre><code class="highlight plaintext">&lt;aop:aspectj-autoproxy/&gt;</code></pre><h5 id="编写aspect切面类"><a class="markdownIt-Anchor" href="#编写aspect切面类"></a> 编写Aspect（切面）类</h5><p>Advice通知+PointCut切入点=Aspect切面</p><ul><li>在使用基于Aspectj注解的Spring aop时，我们可以通过把@Pointcut注解定义Pointcut，指定其表达式，然后再需要使用Pointcut表达时的时候直接指定Pointcut</li></ul><pre><code class="highlight plaintext">//切面类，表示通知加切入点//需要将切面类将给spring IoC容器管理@Component//@Aspect:标记改类是一个切面类@Aspectpublic class MyAspect &#123;// 这里的这个方法名没有什么实际意义，相当于一个id，pointcut种的内容是这个id所匹配的要切入的那些柱子，要切入执行的内容就是下面的@before方法，@before注解的参数就是这个pointcut注解方法的名字    @Pointcut(&quot;execution(* add(..))&quot;)    private void beforeAdd() &#123;&#125;        //@Before表示这是一个前置通知    //value：切入点表达式    @Before(&quot;execution(* *..*.*ServiceImpl.*(..))&quot;)    public void before() &#123;        System.out.println(&quot;-----------前置通知-----------&quot;);    &#125;    &#125;</code></pre><h5 id="配置切面类"><a class="markdownIt-Anchor" href="#配置切面类"></a> 配置切面类</h5><p>即让其纳入spring管理</p><pre><code class="highlight plaintext">&lt;context:component-scan base-package=&quot;com.kkb.spring&quot;/&gt;</code></pre><h4 id="其他注解使用方式"><a class="markdownIt-Anchor" href="#其他注解使用方式"></a> 其他注解使用方式</h4><pre><code class="highlight plaintext">import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;/** * 通知类，横切逻辑 */@Component@Aspectpublic class Advices &#123;    //切点    @Pointcut(&quot;execution(* com.zhangguo.Spring052.aop04.Math.a*(..))&quot;)    public void pointcut()&#123;    &#125;        //前置通知    @Before(&quot;pointcut()&quot;)    public void before(JoinPoint jp)&#123;        System.out.println(jp.getSignature().getName());        System.out.println(&quot;----------前置通知----------&quot;);    &#125;        //最终通知    @After(&quot;pointcut()&quot;)    public void after(JoinPoint jp)&#123;        System.out.println(&quot;----------最终通知----------&quot;);    &#125;        //环绕通知    @Around(&quot;execution(* com.zhangguo.Spring052.aop04.Math.s*(..))&quot;)    public Object around(ProceedingJoinPoint pjp) throws Throwable&#123;        System.out.println(pjp.getSignature().getName());        System.out.println(&quot;----------环绕前置----------&quot;);        Object result=pjp.proceed();        System.out.println(&quot;----------环绕后置----------&quot;);        return result;    &#125;        //返回结果通知    @AfterReturning(pointcut=&quot;execution(* com.zhangguo.Spring052.aop04.Math.m*(..))&quot;,returning=&quot;result&quot;)    public void afterReturning(JoinPoint jp,Object result)&#123;        System.out.println(jp.getSignature().getName());        System.out.println(&quot;结果是：&quot;+result);        System.out.println(&quot;----------返回结果----------&quot;);    &#125;        //异常后通知    @AfterThrowing(pointcut=&quot;execution(* com.zhangguo.Spring052.aop04.Math.d*(..))&quot;,throwing=&quot;exp&quot;)    public void afterThrowing(JoinPoint jp,Exception exp)&#123;        System.out.println(jp.getSignature().getName());        System.out.println(&quot;异常消息：&quot;+exp.getMessage());        System.out.println(&quot;----------异常通知----------&quot;);    &#125;&#125;</code></pre><h4 id="环绕通知注解配置特殊"><a class="markdownIt-Anchor" href="#环绕通知注解配置特殊"></a> 环绕通知注解配置（特殊）</h4><p><strong>@Around</strong></p><ul><li>作用：把当前方法看作环绕通知</li><li>属性<ul><li>value：用于指定切入点表达式，还可以指定切入点表达式的引用</li></ul></li></ul><h4 id="定义通用切入点"><a class="markdownIt-Anchor" href="#定义通用切入点"></a> 定义通用切入点</h4><p>使用@PointCut注解在切面类中定义一个通用的切入点，其他通知可以引用该切入点</p><h4 id="零注解配置"><a class="markdownIt-Anchor" href="#零注解配置"></a> 零注解配置</h4><pre><code class="highlight plaintext">//声明改类是一个配置类@Configuration//将com.kkb包纳入注解扫描@ComponentScan(basePackages=&quot;com.kkb&quot;)//这个就相当于xml文件中的&lt;aop:aspectj-autoproxy/&gt;  AOP自动代理@EnableAspectJAutoProxypublic class SpringConfiguration &#123;//在配置中声明一个bean，相当于&lt;bean id=getUser /&gt;     @Bean     public User getUser()&#123; return new User(); &#125;&#125;</code></pre><h4 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h4><p>其实AOP的原理非常简单。我们以LoggingAspect.doAccessCheck()为例，要把它注入到UserService的每个public方法中，最简单的方法是编写一个子类，并持有原始实例的引用：</p><pre><code class="highlight plaintext">@Aspect@Componentpublic class LoggingAspect &#123;    // 在执行UserService的每个方法前执行:    @Before(&quot;execution(public * com.itranswarp.learnjava.service.UserService.*(..))&quot;)    public void doAccessCheck() &#123;        System.err.println(&quot;[Before] do access check...&quot;);    &#125;    // 在执行MailService的每个方法前后执行:    @Around(&quot;execution(public * com.itranswarp.learnjava.service.MailService.*(..))&quot;)    public Object doLogging(ProceedingJoinPoint pjp) throws Throwable &#123;        System.err.println(&quot;[Around] start &quot; + pjp.getSignature());        Object retVal = pjp.proceed();        System.err.println(&quot;[Around] done &quot; + pjp.getSignature());        return retVal;    &#125;&#125;//子类public UserServiceAopProxy extends UserService &#123;    private UserService target;    private LoggingAspect aspect;    public UserServiceAopProxy(UserService target, LoggingAspect aspect) &#123;        this.target = target;        this.aspect = aspect;    &#125;    public User login(String email, String password) &#123;        // 先执行Aspect的代码:        aspect.doAccessCheck();        // 再执行UserService的逻辑:        return target.login(email, password);    &#125;    public User register(String email, String password, String name) &#123;        aspect.doAccessCheck();        return target.register(email, password, name);    &#125;    ...&#125;</code></pre><p>这些都是Spring容器启动时为我们自动创建的注入了Aspect的子类，它取代了原始的UserService（原始的UserService实例作为内部变量隐藏在UserServiceAopProxy中）。如果我们打印从Spring容器获取的UserService实例类型，它类似UserService$$EnhancerBySpringCGLIB$$1f44e01c，实际上是Spring使用CGLIB动态创建的子类，但对于调用方来说，感觉不到任何区别。</p><blockquote><p>Spring对接口类型使用JDK动态代理，对普通类使用CGLIB创建子类。如果一个Bean的class是final，Spring将无法为其创建子类。</p></blockquote><p>可见，虽然Spring容器内部实现AOP的逻辑比较复杂（需要使用AspectJ解析注解，并通过CGLIB实现代理类），但我们使用AOP非常简单，一共需要三步：</p><ul><li>定义执行方法，并在方法上通过AspectJ的注解告诉Spring应该在何处调用此方法；</li><li>标记@Component和@Aspect；</li><li>在@Configuration类上标注@EnableAspectJAutoProxy。</li></ul><h4 id="案例注解配置aop"><a class="markdownIt-Anchor" href="#案例注解配置aop"></a> 案例:注解配置AOP</h4><ul><li>在上一个示例中修改被代理的类Math,为了实现IOC扫描在Math类上注解了@Service并命名bean为math。相当于上一个示例中在xml配置文件中增加了一个bean，<!-- 被代理对象 --><bean ></bean>，Math类的代码如下：</li></ul><pre><code class="highlight plaintext">package com.zhangguo.Spring052.aop02;import org.springframework.stereotype.Service;/** * 被代理的目标类 */@Service(&quot;math&quot;)public class Math&#123;    //加    public int add(int n1,int n2)&#123;        int result=n1+n2;        System.out.println(n1+&quot;+&quot;+n2+&quot;=&quot;+result);        return result;    &#125;        //减    public int sub(int n1,int n2)&#123;        int result=n1-n2;        System.out.println(n1+&quot;-&quot;+n2+&quot;=&quot;+result);        return result;    &#125;        //乘    public int mut(int n1,int n2)&#123;        int result=n1*n2;        System.out.println(n1+&quot;X&quot;+n2+&quot;=&quot;+result);        return result;    &#125;        //除    public int div(int n1,int n2)&#123;        int result=n1/n2;        System.out.println(n1+&quot;/&quot;+n2+&quot;=&quot;+result);        return result;    &#125;&#125;</code></pre><ul><li>修改通知类Advices，代码中有3个注解，@Component表示该类的实例会被Spring IOC容器管理；@Aspect表示声明一个切面；@Before表示before为前置通知，通过参数execution声明一个切点，Advices.java代码如下所示：</li></ul><blockquote><p>这个Java类就相当于<code>使用XML配置Spring MVC时候的&lt;aop:config&gt;</code> 的配置</p></blockquote><pre><code class="highlight plaintext">package com.zhangguo.Spring052.aop02;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;/** * 通知类，横切逻辑 * */@Component@Aspectpublic class Advices &#123;    @Before(&quot;execution(* com.zhangguo.Spring052.aop02.Math.*(..))&quot;)    public void before(JoinPoint jp)&#123;        System.out.println(&quot;----------前置通知----------&quot;);        System.out.println(jp.getSignature().getName());    &#125;        @After(&quot;execution(* com.zhangguo.Spring052.aop02.Math.*(..))&quot;)    public void after(JoinPoint jp)&#123;        System.out.println(&quot;----------最终通知----------&quot;);    &#125;&#125;</code></pre><ul><li>上面Java类等同于下面的xml</li></ul><pre><code class="highlight plaintext">&lt;!-- 通知 --&gt;    &lt;bean id=&quot;advices&quot; class=&quot;com.zhangguo.Spring052.aop01.Advices&quot;&gt;&lt;/bean&gt;        &lt;!-- aop配置 --&gt;    &lt;aop:config proxy-target-class=&quot;true&quot;&gt;        &lt;!--切面 --&gt;        &lt;aop:aspect ref=&quot;advices&quot;&gt;            &lt;!-- 切点 --&gt;            &lt;aop:pointcut expression=&quot;execution(* com.zhangguo.Spring052.aop01.Math.*(..))&quot; id=&quot;pointcut1&quot;/&gt;            &lt;!--连接通知方法与切点 --&gt;            &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;            &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;</code></pre><ul><li>Spring配置文件<ul><li>新增配置文件aop02.xml，在配置IOC的基础上增加了aop:aspectj-autoproxy节点，Spring框架会自动为与AspectJ切面配置的Bean创建代理，proxy-target-属性表示被代理的目标对象是一个类，而非实现了接口的类，主要是为了选择不同的代理方式</li></ul></li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context-4.3.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop-4.3.xsd&quot;&gt;        &lt;context:component-scan base-package=&quot;com.zhangguo.Spring052.aop02&quot;/&gt;        &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt;</code></pre><h4 id="aspectj切点函数"><a class="markdownIt-Anchor" href="#aspectj切点函数"></a> AspectJ切点函数</h4><h5 id="表达式类型"><a class="markdownIt-Anchor" href="#表达式类型"></a> 表达式类型</h5><ul><li>@AspectJ使用AspectJ专门的切点表达式描述切面，Spring所支持的AspectJ表达式可分为四类:<ul><li>方法切点函数：通过描述目标类方法信息定义连接点。</li><li>方法参数切点函数：通过描述目标类方法入参信息定义连接点。</li><li>目标类切点函数：通过描述目标类类型信息定义连接点。</li><li>代理类切点函数：通过描述代理类信息定义连接点。</li></ul></li><li>标准的Aspectj Aop的pointcut的表达式类型很丰富，但是spring AOP只支持9种，另外加Spring Aop自己扩充的一种，一共是10种类型的表达式，分别如下<ul><li>execution：满足匹配模式字符串的所有目标类方法的连接点</li><li>within：指定某些类型的全部方法执行，也可用来指定一个包。</li><li>this：Spring Aop是基于代理的，生成的bean也是一个代理对象，this就是这个代理对象，当这个对象可以转换为指定的类型时，对应的切入点就是它了，Spring Aop将生效。</li><li>target：当被代理的对象可以转换为指定的类型时，对应的切入点就是它了，Spring Aop将生效。</li><li>args：当执行的方法的参数是指定类型时生效。</li><li>@target：当代理的目标对象上拥有指定的注解时生效。</li><li>@args：当执行的方法参数类型上拥有指定的注解时生效。</li><li>@within：与@target类似，看官方文档和网上的说法都是@within只需要目标对象的类或者父类上有指定的注解，则@within会生效，而@target则是必须是目标对象的类上有指定的注解。而根据笔者的测试这两者都是只要目标类或父类上有指定的注解即可。</li><li>@annotation：当执行的方法上拥有指定的注解时生效。</li><li>bean：当调用的方法是指定的bean的方法时生效。</li></ul></li></ul><h5 id="使用示例案例"><a class="markdownIt-Anchor" href="#使用示例案例"></a> 使用示例，案例</h5><ul><li>新增一个类StrUtil</li></ul><pre><code class="highlight plaintext">package com.zhangguo.Spring052.aop03;import org.springframework.stereotype.Component;@Component(&quot;strUtil&quot;)public class StrUtil &#123;    public void show()&#123;        System.out.println(&quot;Hello StrUtil!&quot;);    &#125;&#125;</code></pre><ul><li>测试代码</li></ul><pre><code class="highlight plaintext">package com.zhangguo.Spring052.aop03;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123;    public static void main(String[] args) &#123;        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;aop03.xml&quot;);        IMath math = ctx.getBean(&quot;math&quot;, Math.class);        int n1 = 100, n2 = 5;        math.add(n1, n2);        math.sub(n1, n2);        math.mut(n1, n2);        math.div(n1, n2);                StrUtil strUtil=ctx.getBean(&quot;strUtil&quot;,StrUtil.class);        strUtil.show();    &#125;&#125;</code></pre><ul><li><strong>execution</strong><ul><li>execution是使用的最多的一种Pointcut表达式，表示某个方法的执行</li></ul></li></ul><pre><code class="highlight plaintext">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)</code></pre><ol><li>modifiers-pattern表示方法的访问类型，public等；</li><li>ret-type-pattern表示方法的返回值类型，如String表示返回类型是String，“*”表示所有的返回类型；</li><li>declaring-type-pattern表示方法的声明类，如“com.elim…*”表示com.elim包及其子包下面的所有类型；</li><li>name-pattern表示方法的名称，如“add*”表示所有以add开头的方法名；</li><li>param-pattern表示方法参数的类型，name-pattern(param-pattern)其实是一起的表示的方法集对应的参数类型，如“add()”表示不带参数的add方法，“add(<em>)”表示带一个任意类型的参数的add方法，“add(</em>,String)”则表示带两个参数，且第二个参数是String类型的add方法；</li><li>throws-pattern表示异常类型；其中以问号结束的部分都是可以省略的。<ol><li>“execution(* add())”匹配所有的不带参数的add()方法。</li><li>“execution(public * com…<em>.add</em>(…))”匹配所有com包及其子包下所有类的以add开头的所有public方法。</li><li>“execution(* *(…) throws Exception)”匹配所有抛出Exception的方法。</li></ol></li></ol><pre><code class="highlight plaintext">@Component@Aspectpublic class Advices &#123;    @Before(&quot;execution(* com.zhangguo.Spring052.aop03.Math.*(..))&quot;)    public void before(JoinPoint jp)&#123;        System.out.println(&quot;----------前置通知----------&quot;);        System.out.println(jp.getSignature().getName());    &#125;        //execution切点函数    //com.zhangguo.Spring052.aop03包下所有类的所有方法被切入    @After(&quot;execution(* com.zhangguo.Spring052.aop03.*.*(..))&quot;)    public void after(JoinPoint jp)&#123;        System.out.println(&quot;----------最终通知----------&quot;);    &#125;&#125;</code></pre><ul><li><strong>within</strong><ul><li>within是用来指定类型，指定类型种的所有方法将被拦截<ol><li>“within(com.spring.aop.service.UserServiceImpl)”匹配UserServiceImpl类对应对象的所有方法外部调用，而且这个对象只能是UserServiceImpl类型，不能是其子类型</li><li>“within(com.elim…*)”匹配com.elim包及其子包下面所有的类的所有方法的外部调用。</li></ol></li></ul></li></ul><pre><code class="highlight plaintext">//within切点函数    //com.zhangguo.Spring052.aop03包下所有类的所有方法被切入    @After(&quot;within(com.zhangguo.Spring052.aop03.*)&quot;)    public void after(JoinPoint jp)&#123;        System.out.println(&quot;----------最终通知----------&quot;);    &#125;</code></pre><p>%!(EXTRA markdown.ResourceType=, string=, string=)</p><ul><li><strong>this</strong><ul><li>Spring Aop是基于代理的，this就表示代理对象。this类型的Pointcut表达式的语法是this(type)，当生成的代理对象可以转换为type指定的类型时则表示匹配。基于JDK接口的代理和基于CGLIB的代理生成的代理对象是不一样的<ol><li>“this(com.spring.aop.service.IUserService)”匹配生成的代理对象是IUserService类型的所有方法的外部调用</li></ol></li></ul></li></ul><pre><code class="highlight plaintext">//this切点函数    //实现了IMath接口的代理对象的任意连接点    @After(&quot;this(com.zhangguo.Spring052.aop03.IMath)&quot;)    public void after(JoinPoint jp)&#123;        System.out.println(&quot;----------最终通知----------&quot;);    &#125;</code></pre><p>%!(EXTRA markdown.ResourceType=, string=, string=)</p><ul><li><strong>target</strong><ul><li>Spring aop是基于代理的，target则表示被代理的布标对象，当被代理的目标对象可以被转换为指定的类型时则表示匹配<ol><li>“target(com.spring.aop.service.IUserService)”则匹配所有被代理的目标对象能够转换为IUserService类型的所有方法的外部调用</li></ol></li></ul></li><li><strong>args</strong><ul><li>arge用来匹配方法参数<ol><li>“args()”匹配任何不带参数的方法。</li><li>“args(java.lang.String)”匹配任何只带一个参数，而且这个参数的类型是String的方法。</li><li>“args(…)”带任意参数的方法。</li><li>“args(java.lang.String,…)”匹配带任意个参数，但是第一个参数的类型是String的方法</li><li>“args(…,java.lang.String)”匹配带任意个参数，但是最后一个参数的类型是String的方法</li></ol></li></ul></li></ul><pre><code class="highlight plaintext">//args切点函数    //要求方法有两个int类型的参考才会被织入横切逻辑    @After(&quot;args(int,int)&quot;)    public void after(JoinPoint jp)&#123;        System.out.println(&quot;----------最终通知----------&quot;);    &#125;</code></pre><p>%!(EXTRA markdown.ResourceType=, string=, string=)</p><ul><li><strong>@target</strong><ul><li>@target匹配当被代理的目标对象对应的类型及其父类型上拥有指定的注解时<ol><li>“@target(com.spring.support.MyAnnotation)”匹配被代理的目标对象对应的类型上拥有MyAnnotation注解时</li></ol></li></ul></li><li><strong>@args</strong><ul><li>@args匹配被调用的方法上含有参数，且对应的参数类型上拥有指定的注解的情况<ol><li>“@args(com.spring.support.MyAnnotation)”匹配方法参数类型上拥有MyAnnotation注解的方法调用。如我们有一个方法add(MyParam param)接收一个MyParam类型的参数，而MyParam这个类是拥有注解MyAnnotation的，则它可以被Pointcut表达式“@args(com.elim.spring.support.MyAnnotation)”匹配上</li></ol></li></ul></li><li><strong>@within</strong><ul><li>@within用于匹配被代理的目标对象对应的类型或其父类型拥有指定的注解的情况，但只有在调用拥有指定注解的类上的方法时才匹配<ol><li>“@within(com.spring.support.MyAnnotation)”匹配被调用的方法声明的类上拥有MyAnnotation注解的情况。比如有一个ClassA上使用了注解MyAnnotation标注，并且定义了一个方法a()，那么在调用ClassA.a()方法时将匹配该Pointcut；如果有一个ClassB上没有MyAnnotation注解，但是它继承自ClassA，同时它上面定义了一个方法b()，那么在调用ClassB().b()方法时不会匹配该Pointcut，但是在调用ClassB().a()时将匹配该方法调用，因为a()是定义在父类型ClassA上的，且ClassA上使用了MyAnnotation注解。但是如果子类ClassB覆写了父类ClassA的a()方法，则调用ClassB.a()方法时也不匹配该Pointcut</li></ol></li></ul></li><li><strong>@annotation</strong><ul><li>@annotation用于匹配方法上拥有指定注解的情况<ol><li>“@annotation(com.spring.support.MyAnnotation)”匹配所有的方法上拥有MyAnnotation注解的方法外部调用</li></ol></li></ul></li><li><code>先定义一个可以定义在方法上的注解</code></li></ul><pre><code class="highlight plaintext">package com.zhangguo.Spring052.aop03;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface MyAnno &#123;&#125;</code></pre><pre><code class="highlight plaintext">//@annotation切点函数    //要求方法必须被注解com.zhangguo.Spring052.aop03.MyAnno才会被织入横切逻辑    @After(&quot;@annotation(com.zhangguo.Spring052.aop03.MyAnno)&quot;)    public void after(JoinPoint jp)&#123;        System.out.println(&quot;----------最终通知----------&quot;);    &#125;</code></pre><pre><code class="highlight plaintext">package com.zhangguo.Spring052.aop03;import org.springframework.stereotype.Component;@Component(&quot;strUtil&quot;)public class StrUtil &#123;    @MyAnno    public void show()&#123;        System.out.println(&quot;Hello StrUtil!&quot;);    &#125;&#125;</code></pre><p>%!(EXTRA markdown.ResourceType=, string=, string=)</p><ul><li><strong>bean</strong><ul><li>bean用于匹配当调用的是指定的Spring的某个bean的方法时<ol><li>“bean(abc)”匹配Spring Bean容器中id或name为abc的bean的方法调用</li><li>“bean(user*)”匹配所有id或name为以user开头的bean的方法调用</li></ol></li></ul></li></ul><h5 id="表达式组合"><a class="markdownIt-Anchor" href="#表达式组合"></a> 表达式组合</h5><ul><li>表达式组合就是表达式的逻辑运算，与，或，非。可以通过他们把表达式组合在一起<ol><li>bean(userService) &amp;&amp; args()”匹配id或name为userService的bean的所有无参方法。</li><li>“bean(userService) || @annotation(MyAnnotation)”匹配id或name为userService的bean的方法调用，或者是方法上使用了MyAnnotation注解的方法调用。</li><li>“bean(userService) &amp;&amp; !args()”匹配id或name为userService的bean的所有有参方法调用。</li></ol></li></ul><h4 id="自定义注解装配aop"><a class="markdownIt-Anchor" href="#自定义注解装配aop"></a> 自定义注解装配AOP</h4><p>使用AspectJ的注解，并配合一个复杂的<code>execution(* xxx.Xyz.*(..))</code> 语法来定义应该如何装配AOP。</p><p>在实际项目中，这种写法其实很少使用。假设你写了一个SecurityAspect：</p><pre><code class="highlight plaintext">@Aspect@Componentpublic class SecurityAspect &#123;    @Before(&quot;execution(public * com.itranswarp.learnjava.service.*.*(..))&quot;)    public void check() &#123;        if (SecurityContext.getCurrentUser() == null) &#123;            throw new RuntimeException(&quot;check failed&quot;);        &#125;    &#125;&#125;</code></pre><p>基本能实现无差别全覆盖，即某个包下面的所有Bean的所有方法都会被这个check()方法拦截。</p><p>还有的童鞋喜欢用方法名前缀进行拦截：</p><pre><code class="highlight plaintext">@Around(&quot;execution(public * update*(..))&quot;)public Object doLogging(ProceedingJoinPoint pjp) throws Throwable &#123;    // 对update开头的方法切换数据源:    String old = setCurrentDataSource(&quot;master&quot;);    Object retVal = pjp.proceed();    restoreCurrentDataSource(old);    return retVal;&#125;</code></pre><p>这种非精准打击误伤面更大，因为从方法前缀区分是否是数据库操作是非常不可取的。</p><p>我们在使用AOP时，要注意到虽然Spring容器可以把指定的方法通过AOP规则装配到指定的Bean的指定方法前后，但是，如果自动装配时，因为不恰当的范围，容易导致意想不到的结果，即很多不需要AOP代理的Bean也被自动代理了，并且，后续新增的Bean，如果不清楚现有的AOP装配规则，容易被强迫装配。</p><p>使用AOP时，被装配的Bean最好自己能清清楚楚地知道自己被安排了。例如，Spring提供的@Transactional就是一个非常好的例子。如果我们自己写的Bean希望在一个数据库事务中被调用，就标注上@Transactional。</p><p>通过@Transactional，某个方法是否启用了事务就一清二楚了。因此，装配AOP的时候，使用注解是最好的方式。</p><p>我们以一个实际例子演示如何使用注解实现AOP装配。为了监控应用程序的性能，我们定义一个性能监控的注解：</p><pre><code class="highlight plaintext">@Target(METHOD)@Retention(RUNTIME)public @interface MetricTime &#123;    String value();&#125;</code></pre><p>在需要被监控的关键方法上标注该注解：</p><pre><code class="highlight plaintext">@Componentpublic class UserService &#123;    // 监控register()方法性能:    @MetricTime(&quot;register&quot;)    public User register(String email, String password, String name) &#123;        ...    &#125;    ...&#125;</code></pre><p>然后，我们定义MetricAspect：</p><pre><code class="highlight plaintext">@Aspect@Componentpublic class MetricAspect &#123;    @Around(&quot;@annotation(metricTime)&quot;)    public Object metric(ProceedingJoinPoint joinPoint, MetricTime metricTime) throws Throwable &#123;        String name = metricTime.value();        long start = System.currentTimeMillis();        try &#123;            return joinPoint.proceed();        &#125; finally &#123;            long t = System.currentTimeMillis() - start;            // 写入日志或发送至JMX:            System.err.println(&quot;[Metrics] &quot; + name + &quot;: &quot; + t + &quot;ms&quot;);        &#125;    &#125;&#125;</code></pre><p>注意metric()方法标注了@Around(“@annotation(metricTime)”)，它的意思是，符合条件的目标方法是带有@MetricTime注解的方法，因为metric()方法参数类型是MetricTime（注意参数名是metricTime不是MetricTime），我们通过它获取性能监控的名称。</p><p>有了@MetricTime注解，再配合MetricAspect，任何Bean，只要方法标注了@MetricTime注解，就可以自动实现性能监控。</p><p>%23%20Spring%20AOP%0A%5Btoc%5D%0A%23%23%20AOP%0A%E5%9C%A8%E8%BD%AF%E4%BB%B6%E4%B8%9A%EF%BC%8CAOP%E6%84%8F%E4%B8%BA%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%EF%BC%8C%E9%80%9A%E8%BF%87**%E9%A2%84%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F**%E6%88%96**%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86**%E5%AE%9E%E7%8E%B0%E7%A8%8B%E5%BA%8F%E5%8A%9F%E8%83%BD%E7%9A%84%E7%BB%9F%E4%B8%80%E7%BB%B4%E6%8A%A4%E7%9A%84%E4%B8%80%E7%A7%8D%E6%8A%80%E6%9C%AF%EF%BC%8CAOP%E6%98%AFOOP%E7%9A%84%E5%BB%B6%E7%BB%AD%EF%BC%8C%E6%98%AF%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E7%83%AD%E7%82%B9%EF%BC%8C%E4%B9%9F%E6%98%AFspring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E9%87%8D%E8%A6%81%E5%86%85%E5%AE%B9%EF%BC%8C%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E7%A7%8D%E8%A1%8D%E7%94%9F%E6%B3%9B%E5%9E%8B%EF%BC%8C%E5%88%A9%E7%94%A8AOP%E5%8F%AF%E4%BB%A5%E5%AF%B9%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E7%9A%84%E5%90%84%E4%B8%AA%E9%83%A8%E5%88%86%E8%BF%9B%E8%A1%8C%E9%9A%94%E7%A6%BB%EF%BC%8C%E4%BB%8E%E8%80%8C%E6%98%AF%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%90%84%E9%83%A8%E5%88%86%E4%B9%8B%E9%97%B4%E8%80%A6%E5%90%88%E5%BA%A6%E9%99%8D%E4%BD%8E%EF%BC%8C%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8F%AF%E9%87%8D%E7%94%A8%E6%80%A7%EF%BC%8C%E5%90%8C%E6%97%B6%E6%8F%90%E9%AB%98%E4%BA%86%E5%BC%80%E5%8F%91%E7%9A%84%E6%95%88%E7%8E%87%0A!%5Bed68a81a67162e6bc2b9f3a81dd5019a.png%5D(en-resource%3A%2F%2Fdatabase%2F4280%3A1)%0A%0A!%5B1a646a6b790eb5d0d974729479c4e4da.png%5D(en-resource%3A%2F%2Fdatabase%2F4279%3A1)%0A%0A%0A%23%23%23%20%E6%84%8F%E5%9B%BE%0A*%20%E5%B0%86%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%EF%BC%8C%E6%80%A7%E8%83%BD%E7%BB%9F%E8%AE%A1%EF%BC%8C%E5%AE%89%E5%85%A8%E6%8E%A7%E5%88%B6%EF%BC%8C%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%EF%BC%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%AD%89%E4%BB%A3%E7%A0%81%E4%BB%8E%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%88%92%E5%88%86%E5%87%BA%E6%9D%A5%EF%BC%8C%E9%80%9A%E8%BF%87%E5%AF%B9%E8%BF%99%E4%BA%9B%E8%A1%8C%E4%B8%BA%E7%9A%84%E5%88%86%E7%A6%BB%EF%BC%8C%E6%88%91%E4%BB%AC%E5%B8%8C%E6%9C%9B%E5%8F%AF%E4%BB%A5%E5%B0%86%E5%AE%83%E4%BB%AC%E7%8B%AC%E7%AB%8B%E5%88%B0%E9%9D%9E%E6%8C%87%E5%AF%BC%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%AD%EF%BC%8C%E8%BF%9B%E8%80%8C%E6%94%B9%E5%8F%98%E8%BF%99%E4%BA%9B%E8%A1%8C%E4%B8%BA%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%8D%E5%BD%B1%E5%93%8D%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E7%9A%84%E4%BB%A3%E7%A0%81%0A%0A%23%23%23%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%0AAOP%E5%8F%AF%E4%BB%A5%E8%AF%B4%E6%98%AF%E5%AF%B9OOP%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8C%E5%AE%8C%E5%96%84%E3%80%82OOP%E5%BC%95%E5%85%A5%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%E6%80%A7%E7%AD%89%E6%A6%82%E5%BF%B5%E6%9D%A5%E5%BB%BA%E7%AB%8B%E4%B8%80%E7%A7%8D%E5%AF%B9%E8%B1%A1%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%EF%BC%8C%E7%94%A8%E4%BB%A5%E6%A8%A1%E6%8B%9F%E5%85%AC%E5%85%B1%E8%A1%8C%E4%B8%BA%E7%9A%84%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E3%80%82%E5%AE%9E%E7%8E%B0AOP%E7%9A%84%E6%8A%80%E6%9C%AF%EF%BC%8C%E4%B8%BB%E8%A6%81%E5%88%86%E4%B8%BA%E4%B8%A4%E5%A4%A7%E7%B1%BB%EF%BC%9A%E4%B8%80%E6%98%AF%E9%87%87%E7%94%A8%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%EF%BC%8C%E5%88%A9%E7%94%A8%E6%88%AA%E5%8F%96%E6%B6%88%E6%81%AF%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%AF%B9%E8%AF%A5%E6%B6%88%E6%81%AF%E8%BF%9B%E8%A1%8C%E8%A3%85%E9%A5%B0%EF%BC%8C%E4%BB%A5%E5%8F%96%E4%BB%A3%E5%8E%9F%E6%9C%89%E5%AF%B9%E8%B1%A1%E8%A1%8C%E4%B8%BA%E7%9A%84%E6%89%A7%E8%A1%8C%EF%BC%9B%E4%BA%8C%E6%98%AF%E9%87%87%E7%94%A8%E9%9D%99%E6%80%81%E7%BB%87%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%BC%95%E5%85%A5%E7%89%B9%E5%AE%9A%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%9B%E5%BB%BA%E2%80%9C%E6%96%B9%E9%9D%A2%E2%80%9D%EF%BC%8C%E4%BB%8E%E8%80%8C%E4%BD%BF%E5%BE%97%E7%BC%96%E8%AF%91%E5%99%A8%E5%8F%AF%E4%BB%A5%E5%9C%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E9%97%B4%E7%BB%87%E5%85%A5%E6%9C%89%E5%85%B3%E2%80%9C%E6%96%B9%E9%9D%A2%E2%80%9D%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%B1%9E%E4%BA%8E%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%0A%0A%0A%E5%9C%A8Java%E5%B9%B3%E5%8F%B0%E4%B8%8A%EF%BC%8C%E5%AF%B9%E4%BA%8EAOP%E7%9A%84%E7%BB%87%E5%85%A5%EF%BC%8C%E6%9C%893%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%0A*%20%E7%BC%96%E8%AF%91%E6%9C%9F%EF%BC%9A%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%EF%BC%8C%E7%94%B1%E7%BC%96%E8%AF%91%E5%99%A8%E6%8A%8A%E5%88%87%E9%9D%A2%E8%B0%83%E7%94%A8%E7%BC%96%E8%AF%91%E8%BF%9B%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%8C%E8%BF%99%E7%A7%8D%E6%96%B9%E5%BC%8F%E9%9C%80%E8%A6%81%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E5%B9%B6%E6%89%A9%E5%B1%95%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%8CAspectJ%E5%B0%B1%E6%89%A9%E5%B1%95%E4%BA%86Java%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97aspect%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%BB%87%E5%85%A5%EF%BC%9B%0A*%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9A%E5%9C%A8%E7%9B%AE%E6%A0%87%E7%B1%BB%E8%A2%AB%E8%A3%85%E8%BD%BD%E5%88%B0JVM%E6%97%B6%EF%BC%8C%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%AF%B9%E7%9B%AE%E6%A0%87%E7%B1%BB%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E9%87%8D%E6%96%B0%E2%80%9C%E5%A2%9E%E5%BC%BA%E2%80%9D%EF%BC%9B%0A*%20%E8%BF%90%E8%A1%8C%E6%9C%9F%EF%BC%9A%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%88%87%E9%9D%A2%E9%83%BD%E6%98%AF%E6%99%AE%E9%80%9AJava%E7%B1%BB%EF%BC%8C%E9%80%9A%E8%BF%87JVM%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%9F%E8%83%BD%E6%88%96%E8%80%85%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%AE%9E%E7%8E%B0%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%8A%A8%E6%80%81%E7%BB%87%E5%85%A5%E3%80%82%0A%0A%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E5%BC%8F%E6%98%AF%E7%AC%AC%E4%B8%89%E7%A7%8D%EF%BC%8CSpring%E7%9A%84AOP%E5%AE%9E%E7%8E%B0%E5%B0%B1%E6%98%AF%E5%9F%BA%E4%BA%8EJVM%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E3%80%82%E7%94%B1%E4%BA%8EJVM%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%A6%81%E6%B1%82%E5%BF%85%E9%A1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E7%B1%BB%E6%B2%A1%E6%9C%89%E4%B8%9A%E5%8A%A1%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%B0%B1%E9%9C%80%E8%A6%81%E9%80%9A%E8%BF%87CGLIB%E6%88%96%E8%80%85Javassist%E8%BF%99%E4%BA%9B%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%AE%9E%E7%8E%B0%E3%80%82%0A%23%23%23%20%E4%BD%9C%E7%94%A8%2F%E4%BC%98%E5%8A%BF%0A**%E4%BD%9C%E7%94%A8%EF%BC%9A**%0A%0AAOP%E9%87%87%E5%8F%96%E6%A8%AA%E5%90%91%E6%8A%BD%E5%8F%96%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%8F%96%E4%BB%A3%E4%BA%86%E4%BC%A0%E7%BB%9F%E7%BA%B5%E5%90%91%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E7%9A%84%E9%87%8D%E5%A4%8D%E6%80%A7%E4%BB%A3%E7%A0%81%EF%BC%88%E6%80%A7%E8%83%BD%E7%9B%91%E8%A7%86%EF%BC%8C%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%EF%BC%8C%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5%EF%BC%8C%E7%BC%93%E5%AD%98%EF%BC%89%0A%0A%E5%9C%A8%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9C%9F%E9%97%B4%EF%BC%8C%E4%B8%8D%E4%BF%AE%E6%94%B9%E6%BA%90%E7%A0%81%E5%AF%B9%E5%B7%B2%E6%9C%89%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%A2%9E%E5%BC%BA%0A%0A%E5%B0%86%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%A4%84%E7%90%86%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%88%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%EF%BC%8C%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%EF%BC%89%E8%A7%A3%E8%80%A6%0A%0A**%E4%BC%98%E5%8A%BF%EF%BC%9A**%0A*%20%E5%87%8F%E5%B0%91%E9%87%8D%E5%A4%8D%E4%BB%A3%E7%A0%81%0A*%20%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%0A*%20%E7%BB%B4%E6%8A%A4%E6%96%B9%E4%BE%BF%0A%0A%23%23%23%20Spring%20%E6%A1%86%E6%9E%B6%E7%9A%84AOP%0A%0A*%20Spring%20%E6%A1%86%E6%9E%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6%E6%98%AF**%E9%9D%A2%E5%90%91%E6%96%B9%E9%9D%A2%E7%9A%84%E7%BC%96%E7%A8%8B**(AOP)%E6%A1%86%E6%9E%B6%E3%80%82%E9%9D%A2%E5%90%91%E6%96%B9%E9%9D%A2%E7%9A%84%E7%BC%96%E7%A8%8B%E9%9C%80%E8%A6%81%E6%8A%8A%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E5%88%86%E8%A7%A3%E6%88%90%E4%B8%8D%E5%90%8C%E7%9A%84%E9%83%A8%E5%88%86%E7%A7%B0%E4%B8%BA%E6%89%80%E8%B0%93%E7%9A%84%E5%85%B3%E6%B3%A8%E7%82%B9%E3%80%82%E8%B7%A8%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%A4%9A%E4%B8%AA%E7%82%B9%E7%9A%84%E5%8A%9F%E8%83%BD%E8%A2%AB%E7%A7%B0%E4%B8%BA**%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9**%EF%BC%8C%E8%BF%99%E4%BA%9B%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9%E5%9C%A8%E6%A6%82%E5%BF%B5%E4%B8%8A%E7%8B%AC%E7%AB%8B%E4%BA%8E%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E3%80%82%E6%9C%89%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BE%88%E5%A5%BD%E7%9A%84%E6%96%B9%E9%9D%A2%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%8C%E5%A6%82%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E3%80%81%E5%AE%A1%E8%AE%A1%E3%80%81%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E7%BC%93%E5%AD%98%E7%AD%89%E3%80%82%0A*%20%E5%9C%A8%20OOP%20%E4%B8%AD%EF%BC%8C%E5%85%B3%E9%94%AE%E5%8D%95%E5%85%83%E6%A8%A1%E5%9D%97%E5%BA%A6%E6%98%AF%E7%B1%BB%EF%BC%8C%E8%80%8C%E5%9C%A8%20AOP%20%E4%B8%AD%E5%8D%95%E5%85%83%E6%A8%A1%E5%9D%97%E5%BA%A6%E6%98%AF%E6%96%B9%E9%9D%A2%E3%80%82%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%B8%AE%E5%8A%A9%E4%BD%A0%E5%AF%B9%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AF%B9%E8%B1%A1%E7%9B%B8%E4%BA%92%E8%A7%A3%E8%80%A6%E5%92%8C%20AOP%20%E5%8F%AF%E4%BB%A5%E5%B8%AE%E5%8A%A9%E4%BD%A0%E4%BB%8E%E5%AE%83%E4%BB%AC%E6%89%80%E5%BD%B1%E5%93%8D%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%AF%B9%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9%E8%A7%A3%E8%80%A6%E3%80%82%0A*%20**%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9%EF%BC%9A**%20%E8%B7%A8%E8%B6%8A%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%A4%9A%E4%B8%AA%E6%A8%A1%E5%9D%97%E7%9A%84%E6%96%B9%E6%B3%95%E6%88%96%E5%8A%9F%E8%83%BD%E3%80%82%EF%BC%88%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%81%9A%E7%94%B1%E4%B8%80%E7%BB%84%E5%85%B3%E6%B3%A8%E7%82%B9%E5%8D%B3%E4%B8%9A%E5%8A%A1%E6%88%96%E5%8A%9F%E8%83%BD%E6%88%96%E6%96%B9%E6%B3%95%E7%BB%84%E6%88%90%EF%BC%8C%E5%85%B6%E4%B8%AD%EF%BC%8C%E7%9B%B4%E6%8E%A5%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%85%B3%E6%B3%A8%E7%82%B9%E6%98%AF%E7%9B%B4%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9%EF%BC%8C%E8%80%8C%E4%B8%BA%E7%9B%B4%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9%E6%9C%8D%E5%8A%A1%E7%9A%84%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9%EF%BC%89%EF%BC%8C%E5%8D%B3%E4%B8%8E%E6%88%91%E4%BB%AC%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%97%A0%E5%85%B3%E7%9A%84%EF%BC%8C%E4%BD%86%E6%98%AF%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E5%85%B3%E6%B3%A8%E7%9A%84%E9%83%A8%E5%88%86%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9%0A%23%23%23%23%20AOP%E6%9C%AF%E8%AF%AD%0A%0A%7C%20%E9%A1%B6%20%7C%20%E6%8F%8F%E8%BF%B0%20%7C%0A%7C%20—%20%7C%20—%20%7C%0A%7C%20%E5%88%87%E9%9D%A2(Aspect)%20%7C%20%E6%98%AF%E5%88%87%E5%85%A5%E7%82%B9%E5%92%8C%E9%80%9A%E7%9F%A5%E7%9A%84%E7%BB%93%E5%90%88%20%7C%0A%7C%20%E7%9B%AE%E6%A0%87(Target)%20%7C%20%E8%A2%AB%E9%80%9A%E7%9F%A5%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%8D%B3%E4%B8%9A%E5%8A%A1%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%20%7C%0A%7C%20%E4%BB%A3%E7%90%86(Proxy)%20%7C%20%E4%B8%80%E4%B8%AA%E7%B1%BB%E8%A2%ABAOP%E7%BB%87%E5%85%A5%E5%A2%9E%E5%BC%BA%E5%90%8E%EF%BC%8C%E5%B0%B1%E4%BA%A7%E7%94%9F%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%9C%E4%BB%A3%E7%90%86%E7%B1%BB%20%7C%0A%7C%20%E5%88%87%E5%85%A5%E7%82%B9(PointCut)%20%7C%20%E5%88%87%E9%9D%A2%E9%80%9A%E7%9F%A5%E6%89%A7%E8%A1%8C%E7%9A%84%E2%80%9C%E5%9C%B0%E7%82%B9%E2%80%9D%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9B%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9C%9F%E6%AD%A3%E8%A2%AB%E5%88%87%E9%9D%A2%E7%BB%87%E5%85%A5%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E5%88%87%E5%85%A5%E7%82%B9%E4%B8%80%E5%AE%9A%E6%98%AF%E8%BF%9E%E6%8E%A5%E7%82%B9%EF%BC%8C%E4%BD%86%E8%BF%9E%E6%8E%A5%E7%82%B9%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%98%AF%E5%88%87%E5%85%A5%E7%82%B9%EF%BC%8C%E8%A2%AB%E6%A0%87%E8%AE%B0%E4%B8%BAfinal%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E4%B8%8D%E8%83%BD%E4%BD%9C%E7%94%A8%E8%BF%9E%E6%8E%A5%E7%82%B9%E4%B8%8E%E5%88%87%E5%85%A5%E7%82%B9%E7%9A%84%20%7C%0A%7C%20%E8%BF%9E%E6%8E%A5%E7%82%B9(JointPoint)%20%7C%20%E4%B8%8E%E5%88%87%E5%85%A5%E7%82%B9%E5%8C%B9%E9%85%8D%E7%9A%84%E6%89%A7%E8%A1%8C%E7%82%B9%EF%BC%8C%E5%8D%B3%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%88%87%E9%9D%A2%EF%BC%88%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%EF%BC%89%E7%BB%87%E5%85%A5%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E6%89%80%E6%9C%89%E8%A6%81%E7%9B%91%E6%8E%A7%E7%9A%84%E6%96%B9%E6%B3%95%E9%83%BD%E7%A7%B0%E4%B8%BA%E8%BF%9E%E6%8E%A5%E7%82%B9%EF%BC%8C%E5%B0%B1%E6%98%AF**%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95**%20%7C%0A%7C%20%E9%80%9A%E7%9F%A5(Advice)%20%7C%20%E9%80%9A%E7%9F%A5%E6%98%AF%E5%88%87%E9%9D%A2%EF%BC%88%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%EF%BC%89%E7%9A%84%E4%B8%80%E7%A7%8D%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%AE%8C%E6%88%90%E7%AE%80%E5%8D%95%E7%9A%84%E7%BB%87%E5%85%A5%E5%8A%9F%E8%83%BD%E3%80%82%E9%80%9A%E7%9F%A5%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E5%88%87%E9%9D%A2%E7%BB%87%E5%85%A5%E7%9A%84%E6%97%B6%E9%97%B4%E7%82%B9%EF%BC%8C%E5%88%87%E5%85%A5%E7%82%B9%E5%AE%9A%E4%B9%89%E4%BA%86%E5%88%87%E9%9D%A2%E7%BB%87%E5%85%A5%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%9B**%E9%92%88%E5%AF%B9%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%8D%E5%A4%9F%E7%81%B5%E6%B4%BB**%20%7C%0A%7C%20%E9%A1%BE%E9%97%AE(Advisor)%20%7C%20%E9%A1%BE%E9%97%AE%E6%98%AF%E5%88%87%E9%9D%A2%EF%BC%88%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%EF%BC%89%E7%9A%84%E4%B8%80%E7%A7%8D%EF%BC%8C%E8%83%BD%E5%A4%9F%E5%B0%86%E9%80%9A%E7%9F%A5%E4%BB%A5%E6%9B%B4%E4%B8%BA%E5%A4%8D%E6%9D%82%E7%9A%84%E7%9A%84%E6%96%B9%E5%BC%8F%E7%BB%87%E5%85%A5%E5%88%B0%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E4%B8%AD%EF%BC%8C%E6%98%AF%E5%B0%86%E9%80%9A%E7%9F%A5%E5%8C%85%E8%A3%85%E4%B8%BA%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E5%88%87%E9%9D%A2%E7%9A%84%E8%A3%85%E9%85%8D%E5%99%A8%20%7C%0A%0A!%5Bf1de713ace79cf9d6fa0f0a2a940d506.png%5D(en-resource%3A%2F%2Fdatabase%2F1015%3A1)%0A%0A!%5B6cbc28f4ef49c048a16e392bab58bfa0.png%5D(en-resource%3A%2F%2Fdatabase%2F1008%3A1)%0A%0A%23%23%20AOP%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%9E%8B%0A%0A%23%23%23%20%E7%B1%BB%E5%9E%8B%0A%23%23%23%23%20Spring%E8%87%AA%E8%BA%AB%E5%AE%9E%E7%8E%B0%0A1.%20<strong>ProxyFactory</strong>%EF%BC%9A%3Cu%3E%E7%BC%96%E7%A8%8B%E5%BC%8F%3C%2Fu%3E%E4%BD%BF%E7%94%A8AOP%0A2.%20<strong>ProxyFactoryBean</strong>%EF%BC%9A%3Cu%3E%E5%A3%B0%E6%98%8E%E5%BC%8F%3C%2Fu%3E%E4%BD%BF%E7%94%A8AOP%EF%BC%8C%E4%B8%93%E9%97%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B7%A5%E5%8E%82%0A%20%20%20%20*%20<strong>Advice%E9%80%9A%E7%9F%A5</strong>%20%E4%BD%BF%E7%94%A8%E6%9B%B4%E7%AE%80%E5%8D%95%0A%20%20%20%20*%20<strong>Advisor%E9%A1%BE%E9%97%AE</strong>%20%E6%93%8D%E7%BA%B5%E6%9B%B4%E7%81%B5%E6%B4%BB%0A%0A%3E%20%E5%BA%95%E5%B1%82%E5%8F%88%E5%88%86%E4%B8%BA<strong>JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0</strong>%20%E5%92%8C%20<strong>CGLib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0</strong>%0A%0A%23%23%23%23%20AspectJ%E5%AE%9E%E7%8E%B0%0A1.%20<strong>AspectJProxyFactory</strong>%EF%BC%9A%E9%9B%86%E6%88%90spring%E4%B8%8EAspect%E5%AE%9E%E7%8E%B0AOP%0A%0A%0A!%5B8b2720317ad74dc6d20fe320a0508d84.png%5D(en-resource%3A%2F%2Fdatabase%2F1010%3A1)%0A%0A*%20**%E8%BF%99%E4%B8%89%E4%B8%AA%E7%B1%BB%E9%83%BD%E7%BB%A7%E6%89%BF%E8%87%AA**%0A%20%20%20%20*%20ProxyConfig%EF%BC%9A%E6%8F%90%E4%BE%9B%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%0A%20%20%20%20*%20AdvisedSupport%EF%BC%9A%E5%B0%81%E8%A3%85%E4%BA%86%E9%80%9A%E7%9F%A5%E4%B8%8E%E9%80%9A%E7%9F%A5%E5%99%A8%0A%20%20%20%20*%20ProxyCreatorSupport%EF%BC%9A%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E8%BE%85%E5%8A%A9%E7%B1%BB%0A%0A%0A%23%23%23%20AOP%E5%AE%9E%E7%8E%B0%E4%B9%8BAspectJ%0A%0AAspectJ%E6%98%AF%E4%B8%80%E4%B8%AAjava%E5%AE%9E%E7%8E%B0%E7%9A%84AOP%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%AE%83%E8%83%BD%E5%A4%9F%E5%AF%B9java%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8CAOP%E7%BC%96%E8%AF%91%EF%BC%88%E4%B8%80%E8%88%AC%E5%9C%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E8%BF%9B%E8%A1%8C%EF%BC%89%EF%BC%8C%E8%AE%A9java%E4%BB%A3%E7%A0%81%E5%85%B7%E6%9C%89AspectJ%E7%9A%84AOP%E5%8A%9F%E8%83%BD%EF%BC%88%E5%BD%93%E7%84%B6%E9%9C%80%E8%A6%81%E7%89%B9%E6%AE%8A%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%89%0A%0A%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E8%AF%B4AspectJ%E6%98%AF%E7%9B%AE%E5%89%8D%E5%AE%9E%E7%8E%B0AOP%E6%A1%86%E6%9E%B6%E4%B8%AD%E6%9C%80%E6%88%90%E7%86%9F%EF%BC%8C%E5%8A%9F%E8%83%BD%E6%9C%80%E4%B8%B0%E5%AF%8C%E7%9A%84%E8%AF%AD%E8%A8%80%EF%BC%8C%E6%9B%B4%E5%B9%B8%E8%BF%90%E7%9A%84%E6%98%AF%EF%BC%8CAspectJ%E4%B8%8Ejava%E7%A8%8B%E5%BA%8F%E5%AE%8C%E5%85%A8%E5%85%BC%E5%AE%B9%EF%BC%8C%E5%87%A0%E4%B9%8E%E6%98%AF%E6%97%A0%E7%BC%9D%E5%85%B3%E8%81%94%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%AF%B9%E4%BA%8E%E6%9C%89java%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%8C%E4%B8%8A%E6%89%8B%E5%92%8C%E4%BD%BF%E7%94%A8%E9%83%BD%E9%9D%9E%E5%B8%B8%E5%AE%B9%E6%98%93%E3%80%82%0A%0A%E4%BA%86%E8%A7%A3AspectJ%E5%BA%94%E7%94%A8%E5%88%B0java%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%88%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E7%A7%B0%E4%B8%BA%E7%BB%87%E5%85%A5%EF%BC%89%EF%BC%8C%E5%AF%B9%E4%BA%8E%E7%BB%87%E5%85%A5%E8%BF%99%E4%B8%AA%E6%A6%82%E5%BF%B5%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E4%B8%BAaspect(%E5%88%87%E9%9D%A2)%E5%BA%94%E7%94%A8%E5%88%B0%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0(%E7%B1%BB)%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82%0A%0A%E5%AF%B9%E4%BA%8E%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%EF%BC%8C**%E4%B8%80%E8%88%AC%E5%88%86%E4%B8%BA%E5%8A%A8%E6%80%81%E7%BB%87%E5%85%A5%E5%92%8C%E9%9D%99%E6%80%81%E7%BB%87%E5%85%A5%EF%BC%8C%E5%8A%A8%E6%80%81%E7%BB%87%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%98%AF%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E5%B0%86%E8%A6%81%E5%A2%9E%E5%BC%BA%E7%9A%84%E4%BB%A3%E7%A0%81%E7%BB%87%E5%85%A5%E5%88%B0%E7%9B%AE%E6%A0%87%E7%B1%BB%E4%B8%AD**%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%BE%80%E5%BE%80%E6%98%AF%E9%80%9A%E8%BF%87%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%E5%AE%8C%E6%88%90%E7%9A%84%EF%BC%8C%E5%A6%82%3Cu%3EJava%20JDK%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86(Proxy%EF%BC%8C%E5%BA%95%E5%B1%82%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%AE%9E%E7%8E%B0)%3C%2Fu%3E%E6%88%96%E8%80%85%3Cu%3ECGLIB%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86(%E5%BA%95%E5%B1%82%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0)%3C%2Fu%3E%EF%BC%8CSpring%20AOP%E9%87%87%E7%94%A8%E7%9A%84%E5%B0%B1%E6%98%AF%E5%9F%BA%E4%BA%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A2%9E%E5%BC%BA%E7%9A%84%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%0A%0A<strong>ApectJ%E9%87%87%E7%94%A8%E7%9A%84%E5%B0%B1%E6%98%AF%E9%9D%99%E6%80%81%E7%BB%87%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F</strong>%E3%80%82ApectJ%E4%B8%BB%E8%A6%81%E9%87%87%E7%94%A8%E7%9A%84%E6%98%AF%E7%BC%96%E8%AF%91%E6%9C%9F%E7%BB%87%E5%85%A5%EF%BC%8C%E5%9C%A8%E8%BF%99%E4%B8%AA%E6%9C%9F%E9%97%B4%E4%BD%BF%E7%94%A8AspectJ%E7%9A%84acj%E7%BC%96%E8%AF%91%E5%99%A8(%E7%B1%BB%E4%BC%BCjavac)%E6%8A%8Aaspect%E7%B1%BB%E7%BC%96%E8%AF%91%E6%88%90class%E5%AD%97%E8%8A%82%E7%A0%81%E5%90%8E%EF%BC%8C%E5%9C%A8java%E7%9B%AE%E6%A0%87%E7%B1%BB%E7%BC%96%E8%AF%91%E6%97%B6%E7%BB%87%E5%85%A5%EF%BC%8C%E5%8D%B3%E5%85%88%E7%BC%96%E8%AF%91aspect%E7%B1%BB%E5%86%8D%E7%BC%96%E8%AF%91%E7%9B%AE%E6%A0%87%E7%B1%BB%E3%80%82%0A%0A<strong>spring%E6%95%B4%E5%90%88%E4%BA%86ApectJ%E6%A1%86%E6%9E%B6%EF%BC%8C%E4%BD%86%E6%98%AF%E5%BA%95%E5%B1%82%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8acj%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%8C%E8%80%8C%E6%98%AF%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF</strong>%0A%0A!%5B684cc877c0b4266dc290fdf4ad997f10.png%5D(en-resource%3A%2F%2Fdatabase%2F1017%3A2)%0A%0A%23%23%23%20AOP%E5%AE%9E%E7%8E%B0%E4%B9%8BSpring%20AOP%0A**%E6%9C%AC%E8%B4%A8%E7%9B%AE%E7%9A%84%E5%B0%B1%E6%98%AF%E5%AF%B9%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AE%80%E5%8C%96%EF%BC%8C%E4%B8%BA%E4%BA%86%E6%96%B9%E4%BE%BF%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%AE%80%E5%8C%96%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%8C%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86**%0A%0Aspring%20AOP%E6%98%AF%E9%80%9A%E8%BF%87**%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0**%E7%9A%84%0A%0A*%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%89%EF%BC%9A**%E5%9F%BA%E4%BA%8EJDK%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86**%E5%92%8C%E4%BD%BF%E7%94%A8<strong>CGLib%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86</strong>%0A*%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%E9%80%89%E6%8B%A9%EF%BC%9A%E6%A0%B9%E6%8D%AE%E6%98%AF%E5%90%A6%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E6%9D%A5%E9%80%89%E6%8B%A9%E5%93%AA%E7%A7%8D%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%0A%0A!%5B190c537f5e1b7054e148f07281d52a7e.png%5D(en-resource%3A%2F%2Fdatabase%2F1016%3A1)%0A%0A%23%23%23%23%20%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%0A1.%20%E5%A3%B0%E6%98%8E%E6%8E%A5%E5%8F%A3%EF%BC%9A%E6%B3%A8%E5%86%8C%E9%9C%80%E8%A6%81%E8%A2%AB%E7%9B%91%E5%90%AC%E8%A1%8C%E4%B8%BA%E7%9A%84%E5%90%8D%E7%A7%B0%0A2.%20%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%9A%E6%89%AE%E6%BC%94%E8%A2%AB%E7%9B%91%E6%8E%A7%E7%9A%84%E7%B1%BB%EF%BC%8C%E8%B4%9F%E8%B4%A3%E8%A2%AB%E7%9B%91%E5%90%AC%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%0A3.%20InvocationHanler%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%9A%0A%20%20%20%20*%20%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%2F%E5%A2%9E%E5%BC%BA%E4%B8%9A%E5%8A%A1%0A%20%20%20%20*%20%E5%B0%86%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%E4%B8%8E%E8%A2%AB%E7%9B%91%E5%90%AC%E6%96%B9%E6%B3%95%E7%BB%91%E5%AE%9A%E6%89%A7%E8%A1%8C%0A4.%20%E4%BB%A3%E7%90%86%E7%9B%91%E6%8E%A7%E5%AF%B9%E8%B1%A1%EF%BC%9A%0A%20%20%20%20*%20%E8%A2%AB%E7%9B%91%E6%8E%A7%E7%B1%BB%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%A2%AB%E7%9B%91%E6%8E%A7%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%8E%A5%E5%8F%A3%EF%BC%8CInvocationHanler%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%0A%0A%23%23%23%23%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%0A1.%20%E5%9F%BA%E4%BA%8EJDK%EF%BC%88%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%EF%BC%89%0A2.%20%E4%BD%BF%E7%94%A8CGLib%EF%BC%88%E9%83%BD%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%EF%BC%89%0A%0ASpring%E4%B8%A4%E7%A7%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%E9%83%BD%E6%9C%89%E4%BD%BF%E7%94%A8%EF%BC%8C%E9%80%9A%E8%BF%87%E6%98%AF%E5%90%A6%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E6%9D%A5%E5%88%A4%E6%96%AD%E7%94%A8%E5%93%AA%E4%B8%AA%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%0A%0A%23%23%23%23%23%20JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%0A**%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%BF%85%E9%A1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3**%0A%0A%E4%BD%BF%E7%94%A8Proxy%E7%B1%BB%E6%9D%A5%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A%0A%60%60%60java%0A%C2%A0%C2%A0%C2%A0%20%2F**%0A%C2%A0%C2%A0%C2%A0%C2%A0%20*%20%E4%BD%BF%E7%94%A8JDK%E7%9A%84%E6%96%B9%E5%BC%8F%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%0A%C2%A0%C2%A0%C2%A0%C2%A0%20*%20%40author%20Administrator%0A%C2%A0%C2%A0%C2%A0%C2%A0%20*%2F%0A%C2%A0%C2%A0%C2%A0%20public%20class%20MyProxyUtils%20%7B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20public%20static%20UserService%20getProxy(final%20UserService%20service)%20%7B%0A%20%20%20%20%20%20%20%20%2F%2FPorxy%E6%98%AFJDK%E4%B8%AD%E7%9A%84API%E7%B1%BB%0A%20%20%20%20%20%20%20%20%2F%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%9A%E7%9B%AE%E6%A0%87%E9%98%9F%E5%BD%A2%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%0A%20%20%20%20%20%20%20%20%2F%2F%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%9A%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8E%A5%E5%8F%A3%0A%20%20%20%20%20%20%20%20%2F%2F%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%9A%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E5%A4%84%E7%90%86%E5%99%A8%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%2F%2F%20%E4%BD%BF%E7%94%A8Proxy%E7%B1%BB%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20UserService%20proxy%20%3D%20%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20(UserService)%20Proxy.newProxyInstance(%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20service.getClass().getClassLoader()%2C%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20service.getClass().getInterfaces()%2C%20%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20new%20InvocationHandler()%20%7B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%2F%2F%20%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B8%80%E6%89%A7%E8%A1%8C%EF%BC%8Cinvoke%E6%96%B9%E6%B3%95%E5%B0%B1%E4%BC%9A%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20public%20Object%20invoke(Object%20proxy%2C%20Method%20method%2C%20Object%5B%5D%20args)%20throws%20Throwable%20%7B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20if(%22save%22.equals(method.getName()))%7B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20System.out.println(%22%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97…%22)%3B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%2F%2F%20%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%7D%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%2F%2F%20%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%2F%2F%20%E8%AE%A9service%E7%B1%BB%E7%9A%84save%E6%88%96%E8%80%85update%E6%96%B9%E6%B3%95%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8B%E5%8E%BB%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20return%20method.invoke(service%2C%20args)%3B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%7D%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%7D)%3B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%2F%2F%20%E8%BF%94%E5%9B%9E%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20return%20proxy%3B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%7D%0A%C2%A0%C2%A0%C2%A0%20%7D%0A%60%60%60%0A%0A%23%23%23%23%23%20CGLib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%0A**%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E4%B8%8D%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3**%0A%E5%BA%95%E5%B1%82%E6%98%AF%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E4%BA%A7%E7%94%9F%E4%BB%A3%E7%90%86%E5%AD%90%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BB%A3%E7%90%86%E5%AD%90%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%BB%A7%E6%89%BF%E4%BA%86%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%E5%B9%B6%E5%8F%AF%E4%BB%A5%E5%AF%B9%E8%AF%A5%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%A2%9E%E5%BC%BA%EF%BC%89%0A%0A%60%60%60java%0Apublic%20static%20UserService%20getProxy()%7B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%2F%2F%20%E5%88%9B%E5%BB%BACGLIB%E6%A0%B8%E5%BF%83%E7%9A%84%E7%B1%BB%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20Enhancer%20enhancer%20%3D%20new%20Enhancer()%3B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%2F%2F%20%E8%AE%BE%E7%BD%AE%E7%88%B6%E7%B1%BB%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20enhancer.setSuperclass(UserServiceImpl.class)%3B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%2F%2F%20%E8%AE%BE%E7%BD%AE%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20enhancer.setCallback(new%20MethodInterceptor()%20%7B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%40Override%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20public%20Object%20intercept(Object%20obj%2C%20Method%20method%2C%20Object%5B%5D%20args%2C%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20MethodProxy%20methodProxy)%20throws%20Throwable%20%7B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20if(%22save%22.equals(method.getName()))%7B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%2F%2F%20%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20System.out.println(%22%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%E4%BA%86…%22)%3B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%7D%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20return%20methodProxy.invokeSuper(obj%2C%20args)%3B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%7D%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%7D)%3B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%2F%2F%20%E7%94%9F%E6%88%90%E5%A2%9E%E5%BC%BA%E4%B9%8B%E5%90%8E%E7%9A%84%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20UserService%20proxy%20%3D%20(UserService)%20enhancer.create()%3B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20return%20proxy%3B%0A%C2%A0%C2%A0%C2%A0%20%7D%0A%60%60%60%0A%23%23%23%23%20Spring%20AOP%EF%BC%9A%E7%AE%80%E5%8C%96%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%0A1.%20%E5%A3%B0%E6%98%8E%E6%8E%A5%E5%8F%A3%EF%BC%9A%E6%B3%A8%E5%86%8C%E9%9C%80%E8%A6%81%E8%A2%AB%E7%9B%91%E5%90%AC%E8%A1%8C%E4%B8%BA%E5%90%8D%E7%A7%B0%0A2.%20%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%9A%E6%89%AE%E6%BC%94%E8%A2%AB%E7%9B%91%E6%8E%A7%E7%9A%84%E7%B1%BB%EF%BC%8C%E8%B4%9F%E8%B4%A3%E8%A2%AB%E7%9B%91%E5%90%AC%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%0A3.%20%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%2F%E5%A2%9E%E5%BC%BA%E4%B8%9A%E5%8A%A1%0A%0A**%E6%89%80%E4%BB%A5%E8%AF%B4spring%20AOP%E5%90%A7%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%845%E4%B8%AA%E6%AD%A5%E9%AA%A4%E7%9C%81%E7%95%A5%E4%B8%BA3%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%8C%E5%8F%AA%E9%9C%80%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%85%B3%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%EF%BC%8C%E5%86%8D%E5%8A%A0%E4%BB%A5%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F**%0A%0ASpring%20AOP%E4%B8%AD%E7%9A%84%E6%96%B0%E5%A2%9E%E5%90%8D%E8%AF%8D%E4%B9%9F%E5%9F%BA%E6%9C%AC%E9%83%BD%E6%98%AF%E4%B8%BA%E4%BA%86%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%80%8C%E6%9C%8D%E5%8A%A1%E7%9A%84%EF%BC%8C%E5%AE%83%E7%9A%84**%E6%9C%AC%E8%B4%A8%E5%B0%B1%E6%98%AF%E4%B8%BA%E4%BA%86%E7%AE%80%E5%8C%96%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0**%0A%0A%0A%23%23%20Spring%20AOP%20%E4%BD%BF%E7%94%A8%0A%0ASpring%20AOP%E6%98%AF%E6%8C%87Spring%E8%87%AA%E8%BA%AB%E5%AF%B9AOP%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%B8%8EAspectJ%E6%97%A0%E5%85%B3%E7%B3%BB%0A%0A%0A%23%23%23%20%E7%BC%96%E7%A8%8B%E5%BC%8FAOP%20ProxyFactory%0A%0A%23%23%23%23%20%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%B7%A5%E5%8E%82%EF%BC%8C%E8%AE%BE%E7%BD%AE%E8%A2%AB%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%B7%BB%E5%8A%A0%E9%80%9A%E7%9F%A5%0A%60%60%60java%0Apackage%20com.zhangguo.Spring041.aop05%3B%0A%0Aimport%20org.springframework.aop.framework.ProxyFactory%3B%0A%0Apublic%20class%20Test%20%7B%0A%0A%20%20%20%20%40org.junit.Test%0A%20%20%20%20public%20void%20test01()%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%E5%AE%9E%E4%BE%8B%E5%8C%96Spring%E4%BB%A3%E7%90%86%E5%B7%A5%E5%8E%82%0A%20%20%20%20%20%20%20%20ProxyFactory%20factory%3Dnew%20ProxyFactory()%3B%0A%20%20%20%20%20%20%20%20%2F%2F%E8%AE%BE%E7%BD%AE%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E5%AF%B9%E8%B1%A1%0A%20%20%20%20%20%20%20%20factory.setTarget(new%20Math())%3B%0A%20%20%20%20%20%20%20%20%2F%2F%E6%B7%BB%E5%8A%A0%E9%80%9A%E7%9F%A5%EF%BC%8C%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%0A%20%20%20%20%20%20%20%20factory.addAdvice(new%20BeforeAdvice())%3B%0A%20%20%20%20%20%20%20%20factory.addAdvice(new%20AfterAdvice())%3B%0A%20%20%20%20%20%20%20%20factory.addAdvice(new%20SurroundAdvice())%3B%0A%20%20%20%20%20%20%20%20%2F%2F%E4%BB%8E%E4%BB%A3%E7%90%86%E5%B7%A5%E5%8E%82%E4%B8%AD%E8%8E%B7%E5%BE%97%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%0A%20%20%20%20%20%20%20%20IMath%20math%3D(IMath)%20factory.getProxy()%3B%0A%20%20%20%20%20%20%20%20int%20n1%3D100%2Cn2%3D5%3B%0A%20%20%20%20%20%20%20%20math.add(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.sub(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.mut(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.div(n1%2C%20n2)%3B%0A%20%20%20%20%7D%0A%20%20%20%20%40org.junit.Test%0A%20%20%20%20public%20void%20test02()%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%2F%2Fmessage.message()%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A*%20%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%0A!%5B14990dfb14f83774e14078db4f5fb0bc.png%5D(en-resource%3A%2F%2Fdatabase%2F1006%3A1)%0A%0A%23%23%23%20%E5%A3%B0%E6%98%8E%E5%BC%8FAOP%20ProxyFactoryBean%0A%23%23%23%23%20Advice%0A%0A%0A**%E9%80%9A%E7%9F%A5Advice%E7%9A%84%E7%B1%BB%E5%9E%8B**%0A*%20springAOP%E4%B8%AD%EF%BC%8C%E9%80%9A%E8%BF%87Advice%E5%AE%9A%E4%B9%89%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%EF%BC%8CSpring%E4%B8%AD%E6%94%AF%E6%8C%815%E4%B8%AD%E7%B1%BB%E5%9E%8B%E7%9A%84Advice%0A%0A%7C%20%E9%80%9A%E7%9F%A5%20%7C%20%E8%BF%9E%E6%8E%A5%E7%82%B9%20%7C%20%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%20%7C%0A%7C%20—%20%7C%20—%20%7C%20—%20%7C%0A%7C%20%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%20%7C%20%E6%96%B9%E6%B3%95%E5%89%8D%20%7C%20org.springframework.aop.MethodBeforeAdvice%20%7C%0A%7C%20%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5%20%7C%20%E6%96%B9%E6%B3%95%E5%90%8E%20%7C%20org.springframework.aop.AfterReturningAdvice%20%7C%0A%7C%20%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%20%7C%20%E6%96%B9%E6%B3%95%E5%89%8D%E5%90%8E%20%7C%20org.aopalliance.intercept.MethodInterceptor%20%7C%0A%7C%20%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%8E%E9%80%9A%E7%9F%A5%20%7C%20%E6%96%B9%E6%B3%95%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%20%7C%20org.springframework.aop.ThrowsAdvice%20%7C%0A%7C%20%E5%BC%95%E4%BB%8B%E9%80%9A%E7%9F%A5%20%7C%20%E7%B1%BB%E4%B8%AD%E5%A2%9E%E5%8A%A0%E6%96%B0%E7%9A%84%E6%96%B9%E6%B3%95%E5%B1%9E%E6%80%A7%20%7C%20org.springframework.aop.IntroductionInterceptor%20%7C%0A%0A**%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5**%0A%60%60%60java%0Apackage%20com.zhangguo.Spring041.aop05%3B%0A%0Aimport%20java.lang.reflect.Method%3B%0A%0Aimport%20org.springframework.aop.MethodBeforeAdvice%3B%0A%0A%2F**%0A%20*%20%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%20%EF%BC%8C%E5%B0%B1%E7%9B%B8%E5%BD%93%E4%BA%8EInvocationHandler%E7%B1%BB%0A%20*%2F%0Apublic%20class%20BeforeAdvice%20implements%20MethodBeforeAdvice%20%7B%0A%0A%20%20%20%20%2F**%0A%20%20%20%20%20*%20method%20%E6%96%B9%E6%B3%95%E4%BF%A1%E6%81%AF%0A%20%20%20%20%20*%20args%20%E5%8F%82%E6%95%B0%0A%20%20%20%20%20*%20target%20%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%0A%20%20%20%20%20*%20%E8%AF%A5%E5%88%87%E9%9D%A2%E4%B8%80%E5%AE%9A%E6%98%AF%E5%9C%A8%E6%89%A7%E8%A1%8C%E4%B8%BB%E8%A6%81%E4%B8%9A%E5%8A%A1%E4%B9%8B%E5%89%8D%E6%89%A7%E8%A1%8C%EF%BC%8C%E6%89%80%E4%BB%A5%E6%96%B9%E6%B3%95%E4%B8%AD%E4%B8%8D%E9%9C%80%E8%A6%81%E5%AF%B9Method%E5%81%9A%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C%0A%20%20%20%20%20*%2F%0A%20%20%20%20public%20void%20before(Method%20method%2C%20Object%5B%5D%20args%2C%20Object%20target)%20throws%20Throwable%20%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22-----------------%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5-----------------%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A**%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5**%0A%60%60%60java%0Apackage%20com.zhangguo.Spring041.aop05%3B%0A%0Aimport%20java.lang.reflect.Method%3B%0A%0Aimport%20org.springframework.aop.AfterReturningAdvice%3B%0A%0A%2F**%0A%20*%20%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5%0A%20*%0A%20*%2F%0Apublic%20class%20AfterAdvice%20implements%20AfterReturningAdvice%20%7B%0A%20%20%20%20%2F*%0A%20%20%20%20%20*%20returnValue%20%E8%BF%94%E5%9B%9E%E5%80%BC%0A%20%20%20%20%20*%20method%20%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%0A%20%20%20%20%20*%20args%20%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%0A%20%20%20%20%20*%20target%20%E8%A2%AB%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%0A%20%20%20%20%20*%2F%0A%20%20%20%20public%20void%20afterReturning(Object%20returnValue%2C%20Method%20method%2C%20Object%5B%5D%20args%2C%20Object%20target)%20throws%20Throwable%20%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22-----------------%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5-----------------%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A**%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5**%0A%60%60%60java%0Apackage%20com.zhangguo.Spring041.aop05%3B%0A%0Aimport%20org.aopalliance.intercept.MethodInterceptor%3B%0Aimport%20org.aopalliance.intercept.MethodInvocation%3B%0A%0A%2F**%0A%20*%20%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%0A%20*%20%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA%E5%99%A8%0A%20*%0A%20*%2F%0Apublic%20class%20SurroundAdvice%20implements%20MethodInterceptor%20%7B%0A%0A%20%20%20%20public%20Object%20invoke(MethodInvocation%20i)%20throws%20Throwable%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%E5%89%8D%E7%BD%AE%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%0A%20%20%20%20%20%20%20%20System.out.println(%22%E6%96%B9%E6%B3%95%22%20%2B%20i.getMethod()%20%2B%20%22%20%E8%A2%AB%E8%B0%83%E7%94%A8%E5%9C%A8%E5%AF%B9%E8%B1%A1%22%20%2B%20i.getThis()%20%2B%20%22%E4%B8%8A%EF%BC%8C%E5%8F%82%E6%95%B0%20%22%20%2B%20i.getArguments())%3B%0A%20%20%20%20%20%20%20%20%2F%2F%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%0A%20%20%20%20%20%20%20%20Object%20ret%20%3D%20i.proceed()%3B%0A%20%20%20%20%20%20%20%20%2F%2F%E5%90%8E%E7%BD%AE%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%0A%20%20%20%20%20%20%20%20System.out.println(%22%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A%22%2B%20ret)%3B%0A%20%20%20%20%20%20%20%20return%20ret%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A%0A%23%23%23%23%23%20%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%0A%60%60%60java%0A%2F**%0A%20*%20%E6%8E%A5%E5%8F%A3%0A%20*%20%E6%8A%BD%E8%B1%A1%E4%B8%BB%E9%A2%98%0A%20*%2F%0Apublic%20interface%20IMath%20%7B%0A%20%20%20%20%2F%2F%E5%8A%A0%0A%20%20%20%20int%20add(int%20n1%2C%20int%20n2)%3B%2F%2FJoinCut%20%E8%BF%9E%E6%8E%A5%E7%82%B9%0A%20%20%20%20%2F%2F%E5%87%8F%0A%20%20%20%20int%20sub(int%20n1%2C%20int%20n2)%3B%2F%2FJoinCut%20%E8%BF%9E%E6%8E%A5%E7%82%B9%0A%20%20%20%20%2F%2F%E4%B9%98%0A%20%20%20%20int%20mut(int%20n1%2C%20int%20n2)%3B%2F%2FJoinCut%20%E8%BF%9E%E6%8E%A5%E7%82%B9%0A%20%20%20%20%2F%2F%E9%99%A4%0A%20%20%20%20int%20div(int%20n1%2C%20int%20n2)%3B%2F%2FJoinCut%20%E8%BF%9E%E6%8E%A5%E7%82%B9%0A%7D%0A%60%60%60%0A%23%23%23%23%23%20%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%0A%60%60%60java%0A%2F**%0A%20*%20%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%0A%20*%E7%9C%9F%E5%AE%9E%E4%B8%BB%E9%A2%98%0A%20*%2F%0Apublic%20class%20Math%20implements%20IMath%20%7B%0A%20%20%20%20%2F%2F%E5%8A%A0%0A%20%20%20%20public%20int%20add(int%20n1%2Cint%20n2)%7B%2F%2F%E5%88%87%E5%85%A5%E7%82%B9%20PointCut%20%20%E4%B8%BB%E8%A6%81%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%B3%95%0A%20%20%20%20%20%20%20%20int%20result%3Dn1%2Bn2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22%2B%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%20%20%20%20%2F%2F%E5%87%8F%0A%20%20%20%20public%20int%20sub(int%20n1%2Cint%20n2)%7B%2F%2F%E5%88%87%E5%85%A5%E7%82%B9%20PointCut%20%20%E4%B8%BB%E8%A6%81%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%B3%95%0A%20%20%20%20%20%20%20%20int%20result%3Dn1-n2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22-%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%20%20%20%20%2F%2F%E4%B9%98%0A%20%20%20%20public%20int%20mut(int%20n1%2Cint%20n2)%7B%2F%2F%E5%88%87%E5%85%A5%E7%82%B9%20PointCut%20%20%E4%B8%BB%E8%A6%81%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%B3%95%0A%20%20%20%20%20%20%20%20int%20result%3Dn1<em>n2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22X%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%20%20%20%20%2F%2F%E9%99%A4%0A%20%20%20%20public%20int%20div(int%20n1%2Cint%20n2)%7B%2F%2F%E5%88%87%E5%85%A5%E7%82%B9%20PointCut%20%20%E4%B8%BB%E8%A6%81%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%B3%95%0A%20%20%20%20%20%20%20%20int%20result%3Dn1%2Fn2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22%2F%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A%23%23%23%23%23%20%E5%AE%9A%E4%B9%89Advice%0A%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8FInvocationHandler%0A%60%60%60java%0A%2F</em>%0A%20*%20%20%20public%20class%20Agent%20implements%20InvocationHandler%7B%0A%20*%20%20%20%0A%20*%20%20%20%20%20%20private%20BaseService%20obj%3B%2F%2F%E5%BD%93%E5%89%8D%E5%85%B7%E4%BD%93%E8%A2%AB%E7%9B%91%E6%8E%A7%E5%AF%B9%E8%B1%A1%0A%20*%20%20%20%20%20%20public%20Agent(BasseSercie%20param)%7B%0A%20*%20%20%20%20%20%20%20%20%20%20this.obj%20%3D%20param%3B%0A%20*%20%20%20%20%20%20%7D%0A%20*%20%20%20%20%20%20public%20Object%20invoke(Object%20proxy%2CMethod%20method%2CObject%5B%5D%20args)%7B%0A%20*%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E7%BB%87%E5%85%A5%E9%A1%BA%E5%BA%8F%0A%20*%20%20%20%20%20%20%7D%0A%20*%20%20%20%20%20%20%2F%2F%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%0A%20*%20%20%20%20%20%20public%20wash()%7B%0A%20*%20%20%20%20%20%20%7D%0A%20*%20%20%20%7D%0A%20*%20%0A%20*%20*%2F%0A%60%60%60%0A**%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5**%0A%60%60%60java%0Aimport%20java.lang.reflect.Method%3B%0Aimport%20org.springframework.aop.AfterReturningAdvice%3B%0A%2F**%0A%20*%20%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5%0A%20*%0A%20*%2F%0Apublic%20class%20AfterAdvice%20implements%20AfterReturningAdvice%20%7B%0A%20%20%20%20%2F*%0A%20%20%20%20%20*%20returnValue%20%E8%BF%94%E5%9B%9E%E5%80%BC%0A%20%20%20%20%20*%20method%20%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%0A%20%20%20%20%20*%20args%20%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%0A%20%20%20%20%20*%20target%20%E8%A2%AB%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%0A%20%20%20%20%20*%20%E5%88%87%E9%9D%A2%EF%BC%8C%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%0A%20%20%20%20%20*%2F%0A%20%20%20%20public%20void%20afterReturning(Object%20returnValue%2C%20Method%20method%2C%20Object%5B%5D%20args%2C%20Object%20target)%20throws%20Throwable%20%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22%E5%85%B1%E7%94%A8%E6%97%B6%EF%BC%9Atime%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A%23%23%23%23%23%20%E4%BD%BF%E7%94%A8IOC%E9%85%8D%E7%BD%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%0A*%20%E5%BC%95%E5%85%A5spring%20IOC%E7%9A%84%E6%A0%B8%E5%BF%83jar%E5%8C%85%0A*%20%E5%88%9B%E5%BB%BAIOC%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6beans.xml%0A%60%60%60XML%0A%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%3F%3E%0A%3Cbeans%20xmlns%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%22%0A%20%20%20%20xmlns%3Axsi%3D%22http%3A%2F%<a href="http://2Fwww.w3.org">2Fwww.w3.org</a>%2F2001%2FXMLSchema-instance%22%20xmlns%3Ap%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fp%22%0A%20%20%20%20xsi%3AschemaLocation%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%2Fspring-beans.xsd%22%3E%0A%20%20%20%20%3C!–%20%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%20%EF%BC%8C%E6%B3%A8%E5%86%8C%E8%A2%AB%E7%9B%91%E6%8E%A7%E5%AE%9E%E7%8E%B0%E7%B1%BB–%3E%0A%20%20%20%20%3Cbean%20id%3D%22target%22%20class%3D%22com.zhangguo.Spring041.aop06.Math%22%3E%3C%2Fbean%3E%0A%20%20%20%20%3C!–%E9%80%9A%E7%9F%A5%E3%80%81%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%EF%BC%8C%E6%B3%A8%E5%86%8C%E9%80%9A%E7%9F%A5%E5%AE%9E%E7%8E%B0%E7%B1%BB–%3E%0A%20%20%20%20%3Cbean%20id%3D%22advice%22%20class%3D%22com.zhangguo.Spring041.aop06.AfterAdvice%22%3E%3C%2Fbean%3E%0A%20%20%20%20%3C!–%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%2C%E6%B3%A8%E5%86%8C%E4%BB%A3%E7%90%86%E7%9B%91%E6%8E%A7%E5%AF%B9%E8%B1%A1%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%8E%82%20–%3E%0A%20%20%20%20%3C!–interceptorNames%20%E9%80%9A%E7%9F%A5%E6%95%B0%E7%BB%84%20–%3E%0A%20%20%20%20%3C!–p%3Atarget-ref%20%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E5%AF%B9%E8%B1%A1–%3E%0A%20%20%20%20%3C!–p%3AproxyTargetClass%20%E8%A2%AB%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%98%AF%E5%88%99%E4%BD%BF%E7%94%A8cglib%2C%E5%90%A6%E5%88%99%E4%BD%BF%E7%94%A8jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%20%20–%3E%0A%20%20%20%20%3Cbean%20id%3D%22proxy%22%20class%3D%22org.springframework.aop.framework.ProxyFactoryBean%22%0A%20%20%20%20%20%20%20%20p%3AinterceptorNames%3D%22advice%22%0A%20%20%20%20%20%20%20%20p%3Atarget-ref%3D%22target%22%0A%20%20%20%20%20%20%20%20p%3AproxyTargetClass%3D%22true%22%3E%3C%2Fbean%3E%0A%3C%2Fbeans%3E%0A%20%20%20%20%3C!–%0A%20%20%20%20p%3AinterceptorNames%3D%22advice%22%E7%AD%89%E4%BB%B7%E4%BA%8E%3Cproperty%20name%3D%22interceptorNames%22%20value%3D%22advice%22%3E%3C%2Fproperty%3E%0A%20%20%20%20p%3Atarget-ref%3D%22target%22%E7%AD%89%E4%BB%B7%E4%BA%8E%3Cproperty%20name%3D%22target%22%20ref%3D%22target%22%3E%3C%2Fbean%3E%0A%20%20%20%20–%3E%0A%60%60%60%0A*%20%E8%8E%B7%E5%8F%96%E4%BB%A3%E7%90%86%E7%B1%BB%E5%B9%B6%E6%89%A7%E8%A1%8C%0A%60%60%60java%0Apackage%20com.zhangguo.Spring041.aop06%3B%0A%0Aimport%20org.springframework.context.ApplicationContext%3B%0Aimport%20org.springframework.context.support.ClassPathXmlApplicationContext%3B%0A%0Apublic%20class%20Test%20%7B%0A%0A%20%20%20%20%40org.junit.Test%0A%20%20%20%20public%20void%20test01()%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%E5%AE%B9%E5%99%A8%0A%20%20%20%20%20%20%20%20ApplicationContext%20ctx%3Dnew%20ClassPathXmlApplicationContext(%22beans.xml%22)%3B%0A%20%20%20%20%20%20%20%20%2F%2F%E4%BB%8E%E4%BB%A3%E7%90%86%E5%B7%A5%E5%8E%82%E4%B8%AD%E8%8E%B7%E5%BE%97%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%0A%20%20%20%20%20%20%20%20IMath%20math%3D(IMath)ctx.getBean(%22proxy%22)%3B%0A%20%20%20%20%20%20%20%20int%20n1%3D100%2Cn2%3D5%3B%0A%20%20%20%20%20%20%20%20math.add(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.sub(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.mut(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.div(n1%2C%20n2)%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A*%20%E8%BE%93%E5%87%BA%0A!%5B85c1048f46d8ee0d65a9b050af2b582e.png%5D(en-resource%3A%2F%2Fdatabase%2F1009%3A1)%0A%23%23%23%23%23%20%E5%B0%8F%E7%BB%93%0A*%20**%E8%BF%99%E9%87%8C%E6%9C%89%E4%B8%AA%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98**%EF%BC%9A%E4%BB%8E%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%8E%B7%E5%BE%97proxy%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%BA%94%E8%AF%A5%E6%98%AForg.springframework.aop.framework.ProxyFactoryBean%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1(%E5%A6%82%E4%B8%8B%E4%BB%A3%E7%A0%81%E6%89%80%E7%A4%BA)%EF%BC%8C%E4%BD%86%E8%BF%99%E9%87%8C%E7%9B%B4%E6%8E%A5%E5%B0%B1%E8%BD%AC%E6%8D%A2%E6%88%90IMath%E7%B1%BB%E5%9E%8B%E4%BA%86%EF%BC%8C%E8%BF%99%E6%98%AF%E5%9B%A0%E4%B8%BA%EF%BC%9AProxyFactoryBean%E6%9C%AC%E8%B4%A8%E4%B8%8A%E6%98%AF%E4%B8%80%E4%B8%AA%E7%94%A8%E6%9D%A5%E7%94%9F%E4%BA%A7Proxy%E7%9A%84FactoryBean%E3%80%82%E5%A6%82%E6%9E%9C%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%8C%81%E6%9C%89%E6%9F%90%E4%B8%AAFactoryBean%E7%9A%84%E5%BC%95%E7%94%A8%EE%80%84%E5%AE%83%E5%8F%96%E5%BE%97%E7%9A%84%E4%B8%8D%E6%98%AFFactoryBean%E6%9C%AC%E8%BA%AB%E8%80%8C%E6%98%AF%20FactoryBean%E7%9A%84getObject()%E6%96%B9%E6%B3%95%E6%89%80%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AF%B9%E8%B1%A1%E3%80%82%E6%89%80%E4%BB%A5%E5%A6%82%E6%9E%9C%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BE%9D%E8%B5%96%E4%BA%8EProxyFactoryBean%E9%82%A3%E4%B9%88%E5%AE%83%E5%B0%86%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%88%B0%20ProxyFactoryBean%E7%9A%84getObject()%E6%96%B9%E6%B3%95%E6%89%80%E8%BF%94%E5%9B%9E%E7%9A%84%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E8%BF%99%E5%B0%B1%E6%98%AFProxyFactryBean%E5%BE%97%E4%BB%A5%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8E%9F%E5%9B%A0%0A%0A%3E%20**%E9%80%9A%E7%9F%A5Advice%E7%9A%84%E5%BC%8A%E7%AB%AF%E6%98%AF%EF%BC%8C%E5%AE%83%E5%8F%AA%E5%8F%AF%E4%BB%A5%E5%AF%B9%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%BB%87%E5%85%A5%E5%88%87%E9%9D%A2**%0A%3E%20%E4%BC%9A%E5%BC%BA%E8%A1%8C%E7%9A%84%E4%B8%8E%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%BB%91%E5%AE%9A%0A%0A%23%23%23%23%20Advisor%20%E9%A1%BE%E9%97%AE%0A%E6%AD%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%AF%94advice%E6%9B%B4%E5%8A%A0%E7%81%B5%E6%B4%BB%EF%BC%8C%E5%8F%AA%E9%9C%80%E5%A4%9A%E5%AE%9E%E7%8E%B0%E5%87%A0%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%E7%9B%B8%E5%90%8C%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%9B%B4%E5%8A%A0%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%0A%23%23%23%23%23%20%E5%A3%B0%E6%98%8E%E6%8E%A5%E5%8F%A3%0A%60%60%60java%0Apublic%20interface%20BaseService%20%7B%0A%20%20%20%20%20%20%20public%20void%20eat()%3B%2F%2FJoinCut%20%E8%BF%9E%E6%8E%A5%E7%82%B9%0A%20%20%20%20%20%20%20public%20void%20wc()%3B%2F%2FJoinCut%20%E8%BF%9E%E6%8E%A5%E7%82%B9%0A%7D%0A%60%60%60%0A%23%23%23%23%23%20%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%0A%60%60%60java%0Aimport%20com.kaikeba.service.BaseService%3B%0A%0Apublic%20class%20Person%20implements%20BaseService%20%7B%0A%0A%09public%20void%20eat()%20%7B%2F%2F%E5%88%87%E5%85%A5%E7%82%B9%20PointCut%20%20%E4%B8%BB%E8%A6%81%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%B3%95%0A%09%09%0A%20%20%20%20%20%20%20%20%20%20%20System.out.println(%22%E5%90%83%E6%B3%A1%E9%9D%A2%22)%3B%0A%09%7D%0A%09public%20void%20wc()%20%7B%2F%2F%E5%88%87%E5%85%A5%E7%82%B9%20PointCut%20%20%20%E4%B8%BB%E8%A6%81%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%B3%95%0A%09%09%0A%09%09%20System.out.println(%22%E4%B8%8A%E5%8E%95%E6%89%80%22)%3B%0A%09%7D%0A%7D%0A%60%60%60%0A%23%23%23%23%23%20%E5%88%87%E9%9D%A2Advice%0A%E6%AC%A1%E8%A6%81%E6%96%B9%E6%B3%95%0A%60%60%60java%0Aimport%20java.lang.reflect.Method%3B%0A%0Aimport%20org.springframework.aop.Advisor%3B%0Aimport%20org.springframework.aop.MethodBeforeAdvice%3B%0Aimport%20org.springframework.aop.framework.ProxyFactoryBean%3B%0A%2F*%0A%20*%20%0A%20*%20%20%20public%20class%20Agent%20implements%20InvocationHandler%7B%0A%20*%20%20%20%0A%20*%20%20%20%20%20%20private%20BaseService%20obj%3B%2F%2F%E5%BD%93%E5%89%8D%E5%85%B7%E4%BD%93%E8%A2%AB%E7%9B%91%E6%8E%A7%E5%AF%B9%E8%B1%A1%0A%20*%20%20%20%20%20%20%0A%20*%20%20%20%20%20%20public%20Agent(BasseSercie%20param)%7B%0A%20*%20%20%20%20%20%20%20%20%20%20this.obj%20%3D%20param%3B%0A%20*%20%20%20%20%20%20%7D%0A%20*%20%20%20%0A%20*%20%20%20%20%20%20public%20Object%20invoke(Object%20proxy%2CMethod%20method%2CObject%5B%5D%20args)%7B%0A%20*%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E7%BB%87%E5%85%A5%E9%A1%BA%E5%BA%8F%0A%20*%20%20%20%20%20%20%7D%0A%20*%20%20%20%20%20%20%0A%20*%20%20%20%20%20%20%2F%2F%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%0A%20*%20%20%20%20%20%20public%20wash()%7B%0A%20*%20%20%20%20%20%20%0A%20*%20%20%20%20%20%20%7D%0A%20*%20%20%20%7D%0A%20*%20%0A%20*%20*%2F%0Apublic%20class%20MyBeforeAdvice%20implements%20MethodBeforeAdvice%20%7B%0A%0A%09%2F%2F%E5%88%87%E9%9D%A2%EF%BC%9A%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%0A%09public%20void%20before(Method%20arg0%2C%20Object%5B%5D%20arg1%2C%20Object%20arg2)%20throws%20Throwable%20%7B%0A%09%09System.out.println(%22-----%E6%B4%97%E6%89%8B-----%22)%3B%0A%20%20%20%20%20%20%20%20%0A%09%7D%0A%7D%0A%60%60%60%0A%23%23%23%23%23%20ClassFilter%20%E7%B1%BB%E6%8B%A6%E6%88%AA%E5%99%A8%0A%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E8%A2%AB%E6%8B%A6%E6%88%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%8D%E6%98%AF%E5%BD%93%E5%89%8D%E9%A1%BE%E9%97%AE%E9%9C%80%E8%A6%81%E7%AE%A1%E7%90%86%E5%AF%B9%E8%B1%A1%0A%60%60%60java%0Aimport%20org.springframework.aop.ClassFilter%3B%0A%0Aimport%20com.kaikeba.serviceImpl.Person%3B%0A%0Apublic%20class%20MyClassFilter%20implements%20ClassFilter%20%7B%0A%0A%09%20%2F*%0A%09%20%20*%20%201.%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%E4%B8%8B%E4%BC%9A%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%AE%9E%E7%8E%B0%E7%B1%BB%0A%09%20%20*%20%202.%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%98%AF%E4%B8%8D%E6%98%AF%E6%88%91%E4%BB%AC%E7%BB%87%E5%85%A5%E6%96%B9%E5%BC%8F%E5%85%B3%E5%BF%83%E7%9A%84%E7%9B%AE%E6%A0%87%E7%B1%BB%0A%09%20%20*%20%20BaseService%E6%8E%A5%E5%8F%A3%E6%88%91%E4%BB%AC%E7%8E%B0%E5%9C%A8%E5%8F%AA%E6%83%B3%E7%AE%A1%E7%90%86Person.%0A%09%20%20*%20%20%E5%8F%82%E6%95%B0%EF%BC%9A%E5%B0%B1%E6%98%AF%E5%BD%93%E5%89%8D%E8%A2%AB%E6%8B%A6%E6%88%AA%E7%B1%BB%EF%BC%9A%E5%8F%AF%E8%83%BDPerson%EF%BC%8C%E5%8F%AF%E8%83%BDGog%0A%09%20%20*%20*%2F%0A%09public%20boolean%20matches(Class%3C%3F%3E%20clazz)%20%7B%0A%09%20%20%20%20if(clazz%20%3D%3D%20Person.class)%7B%0A%09%20%20%20%20%09return%20true%3B%2F%2F%E5%91%8A%E8%AF%89%E9%A1%BE%E9%97%AE%EF%BC%8C%E5%BD%93%E5%89%8D%E7%B1%BB%E6%98%AF%E9%9C%80%E8%A6%81%E6%88%91%E4%BB%AC%E6%8F%90%E4%BE%9B%E7%BB%87%E5%85%A5%E6%9C%8D%E5%8A%A1%0A%09%20%20%20%20%7D%0A%09%20%20%20%20%2F%2FGog%0A%09%09return%20false%3B%0A%09%7D%0A%0A%7D%0A%60%60%60%0A%23%23%23%23%23%20MethodMatcher%20%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA%E5%99%A8%0A%E5%BD%93%E5%89%8D%E8%A2%AB%E6%8B%A6%E6%88%AA%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E4%B8%8D%E6%98%AF%E6%88%91%E4%BB%AC%E6%89%80%E9%9C%80%E8%A6%81%E4%B8%BB%E8%A6%81%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%B3%95%0A%60%60%60java%0Aimport%20java.lang.reflect.Method%3B%0A%0Aimport%20org.springframework.aop.MethodMatcher%3B%0A%0Apublic%20class%20MyMethodMatcher%20implements%20MethodMatcher%20%7B%0A%0A%09%2F*%0A%09%20*%20%20%E8%A2%AB%E7%9B%91%E6%8E%A7%E6%8E%A5%E5%8F%A3%E6%AF%94%E5%A6%82%EF%BC%88BaseService%EF%BC%89%EF%BC%8C%E6%B2%A1%E6%9C%89%E9%87%8D%E8%BD%BD%E6%96%B9%E6%B3%95%0A%09%20*%20%20%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0%E9%83%BD%E6%98%AF%E4%BB%A5%E5%94%AF%E4%B8%80%0A%09%20*%20%20%E6%AD%A4%E6%97%B6%E5%8F%AF%E4%BB%A5%E9%87%87%E7%94%A8%20static%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%8F%AA%E6%A0%B9%E6%8D%AE%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0%E5%88%A4%E6%96%AD%0A%09%20*%20%E5%8F%82%E6%95%B0%EF%BC%9Amethod%3A%20%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%9F%90%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%0A%09%20*%20%20%20%20%20targetClass%3A%20%E6%8E%A5%E5%8F%A3%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%8E%B0%E7%B1%BB%0A%09%20*%20%20%20%20%20%0A%09%20*%20%20%E4%B8%9A%E5%8A%A1%EF%BC%9A%E5%8F%AA%E6%83%B3%E4%B8%BAPerson%E7%B1%BB%E4%B8%ADeat%E6%96%B9%E6%B3%95%E6%8F%90%E4%BE%9B%E7%BB%87%E5%85%A5%20%20%20%0A%09%20*%2F%0A%09%0A%09public%20boolean%20matches(Method%20method%2C%20Class%3C%3F%3E%20targetClass)%20%7B%0A%09%09%0A%09%09String%20methodName%20%3D%20method.getName()%3B%0A%09%09if(%22eat%22.equals(methodName))%7B%0A%09%09%09return%20true%3B%0A%09%09%7D%0A%09%09return%20false%3B%0A%09%7D%0A%0A%09public%20boolean%20isRuntime()%20%7B%0A%09%09%2F%2F%20TODO%20Auto-generated%20method%20stub%0A%09%09return%20false%3B%0A%09%7D%0A%0A%09public%20boolean%20matches(Method%20method%2C%20Class%3C%3F%3E%20targetClass%2C%20Object…%20args)%20%7B%0A%09%09%2F%2F%20TODO%20Auto-generated%20method%20stub%0A%09%09return%20false%3B%0A%09%7D%0A%0A%7D%0A%0A%60%60%60%0A%23%23%23%23%23%20PointCut%0A%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%0A%60%60%60java%0Aimport%20org.springframework.aop.ClassFilter%3B%0Aimport%20org.springframework.aop.MethodMatcher%3B%0Aimport%20org.springframework.aop.Pointcut%3B%0A%0Apublic%20class%20MyPointCut%20implements%20Pointcut%20%7B%0A%09%0A%09%0A%09%2F*%0A%09%20*%20InvocationHandler%E6%8E%A5%E5%8F%A3%0A%09%20*%20%20%20%20invoke()%7B%0A%09%20*%20%20%20%20%20%20%20%20if(obj.getClass%20%EF%BC%81%3D%20person.class)%7B%0A%09%20*%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%0A%09%20*%20%20%20%20%20%20%20%20%7D%0A%09%20*%20%20%20%20%20%20%20%20%0A%09%20*%20%20%20%20%20%20%20%20if(!methodObj.getName.equals(%22eat%22))%7B%0A%09%20*%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%0A%09%20*%20%20%20%20%20%20%20%20%7D%0A%09%20*%20%20%20%20%20%20%20%20%2F%2F%E7%BB%87%E5%85%A5%E6%96%B9%E5%BC%8F%3A%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%B3%95%E5%92%8C%20Peson.eat()%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%0A%09%20*%20%20%20%20%20%20%20%20%2F%2F%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%0A%09%20*%20%20%20%20%20%20%20%20%20%20wash%EF%BC%88%EF%BC%89%EF%BC%9B%0A%09%20*%20%20%20%20%20%20%20%20%20%20Person.eat()%0A%09%20*%20%20%20%20%7D%0A%09%20*%20%0A%09%20*%20*%2F%0A%09%2F%2F%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%0A%09private%20ClassFilter%20classFilter%3B%0A%09private%20MethodMatcher%20metodMatcher%3B%0A%0A%09public%20void%20setClassFilter(ClassFilter%20classFilter)%20%7B%0A%09%09this.classFilter%20%3D%20classFilter%3B%0A%09%7D%0A%0A%09public%20void%20setMetodMatcher(MethodMatcher%20metodMatcher)%20%7B%0A%09%09this.metodMatcher%20%3D%20metodMatcher%3B%0A%09%7D%0A%0A%09public%20ClassFilter%20getClassFilter()%20%7B%0A%09%09%2F%2F%20TODO%20Auto-generated%20method%20stub%0A%09%09return%20this.classFilter%3B%0A%09%7D%0A%0A%09public%20MethodMatcher%20getMethodMatcher()%20%7B%0A%09%09%2F%2F%20TODO%20Auto-generated%20method%20stub%0A%09%09return%20this.metodMatcher%3B%0A%09%7D%0A%0A%7D%0A%60%60%60%0A%23%23%23%23%23%20PointCutAdvisor%0A%E5%8F%AF%E4%BB%A5%E7%81%B5%E6%B4%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E5%BD%93%E5%89%8D%E6%8E%A5%E5%8F%A3%E4%B8%8B%E7%9A%84%E5%93%AA%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%AD%E5%93%AA%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E4%B8%8E%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%E8%BF%9B%E8%A1%8C%E7%BB%91%E5%AE%9A%0A%60%60%60java%0Aimport%20org.aopalliance.aop.Advice%3B%0Aimport%20org.springframework.aop.Pointcut%3B%0Aimport%20org.springframework.aop.PointcutAdvisor%3B%0A%0Apublic%20class%20MyPointCutAdvisor%20implements%20PointcutAdvisor%20%7B%0A%09%2F%2F%E9%87%87%E7%94%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%20set%0A%20%20%20%20private%20Advice%20advice%3B%2F%2F%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%E4%BB%A5%E5%8F%8A%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%E4%B8%8E%E4%B8%BB%E8%A6%81%E4%B8%9A%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%0A%20%20%20%20private%20Pointcut%20pointcut%3B%2F%2F%E5%BD%93%E5%89%8D%E6%8B%A6%E6%88%AA%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8%E4%B8%BB%E8%A6%81%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%B3%95%20person%E5%AF%B9%E8%B1%A1.eat()%0A%20%20%20%20%0A%20%20%20%20%0A%20%20%20%20%0A%09public%20void%20setAdvice(Advice%20advice)%20%7B%0A%09%09this.advice%20%3D%20advice%3B%0A%09%7D%0A%0A%09public%20void%20setPointcut(Pointcut%20pointcut)%20%7B%0A%09%09this.pointcut%20%3D%20pointcut%3B%0A%09%7D%0A%0A%09public%20Advice%20getAdvice()%20%7B%0A%09%09%2F%2F%20TODO%20Auto-generated%20method%20stub%0A%09%09return%20this.advice%3B%0A%09%7D%0A%0A%09public%20boolean%20isPerInstance()%20%7B%0A%09%09%2F%2F%20TODO%20Auto-generated%20method%20stub%0A%09%09return%20false%3B%0A%09%7D%0A%0A%09public%20Pointcut%20getPointcut()%20%7B%0A%09%09%2F%2F%20TODO%20Auto-generated%20method%20stub%0A%09%09return%20this.pointcut%3B%0A%09%7D%0A%0A%7D%0A%0A%60%60%60%0A%23%23%23%23%23%20spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%0A%60%60%60xml%0A%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%3F%3E%0A%3Cbeans%20xmlns%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%22%0A%20%20%20%20xmlns%3Axsi%3D%22http%3A%2F%<a href="http://2Fwww.w3.org">2Fwww.w3.org</a>%2F2001%2FXMLSchema-instance%22%0A%20%20%20%20xmlns%3Ap%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fp%22%0A%20%20%20%20xmlns%3Ac%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fc%22%0A%20%20%20%20xsi%3AschemaLocation%3D%22%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%20%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%2Fspring-beans.xsd%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fcontext%20%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fcontext%2Fspring-context.xsd%22%3E%0A%20%20%20%0A%20%20%20%20%20%20%20%3C!–%20%E6%B3%A8%E5%86%8C%E8%A2%AB%E7%9B%91%E6%8E%A7%E5%AE%9E%E7%8E%B0%E7%B1%BB%20–%3E%0A%20%20%20%20%20%20%20%3Cbean%20id%3D%22person%22%20class%3D%22com.kaikeba.serviceImpl.Person%22%3E%3C%2Fbean%3E%0A%20%20%20%20%20%20%20%3Cbean%20id%3D%22dog%22%20class%3D%22com.kaikeba.serviceImpl.Gog%22%3E%3C%2Fbean%3E%0A%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%3C!–%20%E6%B3%A8%E5%86%8C%E9%80%9A%E7%9F%A5%E5%AE%9E%E7%8E%B0%E7%B1%BB%20–%3E%0A%20%20%20%20%20%20%20%3Cbean%20id%3D%22before%22%20class%3D%22com.kaikeba.advice.MyBeforeAdvice%22%3E%3C%2Fbean%3E%0A%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%3C!–%20%E6%B3%A8%E5%86%8C%E7%B1%BB%E5%9E%8B%E8%BF%87%E6%BB%A4%E5%99%A8%20–%3E%0A%20%20%20%20%20%20%20%3Cbean%20id%3D%22classFilter%22%20class%3D%22com.kaikeba.util.MyClassFilter%22%3E%3C%2Fbean%3E%0A%20%20%20%20%20%20%20%3C!–%20%E6%B3%A8%E5%86%8C%E6%96%B9%E6%B3%95%E5%8C%B9%E9%85%8D%E5%99%A8%20–%3E%0A%20%20%20%20%20%20%20%3Cbean%20id%3D%22methodMatcher%22%20class%3D%22com.kaikeba.util.MyMethodMatcher%22%3E%3C%2Fbean%3E%0A%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%3C!–%20%E6%B3%A8%E5%86%8C%E5%88%87%E5%85%A5%E7%82%B9%20–%3E%0A%20%20%20%20%20%20%20%3Cbean%20id%3D%22pointCut%22%20class%3D%22com.kaikeba.util.MyPointCut%22%20%3E%0A%20%20%20%20%20%20%20%20%20%20%3Cproperty%20name%3D%22classFilter%22%20ref%3D%22classFilter%22%3E%3C%2Fproperty%3E%0A%20%20%20%20%20%20%20%20%20%20%3Cproperty%20name%3D%22metodMatcher%22%20ref%3D%22methodMatcher%22%3E%3C%2Fproperty%3E%0A%20%20%20%20%20%20%20%3C%2Fbean%3E%0A%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%3C!–%20%E6%B3%A8%E5%86%8C%E9%A1%BE%E9%97%AE%20–%3E%0A%20%20%20%20%20%20%20%3Cbean%20id%3D%22myAdvisor%22%20class%3D%22com.kaikeba.util.MyPointCutAdvisor%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%3Cproperty%20name%3D%22advice%22%20ref%3D%22before%22%3E%3C%2Fproperty%3E%0A%20%20%20%20%20%20%20%20%20%20%20%3Cproperty%20name%3D%22pointcut%22%20ref%3D%22pointCut%22%3E%3C%2Fproperty%3E%0A%20%20%20%20%20%20%20%3C%2Fbean%3E%0A%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%3C!–%20%E6%B3%A8%E5%86%8C%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E5%B7%A5%E5%8E%82%20–%3E%0A%20%20%20%20%20%20%20%3C!–%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E6%AD%A4%E6%97%B6%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%8F%AA%E4%BC%9A%E8%B4%9F%E8%B4%A3person.eat%E6%96%B9%E6%B3%95%E7%9B%91%E6%8E%A7%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E4%B8%8EAdvice%E4%B8%8D%E5%90%8C%EF%BC%8C%E4%B8%8D%E4%BC%9A%E5%AF%B9BaseService%E6%89%80%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%9B%91%E6%8E%A7%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20–%3E%0A%20%20%20%20%20%20%20%3Cbean%20id%3D%22personProxy%22%20class%3D%22org.springframework.aop.framework.ProxyFactoryBean%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cproperty%20name%3D%22target%22%20ref%3D%22person%22%3E%3C%2Fproperty%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cproperty%20name%3D%22interceptorNames%22%20value%3D%22myAdvisor%22%3E%3C%2Fproperty%3E%0A%20%20%20%20%20%20%20%3C%2Fbean%3E%0A%3C%2Fbeans%3E%0A%60%60%60%0A%0A%0A%23%23%20AspectJ%20AOP%EF%BC%88%E4%B8%80%E8%88%AC%E4%BD%BF%E7%94%A8%E8%AF%A5%E6%96%B9%E5%BC%8F%EF%BC%89%0A%0A<strong>AspectJ%20%E6%98%AFAOP%E5%8D%95%E7%8B%AC%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%8E%B0%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%92%8Cspring%E5%B9%B6%E6%97%A0%E5%85%B3%E7%B3%BB</strong>%0A%0A**%E4%B8%8B%E8%BF%B0%E6%AD%A5%E9%AA%A4%E6%98%AFAspectJ%2BSpring%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%EF%BC%88spring%E8%87%AA%E8%BA%AB%E5%AE%9E%E7%8E%B0%E7%9A%84aop%E6%98%AF%60ProxyFactoryBean%60%EF%BC%89**%0A%0AAspectJ%E6%98%AF%E4%B8%80%E4%B8%AAjava%E5%AE%9E%E7%8E%B0%E7%9A%84AOP%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%AE%83%E8%83%BD%E5%A4%9F%E5%AF%B9java%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8CAOP%E7%BC%96%E8%AF%91%EF%BC%88%E4%B8%80%E8%88%AC%E5%9C%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E8%BF%9B%E8%A1%8C%EF%BC%89%EF%BC%8C%E8%AE%A9java%E4%BB%A3%E7%A0%81%E5%85%B7%E6%9C%89AspectJ%E7%9A%84AOP%E5%8A%9F%E8%83%BD%EF%BC%88%E5%BD%93%E7%84%B6%E9%9C%80%E8%A6%81%E7%89%B9%E6%AE%8A%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%89%0A%0A%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E8%AF%B4AspectJ%E6%98%AF%E7%9B%AE%E5%89%8D%E5%AE%9E%E7%8E%B0AOP%E6%A1%86%E6%9E%B6%E4%B8%AD%E6%9C%80%E6%88%90%E7%86%9F%EF%BC%8C%E5%8A%9F%E8%83%BD%E6%9C%80%E4%B8%B0%E5%AF%8C%E7%9A%84%E8%AF%AD%E8%A8%80%EF%BC%8C%E6%9B%B4%E5%B9%B8%E8%BF%90%E7%9A%84%E6%98%AF%EF%BC%8CAspectJ%E4%B8%8Ejava%E7%A8%8B%E5%BA%8F%E5%AE%8C%E5%85%A8%E5%85%BC%E5%AE%B9%EF%BC%8C%E5%87%A0%E4%B9%8E%E6%98%AF%E6%97%A0%E7%BC%9D%E5%85%B3%E8%81%94%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%AF%B9%E4%BA%8E%E6%9C%89java%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%8C%E4%B8%8A%E6%89%8B%E5%92%8C%E4%BD%BF%E7%94%A8%E9%83%BD%E9%9D%9E%E5%B8%B8%E5%AE%B9%E6%98%93%E3%80%82%0A%0A%E4%BA%86%E8%A7%A3AspectJ%E5%BA%94%E7%94%A8%E5%88%B0java%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%88%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E7%A7%B0%E4%B8%BA%E7%BB%87%E5%85%A5%EF%BC%89%EF%BC%8C%E5%AF%B9%E4%BA%8E%E7%BB%87%E5%85%A5%E8%BF%99%E4%B8%AA%E6%A6%82%E5%BF%B5%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E4%B8%BAaspect(%E5%88%87%E9%9D%A2)%E5%BA%94%E7%94%A8%E5%88%B0%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0(%E7%B1%BB)%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82%0A%0A%E5%AF%B9%E4%BA%8E%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%EF%BC%8C**%E4%B8%80%E8%88%AC%E5%88%86%E4%B8%BA%E5%8A%A8%E6%80%81%E7%BB%87%E5%85%A5%E5%92%8C%E9%9D%99%E6%80%81%E7%BB%87%E5%85%A5%EF%BC%8C%E5%8A%A8%E6%80%81%E7%BB%87%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%98%AF%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E5%B0%86%E8%A6%81%E5%A2%9E%E5%BC%BA%E7%9A%84%E4%BB%A3%E7%A0%81%E7%BB%87%E5%85%A5%E5%88%B0%E7%9B%AE%E6%A0%87%E7%B1%BB%E4%B8%AD**%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%BE%80%E5%BE%80%E6%98%AF%E9%80%9A%E8%BF%87%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%E5%AE%8C%E6%88%90%E7%9A%84%EF%BC%8C%E5%A6%82%3Cu%3EJava%20JDK%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86(Proxy%EF%BC%8C%E5%BA%95%E5%B1%82%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%AE%9E%E7%8E%B0)%3C%2Fu%3E%E6%88%96%E8%80%85%3Cu%3ECGLIB%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86(%E5%BA%95%E5%B1%82%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0)%3C%2Fu%3E%EF%BC%8CSpring%20AOP%E9%87%87%E7%94%A8%E7%9A%84%E5%B0%B1%E6%98%AF%E5%9F%BA%E4%BA%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A2%9E%E5%BC%BA%E7%9A%84%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%0A%0A<strong>ApectJ%E9%87%87%E7%94%A8%E7%9A%84%E5%B0%B1%E6%98%AF%E9%9D%99%E6%80%81%E7%BB%87%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F</strong>%E3%80%82ApectJ%E4%B8%BB%E8%A6%81%E9%87%87%E7%94%A8%E7%9A%84%E6%98%AF%E7%BC%96%E8%AF%91%E6%9C%9F%E7%BB%87%E5%85%A5%EF%BC%8C%E5%9C%A8%E8%BF%99%E4%B8%AA%E6%9C%9F%E9%97%B4%E4%BD%BF%E7%94%A8AspectJ%E7%9A%84acj%E7%BC%96%E8%AF%91%E5%99%A8(%E7%B1%BB%E4%BC%BCjavac)%E6%8A%8Aaspect%E7%B1%BB%E7%BC%96%E8%AF%91%E6%88%90class%E5%AD%97%E8%8A%82%E7%A0%81%E5%90%8E%EF%BC%8C%E5%9C%A8java%E7%9B%AE%E6%A0%87%E7%B1%BB%E7%BC%96%E8%AF%91%E6%97%B6%E7%BB%87%E5%85%A5%EF%BC%8C%E5%8D%B3%E5%85%88%E7%BC%96%E8%AF%91aspect%E7%B1%BB%E5%86%8D%E7%BC%96%E8%AF%91%E7%9B%AE%E6%A0%87%E7%B1%BB%E3%80%82%0A%0A<strong>spring%E6%95%B4%E5%90%88%E4%BA%86ApectJ%E6%A1%86%E6%9E%B6%EF%BC%8C%E4%BD%86%E6%98%AF%E5%BA%95%E5%B1%82%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8acj%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%8C%E8%80%8C%E6%98%AF%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF</strong>%0A%0A!%5B684cc877c0b4266dc290fdf4ad997f10.png%5D(en-resource%3A%2F%2Fdatabase%2F1017%3A2)%0A%0A%23%23%23%20AspectJ%E7%9A%84XML%E5%AE%9E%E7%8E%B0AOP%0A%23%23%23%23%20%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%0A%23%23%23%23%23%20%E7%BC%96%E5%86%99%E7%9B%AE%E6%A0%87%E7%B1%BB%0A%E7%BC%96%E5%86%99%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%88%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%EF%BC%89%0A*%20UserService%E6%8E%A5%E5%8F%A3%0A*%20UserServiceImpl%E5%AE%9E%E7%8E%B0%E7%B1%BB%0A%0A%3E%20%E9%85%8D%E7%BD%AE%E7%9B%AE%E6%A0%87%E7%B1%BB%EF%BC%8C%E5%B0%86%E7%9B%AE%E6%A0%87%E7%B1%BB%E4%BA%A4%E7%BB%99spring%20IoC%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%0A%0A%23%23%23%23%23%20maven%E4%BE%9D%E8%B5%96%0A%60%60%60xml%0A%3C!–%20%E5%9F%BA%E4%BA%8EAspectJ%E7%9A%84aop%E4%BE%9D%E8%B5%96%20–%3E%0A%3Cdependency%3E%0A%20%20%20%20%20%20%3CgroupId%3Eorg.springframework%3C%2FgroupId%3E%0A%20%20%20%20%20%20%3CartifactId%3Espring-aspects%3C%2FartifactId%3E%0A%20%20%20%20%20%20%3Cversion%3E5.0.7.RELEASE%3C%2Fversion%3E%0A%3C%2Fdependency%3E%0A%3C!–%3Cdependency%3E%0A%20%20%20%20%20%20%3CgroupId%3Eaopalliance%3C%2FgroupId%3E%0A%20%20%20%20%20%20%3CartifactId%3Eaopalliance%3C%2FartifactId%3E%0A%20%20%20%20%20%20%3Cversion%3E1.0%3C%2Fversion%3E%0A%3C%2Fdependency%3E–%3E%0A%60%60%60%0A%23%23%23%23%23%20%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAadvice%EF%BC%88%E9%80%9A%E7%9F%A5%EF%BC%89%0A*%20%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAbean%0A%20%20%20%20*%20%E8%AF%A5%E9%80%9A%E7%9F%A5%E4%B8%8D%E5%86%8D%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E4%BB%BB%E4%BD%95%E6%8E%A5%E5%8F%A3%E6%88%96%E7%BB%A7%E6%89%BF%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E7%9A%84bean%E5%8D%B3%E5%8F%AF%EF%BC%8C%E6%96%B9%E6%B3%95**%E5%8F%AF%E4%BB%A5**%EF%BC%88%E4%B9%9F%E5%8F%AF%E4%B8%8D%E5%B8%A6%EF%BC%89%E5%B8%A6%E4%B8%80%E4%B8%AAJoinPoint%E8%BF%9E%E6%8E%A5%E7%82%B9%E5%8F%82%E6%95%B0%EF%BC%8C%E7%94%A8%E4%BA%8E%E8%8E%B7%E5%BE%97%E8%BF%9E%E6%8E%A5%E7%82%B9%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%A6%82%E6%96%B9%E6%B3%95%E5%90%8D%EF%BC%8C%E5%8F%82%E6%95%B0%EF%BC%8C%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%AD%89%0A%60%60%60java%0Apackage%20com.zhangguo.Spring041.aop08%3B%0A%0Aimport%20org.aspectj.lang.JoinPoint%3B%0A%0A%2F**%0A%20*%20%E9%80%9A%E7%9F%A5%0A%20*%2F%0Apublic%20class%20Advices%20%7B%0A%20%20%20%20%2F%2F%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%0A%20%20%20%20public%20void%20before(JoinPoint%20jp)%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22--------------------bofore--------------------%22)%3B%0A%20%20%20%20%20%20%20%20System.out.println(%22%E6%96%B9%E6%B3%95%E5%90%8D%EF%BC%9A%22%2Bjp.getSignature()%2B%22%EF%BC%8C%E5%8F%82%E6%95%B0%EF%BC%9A%22%2Bjp.getArgs().length%2B%22%EF%BC%8C%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%EF%BC%9A%22%2Bjp.getTarget())%3B%0A%20%20%20%20%7D%0A%20%20%20%20%2F%2F%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5%0A%20%20%20%20public%20void%20after(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22--------------------after--------------------%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A*%20%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%BE%88%E5%A4%9A%E7%A7%8D%EF%BC%8C%E6%9C%89%E4%BA%9B%E5%8F%82%E6%95%B0%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%8C%E7%89%B9%E5%88%AB%E6%98%AF%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%0A%20%20%20%20*%20**%E4%B8%8B%E5%88%97%E6%96%B9%E6%B3%95%E5%90%8D%E5%8F%AF%E4%BB%A5%E9%9A%8F%E6%84%8F%E7%BC%96%E5%86%99**%0A%60%60%60java%0A%2F%2F%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%0Apublic%20void%20beforeMethod(JoinPoint%20joinPoint)%0A%0A%2F%2F%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5%0Apublic%20void%20afterMethod(JoinPoint%20joinPoint)%0A%0A%2F%2F%E8%BF%94%E5%9B%9E%E5%80%BC%E9%80%9A%E7%9F%A5%0Apublic%20void%20afterReturning(JoinPoint%20joinPoint%2C%20Object%20result)%0A%0A%2F%2F%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E9%80%9A%E7%9F%A5%0A%2F%2F%E5%9C%A8%E6%96%B9%E6%B3%95%E5%87%BA%E7%8E%B0%E5%BC%82%E5%B8%B8%E6%97%B6%E4%BC%9A%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E5%88%B0%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%8C%87%E5%AE%9A%E5%9C%A8%E5%87%BA%E7%8E%B0%E7%89%B9%E5%AE%9A%E5%BC%82%E5%B8%B8%E6%97%B6%E5%9C%A8%E6%89%A7%E8%A1%8C%E9%80%9A%E7%9F%A5%E4%BB%A3%E7%A0%81%0Apublic%20void%20afterThrowing(JoinPoint%20joinPoint%2C%20Exception%20ex)%0A%0A%2F%2F%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%0A%2F%2F%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E9%9C%80%E8%A6%81%E6%90%BA%E5%B8%A6ProceedingJoinPoint%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%0A%2F%2F%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E7%B1%BB%E4%BC%BC%E4%BA%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%9AProceedingJoinPoint%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%E5%8F%AF%E4%BB%A5%E5%86%B3%E5%AE%9A%E6%98%AF%E5%90%A6%E6%89%A7%E8%A1%8C%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E3%80%82%0A%2F%2F%E8%80%8C%E4%B8%94%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E5%BF%85%E9%A1%BB%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E5%8D%B3%E4%B8%BA%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%0Apublic%20Object%20aroundMethod(ProceedingJoinPoint%20pjd)%7B%0A%20%20%20%20System.out.println(%22%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E5%89%8D%22)%3B%0A%20%20%20%20%2F%2F%E8%B0%83%E7%94%A8%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%0A%20%20%20%20Object%20proceed%20%3D%20pjd.proceed()%3B%20%0A%20%20%20%20System.out.println(%22%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E5%89%8D%22)%3B%0A%20%20%20%20return%20proceed%3B%0A%7D%0A%60%60%60%0A%23%23%23%23%23%20%E9%85%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%0A*%20xml%E9%85%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%EF%BC%8C%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E7%9A%84bean%0A%60%60%60xml%0A%3Cbean%20id%3D%22advices%22%20class%3D%22com.zhangguo.Spring041.aop08.Advices%22%3E%3C%2Fbean%3E%0A…%0A%3C%2Fbean%3E%0A%60%60%60%0A%0A%23%23%23%23%23%20%E9%85%8D%E7%BD%AEAOP%E5%88%87%E9%9D%A2%0A*%20%E5%B0%B1%E6%98%AF%E6%8C%87%E6%98%8E%E4%BD%A0%E7%9A%84%E5%88%87%E9%9D%A2%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%A6%81%E5%9C%A8%E5%93%AA%E4%BA%9B%E7%B1%BB%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E7%9A%84%E5%89%8D%E5%90%8E%E6%89%A7%E8%A1%8C%0A%20%20%20%20*%20%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%A1%88%E4%BE%8B%E6%8C%87%E6%98%8E%E4%BA%86%E6%98%AF%E5%B0%86%E5%88%87%E9%9D%A2%E5%88%87%E5%85%A5service%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%EF%BC%8C%E5%8D%B3%E8%AF%A5%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E5%8F%AA%E8%A6%81%E4%B8%80%E6%89%A7%E8%A1%8C%E5%B0%B1%E8%B0%83%E7%94%A8%E5%88%87%E9%9D%A2%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E9%80%9A%E7%9F%A5%E6%96%B9%E6%B3%95%EF%BC%8C%E8%87%B3%E4%BA%8E%E8%A6%81%E6%89%A7%E8%A1%8C%E5%93%AA%E4%BA%9B%E9%80%9A%E7%9F%A5%E6%96%B9%E6%B3%95%EF%BC%8C%E9%9C%80%E8%A6%81%E5%90%8E%E7%BB%AD%E6%AD%A5%E9%AA%A4%E7%BB%A7%E7%BB%AD%E9%85%8D%E7%BD%AE%0A%0A%60%60%60xml%0A%3Caop%3Aconfig%3E%0A%20%20%20%3Caop%3Aaspect%20id%3D%22myAspect%22%20ref%3D%22aBean%22%3E%0A%20%20%20%20%20%20%3Caop%3Apointcut%20id%3D%22businessService%22%0A%20%20%20%20%20%20%20%20%20expression%3D%22execution(<em>%20com.xyz.myapp.service.</em>.<em>(…))%22%2F%3E%0A%20%20%20%20%20%20%3C!–%20%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%20–%3E%0A%20%20%20%20%20%20%3Caop%3Abefore%20pointcut-ref%3D%22businessService%22%20%0A%20%20%20%20%20%20%20%20%20method%3D%22doRequiredTask%22%2F%3E%0A%20%20%20%20%20%20%3C!–%20%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5%20–%3E%0A%20%20%20%20%20%20%3Caop%3Aafter%20pointcut-ref%3D%22businessService%22%20%0A%20%20%20%20%20%20%20%20%20method%3D%22doRequiredTask%22%2F%3E%0A%20%20%20%20%20%20%3C!–%20%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5%20–%3E%0A%20%20%20%20%20%20%3Caop%3Aafter-returning%20pointcut-ref%3D%22businessService%22%0A%20%20%20%20%20%20%20%20%20returning%3D%22retVal%22%0A%20%20%20%20%20%20%20%20%20method%3D%22doRequiredTask%22%2F%3E%0A%20%20%20%20%20%20%3C!–%20%E5%BC%82%E5%B8%B8%E6%8A%9B%E5%87%BA%E9%80%9A%E7%9F%A5–%3E%0A%20%20%20%20%20%20%3Caop%3Aafter-throwing%20pointcut-ref%3D%22businessService%22%0A%20%20%20%20%20%20%20%20%20throwing%3D%22ex%22%0A%20%20%20%20%20%20%20%20%20method%3D%22doRequiredTask%22%2F%3E%0A%20%20%20%20%20%20%3C!–%20%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%20–%3E%0A%20%20%20%20%20%20%3Caop%3Aaround%20pointcut-ref%3D%22businessService%22%20%0A%20%20%20%20%20%20%20%20%20method%3D%22doRequiredTask%22%2F%3E%0A%20%20%20…%0A%20%20%20%3C%2Faop%3Aaspect%3E%0A%3C%2Faop%3Aconfig%3E%0A%3Cbean%20id%3D%22aBean%22%20class%3D%22…%22%3E%0A…%0A%3C%2Fbean%3E%0A%60%60%60%0A!%5B6906bc90093be45361359b6d422da53f.png%5D(en-resource%3A%2F%2Fdatabase%2F1018%3A1)%0A%0A!%5B7e0223d5cd1e4ba3eeeca3754c226ccb.png%5D(en-resource%3A%2F%2Fdatabase%2F1020%3A1)%0A%0A%23%23%23%23%20%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%0A%3Cu%3E%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A0%BC%E5%BC%8F%3C%2Fu%3E%EF%BC%9A%0A%0A%3Cu%3E</em>%E5%8D%95%E4%B8%AA%E7%82%B9%E7%94%A8%E6%9D%A5%E5%88%86%E5%89%B2%E5%8C%85%E5%90%8D%EF%BC%8C%E7%B1%BB%E5%90%8D%EF%BC%8C%E6%96%B9%E6%B3%95%E5%90%8D*%3C%2Fu%3E%0A%0A<strong>execution(%5B%E4%BF%AE%E9%A5%B0%E7%AC%A6%5D%20%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%20%E5%8C%85%E5%90%8D.%E7%B1%BB%E5%90%8D.%E6%96%B9%E6%B3%95%E5%90%8D(%E5%8F%82%E6%95%B0))</strong>%0A*%20execution%EF%BC%9A%E5%BF%85%E9%A1%BB%E8%A6%81%0A*%20%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A%E5%8F%AF%E7%9C%81%E7%95%A5%0A*%20%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%9A%E5%BF%85%E9%A1%BB%E8%A6%81%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8*%E9%80%9A%E9%85%8D%E7%AC%A6%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%0A%0A*%20**%E5%8C%85%E5%90%8D%C2%A0%EF%BC%9A**%0A%20%20%20%20*%20%E5%A4%9A%E7%BA%A7%E5%8C%85%E4%B9%8B%E9%97%B4%E4%BD%BF%E7%94%A8.%E5%88%86%E5%89%B2%0A%20%20%20%20*%20%E5%8C%85%E5%90%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20*%20%E4%BB%A3%E6%9B%BF%EF%BC%8C%E5%A4%9A%E7%BA%A7%E5%8C%85%E5%90%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%20*%20%E4%BB%A3%E6%9B%BF%0A%20%20%20%20*%20%E5%A6%82%E6%9E%9C%E6%83%B3%E7%9C%81%E7%95%A5%E4%B8%AD%E9%97%B4%E7%9A%84%E5%8C%85%E5%90%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20…%0A*%20**%E7%B1%BB%E5%90%8D%EF%BC%9A**%0A%20%20%20%20*%20%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20*%20%E4%BB%A3%E6%9B%BF%0A%20%20%20%20*%20%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%86%99%E6%88%90%20*%20DaoImpl%0A*%20**%E6%96%B9%E6%B3%95%E5%90%8D%EF%BC%9A**%0A%20%20%20%20*%20%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20*%20%E5%A5%BD%E4%BB%A3%E6%9B%BF%0A%20%20%20%20*%20%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%86%99%E6%88%90add%20*%20%0A*%20**%E5%8F%82%E6%95%B0%EF%BC%9A**%0A%20%20%20%20*%20%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8%20*%20%E4%BB%A3%E6%9B%BF%0A%20%20%20%20*%20%E5%A6%82%E6%9E%9C%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20…%E4%BB%A3%E6%9B%BF%0A%0A!%5B6072916c32e601d94c0f51e6b83d0065.png%5D(en-resource%3A%2F%2Fdatabase%2F1019%3A1)%0A%0A%23%23%23%23%20%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B%0A%0A%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BA%94%E7%A7%8D%EF%BC%89%EF%BC%9A**%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%E3%80%81%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5%E3%80%81%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5%E3%80%81%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E3%80%81%E5%BC%82%E5%B8%B8%E6%8A%9B%E5%87%BA%E9%80%9A%E7%9F%A5**%0A%0A**%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%EF%BC%9A**%0A*%20%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA%EF%BC%9A%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B9%8B%E5%89%8D%E6%89%A7%E8%A1%8C%E9%80%9A%E7%9F%A5%0A*%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9A%3Caop%3Abefore%20method%3D%22before%22%20pointcut-ref%3D%22myPointcut%22%2F%3E%0A*%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%E6%96%B9%E6%B3%95%E5%BC%80%E5%A7%8B%E6%97%B6%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E6%A0%A1%E9%AA%8C%0A%0A**%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5%EF%BC%9A**%0A*%20%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA%EF%BC%9A%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%E9%80%9A%E7%9F%A5%EF%BC%8C%E6%9C%89%E5%BC%82%E5%B8%B8%E5%88%99%E4%B8%8D%E6%89%A7%E8%A1%8C%E4%BA%86%0A*%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9A%3Caop%3Aafter-returning%20method%3D%22afterReturning%22%20%0Apointcut-ref%3D%22myPointcut%22%2F%3E%0A*%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%0A%0A**%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5%EF%BC%9A**%0A*%20%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA%EF%BC%9A%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%E9%80%9A%E7%9F%A5%EF%BC%8C%E6%9C%89%E6%B2%A1%E6%9C%89%E5%BC%82%E5%B8%B8%E9%83%BD%E4%BC%9A%E6%89%A7%E8%A1%8C%0A*%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9A%3Caop%3Aafter%20method%3D%22after%22%20pointcut-ref%3D%22myPointcut%22%2F%3E%0A*%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%E4%BE%8B%E5%A6%82%E5%83%8F%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90%0A%0A**%E5%BC%82%E5%B8%B8%E6%8A%9B%E5%87%BA%E9%80%9A%E7%9F%A5%EF%BC%9A**%0A*%20%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA%EF%BC%9A%E5%9C%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%8E%E9%80%9A%E7%9F%A5%0A*%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9A%3Caop%3Aafter-throwing%20method%3D%22%20afterThrowing%20%22%20pointcut-%20%0Aref%3D%22myPointcut%22%2F%3E%0A*%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%E5%8C%85%E8%A3%85%E5%BC%82%E5%B8%B8%0A%0A**%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%EF%BC%9A%EF%BC%88%E4%BD%BF%E7%94%A8%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E5%8F%AF%E4%BB%A5%E6%9B%BF%E4%BB%A3%E5%85%B6%E4%BB%96%E5%9B%9B%E4%B8%AA%E9%80%9A%E7%9F%A5%EF%BC%89**%0A*%20%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA%EF%BC%9A%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B9%8B%E5%89%8D%E5%92%8C%E4%B9%8B%E5%90%8E%E9%83%BD%E4%BC%9A%E6%89%A7%E8%A1%8C%EF%BC%8C%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%8E%E4%B8%8D%E4%BC%9A%E6%89%A7%E8%A1%8C%0A*%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9A%3Caop%3Aaround%20method%3D%22around%22%20pointcut-ref%3D%22myPointcut%22%2F%3E%0A*%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%E4%BA%8B%E5%8A%A1%E3%80%81%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA%0A%0A!%5Bcc1c8d03855a2cac4b9a39857a6dba3b.png%5D(en-resource%3A%2F%2Fdatabase%2F1021%3A1)%40w%3D400%0A%0A%0A%23%23%23%23%20XML%E5%AE%9E%E7%8E%B0Spring%20AOP%20%E6%A1%88%E4%BE%8B%0A**%E8%A6%81%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84Math%E7%B1%BB**%0A%60%60%60java%0Apackage%20com.zhangguo.Spring052.aop01%3B%0A%0A%2F**%0A%20*%20%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E7%B1%BB%0A%20*%2F%0Apublic%20class%20Math%7B%0A%20%20%20%20%2F%2F%E5%8A%A0%0A%20%20%20%20public%20int%20add(int%20n1%2Cint%20n2)%7B%0A%20%20%20%20%20%20%20%20int%20result%3Dn1%2Bn2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22%2B%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%E5%87%8F%0A%20%20%20%20public%20int%20sub(int%20n1%2Cint%20n2)%7B%0A%20%20%20%20%20%20%20%20int%20result%3Dn1-n2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22-%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%E4%B9%98%0A%20%20%20%20public%20int%20mut(int%20n1%2Cint%20n2)%7B%0A%20%20%20%20%20%20%20%20int%20result%3Dn1<em>n2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22X%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%E9%99%A4%0A%20%20%20%20public%20int%20div(int%20n1%2Cint%20n2)%7B%0A%20%20%20%20%20%20%20%20int%20result%3Dn1%2Fn2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22%2F%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A%20**%E7%BC%96%E8%BE%91%E9%80%9A%E7%9F%A5%E7%B1%BBAdvice**%0A%60%60%60java%0Apackage%20com.zhangguo.Spring052.aop01%3B%0A%0Aimport%20org.aspectj.lang.JoinPoint%3B%0A%0A%2F**%0A%20</em>%20%E9%80%9A%E7%9F%A5%E7%B1%BB%EF%BC%8C%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%0A%20*%0A%20*%2F%0Apublic%20class%20Advices%20%7B%0A%20%20%20%20%0A%20%20%20%20public%20void%20before(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%20%20%20%20System.out.println(jp.getSignature().getName())%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20public%20void%20after(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A**%E9%85%8D%E7%BD%AEAOP%20XML%E6%96%87%E4%BB%B6**%0A*%20%E5%8A%A0%E7%B2%97%E9%83%A8%E5%88%86%E7%9A%84%E5%86%85%E5%AE%B9%E6%98%AF%E5%9C%A8%E5%8E%9FIOC%E5%86%85%E5%AE%B9%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E4%B8%BAAOP%E6%9C%8D%E5%8A%A1%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%BC%95%E5%85%A5%E5%A4%B1%E8%B4%A5%E5%88%99%E6%B2%A1%E6%9C%89%E6%99%BA%E8%83%BD%E6%8F%90%E7%A4%BA%E3%80%82xmlns%3A%E6%98%AFxml%20namespace%E7%9A%84%E7%AE%80%E5%86%99%E3%80%82xmlns%3Axsi%EF%BC%9A%E5%85%B6xsd%E6%96%87%E4%BB%B6%E6%98%AFxml%E9%9C%80%E8%A6%81%E9%81%B5%E5%AE%88%E7%9A%84%E8%A7%84%E8%8C%83%EF%BC%8C%E9%80%9A%E8%BF%87URL%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%EF%BC%8C%E6%98%AFw3%E7%9A%84%E7%BB%9F%E4%B8%80%E8%A7%84%E8%8C%83%EF%BC%8C%E5%90%8E%E9%9D%A2%E9%80%9A%E8%BF%87xsi%3AschemaLocation%E6%9D%A5%E5%AE%9A%E4%BD%8D%E6%89%80%E6%9C%89%E7%9A%84%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6%EF%BC%8C%E8%BF%99%E9%87%8C%E5%8F%AA%E8%83%BD%E6%88%90%E5%81%B6%E6%95%B0%E5%AF%B9%E5%87%BA%E7%8E%B0%E3%80%82%0A*%20%60%3Cbean%20id%3D%22advice%22%20class%3D%22com.zhangguo.Spring041.aop08.Advices%22%3E%3C%2Fbean%3E%60%E8%A1%A8%E7%A4%BA%E9%80%9A%E7%9F%A5bean%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91bean%0A*%20%60%20%3Caop%3Aconfig%20proxy-target-class%3D%22true%22%3E%60%E7%94%A8%E4%BA%8EAOP%E9%85%8D%E7%BD%AE%EF%BC%8Cproxy-target-class%E5%B1%9E%E6%80%A7%E8%A1%A8%E7%A4%BA%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%B1%BB%E6%98%AF%E5%90%A6%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%EF%BC%8CSpring%E4%BC%9A%E4%BE%9D%E6%8D%AE%E5%AE%9E%E7%8E%B0%E4%BA%86%E6%8E%A5%E5%8F%A3%E5%88%99%E4%BD%BF%E7%94%A8JDK%E5%86%85%E7%BD%AE%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%AA%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%88%99%E4%BD%BF%E7%94%A8cblib%EF%BC%9B%E5%9C%A8Bean%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%8C%E6%89%80%E6%9C%89%E7%9A%84Spring%20AOP%E9%85%8D%E7%BD%AE%E9%83%BD%E5%BF%85%E9%A1%BB%E5%AE%9A%E4%B9%89%E5%9C%A8%3Caop%3Aconfig%3E%E5%85%83%E7%B4%A0%E5%86%85%E9%83%A8%E3%80%82%0A%0A*%20%60%3Caop%3Aaspect%3E%60%E5%85%83%E7%B4%A0%E6%9D%A5%E4%B8%BA%E5%85%B7%E4%BD%93%E7%9A%84%E5%88%87%E9%9D%A2%E5%AE%9E%E7%8E%B0%E5%BC%95%E7%94%A8%E5%90%8E%E7%AB%AFBean%E5%AE%9E%E4%BE%8B%E3%80%82%E5%9B%A0%E6%AD%A4%EF%BC%8C%E5%88%87%E9%9D%A2Bean%E5%BF%85%E9%A1%BB%E6%9C%89%E4%B8%80%E4%B8%AA%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%8C%E4%BE%9B%3Caop%3Aaspect%3E%E5%85%83%E7%B4%A0%E5%BC%95%E7%94%A8%E3%80%82aop%3Aaspect%E8%A1%A8%E7%A4%BA%E5%88%87%E9%9D%A2%E9%85%8D%E7%BD%AE%EF%BC%8C%C2%A0ref%E8%A1%A8%E7%A4%BA%E9%80%9A%E7%9F%A5%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%9B%0A*%20%60aop%3Apointcut%60%E6%98%AF%E9%85%8D%E7%BD%AE%E5%88%87%E5%85%A5%E7%82%B9%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%E5%B0%86%E6%B3%A8%E5%85%A5%E7%9A%84%E7%B2%BE%E7%A1%AE%E4%BD%8D%E7%BD%AE%EF%BC%8C%E9%82%A3%E4%BA%9B%E5%8C%85%EF%BC%8C%E7%B1%BB%EF%BC%8C%E6%96%B9%E6%B3%95%E9%9C%80%E8%A6%81%E6%8B%A6%E6%88%AA%E6%B3%A8%E5%85%A5%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%0A%60%60%60xml%0A%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%3F%3E%0A%3Cbeans%20xmlns%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%22%0A%20%20%20%20xmlns%3Axsi%3D%22http%3A%2F%<a href="http://2Fwww.w3.org">2Fwww.w3.org</a>%2F2001%2FXMLSchema-instance%22%20%0A%20%20%20%20xmlns%3Ap%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fp%22%0A%20%20%20%20xmlns%3Aaop%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Faop%22%0A%20%20%20%20xsi%3AschemaLocation%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%2Fspring-beans.xsd%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Faop%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Faop%2Fspring-aop-4.3.xsd%22%3E%0A%20%20%20%20%20%0A%20%20%20%20%3C!–%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%20–%3E%0A%20%20%20%20%3Cbean%20id%3D%22math%22%20class%3D%22com.zhangguo.Spring041.aop08.Math%22%3E%3C%2Fbean%3E%0A%20%20%20%20%3C!–%20%E9%80%9A%E7%9F%A5%20–%3E%0A%20%20%20%20%3Cbean%20id%3D%22advice%22%20class%3D%22com.zhangguo.Spring041.aop08.Advices%22%3E%3C%2Fbean%3E%0A%20%20%20%20%3C!–%20AOP%E9%85%8D%E7%BD%AE%20–%3E%0A%20%20%20%20%3C!–%20proxy-target-class%E5%B1%9E%E6%80%A7%E8%A1%A8%E7%A4%BA%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%B1%BB%E6%98%AF%E5%90%A6%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%EF%BC%8CSpring%E4%BC%9A%E4%BE%9D%E6%8D%AE%E5%AE%9E%E7%8E%B0%E4%BA%86%E6%8E%A5%E5%8F%A3%E5%88%99%E4%BD%BF%E7%94%A8JDK%E5%86%85%E7%BD%AE%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%AA%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%88%99%E4%BD%BF%E7%94%A8cblib%20–%3E%0A%20%20%20%20%3Caop%3Aconfig%20proxy-target-class%3D%22true%22%3E%0A%20%20%20%20%20%20%20%20%3C!–%20%E5%88%87%E9%9D%A2%E9%85%8D%E7%BD%AE%20–%3E%0A%20%20%20%20%20%20%20%20%3C!–ref%E8%A1%A8%E7%A4%BA%E9%80%9A%E7%9F%A5%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%20–%3E%0A%20%20%20%20%20%20%20%20%3Caop%3Aaspect%20ref%3D%22advice%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3C!–%20%E9%85%8D%E7%BD%AE%E5%88%87%E5%85%A5%E7%82%B9(%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%E5%B0%86%E6%B3%A8%E5%85%A5%E7%9A%84%E7%B2%BE%E7%A1%AE%E4%BD%8D%E7%BD%AE)%20–%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Caop%3Apointcut%20expression%3D%22execution(<em>%20com.zhangguo.Spring041.aop08.Math.</em>(…))%22%20id%3D%22pointcut1%22%2F%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3C!–%E5%A3%B0%E6%98%8E%E9%80%9A%E7%9F%A5%EF%BC%8Cmethod%E6%8C%87%E5%AE%9A%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B%EF%BC%8Cpointcut%E6%8C%87%E5%AE%9A%E5%88%87%E7%82%B9%EF%BC%8C%E5%B0%B1%E6%98%AF%E8%AF%A5%E9%80%9A%E7%9F%A5%E5%BA%94%E8%AF%A5%E6%B3%A8%E5%85%A5%E9%82%A3%E4%BA%9B%E6%96%B9%E6%B3%95%E4%B8%AD%20–%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Caop%3Abefore%20method%3D%22before%22%20pointcut-ref%3D%22pointcut1%22%2F%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Caop%3Aafter%20method%3D%22after%22%20pointcut-ref%3D%22pointcut1%22%2F%3E%0A%20%20%20%20%20%20%20%20%3C%2Faop%3Aaspect%3E%0A%20%20%20%20%3C%2Faop%3Aconfig%3E%0A%3C%2Fbeans%3E%0A%60%60%60%0A*%20aop%3Abefore%E7%94%A8%E4%BA%8E%E5%A3%B0%E6%98%8E%E9%80%9A%E7%9F%A5%EF%BC%8Cmethod%E6%8C%87%E5%AE%9A%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B%EF%BC%8Cpointcut%E6%8C%87%E5%AE%9A%E5%88%87%E7%82%B9%EF%BC%8C%E5%B0%B1%E6%98%AF%E8%AF%A5%E9%80%9A%E7%9F%A5%E5%BA%94%E8%AF%A5%E6%B3%A8%E5%85%A5%E9%82%A3%E4%BA%9B%E6%96%B9%E6%B3%95%E4%B8%AD%E3%80%82%E5%9C%A8aop%20Schema%E4%B8%AD%EF%BC%8C%E6%AF%8F%E7%A7%8D%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B%E9%83%BD%E5%AF%B9%E5%BA%94%E4%B8%80%E4%B8%AA%E7%89%B9%E5%AE%9A%E5%9C%B0XML%E5%85%83%E7%B4%A0%E3%80%82%E9%80%9A%E7%9F%A5%E5%85%83%E7%B4%A0%E9%9C%80%E8%A6%81pointcut-ref%E5%B1%9E%E6%80%A7%E6%9D%A5%E5%BC%95%E7%94%A8%E5%88%87%E5%85%A5%E7%82%B9%EF%BC%8C%E6%88%96%E8%80%85%E7%94%A8pointcut%E5%B1%9E%E6%80%A7%E7%9B%B4%E6%8E%A5%E5%B5%8C%E5%85%A5%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%82method%E5%B1%9E%E6%80%A7%E6%8C%87%E5%AE%9A%E5%88%87%E9%9D%A2%E7%B1%BB%E4%B8%AD%E9%80%9A%E7%9F%A5%E6%96%B9%E6%B3%95%E7%9A%84%E5%90%8D%E7%A7%B0%E3%80%82%E6%9C%89%E5%A6%82%E4%B8%8B%E5%87%A0%E7%A7%8D%EF%BC%9A%0A%60%60%60xml%0A%3C!–%20%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%20–%3E%0A%3Caop%3Abefore%20method%3D%22before%22%20pointcut-ref%3D%22pointcut1%22%2F%3E%0A%3C!–%20%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5%20–%3E%0A%3Caop%3Aafter%20method%3D%22after%22%20pointcut-ref%3D%22pointcut1%22%2F%3E%0A%3C!–%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%20–%3E%0A%3Caop%3Aaround%20method%3D%22around%22%20pointcut%3D%22execution(<em>%20com.zhangguo.Spring041.aop08.Math.s</em>(…))%22%2F%3E%0A%3C!–%E5%BC%82%E5%B8%B8%E9%80%9A%E7%9F%A5%20–%3E%0A%3Caop%3Aafter-throwing%20method%3D%22afterThrowing%22%20pointcut%3D%22execution(<em>%20com.zhangguo.Spring041.aop08.Math.d</em>(…))%22%20%20throwing%3D%22exp%22%2F%3E%0A%3C!–%20%E8%BF%94%E5%9B%9E%E5%80%BC%E9%80%9A%E7%9F%A5%20–%3E%0A%3Caop%3Aafter-returning%20method%3D%22afterReturning%22%20pointcut%3D%22execution(<em>%20com.zhangguo.Spring041.aop08.Math.m</em>(…))%22%20returning%3D%22result%22%2F%3E%0A%60%60%60%0A**%E6%B5%8B%E8%AF%95%E8%BF%90%E8%A1%8C**%0A%60%60%60java%0Apackage%20com.zhangguo.Spring052.aop01%3B%0A%0Aimport%20org.springframework.context.ApplicationContext%3B%0Aimport%20org.springframework.context.support.ClassPathXmlApplicationContext%3B%0A%0Apublic%20class%20Test%20%7B%0A%0A%20%20%20%20public%20static%20void%20main(String%5B%5D%20args)%20%7B%0A%20%20%20%20%20%20%20%20ApplicationContext%20ctx%20%3D%20new%20ClassPathXmlApplicationContext(%22aop01.xml%22)%3B%0A%20%20%20%20%20%20%20%20Math%20math%20%3D%20ctx.getBean(%22math%22%2C%20Math.class)%3B%0A%20%20%20%20%20%20%20%20int%20n1%20%3D%20100%2C%20n2%20%3D%205%3B%0A%20%20%20%20%20%20%20%20math.add(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.sub(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.mut(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.div(n1%2C%20n2)%3B%0A%20%20%20%20%7D%0A%0A%7D%0A%60%60%60%0A**%E7%BB%93%E6%9E%9C**%0A!%5Be415ff2a8b4907a06caffe29ca2c164d.png%5D(en-resource%3A%2F%2Fdatabase%2F1013%3A1)%40w%3D200%0A%0A***%0A%20%20%20%20%0A%23%23%23%20AspectJ%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0AOP%0A%23%23%23%23%20%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%0A%23%23%23%23%23%20%E7%BC%96%E5%86%99%E7%9B%AE%E6%A0%87%E7%B1%BB%0A%E7%BC%96%E5%86%99%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%88%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%EF%BC%89%0A*%20UserService%E6%8E%A5%E5%8F%A3%0A*%20UserServiceImpl%E5%AE%9E%E7%8E%B0%E7%B1%BB%0A%0A%3E%20%E9%85%8D%E7%BD%AE%E7%9B%AE%E6%A0%87%E7%B1%BB%EF%BC%8C%E5%B0%86%E7%9B%AE%E6%A0%87%E7%B1%BB%E4%BA%A4%E7%BB%99spring%20IoC%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%0A%0A%0A%23%23%23%23%23%20%E5%BC%80%E5%90%AFAOP%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%90%86%0A*%20%E5%9C%A8spring%E7%9A%84xml%E6%96%87%E4%BB%B6%E4%B8%AD%E5%8A%A0%E5%85%A5%0A%60%60%60xml%0A%3Caop%3Aaspectj-autoproxy%2F%3E%0A%60%60%60%0A%23%23%23%23%23%20%E7%BC%96%E5%86%99Aspect%EF%BC%88%E5%88%87%E9%9D%A2%EF%BC%89%E7%B1%BB%0AAdvice%E9%80%9A%E7%9F%A5%2BPointCut%E5%88%87%E5%85%A5%E7%82%B9%3DAspect%E5%88%87%E9%9D%A2%0A%0A*%20%E5%9C%A8%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8EAspectj%E6%B3%A8%E8%A7%A3%E7%9A%84Spring%20aop%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%8A%8A%40Pointcut%E6%B3%A8%E8%A7%A3%E5%AE%9A%E4%B9%89Pointcut%EF%BC%8C%E6%8C%87%E5%AE%9A%E5%85%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8Pointcut%E8%A1%A8%E8%BE%BE%E6%97%B6%E7%9A%84%E6%97%B6%E5%80%99%E7%9B%B4%E6%8E%A5%E6%8C%87%E5%AE%9APointcut%0A%60%60%60java%0A%2F%2F%E5%88%87%E9%9D%A2%E7%B1%BB%EF%BC%8C%E8%A1%A8%E7%A4%BA%E9%80%9A%E7%9F%A5%E5%8A%A0%E5%88%87%E5%85%A5%E7%82%B9%0A%0A%2F%2F%E9%9C%80%E8%A6%81%E5%B0%86%E5%88%87%E9%9D%A2%E7%B1%BB%E5%B0%86%E7%BB%99spring%20IoC%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%0A%40Component%0A%2F%2F%40Aspect%3A%E6%A0%87%E8%AE%B0%E6%94%B9%E7%B1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%88%87%E9%9D%A2%E7%B1%BB%0A%40Aspect%0Apublic%20class%20MyAspect%20%7B%0A%2F%2F%20%E8%BF%99%E9%87%8C%E7%9A%84%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E5%90%8D%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%AE%9E%E9%99%85%E6%84%8F%E4%B9%89%EF%BC%8C%E7%9B%B8%E5%BD%93%E4%BA%8E%E4%B8%80%E4%B8%AAid%EF%BC%8Cpointcut%E7%A7%8D%E7%9A%84%E5%86%85%E5%AE%B9%E6%98%AF%E8%BF%99%E4%B8%AAid%E6%89%80%E5%8C%B9%E9%85%8D%E7%9A%84%E8%A6%81%E5%88%87%E5%85%A5%E7%9A%84%E9%82%A3%E4%BA%9B%E6%9F%B1%E5%AD%90%EF%BC%8C%E8%A6%81%E5%88%87%E5%85%A5%E6%89%A7%E8%A1%8C%E7%9A%84%E5%86%85%E5%AE%B9%E5%B0%B1%E6%98%AF%E4%B8%8B%E9%9D%A2%E7%9A%84%40before%E6%96%B9%E6%B3%95%EF%BC%8C%40before%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8F%82%E6%95%B0%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B8%AApointcut%E6%B3%A8%E8%A7%A3%E6%96%B9%E6%B3%95%E7%9A%84%E5%90%8D%E5%AD%97%0A%20%20%20%20%40Pointcut(%22execution(<em>%20add(…))%22)%0A%20%20%20%20private%20void%20beforeAdd()%20%7B%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%40Before%E8%A1%A8%E7%A4%BA%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%0A%20%20%20%20%2F%2Fvalue%EF%BC%9A%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%0A%20%20%20%20%40Before(%22execution(</em>%20*…<em>.<em>ServiceImpl.</em>(…))%22)%0A%20%20%20%20public%20void%20before()%20%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22-----------%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5-----------%22)%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%7D%0A%60%60%60%0A%23%23%23%23%23%20%E9%85%8D%E7%BD%AE%E5%88%87%E9%9D%A2%E7%B1%BB%0A%E5%8D%B3%E8%AE%A9%E5%85%B6%E7%BA%B3%E5%85%A5spring%E7%AE%A1%E7%90%86%0A%60%60%60xml%0A%3Ccontext%3Acomponent-scan%20base-package%3D%22com.kkb.spring%22%2F%3E%0A%60%60%60%0A%0A%23%23%23%23%20%E5%85%B6%E4%BB%96%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%0A%60%60%60java%0Aimport%20org.aspectj.lang.JoinPoint%3B%0Aimport%20org.aspectj.lang.ProceedingJoinPoint%3B%0Aimport%20org.aspectj.lang.annotation.After%3B%0Aimport%20org.aspectj.lang.annotation.AfterReturning%3B%0Aimport%20org.aspectj.lang.annotation.AfterThrowing%3B%0Aimport%20org.aspectj.lang.annotation.Around%3B%0Aimport%20org.aspectj.lang.annotation.Aspect%3B%0Aimport%20org.aspectj.lang.annotation.Before%3B%0Aimport%20org.aspectj.lang.annotation.Pointcut%3B%0Aimport%20org.springframework.stereotype.Component%3B%0A%0A%2F**%0A%20</em>%20%E9%80%9A%E7%9F%A5%E7%B1%BB%EF%BC%8C%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%0A%20*%2F%0A%40Component%0A%40Aspect%0Apublic%20class%20Advices%20%7B%0A%20%20%20%20%2F%2F%E5%88%87%E7%82%B9%0A%20%20%20%20%40Pointcut(%22execution(<em>%20com.zhangguo.Spring052.aop04.Math.a</em>(…))%22)%0A%20%20%20%20public%20void%20pointcut()%7B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%0A%20%20%20%20%40Before(%22pointcut()%22)%0A%20%20%20%20public%20void%20before(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(jp.getSignature().getName())%3B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5%0A%20%20%20%20%40After(%22pointcut()%22)%0A%20%20%20%20public%20void%20after(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%0A%20%20%20%20%40Around(%22execution(<em>%20com.zhangguo.Spring052.aop04.Math.s</em>(…))%22)%0A%20%20%20%20public%20Object%20around(ProceedingJoinPoint%20pjp)%20throws%20Throwable%7B%0A%20%20%20%20%20%20%20%20System.out.println(pjp.getSignature().getName())%3B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E7%8E%AF%E7%BB%95%E5%89%8D%E7%BD%AE----------%22)%3B%0A%20%20%20%20%20%20%20%20Object%20result%3Dpjp.proceed()%3B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E7%8E%AF%E7%BB%95%E5%90%8E%E7%BD%AE----------%22)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E9%80%9A%E7%9F%A5%0A%20%20%20%20%40AfterReturning(pointcut%3D%22execution(<em>%20com.zhangguo.Spring052.aop04.Math.m</em>(…))%22%2Creturning%3D%22result%22)%0A%20%20%20%20public%20void%20afterReturning(JoinPoint%20jp%2CObject%20result)%7B%0A%20%20%20%20%20%20%20%20System.out.println(jp.getSignature().getName())%3B%0A%20%20%20%20%20%20%20%20System.out.println(%22%E7%BB%93%E6%9E%9C%E6%98%AF%EF%BC%9A%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C----------%22)%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%E5%BC%82%E5%B8%B8%E5%90%8E%E9%80%9A%E7%9F%A5%0A%20%20%20%20%40AfterThrowing(pointcut%3D%22execution(<em>%20com.zhangguo.Spring052.aop04.Math.d</em>(…))%22%2Cthrowing%3D%22exp%22)%0A%20%20%20%20public%20void%20afterThrowing(JoinPoint%20jp%2CException%20exp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(jp.getSignature().getName())%3B%0A%20%20%20%20%20%20%20%20System.out.println(%22%E5%BC%82%E5%B8%B8%E6%B6%88%E6%81%AF%EF%BC%9A%22%2Bexp.getMessage())%3B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E5%BC%82%E5%B8%B8%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A%23%23%23%23%20%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%EF%BC%88%E7%89%B9%E6%AE%8A%EF%BC%89%0A**%40Around**%0A*%20%E4%BD%9C%E7%94%A8%EF%BC%9A%E6%8A%8A%E5%BD%93%E5%89%8D%E6%96%B9%E6%B3%95%E7%9C%8B%E4%BD%9C%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%0A*%20%E5%B1%9E%E6%80%A7%0A%20%20%20%20*%20value%EF%BC%9A%E7%94%A8%E4%BA%8E%E6%8C%87%E5%AE%9A%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E8%BF%98%E5%8F%AF%E4%BB%A5%E6%8C%87%E5%AE%9A%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%BC%95%E7%94%A8%0A%0A!%5B53eeff2bdceca466fc1fce018e5cbf86.png%5D(en-resource%3A%2F%2Fdatabase%2F1022%3A1)%40w%3D450%0A%0A%23%23%23%23%20%E5%AE%9A%E4%B9%89%E9%80%9A%E7%94%A8%E5%88%87%E5%85%A5%E7%82%B9%0A%E4%BD%BF%E7%94%A8%40PointCut%E6%B3%A8%E8%A7%A3%E5%9C%A8%E5%88%87%E9%9D%A2%E7%B1%BB%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E5%88%87%E5%85%A5%E7%82%B9%EF%BC%8C%E5%85%B6%E4%BB%96%E9%80%9A%E7%9F%A5%E5%8F%AF%E4%BB%A5%E5%BC%95%E7%94%A8%E8%AF%A5%E5%88%87%E5%85%A5%E7%82%B9%0A%0A!%5B8b08a02492b6c0a19f5401cfedcd4f47.png%5D(en-resource%3A%2F%2Fdatabase%2F1023%3A1)%40w%3D400%0A%0A%0A%23%23%23%23%20%E9%9B%B6%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%0A%60%60%60java%0A%2F%2F%E5%A3%B0%E6%98%8E%E6%94%B9%E7%B1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E9%85%8D%E7%BD%AE%E7%B1%BB%0A%40Configuration%0A%2F%2F%E5%B0%86com.kkb%E5%8C%85%E7%BA%B3%E5%85%A5%E6%B3%A8%E8%A7%A3%E6%89%AB%E6%8F%8F%0A%40ComponentScan(basePackages%3D%22com.kkb%22)%0A%2F%2F%E8%BF%99%E4%B8%AA%E5%B0%B1%E7%9B%B8%E5%BD%93%E4%BA%8Exml%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%3Caop%3Aaspectj-autoproxy%2F%3E%20%20AOP%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%90%86%0A%40EnableAspectJAutoProxy%0Apublic%20class%20SpringConfiguration%20%7B%0A%2F%2F%E5%9C%A8%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AAbean%EF%BC%8C%E7%9B%B8%E5%BD%93%E4%BA%8E%3Cbean%20id%3DgetUser%20class%3D%22com.zhangguo.Spring052.aop05.User%22%2F%3E%20%0A%20%20%20%20%40Bean%20%0A%20%20%20%20public%20User%20getUser()%7B%20return%20new%20User()%3B%20%7D%0A%0A%7D%0A%0A%60%60%60%0A%23%23%23%23%20%E5%8E%9F%E7%90%86%0A%0A%E5%85%B6%E5%AE%9EAOP%E7%9A%84%E5%8E%9F%E7%90%86%E9%9D%9E%E5%B8%B8%E7%AE%80%E5%8D%95%E3%80%82%E6%88%91%E4%BB%AC%E4%BB%A5LoggingAspect.doAccessCheck()%E4%B8%BA%E4%BE%8B%EF%BC%8C%E8%A6%81%E6%8A%8A%E5%AE%83%E6%B3%A8%E5%85%A5%E5%88%B0UserService%E7%9A%84%E6%AF%8F%E4%B8%AApublic%E6%96%B9%E6%B3%95%E4%B8%AD%EF%BC%8C%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%AD%90%E7%B1%BB%EF%BC%8C%E5%B9%B6%E6%8C%81%E6%9C%89%E5%8E%9F%E5%A7%8B%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%9A%0A%60%60%60java%0A%0A%40Aspect%40Componentpublic%20class%20LoggingAspect%20%7B%0A%20%20%20%20%2F%2F%20%E5%9C%A8%E6%89%A7%E8%A1%8CUserService%E7%9A%84%E6%AF%8F%E4%B8%AA%E6%96%B9%E6%B3%95%E5%89%8D%E6%89%A7%E8%A1%8C%3A%0A%20%20%20%20%40Before(%22execution(public%20*%20com.itranswarp.learnjava.service.UserService.<em>(…))%22)%0A%20%20%20%20public%20void%20doAccessCheck()%20%7B%0A%20%20%20%20%20%20%20%20System.err.println(%22%5BBefore%5D%20do%20access%20check…%22)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20%E5%9C%A8%E6%89%A7%E8%A1%8CMailService%E7%9A%84%E6%AF%8F%E4%B8%AA%E6%96%B9%E6%B3%95%E5%89%8D%E5%90%8E%E6%89%A7%E8%A1%8C%3A%0A%20%20%20%20%40Around(%22execution(public%20</em>%20com.itranswarp.learnjava.service.MailService.<em>(…))%22)%0A%20%20%20%20public%20Object%20doLogging(ProceedingJoinPoint%20pjp)%20throws%20Throwable%20%7B%0A%20%20%20%20%20%20%20%20System.err.println(%22%5BAround%5D%20start%20%22%20%2B%20pjp.getSignature())%3B%0A%20%20%20%20%20%20%20%20Object%20retVal%20%3D%20pjp.proceed()%3B%0A%20%20%20%20%20%20%20%20System.err.println(%22%5BAround%5D%20done%20%22%20%2B%20pjp.getSignature())%3B%0A%20%20%20%20%20%20%20%20return%20retVal%3B%0A%20%20%20%20%7D%0A%7D%0A%0A%2F%2F%E5%AD%90%E7%B1%BB%0Apublic%20UserServiceAopProxy%20extends%20UserService%20%7B%0A%20%20%20%20private%20UserService%20target%3B%0A%20%20%20%20private%20LoggingAspect%20aspect%3B%0A%0A%20%20%20%20public%20UserServiceAopProxy(UserService%20target%2C%20LoggingAspect%20aspect)%20%7B%0A%20%20%20%20%20%20%20%20this.target%20%3D%20target%3B%0A%20%20%20%20%20%20%20%20this.aspect%20%3D%20aspect%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20public%20User%20login(String%20email%2C%20String%20password)%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20%E5%85%88%E6%89%A7%E8%A1%8CAspect%E7%9A%84%E4%BB%A3%E7%A0%81%3A%0A%20%20%20%20%20%20%20%20aspect.doAccessCheck()%3B%0A%20%20%20%20%20%20%20%20%2F%2F%20%E5%86%8D%E6%89%A7%E8%A1%8CUserService%E7%9A%84%E9%80%BB%E8%BE%91%3A%0A%20%20%20%20%20%20%20%20return%20target.login(email%2C%20password)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20public%20User%20register(String%20email%2C%20String%20password%2C%20String%20name)%20%7B%0A%20%20%20%20%20%20%20%20aspect.doAccessCheck()%3B%0A%20%20%20%20%20%20%20%20return%20target.register(email%2C%20password%2C%20name)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20…%0A%7D%0A%60%60%60%0A%E8%BF%99%E4%BA%9B%E9%83%BD%E6%98%AFSpring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E4%B8%BA%E6%88%91%E4%BB%AC%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B3%A8%E5%85%A5%E4%BA%86Aspect%E7%9A%84%E5%AD%90%E7%B1%BB%EF%BC%8C%E5%AE%83%E5%8F%96%E4%BB%A3%E4%BA%86%E5%8E%9F%E5%A7%8B%E7%9A%84UserService%EF%BC%88%E5%8E%9F%E5%A7%8B%E7%9A%84UserService%E5%AE%9E%E4%BE%8B%E4%BD%9C%E4%B8%BA%E5%86%85%E9%83%A8%E5%8F%98%E9%87%8F%E9%9A%90%E8%97%8F%E5%9C%A8UserServiceAopProxy%E4%B8%AD%EF%BC%89%E3%80%82%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E6%89%93%E5%8D%B0%E4%BB%8ESpring%E5%AE%B9%E5%99%A8%E8%8E%B7%E5%8F%96%E7%9A%84UserService%E5%AE%9E%E4%BE%8B%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%AE%83%E7%B1%BB%E4%BC%BCUserService%24%24EnhancerBySpringCGLIB%24%241f44e01c%EF%BC%8C%E5%AE%9E%E9%99%85%E4%B8%8A%E6%98%AFSpring%E4%BD%BF%E7%94%A8CGLIB%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AD%90%E7%B1%BB%EF%BC%8C%E4%BD%86%E5%AF%B9%E4%BA%8E%E8%B0%83%E7%94%A8%E6%96%B9%E6%9D%A5%E8%AF%B4%EF%BC%8C%E6%84%9F%E8%A7%89%E4%B8%8D%E5%88%B0%E4%BB%BB%E4%BD%95%E5%8C%BA%E5%88%AB%E3%80%82%0A%0A%3ESpring%E5%AF%B9%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%8C%E5%AF%B9%E6%99%AE%E9%80%9A%E7%B1%BB%E4%BD%BF%E7%94%A8CGLIB%E5%88%9B%E5%BB%BA%E5%AD%90%E7%B1%BB%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AABean%E7%9A%84class%E6%98%AFfinal%EF%BC%8CSpring%E5%B0%86%E6%97%A0%E6%B3%95%E4%B8%BA%E5%85%B6%E5%88%9B%E5%BB%BA%E5%AD%90%E7%B1%BB%E3%80%82%0A%0A%E5%8F%AF%E8%A7%81%EF%BC%8C%E8%99%BD%E7%84%B6Spring%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0AOP%E7%9A%84%E9%80%BB%E8%BE%91%E6%AF%94%E8%BE%83%E5%A4%8D%E6%9D%82%EF%BC%88%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8AspectJ%E8%A7%A3%E6%9E%90%E6%B3%A8%E8%A7%A3%EF%BC%8C%E5%B9%B6%E9%80%9A%E8%BF%87CGLIB%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E7%B1%BB%EF%BC%89%EF%BC%8C%E4%BD%86%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8AOP%E9%9D%9E%E5%B8%B8%E7%AE%80%E5%8D%95%EF%BC%8C%E4%B8%80%E5%85%B1%E9%9C%80%E8%A6%81%E4%B8%89%E6%AD%A5%EF%BC%9A%0A</em>%20%E5%AE%9A%E4%B9%89%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95%EF%BC%8C%E5%B9%B6%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%8A%E9%80%9A%E8%BF%87AspectJ%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%91%8A%E8%AF%89Spring%E5%BA%94%E8%AF%A5%E5%9C%A8%E4%BD%95%E5%A4%84%E8%B0%83%E7%94%A8%E6%AD%A4%E6%96%B9%E6%B3%95%EF%BC%9B%0A*%20%E6%A0%87%E8%AE%B0%40Component%E5%92%8C%40Aspect%EF%BC%9B%0A*%20%E5%9C%A8%40Configuration%E7%B1%BB%E4%B8%8A%E6%A0%87%E6%B3%A8%40EnableAspectJAutoProxy%E3%80%82%0A%0A%23%23%23%23%20%E6%A1%88%E4%BE%8B%3A%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AEAOP%0A*%20%E5%9C%A8%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B%E4%B8%AD%E4%BF%AE%E6%94%B9%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%B1%BBMath%2C%E4%B8%BA%E4%BA%86%E5%AE%9E%E7%8E%B0IOC%E6%89%AB%E6%8F%8F%E5%9C%A8Math%E7%B1%BB%E4%B8%8A%E6%B3%A8%E8%A7%A3%E4%BA%86%40Service%E5%B9%B6%E5%91%BD%E5%90%8Dbean%E4%B8%BAmath%E3%80%82%E7%9B%B8%E5%BD%93%E4%BA%8E%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B%E4%B8%AD%E5%9C%A8xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%BA%86%E4%B8%80%E4%B8%AAbean%EF%BC%8C%3C!–%20%E8%A2%AB%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%20–%3E%3Cbean%20id%3D%22math%22%20class%3D%22com.zhangguo.Spring052.aop01.Math%22%3E%3C%2Fbean%3E%EF%BC%8CMath%E7%B1%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A%0A%60%60%60java%0Apackage%20com.zhangguo.Spring052.aop02%3B%0A%0Aimport%20org.springframework.stereotype.Service%3B%0A%0A%2F**%0A%20*%20%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E7%B1%BB%0A%20*%2F%0A%40Service(%22math%22)%0Apublic%20class%20Math%7B%0A%20%20%20%20%2F%2F%E5%8A%A0%0A%20%20%20%20public%20int%20add(int%20n1%2Cint%20n2)%7B%0A%20%20%20%20%20%20%20%20int%20result%3Dn1%2Bn2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22%2B%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%E5%87%8F%0A%20%20%20%20public%20int%20sub(int%20n1%2Cint%20n2)%7B%0A%20%20%20%20%20%20%20%20int%20result%3Dn1-n2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22-%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%E4%B9%98%0A%20%20%20%20public%20int%20mut(int%20n1%2Cint%20n2)%7B%0A%20%20%20%20%20%20%20%20int%20result%3Dn1<em>n2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22X%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%E9%99%A4%0A%20%20%20%20public%20int%20div(int%20n1%2Cint%20n2)%7B%0A%20%20%20%20%20%20%20%20int%20result%3Dn1%2Fn2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22%2F%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A</em>%20%E4%BF%AE%E6%94%B9%E9%80%9A%E7%9F%A5%E7%B1%BBAdvices%EF%BC%8C%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%9C%893%E4%B8%AA%E6%B3%A8%E8%A7%A3%EF%BC%8C%40Component%E8%A1%A8%E7%A4%BA%E8%AF%A5%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%BC%9A%E8%A2%ABSpring%20IOC%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%EF%BC%9B%40Aspect%E8%A1%A8%E7%A4%BA%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E5%88%87%E9%9D%A2%EF%BC%9B%40Before%E8%A1%A8%E7%A4%BAbefore%E4%B8%BA%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%EF%BC%8C%E9%80%9A%E8%BF%87%E5%8F%82%E6%95%B0execution%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E5%88%87%E7%82%B9%EF%BC%8CAdvices.java%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA%EF%BC%9A%0A%3E%20%E8%BF%99%E4%B8%AAJava%E7%B1%BB%E5%B0%B1%E7%9B%B8%E5%BD%93%E4%BA%8E%60%E4%BD%BF%E7%94%A8XML%E9%85%8D%E7%BD%AESpring%20MVC%E6%97%B6%E5%80%99%E7%9A%84%3Caop%3Aconfig%3E%60%20%E7%9A%84%E9%85%8D%E7%BD%AE%0A%60%60%60java%0Apackage%20com.zhangguo.Spring052.aop02%3B%0A%0Aimport%20org.aspectj.lang.JoinPoint%3B%0Aimport%20org.aspectj.lang.annotation.After%3B%0Aimport%20org.aspectj.lang.annotation.Aspect%3B%0Aimport%20org.aspectj.lang.annotation.Before%3B%0Aimport%20org.springframework.stereotype.Component%3B%0A%0A%2F**%0A%20*%20%E9%80%9A%E7%9F%A5%E7%B1%BB%EF%BC%8C%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%0A%20*%0A%20*%2F%0A%40Component%0A%40Aspect%0Apublic%20class%20Advices%20%7B%0A%20%20%20%20%40Before(%22execution(<em>%20com.zhangguo.Spring052.aop02.Math.</em>(…))%22)%0A%20%20%20%20public%20void%20before(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%20%20%20%20System.out.println(jp.getSignature().getName())%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%40After(%22execution(<em>%20com.zhangguo.Spring052.aop02.Math.</em>(…))%22)%0A%20%20%20%20public%20void%20after(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A*%20%E4%B8%8A%E9%9D%A2Java%E7%B1%BB%E7%AD%89%E5%90%8C%E4%BA%8E%E4%B8%8B%E9%9D%A2%E7%9A%84xml%0A%60%60%60xml%0A%3C!–%20%E9%80%9A%E7%9F%A5%20–%3E%0A%20%20%20%20%3Cbean%20id%3D%22advices%22%20class%3D%22com.zhangguo.Spring052.aop01.Advices%22%3E%3C%2Fbean%3E%0A%20%20%20%20%0A%20%20%20%20%3C!–%20aop%E9%85%8D%E7%BD%AE%20–%3E%0A%20%20%20%20%3Caop%3Aconfig%20proxy-target-class%3D%22true%22%3E%0A%20%20%20%20%20%20%20%20%3C!–%E5%88%87%E9%9D%A2%20–%3E%0A%20%20%20%20%20%20%20%20%3Caop%3Aaspect%20ref%3D%22advices%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3C!–%20%E5%88%87%E7%82%B9%20–%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Caop%3Apointcut%20expression%3D%22execution(<em>%20com.zhangguo.Spring052.aop01.Math.</em>(…))%22%20id%3D%22pointcut1%22%2F%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3C!–%E8%BF%9E%E6%8E%A5%E9%80%9A%E7%9F%A5%E6%96%B9%E6%B3%95%E4%B8%8E%E5%88%87%E7%82%B9%20–%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Caop%3Abefore%20method%3D%22before%22%20pointcut-ref%3D%22pointcut1%22%2F%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Caop%3Aafter%20method%3D%22after%22%20pointcut-ref%3D%22pointcut1%22%2F%3E%0A%20%20%20%20%20%20%20%20%3C%2Faop%3Aaspect%3E%0A%20%20%20%20%3C%2Faop%3Aconfig%3E%0A%60%60%60%0A*%20Spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%0A%20%20%20%20*%20%E6%96%B0%E5%A2%9E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6aop02.xml%EF%BC%8C%E5%9C%A8%E9%85%8D%E7%BD%AEIOC%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%E5%A2%9E%E5%8A%A0%E4%BA%86aop%3Aaspectj-autoproxy%E8%8A%82%E7%82%B9%EF%BC%8CSpring%E6%A1%86%E6%9E%B6%E4%BC%9A%E8%87%AA%E5%8A%A8%E4%B8%BA%E4%B8%8EAspectJ%E5%88%87%E9%9D%A2%E9%85%8D%E7%BD%AE%E7%9A%84Bean%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%EF%BC%8Cproxy-target-class%3D%22true%22%E5%B1%9E%E6%80%A7%E8%A1%A8%E7%A4%BA%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%80%E4%B8%AA%E7%B1%BB%EF%BC%8C%E8%80%8C%E9%9D%9E%E5%AE%9E%E7%8E%B0%E4%BA%86%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E4%B8%BA%E4%BA%86%E9%80%89%E6%8B%A9%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%0A%60%60%60xml%0A%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%3F%3E%0A%3Cbeans%20xmlns%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%22%0A%20%20%20%20xmlns%3Axsi%3D%22http%3A%2F%<a href="http://2Fwww.w3.org">2Fwww.w3.org</a>%2F2001%2FXMLSchema-instance%22%20%0A%20%20%20%20xmlns%3Ap%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fp%22%0A%20%20%20%20xmlns%3Aaop%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Faop%22%0A%20%20%20%20xmlns%3Acontext%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fcontext%22%0A%20%20%20%20xsi%3AschemaLocation%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%2Fspring-beans.xsd%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fcontext%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fcontext%2Fspring-context-4.3.xsd%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Faop%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Faop%2Fspring-aop-4.3.xsd%22%3E%0A%20%20%20%20%20%20%20%20%3Ccontext%3Acomponent-scan%20base-package%3D%22com.zhangguo.Spring052.aop02%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Caop%3Aaspectj-autoproxy%20proxy-target-class%3D%22true%22%3E%3C%2Faop%3Aaspectj-autoproxy%3E%0A%3C%2Fbeans%3E%0A%60%60%60%0A%23%23%23%23%20AspectJ%E5%88%87%E7%82%B9%E5%87%BD%E6%95%B0%0A%23%23%23%23%23%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%0A*%20%40AspectJ%E4%BD%BF%E7%94%A8AspectJ%E4%B8%93%E9%97%A8%E7%9A%84%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8F%8F%E8%BF%B0%E5%88%87%E9%9D%A2%EF%BC%8CSpring%E6%89%80%E6%94%AF%E6%8C%81%E7%9A%84AspectJ%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%AF%E5%88%86%E4%B8%BA%E5%9B%9B%E7%B1%BB%3A%0A%20%20%20%20*%20%E6%96%B9%E6%B3%95%E5%88%87%E7%82%B9%E5%87%BD%E6%95%B0%EF%BC%9A%E9%80%9A%E8%BF%87%E6%8F%8F%E8%BF%B0%E7%9B%AE%E6%A0%87%E7%B1%BB%E6%96%B9%E6%B3%95%E4%BF%A1%E6%81%AF%E5%AE%9A%E4%B9%89%E8%BF%9E%E6%8E%A5%E7%82%B9%E3%80%82%0A%20%20%20%20*%20%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%88%87%E7%82%B9%E5%87%BD%E6%95%B0%EF%BC%9A%E9%80%9A%E8%BF%87%E6%8F%8F%E8%BF%B0%E7%9B%AE%E6%A0%87%E7%B1%BB%E6%96%B9%E6%B3%95%E5%85%A5%E5%8F%82%E4%BF%A1%E6%81%AF%E5%AE%9A%E4%B9%89%E8%BF%9E%E6%8E%A5%E7%82%B9%E3%80%82%0A%20%20%20%20*%20%E7%9B%AE%E6%A0%87%E7%B1%BB%E5%88%87%E7%82%B9%E5%87%BD%E6%95%B0%EF%BC%9A%E9%80%9A%E8%BF%87%E6%8F%8F%E8%BF%B0%E7%9B%AE%E6%A0%87%E7%B1%BB%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%E5%AE%9A%E4%B9%89%E8%BF%9E%E6%8E%A5%E7%82%B9%E3%80%82%0A%20%20%20%20*%20%E4%BB%A3%E7%90%86%E7%B1%BB%E5%88%87%E7%82%B9%E5%87%BD%E6%95%B0%EF%BC%9A%E9%80%9A%E8%BF%87%E6%8F%8F%E8%BF%B0%E4%BB%A3%E7%90%86%E7%B1%BB%E4%BF%A1%E6%81%AF%E5%AE%9A%E4%B9%89%E8%BF%9E%E6%8E%A5%E7%82%B9%E3%80%82%0A*%20%E6%A0%87%E5%87%86%E7%9A%84Aspectj%20Aop%E7%9A%84pointcut%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E5%BE%88%E4%B8%B0%E5%AF%8C%EF%BC%8C%E4%BD%86%E6%98%AFspring%20AOP%E5%8F%AA%E6%94%AF%E6%8C%819%E7%A7%8D%EF%BC%8C%E5%8F%A6%E5%A4%96%E5%8A%A0Spring%20Aop%E8%87%AA%E5%B7%B1%E6%89%A9%E5%85%85%E7%9A%84%E4%B8%80%E7%A7%8D%EF%BC%8C%E4%B8%80%E5%85%B1%E6%98%AF10%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E5%88%86%E5%88%AB%E5%A6%82%E4%B8%8B%0A%20%20%20%20*%20execution%EF%BC%9A%E6%BB%A1%E8%B6%B3%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%AE%E6%A0%87%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%82%B9%0A%20%20%20%20*%20within%EF%BC%9A%E6%8C%87%E5%AE%9A%E6%9F%90%E4%BA%9B%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%A8%E9%83%A8%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%EF%BC%8C%E4%B9%9F%E5%8F%AF%E7%94%A8%E6%9D%A5%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%8C%85%E3%80%82%0A%20%20%20%20*%20this%EF%BC%9ASpring%20Aop%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%90%86%E7%9A%84%EF%BC%8C%E7%94%9F%E6%88%90%E7%9A%84bean%E4%B9%9F%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%EF%BC%8Cthis%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B8%AA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%BD%93%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%8C%87%E5%AE%9A%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%97%B6%EF%BC%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E5%88%87%E5%85%A5%E7%82%B9%E5%B0%B1%E6%98%AF%E5%AE%83%E4%BA%86%EF%BC%8CSpring%20Aop%E5%B0%86%E7%94%9F%E6%95%88%E3%80%82%0A%20%20%20%20*%20target%EF%BC%9A%E5%BD%93%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%8C%87%E5%AE%9A%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%97%B6%EF%BC%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E5%88%87%E5%85%A5%E7%82%B9%E5%B0%B1%E6%98%AF%E5%AE%83%E4%BA%86%EF%BC%8CSpring%20Aop%E5%B0%86%E7%94%9F%E6%95%88%E3%80%82%0A%20%20%20%20*%20args%EF%BC%9A%E5%BD%93%E6%89%A7%E8%A1%8C%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E6%97%B6%E7%94%9F%E6%95%88%E3%80%82%0A%20%20%20%20*%20%40target%EF%BC%9A%E5%BD%93%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E4%B8%8A%E6%8B%A5%E6%9C%89%E6%8C%87%E5%AE%9A%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%97%B6%E7%94%9F%E6%95%88%E3%80%82%0A%20%20%20%20*%20%40args%EF%BC%9A%E5%BD%93%E6%89%A7%E8%A1%8C%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%B8%8A%E6%8B%A5%E6%9C%89%E6%8C%87%E5%AE%9A%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%97%B6%E7%94%9F%E6%95%88%E3%80%82%0A%20%20%20%20*%20%40within%EF%BC%9A%E4%B8%8E%40target%E7%B1%BB%E4%BC%BC%EF%BC%8C%E7%9C%8B%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%92%8C%E7%BD%91%E4%B8%8A%E7%9A%84%E8%AF%B4%E6%B3%95%E9%83%BD%E6%98%AF%40within%E5%8F%AA%E9%9C%80%E8%A6%81%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E6%88%96%E8%80%85%E7%88%B6%E7%B1%BB%E4%B8%8A%E6%9C%89%E6%8C%87%E5%AE%9A%E7%9A%84%E6%B3%A8%E8%A7%A3%EF%BC%8C%E5%88%99%40within%E4%BC%9A%E7%94%9F%E6%95%88%EF%BC%8C%E8%80%8C%40target%E5%88%99%E6%98%AF%E5%BF%85%E9%A1%BB%E6%98%AF%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E4%B8%8A%E6%9C%89%E6%8C%87%E5%AE%9A%E7%9A%84%E6%B3%A8%E8%A7%A3%E3%80%82%E8%80%8C%E6%A0%B9%E6%8D%AE%E7%AC%94%E8%80%85%E7%9A%84%E6%B5%8B%E8%AF%95%E8%BF%99%E4%B8%A4%E8%80%85%E9%83%BD%E6%98%AF%E5%8F%AA%E8%A6%81%E7%9B%AE%E6%A0%87%E7%B1%BB%E6%88%96%E7%88%B6%E7%B1%BB%E4%B8%8A%E6%9C%89%E6%8C%87%E5%AE%9A%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%8D%B3%E5%8F%AF%E3%80%82%0A%20%20%20%20*%20%40annotation%EF%BC%9A%E5%BD%93%E6%89%A7%E8%A1%8C%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8A%E6%8B%A5%E6%9C%89%E6%8C%87%E5%AE%9A%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%97%B6%E7%94%9F%E6%95%88%E3%80%82%0A%20%20%20%20*%20bean%EF%BC%9A%E5%BD%93%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E6%8C%87%E5%AE%9A%E7%9A%84bean%E7%9A%84%E6%96%B9%E6%B3%95%E6%97%B6%E7%94%9F%E6%95%88%E3%80%82%0A%23%23%23%23%23%20%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%EF%BC%8C%E6%A1%88%E4%BE%8B%0A*%20%E6%96%B0%E5%A2%9E%E4%B8%80%E4%B8%AA%E7%B1%BBStrUtil%0A%60%60%60java%0Apackage%20com.zhangguo.Spring052.aop03%3B%0A%0Aimport%20org.springframework.stereotype.Component%3B%0A%0A%40Component(%22strUtil%22)%0Apublic%20class%20StrUtil%20%7B%0A%20%20%20%20public%20void%20show()%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22Hello%20StrUtil!%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%0A%60%60%60%0A*%20%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%0A%60%60%60java%0Apackage%20com.zhangguo.Spring052.aop03%3B%0A%0Aimport%20org.springframework.context.ApplicationContext%3B%0Aimport%20org.springframework.context.support.ClassPathXmlApplicationContext%3B%0A%0Apublic%20class%20Test%20%7B%0A%0A%20%20%20%20public%20static%20void%20main(String%5B%5D%20args)%20%7B%0A%20%20%20%20%20%20%20%20ApplicationContext%20ctx%20%3D%20new%20ClassPathXmlApplicationContext(%22aop03.xml%22)%3B%0A%20%20%20%20%20%20%20%20IMath%20math%20%3D%20ctx.getBean(%22math%22%2C%20Math.class)%3B%0A%20%20%20%20%20%20%20%20int%20n1%20%3D%20100%2C%20n2%20%3D%205%3B%0A%20%20%20%20%20%20%20%20math.add(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.sub(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.mut(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.div(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20StrUtil%20strUtil%3Dctx.getBean(%22strUtil%22%2CStrUtil.class)%3B%0A%20%20%20%20%20%20%20%20strUtil.show()%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A%0A*%20<strong>execution</strong>%0A%20%20%20%20*%20execution%E6%98%AF%E4%BD%BF%E7%94%A8%E7%9A%84%E6%9C%80%E5%A4%9A%E7%9A%84%E4%B8%80%E7%A7%8DPointcut%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E8%A1%A8%E7%A4%BA%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%0A%60%60%60%0Aexecution(modifiers-pattern%3F%20ret-type-pattern%20declaring-type-pattern%3F%20name-pattern(param-pattern)%20throws-pattern%3F)%0A%60%60%60%0A1.%20modifiers-pattern%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%9E%8B%EF%BC%8Cpublic%E7%AD%89%EF%BC%9B%0A2.%20ret-type-pattern%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%A6%82String%E8%A1%A8%E7%A4%BA%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E6%98%AFString%EF%BC%8C%E2%80%9C%5C*%E2%80%9D%E8%A1%A8%E7%A4%BA%E6%89%80%E6%9C%89%E7%9A%84%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%EF%BC%9B%0A3.%20declaring-type-pattern%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%E7%9A%84%E5%A3%B0%E6%98%8E%E7%B1%BB%EF%BC%8C%E5%A6%82%E2%80%9Ccom.elim…%5C*%E2%80%9D%E8%A1%A8%E7%A4%BAcom.elim%E5%8C%85%E5%8F%8A%E5%85%B6%E5%AD%90%E5%8C%85%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%89%80%E6%9C%89%E7%B1%BB%E5%9E%8B%EF%BC%9B%0A4.%20name-pattern%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%E7%9A%84%E5%90%8D%E7%A7%B0%EF%BC%8C%E5%A6%82%E2%80%9Cadd%5C*%E2%80%9D%E8%A1%A8%E7%A4%BA%E6%89%80%E6%9C%89%E4%BB%A5add%E5%BC%80%E5%A4%B4%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%8D%EF%BC%9B%0A5.%20param-pattern%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%8Cname-pattern(param-pattern)%E5%85%B6%E5%AE%9E%E6%98%AF%E4%B8%80%E8%B5%B7%E7%9A%84%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%96%B9%E6%B3%95%E9%9B%86%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%A6%82%E2%80%9Cadd()%E2%80%9D%E8%A1%A8%E7%A4%BA%E4%B8%8D%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84add%E6%96%B9%E6%B3%95%EF%BC%8C%E2%80%9Cadd(%5C*)%E2%80%9D%E8%A1%A8%E7%A4%BA%E5%B8%A6%E4%B8%80%E4%B8%AA%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%E7%9A%84add%E6%96%B9%E6%B3%95%EF%BC%8C%E2%80%9Cadd(%5C*%2CString)%E2%80%9D%E5%88%99%E8%A1%A8%E7%A4%BA%E5%B8%A6%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E4%B8%94%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%E6%98%AFString%E7%B1%BB%E5%9E%8B%E7%9A%84add%E6%96%B9%E6%B3%95%EF%BC%9B%0A6.%20throws-pattern%E8%A1%A8%E7%A4%BA%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%EF%BC%9B%E5%85%B6%E4%B8%AD%E4%BB%A5%E9%97%AE%E5%8F%B7%E7%BB%93%E6%9D%9F%E7%9A%84%E9%83%A8%E5%88%86%E9%83%BD%E6%98%AF%E5%8F%AF%E4%BB%A5%E7%9C%81%E7%95%A5%E7%9A%84%E3%80%82%0A%20%20%20%201.%20%E2%80%9Cexecution(<em>%20add())%E2%80%9D%E5%8C%B9%E9%85%8D%E6%89%80%E6%9C%89%E7%9A%84%E4%B8%8D%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84add()%E6%96%B9%E6%B3%95%E3%80%82%0A%20%20%20%202.%20%E2%80%9Cexecution(public%20</em>%20com…%5C*.add*(…))%E2%80%9D%E5%8C%B9%E9%85%8D%E6%89%80%E6%9C%89com%E5%8C%85%E5%8F%8A%E5%85%B6%E5%AD%90%E5%8C%85%E4%B8%8B%E6%89%80%E6%9C%89%E7%B1%BB%E7%9A%84%E4%BB%A5add%E5%BC%80%E5%A4%B4%E7%9A%84%E6%89%80%E6%9C%89public%E6%96%B9%E6%B3%95%E3%80%82%0A%20%20%20%203.%20%E2%80%9Cexecution(<em>%20%5C</em>(…)%20throws%20Exception)%E2%80%9D%E5%8C%B9%E9%85%8D%E6%89%80%E6%9C%89%E6%8A%9B%E5%87%BAException%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82%0A%60%60%60java%0A%0A%40Component%0A%40Aspect%0Apublic%20class%20Advices%20%7B%0A%20%20%20%20%40Before(%22execution(<em>%20com.zhangguo.Spring052.aop03.Math.</em>(…))%22)%0A%20%20%20%20public%20void%20before(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%20%20%20%20System.out.println(jp.getSignature().getName())%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2Fexecution%E5%88%87%E7%82%B9%E5%87%BD%E6%95%B0%0A%20%20%20%20%2F%2Fcom.zhangguo.Spring052.aop03%E5%8C%85%E4%B8%8B%E6%89%80%E6%9C%89%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E8%A2%AB%E5%88%87%E5%85%A5%0A%20%20%20%20%40After(%22execution(<em>%20com.zhangguo.Spring052.aop03.</em>.<em>(…))%22)%0A%20%20%20%20public%20void%20after(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A!%5B41399f848259aa40b4120ab23785623e.png%5D(en-resource%3A%2F%2Fdatabase%2F1007%3A2)%0A%0A</em>%20<strong>within</strong>%0A%20%20%20%20*%20%20%20within%E6%98%AF%E7%94%A8%E6%9D%A5%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E7%A7%8D%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E5%B0%86%E8%A2%AB%E6%8B%A6%E6%88%AA%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%201.%20%E2%80%9Cwithin(com.spring.aop.service.UserServiceImpl)%E2%80%9D%E5%8C%B9%E9%85%8DUserServiceImpl%E7%B1%BB%E5%AF%B9%E5%BA%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%EF%BC%8C%E8%80%8C%E4%B8%94%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%8F%AA%E8%83%BD%E6%98%AFUserServiceImpl%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%B8%8D%E8%83%BD%E6%98%AF%E5%85%B6%E5%AD%90%E7%B1%BB%E5%9E%8B%0A%20%20%20%20%20%20%20%202.%20%E2%80%9Cwithin(com.elim…<em>)%E2%80%9D%E5%8C%B9%E9%85%8Dcom.elim%E5%8C%85%E5%8F%8A%E5%85%B6%E5%AD%90%E5%8C%85%E4%B8%8B%E9%9D%A2%E6%89%80%E6%9C%89%E7%9A%84%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E3%80%82%0A%60%60%60java%0A%2F%2Fwithin%E5%88%87%E7%82%B9%E5%87%BD%E6%95%B0%0A%20%20%20%20%2F%2Fcom.zhangguo.Spring052.aop03%E5%8C%85%E4%B8%8B%E6%89%80%E6%9C%89%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E8%A2%AB%E5%88%87%E5%85%A5%0A%20%20%20%20%40After(%22within(com.zhangguo.Spring052.aop03.</em>)%22)%0A%20%20%20%20public%20void%20after(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%7D%0A%60%60%60%0A!%5B41399f848259aa40b4120ab23785623e.png%5D(en-resource%3A%2F%2Fdatabase%2F1007%3A2)%0A%0A*%20<strong>this</strong>%0A%20%20%20%20*%20Spring%20Aop%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%90%86%E7%9A%84%EF%BC%8Cthis%E5%B0%B1%E8%A1%A8%E7%A4%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E3%80%82this%E7%B1%BB%E5%9E%8B%E7%9A%84Pointcut%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95%E6%98%AFthis(type)%EF%BC%8C%E5%BD%93%E7%94%9F%E6%88%90%E7%9A%84%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%BD%AC%E6%8D%A2%E4%B8%BAtype%E6%8C%87%E5%AE%9A%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%97%B6%E5%88%99%E8%A1%A8%E7%A4%BA%E5%8C%B9%E9%85%8D%E3%80%82%E5%9F%BA%E4%BA%8EJDK%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BB%A3%E7%90%86%E5%92%8C%E5%9F%BA%E4%BA%8ECGLIB%E7%9A%84%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%0A%20%20%20%20%20%20%20%201.%20%E2%80%9Cthis(com.spring.aop.service.IUserService)%E2%80%9D%E5%8C%B9%E9%85%8D%E7%94%9F%E6%88%90%E7%9A%84%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E6%98%AFIUserService%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%0A%60%60%60java%0A%2F%2Fthis%E5%88%87%E7%82%B9%E5%87%BD%E6%95%B0%0A%20%20%20%20%2F%2F%E5%AE%9E%E7%8E%B0%E4%BA%86IMath%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BB%BB%E6%84%8F%E8%BF%9E%E6%8E%A5%E7%82%B9%0A%20%20%20%20%40After(%22this(com.zhangguo.Spring052.aop03.IMath)%22)%0A%20%20%20%20public%20void%20after(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%7D%0A%60%60%60%0A!%5B91c5dd274415195d349d174a80bebe5a.png%5D(en-resource%3A%2F%2Fdatabase%2F1011%3A1)%0A%0A%0A*%20<strong>target</strong>%0A%20%20%20%20*%20Spring%20aop%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%90%86%E7%9A%84%EF%BC%8Ctarget%E5%88%99%E8%A1%A8%E7%A4%BA%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E5%B8%83%E6%A0%87%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%BD%93%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%8C%87%E5%AE%9A%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%97%B6%E5%88%99%E8%A1%A8%E7%A4%BA%E5%8C%B9%E9%85%8D%0A%20%20%20%20%20%20%20%201.%20%E2%80%9Ctarget(com.spring.aop.service.IUserService)%E2%80%9D%E5%88%99%E5%8C%B9%E9%85%8D%E6%89%80%E6%9C%89%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E8%83%BD%E5%A4%9F%E8%BD%AC%E6%8D%A2%E4%B8%BAIUserService%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%0A%0A*%20<strong>args</strong>%0A%20%20%20%20*%20arge%E7%94%A8%E6%9D%A5%E5%8C%B9%E9%85%8D%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%0A%20%20%20%20%20%20%20%201.%20%E2%80%9Cargs()%E2%80%9D%E5%8C%B9%E9%85%8D%E4%BB%BB%E4%BD%95%E4%B8%8D%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82%0A%20%20%20%20%20%20%20%202.%20%E2%80%9Cargs(java.lang.String)%E2%80%9D%E5%8C%B9%E9%85%8D%E4%BB%BB%E4%BD%95%E5%8F%AA%E5%B8%A6%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E8%80%8C%E4%B8%94%E8%BF%99%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AFString%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82%0A%20%20%20%20%20%20%20%203.%20%E2%80%9Cargs(…)%E2%80%9D%E5%B8%A6%E4%BB%BB%E6%84%8F%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82%0A%20%20%20%20%20%20%20%204.%20%E2%80%9Cargs(java.lang.String%2C…)%E2%80%9D%E5%8C%B9%E9%85%8D%E5%B8%A6%E4%BB%BB%E6%84%8F%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E4%BD%86%E6%98%AF%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AFString%E7%9A%84%E6%96%B9%E6%B3%95%0A%20%20%20%20%20%20%20%205.%20%E2%80%9Cargs(…%2Cjava.lang.String)%E2%80%9D%E5%8C%B9%E9%85%8D%E5%B8%A6%E4%BB%BB%E6%84%8F%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AFString%E7%9A%84%E6%96%B9%E6%B3%95%0A%0A%60%60%60java%0A%2F%2Fargs%E5%88%87%E7%82%B9%E5%87%BD%E6%95%B0%0A%20%20%20%20%2F%2F%E8%A6%81%E6%B1%82%E6%96%B9%E6%B3%95%E6%9C%89%E4%B8%A4%E4%B8%AAint%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E8%80%83%E6%89%8D%E4%BC%9A%E8%A2%AB%E7%BB%87%E5%85%A5%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%0A%20%20%20%20%40After(%22args(int%2Cint)%22)%0A%20%20%20%20public%20void%20after(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%7D%0A%60%60%60%0A!%5Bd3cad0fd1024c7f80ea8d574ffc4e30a.png%5D(en-resource%3A%2F%2Fdatabase%2F1012%3A1)%0A%0A*%20**%40target**%0A%20%20%20%20*%20%40target%E5%8C%B9%E9%85%8D%E5%BD%93%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%AF%B9%E5%BA%94%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E7%88%B6%E7%B1%BB%E5%9E%8B%E4%B8%8A%E6%8B%A5%E6%9C%89%E6%8C%87%E5%AE%9A%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%97%B6%0A%20%20%20%20%20%20%20%201.%20%E2%80%9C%40target(com.spring.support.MyAnnotation)%E2%80%9D%E5%8C%B9%E9%85%8D%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%AF%B9%E5%BA%94%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%8A%E6%8B%A5%E6%9C%89MyAnnotation%E6%B3%A8%E8%A7%A3%E6%97%B6%0A%0A*%20**%40args**%0A%20%20%20%20*%20%40args%E5%8C%B9%E9%85%8D%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8A%E5%90%AB%E6%9C%89%E5%8F%82%E6%95%B0%EF%BC%8C%E4%B8%94%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%B8%8A%E6%8B%A5%E6%9C%89%E6%8C%87%E5%AE%9A%E7%9A%84%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%83%85%E5%86%B5%0A%20%20%20%20%20%20%20%201.%20%E2%80%9C%40args(com.spring.support.MyAnnotation)%E2%80%9D%E5%8C%B9%E9%85%8D%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%B8%8A%E6%8B%A5%E6%9C%89MyAnnotation%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E3%80%82%E5%A6%82%E6%88%91%E4%BB%AC%E6%9C%89%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95add(MyParam%20param)%E6%8E%A5%E6%94%B6%E4%B8%80%E4%B8%AAMyParam%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%8C%E8%80%8CMyParam%E8%BF%99%E4%B8%AA%E7%B1%BB%E6%98%AF%E6%8B%A5%E6%9C%89%E6%B3%A8%E8%A7%A3MyAnnotation%E7%9A%84%EF%BC%8C%E5%88%99%E5%AE%83%E5%8F%AF%E4%BB%A5%E8%A2%ABPointcut%E8%A1%A8%E8%BE%BE%E5%BC%8F%E2%80%9C%40args(com.elim.spring.support.MyAnnotation)%E2%80%9D%E5%8C%B9%E9%85%8D%E4%B8%8A%0A%0A*%20**%40within**%0A%20%20%20%20*%20%40within%E7%94%A8%E4%BA%8E%E5%8C%B9%E9%85%8D%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%AF%B9%E5%BA%94%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%88%96%E5%85%B6%E7%88%B6%E7%B1%BB%E5%9E%8B%E6%8B%A5%E6%9C%89%E6%8C%87%E5%AE%9A%E7%9A%84%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E4%BD%86%E5%8F%AA%E6%9C%89%E5%9C%A8%E8%B0%83%E7%94%A8%E6%8B%A5%E6%9C%89%E6%8C%87%E5%AE%9A%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%B1%BB%E4%B8%8A%E7%9A%84%E6%96%B9%E6%B3%95%E6%97%B6%E6%89%8D%E5%8C%B9%E9%85%8D%0A%20%20%20%20%20%20%20%201.%20%E2%80%9C%40within(com.spring.support.MyAnnotation)%E2%80%9D%E5%8C%B9%E9%85%8D%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E5%A3%B0%E6%98%8E%E7%9A%84%E7%B1%BB%E4%B8%8A%E6%8B%A5%E6%9C%89MyAnnotation%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%83%85%E5%86%B5%E3%80%82%E6%AF%94%E5%A6%82%E6%9C%89%E4%B8%80%E4%B8%AAClassA%E4%B8%8A%E4%BD%BF%E7%94%A8%E4%BA%86%E6%B3%A8%E8%A7%A3MyAnnotation%E6%A0%87%E6%B3%A8%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%AE%9A%E4%B9%89%E4%BA%86%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95a()%EF%BC%8C%E9%82%A3%E4%B9%88%E5%9C%A8%E8%B0%83%E7%94%A8ClassA.a()%E6%96%B9%E6%B3%95%E6%97%B6%E5%B0%86%E5%8C%B9%E9%85%8D%E8%AF%A5Pointcut%EF%BC%9B%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E4%B8%AAClassB%E4%B8%8A%E6%B2%A1%E6%9C%89MyAnnotation%E6%B3%A8%E8%A7%A3%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%83%E7%BB%A7%E6%89%BF%E8%87%AAClassA%EF%BC%8C%E5%90%8C%E6%97%B6%E5%AE%83%E4%B8%8A%E9%9D%A2%E5%AE%9A%E4%B9%89%E4%BA%86%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95b()%EF%BC%8C%E9%82%A3%E4%B9%88%E5%9C%A8%E8%B0%83%E7%94%A8ClassB().b()%E6%96%B9%E6%B3%95%E6%97%B6%E4%B8%8D%E4%BC%9A%E5%8C%B9%E9%85%8D%E8%AF%A5Pointcut%EF%BC%8C%E4%BD%86%E6%98%AF%E5%9C%A8%E8%B0%83%E7%94%A8ClassB().a()%E6%97%B6%E5%B0%86%E5%8C%B9%E9%85%8D%E8%AF%A5%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%8C%E5%9B%A0%E4%B8%BAa()%E6%98%AF%E5%AE%9A%E4%B9%89%E5%9C%A8%E7%88%B6%E7%B1%BB%E5%9E%8BClassA%E4%B8%8A%E7%9A%84%EF%BC%8C%E4%B8%94ClassA%E4%B8%8A%E4%BD%BF%E7%94%A8%E4%BA%86MyAnnotation%E6%B3%A8%E8%A7%A3%E3%80%82%E4%BD%86%E6%98%AF%E5%A6%82%E6%9E%9C%E5%AD%90%E7%B1%BBClassB%E8%A6%86%E5%86%99%E4%BA%86%E7%88%B6%E7%B1%BBClassA%E7%9A%84a()%E6%96%B9%E6%B3%95%EF%BC%8C%E5%88%99%E8%B0%83%E7%94%A8ClassB.a()%E6%96%B9%E6%B3%95%E6%97%B6%E4%B9%9F%E4%B8%8D%E5%8C%B9%E9%85%8D%E8%AF%A5Pointcut%0A%0A*%20**%40annotation**%0A%20%20%20%20*%20%40annotation%E7%94%A8%E4%BA%8E%E5%8C%B9%E9%85%8D%E6%96%B9%E6%B3%95%E4%B8%8A%E6%8B%A5%E6%9C%89%E6%8C%87%E5%AE%9A%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%83%85%E5%86%B5%0A%20%20%20%20%20%20%20%201.%20%E2%80%9C%40annotation(com.spring.support.MyAnnotation)%E2%80%9D%E5%8C%B9%E9%85%8D%E6%89%80%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8A%E6%8B%A5%E6%9C%89MyAnnotation%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B9%E6%B3%95%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%0A%0A*%20%60%E5%85%88%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%8A%E7%9A%84%E6%B3%A8%E8%A7%A3%60%0A%60%60%60java%0Apackage%20com.zhangguo.Spring052.aop03%3B%0A%0Aimport%20java.lang.annotation.Documented%3B%0Aimport%20java.lang.annotation.ElementType%3B%0Aimport%20java.lang.annotation.Retention%3B%0Aimport%20java.lang.annotation.RetentionPolicy%3B%0Aimport%20java.lang.annotation.Target%3B%0A%0A%40Target(%7BElementType.METHOD%7D)%0A%40Retention(RetentionPolicy.RUNTIME)%0A%40Documented%0Apublic%20%40interface%20MyAnno%20%7B%0A%7D%0A%60%60%60%0A%60%60%60java%0A%2F%2F%40annotation%E5%88%87%E7%82%B9%E5%87%BD%E6%95%B0%0A%20%20%20%20%2F%2F%E8%A6%81%E6%B1%82%E6%96%B9%E6%B3%95%E5%BF%85%E9%A1%BB%E8%A2%AB%E6%B3%A8%E8%A7%A3com.zhangguo.Spring052.aop03.MyAnno%E6%89%8D%E4%BC%9A%E8%A2%AB%E7%BB%87%E5%85%A5%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%0A%20%20%20%20%40After(%22%40annotation(com.zhangguo.Spring052.aop03.MyAnno)%22)%0A%20%20%20%20public%20void%20after(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%7D%0A%60%60%60%0A%60%60%60java%0Apackage%20com.zhangguo.Spring052.aop03%3B%0A%0Aimport%20org.springframework.stereotype.Component%3B%0A%0A%40Component(%22strUtil%22)%0Apublic%20class%20StrUtil%20%7B%0A%20%20%20%20%40MyAnno%0A%20%20%20%20public%20void%20show()%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22Hello%20StrUtil!%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A!%5Beb7609a8f95aa8f96cd01f8fddd9646c.png%5D(en-resource%3A%2F%2Fdatabase%2F1014%3A1)%0A%0A*%20<strong>bean</strong>%0A%20%20%20%20*%20bean%E7%94%A8%E4%BA%8E%E5%8C%B9%E9%85%8D%E5%BD%93%E8%B0%83%E7%94%A8%E7%9A%84%E6%98%AF%E6%8C%87%E5%AE%9A%E7%9A%84Spring%E7%9A%84%E6%9F%90%E4%B8%AAbean%E7%9A%84%E6%96%B9%E6%B3%95%E6%97%B6%0A%20%20%20%20%20%20%20%201.%20%E2%80%9Cbean(abc)%E2%80%9D%E5%8C%B9%E9%85%8DSpring%20Bean%E5%AE%B9%E5%99%A8%E4%B8%ADid%E6%88%96name%E4%B8%BAabc%E7%9A%84bean%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%0A%20%20%20%20%20%20%20%202.%20%E2%80%9Cbean(user*)%E2%80%9D%E5%8C%B9%E9%85%8D%E6%89%80%E6%9C%89id%E6%88%96name%E4%B8%BA%E4%BB%A5user%E5%BC%80%E5%A4%B4%E7%9A%84bean%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%0A%0A%23%23%23%23%23%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%84%E5%90%88%0A*%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%84%E5%90%88%E5%B0%B1%E6%98%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%EF%BC%8C%E4%B8%8E%EF%BC%8C%E6%88%96%EF%BC%8C%E9%9D%9E%E3%80%82%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E4%BB%96%E4%BB%AC%E6%8A%8A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%84%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7%0A%20%20%20%201.%20bean(userService)%20%26%26%20args()%E2%80%9D%E5%8C%B9%E9%85%8Did%E6%88%96name%E4%B8%BAuserService%E7%9A%84bean%E7%9A%84%E6%89%80%E6%9C%89%E6%97%A0%E5%8F%82%E6%96%B9%E6%B3%95%E3%80%82%0A%20%20%20%202.%20%E2%80%9Cbean(userService)%20%7C%7C%20%40annotation(MyAnnotation)%E2%80%9D%E5%8C%B9%E9%85%8Did%E6%88%96name%E4%B8%BAuserService%E7%9A%84bean%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%8C%E6%88%96%E8%80%85%E6%98%AF%E6%96%B9%E6%B3%95%E4%B8%8A%E4%BD%BF%E7%94%A8%E4%BA%86MyAnnotation%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E3%80%82%0A%20%20%20%203.%20%E2%80%9Cbean(userService)%20%26%26%20!args()%E2%80%9D%E5%8C%B9%E9%85%8Did%E6%88%96name%E4%B8%BAuserService%E7%9A%84bean%E7%9A%84%E6%89%80%E6%9C%89%E6%9C%89%E5%8F%82%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E3%80%82%0A%0A%0A%23%23%23%23%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E8%A3%85%E9%85%8DAOP%0A%0A%E4%BD%BF%E7%94%A8AspectJ%E7%9A%84%E6%B3%A8%E8%A7%A3%EF%BC%8C%E5%B9%B6%E9%85%8D%E5%90%88%E4%B8%80%E4%B8%AA%E5%A4%8D%E6%9D%82%E7%9A%84%60execution(<em>%20xxx.Xyz.</em>(…))%60%20%20%E8%AF%AD%E6%B3%95%E6%9D%A5%E5%AE%9A%E4%B9%89%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E8%A3%85%E9%85%8DAOP%E3%80%82%0A%0A%E5%9C%A8%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%EF%BC%8C%E8%BF%99%E7%A7%8D%E5%86%99%E6%B3%95%E5%85%B6%E5%AE%9E%E5%BE%88%E5%B0%91%E4%BD%BF%E7%94%A8%E3%80%82%E5%81%87%E8%AE%BE%E4%BD%A0%E5%86%99%E4%BA%86%E4%B8%80%E4%B8%AASecurityAspect%EF%BC%9A%0A%60%60%60java%0A%40Aspect%0A%40Component%0Apublic%20class%20SecurityAspect%20%7B%0A%20%20%20%20%40Before(%22execution(public%20*%20com.itranswarp.learnjava.service.<em>.</em>(…))%22)%0A%20%20%20%20public%20void%20check()%20%7B%0A%20%20%20%20%20%20%20%20if%20(SecurityContext.getCurrentUser()%20%3D%3D%20null)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20throw%20new%20RuntimeException(%22check%20failed%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A%E5%9F%BA%E6%9C%AC%E8%83%BD%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%B7%AE%E5%88%AB%E5%85%A8%E8%A6%86%E7%9B%96%EF%BC%8C%E5%8D%B3%E6%9F%90%E4%B8%AA%E5%8C%85%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%89%80%E6%9C%89Bean%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E9%83%BD%E4%BC%9A%E8%A2%AB%E8%BF%99%E4%B8%AAcheck()%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA%E3%80%82%0A%0A%E8%BF%98%E6%9C%89%E7%9A%84%E7%AB%A5%E9%9E%8B%E5%96%9C%E6%AC%A2%E7%94%A8%E6%96%B9%E6%B3%95%E5%90%8D%E5%89%8D%E7%BC%80%E8%BF%9B%E8%A1%8C%E6%8B%A6%E6%88%AA%EF%BC%9A%0A%60%60%60java%0A%40Around(%22execution(public%20*%20update*(…))%22)%0Apublic%20Object%20doLogging(ProceedingJoinPoint%20pjp)%20throws%20Throwable%20%7B%0A%20%20%20%20%2F%2F%20%E5%AF%B9update%E5%BC%80%E5%A4%B4%E7%9A%84%E6%96%B9%E6%B3%95%E5%88%87%E6%8D%A2%E6%95%B0%E6%8D%AE%E6%BA%90%3A%0A%20%20%20%20String%20old%20%3D%20setCurrentDataSource(%22master%22)%3B%0A%20%20%20%20Object%20retVal%20%3D%20pjp.proceed()%3B%0A%20%20%20%20restoreCurrentDataSource(old)%3B%0A%20%20%20%20return%20retVal%3B%0A%7D%0A%60%60%60%0A%E8%BF%99%E7%A7%8D%E9%9D%9E%E7%B2%BE%E5%87%86%E6%89%93%E5%87%BB%E8%AF%AF%E4%BC%A4%E9%9D%A2%E6%9B%B4%E5%A4%A7%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%BB%8E%E6%96%B9%E6%B3%95%E5%89%8D%E7%BC%80%E5%8C%BA%E5%88%86%E6%98%AF%E5%90%A6%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E6%98%AF%E9%9D%9E%E5%B8%B8%E4%B8%8D%E5%8F%AF%E5%8F%96%E7%9A%84%E3%80%82%0A%0A%E6%88%91%E4%BB%AC%E5%9C%A8%E4%BD%BF%E7%94%A8AOP%E6%97%B6%EF%BC%8C%E8%A6%81%E6%B3%A8%E6%84%8F%E5%88%B0%E8%99%BD%E7%84%B6Spring%E5%AE%B9%E5%99%A8%E5%8F%AF%E4%BB%A5%E6%8A%8A%E6%8C%87%E5%AE%9A%E7%9A%84%E6%96%B9%E6%B3%95%E9%80%9A%E8%BF%87AOP%E8%A7%84%E5%88%99%E8%A3%85%E9%85%8D%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9A%84Bean%E7%9A%84%E6%8C%87%E5%AE%9A%E6%96%B9%E6%B3%95%E5%89%8D%E5%90%8E%EF%BC%8C%E4%BD%86%E6%98%AF%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%97%B6%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%B8%8D%E6%81%B0%E5%BD%93%E7%9A%84%E8%8C%83%E5%9B%B4%EF%BC%8C%E5%AE%B9%E6%98%93%E5%AF%BC%E8%87%B4%E6%84%8F%E6%83%B3%E4%B8%8D%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%8C%E5%8D%B3%E5%BE%88%E5%A4%9A%E4%B8%8D%E9%9C%80%E8%A6%81AOP%E4%BB%A3%E7%90%86%E7%9A%84Bean%E4%B9%9F%E8%A2%AB%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%90%86%E4%BA%86%EF%BC%8C%E5%B9%B6%E4%B8%94%EF%BC%8C%E5%90%8E%E7%BB%AD%E6%96%B0%E5%A2%9E%E7%9A%84Bean%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%B8%85%E6%A5%9A%E7%8E%B0%E6%9C%89%E7%9A%84AOP%E8%A3%85%E9%85%8D%E8%A7%84%E5%88%99%EF%BC%8C%E5%AE%B9%E6%98%93%E8%A2%AB%E5%BC%BA%E8%BF%AB%E8%A3%85%E9%85%8D%E3%80%82%0A%0A%E4%BD%BF%E7%94%A8AOP%E6%97%B6%EF%BC%8C%E8%A2%AB%E8%A3%85%E9%85%8D%E7%9A%84Bean%E6%9C%80%E5%A5%BD%E8%87%AA%E5%B7%B1%E8%83%BD%E6%B8%85%E6%B8%85%E6%A5%9A%E6%A5%9A%E5%9C%B0%E7%9F%A5%E9%81%93%E8%87%AA%E5%B7%B1%E8%A2%AB%E5%AE%89%E6%8E%92%E4%BA%86%E3%80%82%E4%BE%8B%E5%A6%82%EF%BC%8CSpring%E6%8F%90%E4%BE%9B%E7%9A%84%40Transactional%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%B8%B8%E5%A5%BD%E7%9A%84%E4%BE%8B%E5%AD%90%E3%80%82%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84Bean%E5%B8%8C%E6%9C%9B%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E4%B8%AD%E8%A2%AB%E8%B0%83%E7%94%A8%EF%BC%8C%E5%B0%B1%E6%A0%87%E6%B3%A8%E4%B8%8A%40Transactional%E3%80%82%0A%0A%E9%80%9A%E8%BF%87%40Transactional%EF%BC%8C%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%90%AF%E7%94%A8%E4%BA%86%E4%BA%8B%E5%8A%A1%E5%B0%B1%E4%B8%80%E6%B8%85%E4%BA%8C%E6%A5%9A%E4%BA%86%E3%80%82%E5%9B%A0%E6%AD%A4%EF%BC%8C%E8%A3%85%E9%85%8DAOP%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%98%AF%E6%9C%80%E5%A5%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E3%80%82%0A%0A%E6%88%91%E4%BB%AC%E4%BB%A5%E4%B8%80%E4%B8%AA%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90%E6%BC%94%E7%A4%BA%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0AOP%E8%A3%85%E9%85%8D%E3%80%82%E4%B8%BA%E4%BA%86%E7%9B%91%E6%8E%A7%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD%EF%BC%8C%E6%88%91%E4%BB%AC%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E7%9A%84%E6%B3%A8%E8%A7%A3%EF%BC%9A%0A%60%60%60java%0A%40Target(METHOD)%0A%40Retention(RUNTIME)%0Apublic%20%40interface%20MetricTime%20%7B%0A%20%20%20%20String%20value()%3B%0A%7D%0A%60%60%60%0A%0A%E5%9C%A8%E9%9C%80%E8%A6%81%E8%A2%AB%E7%9B%91%E6%8E%A7%E7%9A%84%E5%85%B3%E9%94%AE%E6%96%B9%E6%B3%95%E4%B8%8A%E6%A0%87%E6%B3%A8%E8%AF%A5%E6%B3%A8%E8%A7%A3%EF%BC%9A%0A%60%60%60java%0A%40Component%0Apublic%20class%20UserService%20%7B%0A%20%20%20%20%2F%2F%20%E7%9B%91%E6%8E%A7register()%E6%96%B9%E6%B3%95%E6%80%A7%E8%83%BD%3A%0A%20%20%20%20%40MetricTime(%22register%22)%0A%20%20%20%20public%20User%20register(String%20email%2C%20String%20password%2C%20String%20name)%20%7B%0A%20%20%20%20%20%20%20%20…%0A%20%20%20%20%7D%0A%20%20%20%20…%0A%7D%0A%60%60%60%0A%E7%84%B6%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E5%AE%9A%E4%B9%89MetricAspect%EF%BC%9A%0A%60%60%60java%0A%40Aspect%0A%40Component%0Apublic%20class%20MetricAspect%20%7B%0A%20%20%20%20%40Around(%22%40annotation(metricTime)%22)%0A%20%20%20%20public%20Object%20metric(ProceedingJoinPoint%20joinPoint%2C%20MetricTime%20metricTime)%20throws%20Throwable%20%7B%0A%20%20%20%20%20%20%20%20String%20name%20%3D%20metricTime.value()%3B%0A%20%20%20%20%20%20%20%20long%20start%20%3D%20System.currentTimeMillis()%3B%0A%20%20%20%20%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20joinPoint.proceed()%3B%0A%20%20%20%20%20%20%20%20%7D%20finally%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20long%20t%20%3D%20System.currentTimeMillis()%20-%20start%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E5%86%99%E5%85%A5%E6%97%A5%E5%BF%97%E6%88%96%E5%8F%91%E9%80%81%E8%87%B3JMX%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20System.err.println(%22%5BMetrics%5D%20%22%20%2B%20name%20%2B%20%22%3A%20%22%20%2B%20t%20%2B%20%22ms%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A%E6%B3%A8%E6%84%8Fmetric()%E6%96%B9%E6%B3%95%E6%A0%87%E6%B3%A8%E4%BA%86%40Around(%22%40annotation(metricTime)%22)%EF%BC%8C%E5%AE%83%E7%9A%84%E6%84%8F%E6%80%9D%E6%98%AF%EF%BC%8C%E7%AC%A6%E5%90%88%E6%9D%A1%E4%BB%B6%E7%9A%84%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E6%98%AF%E5%B8%A6%E6%9C%89%40MetricTime%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E5%9B%A0%E4%B8%BAmetric()%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%98%AFMetricTime%EF%BC%88%E6%B3%A8%E6%84%8F%E5%8F%82%E6%95%B0%E5%90%8D%E6%98%AFmetricTime%E4%B8%8D%E6%98%AFMetricTime%EF%BC%89%EF%BC%8C%E6%88%91%E4%BB%AC%E9%80%9A%E8%BF%87%E5%AE%83%E8%8E%B7%E5%8F%96%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E7%9A%84%E5%90%8D%E7%A7%B0%E3%80%82%0A%0A%E6%9C%89%E4%BA%86%40MetricTime%E6%B3%A8%E8%A7%A3%EF%BC%8C%E5%86%8D%E9%85%8D%E5%90%88MetricAspect%EF%BC%8C%E4%BB%BB%E4%BD%95Bean%EF%BC%8C%E5%8F%AA%E8%A6%81%E6%96%B9%E6%B3%95%E6%A0%87%E6%B3%A8%E4%BA%86%40MetricTime%E6%B3%A8%E8%A7%A3%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%82%0A</p>]]>
    </content>
    <id>http://example.com/2023/06/29/Spring_AOP/</id>
    <link href="http://example.com/2023/06/29/Spring_AOP/"/>
    <published>2023-06-29T04:00:00.000Z</published>
    <summary>AOP采取横向抽取机制，取代了传统纵向继承体系的重复性代码（性能监视，事务管理，安全检查，缓存）在程序运行期间，不修改源码对已有方法进行增强，将业务逻辑和系统处理的代码（关闭连接，事务管理，操作日志记录）解耦</summary>
    <title>Spring AOP</title>
    <updated>2026-02-26T09:23:53.372Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    <content>
      <![CDATA[<h1 id="spring-jdbc事务"><a class="markdownIt-Anchor" href="#spring-jdbc事务"></a> $Spring JDBC/事务</h1><h1 id="springjdbc"><a class="markdownIt-Anchor" href="#springjdbc"></a> SpringJDBC</h1><ul><li><a href="">SpringJDBC</a><ul><li><a href="">Spring对JDBC的整合支持</a><ul><li><a href="">spring对DAO技术提供了那些支持</a><ul><li><a href="">Spring对DAO异常的支持</a></li><li><a href="">Spring对DAO编写的支持</a></li></ul></li><li><a href="">如何编写DAO组件</a></li></ul></li><li><a href="">Spring jdbcTemplate的应用(XML)</a><ul><li><a href="">maven依赖</a></li><li><a href="">入门直接使用</a></li><li><a href="">spring管理使用方式</a><ul><li><a href="">spring配置文件</a></li><li><a href="">测试使用</a></li><li><a href="">增删改查</a></li><li><a href="">dbcp/c3p0连接池使用</a></li></ul></li></ul></li><li><a href="">Spring jdbcTemplate的应用(注解)</a><ul><li><a href="">JdbcTemplate用法</a></li></ul></li><li><a href="">Sprng JdbcDaoSupport应用</a><ul><li><a href="">使用</a></li></ul></li></ul></li><li><a href="">Spring 事务</a><ul><li><a href="">事务概念</a><ul><li><a href="">事务介绍</a></li><li><a href="">事务的并发问题（隔离性导致）</a></li><li><a href="">事务隔离级别</a><ul><li><a href="">四种隔离级别</a></li><li><a href="">事务的传播行为</a></li><li><a href="">注意事项</a></li></ul></li></ul></li><li><a href="">Spring框架的事务管理相关的类和API</a><ul><li><a href="">PlatformTransactionManager接口</a></li><li><a href="">TransactionDefinition接口</a></li><li><a href="">TransactionStatus接口</a></li></ul></li><li><a href="">Spring框架事务管理的分类</a><ul><li><a href="">编程式事务管理（了解）</a><ul><li><a href="">配置一个事务管理器</a></li><li><a href="">配置事务管理模板</a></li><li><a href="">注入事务管理模板</a></li><li><a href="">在业务层使用模板管理事务</a></li></ul></li><li><a href="">声明式事务管理（重点）</a><ul><li><a href="">基于AspectJ的XML方式</a><ul><li><a href="">maven依赖</a></li><li><a href="">数据库表</a></li><li><a href="">持久层</a></li><li><a href="">业务层</a></li><li><a href="">spring 配置</a></li><li><a href="">测试</a></li><li><a href="">源码分析</a></li></ul></li><li><a href="">基于AspectJ的注解方式</a></li></ul></li><li><a href="">使用声明式事务</a><ul><li><a href="">回滚事务</a></li><li><a href="">事务边界</a></li><li><a href="">事务传播</a></li></ul></li></ul></li></ul></li></ul><h2 id="spring对jdbc的整合支持"><a class="markdownIt-Anchor" href="#spring对jdbc的整合支持"></a> Spring对JDBC的整合支持</h2><p>Spring JDBC就是指spring自身对jdbc的代码进行了一些封装，使得使用更加的简单，方便，快捷。</p><h3 id="spring对dao技术提供了那些支持"><a class="markdownIt-Anchor" href="#spring对dao技术提供了那些支持"></a> spring对DAO技术提供了那些支持</h3><ul><li>Spring对JDBC等数据库访问技术编写DAO提供了以下几个重要支持<ul><li>Spring对DAO异常提供了统一处理</li><li>Spring对DAO编写提供了支持的抽象类</li><li>提高编程效率，减少JDBC编码量</li></ul></li></ul><h4 id="spring对dao异常的支持"><a class="markdownIt-Anchor" href="#spring对dao异常的支持"></a> Spring对DAO异常的支持</h4><ul><li>Spring把特定某种技术的异常，如SQLException,统一转化为自己的异常类型，这些异常以DataAccessException为父类，它们封装了原始异常对象，不会丢失原始错误信息</li><li>DataAccessException继承于RuntimeException，是非检查异常，不会因为没有处理异常而出现编译错误，异常必须处理，可以用拦截器或者在界面层统一处理</li></ul><h4 id="spring对dao编写的支持"><a class="markdownIt-Anchor" href="#spring对dao编写的支持"></a> Spring对DAO编写的支持</h4><ul><li>Spring为了便于以一种一致的方式使用各种数据访问技术，如JDBC,Hibernate，Spring提供了一套抽象的DAO类，这些抽象类提供了一些方法，通过他们可以获得与数据访问技术相关的数据源和其他配置信息<ul><li><code>JdbcTemplate</code> 封装常用的JDBC方法</li><li><code>HibernateTemplate</code> 封装常用Hibernate方法</li><li><code>JdbcDaoSupport</code> -JDBC数据访问对象的基类</li><li><code>HibernateDaoSupport</code> -Hibernate数据访问对象的基类</li></ul></li></ul><h3 id="如何编写dao组件"><a class="markdownIt-Anchor" href="#如何编写dao组件"></a> 如何编写DAO组件</h3><ul><li>基于JDBC技术编写DAO组件可以采用下面两种模式<ol><li><strong>DAO继承JdbcDaoSupport</strong>，通过getJdbcTemplate()方法获取JdbcTemplate对象，需要在DAO实现类中注入一个DataSource对象来完成JdbcTemplate的实例化</li><li><strong>DAO使用JdbcTemplate</strong>，在Spring容器中配置一个JdbcTemplate的bean，然后注入给DAO实现类</li></ol></li></ul><h2 id="spring-jdbctemplate的应用xml"><a class="markdownIt-Anchor" href="#spring-jdbctemplate的应用xml"></a> Spring jdbcTemplate的应用(XML)</h2><p>JdbcTemplate封装了连接获取以及连接释放等工作，从而简化了我买对JDBC的使用，避免忘记关闭连接等错误</p><ul><li>JdbcTemplate提供了以下主要方法<ul><li><code>queryForInt</code>()</li><li><code>queryForObject</code>()</li><li><code>query</code>()</li><li><code>update</code>()</li><li><code>execute</code>()</li></ul></li></ul><p>正确编写JDBC代码的关键是使用try … finally释放资源，涉及到事务的代码需要正确提交或回滚事务。</p><p>在Spring使用JDBC，首先我们通过IoC容器创建并管理一个DataSource实例，然后，Spring提供了一个JdbcTemplate，可以方便地让我们操作JDBC，因此，通常情况下，我们会实例化一个JdbcTemplate。顾名思义，这个类主要使用了Template模式。</p><p>编写示例代码或者测试代码时，我们强烈推荐使用HSQLDB这个数据库，它是一个用Java编写的关系数据库，可以以内存模式或者文件模式运行，本身只有一个jar包，非常适合演示代码或者测试代码。</p><h3 id="maven依赖"><a class="markdownIt-Anchor" href="#maven依赖"></a> maven依赖</h3><blockquote><p>或者可以使用阿里的<strong>druid连接�</strong>�</p></blockquote><pre><code class="highlight plaintext">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;groupId&gt;com.lee&lt;/groupId&gt;&lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;dependencies&gt;&lt;!-- spring ioc组件需要的依赖包 --&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-core&lt;/artifactId&gt;&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-context&lt;/artifactId&gt;&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-expression&lt;/artifactId&gt;&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 基于AspectJ的aop依赖 --&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;aopalliance&lt;/groupId&gt;&lt;artifactId&gt;aopalliance&lt;/artifactId&gt;&lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring 事务管理和JDBC依赖包 --&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-tx&lt;/artifactId&gt;&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring 单元测试组件包 --&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-test&lt;/artifactId&gt;&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 单元测试Junit --&gt;&lt;dependency&gt;&lt;groupId&gt;junit&lt;/groupId&gt;&lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql数据库驱动包 --&gt;&lt;dependency&gt;&lt;groupId&gt;mysql&lt;/groupId&gt;&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;version&gt;5.1.35&lt;/version&gt;&lt;/dependency&gt;&lt;!-- dbcp连接池的依赖包 --&gt;&lt;dependency&gt;&lt;groupId&gt;commons-dbcp&lt;/groupId&gt;&lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;&lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt;&lt;plugins&gt;&lt;!-- 配置Maven的JDK编译级别 --&gt;&lt;plugin&gt;&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&lt;version&gt;3.2&lt;/version&gt;&lt;configuration&gt;&lt;source&gt;1.8&lt;/source&gt;&lt;target&gt;1.8&lt;/target&gt;&lt;encoding&gt;UTF-8&lt;/encoding&gt;&lt;/configuration&gt;&lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt;&lt;/project&gt;</code></pre><h3 id="入门直接使用"><a class="markdownIt-Anchor" href="#入门直接使用"></a> 入门直接使用</h3><p>不使用spring管理，直接调用</p><pre><code class="highlight plaintext">import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;public class Test &#123;    @org.junit.Test    public void run1()&#123;        // 创建连接池，先使用Spring框架内置的连接池        DriverManagerDataSource dataSource = new DriverManagerDataSource();        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);        dataSource.setUrl(&quot;jdbc:mysql:///leetest&quot;);        dataSource.setUsername(&quot;root&quot;);        dataSource.setPassword(&quot;123456&quot;);        // 创建模板类        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);        // 完成数据的添加        jdbcTemplate.update(&quot;insert into account values (?,?,?)&quot;, 1,&quot;测试&quot;,10000);    &#125;&#125;</code></pre><h3 id="spring管理使用方式"><a class="markdownIt-Anchor" href="#spring管理使用方式"></a> spring管理使用方式</h3><p>使用方式改为纳入spring管理的使用方式</p><p><strong>使用spring自带的datasource连接�</strong>�</p><h4 id="spring配置文件"><a class="markdownIt-Anchor" href="#spring配置文件"></a> spring配置文件</h4><p>applicationContext.xml</p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--配置Spring内置数据源dataSource--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/leetest?characterEncoding=UTF-8&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;    &lt;/bean&gt;    &lt;!--spring管理模板类 --&gt;    &lt;bean id=&quot;JdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h4 id="测试使用"><a class="markdownIt-Anchor" href="#测试使用"></a> 测试使用</h4><pre><code class="highlight plaintext">import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:ApplicationContext.xml&quot;)public class TestSpring &#123;    @Resource    JdbcTemplate template;    @Test    public void test()&#123;        template.update(&quot;insert into account values (?,?,?)&quot;, 2,&quot;测试222&quot;,10000);    &#125;&#125;</code></pre><h4 id="增删改查"><a class="markdownIt-Anchor" href="#增删改查"></a> 增删改查</h4><p>Account</p><pre><code class="highlight plaintext">public class Account &#123;    private int id;    private String name;    private Double salary;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Double getSalary() &#123;        return salary;    &#125;    public void setSalary(Double salary) &#123;        this.salary = salary;    &#125;&#125;</code></pre><pre><code class="highlight plaintext">import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;import java.sql.ResultSet;import java.sql.SQLException;import java.util.List;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:ApplicationContext.xml&quot;)public class SpringDemo &#123;    @Resource    private JdbcTemplate jdbcTemplate;    @Test    // 插入操作    public void demo1() &#123;        jdbcTemplate.update(&quot;insert into account values (null,?,?)&quot;, &quot;冠希&quot;, 10000d);    &#125;    @Test    // 修改操作    public void demo2() &#123;        jdbcTemplate.update(&quot;update account set name=?,money =? where id = ?&quot;, &quot;思雨&quot;, 10000d, 5);    &#125;    @Test    // 删除操作    public void demo3() &#123;        jdbcTemplate.update(&quot;delete from account where id = ?&quot;, 5);    &#125;    @Test    // 查询一条记录    public void demo4() &#123;        Account account = jdbcTemplate.queryForObject(&quot;select * from account where id = ?&quot;, new BeanMapper(), 1);        System.out.println(account);    &#125;    @Test    // 查询所有记录    public void demo5() &#123;        List&lt;Account&gt; list = jdbcTemplate.query(&quot;select * from t_account&quot;, new BeanMapper());        for (Account account : list) &#123;            System.out.println(account);        &#125;    &#125;&#125;class BeanMapper implements RowMapper&lt;Account&gt; &#123;    public Account mapRow(ResultSet rs, int arg1) throws SQLException &#123;        Account account = new Account();        account.setId(rs.getInt(&quot;id&quot;));        account.setName(rs.getString(&quot;name&quot;));        account.setSalary(rs.getDouble(&quot;salary&quot;));        return account;    &#125;&#125;</code></pre><h4 id="dbcpc3p0连接池使用"><a class="markdownIt-Anchor" href="#dbcpc3p0连接池使用"></a> dbcp/c3p0连接池使用</h4><p><strong>spring配置文件</strong></p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--配置Spring内置数据源dataSource--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/leetest?characterEncoding=UTF-8&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;    &lt;/bean&gt;    &lt;!--spring管理模板类 --&gt;    &lt;bean id=&quot;JdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;c3p0DataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!--使用dbcp连接池--&gt;    &lt;bean id=&quot;dbcpDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/leetest?characterEncoding=UTF-8&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;    &lt;/bean&gt;    &lt;!--使用c3p0连接池--&gt;    &lt;bean id=&quot;c3p0DataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/leetest?characterEncoding=UTF-8&quot;/&gt;        &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h2 id="spring-jdbctemplate的应用注解"><a class="markdownIt-Anchor" href="#spring-jdbctemplate的应用注解"></a> Spring jdbcTemplate的应用(注解)</h2><p>在Spring使用JDBC，首先我们通过IoC容器创建并管理一个DataSource实例，然后，Spring提供了一个JdbcTemplate，可以方便地让我们操作JDBC，因此，通常情况下，我们会实例化一个JdbcTemplate。顾名思义，这个类主要使用了Template模式。</p><p>编写示例代码或者测试代码时，我们强烈推荐使用HSQLDB这个数据库，它是一个用Java编写的关系数据库，可以以内存模式或者文件模式运行，本身只有一个jar包，非常适合演示代码或者测试代码。</p><p>我们以实际工程为例，先创建Maven工程spring-data-jdbc，然后引入以下依赖：</p><pre><code class="highlight plaintext">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;        &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.annotation&lt;/groupId&gt;        &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;        &lt;version&gt;1.3.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.zaxxer&lt;/groupId&gt;        &lt;artifactId&gt;HikariCP&lt;/artifactId&gt;        &lt;version&gt;3.4.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;        &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;        &lt;version&gt;2.5.0&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>在AppConfig中，我们需要创建以下几个必须的Bean：</p><pre><code class="highlight plaintext">Configuration@ComponentScan@PropertySource(&quot;jdbc.properties&quot;)public class AppConfig &#123;    @Value(&quot;$&#123;jdbc.url&#125;&quot;)    String jdbcUrl;    @Value(&quot;$&#123;jdbc.username&#125;&quot;)    String jdbcUsername;    @Value(&quot;$&#123;jdbc.password&#125;&quot;)    String jdbcPassword;    @Bean    DataSource createDataSource() &#123;        HikariConfig config = new HikariConfig();        config.setJdbcUrl(jdbcUrl);        config.setUsername(jdbcUsername);        config.setPassword(jdbcPassword);        config.addDataSourceProperty(&quot;autoCommit&quot;, &quot;true&quot;);        config.addDataSourceProperty(&quot;connectionTimeout&quot;, &quot;5&quot;);        config.addDataSourceProperty(&quot;idleTimeout&quot;, &quot;60&quot;);        return new HikariDataSource(config);    &#125;    @Bean    JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) &#123;        return new JdbcTemplate(dataSource);    &#125;&#125;</code></pre><p>在上述配置中：</p><ol><li>通过@PropertySource(“jdbc.properties”)读取数据库配置文件；</li><li>通过@Value(“${jdbc.url}”)注入配置文件的相关配置；</li><li>创建一个DataSource实例，它的实际类型是HikariDataSource，创建时需要用到注入的配置；</li><li>创建一个JdbcTemplate实例，它需要注入DataSource，这是通过方法参数完成注入的。</li></ol><p>最后，针对HSQLDB写一个配置文件jdbc.properties：</p><pre><code class="highlight plaintext"># 数据库文件名为testdb:jdbc.url=jdbc:hsqldb:file:testdb# Hsqldb默认的用户名是sa，口令是空字符串:jdbc.username=sajdbc.password=</code></pre><p>可以通过HSQLDB自带的工具来初始化数据库表，这里我们写一个Bean，在Spring容器启动时自动创建一个users表：</p><pre><code class="highlight plaintext">@Componentpublic class DatabaseInitializer &#123;    @Autowired    JdbcTemplate jdbcTemplate;    @PostConstruct    public void init() &#123;        jdbcTemplate.update(&quot;CREATE TABLE IF NOT EXISTS users (&quot; //                + &quot;id BIGINT IDENTITY NOT NULL PRIMARY KEY, &quot; //                + &quot;email VARCHAR(100) NOT NULL, &quot; //                + &quot;password VARCHAR(100) NOT NULL, &quot; //                + &quot;name VARCHAR(100) NOT NULL, &quot; //                + &quot;UNIQUE (email))&quot;);    &#125;&#125;</code></pre><p>现在，所有准备工作都已完毕。我们只需要在需要访问数据库的Bean中，注入JdbcTemplate即可：</p><pre><code class="highlight plaintext">@Componentpublic class UserService &#123;    @Autowired    JdbcTemplate jdbcTemplate;    ...&#125;</code></pre><h3 id="jdbctemplate用法"><a class="markdownIt-Anchor" href="#jdbctemplate用法"></a> JdbcTemplate用法</h3><p>Spring提供的JdbcTemplate采用Template模式，提供了一系列以回调为特点的工具方法，目的是避免繁琐的try…catch语句。</p><p>我们以具体的示例来说明JdbcTemplate的用法。</p><p>首先我们看T execute(ConnectionCallback<T> action)方法，它提供了Jdbc的Connection供我们使用：</p><pre><code class="highlight plaintext">public User getUserById(long id) &#123;    // 注意传入的是ConnectionCallback:    return jdbcTemplate.execute((Connection conn) -&gt; &#123;        // 可以直接使用conn实例，不要释放它，回调结束后JdbcTemplate自动释放:        // 在内部手动创建的PreparedStatement、ResultSet必须用try(...)释放:        try (var ps = conn.prepareStatement(&quot;SELECT * FROM users WHERE id = ?&quot;)) &#123;            ps.setObject(1, id);            try (var rs = ps.executeQuery()) &#123;                if (rs.next()) &#123;                    return new User( // new User object:                            rs.getLong(&quot;id&quot;), // id                            rs.getString(&quot;email&quot;), // email                            rs.getString(&quot;password&quot;), // password                            rs.getString(&quot;name&quot;)); // name                &#125;                throw new RuntimeException(&quot;user not found by id.&quot;);            &#125;        &#125;    &#125;);&#125;</code></pre><p>也就是说，上述回调方法允许获取Connection，然后做任何基于Connection的操作。</p><p>我们再看T execute(String sql, PreparedStatementCallback<T> action)的用法：</p><pre><code class="highlight plaintext">public User getUserByName(String name) &#123;    // 需要传入SQL语句，以及PreparedStatementCallback:    return jdbcTemplate.execute(&quot;SELECT * FROM users WHERE name = ?&quot;, (PreparedStatement ps) -&gt; &#123;        // PreparedStatement实例已经由JdbcTemplate创建，并在回调后自动释放:        ps.setObject(1, name);        try (var rs = ps.executeQuery()) &#123;            if (rs.next()) &#123;                return new User( // new User object:                        rs.getLong(&quot;id&quot;), // id                        rs.getString(&quot;email&quot;), // email                        rs.getString(&quot;password&quot;), // password                        rs.getString(&quot;name&quot;)); // name            &#125;            throw new RuntimeException(&quot;user not found by id.&quot;);        &#125;    &#125;);&#125;</code></pre><p>最后，我们看T queryForObject(String sql, Object[] args, RowMapper<T> rowMapper)方法：</p><pre><code class="highlight plaintext">public User getUserByEmail(String email) &#123;    // 传入SQL，参数和RowMapper实例:    return jdbcTemplate.queryForObject(&quot;SELECT * FROM users WHERE email = ?&quot;, new Object[] &#123; email &#125;,            (ResultSet rs, int rowNum) -&gt; &#123;                // 将ResultSet的当前行映射为一个JavaBean:                return new User( // new User object:                        rs.getLong(&quot;id&quot;), // id                        rs.getString(&quot;email&quot;), // email                        rs.getString(&quot;password&quot;), // password                        rs.getString(&quot;name&quot;)); // name            &#125;);&#125;</code></pre><p>在queryForObject()方法中，传入SQL以及SQL参数后，JdbcTemplate会自动创建PreparedStatement，自动执行查询并返回ResultSet，我们提供的RowMapper需要做的事情就是把ResultSet的当前行映射成一个JavaBean并返回。整个过程中，使用Connection、PreparedStatement和ResultSet都不需要我们手动管理。</p><p>RowMapper不一定返回JavaBean，实际上它可以返回任何Java对象。例如，使用<code>SELECT COUNT(*)</code>查询时，可以返回Long：</p><pre><code class="highlight plaintext">public long getUsers() &#123;    return jdbcTemplate.queryForObject(&quot;SELECT COUNT(*) FROM users&quot;, null, (ResultSet rs, int rowNum) -&gt; &#123;        // SELECT COUNT(*)查询只有一列，取第一列数据:        return rs.getLong(1);    &#125;);&#125;```如果我们期望返回多行记录，而不是一行，可以用query()方法：```javapublic List&lt;User&gt; getUsers(int pageIndex) &#123;    int limit = 100;    int offset = limit * (pageIndex - 1);    return jdbcTemplate.query(&quot;SELECT * FROM users LIMIT ? OFFSET ?&quot;, new Object[] &#123; limit, offset &#125;,            new BeanPropertyRowMapper&lt;&gt;(User.class));&#125;</code></pre><p>上述query()方法传入的参数仍然是SQL、SQL参数以及RowMapper实例。这里我们直接使用Spring提供的BeanPropertyRowMapper。如果数据库表的结构恰好和JavaBean的属性名称一致，那么BeanPropertyRowMapper就可以直接把一行记录按列名转换为JavaBean。</p><p>如果我们执行的不是查询，而是插入、更新和删除操作，那么需要使用update()方法：</p><pre><code class="highlight plaintext">public void updateUser(User user) &#123;    // 传入SQL，SQL参数，返回更新的行数:    if (1 != jdbcTemplate.update(&quot;UPDATE users SET name = ? WHERE id=?&quot;, user.getName(), user.getId())) &#123;        throw new RuntimeException(&quot;User not found by id&quot;);    &#125;&#125;</code></pre><p>只有一种INSERT操作比较特殊，那就是如果某一列是自增列（例如自增主键），通常，我们需要获取插入后的自增值。JdbcTemplate提供了一个KeyHolder来简化这一操作：</p><pre><code class="highlight plaintext">public User register(String email, String password, String name) &#123;    // 创建一个KeyHolder:    KeyHolder holder = new GeneratedKeyHolder();    if (1 != jdbcTemplate.update(        // 参数1:PreparedStatementCreator        (conn) -&gt; &#123;            // 创建PreparedStatement时，必须指定RETURN_GENERATED_KEYS:            var ps = conn.prepareStatement(&quot;INSERT INTO users(email,password,name) VALUES(?,?,?)&quot;,                    Statement.RETURN_GENERATED_KEYS);            ps.setObject(1, email);            ps.setObject(2, password);            ps.setObject(3, name);            return ps;        &#125;,        // 参数2:KeyHolder        holder)    ) &#123;        throw new RuntimeException(&quot;Insert failed.&quot;);    &#125;    // 从KeyHolder中获取返回的自增值:    return new User(holder.getKey().longValue(), email, password, name);&#125;</code></pre><p>JdbcTemplate还有许多重载方法，这里我们不一一介绍。需要强调的是，JdbcTemplate只是对JDBC操作的一个简单封装，它的目的是尽量减少手动编写try(resource) {…}的代码，对于查询，主要通过RowMapper实现了JDBC结果集到Java对象的转换。</p><h2 id="sprng-jdbcdaosupport应用"><a class="markdownIt-Anchor" href="#sprng-jdbcdaosupport应用"></a> Sprng JdbcDaoSupport应用</h2><ul><li>JdbcDaoSupport是利用JDBC技术编写DAO的父类，通过该类提供的方法，可便于获取Connection和JdbcTemplate等对象信息</li><li>JdbcDaoSupport使用时需要注入一个DataSource对象</li><li>JdbcDaoSupport对代码有一定的<strong>侵入性</strong></li></ul><p><strong>jdbcDaoSupport有个成员变量jdbcTemplate</strong>，所以可以直接继承改类来获取jdbcTemplate，使用方式完全相同，<strong>只需把注入的方式改为继承的方式</strong></p><h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3><p>使用JdbcDaoSupport，<strong>只需让sql操作类继承改类</strong>，然后在spring配置文件中，给sql操作类<strong>显式的注入datasource</strong>即可</p><pre><code class="highlight plaintext">import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:ApplicationContext.xml&quot;)public class TestSpring extends JdbcDaoSupport &#123;//使用JdbcDaoSupport就无需注入JdbcTemplate//    @Resource//    JdbcTemplate template;    @Test    public void test()&#123;        this.template.update(&quot;insert into account values (?,?,?)&quot;, 2,&quot;测试222&quot;,10000);    &#125;&#125;</code></pre><p>applicationContext.xml配置文件给该类注入datasource</p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--配置Spring内置数据源dataSource--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/leetest?characterEncoding=UTF-8&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;    &lt;/bean&gt;    &lt;!--spring管理模板类 --&gt;    &lt;!--在这里显式的注入dataSource--&gt;    &lt;bean id=&quot;TestSpring&quot; class=&quot;com.lee.TestSpring&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><p>集成Hibernate</p><h1 id="spring-事务"><a class="markdownIt-Anchor" href="#spring-事务"></a> Spring 事务</h1><h2 id="事务概念"><a class="markdownIt-Anchor" href="#事务概念"></a> 事务概念</h2><h3 id="事务介绍"><a class="markdownIt-Anchor" href="#事务介绍"></a> 事务介绍</h3><p>事务：指的是逻辑上一组操作，组成这个事务的各个执行单元，要么一起成功，要么一起失败</p><p>事务的特新：</p><ul><li><strong>原子性</strong>（Atomicity）<ul><li>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚</li></ul></li><li><strong>一致性</strong>（Consistecy）<ul><li>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态</li><li>比如：转账，a用户和b用户两者的钱加起来一共是5000，那么不管a和b之间如何转账，转几次帐，事务结束后两个用户的钱加起来还要是5000，这就是事务的一致性</li></ul></li><li>隔离性（Isolation）<ul><li>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离</li></ul></li><li>持久性（Durability）<ul><li>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即使实在数据库系统中遇到故障的情况下，也不会丢失提交事务的操作</li></ul></li></ul><h3 id="事务的并发问题隔离性导致"><a class="markdownIt-Anchor" href="#事务的并发问题隔离性导致"></a> 事务的并发问题（隔离性导致）</h3><p>在事务的并发操作中可能会出现一些问题：</p><ul><li><strong>脏读</strong>：一个事务读取到另一个事务<strong>未提交</strong>的数据</li><li><strong>不可重复读</strong>：一个事务因读取到另一个事务已提交的数据，导致对<strong>同一条记录</strong>读取两次以上的结果不一致，update操作</li><li><strong>幻读</strong>：一个事务因读取到另一个事务已提交的数据，导致<strong>对同一张表</strong>读取两次以上的结果不一致，insert,delete操作</li></ul><p><img src="image/.png" alt=".png" /></p><h3 id="事务隔离级别"><a class="markdownIt-Anchor" href="#事务隔离级别"></a> 事务隔离级别</h3><p>为了避免出现上述的几种情况，在标准sql规范中，定义了4个事务隔离级别，不同的隔离级别对事务的处理不同</p><h4 id="四种隔离级别"><a class="markdownIt-Anchor" href="#四种隔离级别"></a> 四种隔离级别</h4><p>MySQL数据库为我们提供了四种隔离级别（由低到高）：</p><ul><li><strong>Read uncommitted</strong>（读未提交）：最低级别，任何情况都无法保证</li><li><strong>Read committed</strong>（读已提交）：可避免脏读的发生</li><li><strong>Repeatable read</strong>（可重复读）：可避免脏读，不可重复读的发生</li><li><strong>Serializable</strong>（串行化）：可避免脏读，不可重复读，幻读的发生</li></ul><p><strong>默认隔离级别</strong></p><p>大多数数据库的默认隔离级别时Read committed，比如Oracle，DB2等</p><p>MySQL数据库的隔离级别时Repeatable read</p><h4 id="事务的传播行为"><a class="markdownIt-Anchor" href="#事务的传播行为"></a> 事务的传播行为</h4><p>事务的传播行为：解决的是业务层之间的方法调用</p><p>比如：事务都是针对service层进行设置的，但是service层的代码之间是可以相互调用的，s1和s2方法，两个方法都有各自的事务，如果此时s1调用了s2，那么为了保证在一个事务内进行操作的，需要进行事务传播特性的设置</p><ul><li><strong>PROPAGATION_REQUIRED</strong>（默认值）：A中有事务,使用A中的事务.如果没有，B就会开启一个新的事务,将A包含进来.(保证A,B在同一个事务中)，<strong>默认值</strong></li><li><strong>PROPAGATION_SUPPORTS</strong>：A中有事务,使用A中的事务.如果A中没有事务.那么B也不使用事务.</li><li><strong>PROPAGATION_MANDATORY</strong>：A中有事务,使用A中的事务.如果A没有事务.抛出异常.</li><li><strong>PROPAGATION_REQUIRES_NEW</strong>：A中有事务,将A中的事务挂起.B创建一个新的事务.(保证A,B没有在一个事务中)</li><li><strong>PROPAGATION_NOT_SUPPORTED</strong>：A中有事务,将A中的事务挂起.</li><li><strong>PROPAGATION_NEVER</strong>：A中有事务,抛出异常.</li><li><strong>PROPAGATION_NESTED</strong>：嵌套事务.当A执行之后,就会在这个位置设置一个保存点.如果B没有问题.执行通过.如果B出现异常,运行客户根据需求回滚(选择回滚到保存点或者是最初始状态)</li></ul><h4 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h4><p><strong>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大</strong></p><p>对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制</p><h2 id="spring框架的事务管理相关的类和api"><a class="markdownIt-Anchor" href="#spring框架的事务管理相关的类和api"></a> Spring框架的事务管理相关的类和API</h2><p>Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。 <strong>Spring事务管理器的接口是PlatformTransactionManager</strong>，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了</p><p><img src="image/-1.png" alt="-1.png" /></p><h3 id="platformtransactionmanager接口"><a class="markdownIt-Anchor" href="#platformtransactionmanager接口"></a> PlatformTransactionManager接口</h3><p>平台事务管理器（真正管理事务的类），该接口有具体的实现类，根据不同的持久层框架，需要选择不同的实现类</p><ul><li><strong>接口的实现类：</strong><ul><li>如果使用spring的jdbc模板或者mybatis框架，需要选择<code>DataSourceTransactionManager</code>实现类</li><li>如果使用的是Hibernate的框架，需要选择的是<code>HibernateTransactionManager</code>实现类</li></ul></li><li><strong>该接口的常用方法：</strong><ul><li>void commit(TransactionStatus status)</li><li>TransactionStatus getTransaction(TransactionDefinition definition)</li><li>void rollback(TransactionStatus status)</li></ul></li></ul><h3 id="transactiondefinition接口"><a class="markdownIt-Anchor" href="#transactiondefinition接口"></a> TransactionDefinition接口</h3><p>事务定义信息（事务的隔离级别，传播行为，超时，只读）</p><ul><li><strong>事务隔离级别的常量</strong><ul><li>static int ISOLATION_DEFAULT             – 采用数据库的默认隔离级别</li><li>static int ISOLATION_READ_UNCOMMITTED</li><li>static int ISOLATION_READ_COMMITTED</li><li>static int ISOLATION_REPEATABLE_READ</li><li>static int ISOLATION_SERIALIZABLE</li></ul></li><li><strong>事务的传播行为</strong><ul><li>PROPAGATION_REQUIRED（默认值） – A中有事务,使用A中的事务.如果没有，B就会开启一个新的事务,将A包含进来.(保证A,B在同一个事务中)，默认值！！</li><li>PROPAGATION_SUPPORTS          – A中有事务,使用A中的事务.如果A中没有事务.那么B也不使用事务.</li><li>PROPAGATION_MANDATORY         – A中有事务,使用A中的事务.如果A没有事务.抛出异常.</li><li>PROPAGATION_REQUIRES_NEW      – A中有事务,将A中的事务挂起.B创建一个新的事务.(保证A,B没有在一个事务中)</li><li>PROPAGATION_NOT_SUPPORTED     – A中有事务,将A中的事务挂起.</li><li>PROPAGATION_NEVER             – A中有事务,抛出异常.</li><li>PROPAGATION_NESTED            – 嵌套事务.当A执行之后,就会在这个位置设置一个保存点.如果B没有问题.执行通过.如果B出现异常,运行客户根据需求回滚(选择回滚到保存点或者是最初始状态)</li></ul></li></ul><h3 id="transactionstatus接口"><a class="markdownIt-Anchor" href="#transactionstatus接口"></a> TransactionStatus接口</h3><p>事务的状态（是否新事物，是否已提交，是否有保存点，是否回滚）</p><blockquote><p>总结：上述对象之间的关系：平台事务管理器PlatformTransactionManager真正管理事务对象，根据事务定义的信息TransactionDefinition进行事务管理，在管理事务中产生一些状态，将状态记录到TransactionStatus中</p></blockquote><h2 id="spring框架事务管理的分类"><a class="markdownIt-Anchor" href="#spring框架事务管理的分类"></a> Spring框架事务管理的分类</h2><ol><li>spring的<strong>编程式事务管理</strong>（不推荐使用）<ul><li>通过手动编写代码的方式完成事务的管理</li></ul></li><li>spring的<strong>声明式事务管理</strong>（底层采用AOP的技术）<ul><li>通过一段配置的方式完成事务的管理</li><li>一般使用基于aspectJ的xml方式 和 基于aspectJ的注解方式</li></ul></li></ol><h3 id="编程式事务管理了解"><a class="markdownIt-Anchor" href="#编程式事务管理了解"></a> 编程式事务管理（了解）</h3><p>spring为了简化事务管理的代码，提供了模板类TransactionTemplate，所以手手动编程的方式管理事务，只需要使用该模板类即可</p><h4 id="配置一个事务管理器"><a class="markdownIt-Anchor" href="#配置一个事务管理器"></a> 配置一个事务管理器</h4><p>配置一个事务管理器，Spring使用PlatformTransactionManager接口来管理事务，所以咱们需要使用到他的实现类</p><pre><code class="highlight plaintext">&lt;!-- 配置事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;</code></pre><h4 id="配置事务管理模板"><a class="markdownIt-Anchor" href="#配置事务管理模板"></a> 配置事务管理模板</h4><pre><code class="highlight plaintext">&lt;!-- 配置事务管理的模板 --&gt;&lt;bean id=&quot;transactionTemplate&quot; class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt;    &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;&lt;/bean&gt;</code></pre><h4 id="注入事务管理模板"><a class="markdownIt-Anchor" href="#注入事务管理模板"></a> 注入事务管理模板</h4><p>在需要在进行事务管理的类中，注入事务管理的模板</p><pre><code class="highlight plaintext">&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.demo1.AccountServiceImpl&quot;&gt;    &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;    &lt;property name=&quot;transactionTemplate&quot; ref=&quot;transactionTemplate&quot;/&gt;&lt;/bean&gt;</code></pre><h4 id="在业务层使用模板管理事务"><a class="markdownIt-Anchor" href="#在业务层使用模板管理事务"></a> 在业务层使用模板管理事务</h4><pre><code class="highlight plaintext">        // 注入事务模板对象        private TransactionTemplate transactionTemplate;        public void setTransactionTemplate(TransactionTemplate transactionTemplate) &#123;            this.transactionTemplate = transactionTemplate;        &#125;        public void pay(final String out, final String in, final double money) &#123;            transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;                protected void doInTransactionWithoutResult(TransactionStatus status) &#123;                    // 扣钱                    accountDao.outMoney(out, money);                    int a = 10/0;                    // 加钱                    accountDao.inMoney(in, money);                &#125;            &#125;);        &#125;</code></pre><h3 id="声明式事务管理重点"><a class="markdownIt-Anchor" href="#声明式事务管理重点"></a> 声明式事务管理（重点）</h3><p>声明式事务管理又分成两种方式</p><ul><li>基于AspectJ的XML方式（重点掌握）</li><li>基于AspectJ的注解方式（重点掌握）</li></ul><h4 id="基于aspectj的xml方式"><a class="markdownIt-Anchor" href="#基于aspectj的xml方式"></a> 基于AspectJ的XML方式</h4><h5 id="maven依赖-2"><a class="markdownIt-Anchor" href="#maven依赖-2"></a> maven依赖</h5><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.lee&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;!-- spring ioc组件需要的依赖包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 基于AspectJ的aop依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;aopalliance&lt;/groupId&gt;            &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;            &lt;version&gt;1.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- spring 事务管理依赖包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--spring jdbc依赖包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- spring 单元测试组件包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 单元测试Junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- mysql数据库驱动包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.35&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- dbcp连接池的依赖包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;            &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;            &lt;version&gt;1.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--c3p0连接池--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.mchange&lt;/groupId&gt;            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;            &lt;version&gt;0.9.5.4&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;!-- 配置Maven的JDK编译级别 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><h5 id="数据库表"><a class="markdownIt-Anchor" href="#数据库表"></a> 数据库表</h5><p><img src="image/-2.png" alt="-2.png" /></p><h5 id="持久层"><a class="markdownIt-Anchor" href="#持久层"></a> 持久层</h5><ul><li>AccountDao</li></ul><pre><code class="highlight plaintext">package com.lee.dao;public interface AccountDao &#123;    void updateAccount(String name,double mony);    Double selectAccount(String name);&#125;</code></pre><ul><li>AccountDaoImpl</li></ul><pre><code class="highlight plaintext">package com.lee.dao;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowCallbackHandler;import org.springframework.jdbc.core.RowMapper;import org.springframework.stereotype.Repository;import javax.annotation.Resource;import java.sql.ResultSet;import java.sql.SQLException;@Repositorypublic class AccountDaoImpl implements AccountDao &#123;    @Resource    JdbcTemplate jdbcTemplate;    //根据名字修改金钱    public void updateAccount(String name, double money) &#123;        jdbcTemplate.update(&quot;update account set money = ? where name = ? &quot;, money, name);    &#125;    //根据名字查金钱    public Double selectAccount(String name) &#123;        Double money = jdbcTemplate.queryForObject(&quot;select money from account where name = ?&quot;, new BeanMapper(),name);        return money;    &#125;    class BeanMapper implements RowMapper&lt;Double&gt; &#123;        public Double mapRow(ResultSet rs, int arg1) throws SQLException &#123;            return rs.getDouble(&quot;money&quot;);        &#125;    &#125;&#125;</code></pre><h5 id="业务层"><a class="markdownIt-Anchor" href="#业务层"></a> 业务层</h5><ul><li>AccountService</li></ul><pre><code class="highlight plaintext">package com.lee.service;public interface AccountService &#123;    void transfer(String form,String to,double money);&#125;</code></pre><ul><li>AccountServiceImpl</li></ul><pre><code class="highlight plaintext">package com.lee.service;import com.lee.dao.AccountDao;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Servicepublic class AccountServiceImpl implements AccountService &#123;    @Resource    AccountDao dao;    @Override    public void transfer(String form, String to, double money) &#123;        //给from减去金额        double money1 = dao.selectAccount(form);        dao.updateAccount(form,money1-money);        System.out.println(1/0);        //给to加上金额        double money2 = dao.selectAccount(to);        dao.updateAccount(to,money2+money);    &#125;&#125;</code></pre><h5 id="spring-配置"><a class="markdownIt-Anchor" href="#spring-配置"></a> spring 配置</h5><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd       http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.lee&quot;&gt;&lt;/context:component-scan&gt;    &lt;!--配置Spring内置数据源dataSource--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/leetest?characterEncoding=UTF-8&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;    &lt;/bean&gt;    &lt;!--spring管理模板类 --&gt;    &lt;bean id=&quot;JdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!--基于AspectJ + XML方式实现声明式事务--&gt;    &lt;!--配置平台事务管理器DataSourceTransactionManager--&gt;    &lt;!--底层实际还是使用jdbc进行事务管理--&gt;    &lt;bean id=&quot;TransactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!--事务通知--&gt;    &lt;!--tx:advice：对应的处理器类就是TransactionInterceptor类（实现MethodInterceptor环绕通知接口）--&gt;    &lt;!--TransactionInterceptor类实现事务是通过transaction-manager属性指定的值实现事务管理的--&gt;    &lt;tx:advice id=&quot;txAdvice&quot;  transaction-manager=&quot;TransactionManager&quot;&gt;        &lt;!--设置事务管理信息（隔离级别，传播行为）--&gt;        &lt;tx:attributes&gt;            &lt;!--name：要管理的方法名，可以使用通配符*--&gt;            &lt;!--isolation:隔离级别，一般使用默认--&gt;            &lt;!--propagation:事务传播行为：增删改一般使用required，查询一般使用read-only--&gt;            &lt;tx:method name=&quot;trans*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot;/&gt;                        &lt;!--该标签可以写多条--&gt;            &lt;tx:method name=&quot;query*&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!--配置aop--&gt;    &lt;aop:config&gt;        &lt;!--使用advisor的原因是我们使用的advice不是自己写的--&gt;        &lt;!--aop:advisor标签使用的是传统spring aop开发方式实现的--&gt;        &lt;!--spring已经提前实现了该增强功能，spring使用的是MethodInterceptor（环绕通知）接口的方式--&gt;        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* *..*.*ServiceImpl.*(..))&quot;/&gt;&lt;!--        这里不使用aspect的原因是aspect自由度更高，当我们自定义实现advice的时候使用aspect--&gt;&lt;!--        &lt;aop:aspect ref=&quot;txAdvice&quot;&gt;--&gt;&lt;!--            &lt;aop:around method=&quot;&quot; pointcut=&quot;execution(* *..*.*ServiceImpl.*(..))&quot;/&gt;--&gt;&lt;!--        &lt;/aop:aspect&gt;--&gt;    &lt;/aop:config&gt;&lt;/beans&gt;</code></pre><h5 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h5><pre><code class="highlight plaintext">import com.lee.service.AccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:ApplicationContext.xml&quot;)public class TestSpring &#123;    @Resource    AccountService service;    @Test    public void test2()&#123;        service.transfer(&quot;李博&quot;,&quot;李菊&quot;,200);    &#125;&#125;</code></pre><p>加上事务管理后，如果程序报错，则转账双方的金额都不会改变</p><h5 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h5><p><strong>源码入口</strong></p><p>此处需要了解TxAdviceBeanDefinitionParser的继承体系，TxAdviceBeanDefinitionParseràAbstractSingleBeanDefinitionParseràAbstractBeanDefinitionParser，因为根据上面loadBeanDefinitions流程源码分析，我们知道自定义元素的解析工作是从一个namespaceHandler.parser方法开始的，该方法在AbstractBeanDefinitionParser类中</p><p><img src="image/-3.png" alt="-3.png" /></p><p><img src="image/-4.png" alt="-4.png" /></p><p>我们重点关心如何获取BeanDefinition对象的，所以接下来，我们进入parseInternal方法，该方法在AbstractSingleBeanDefinitionParser中（参考上面继承体系）</p><p><img src="image/-5.png" alt="-5.png" /></p><p>接下来，我们来到了TxAdviceBeanDefinitionParser类，因为getBeanClass方法和doParser方法都在该类里面</p><p><img src="image/-6.png" alt="-6.png" /></p><p>此时我们重点了解一下TransactionInterceptor这个类，它是我们分析的最终目标</p><p><img src="image/-7.png" alt="-7.png" /></p><p>invokeWithInTransaction方法在TransactionInterceptor类的父类TransactionAspectSupport中：</p><p><img src="image/-8.png" alt="-8.png" /></p><p>对于事务源码，了解到此处基本上可以了，如果想再了解事务是如何开启和提交的，请继续往下看，接下来我们进入createTransactionIfNecessary方法看看，事务是如何开启的</p><p><img src="image/-9.png" alt="-9.png" /></p><p>我们进入AbstractPlatformTransactionManager中的getTransaction方法继续了解事务是如何开启的：</p><p><img src="image/-10.png" alt="-10.png" /></p><p>接下来，该进入doBegin方法了，不过该方法在具体的平台事务管理器的子类中，我们此处使用DataSourceTransactionManager子类进行源码跟踪</p><p><img src="image/-11.png" alt="-11.png" /></p><p>DataSourceTransactionManager的事务管理是通过底层的JDBC代码实现的，但是不同的平台事务管理器，它们底层的事务处理也是不同的</p><h4 id="基于aspectj的注解方式"><a class="markdownIt-Anchor" href="#基于aspectj的注解方式"></a> 基于AspectJ的注解方式</h4><p><strong>service类上或者方法上加注解：</strong></p><ul><li>类上加@Transactional：表示该类中所有的方法都被事务管理</li><li>方法上加@Transactional：表示只有该方法被事务管理</li></ul><pre><code class="highlight plaintext">package com.lee.service;import com.lee.dao.AccountDao;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import javax.annotation.Resource;//@Transactional：标记改类的所有方法都已经被事务管理了，至于管理属性，不设置的话，都采取默认值@Transactional@Servicepublic class AccountServiceImpl implements AccountService &#123;    @Resource    AccountDao dao;    @Override    public void transfer(String form, String to, double money) &#123;        //给from减去金额        double money1 = dao.selectAccount(form);        dao.updateAccount(form,money1-money);        System.out.println(1/0);        //给to加上金额        double money2 = dao.selectAccount(to);        dao.updateAccount(to,money2+money);    &#125;&#125;</code></pre><p><strong>开启事务注解：</strong></p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd       http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.lee&quot;&gt;&lt;/context:component-scan&gt;    &lt;!--配置Spring内置数据源dataSource--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/leetest?characterEncoding=UTF-8&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;    &lt;/bean&gt;    &lt;!--spring管理模板类 --&gt;    &lt;bean id=&quot;JdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置平台事务管理器DataSourceTransactionManager--&gt;    &lt;!--底层实际还是使用jdbc进行事务管理--&gt;    &lt;bean id=&quot;TransactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!--开启事务注解--&gt;    &lt;tx:annotation-driven transaction-manager=&quot;TransactionManager&quot;/&gt;&lt;/beans&gt;</code></pre><p><strong>@Transactional注解就相当于以下的配置，即使用注解后，以下代码就可以省略</strong></p><pre><code class="highlight plaintext">  &lt;!--事务通知--&gt;    &lt;!--tx:advice：对应的处理器类就是TransactionInterceptor类（实现MethodInterceptor环绕通知接口）--&gt;    &lt;!--TransactionInterceptor类实现事务是通过transaction-manager属性指定的值实现事务管理的--&gt;    &lt;tx:advice id=&quot;txAdvice&quot;  transaction-manager=&quot;TransactionManager&quot;&gt;        &lt;!--设置事务管理信息（隔离级别，传播行为）--&gt;        &lt;tx:attributes&gt;            &lt;!--name：要管理的方法名，可以使用通配符*--&gt;            &lt;!--isolation:隔离级别，一般使用默认--&gt;            &lt;!--propagation:事务传播行为：增删改一般使用required，查询一般使用read-only--&gt;            &lt;tx:method name=&quot;trans*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!--配置aop--&gt;    &lt;aop:config&gt;        &lt;!--使用advisor的原因是我们使用的advice不是自己写的--&gt;        &lt;!--aop:advisor标签使用的是传统spring aop开发方式实现的--&gt;        &lt;!--spring已经提前实现了该增强功能，spring使用的是MethodInterceptor（环绕通知）接口的方式--&gt;        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* *..*.*ServiceImpl.*(..))&quot;/&gt;&lt;!--        这里不使用aspect的原因是aspect自由度更高，当我们自定义实现advice的时候使用aspect--&gt;&lt;!--        &lt;aop:aspect ref=&quot;txAdvice&quot;&gt;--&gt;&lt;!--            &lt;aop:around method=&quot;&quot; pointcut=&quot;execution(* *..*.*ServiceImpl.*(..))&quot;/&gt;--&gt;&lt;!--        &lt;/aop:aspect&gt;--&gt;    &lt;/aop:config&gt;</code></pre><h3 id="使用声明式事务"><a class="markdownIt-Anchor" href="#使用声明式事务"></a> 使用声明式事务</h3><p>使用Spring操作JDBC虽然方便，但是我们在前面讨论JDBC的时候，讲到过JDBC事务，如果要在Spring中操作事务，没必要手写JDBC事务，可以使用Spring提供的高级接口来操作事务。</p><p>Spring提供了一个PlatformTransactionManager来表示事务管理器，所有的事务都由它负责管理。而事务由TransactionStatus表示。如果手写事务代码，使用try…catch如下：</p><pre><code class="highlight plaintext">TransactionStatus tx = null;try &#123;    // 开启事务:    tx = txManager.getTransaction(new DefaultTransactionDefinition());    // 相关JDBC操作:    jdbcTemplate.update(&quot;...&quot;);    jdbcTemplate.update(&quot;...&quot;);    // 提交事务:    txManager.commit(tx);&#125; catch (RuntimeException e) &#123;    // 回滚事务:    txManager.rollback(tx);    throw e;&#125;</code></pre><p>Spring为啥要抽象出PlatformTransactionManager和TransactionStatus？原因是JavaEE除了提供JDBC事务外，它还支持分布式事务JTA（Java Transaction API）。分布式事务是指多个数据源（比如多个数据库，多个消息系统）要在分布式环境下实现事务的时候，应该怎么实现。分布式事务实现起来非常复杂，简单地说就是通过一个分布式事务管理器实现两阶段提交，但本身数据库事务就不快，基于数据库事务实现的分布式事务就慢得难以忍受，所以使用率不高。</p><p>Spring为了同时支持JDBC和JTA两种事务模型，就抽象出PlatformTransactionManager。因为我们的代码只需要JDBC事务，因此，在AppConfig中，需要再定义一个PlatformTransactionManager对应的Bean，它的实际类型是DataSourceTransactionManager：</p><pre><code class="highlight plaintext">@Configuration@ComponentScan@PropertySource(&quot;jdbc.properties&quot;)public class AppConfig &#123;    ...    @Bean    PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) &#123;        return new DataSourceTransactionManager(dataSource);    &#125;&#125;</code></pre><p>使用编程的方式使用Spring事务仍然比较繁琐，更好的方式是通过声明式事务来实现。使用声明式事务非常简单，除了在AppConfig中追加一个上述定义的PlatformTransactionManager外，再加一个@EnableTransactionManagement就可以启用声明式事务：</p><pre><code class="highlight plaintext">@Configuration@ComponentScan@EnableTransactionManagement // 启用声明式@PropertySource(&quot;jdbc.properties&quot;)public class AppConfig &#123;    ...&#125;</code></pre><p>然后，对需要事务支持的方法，加一个@Transactional注解：</p><pre><code class="highlight plaintext">@Componentpublic class UserService &#123;    // 此public方法自动具有事务支持:    @Transactional    public User register(String email, String password, String name) &#123;       ...    &#125;&#125;</code></pre><p>或者更简单一点，直接在Bean的class处加上，表示所有public方法都具有事务支持：</p><pre><code class="highlight plaintext">@Component@Transactionalpublic class UserService &#123;    ...&#125;</code></pre><p>Spring对一个声明式事务的方法，如何开启事务支持？原理仍然是AOP代理，即通过自动创建Bean的Proxy实现：</p><pre><code class="highlight plaintext">public class UserService$$EnhancerBySpringCGLIB extends UserService &#123;    UserService target = ...    PlatformTransactionManager txManager = ...    public User register(String email, String password, String name) &#123;        TransactionStatus tx = null;        try &#123;            tx = txManager.getTransaction(new DefaultTransactionDefinition());            target.register(email, password, name);            txManager.commit(tx);        &#125; catch (RuntimeException e) &#123;            txManager.rollback(tx);            throw e;        &#125;    &#125;    ...&#125;</code></pre><blockquote><p>注意：声明了@EnableTransactionManagement后，不必额外添加@EnableAspectJAutoProxy。</p></blockquote><h4 id="回滚事务"><a class="markdownIt-Anchor" href="#回滚事务"></a> 回滚事务</h4><p>默认情况下，如果发生了RuntimeException，Spring的声明式事务将自动回滚。在一个事务方法中，如果程序判断需要回滚事务，只需抛出RuntimeException，例如：</p><pre><code class="highlight plaintext">@Transactionalpublic buyProducts(long productId, int num) &#123;    ...    if (store &lt; num) &#123;        // 库存不够，购买失败:        throw new IllegalArgumentException(&quot;No enough products&quot;);    &#125;    ...&#125;</code></pre><p>如果要针对Checked Exception回滚事务，需要在@Transactional注解中写出来：</p><pre><code class="highlight plaintext">@Transactional(rollbackFor = &#123;RuntimeException.class, IOException.class&#125;)public buyProducts(long productId, int num) throws IOException &#123;    ...&#125;</code></pre><p>上述代码表示在抛出RuntimeException或IOException时，事务将回滚。</p><p>为了简化代码，我们强烈建议业务异常体系从RuntimeException派生，这样就不必声明任何特殊异常即可让Spring的声明式事务正常工作：</p><pre><code class="highlight plaintext">public class BusinessException extends RuntimeException &#123;    ...&#125;public class LoginException extends BusinessException &#123;    ...&#125;public class PaymentException extends BusinessException &#123;    ...&#125;</code></pre><h4 id="事务边界"><a class="markdownIt-Anchor" href="#事务边界"></a> 事务边界</h4><p>在使用事务的时候，明确事务边界非常重要。对于声明式事务，例如，下面的register()方法：</p><pre><code class="highlight plaintext">@Componentpublic class UserService &#123;    @Transactional    public User register(String email, String password, String name) &#123; // 事务开始       ...    &#125; // 事务结束&#125;</code></pre><p>它的事务边界就是register()方法开始和结束。</p><p>类似的，一个负责给用户增加积分的addBonus()方法：</p><pre><code class="highlight plaintext">@Componentpublic class BonusService &#123;    @Transactional    public void addBonus(long userId, int bonus) &#123; // 事务开始       ...    &#125; // 事务结束&#125;</code></pre><p>它的事务边界就是addBonus()方法开始和结束。</p><p>在现实世界中，问题总是要复杂一点点。用户注册后，能自动获得100积分，因此，实际代码如下：</p><pre><code class="highlight plaintext">@Componentpublic class UserService &#123;    @Autowired    BonusService bonusService;    @Transactional    public User register(String email, String password, String name) &#123;        // 插入用户记录:        User user = jdbcTemplate.insert(&quot;...&quot;);        // 增加100积分:        bonusService.addBonus(user.id, 100);    &#125;&#125;</code></pre><p>现在问题来了：调用方（比如RegisterController）调用UserService.register()这个事务方法，它在内部又调用了BonusService.addBonus()这个事务方法，一共有几个事务？如果addBonus()抛出了异常需要回滚事务，register()方法的事务是否也要回滚？</p><h4 id="事务传播"><a class="markdownIt-Anchor" href="#事务传播"></a> 事务传播</h4><p>要解决上面的问题，我们首先要定义事务的传播模型。</p><p>假设用户注册的入口是RegisterController，它本身没有事务，仅仅是调用UserService.register()这个事务方法：</p><pre><code class="highlight plaintext">@Controllerpublic class RegisterController &#123;    @Autowired    UserService userService;    @PostMapping(&quot;/register&quot;)    public ModelAndView doRegister(HttpServletRequest req) &#123;        String email = req.getParameter(&quot;email&quot;);        String password = req.getParameter(&quot;password&quot;);        String name = req.getParameter(&quot;name&quot;);        User user = userService.register(email, password, name);        return ...    &#125;&#125;</code></pre><p>因此，UserService.register()这个事务方法的起始和结束，就是事务的范围。</p><p>我们需要关心的问题是，在UserService.register()这个事务方法内，调用BonusService.addBonus()，我们期待的事务行为是什么：</p><pre><code class="highlight plaintext">@Transactionalpublic User register(String email, String password, String name) &#123;    // 事务已开启:    User user = jdbcTemplate.insert(&quot;...&quot;);    // ???:    bonusService.addBonus(user.id, 100);&#125; // 事务结束</code></pre><p>对于大多数业务来说，我们期待BonusService.addBonus()的调用，和UserService.register()应当融合在一起，它的行为应该如下：</p><p>UserService.register()已经开启了一个事务，那么在内部调用BonusService.addBonus()时，BonusService.addBonus()方法就没必要再开启一个新事务，直接加入到BonusService.register()的事务里就好了。</p><p>其实就相当于：</p><ol><li>UserService.register()先执行了一条INSERT语句：INSERT INTO users …</li><li>BonusService.addBonus()再执行一条INSERT语句：INSERT INTO bonus …</li></ol><p>因此，Spring的声明式事务为事务传播定义了几个级别，<strong>默认传播级别就是REQUIRED</strong>，它的意思是，<strong>如果当前没有事务，就创建一个新事务，如果当前有事务，就加入到当前事务中执行</strong>。</p><p>我们观察UserService.register()方法，它在RegisterController中执行，因为RegisterController没有事务，因此，UserService.register()方法会自动创建一个新事务。</p><p>在UserService.register()方法内部，调用BonusService.addBonus()方法时，因为BonusService.addBonus()检测到当前已经有事务了，因此，它会加入到当前事务中执行。</p><p>因此，整个业务流程的事务边界就清晰了：它只有一个事务，并且范围就是UserService.register()方法。</p><p>有的童鞋会问：把BonusService.addBonus()方法的@Transactional去掉，变成一个普通方法，那不就规避了复杂的传播模型吗？</p><p>去掉BonusService.addBonus()方法的@Transactional，会引来另一个问题，即其他地方如果调用BonusService.addBonus()方法，那就没法保证事务了。例如，规定用户登录时积分+5：</p><pre><code class="highlight plaintext">@Controllerpublic class LoginController &#123;    @Autowired    BonusService bonusService;    @PostMapping(&quot;/login&quot;)    public ModelAndView doLogin(HttpServletRequest req) &#123;        User user = ...        bonusService.addBonus(user.id, 5);    &#125;&#125;</code></pre><p>可见，BonusService.addBonus()方法必须要有@Transactional，否则，登录后积分就无法添加了。</p><p>默认的事务传播级别是REQUIRED，它满足绝大部分的需求。还有一些其他的传播级别：</p><ul><li>SUPPORTS：表示如果有事务，就加入到当前事务，如果没有，那也不开启事务执行。这种传播级别可用于查询方法，因为SELECT语句既可以在事务内执行，也可以不需要事务；</li><li>MANDATORY：表示必须要存在当前事务并加入执行，否则将抛出异常。这种传播级别可用于核心更新逻辑，比如用户余额变更，它总是被其他事务方法调用，不能直接由非事务方法调用；</li><li>REQUIRES_NEW：表示不管当前有没有事务，都必须开启一个新的事务执行。如果当前已经有事务，那么当前事务会挂起，等新事务完成后，再恢复执行；</li><li>NOT_SUPPORTED：表示不支持事务，如果当前有事务，那么当前事务会挂起，等这个方法执行完成后，再恢复执行；</li><li>NEVER：和NOT_SUPPORTED相比，它不但不支持事务，而且在监测到当前有事务时，会抛出异常拒绝执行；</li><li>NESTED：表示如果当前有事务，则开启一个嵌套级别事务，如果当前没有事务，则开启一个新事务。</li></ul><p>定义事务的传播级别也是写在@Transactional注解里的：</p><pre><code class="highlight plaintext">@Transactional(propagation = Propagation.REQUIRES_NEW)public Product createProduct() &#123;    ...&#125;</code></pre><p>现在只剩最后一个问题了：Spring是如何传播事务的？</p><p>我们在JDBC中使用事务的时候，是这么个写法：</p><pre><code class="highlight plaintext">Connection conn = openConnection();try &#123;    // 关闭自动提交:    conn.setAutoCommit(false);    // 执行多条SQL语句:    insert(); update(); delete();    // 提交事务:    conn.commit();&#125; catch (SQLException e) &#123;    // 回滚事务:    conn.rollback();&#125; finally &#123;    conn.setAutoCommit(true);    conn.close();&#125;</code></pre><p>Spring使用声明式事务，最终也是通过执行JDBC事务来实现功能的，那么，一个事务方法，如何获知当前是否存在事务？</p><p>答案是使用ThreadLocal。Spring总是把JDBC相关的Connection和TransactionStatus实例绑定到ThreadLocal。如果一个事务方法从ThreadLocal未取到事务，那么它会打开一个新的JDBC连接，同时开启一个新的事务，否则，它就直接使用从ThreadLocal获取的JDBC连接以及TransactionStatus。</p><p>因此，事务能正确传播的前提是，方法调用是在一个线程内才行。如果像下面这样写：</p><pre><code class="highlight plaintext">@Transactionalpublic User register(String email, String password, String name) &#123; // BEGIN TX-A    User user = jdbcTemplate.insert(&quot;...&quot;);    new Thread(() -&gt; &#123;        // BEGIN TX-B:        bonusService.addBonus(user.id, 100);        // END TX-B    &#125;).start();&#125; // END TX-A</code></pre><p>在另一个线程中调用BonusService.addBonus()，它根本获取不到当前事务，因此，UserService.register()和BonusService.addBonus()两个方法，将分别开启两个完全独立的事务。</p><p>换句话说，事务只能在当前线程传播，无法跨线程传播。</p><p>那如果我们想实现跨线程传播事务呢？原理很简单，就是要想办法把当前线程绑定到ThreadLocal的Connection和TransactionStatus实例传递给新线程，但实现起来非常复杂，根据异常回滚更加复杂，不推荐自己去实现。</p>]]>
    </content>
    <id>http://example.com/2023/03/29/Spring_JDBC-%E4%BA%8B%E5%8A%A1/</id>
    <link href="http://example.com/2023/03/29/Spring_JDBC-%E4%BA%8B%E5%8A%A1/"/>
    <published>2023-03-29T04:00:00.000Z</published>
    <summary>Spring JDBC就是指spring自身对jdbc的代码进行了一些封装，使得使用更加的简单，方便，快捷。</summary>
    <title>Spring JDBC/事务</title>
    <updated>2026-02-26T09:22:10.910Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    <content>
      <![CDATA[<h1 id="spring-mvc"><a class="markdownIt-Anchor" href="#spring-mvc"></a> $Spring MVC</h1><h1 id="spring-mvc-2"><a class="markdownIt-Anchor" href="#spring-mvc-2"></a> Spring MVC</h1><ul><li><a href="">Spring MVC</a><ul><li><a href="">MVC简介</a><ul><li><a href="">MVC模式简介</a></li><li><a href="">什么是Spring MVC</a></li><li><a href="">核心组件/处理流程</a></li></ul></li><li><a href="">springMVC架构</a><ul><li><a href="">架构流程</a></li><li><a href="">组件说明</a></li><li><a href="">默认配置文件</a></li></ul></li><li><a href="">spring MVC应用</a><ul><li><a href="">搭建Spring Web MVC环境（IDEA）</a><ul><li><a href="">maven创建spring mvc项目</a></li><li><a href="">添加依赖的jar�</a>�</li></ul></li><li><a href="">Spring MVC配置文件</a></li><li><a href="">配置DispatcherServlet（web.xml）</a></li><li><a href="">编写处理器Handler（Controller）</a><ul><li><a href="">方式一（接口方式）</a></li><li><a href="">方式二（注解方式）</a></li></ul></li><li><a href="">创建视图</a><ul><li><a href="">ModelAndView组件</a><ul><li><a href="">Model和ModelMap</a></li><li><a href="">ModelAndView和Model的区别</a></li></ul></li><li><a href="">ViewResolver组件</a></li></ul></li><li><a href="">配置tomcat部署项目</a></li><li><a href="">设置引导页</a></li></ul></li><li><a href="">SpringMVC详解</a><ul><li><a href="">@RequestMapping注解</a><ul><li><a href="">属性</a><ul><li><a href="">value属性</a></li><li><a href="">methods/consumes/produces/params/headers/path属性</a></li></ul></li><li><a href="">@RequestMapping源码解析</a></li><li><a href="">@RequestMapping快捷方式</a></li></ul></li><li><a href="">@Controller注解应用</a></li><li><a href="">请求参数值绑定</a><ul><li><a href="">什么是请求参数绑定</a></li><li><a href="">默认支持的参数类型</a></li><li><a href="">直接绑定</a><ul><li><a href="">绑定基本类型</a></li><li><a href="">绑定pojo类型</a></li><li><a href="">绑定包装pojo</a></li><li><a href="">使用简单类型数组</a></li><li><a href="">使用pojo类型集合或者数组</a></li><li><a href="">自定义参数绑定</a></li></ul></li><li><a href="">注解绑定</a><ul><li><a href="">@RequestParam</a></li><li><a href="">@PathVariable</a></li><li><a href="">@RequestBody</a></li></ul></li><li><a href="">传参校验</a><ul><li><a href="">使用@Valid</a></li><li><a href="">自定义校验标签</a></li></ul></li><li><a href="">自定义参数绑定</a></li></ul></li><li><a href="">向页面传值</a><ul><li><a href="">1.使用request.setAttribute方法</a></li><li><a href="">2.ModeAndView对象</a></li><li><a href="">3.ModelMap参数</a></li><li><a href="">4.@ModelAttribute</a></li><li><a href="">5.Sessioin存储</a></li></ul></li><li><a href="">Controller返回值</a><ul><li><a href="">不用注解修饰</a><ul><li><a href="">返回ModelAndView</a></li><li><a href="">返回void</a></li><li><a href="">返回字符串（推荐）</a><ul><li><a href="">逻辑视图名</a></li><li><a href="">redirect重定向</a></li><li><a href="">forward转发</a></li></ul></li></ul></li><li><a href="">使用注解修饰@ResponseBody</a><ul><li><a href="">@RestController</a></li></ul></li></ul></li><li><a href="">@ControllerAdvice</a><ul><li><a href="">@ExceptionHandler</a></li><li><a href="">@InitBinder</a><ul><li><a href="">防止XSS注入</a></li></ul></li><li><a href="">@ModelAttribute</a></li></ul></li><li><a href="">bmi健康指数案例</a></li></ul></li><li><a href="">集成Filter</a></li><li><a href="">使用Interceptor</a><ul><li><a href="">处理异常</a></li></ul></li><li><a href="">处理CORS</a><ul><li><a href="">使用@CrossOrigin</a></li><li><a href="">使用CorsRegistry</a></li><li><a href="">使用CorsFilter</a></li></ul></li><li><a href="">异步处理</a><ul><li><a href="">Filter处理</a></li></ul></li><li><a href="">使用WebSocket</a><ul><li><a href="">处理WebSocket连接</a></li><li><a href="">客户端开发</a></li></ul></li><li><a href="">使用Scheduler</a><ul><li><a href="">使用Cron任务</a></li><li><a href="">集成Quarz</a></li></ul></li><li><a href="">Spring MVC源码解析</a><ul><li><a href="">知识储备</a><ul><li><a href="">Servlet的生命周期方法</a></li><li><a href="">DispatcherServlet继承体系</a></li><li><a href="">InitializingBean接口介绍</a></li></ul></li><li><a href="">主流程DispatcherServlet</a></li><li><a href="">处理器映射器</a></li><li><a href="">处理器适配器</a></li><li><a href="">视图解析器</a></li><li><a href="">mvc:annotation-driver</a></li><li><a href="">异常处理流程</a></li><li><a href="">文件上传流程</a></li></ul></li></ul></li><li><a href="">SSM整合</a><ul><li><a href="">系统分层</a><ul><li><a href="">如何分层</a><ul><li><a href="">表现层</a></li><li><a href="">业务层Service</a></li><li><a href="">持久层DAO</a></li></ul></li></ul></li><li><a href="">SSM框架整合</a><ul><li><a href="">整合思路</a></li><li><a href="">工程搭建（maven依赖）</a></li><li><a href="">工程整合（配置文件）</a><ul><li><a href="">web.xml</a></li><li><a href="">整合mapper</a></li><li><a href="">整合Service</a></li><li><a href="">整合controller</a></li></ul></li><li><a href="">整合测试（编写代码）</a><ul><li><a href="">数据库</a></li><li><a href="">持久层</a><ul><li><a href="">pojo</a></li><li><a href="">mapper</a></li></ul></li><li><a href="">业务层</a></li><li><a href="">表现层</a></li></ul></li></ul></li><li><a href="">实战技巧</a><ul><li><a href="">中文乱码解决方案</a><ul><li><a href="">数据库乱码</a></li><li><a href="">解决get乱码</a></li><li><a href="">解决post乱码</a></li><li><a href="">jsp乱码</a></li><li><a href="">@responsebody 乱码</a></li><li><a href="">html页面编码</a></li></ul></li><li><a href="">拦截器</a><ul><li><a href="">什么是拦截器</a></li><li><a href="">如何写一个拦截器</a></li><li><a href="">定义拦截器（实现登陆检查）</a><ul><li><a href="">先定义拦截器</a></li><li><a href="">配置拦截器</a></li></ul></li><li><a href="">session验证案例</a><ul><li><a href="">Controller</a></li><li><a href="">定义与配置拦截器</a></li></ul></li></ul></li><li><a href="">异常处理</a><ul><li><a href="">异常概念</a></li><li><a href="">异常处理思路</a></li><li><a href="">使用SimpleMappingExceptionResolver</a></li><li><a href="">实现HandlerExceptionResolver接口自定义异常处理器</a></li><li><a href="">@ExceptionHandler注解实现异常处理</a></li><li><a href="">@ResponseStatus</a></li><li><a href="">对于框架内部异常或代码无法捕获的异常</a></li></ul></li><li><a href="">文件上�</a>�<ul><li><a href="">SpringMVC文件上传简介</a></li><li><a href="">CommonsMultipartResolver组件</a></li><li><a href="">实现步骤</a></li><li><a href="">限制文件上传类型</a></li></ul></li><li><a href="">文件下载</a></li><li><a href="">JSON数据交互</a><ul><li><a href="">kv/json</a></li><li><a href="">json/json</a></li></ul></li><li><a href="">Mock测试（模拟测试）</a><ul><li><a href="">Mock各模块介绍</a></li><li><a href="">MockMVC使用</a></li></ul></li><li><a href="">RESTful支持</a><ul><li><a href="">介绍</a></li><li><a href="">springMVC对RESTful的支持</a></li><li><a href="">静态资源访问``</a></li></ul></li><li><a href="">SpringMVC父子容器</a></li><li><a href="">跨域处理</a><ul><li><a href="">CORS</a></li><li><a href="">CORS请求分类</a><ul><li><a href="">简单请求</a></li><li><a href="">非简单请求</a></li></ul></li><li><a href="">CORS实现</a><ul><li><a href="">跨域提交Cookie</a></li><li><a href="">跨域提交Cookie</a></li></ul></li></ul></li><li><a href="">@PathVariable和@RequestParam的区别</a></li></ul></li></ul></li></ul><h2 id="mvc简介"><a class="markdownIt-Anchor" href="#mvc简介"></a> MVC简介</h2><h3 id="mvc模式简介"><a class="markdownIt-Anchor" href="#mvc模式简介"></a> MVC模式简介</h3><p>是一种用于设计创建web应用程序表现层的模式</p><ul><li>M-<strong>Model</strong>模型<ul><li>模型（Model）的职责是负责业务逻辑，模型包含业务模型和数据模型，数据模型用于封装数据，业务模型用于处理业务</li></ul></li><li>V-<strong>View</strong>视图<ul><li>视图（View）的职责是负责显示界面和用户交互（手机用户信息），属于视图的组件是不包含业务逻辑和控制逻辑的JSP</li></ul></li><li>C-<strong>Controller</strong>控制器<ul><li>控制器是模型层M和视图层V之间的桥梁，用于控制流程，比如：在Servlet项目中的单一控制器ActionServlet</li><li>是应用程序中处理用户交互的部分。作用一般就是处理程序逻辑的</li></ul></li><li><h2 id="关系图"><a class="markdownIt-Anchor" href="#关系图"></a> 关系图</h2></li></ul><h3 id="什么是spring-mvc"><a class="markdownIt-Anchor" href="#什么是spring-mvc"></a> 什么是Spring MVC</h3><ul><li>Spring MVC是Spring框架一个非常重要的功能模块，实现了MVC结构，便于简单，快速开发MVC结构的Web程序，Spring Web MVC提供的API封装了Web开发中常用的功能，简化了Web过程。</li><li>springMVC是为了解决表现层问题的web框架，他们都是基于MVC设计模式的，表现层的主要职责就是处理前端HTTP请求</li><li></li></ul><p><strong>优点</strong></p><ul><li>轻量</li><li>高效</li><li>与spring兼容好</li><li>功能强大</li><li>简洁灵活</li></ul><p><strong>功能</strong></p><p>清晰的角色划分</p><ul><li>控制器（controller）、验证器（validator）、 命令对象（command object）、表单对象（form object）、模型对象（model object）、 Servlet分发器（DispatcherServlet）、 处理器映射（handler mapping）、视图解析器（view resolver）等等。 每一个角色都可以由一个专门的对象来实现</li></ul><p>强大而直接的配置方式</p><ul><li>将框架类和应用程序类都能作为JavaBean配置，支持跨多个context的引用，例如，在web控制器中对业务对象和验证器（validator）的引用</li></ul><p>可适配，非侵入</p><ul><li>可以根据不同的应用常见，选择合适的控制器子类（simple型、command型、form型、wizard型、multi-action型或者自定义），而不是从单一控制器 （比如Action/ActionForm）继承</li></ul><p>可重用的业务代码</p><ul><li>可以使用现有的业务对象作为命令或表单对象，而不需要去扩展某个特定框架的基类</li></ul><p>可定制的绑定（binding） 和验证（validation）</p><ul><li>比如将类型不匹配作为应用级的验证错误， 这可以保存错误的值。再比如本地化的日期和数字绑定等等。在其他某些框架中，你只能使用字符串表单对象， 需要手动解析它并转换到业务对象</li></ul><p>可定制的handler mapping和view resolution</p><ul><li>Spring提供从最简单的URL映射， 到复杂的、专用的定制策略。与某些web MVC框架强制开发人员使用单一特定技术相比，Spring显得更加灵活</li></ul><p>灵活的model转换</p><ul><li>在Springweb框架中，使用基于Map的 键/值对来达到轻易地与各种视图技术的集成</li></ul><p>可定制的本地化和主题（theme）解析</p><ul><li>支持在JSP中可选择地使用Spring标签库、支持JSTL、支持Velocity（不需要额外的中间层）等等</li></ul><p>简单而强大的JSP标签库（Spring Tag Library）</p><ul><li>支持包括诸如数据绑定和主题（theme） 之类的许多功能。它提供在标记方面的最大灵活性</li></ul><p>JSP表单标签库</p><ul><li>在Spring2.0中引入的表单标签库，使得在JSP中编写 表单更加容易</li></ul><p>Spring Bean的生命周期可以被限制在当前的HTTP Request或者HTTP Session</p><ul><li>准确的说，这并非Spring MVC框架本身特性，而应归属于Sping MVC使用的WebApplicationContext容器。</li></ul><h3 id="核心组件处理流程"><a class="markdownIt-Anchor" href="#核心组件处理流程"></a> 核心组件/处理流程</h3><p><strong>核心组件</strong></p><ul><li><strong>DispatcherServlet</strong>（前端控制器，请求入口）<ul><li>接受请求，依据HandlerMapping的配置调用相应的模型来处理</li></ul></li><li><strong>HandlerMapping</strong>（控制器，请求派发）<ul><li>包含了请求路劲与模型的对应关系</li></ul></li><li><strong>Controller</strong>（处理器，请求处理流程）<ul><li>负责处理业务逻辑</li></ul></li><li><strong>ModelAndView</strong>（模型，封装业务处理结果和视图）<ul><li>封装了处理结果</li><li>注：处理结果除了数据之外，可能还有视图名</li></ul></li><li><strong>ViewResolver</strong>（视图解析器，视图显示处理器）<ul><li>DispatcherServlet依据ViewResolver的解析，调用真正的视图对象来生成相应的页面</li></ul></li></ul><p><strong>处理流程</strong></p><ul><li>浏览器向Spring发出请求，请求交给前端控制器<strong>DispatcherServlet</strong>通过<strong>HandlerMapping</strong>找到<strong>Controller</strong>组件处理请求</li><li>执行<strong>Controller</strong>组件约定方法处理请求，在约定方法调用模型组件完成业务处理，约定方法可以返回一个<strong>ModelAndView</strong>对象，封装了处理结果数据和视图名称信息</li><li><strong>DispatcherServlet</strong>控制器接受<strong>ModelAndView</strong>之后，调用<strong>ViewResolver</strong>组件，定位View(JSP)并传递数据信息，生成响应界面结果</li><li></li><li></li></ul><h2 id="springmvc架构"><a class="markdownIt-Anchor" href="#springmvc架构"></a> springMVC架构</h2><p>springMVC是基于MVC设计模式的，MVC模式指的就是Model(业务模型)，View(视图)，Controller(控制器)。SpringMVC处理请求就是通过MVC这三种角色实现的</p><p>不过千万不要把<strong>MVC设计模式</strong>和<strong>工程的三层结构</strong>混淆，三层结构指的是<strong>表现层</strong>，<strong>业务层</strong>，<strong>数据持久层</strong>；而MVC只针对<strong>表现层</strong>进行设计</p><h3 id="架构流程"><a class="markdownIt-Anchor" href="#架构流程"></a> 架构流程</h3><ol><li>用户发送请求至前端控制器DispatcherServlet</li><li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li><li>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li><li>DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</li><li>HandlerAdapter执行处理器(handler，也叫后端控制器)。</li><li>Controller执行完成返回ModelAndView</li><li>HandlerAdapter将handler执行结果ModelAndView返回给DispatcherServlet</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li><li>ViewReslover解析后返回具体View对象</li><li>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</li><li>DispatcherServlet响应用户</li></ol><h3 id="组件说明"><a class="markdownIt-Anchor" href="#组件说明"></a> 组件说明</h3><p><strong>DispatcherServlet</strong>：前端控制器</p><ul><li>用户请求到达前端控制器，它就相当于mvc模式中的C，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</li></ul><p><strong>HandlerMapping</strong>：处理器映射器</p><ul><li>HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</li></ul><p><strong>Handler</strong>：处理器</p><ul><li>Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。</li><li>由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</li></ul><p><strong>HandlAdapter</strong>：处理器适配器</p><ul><li>通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行</li></ul><p><strong>View Resolver</strong>：视图解析器</p><ul><li>View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。</li></ul><p><strong>View</strong>：视图</p><ul><li>springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。</li><li>一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面</li></ul><blockquote><p>说明：在springmvc的各个组件中，<strong>处理器映射器、处理器适配器、视图解析器</strong>称为springmvc的三大组件。</p></blockquote><blockquote><p>需要用户开发的组件有：处理器、视图</p></blockquote><h3 id="默认配置文件"><a class="markdownIt-Anchor" href="#默认配置文件"></a> 默认配置文件</h3><p>spring-webmvc-xxx.jar包中有一个DispatcherServlet.properties文件，该配置中默认加载了一些springmvc默认的其他组件，其中就包括三大组件</p><h2 id="spring-mvc应用"><a class="markdownIt-Anchor" href="#spring-mvc应用"></a> spring MVC应用</h2><h3 id="搭建spring-web-mvc环境idea"><a class="markdownIt-Anchor" href="#搭建spring-web-mvc环境idea"></a> 搭建Spring Web MVC环境（IDEA）</h3><h5 id="maven创建spring-mvc项目"><a class="markdownIt-Anchor" href="#maven创建spring-mvc项目"></a> maven创建spring mvc项目</h5><ul><li><p>在Idea中新建Maven项目，选择“org.apache.maven.archetypes:maven-archetype-webapp”骨架（模板），创建一个Web项目</p></li><li><p>输入项目的坐标</p></li><li><p>选择仓库位置与配置信息，建议使用默认设置（先使用IDEA的默认设置将Maven配置好）</p></li><li><p>输出项目位置，点完成</p></li><li><p>初始化的项目如下</p></li><li><p>根据Maven规范，需要创建源代码、资源与测试目录</p></li><li><p>在main上右键创建java目录、resources目录，创建与main平级的test测试目录：</p></li><li><p>设置目录的特殊属性</p></li><li><p>设置完成后的结果</p></li></ul><h5 id="添加依赖的jar包"><a class="markdownIt-Anchor" href="#添加依赖的jar包"></a> 添加依赖的jar包</h5><ul><li>导入Spring Web MVC相关开发包，主要有Spring框架核心库，Spring MVC，JSTL等<ul><li>pom.xml</li></ul></li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;com.zhangguo.springmvc01&lt;/groupId&gt;  &lt;artifactId&gt;SpringMVC01&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;  &lt;name&gt;SpringMVC01 Maven Webapp&lt;/name&gt;  &lt;!-- FIXME change it to the project&#x27;s website --&gt;  &lt;url&gt;http://www.example.com&lt;/url&gt;  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;    &lt;spring.version&gt;4.3.0.RELEASE&lt;/spring.version&gt;  &lt;/properties&gt;  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;4.11&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!--Spring框架核心库 --&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- Spring MVC --&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Servlet核心--&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;      &lt;version&gt;3.0.1&lt;/version&gt;      &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- JSTL --&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;jstl&lt;/artifactId&gt;      &lt;version&gt;1.2&lt;/version&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;build&gt;    &lt;finalName&gt;SpringMVC01&lt;/finalName&gt;    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;      &lt;plugins&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;          &lt;version&gt;3.0.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;          &lt;version&gt;3.0.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;          &lt;version&gt;3.7.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;          &lt;version&gt;2.20.1&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;          &lt;version&gt;3.2.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;          &lt;version&gt;2.5.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;          &lt;version&gt;2.8.2&lt;/version&gt;        &lt;/plugin&gt;      &lt;/plugins&gt;    &lt;/pluginManagement&gt;  &lt;/build&gt;&lt;/project&gt;</code></pre><p><strong>详细版pom依赖</strong></p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.lee&lt;/groupId&gt;    &lt;artifactId&gt;springmvcDemo&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;name&gt;springmvcDemo Maven Webapp&lt;/name&gt;    &lt;!-- FIXME change it to the project&#x27;s website --&gt;    &lt;url&gt;http://www.example.com&lt;/url&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;    &lt;/properties&gt;    &lt;!-- 持久层：mysql驱动、dbcp连接池、mybatis、mybatis和spring整合依赖、spring依赖 --&gt; &lt;!-- 业务层：aop相关依赖 --&gt;    &lt;dependencies&gt;        &lt;!-- spring ioc组件需要的依赖包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 基于AspectJ的aop依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;aopalliance&lt;/groupId&gt;            &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;            &lt;version&gt;1.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- spring 事务管理和JDBC依赖包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- spring 单元测试组件包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 单元测试Junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- mysql数据库驱动包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.35&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- dbcp连接池的依赖包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;            &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;            &lt;version&gt;1.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- mybatis依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.5&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- mybatis和spring的整合依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;1.3.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--spring mvc依赖包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--Servlet核心--&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;            &lt;version&gt;2.5&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- JSTL --&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;jstl&lt;/artifactId&gt;            &lt;version&gt;1.2&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;finalName&gt;springmvcDemo&lt;/finalName&gt;        &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;            &lt;plugins&gt;                &lt;!-- 配置Maven的JDK编译级别 --&gt;                &lt;plugin&gt;                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                    &lt;version&gt;3.2&lt;/version&gt;                    &lt;configuration&gt;                        &lt;source&gt;1.8&lt;/source&gt;                        &lt;target&gt;1.8&lt;/target&gt;                        &lt;encoding&gt;UTF-8&lt;/encoding&gt;                    &lt;/configuration&gt;                &lt;/plugin&gt;&lt;!--                &amp;lt;!&amp;ndash; 配置Tomcat插件 &amp;ndash;&amp;gt;--&gt;&lt;!--                &lt;plugin&gt;--&gt;&lt;!--                    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;--&gt;&lt;!--                    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;--&gt;&lt;!--                    &lt;version&gt;2.2&lt;/version&gt;--&gt;&lt;!--                    &lt;configuration&gt;--&gt;&lt;!--                        &lt;port&gt;8080&lt;/port&gt;--&gt;&lt;!--                        &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt;--&gt;&lt;!--                    &lt;/configuration&gt;--&gt;&lt;!--                &lt;/plugin&gt;--&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;                    &lt;version&gt;3.1.0&lt;/version&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;                    &lt;version&gt;3.0.2&lt;/version&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                    &lt;version&gt;3.8.0&lt;/version&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;                    &lt;version&gt;2.22.1&lt;/version&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;                    &lt;version&gt;3.2.2&lt;/version&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;                    &lt;version&gt;2.5.2&lt;/version&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;                    &lt;version&gt;2.8.2&lt;/version&gt;                &lt;/plugin&gt;            &lt;/plugins&gt;        &lt;/pluginManagement&gt;        &lt;!--maven默认不加载xml非resources目录下的xml文件，Mapper文件就无法加载，所以得加上如下配置--&gt;        &lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/java&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;/includes&gt;                &lt;filtering&gt;true&lt;/filtering&gt;            &lt;/resource&gt;        &lt;/resources&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><h3 id="spring-mvc配置文件"><a class="markdownIt-Anchor" href="#spring-mvc配置文件"></a> Spring MVC配置文件</h3><p>不配置 <code>&lt;mvc:annotation-driven/&gt;</code>也可以正常使用@RequestMapping注解的原因是，spring-webmvc-xxx.jar包中有一个DispatcherServlet.properties文件，该配置中默认加载了一些springmvc默认的其他组件，其中就包括三大组件<strong>HandlerMapping,HandlerAdapter,ViewResolver</strong></p><ul><li>在resource下添加Spring的XML配置文件<ul><li>名称可自定义，例如spring-mvc.xml</li></ul></li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;!--配置注解扫描,多个包中间使用半角逗号分隔 --&gt;    &lt;context:component-scan base-package=&quot;com.lee.controller&quot;/&gt;    &lt;!-- Spring MVC不处理静态资源 --&gt;    &lt;mvc:default-servlet-handler /&gt;    &lt;!--在spring中一般采用@RequestMapping注解来完成映射关系， 要想使@RequestMapping注解生效必须向上下文中注册DefaultAnnotationHandlerMapping和一个AnnotationMethodHandlerAdapter 实例，这两个实例分别在类级别和方法级别处理。而annotation-driven配置帮助我们自动完成上述两个实例的注入。--&gt;    &lt;!--配置注解的适配器和映射器，同时还注入了其他很多的bean--&gt;    &lt;mvc:annotation-driven/&gt;    &lt;!-- 视图解析器（该解析器不配置也会默认加载，但是自己配置的话可以注入自定义配置）--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;          id=&quot;internalResourceViewResolver&quot;&gt;        &lt;!-- 前缀 --&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/item/&quot;/&gt;        &lt;!-- 后缀 --&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><blockquote><p>视图解析器中我们把所有的视图都放在/WEB-INF/目录下，这样是为了视图安全，因为这个目录用户端不能直接访问</p></blockquote><hr /><p><strong>mvc:annotation-drivern</strong>标签的作用，详见AnnotationDrivenBeanDefinitionParser类的parse方法。</p><p>分析得知：mvc:annotation-drivern往spring容器中注册了以下的一些BeanDefinition：</p><p><strong>RequestMappingHandlerMapping</strong>：注解式处理器映射器，对类中标记@ResquestMapping的方法进行映射，根据ResquestMapping定义的url匹配ResquestMapping标记的方法，匹配成功返回HandlerMethod对象给前端控制器，HandlerMethod对象中封装url对应的方法Method。</p><p><strong>RequestMappingHandlerAdapter</strong>：注解式处理器适配器，对标记@ResquestMapping的方法进行适配</p><pre><code class="highlight plaintext">&lt;!--注解映射器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;&lt;!--注解适配器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;&lt;!--替换上面两句--&gt;&lt;mvc:annotation-driven/&gt;</code></pre><blockquote><p>springmvc.xml配置文件中使用<code>&lt;mvc:annotation-driven/&gt;</code>标签替代bean标签配置的注解处理器和适配器</p></blockquote><h3 id="配置dispatcherservletwebxml"><a class="markdownIt-Anchor" href="#配置dispatcherservletwebxml"></a> 配置DispatcherServlet（web.xml）</h3><ul><li>Spring MVC框架像许多其他MVC框架一样, 请求驱动,围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。如下图所示当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者</li><li></li><li>在web.xml中配置DispatcherServlet前端控制器组件<ul><li>DispatcherServlet组件在spring mvc中已提供，只需配置即可</li><li>配置DispatcherServlet时，同时指定xml配置文件</li></ul></li></ul><pre><code class="highlight plaintext">&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;!--配置前端控制器--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;!--设置spring配置文件路径--&gt;    &lt;!--如果不设置初始化参数，那么DispatcherServlet会读取默认路径下的配置文件--&gt;    &lt;!--默认配置文件路径：/WEB-INF/springmvc-servlet.xml--&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;!--指定初始化日期，设置为2，表示tomcat启动时，DispatcherServlet会跟随着初始化--&gt;    &lt;!--如果未指定初始化日期，DispatcherServlet就会在第一次请求的时候，才会初始化，而且只会被初始化一次--&gt;    &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;!--url-pattern的配置--&gt;    &lt;!--不要配置为/*，否则会报错（因为它拦截了jsp请求但是不会去处理）--&gt;    &lt;!--通俗解释：/*会拦截整个项目中的资源访问，包含jsp和静态资源的访问，对于静态资源的访问springMVC提供了默认的handler处理器--&gt;    &lt;!--但是对于jsp来讲，springMVC没有提供默认的处理器，我们也没有手动编写对应的处理器，此时按照springMVC的处理流程分析得知，它短路了--&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p><strong>url-pattern匹配顺序详解</strong></p><p><strong>web.xml配置内容的加载顺序</strong></p><h3 id="编写处理器handlercontroller"><a class="markdownIt-Anchor" href="#编写处理器handlercontroller"></a> 编写处理器Handler（Controller）</h3><p>处理器开发方式有多种：实现HttpRequestHandler接口、实现Controller接口、<strong>注解方式</strong>等。</p><h4 id="方式一接口方式"><a class="markdownIt-Anchor" href="#方式一接口方式"></a> <s>方式一（接口方式）</s></h4><p>不推荐使用</p><p><strong>1 HandlerMapping组件（映射器）</strong></p><ul><li>通过handlerMapping组件，DispatcherServlet控制器可以将客户HTTP请求映射到Controller组件上</li><li><strong>SimpleUrlHandlerMapping</strong><ul><li>维护一个HTTP请求和Controller映射关系表（map）,根据列表对应关系调用Controller</li></ul></li></ul><pre><code class="highlight plaintext">       &lt;!-- 配置HandlerMapping --&gt;       &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;             &lt;property name=&quot;mappings&quot;&gt;                    &lt;props&gt;                           &lt;prop key=&quot;/hello.do&quot;&gt;helloController&lt;/prop&gt;                    &lt;/props&gt;             &lt;/property&gt;       &lt;/bean&gt;       &lt;!-- 配置处理器，这里的id要和上面的prop中的值相等，才能调用 --&gt;       &lt;bean id=&quot;helloController&quot; class=&quot;controller.HelloController&quot;&gt;&lt;/bean&gt;</code></pre><ul><li><strong>RequestMappingHandlerMapping</strong></li><li><strong>RequestMappingHandlerAdapter</strong><ul><li>在Controller类和方法上使用@RequestMapping注解指定对应的客户HTTP请求</li></ul></li></ul><p><strong>2 Controller组件（处理器）</strong></p><ul><li>实现Controller有两种方法<ol><li>实现Controller接口,重写handleRequest方法</li><li>使用@Controller定义控制器</li></ol></li><li>Controller组件负责执行具体的业务逻辑，可以调用DAO等组件，编写时需要实现Controller接口及约定的方法</li></ul><blockquote><p>这是一种比较古老的方式，缺点是：一个控制器中只有一个Action，如果要多个Action，则需要定义多个Controller，定义方式比较麻烦，推荐<strong>使用注解的方法</strong></p></blockquote><pre><code class="highlight plaintext">public class HelloController implements Controller&#123;    public ModelAndView handleRequest(HttpServletRequest req,HttpServletResponse res) throws Exception&#123;        System.out.println(&quot;hello spring!&quot;);                     /*              * ModelAndView有两个构造器              *     1.ModelAndView(String viewName)              *     viewName就是视图名              *  2.ModelAndView(String viewName,Map date)              *     map用于封装处理结果的数据              */         return new ModelAndView(&quot;hello&quot;);//下一个ppt    &#125;&#125;</code></pre><h4 id="方式二注解方式"><a class="markdownIt-Anchor" href="#方式二注解方式"></a> 方式二（注解方式）</h4><p><strong>@Controller注解</strong>：在类上添加该注解，指定该类为一个请求处理器，不需要实现任何接口或者继承任何类。</p><p><strong>@RequestMapping注解</strong>：在方法上添加该注解，指定请求的url由该方法处理。其中“.do”可以加也可以不加。</p><p>处理器的返回值是ModelAndView对象，该对象的具体理解如下：</p><p><strong>ModelAndView</strong>：方法返回值对象，该对象包含两个功能：一个是将数据存储到Request域中，一个是设置响应视图，比如将视图设置为“/WEB-INF/jsp/itemList.jsp”</p><pre><code class="highlight plaintext">package com.lee.controller;import com.lee.pojo.Item;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpSession;import java.util.ArrayList;import java.util.List;@Controllerpublic class ItemController &#123;    //@RequestMapping此时填写的是URL    //ModelAndView表示的是数据模型，view就是最终要展示给用户的视图    @RequestMapping(&quot;queryItem&quot;)    public ModelAndView queryItem(HttpSession session)&#123;        List&lt;Item&gt; items = new ArrayList&lt;Item&gt;();        items.add(new Item(&quot;联想笔记本&quot;, (float) 5000,&quot;ThinkPad T430 联想笔记本电脑&quot;));        items.add(new Item(&quot;苹果手机&quot;, (float) 8000,&quot;iPhone 11 苹果手机&quot;));        System.out.println(items.get(0));        System.out.println(items.get(1));        ModelAndView modelAndView = new ModelAndView();        //设置数据模型，相当于request的setAttrbute方法，实质上，底层也确实是转成了request        //先将k/v数据放入map中，最终根据视图对象不同，在进行后续处理        modelAndView.addObject(&quot;itemList&quot;,items);        //设置视图（逻辑路径）        modelAndView.setViewName(&quot;item-list&quot;);        return modelAndView;    &#125;&#125;</code></pre><blockquote><p>注解为@<strong>Controller</strong>是为了让Spring IOC容器初始化时自动扫描到；@<strong>RequestMapping</strong>是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/hello/hi；方法中声明Model类型的参数是为了把Action中的数据带到视图中；方法返回的结果是<strong>视图的名称</strong>hi，加上配置文件中的前后缀变成WEB-INF/view/hi.jsp</p></blockquote><p>pojo类</p><pre><code class="highlight plaintext">package com.lee.pojo;import java.util.Date;public class Item &#123;    private Integer id;    private String name;    private Float price;    private String pic;    private Date createtime;    private String detail;    public Item(String name,Float price,String detail)&#123;        this.id = 1;        this.name = name;        this.price = price;        this.pic = &quot;哈哈&quot;;        this.createtime = new Date();        this.detail = detail;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Float getPrice() &#123;        return price;    &#125;    public void setPrice(Float price) &#123;        this.price = price;    &#125;    public String getPic() &#123;        return pic;    &#125;    public void setPic(String pic) &#123;        this.pic = pic;    &#125;    public Date getCreatetime() &#123;        return createtime;    &#125;    public void setCreatetime(Date createtime) &#123;        this.createtime = createtime;    &#125;    public String getDetail() &#123;        return detail;    &#125;    public void setDetail(String detail) &#123;        this.detail = detail;    &#125;    public String toString() &#123;        return &quot;Item&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +                &quot;, price=&quot; + price +                &quot;, pic=&#x27;&quot; + pic + &#x27;\&#x27;&#x27; +                &quot;, createtime=&quot; + createtime +                &quot;, detail=&#x27;&quot; + detail + &#x27;\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;</code></pre><h3 id="创建视图"><a class="markdownIt-Anchor" href="#创建视图"></a> 创建视图</h3><ul><li>在WEB-INF/view目录中创建视图，hi.jsp视图将从Action中带回的信息展示，具体内容如下：</li></ul><p><strong>一定要注意加上<code>&lt;%@page isELIgnored=&quot;false&quot;%&gt;</code>，否则$符号无法使用</strong></p><pre><code class="highlight plaintext">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot; %&gt;&lt;%@page isELIgnored=&quot;false&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;查询商品列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath &#125;/itemList.do&quot; method=&quot;post&quot;&gt;    查询条件：    &lt;table width=&quot;100%&quot; border=1&gt;        &lt;tr&gt;            &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;查询&quot;/&gt;&lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;    商品列表：    &lt;table width=&quot;100%&quot; border=1&gt;        &lt;tr&gt;            &lt;td&gt;商品名称&lt;/td&gt;            &lt;td&gt;商品价格&lt;/td&gt;            &lt;td&gt;生产日期&lt;/td&gt;            &lt;td&gt;商品描述&lt;/td&gt;            &lt;td&gt;操作&lt;/td&gt;        &lt;/tr&gt;        &lt;c:forEach items=&quot;$&#123;itemList&#125;&quot; var=&quot;item&quot;&gt;            &lt;tr&gt;                &lt;td&gt;$&#123;item.name&#125;&lt;/td&gt;                &lt;td&gt;$&#123;item.price&#125;&lt;/td&gt;                &lt;td&gt;&lt;fmt:formatDate value=&quot;$&#123;item.createtime&#125;&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&lt;/td&gt;                &lt;td&gt;$&#123;item.detail&#125;&lt;/td&gt;                &lt;td&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/itemEdit.do?id=$&#123;item.id&#125;&quot;&gt;修改&lt;/a&gt;&lt;/td&gt;            &lt;/tr&gt;        &lt;/c:forEach&gt;    &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="modelandview组件"><a class="markdownIt-Anchor" href="#modelandview组件"></a> ModelAndView组件</h4><ul><li>Controller组件约定的handleRequest方法执行后返回一个ModelAndView对象，该对象可封装模型数据和视图名响应信息，ModelAndView构造器如下<ul><li><code>ModelAndView(String viewName)</code></li><li><code>ModelAndView(String viewName,Map model)</code></li></ul></li><li>viewName是jsp页面名字</li><li>model的数据存储到request的attribute中</li></ul><pre><code class="highlight plaintext">@RequestMapping(&quot;listCategory&quot;)public ModelAndView listCategory() &#123;     //创建一个模型视图对象     ModelAndView mav = new ModelAndView();     //获取到查询的数据     List&lt;Category&gt; cs= categoryService.list();     //将数据放置到ModelAndView对象view中,第二个参数可以是任何java类型     mav.addObject(&quot;cs&quot;, cs);     // 放入jsp路径 ，或者可以new的时候直接绑定路径    mav.setViewName(&quot;listCategory&quot;);     //返回ModelAndView对象mav     return mav; &#125;</code></pre><p><strong>JSP取值</strong></p><pre><code class="highlight plaintext">&lt;!-- 使用c标签库，循环遍历出数据 ，命名为c--&gt; &lt;c:forEach items=&quot;$&#123;cs&#125;&quot; var=&quot;c&quot; varStatus=&quot;st&quot;&gt;     &lt;tr&gt;         &lt;td&gt;$&#123;c.id&#125;&lt;/td&gt;         &lt;td&gt;$&#123;c.name&#125;&lt;/td&gt;     &lt;/tr&gt;&lt;/c:forEach&gt;</code></pre><h5 id="model和modelmap"><a class="markdownIt-Anchor" href="#model和modelmap"></a> Model和ModelMap</h5><p>ModelMap对象主要用于传递控制方法处理数据到结果页面，也就是说我们把结果页面上需要的数据放到ModelMap对象中即可；</p><p>他的作用类似于request对象的setAttribute方法的作用: 用来在一个请求过程中传递处理的数据。</p><p>ModelMap或者Model通过<code>addAttribute</code>方法向页面传递参数.</p><p>然后在jsp页面上可以通过el表达式语言$attributeName或者是C标签库下的方法，来获取并展示modelmap中的数据。</p><p><strong>modelmap本身不能设置页面跳转的url地址别名或者物理跳转地址</strong>.</p><p>那么我们可以通过控制器方法的字符串返回值来设置跳转url地址别名或者物理跳转地址</p><pre><code class="highlight plaintext">@RequestMapping(value=&quot;/list-books&quot;)private String getAllBooks(Model model)&#123;    logger.error(&quot;/list-books&quot;);    List&lt;Book&gt; books= bookService.getAllBooks();    //绑定数据，相当于request.setAttribute()    //在jsp页面利$&#123;books&#125;即可取出其中的值    model.addAttribute(&quot;books&quot;, books);    //返回视图名，即BookList.jsp，这个要看自己具体配置    return &quot;BookList&quot;;&#125;</code></pre><blockquote><p>在jsp页面利<code>$&#123;books&#125;</code>即可取出其中的值</p></blockquote><h5 id="modelandview和model的区别"><a class="markdownIt-Anchor" href="#modelandview和model的区别"></a> ModelAndView和Model的区别</h5><p><strong>Model</strong>是每次请求中都存在的默认参数，利用其addAttribute()方法即可将服务器的值传递到jsp页面中；</p><p><strong>ModelAndView</strong>包含model和view两部分，使用时需要自己实例化，利用ModelMap用来传值，也可以设置view的名称，ModelAndView的实例是需要我们手动new的，这也是和ModelMap的一个区别</p><p>而且，ModelAndView 可以自己寻址，只需要return 返回其对象即可</p><h4 id="viewresolver组件"><a class="markdownIt-Anchor" href="#viewresolver组件"></a> ViewResolver组件</h4><ul><li>所有Controller组件都返回一个ModelAndView实例，封装了视图名，spring中的视图以名字为标识，视图解析器ViewResolver通过名字来解析视图</li><li>Spring提供了多种视图解析器<blockquote><p><strong>UrlBasedViewResolver</strong> <code>将视图名直接解析成对应的URL，不需要显示的映射定义，如果你的视图名和视图资源的名字是一致的，就可以使用该解释器，而无须进行映射</code></p><p><strong>InternalResourceViewResolver</strong> <code>UrlBasedViewResolver的子类，它支持InternalResourceView（对Servlet和JSP的包装），以及其子类JstlView和TilesView响应类型</code></p><p><strong>XmlViewResolver</strong> <code>支持用XML文件定义具体的响应视图文件</code></p><p><strong>VelocityViewResolver/FreeMarkerViewResolver</strong><code>UrlBasedViewResolver的子类，他能支持Velocity和FreeMarker等视图技术</code></p></blockquote></li><li><strong>InternalResourceViewResolver使用实例如下</strong></li></ul><pre><code class="highlight plaintext">       &lt;!-- 配置ViewResolver视图解析器 --&gt;       &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;             &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot;&gt;&lt;/property&gt;             &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;       &lt;/bean&gt;</code></pre><blockquote><p>如：视图名hello<code>（即new ModelAndView(&quot;hello&quot;)中的参数）</code>通过以上配置可以映射到/WEB-INF/jsp/hello.jsp</p></blockquote><h3 id="配置tomcat部署项目"><a class="markdownIt-Anchor" href="#配置tomcat部署项目"></a> 配置tomcat部署项目</h3><ul><li><p>点击右上角的Edit Configurations添加对tomcat的配置</p></li><li><p>添加对tomcat的配置，设置名称，添加Deployment</p></li><li><p>可以设置context也可以没有，类似虚拟目录</p></li></ul><h3 id="设置引导页"><a class="markdownIt-Anchor" href="#设置引导页"></a> 设置引导页</h3><ul><li>使用了spring mvc如果想直接访问控制器下的某个action为引导页，可以通过如下方式实现：<br /><strong>方法一</strong></li><li>删除index.jsp默认引导文件</li><li>定义以下Home控制器，如下所示</li></ul><pre><code class="highlight plaintext">package com.zhangguo.springmvc01.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;/**控制器*/@Controller@RequestMapping(&quot;/&quot;)public class HomeController &#123;    /**动作，action*/    @RequestMapping(&quot;&quot;)    public String index(Model model)&#123;        //向模型中添加属性msg与值，将与页面模板渲染后输出        model.addAttribute(&quot;msg&quot;,&quot;Welcome my website!&quot;);        return &quot;hi&quot;;    &#125;&#125;</code></pre><p><strong>方法二</strong></p><ul><li>修改Spring MVC配置文件，增加如下配置：</li></ul><pre><code class="highlight plaintext">&lt;!--此标签用以在springMVC配置文件中实现路径的转发和资源的请求--&gt;&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;redirect:/hello/&quot;&gt;&lt;/mvc:view-controller&gt;</code></pre><pre><code class="highlight plaintext">package com.zhangguo.springmvc01.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;/**控制器*/@Controller@RequestMapping(&quot;/hello&quot;)public class HelloController &#123;    /**动作，action*/    @RequestMapping(&quot;/hi&quot;)    public String hi(Model model)&#123;        //向模型中添加属性msg与值，将与页面模板渲染后输出        model.addAttribute(&quot;msg&quot;,&quot;Hello Spring MVC!&quot;);        return &quot;hi&quot;;    &#125;    /**动作，action*/    @RequestMapping(&quot;&quot;)    public String index(Model model)&#123;        //向模型中添加属性msg与值，将与页面模板渲染后输出        model.addAttribute(&quot;msg&quot;,&quot;Index Page!&quot;);        return &quot;hi&quot;;    &#125;&#125;</code></pre><blockquote><p>注意这种方法是使用的重定向方式，需发起两次请求，尽量转发</p></blockquote><h2 id="springmvc详解"><a class="markdownIt-Anchor" href="#springmvc详解"></a> SpringMVC详解</h2><ul><li>导包</li><li>添加spring的配置文件</li><li>配置DispatcherServlet</li><li>写Controller</li><li>写jsp</li><li>在spring配置文件中，添加如下配置<ul><li>a.组件扫描</li><li>b.mvc注解扫描</li><li>c.视图解析器</li><li></li></ul></li></ul><h3 id="requestmapping注解"><a class="markdownIt-Anchor" href="#requestmapping注解"></a> @RequestMapping注解</h3><p><strong>spring.xml定义</strong></p><ul><li>开启@RequestMapping注解映射，需要在Spring的xml配置文件中定义<strong>RequestMappingHandlerMapping</strong>（注解映射器）和<strong>RequestMappingHandlerAdapter</strong>（注解适配器）两个bean组件</li></ul><pre><code class="highlight plaintext">Spring 3.1版本之前需要定义&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;Spring3.2之后可以使用下面xml简化配置&lt;mvc:annotation-driven/&gt;</code></pre><h4 id="属性"><a class="markdownIt-Anchor" href="#属性"></a> 属性</h4><h5 id="value属性"><a class="markdownIt-Anchor" href="#value属性"></a> value属性</h5><p><strong>基础用法</strong></p><ul><li>@RequestMapping可以用在类定义和方法定义上<ul><li><strong>用在类上</strong>：表示类中的所有响应请求的方法都是以该地址作为父路径，通过此种方法对url进行分类管理</li><li><strong>用在方法上</strong>：URL路径映射</li></ul></li><li>@RequestMapping表明这个<strong>类</strong>或<strong>方法</strong>与哪一个客户请求想对应</li><li><strong>方法名不作要求，返回类型可以是ModelAndview，也可以是String</strong></li><li>当@<strong>RequestMapping为空</strong>时<ul><li>注解在方法时，表示该方法为类下默认的action</li><li>注解在类上时，可表示项目的起始页</li></ul></li></ul><pre><code class="highlight plaintext">/* * 如何写一个处理器： * 1.不用实现Controller接口 * 2.可以在处理器类当中，添加多个方法，每一个方法处理一种类型的请求 * 3.方法名不作要求，返回类型可以是ModelAndview，也可以是String * 4.使用@Controler，将该处理器纳入容器进行管理（也就是说，spring配置文件不用配置该处理器了） * 5.使用@RequestMapping，告诉前端控制器（DispatcherServlet），请求路径与处理器的方法对应关系（spring配置文件不用配置HandlerMapping了） *  */@Controller@RequestMapping(&quot;/login&quot;)//@RequestMapping(value=&#123;&quot;/item&quot;,&quot;/item2&quot;&#125;)public class HelloController &#123;       @RequestMapping(&quot;/hello.do&quot;)                                                                                        // http://localhost:8080/srpingmvc02/login/hello.do       public String hello() &#123;             System.out.println(&quot;hello()&quot;);             return &quot;hello&quot;;       &#125;@RequestMapping(&quot;/toLogin.do&quot;)        // //http://localhost:8080/srpingmvc02/login/toLogin.do        public String toLogin()&#123;            System.out.println(&quot;toLogin()&quot;);            return &quot;login&quot;;            &#125;            @RequestMapping   //http://localhost:8087/SpringMVC02/login    public String action2(Model model)&#123;        //在模型中添加属性message值为action2，渲染页面时使用        model.addAttribute(&quot;message&quot;, &quot;action2&quot;);        return &quot;foo/index&quot;;    &#125;</code></pre><p><strong>路径变量占位URL模板模式</strong></p><ul><li>可以使用@<strong>PathVariable</strong>注释方法参数的值绑定到一个URL模板变量</li></ul><pre><code class="highlight plaintext">@RequestMapping(&quot;/action3/&#123;p1&#125;/&#123;p2&#125;&quot;)    public String action3(@PathVariable int p1,@PathVariable int p2,Model model)&#123;        model.addAttribute(&quot;message&quot;, p1+p2);        return &quot;foo/index&quot;;    &#125;</code></pre><blockquote><p>使用路径变量的<strong>好处</strong>：使路径变得更加简洁；获得参数更加方便，框架会自动进行类型转换。通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到action，如这里访问是的路径是/action3/1/a，则路径与方法不匹配，而不会是参数转换失败</p></blockquote><p><strong>正则表达式模式的URL模板</strong></p><ul><li>案例要求id必须为6位数字，name必须位3位小写字母</li></ul><pre><code class="highlight plaintext">@RequestMapping(value=&quot;/action4/&#123;id:\\d&#123;6&#125;&#125;-&#123;name:[a-z]&#123;3&#125;&#125;&quot;)    public String action4(@PathVariable int id,@PathVariable String name,Model model)&#123;        model.addAttribute(&quot;message&quot;, &quot;id:&quot;+id+&quot; name:&quot;+name);        return &quot;foo/index&quot;;    &#125;</code></pre><p><strong>矩阵变量@MatrixVariable</strong></p><ul><li>矩阵变量可以出现在任何路径段,每个矩阵变量用“;”分隔。例如:“/汽车;颜色=红;年=2012”。多个值可以是“,”分隔“颜色=红、绿、蓝”或变量名称可以重复“颜色=红;颜色=绿色;颜色=蓝”，如下所示：</li><li>案例1</li></ul><pre><code class="highlight plaintext">// GET /pets/42;q=11;r=22    @RequestMapping(value = &quot;/pets/&#123;petId&#125;&quot;)    public void findPet(@PathVariable String petId, @MatrixVariable int q) &#123;        // petId == 42        // q == 11    &#125;</code></pre><ul><li>案例2</li></ul><pre><code class="highlight plaintext">// 矩阵变量    @RequestMapping(value = &quot;/action5/&#123;name&#125;&quot;)    public String action5(Model model,             @PathVariable String name,   //路径变量，用于获得路径中的变量name的值            @MatrixVariable String r,            @MatrixVariable(required = true) String g,  //参数g是必须的            @MatrixVariable(defaultValue = &quot;99&quot;, required = false) String b) &#123;  //参数b不是必须的，默认值是99        model.addAttribute(&quot;message&quot;, name + &quot; is #&quot; + r + g + b);        return &quot;foo/index&quot;;    &#125;    //Get http://localhost:8087/SpringMVC02/action5/the%20book%20color;r=33;g=66    //the book color is #336699</code></pre><ul><li>默认时不允许使用矩阵变量的，需要设置配置文中的RequestMappingHandlerMapping的属性removeSemicolonContent为false；在annotation-driven中增加属性enable-matrix-variables=“true”，修改后的springmvc-servlet.xml文件如下：</li></ul><pre><code class="highlight plaintext">&lt;!-- 支持mvc注解驱动 --&gt;    &lt;mvc:annotation-driven enable-matrix-variables=&quot;true&quot; /&gt;    &lt;!-- 配置映射媒体类型的策略 --&gt;    &lt;bean        class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;&gt;        &lt;property name=&quot;removeSemicolonContent&quot; value=&quot;false&quot; /&gt;    &lt;/bean&gt;</code></pre><p><strong>Ant风格路径模式</strong></p><ul><li></li><li></li><li></li><li>@RequestMapping注解也支持ant风格的路径模式，如/myPath/<em>.do，/owners/</em>/pets/{petId}，示例代码如下：</li></ul><pre><code class="highlight plaintext">//http://localhost:8080/SpringMVC02/action6/ant.do//Ant风格路径模式    @RequestMapping(value = &quot;/action6/*.do&quot;)    public String action6(Model model)&#123;         model.addAttribute(&quot;message&quot;,&quot;Ant风格路径模式&quot;);        return &quot;foo/index&quot;;    &#125;</code></pre><p><strong>处理多个URI</strong></p><ul><li>你可以将多个请求映射到一个方法上去，只需要添加一个带有请求路径值列表的 @RequestMapping 注解就行了</li></ul><pre><code class="highlight plaintext">@RestController  @RequestMapping(&quot;/home&quot;)  public class IndexController &#123;        @RequestMapping(value = &#123;&quot;&quot;,&quot;/page&quot;,&quot;page*&quot;,  &quot;view/*&quot;,&quot;**/msg&quot;&#125;)      String indexMultipleMapping() &#123;          return &quot;Hello from index multiple mapping.&quot;;      &#125;  &#125;可以匹配路径localhost:8080/homelocalhost:8080/home/localhost:8080/home/pagelocalhost:8080/home/pageabclocalhost:8080/home/view/localhost:8080/home/view/view</code></pre><h5 id="methodsconsumesproducesparamsheaderspath属性"><a class="markdownIt-Anchor" href="#methodsconsumesproducesparamsheaderspath属性"></a> methods/consumes/produces/params/headers/path属性</h5><p><strong>method属性指定请求类型</strong></p><ul><li>用于约束请求的谓词类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE，如下代码所示：</li></ul><pre><code class="highlight plaintext">//谓词类型    @RequestMapping(value = &quot;/action6&quot;,method=&#123;RequestMethod.POST,RequestMethod.DELETE&#125;)    public String action6(Model model) &#123;        model.addAttribute(&quot;message&quot;, &quot;请求谓词只能是POST与DELETE&quot;);        return &quot;foo/index&quot;;    &#125;</code></pre><p><strong>consumes属性指定请求的Content-Type</strong></p><ul><li>@RequestMapping 注解的 produces 和 consumes 这两个元素来缩小请求映射类型的范围，达到处理生产和消费对象的目的</li><li>指定处理请求的提交内容类型（Content-Type），例如application/json, text/html，收窄请求范围，<strong>如果用户发送的请求内容类型不匹配则方法不会响应请求</strong>，具体使用如下代码所示：</li></ul><pre><code class="highlight plaintext">package com.zhangguo.springmvc02.controllers;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;/home&quot;)public class HomeController &#123;    // 请求内容类型必须为text/html，注意浏览器默认没有指定Content-type    @RequestMapping(value = &quot;/action8&quot;,consumes=&quot;text/html&quot;)    public String action8(Model model) &#123;        model.addAttribute(&quot;message&quot;, &quot;请求的提交内容类型（Content-Type）是text/html&quot;);        return &quot;foo/index&quot;;    &#125;&#125;</code></pre><blockquote><p>注意：可以使用！号，如consumes=“!text/html”</p></blockquote><p><strong>produces属性指定响应的Content-Type</strong></p><ul><li>设置响应体包头中的<strong>Content-Type</strong>属性，常用<strong>来解决乱码</strong></li><li>指定返回的内容类型，<strong>仅当request请求头中的(Accept)类型中包含该指定类型才返回</strong>(请求头中的Accept指明浏览器能接受的类型)，方法才处理客户端的请求否则会报406错误，常用设置如下：<ul><li>produces = “text/plain”  //客户端只接收纯文本</li><li>produces = {“text/plain”, “application/*”}   //客户端接收纯文本与application/*类型的内容</li><li>produces = “application/json; charset=UTF-8”  <strong>设置响应体中Content-Type</strong></li></ul></li></ul><pre><code class="highlight plaintext">//设置响应体的包头中Content-Type设置为application/json；charset=utf-8    @RequestMapping(value = &quot;/action9&quot;,produces=&quot;application/json; charset=UTF-8&quot;)    public String action9(Model model) &#123;        model.addAttribute(&quot;message&quot;, &quot;客户端可以接收的类型是application/json; charset=UTF-8&quot;);        return &quot;foo/index&quot;;    &#125;</code></pre><blockquote><p>注意：可以使用！号，如produces=“!text/html”</p></blockquote><p><strong>params属性指定请求中必须有特定参数与值</strong></p><ul><li>映射请求的参数，收窄请求范围。可以限制客户端发送到服务器的请求参数为某些特定值或不为某些值，如下代码所示</li><li>代码中我们用@RequestMapping 的params 属性指定了三个参数，这些参数都是针对请求参数而言的，它们分别表示参数param1 的值必须等于value1 ，参数param2 必须存在，值无所谓，参数param3 必须不存在，只有当请求/testParams.do 并且满足指定的三个参数条件的时候才能访问到该方法。所以当请求/testParams.do?param1=value1&amp;param2=value2 的时候能够正确访问到该testParams 方法，当请求/testParams.do?param1=value1&amp;param2=value2&amp;param3=value3 的时候就不能够正常的访问到该方法，因为在@RequestMapping 的params 参数里面指定了参数param3 是不能存在的</li></ul><pre><code class="highlight plaintext">@RequestMapping (value= &quot;testParams&quot; , params=&#123; &quot;param1=value1&quot; , &quot;param2&quot; , &quot;!param3&quot; &#125;)  public String testParams() &#123;     System. out .println( &quot;test Params...........&quot; );     return &quot;testParams&quot; ;  &#125;</code></pre><p><strong>headers属性指定请求中必须有特定header值</strong></p><ul><li>映射请求头部，收窄请求范围。约束客户端发送的请求头部信息中必须包含某个特定的值或不包含某个值，作用范围明显大于前面讲过的几种，示例代码如下：</li></ul><pre><code class="highlight plaintext">@RequestMapping (value= &quot;testHeaders&quot; , headers=&#123; &quot;host=localhost&quot; , &quot;Accept&quot; &#125;)  public String testHeaders() &#123;  return &quot;headers&quot; ;  &#125;</code></pre><blockquote><p>这里同样可以使用！号；可以使用通配符如：Content-Type=“application/*”</p></blockquote><p><strong>path属性指定路径</strong></p><ul><li>源码</li></ul><pre><code class="highlight plaintext">@AliasFor(&quot;path&quot;)String[] value() default &#123;&#125;;@AliasFor(&quot;value&quot;)String[] path() default &#123;&#125;;</code></pre><ul><li>从Spring 4.2开始引入了@AliasFor注解，可以实现属性的别名，如value本身并没有特定的含义，而path会更加具体，能见名知义，通俗说可以认为<strong>两者使用过程中是一样的</strong><ul><li>@RequestMapping(“/foo”)} 与 @RequestMapping(path=“/foo”)相同</li></ul></li></ul><h4 id="requestmapping源码解析"><a class="markdownIt-Anchor" href="#requestmapping源码解析"></a> @RequestMapping源码解析</h4><pre><code class="highlight plaintext">package org.springframework.web.bind.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.util.concurrent.Callable;import org.springframework.core.annotation.AliasFor;/** * 用于映射url到控制器类或一个特定的处理程序方法. *///该注解只能用于方法或类型上@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Mappingpublic @interface RequestMapping &#123;    /**     * 指定映射的名称     */    String name() default &quot;&quot;;    /**     * 指定请求的路径映射，指定的地址可以是uri模板,别名为path     */    @AliasFor(&quot;path&quot;)    String[] value() default &#123;&#125;;    /** 别名为value，使用path更加形象     * 只有用在一个Servlet环境：路径映射URI（例如“/myPath.do”）。     * Ant风格的路径模式，同时也支持（例如，“/myPath/*.do”）。在方法层面，在主要的映射在类型级别表示相对路径（例如，“edit.do”）     * 的支持。路径映射的URI可能包含占位符（例如“/$ &#123;&#125;连接”）     */    @AliasFor(&quot;value&quot;)    String[] path() default &#123;&#125;;    /**     * 指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE. 收窄请求范围 The     * HTTP request methods to map to, narrowing the primary mapping: GET, POST,     * HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE.     */    RequestMethod[] method() default &#123;&#125;;    /**     * 映射请求的参数，收窄请求范围 The parameters of the mapped request, narrowing the     * primary mapping.     */    String[]params() default &#123;&#125;;    /**     * 映射请求头部，收窄请求范围 The headers of the mapped request, narrowing the primary     * mapping. RequestMapping(value = &quot;/something&quot;, headers =     * &quot;content-type=text/*&quot;)     */    String[] headers() default &#123;&#125;;    /**     * 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html，收窄请求范围 The     * consumable media types of the mapped request, narrowing the primary     * mapping.     */    String[] consumes() default &#123;&#125;;    /**     * 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回 The producible media types     * of the mapped request, narrowing the primary mapping. produces =     * &quot;text/plain&quot; produces = &#123;&quot;text/plain&quot;, &quot;application/*&quot;&#125; produces =     * &quot;application/json; charset=UTF-8&quot;     */    String[] produces() default &#123;&#125;;&#125;</code></pre><blockquote><p>从上面的源码可以发现除了name基本都是数组类型，在设置时我们可以指定单个值，如@RequestMapping(value=“/foo”)；也可以同时指定多个值如：@RequestMapping(value={“/foo”,“/bar”})</p></blockquote><h4 id="requestmapping快捷方式"><a class="markdownIt-Anchor" href="#requestmapping快捷方式"></a> @RequestMapping快捷方式</h4><ul><li>Spring 4.3 引入了方法级注解的变体，也被叫做 @RequestMapping 的组合注解。组合注解可以更好的表达被注解方法的语义。它们所扮演的角色就是针对 @RequestMapping 的封装，而且成了定义端点的标准方法。</li><li>例如，@GetMapping 是一个组合注解，它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。</li></ul><pre><code class="highlight plaintext">@GetMapping@PostMapping@PutMapping@DeleteMapping@PatchMappin例如@RequestMapping(value = &quot;/action3&quot;,method = RequestMethod.GET)等价于@GetMapping(&quot;/action3&quot;)</code></pre><h3 id="controller注解应用"><a class="markdownIt-Anchor" href="#controller注解应用"></a> @Controller注解应用</h3><ul><li>推荐使用@Controller注解声明Controller组件，这样可以使得Controller定义更加灵活，可以不用实现Controller接口，请求处理的方法也可以灵活定义</li></ul><pre><code class="highlight plaintext">@Controller@RequestMapping(&quot;/day01&quot;)public class HelloController&#123;    @RequestMapping(&quot;/hello.form&quot;)    public String execute() throws Exception&#123;        return &quot;hello&quot;;    &#125;&#125;</code></pre><ul><li>为了使@Controller注解生效，需要在Spring的XML配置文件中开启组件扫描定义，并指定Controller组件所在的包</li></ul><pre><code class="highlight plaintext">&lt;context:component-scan base-package=&quot;com.tarena.controller&quot;/&gt;</code></pre><h3 id="请求参数值绑定"><a class="markdownIt-Anchor" href="#请求参数值绑定"></a> 请求参数值绑定</h3><h4 id="什么是请求参数绑定"><a class="markdownIt-Anchor" href="#什么是请求参数绑定"></a> 什么是请求参数绑定</h4><p><strong>请求参数格式</strong></p><ul><li>默认是<strong>key/value</strong>格式，比如：<a href="http://XXXXX?id=1&amp;type=301">http://XXXXX?id=1&amp;type=301</a></li></ul><p><strong>请求参数值的数据类型</strong></p><ul><li>都是<strong>字符串</strong>类型的各种值</li></ul><p><strong>请求参数值要绑定的目标类型</strong></p><ul><li><strong>controller类中的方法参数</strong>，比如简单类型，pojo类型，集合类型等</li></ul><p><strong>springMVC内置的参数解析组件</strong></p><ul><li>默认内置了<strong>24种</strong>参数解析组件（ArgumentResolver）</li></ul><p><strong>什么是参数绑定？</strong></p><ul><li>就是将请求参数串中的<strong>value值获取到之后</strong>，再进行<strong>类型转换</strong>，然后将转换后的值<strong>赋值给controller类中方法的形参</strong>，这个过程就是参数绑定</li></ul><h4 id="默认支持的参数类型"><a class="markdownIt-Anchor" href="#默认支持的参数类型"></a> 默认支持的参数类型</h4><p>Controller方法<strong>形参</strong>中可以<strong>随时添加如下类型的参数</strong>，处理适配器会自动识别并进行赋值。</p><hr /><p><strong>HttpServlet</strong></p><p>主要包括HttpServletRequest 、HttpServletResponse 和HttpSession 对象。 这些参数Spring 在调用处理器方法的时候会自动给它们赋值，所以当在处理器方法中需要使用到这些对象的时候，可以直接在方法上给定一个方法参数的申明，然后在方法体里面直接用就可以了。但是有一点需要注意的是在使用HttpSession 对象的时候，如果此时HttpSession 对象还没有建立起来的话就会有问题</p><ul><li><strong>HttpServletRequest</strong>：通过request对象获取请求信息</li></ul><pre><code class="highlight plaintext">@RequestMapping(&quot;/login-action1.form&quot;) public String checkLogin1(HttpServletRequest req)&#123;     String name = req.getParameter(&quot;name&quot;);&#125;</code></pre><ul><li><strong>HttpServletResponse</strong>：通过response处理响应信息</li><li><strong>HttpSession</strong>：通过session对象得到session中存放的对象</li></ul><hr /><p><strong>Spring 自己的WebRequest 对象</strong></p><p>使用该对象可以访问到存放在HttpServletRequest 和HttpSession 中的属性值。</p><hr /><p><strong>使用@PathVariable 、@RequestParam 、@CookieValue 和@RequestHeader 标记的参数</strong></p><hr /><p><strong>使用@ModelAttribute 标记的参数</strong></p><hr /><p><strong>java.util.Map 、Spring 封装的Model 和ModelMap</strong></p><p>这些都可以用来封装模型数据，用来给视图做展示。</p><ul><li>ModelMap继承自LinkedHashMap，Model是一个接口，它们的底层实现都是同一个类（BindingAwareModelMap），作用就是向页面传递数据，相当于Request的作用，如下：</li></ul><pre><code class="highlight plaintext">//调用service查询商品信息Item item = service.queryItemById(id);model.addAttribute(&quot;item&quot;, item);</code></pre><hr /><p><strong>InputStream、OutputStream</strong>，<strong>Reader、Writer</strong></p><p>InputStream 和Reader 是针对HttpServletRequest 而言的，可以从里面取数据；OutputStream 和Writer 是针对HttpServletResponse 而言的，可以往里面写数据。</p><hr /><p><strong>实体类</strong></p><p>可以用来接收上传的参数</p><hr /><p><strong>Spring 封装的MultipartFile</strong></p><p>用来接收上传文件的</p><hr /><p><strong>Spring 封装的Errors 和BindingResult 对象</strong></p><p>这两个对象参数必须紧接在需要验证的实体对象参数之后，它里面包含了实体对象的验证结果</p><h4 id="直接绑定"><a class="markdownIt-Anchor" href="#直接绑定"></a> 直接绑定</h4><h5 id="绑定基本类型"><a class="markdownIt-Anchor" href="#绑定基本类型"></a> 绑定基本类型</h5><p><strong>使用要求</strong></p><p>http请求参数的<strong>key</strong>和controller方法的<strong>形参名称</strong>一致</p><p><strong>请求url</strong></p><p>请求参数的key为id</p><pre><code class="highlight plaintext">http://localhost:8080/xxx/findItem?id=1</code></pre><p><strong>controller方法</strong></p><p>controller的形参为inteeger id，他和请求参数的key一致，所以直接绑定成功</p><pre><code class="highlight plaintext">@RequestMapping(value = &quot;/findItem&quot;)public String findItem(Integer id) &#123;     System.out.println(&quot;接收到的请求参数是：&quot;+ id);    return &quot;success&quot;;&#125;</code></pre><h5 id="绑定pojo类型"><a class="markdownIt-Anchor" href="#绑定pojo类型"></a> 绑定pojo类型</h5><p><strong>使用要求</strong></p><p>控制器的方法的参数类型是pojo类型</p><p>要求表单中<strong>参数名称</strong>和pojo类的<strong>属性名称</strong>保持一致</p><p>使用自动机制封装成实体参数实例</p><ul><li>在Controller组件处理方法定义User类型参数</li><li>Spring会自动把请求参数封装new为User类型传入</li></ul><pre><code class="highlight plaintext">@RequestMapping(&quot;/login-action3.form&quot;)public String checkLogin3(User user)&#123;    System.out.println(user.getName());    System.out.println(user.getPwd());    User u = userService.login(user.getName(),user.getPwd());    //...    return &quot;success&quot;;&#125;</code></pre><p><strong>请求url</strong></p><pre><code class="highlight plaintext">http://localhost:8080/xxx/updateItem?id=1&amp;name=iphone&amp;price=1000</code></pre><p><strong>controller方法</strong></p><ul><li><p>pojo定义</p></li><li><p>controller方法</p></li></ul><pre><code class="highlight plaintext">@RequestMapping(&quot;/updateItem&quot;)public String updateItem(Integer id,Item item) &#123; System.out.println(&quot;接收到的请求参数是：&quot;+ id); System.out.println(&quot;接收到的请求参数是：&quot;+ item);return &quot;success&quot;;&#125;</code></pre><h5 id="绑定包装pojo"><a class="markdownIt-Anchor" href="#绑定包装pojo"></a> 绑定包装pojo</h5><p><strong>包装pojo类</strong>，依然是一个pojo类，将POJO中包含另一个pojo的这种类，称之为包装pojo</p><p><strong>包装对象</strong></p><pre><code class="highlight plaintext">public class ItemQueryVO &#123;//商品信息private Item item;&#125;</code></pre><p><strong>页面定义</strong></p><pre><code class="highlight plaintext">&lt;table width=&quot;100%&quot; border=1&gt;&lt;tr&gt;&lt;td&gt;商品名称：&lt;input type=&quot;text&quot; name=&quot;item.name&quot; /&gt;&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;查询&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</code></pre><p><strong>controller方法</strong></p><h5 id="使用简单类型数组"><a class="markdownIt-Anchor" href="#使用简单类型数组"></a> 使用简单类型数组</h5><p><strong>使用要求</strong></p><p>通过HTTP请求<strong>批量传递简单类型数据</strong>的情况，Controller方法中可以用<strong>String</strong>[]或者<strong>pojo的String[]属性</strong>接收（两种方式任选其一），但是<strong>不能使用集合</strong>接收。</p><p><strong>请求url</strong></p><pre><code class="highlight plaintext">http://localhost:8080/xxx/deleteItem?id=1&amp;id=2&amp;id=3</code></pre><p><strong>controller方法</strong></p><p>数组类型一定要和url参数类型一致</p><pre><code class="highlight plaintext">@RequestMapping(&quot;/deleteItem&quot;)public String deleteitem(Integer[] Id)&#123;return &quot;success&quot;;&#125;</code></pre><h5 id="使用pojo类型集合或者数组"><a class="markdownIt-Anchor" href="#使用pojo类型集合或者数组"></a> 使用pojo类型集合或者数组</h5><p><strong>使用要求</strong></p><p>批量传递的请求参数，最终要使用List<POJO>来接收，那么这个List<POJO>必须放在<strong>另一个POJO类中</strong></p><p><strong>接受商品列表的pojo</strong></p><pre><code class="highlight plaintext">public class ItemQueryVO &#123;// 商品信息private Item item;// 其他信息// 商品信息集合private List&lt;Item&gt; itemList;&#125;</code></pre><p><strong>请求URL</strong></p><pre><code class="highlight plaintext">http://localhost:8080/xxx/batchUpdateItem?itemList[0].id=1&amp; itemList[0].name=iphone&amp; itemList[0].price=1000&amp;itemList[1].id=2&amp; itemList[1].name=iphone x&amp; itemList[1].price=2000</code></pre><p><strong>controller</strong></p><pre><code class="highlight plaintext">@RequestMapping(&quot;/batchUpdateItem&quot;)public String batchUpdateItem(ItemQueryVO vo) &#123;return &quot;success&quot;;&#125;</code></pre><h5 id="自定义参数绑定"><a class="markdownIt-Anchor" href="#自定义参数绑定"></a> 自定义参数绑定</h5><p><strong>请求url</strong></p><pre><code class="highlight plaintext">http://localhost:8080/xxx/saveItem?date=2018-08-12</code></pre><p><strong>controller</strong></p><pre><code class="highlight plaintext">@RequestMapping(&quot;/saveItem&quot;)public String saveItem(String date)&#123;System.out.println(&quot;接收到的请求参数是：&quot;+ date);return &quot;success&quot;;&#125;</code></pre><blockquote><p>但是如果将data参数的类型由string改为date，则报错</p></blockquote><p><strong>自定义Converter</strong></p><pre><code class="highlight plaintext">public class DateConverter implements Converter&lt;String, Date&gt; &#123;@Overridepublic Date convert(String source) &#123;SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);try &#123;return simpleDateFormat.parse(source);&#125; catch (ParseException e) &#123;e.printStackTrace();&#125;return null;&#125;&#125;</code></pre><p><strong>配置Converter</strong></p><p>在springmvc.xml文件中添加如下代码</p><pre><code class="highlight plaintext">&lt;!-- 加载注解驱动 --&gt;&lt;!--处理器适配器会去调用conversionService--&gt;&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt;&lt;!-- 转换器配置（配置自定义转换器） --&gt;&lt;bean id=&quot;conversionService&quot;class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;&lt;property name=&quot;converters&quot;&gt;&lt;set&gt;&lt;bean class=&quot;com.kkb.ssm.controller.converter.DateConverter&quot;/&gt;&lt;/set&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h4 id="注解绑定"><a class="markdownIt-Anchor" href="#注解绑定"></a> 注解绑定</h4><h5 id="requestparam"><a class="markdownIt-Anchor" href="#requestparam"></a> @RequestParam</h5><hr /><p>@RequestParam注解只适用与Key/Value的http请求，即浏览器默认的表单类型（如果为json，xml等类型，不可以使用）</p><p>@RequestParam用来处理  <strong>Content-Type  为  application/x-www-form-urlencoded</strong>  编码的内容， Content-Type 默认为该属性</p><p>@RequestParam也可用于其它类型的请求，例如：POST、DELETE等请求。比如向表中插入单条数据</p><p>@RequestParam(value)相当于<code>Request.getParameter(请求参数key)</code></p><blockquote><p>@RequestParam不支持批量插入数据，如果改用  json  字符串来传值的话，类型设置为  application/json ，点击发送的话，会报错，后台接收不到值，为null</p></blockquote><blockquote><p>如果参数前写了@RequestParam(xxx)，那么前端必须有对应的xxx名字才行(不管其是否有值，当然可以通过设置该注解的required属性来调节是否必须传)，如果没有xxx名的话，那么请求会出错，报400</p></blockquote><blockquote><p>这里与feign消费服务时不同；feign消费服务时，如果参数前什么也不写，那么会被默认是@RequestBody的</p></blockquote><hr /><p><strong>使用要求</strong></p><p>请求参数的key和controller方法的形参名称不一致时，需要使用@<strong>RequestParam注解</strong>才能将请求参数绑定成功</p><ul><li><strong>value</strong>：参数名字，即入参的请求参数名字，如value=“itemid”表示请求的参数中的名字为itemid的参数的值将传入；</li><li><strong>required</strong>：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报；<code>TTP Status 400 - Required Integer parameter 'XXXX' is not present</code></li><li><strong>defaultValue</strong>：默认值，表示如果请求中没有同名参数时的默认值</li></ul><p><strong>请求url</strong></p><p>请求参数的id为itemid=1</p><pre><code class="highlight plaintext">http://localhost:8080/xxx/findItem?itemid=1</code></pre><p><strong>controller方法</strong></p><p>Controller的形参为Integer id,它和请求的参数不一致，要使用@RequestParam注解才能绑定成功</p><pre><code class="highlight plaintext"> @RequestMapping(value = &quot;/findItem&quot;)// 通过@RequestParam注解绑定简单类型// 学习@RequestParam注解中的value、required、defaultValue属性public String findItem (@RequestParam(value = &quot;itemid&quot;, required = true, defaultValue = &quot;2&quot;) Integer id) &#123; System.out.println(&quot;接收到的请求参数是：&quot;+ id);  return &quot;success&quot;;&#125;</code></pre><h5 id="pathvariable"><a class="markdownIt-Anchor" href="#pathvariable"></a> @PathVariable</h5><p>@PathVariable只适用于参数再URL路径的绑定情况</p><p>通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过@PathVariable(“xxx“) 绑定到操作方法的入参中</p><pre><code class="highlight plaintext">@RequestMapping(value = &quot;/hosts/pushInstallClient/&#123;id&#125;&quot;, method = RequestMethod.PUT, consumes = &quot;application/json&quot;)//@PathVariable直接接收url中的参数值public void pushInstallClient(@PathVariable(&quot;id&quot;) int id, HttpServletRequest request) &#123;        System.out.println(id);&#125;</code></pre><h5 id="requestbody"><a class="markdownIt-Anchor" href="#requestbody"></a> @RequestBody</h5><p>注解用于将Controller的方法参数，根据HTTP Request Header的content-Type的内容,<strong>通过适当的HttpMessageConverter转换为JAVA类</strong></p><p>@RequestBody只适用与参数在请求体body中，并且请求体数据为json/xml类型的情况（注：框架将json对象转换为Java对象，<strong>故参数必须为引用类型对象</strong>）</p><p>注解@RequestBody接收的参数是来自requestBody中，即请求体。一般用于处理非  Content-Type: application/x-www-form-urlencoded 编码格式的数据，比如： application/json 、 application/xml 等类型的数据</p><p>就 application/json 类型的数据而言，使用注解@RequestBody可以将body里面所有的json数据传到后端，后端再进行解析</p><blockquote><p>@RequestBody与@RequestParam()可以同时使用，@RequestBody最多只能有一个，而@RequestParam()可以有多个</p></blockquote><blockquote><p>当，@RequestBody 与@RequestParam()可以同时使用时，原SpringMVC接收参数的机制不变，只不过RequestBody 接收的是请求体里面的数据；而RequestParam接收的是key-value里面的参数，所以它会被切面进行处理从而可以用普通元素、数组、集合、对象等接收</p></blockquote><hr /><p>如果后端参数是一个对象，且该参数前是以@RequestBody修饰的，那么前端传递json参数时，必须满足以下要求：</p><ul><li>后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类(即：@RequestBody后面的类)时，会根据json字符串中的key来匹配对应实体类的属性，如果匹配一致且json中的该key对应的值符合(或可转换为)，实体类的对应属性的类型要求时,会调用实体类的setter方法将值赋给该属性</li><li>json字符串中，如果value为&quot;“的话，后端对应属性如果是String类型的，那么接受到的就是”&quot;，如果是后端属性的类型是Integer、Double等类型，那么接收到的就是null</li><li>json字符串中，如果value为null的话，后端对应收到的就是null</li><li>如果某个参数没有value的话，在传json字符串给后端时，要么干脆就不把该字段写到json字符串中；要么写value时， 必须有值，null  或&quot;“都行。千万不能有类似&quot;stature”:，这样的写法</li></ul><hr /><p><strong>@RequestBody与前端传过来的json数据的匹配规则</strong></p><p><strong>声明</strong></p><ul><li>根据不同的Content-Type等情况,Spring-MVC会采取不同的HttpMessageConverter实现来进行信息转换解析。下面介绍的是最常模型接收数据的情况。</li></ul><p><strong>解析json数据大体流程概述：</strong></p><ul><li>Http传递请求体信息，最终会被封装进com.fasterxml.jackson.core.json.UTF8StreamJsonParser中(提示：Spring采用CharacterEncodingFilter设置了默认编码为UTF-8)，然后在public class BeanDeserializer extends BeanDeserializerBase implements java.io.Serializable中，通过 public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException方法进行解析。</li><li>假设前端传的json串是这样的： {“name1”:“邓沙利文”,“age”:123,“mot”:“我是一只小小小小鸟~”} 后端的模型只有name和age属性，以及对应的setter/getter方法；给出一般用到的deserializeFromObject(JsonParser p, DeserializationContext ctxt)方法的核心逻辑：</li></ul><p><strong>可以使用@JsonAlias指定模型中的属性对应什么key</strong></p><pre><code class="highlight plaintext">public class User&#123;    @JsonAlias(value=&#123;&quot;Name&quot;,&quot;name123&quot;&#125;)    private String name;    private Integer age;    private String gender;    @JsonProperty(&quot;MOTTO&quot;)    private String motto;        ...getter and setter...        public String toString()&#123;        return age+&quot;岁&quot;+gender+&quot;人[&quot;+name+&quot;]的座右铭居然是：&quot;+motto+&quot;!!!&quot;    &#125;&#125;</code></pre><ul><li><strong>@JsonAlias注解</strong>，实现:json转模型时，使json中的特定key能转化为特定的模型属性;但是模型转json时，对应的转换后的key仍然与属性名一致，见：上图示例中的name字段的请求与响应。以下图进一步说明：</li></ul><blockquote><p>此时，json字符串转换为模型时，json中key为Name或为name123或为name的都能识别</p></blockquote><ul><li><strong>@JsonProperty注解</strong>，实现：json转模型时，使json中的特定key能转化为指定的模型属性；同样的，模型转json时，对应的转换后的key为指定的key，见：示例中的motto字段的请求与响应。以下图进一步说明：</li></ul><blockquote><p>此时，json字符串转换为模型时，key为MOTTO的能识别，但key为motto的不能识别</p></blockquote><blockquote><p>@JsonAlias注解需要依赖于setter、getter，而@JsonProperty注解不需要</p></blockquote><blockquote><p>在不考虑上述两个注解的一般情况下，key与属性匹配时,默认大小写敏感</p></blockquote><blockquote><p>有多个相同的key的json字符串中，转换为模型时，会以相同的几个key中，排在最后的那个key的值给模型属性复制，因为setter会覆盖原来的值。见示例中的gender属性</p></blockquote><blockquote><p>后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类(即:@RequestBody后面的类)时，会根据json字符串中的key来匹配对应实体类的属性，如果匹配一致且json中的该key对应的值符合(或可转换为)实体类的对应属性的类型要求时，会调用实体类的setter方法将值赋给该属性</p></blockquote><hr /><p><strong>@RequestBody直接以String接收前端传过来的json数据：</strong></p><pre><code class="highlight plaintext">/***   直接以String接收前端传来的json数据*/@RequestMapping(value = &quot;/testRequestBody&quot;)public Person testRequestBody(@RequestBody String jsonString) &#123;    System.out.println(jsonString);    return jsonString;&#125;</code></pre><hr /><p><strong>@RequestBody以简单对象接收前端传过来的json数据：</strong></p><pre><code class="highlight plaintext">/***   以比较简单的user对象接收前端传过来的json数据（SpringMVC会智能的将符合要求的数据装配进User对象中）*/@RequestMapping(value = &quot;/testRequestBody&quot;)public Person testRequestBody(@RequestBody User user) &#123;    System.out.println(user.toString());    return user.toString();&#125;</code></pre><pre><code class="highlight plaintext">public class User&#123;    private String name;    private Integer age;    private String gender;    private String motto;        ...getter and setter...        public String toString()&#123;        return age+&quot;岁&quot;+gender+&quot;人[&quot;+name+&quot;]的座右铭居然是：&quot;+motto+&quot;!!!&quot;    &#125;&#125;</code></pre><hr /><p><strong>@RequestBody以复杂对象接收前端传过来的json数据：</strong></p><pre><code class="highlight plaintext">/*** 以较复杂的Team对象接收前端传过来的json数据（SpringMVC会智能的将符合要求的数据装配进该Team对象中）* 注：如果后端@RequestBody后的对象，持有了集合等，当前端向传参令该对象持有的该集合为空时，json空字符串中，对象位置应该形如&quot;teamMembers&quot;:[]这么写，即：传递的json字符串中必须要有key，发否则请求出错*/@RequestMapping(value = &quot;/testRequestBody&quot;)public Person testRequestBody(@RequestBody Team team) &#123;    System.out.println(team.toString());    return team.toString();&#125;</code></pre><pre><code class="highlight plaintext">public class Team&#123;    private Integer id;    //小组名字    private String teamName;    //小组所获荣誉    private List&lt;String&gt; honors;    //小组成员    private List&lt;User&gt; teamMembers;        ...getter and setter ...        public String toString()&#123;        //遍历出小组所获荣耀        StringBuffer sbHonors = new StringBuffer(&quot;荣耀start----\n&quot;);        for(String honor:honors)&#123;            sbHonors.append(honor);            sbHonors.append(&quot;\n&quot;);        &#125;        sbHonors.append(&quot;荣耀end----\n&quot;);                //遍历出小组成员        StringBuffer sbMembers = new StringBuffer(&quot;成员start----\n&quot;);        for(User user:sbMembers)&#123;            sbHonors.append(user.toString());            sbHonors.append(&quot;\n&quot;);        &#125;        sbHonors.append(&quot;成员end----\n&quot;);                return &quot;小组id:&quot;+id+&quot;\n&quot;+&quot;小组名字：&quot;+teamName+&quot;\n&quot;+&quot;小组所获荣耀：&quot;+sbHonors+&quot;\n&quot;+&quot;小组成员：&quot;+sbMembers    &#125;    &#125;</code></pre><hr /><p><strong>@RequestBody与简单的@RequestParam()同时使用：</strong></p><pre><code class="highlight plaintext">//@RequestBody与复杂的@RequestParam()同时使用  注：这里以集合或者以数组接收数据都可以@RequestMapping(value = &quot;/testRequestBody&quot;)public String myTestController(@RequestBody User user,@RequestParam(&quot;token&quot;) String token)&#123;    System.out.println(user.toString());    System.our.println(tijeb);    return token+&quot;&gt;&gt;&gt;&quot;+user.toString();&#125;</code></pre><hr /><p><strong>@RequestBody与复杂的@RequestParam()同时使用：</strong></p><pre><code class="highlight plaintext">//这里@RequestParam以集合或者数组接收都可以@RequestMapping(&quot;&quot;)public String myTestController(@RequestBody User user,@RequestParam(&quot;arrays&quot;) List&lt;String&gt; arrays)&#123;System.out.println(user.toString());StringBuffer sb = new StringBuffer();for(String array:arrays)&#123;sb.append(&quot;array&quot;);sb.append(&quot; &quot;);System.out.println(array);&#125;return sb.toString()+user.toString();&#125;</code></pre><hr /><p><strong>@RequestBody接收请求体中的json数据；不加注解接收URL中的数据并组装为对象：</strong></p><pre><code class="highlight plaintext">//这里@RequestParam以集合或者数组接收都可以@RequestMapping(&quot;&quot;)public String myTestController(@RequestBody User user1,User user2)&#123;System.out.println(user1.toString());System.out.println(user2.toString());return user2.toString()+&quot;\n&quot;+user1.toString();&#125;</code></pre><blockquote><p>注：如果在后端方法参数前，指定了@RequestParam()的话，那么前端必须要有对应字段才行(当然可以通过设置该注解的required属性来调节是否必须传)，否者会报错400；如果参数前没有任何该注解，那么前端可以传，也可以不传</p></blockquote><h4 id="传参校验"><a class="markdownIt-Anchor" href="#传参校验"></a> 传参校验</h4><h5 id="使用valid"><a class="markdownIt-Anchor" href="#使用valid"></a> 使用@Valid</h5><p>使用该注解的主要目的时减轻表单验证的代码量，使逻辑看起来简单易用</p><ul><li>增加相关依赖：</li></ul><pre><code class="highlight plaintext">&lt;dependency&gt;        &lt;groupId&gt;javax.validation&lt;/groupId&gt;        &lt;artifactId&gt;validation-api&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ul><li>在Controller层的方法的欲校验的参数上添加@Valid注解</li></ul><pre><code class="highlight plaintext">@PostMapping(&quot;/action/register&quot;)public Result registerByForm(@Valid @RequestBody RegisterUser registerUser)&#123;    return userService.register(registerUser);&#125;</code></pre><ul><li>在实体类中增加校验标签</li></ul><p>空检查</p><p>@Null 验证对象是否为null</p><p>@NotNull 验证对象是否不为null, 无法查检长度为0的字符串</p><p>@NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.</p><p>@NotEmpty 检查约束元素是否为NULL或者是EMPTY.</p><p>Booelan检查</p><p>@AssertTrue 验证 Boolean 对象是否为 true</p><p>@AssertFalse 验证 Boolean 对象是否为 false</p><p>长度检查</p><ul><li>@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内</li><li>@Length(min=, max=) Validates that the annotated string is between min and max included.</li></ul><p>日期检查</p><ul><li>@Past 验证 Date 和 Calendar 对象是否在当前时间之前</li><li>@Future 验证 Date 和 Calendar 对象是否在当前时间之后</li><li>@Pattern 验证 String 对象是否符合正则表达式的规则</li></ul><p>数值检查</p><blockquote><p>建议使用在Stirng,Integer类型，不建议使用在int类型上，因为表单值为“”时无法转换为int，但可以转换为Stirng为&quot;&quot;,Integer为null</p></blockquote><ul><li>@Min 验证 Number 和 String 对象是否大等于指定的值</li><li>@Max 验证 Number 和 String 对象是否小等于指定的值</li><li>@DecimalMax 被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过BigDecimal定义的最大值的字符串表示.小数存在精度</li><li>@DecimalMin 被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过BigDecimal定义的最小值的字符串表示.小数存在精度</li><li>@Digits 验证 Number 和 String 的构成是否合法</li><li>@Digits(integer=,fraction=) 验证字符串是否是符合指定格式的数字，interger指定整数精度，fraction指定小数精度。</li><li>@Range(min=, max=) Checks whether the annotated value lies between (inclusive) the specified minimum and maximum. *</li><li>@Range(min=10000,max=50000,message=“range.bean.wage”) private BigDecimal wage;</li></ul><p>其他：</p><ul><li>@Valid 递归的对关联对象进行校验, 如果关联对象是个集合或者数组,那么对其中的元素进行递归校验,如果是一个map,则对其中的值部分进行校验.(是否进行递归验证)</li><li>@CreditCardNumber信用卡验证</li><li>@Email 验证是否是邮件地址，如果为null,不进行验证，算通过验证。</li><li>@ScriptAssert(lang= ,script=, alias=)</li><li>@URL(protocol=,host=, port=,regexp=, flags=)</li></ul><blockquote><p>要注意每个注解对应的数据类型</p></blockquote><pre><code class="highlight plaintext">@Data@AllArgsConstructor@NoArgsConstructorpublic class RegisterUser &#123;@Min(value = 1000000)@NotNull(message = &quot;ID不能为空&quot;)private Long userId;@NotNull(message = &quot;用户名不能为空&quot;)@Email(message = &quot;邮箱不正确&quot;)private String username;/*** 教师职称*/@Pattern(regexp = &quot;^[^&lt;&gt;():=]*$&quot;)private String position;/*** 教师所属教研室*/private String office;&#125;</code></pre><ul><li>异常处理（两种方式）</li></ul><ol><li>直接在@Valid修饰的对象后增加Errors形参，该形参即可获取相关异常</li></ol><pre><code class="highlight plaintext">@PostMapping(&quot;/action/register&quot;)public Result registerByForm(@Valid @RequestBody RegisterUser registerUser, Errors erros)&#123;       if (errors.hasErrors()) &#123;            throw new Exception(errors.getAllErrors().get(0).getDefaultMessage());        &#125;    return userService.register(registerUser);&#125;</code></pre><ol><li>定义全局处理异常类</li></ol><pre><code class="highlight plaintext">@Slf4j@ControllerAdvicepublic class GlobalExceptionHandler &#123;    private final static String EXCEPTION_MSG_KEY = &quot;Exception message : &quot;;    @ResponseBody    @ExceptionHandler(MethodArgumentNotValidException.class)    public Result handleValidException(MethodArgumentNotValidException e)&#123;                //日志记录错误信息                log.error(Objects.requireNonNull(e.getBindingResult().getFieldError()).getDefaultMessage());                //将错误信息返回给前台                return Result.error(103, Objects.requireNonNull(e.getBindingResult().getFieldError()).getDefaultMessage());    &#125;&#125;------------------------------------------------------------------------------------------@Data@JsonInclude(JsonInclude.Include.NON_NULL)public class Result&lt;T&gt; &#123;    private Integer code;    private String message;    private T data;    public Result() &#123;        this.code = 200;        this.message = &quot;操作成功&quot;;    &#125;    /**     * 用于错误处理     * @param code 错误码      * @param message 错误提示信息     */    public Result(Integer code,String message)&#123;        this.code = code;        this.message = message;    &#125;    public static  Result&lt;String&gt; error(Integer code,String msg)&#123;        return new Result&lt;&gt;(code,msg);    &#125;&#125;</code></pre><p>或者：</p><pre><code class="highlight plaintext">@ControllerAdvice@ResponseBodypublic class AppliCationExceptionHandler &#123; @ExceptionHandler(value=Exception.class)public Result&lt;String&gt; exceptionHandler(HttpServletRequest request, Exception e)&#123;e.printStackTrace();if(e instanceof ApplicationException) &#123;ApplicationException ex = (ApplicationException)e;return Result.error(ex.getErrorCode()+&quot;:&quot;+ex.getMsg());&#125;else if(e instanceof BindException) &#123;BindException ex = (BindException)e;List&lt;ObjectError&gt; errors = ex.getAllErrors();ObjectError error = errors.get(0);String msg = error.getDefaultMessage();return Result.errorArgs(msg, errors);&#125;return Result.error(e.getMessage()) ;&#125;&#125;</code></pre><h5 id="自定义校验标签"><a class="markdownIt-Anchor" href="#自定义校验标签"></a> 自定义校验标签</h5><ul><li>编写注解<ul><li>@Constraint注解的值就是我们的自己已注解处理类</li></ul></li></ul><pre><code class="highlight plaintext">@Constraint(validatedBy = GeneralNameValidator.class)@Target(&#123;ElementType.METHOD, ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface GeneralNameCheck &#123;    String message() default &quot;格式不合法&quot;;    long min() default 1;    long max() default 64;    Class&lt;?&gt;[] groups() default &#123;&#125;;    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125;</code></pre><ul><li>编写处理方法<ul><li>方法必须要实现ConstraintValidator接口</li></ul></li></ul><pre><code class="highlight plaintext">public class GeneralNameValidator implements ConstraintValidator&lt;GeneralNameCheck, String&gt; &#123;   private long max ;   private long min ;   private Pattern pattern ;        //初始化   public void initialize(GeneralNameCheck constraint) &#123;      max = constraint.max();      min = constraint.min();      pattern = Pattern.compile(&quot;^\\w&#123;&quot;+min+&quot;,&quot;+max+&quot;&#125;$&quot;);   &#125;   //校验   public boolean isValid(String value, ConstraintValidatorContext context) &#123;      return pattern.matcher(value).matches();   &#125;&#125;</code></pre><ul><li>使用</li></ul><p>使用方式与上述方式一致，@Valid定义在Controller形参上，自定义标签写在对应的pojo类成员变量即可。</p><h4 id="自定义参数绑定-2"><a class="markdownIt-Anchor" href="#自定义参数绑定-2"></a> 自定义参数绑定</h4><p>如果在参数绑定spring无法满足，我们就可以自定义参数绑定。</p><p><strong>自定义注解</strong></p><pre><code class="highlight plaintext">import java.lang.annotation.*;@Target(&#123;ElementType.PARAMETER&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface LoginUserInfo &#123;&#125;</code></pre><p><strong>定义处理类</strong></p><pre><code class="highlight plaintext">@Componentpublic class UserInfoArgumentResolver implements HandlerMethodArgumentResolver &#123;    @Autowired    private UserService userService;    /**     * 判断是否对参数类型的支持     * @param methodParameter     * @return     */    @Override    public boolean supportsParameter(MethodParameter methodParameter) &#123;        return methodParameter.hasParameterAnnotation(LoginUserInfo.class);    &#125;    /**     * 对参数的处理     * @param methodParameter     * @param modelAndViewContainer     * @param nativeWebRequest     * @param webDataBinderFactory     * @return     * @throws Exception     */    @Override    public Integer resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,                                NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception &#123;        HttpServletRequest servletRequest = nativeWebRequest.getNativeRequest(HttpServletRequest.class);        String userId = servletRequest.getParameter(&quot;userId&quot;);        if ((userId==null||&quot;&quot;.equals(userId))||//页面未传用户信息                (CommonConstants.CURRENT_USER_ID.equals(userId) &amp;&amp; CommonUtils.isAjaxReqeust(servletRequest)))&#123;//页面传currentuser用户信息            int userId1 = SingleLogin.getUserId(servletRequest);            if (userId1==-1)&#123;                throw new LoginException(&quot;登录异常，请重新登录&quot;);            &#125;            return  userId1;        &#125;        //页面传的真实的用户id        if (IntegerUtils.isNumeric(userId))&#123;            return  Integer.valueOf(userId);        &#125;       throw new LoginException(&quot;登录异常，请重新登录&quot;);    &#125;&#125;</code></pre><p><strong>添加到Configuration</strong></p><pre><code class="highlight plaintext">@Configurationpublic class AdmWebMvcConfiguration extends WebMvcConfigurerAdapter &#123; /*   @Override    public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123;        argumentResolvers.add(new UserInfoArgumentResolver());    &#125;*/    @Autowired    public  void setRequestMappingHandlerAdapter(RequestMappingHandlerAdapter adapter, UserInfoArgumentResolver userInfoArgumentResolver)&#123;        List&lt;HandlerMethodArgumentResolver&gt; resolvers = new ArrayList(adapter.getArgumentResolvers());        resolvers.add(0,userInfoArgumentResolver);        adapter.setArgumentResolvers(resolvers);    &#125;&#125;</code></pre><p><strong>页面使用</strong></p><pre><code class="highlight plaintext">@Override@RequestMapping(value = &quot;/mysqlSrcs/&#123;id&#125;&quot;, method = RequestMethod.DELETE)@ResponseStatus(HttpStatus.NO_CONTENT)public MysqlSrc delete(@PathVariable int id, HttpServletRequest request,@LoginUserInfo Integer userId) &#123;    return mysqlSrcOperationService.deleteMysqlSrc(id, request);&#125;</code></pre><h3 id="向页面传值"><a class="markdownIt-Anchor" href="#向页面传值"></a> 向页面传值</h3><ul><li>当Controller组件处理后，需要向JSP传值，用下述步骤</li><li>直接使用HttpSerlvetRequest和Session</li><li>使用ModeAndView对象</li><li>使用ModeMap参数对象</li><li>使用@ModelAttribute注解</li><li></li></ul><h5 id="1使用requestsetattribute方法"><a class="markdownIt-Anchor" href="#1使用requestsetattribute方法"></a> 1.使用request.setAttribute方法</h5><ul><li>将数据绑定到request，然后转发某个jsp</li></ul><blockquote><p>注：springmvc<strong>默认使用转发</strong></p></blockquote><pre><code class="highlight plaintext">       @RequestMapping(&quot;/login4.do&quot;)       //页面传值的第一钟方式：使用request       public String login4(AdminParam ap,HttpServletRequest request) &#123;             System.out.println(&quot;login4()&quot;);             String adminCode = ap.getAdminCode();             System.out.println(adminCode);             //将数据绑定到request中,就是给request对象存储一个值，用来在jsp页面用getAttribute()方法获取             request.setAttribute(&quot;adminCode&quot;,adminCode);             //springmvc默认使用转发             //框架后台默认调用转发方法 request.getRequestDispatcher(&quot;WEB-INF/findAll2.jsp&quot;).forward(req, res)             return &quot;index&quot;;       &#125;</code></pre><ul><li><strong>共用前端代码</strong></li></ul><pre><code class="highlight plaintext">login.jsp&lt;%@page pageEncoding=&quot;utf-8&quot; contentType=&quot;text/html; charset=utf-8&quot;%&gt;&lt;%@page isELIgnored=&quot;false&quot;%&gt;&lt;html&gt;       &lt;head&gt;&lt;u&gt;登陆&lt;/u&gt;&lt;/head&gt;       &lt;body&gt;             &lt;form action=&quot;login4.do&quot; method=&quot;post&quot;&gt;                    账号：&lt;input name=&quot;adminCode&quot;/&gt;                    密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;/&gt;                    &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;/&gt;            &lt;/form&gt;       &lt;/body&gt;&lt;/html&gt;index.jsp&lt;h1&gt;&lt;u&gt;succes&lt;/u&gt;...&lt;/h1&gt;&lt;h1&gt;$&#123;adminCode&#125;&lt;/h1&gt;</code></pre><h5 id="2modeandview对象"><a class="markdownIt-Anchor" href="#2modeandview对象"></a> 2.ModeAndView对象</h5><ul><li>在Controller处理方法完成后返回一个ModelAndView对象，包含显示视图名和模型数据</li><li>DispatcherServlet对象在收到ModelAndView后分析其携带的参数，然后调用request.setAttribute()方法传入参数，然后调用request.getRequestDispatcher(“WEB-INF/findAll2.jsp”).forward(req, res)方法转发到JSP页面</li></ul><pre><code class="highlight plaintext">       @RequestMapping(&quot;/login5.do&quot;)//向页面传值的第二中方式：使用ModelAndView       public ModelAndView login5(AdminParam ap) &#123;             System.out.println(&quot;login5()&quot;);             String adminCode = ap.getAdminCode();             System.out.println(adminCode);             Map&lt;String,Object&gt; data = new HashMap&lt;String,Object&gt;();             //相当于request.setAttribute(&quot;adminCode&quot;,adminCode)             //虽然这里是吧参数放到了一个map里面，但是框架本身还是要吧参数放到request里面             data.put(&quot;adminCode&quot;, adminCode);             //构造ModeAndView对象             ModelAndView mav = new ModelAndView(&quot;index&quot;,data);             return mav;       &#125;</code></pre><blockquote><p>Model数据会利用HttpServletRequest的Attribute传递到JSP页面中</p></blockquote><h5 id="3modelmap参数"><a class="markdownIt-Anchor" href="#3modelmap参数"></a> 3.ModelMap参数</h5><ul><li>将该对象作为方法的参数，然后将数据绑定到该对象</li></ul><pre><code class="highlight plaintext">       @RequestMapping(&quot;/login6.do&quot;)//像页面传值的第三种方式：使用ModelMap       public String login6(AdminParam ap,ModelMap mm) &#123;             System.out.println(&quot;login6()&quot;);             String adminCode = ap.getAdminCode();             System.out.println(adminCode);             //相当于request。setAttribute...             mm.addAttribute(&quot;adminCode&quot;,adminCode);             return &quot;index&quot;;       &#125;</code></pre><blockquote><p>ModelMap数据会利用HttpServletRequest的Attribute传递到JSP页面中</p></blockquote><h5 id="4modelattribute"><a class="markdownIt-Anchor" href="#4modelattribute"></a> 4.@ModelAttribute</h5><ul><li>在Controller方法的参数部分或Bean属性方法上使用</li></ul><pre><code class="highlight plaintext"> @RequestMappint(&quot;/login-action6.form&quot;) public String checkLogin6(@ModelAttribute(&quot;user&quot;)User user)&#123;     return &quot;success&quot;; &#125; @ModelAttribute(&quot;name&quot;)public String getName()&#123; return name;&#125;</code></pre><blockquote><p>ModelMap数据会利用HttpServletRequest的Attribute传递到JSP页面中</p></blockquote><h5 id="5sessioin存储"><a class="markdownIt-Anchor" href="#5sessioin存储"></a> 5.Sessioin存储</h5><ul><li>可以利用HttpServletRequest的getSession()方法访问</li><li>request的生命周期是一次请求的响应时间内可以使用，session的生命周期多次请求都可以使用，存在时间是30分钟（优先使用生命周期短的）</li><li>前端控制器DispatcherServlet会使用反射机制分析这个方法的参数，如果有session则会把session对象传入进来</li></ul><pre><code class="highlight plaintext">       @RequestMapping(&quot;login7.do&quot;)       //像页面传值的第四种方式：使用Session       public String login7(AdminParam ap,HttpSession session) &#123;             System.out.println(&quot;login7&quot;);             String adminCode = ap.getAdminCode();             System.out.println(adminCode);             session.setAttribute(&quot;adminCode&quot;, adminCode);             return &quot;index&quot;;       &#125;</code></pre><ul><li>案例2：就是每次访问为session中的count+1.</li></ul><pre><code class="highlight plaintext">    @RequestMapping(&quot;/check&quot;)    public ModelAndView check(HttpSession session) &#123;        Integer i = (Integer) session.getAttribute(&quot;count&quot;);        if (i == null)            i = 0;        i++;        session.setAttribute(&quot;count&quot;, i);        ModelAndView mav = new ModelAndView(&quot;check&quot;);        return mav;    &#125;</code></pre><ul><li>check.jsp</li></ul><pre><code class="highlight plaintext">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot; isELIgnored=&quot;false&quot;%&gt;session中记录的访问次数：$&#123;count&#125;</code></pre><h3 id="controller返回值"><a class="markdownIt-Anchor" href="#controller返回值"></a> Controller返回值</h3><ul><li>一个包含模型和视图的ModelAndView 对象。</li><li>一个模型对象，这主要包括Spring 封装好的Model 和ModelMap ，以及java.util.Map ，当没有视图返回的时候视图名称将由RequestToViewNameTranslator 来决定。</li><li>一个View 对象。这个时候如果在渲染视图的过程中模型的话就可以给处理器方法定义一个模型参数，然后在方法体里面往模型中添加值。</li><li>一个String 字符串。这往往代表的是一个视图名称。这个时候如果需要在渲染视图的过程中需要模型的话就可以给处理器方法一个模型参数，然后在方法体里面往模型中添加值就可以了。</li><li>返回值是void 。这种情况一般是我们直接把返回结果写到HttpServletResponse 中了，如果没有写的话，那么Spring 将会利用RequestToViewNameTranslator 来返回一个对应的视图名称。如果视图中需要模型的话，处理方法与返回字符串的情况相同。</li><li>如果处理器方法被注解@ResponseBody 标记的话，那么处理器方法的任何返回类型都会通过HttpMessageConverters 转换之后写到HttpServletResponse 中，而不会像上面的那些情况一样当做视图或者模型来处理。</li><li>除以上几种情况之外的其他任何返回类型都会被当做模型中的一个属性来处理，而返回的视图还是由RequestToViewNameTranslator 来决定，添加到模型中的属性名称可以在该方法上用@ModelAttribute(“attributeName”) 来定义，否则将使用返回类型的类名称的首字母小写形式来表示。使用@ModelAttribute 标记的方法会在@RequestMapping 标记的方法执行之前执行。</li></ul><h4 id="不用注解修饰"><a class="markdownIt-Anchor" href="#不用注解修饰"></a> 不用注解修饰</h4><h5 id="返回modelandview"><a class="markdownIt-Anchor" href="#返回modelandview"></a> <strong>返回ModelAndView</strong></h5><p>controller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定view</p><pre><code class="highlight plaintext">@Controllerpublic class ItemController &#123;    @Autowired    ItemService service;    @RequestMapping(&quot;queryItem&quot;)    public ModelAndView queryItem()&#123;        List&lt;Item&gt; items = service.queryItemList();        ModelAndView modelAndView = new ModelAndView();        modelAndView.addObject(&quot;itemList&quot;,items);        //设置视图（逻辑路径）        modelAndView.setViewName(&quot;item-list&quot;);        return modelAndView;    &#125;&#125;</code></pre><h5 id="返回void"><a class="markdownIt-Anchor" href="#返回void"></a> <strong>返回void</strong></h5><ul><li>request/response</li></ul><p>在controller<strong>方法形参上可以定义request和response</strong>，使用request或response指定响应结果：</p><pre><code class="highlight plaintext">void service(HttpServletRequest request,HttpServletResponse response,Model model)&#123;    //可以使用request绑定返回值    request.setAttribute(&quot;itemList&quot;, itemList);    //也可以使用model绑定返回值    model.addAttribute(&quot;itemList&quot;, itemList);          //使用request转发向页面（ModelAndView底层用的其实也是转发）    request.getRequestDispatcher(&quot;页面路径&quot;).forward(request, response);    //也可以使用response页面重定向    response.sendRedirect(&quot;url&quot;)    //也可以通过response指定响应结果，例如响应json数据如下：    response.setCharacterEncoding(&quot;utf-8&quot;);    response.setContentType(&quot;application/json;charset=utf-8&quot;);    response.getWriter().write(&quot;json串&quot;);&#125;</code></pre><h5 id="返回字符串推荐"><a class="markdownIt-Anchor" href="#返回字符串推荐"></a> <strong>返回字符串（推荐）</strong></h5><h6 id="逻辑视图名"><a class="markdownIt-Anchor" href="#逻辑视图名"></a> 逻辑视图名</h6><pre><code class="highlight plaintext">return &quot;item/item-list&quot;;</code></pre><h6 id="redirect重定向"><a class="markdownIt-Anchor" href="#redirect重定向"></a> <strong>redirect重定向</strong></h6><ul><li>Spring MVC默认采用转发方式定位视图，如果需要重定向方式可采用下面几种方法<ul><li>使用RedirectView<code>（如果返回值是ModelAndView）</code></li><li>使用redirect:前缀<code>（如果返回值是String）</code></li></ul></li></ul><p><strong>RedirectView</strong></p><ul><li>如果Controller的请求处理方法返回的是ModelAndView对象，可以使用RedirectView方法重定向</li></ul><pre><code class="highlight plaintext">       @RequestMapping(&quot;/login9.do&quot;)       //重定向第二种方法：使用RedirectView       public ModelAndView login9() &#123;             System.out.println(&quot;login9&quot;);             RedirectView rv = new RedirectView(&quot;toIndex.do&quot;);             return new ModelAndView(rv);       &#125;</code></pre><p><strong>redirect</strong></p><ul><li>重定向到其他网址</li><li>重定向到其他视图</li></ul><pre><code class="highlight plaintext">//testRedirect：url，可以是url网址，也可以是其他requestMappingreturn &quot;redirect:testRedirect&quot;;//直接重定向到http://www.baidu.comreturn &quot;redirect:http://www.baidu.com&quot;;//重定向到其他requestMapping,重定向到下面的controller中return &quot;redirect:testRedirect&quot;;@RequestMapping(&quot;testRedirect&quot;)public String testRedirect(HttpServletRequest request) &#123;&#125;</code></pre><blockquote><p>相当于<code>response.sendRedirect()</code>，<strong>浏览器URL发生改变，Request域不共享</strong></p></blockquote><h6 id="forward转发"><a class="markdownIt-Anchor" href="#forward转发"></a> <strong>forward转发</strong></h6><p>转发：从Controller转发到jsp然后再返回给浏览器</p><pre><code class="highlight plaintext">//testRedirect：url，可以是url网址，也可以是其他requestMappingreturn &quot;forward:testForward&quot;;</code></pre><blockquote><p>相当于<code>request.getRequestDispatcher().forward(request,response)</code>，<strong>浏览器URL不发生改变，Request域可以共享</strong></p></blockquote><h4 id="使用注解修饰responsebody"><a class="markdownIt-Anchor" href="#使用注解修饰responsebody"></a> 使用注解修饰@ResponseBody</h4><p><strong>返回带@ResponseBody注解的值</strong></p><p>@<strong>ResponseBody</strong>的作用：</p><ul><li>将返回的<strong>pojo类型转换为json格式</strong>返回给浏览器（将响应体的Content-Type设置为application/json；charset=utf-8）<br />将返回的<strong>字符串类型直接返回</strong>给浏览器（将响应体的Content-Type设置为text/plain；charset=utf-8）</li><li>ResponseBody注解可以通过内置的9种HttpMessageConverter，匹配<strong>不同的Controller返回值类型</strong>，然后进行不同的<strong>消息转换处理</strong></li><li>将转换之后的数据放到HttpServletResponse对象的<strong>响应体</strong>返回到页面，不同的HttpMessageConverter处理的数据，指定的<strong>ContentType值</strong>也不同</li></ul><pre><code class="highlight plaintext">@RequestMapping(&quot;jsonTest&quot;)@ResponseBodypublic Item jsonTest()&#123;    Item item = service.queryItemById(1);    System.out.println(item);    return item;&#125;</code></pre><p>@<strong>RequestBody</strong></p><ul><li>注解的作用和@ResponseBody注解正好相反，它是处理<strong>请求参数</strong>的Http消息转换的</li></ul><hr /><p><strong>常用的HttpMessageConverter</strong></p><ul><li><code>MappingJacksonHttpMessageConverter</code>处理POJO类型返回值<ul><li>默认使用MappingJackson的JSON处理能力，将后台返回的Java对象（POJO类型）</li><li>转为JSON格式输出到页面,将响应体的Content-Type设置为application/json；charset=utf-8</li></ul></li><li><code>StringHttpMessageConverter</code>处理String类型返回值<ul><li>调用response.getWriter()方法将String类型的字符串写回给调用者。</li><li>将响应体的Content-Type设置为text/plain；charset=utf-8</li></ul></li></ul><h5 id="restcontroller"><a class="markdownIt-Anchor" href="#restcontroller"></a> @RestController</h5><p>@RestController相当于@<strong>Controller和@ResponseBody</strong>的组合</p><p>该类所有方法的返回值都将被@ResponseBody注解给修饰</p><pre><code class="highlight plaintext">@RestControllerpublic class RestItemController &#123;&#125;</code></pre><h3 id="controlleradvice"><a class="markdownIt-Anchor" href="#controlleradvice"></a> @ControllerAdvice</h3><p>ControllerAdvice标注的Class的作用是用来辅助Controller的，我们可以在ControllerAdvice标注的Class中使用@ExceptionHandler、@InitBinder和@ModelAttribute标记对应的方法，以便它们可以对指定范围内的Controller起作用</p><ul><li>@ExceptionHandler：用来进行异常处理的</li><li>@InitBinder：</li><li>@ModelAttribute：</li></ul><p>在没有ControllerAdvice时，我们定义的<code>@ExceptionHandler、@InitBinder和@ModelAttribute</code>都只能在Controller中<strong>对当前Controller生效</strong>，如果需要让更多的Controller应用相同的逻辑，只能把它们定义在共同的父类中。有了ControllerAdvice后则可以把它们定义在使用@ControllerAdvice标注的Class中</p><p><strong>ControllerAdvice定义的Class是有作用范围的</strong>，默认情况下，什么参数都不指定时它的作用范围是所有的范围。ControllerAdvice提供了一些可以缩小它的处理范围的参数。</p><ul><li>value：数组类型，用来指定可以作用的基包，即将对指定的包下面的Controller及其子包下面的Controller起作用。</li><li>basePackages：数组类型，等价于value。</li><li>basePackageClasses：数组类型，此时的基包将以指定的Class所在的包为准。</li><li>assignableTypes：数组类型，用来指定具体的Controller类型，它可以是一个共同的接口或父类等。</li><li>annotations：数组类型，用来指定Class上拥有指定的注解的Controller。</li></ul><ol><li>下面的ControllerAdvice将对定义在com.elim.app.mvc.controller包及其子包中的Controller起作用</li></ol><pre><code class="highlight plaintext">@ControllerAdvice(value=&quot;com.elim.app.mvc.controller&quot;)//@ControllerAdvice(basePackages=&quot;com.elim.app.mvc.controller&quot;)public class DefaultExceptionHandler &#123;    //...&#125;</code></pre><ol><li>下面的ControllerAdvice也将对定义在com.elim.app.mvc.controller包及其子包中的Controller起作用。它通过basePackageClasses指定了需要作为基包的Class，此时基包将以basePackageClasses指定的Class所在的包为准，即com.elim.app.mvc.controller</li></ol><pre><code class="highlight plaintext">@ControllerAdvice(basePackageClasses=com.elim.app.mvc.controller.Package.class)public class DefaultExceptionHandler &#123;    //...&#125;</code></pre><ol><li>下面的ControllerAdvice将对FooController及其子类型的Controller起作用。</li></ol><pre><code class="highlight plaintext">@ControllerAdvice(assignableTypes=FooController.class)public class DefaultExceptionHandler &#123;    //...&#125;</code></pre><ol><li>下面的ControllerAdvice将对所有Class上使用了RestController注解标注的Controller起作用。</li></ol><pre><code class="highlight plaintext">@ControllerAdvice(annotations=RestController.class)public class DefaultExceptionHandler &#123;    //...&#125;</code></pre><ol><li>也可以同时指定多个属性，比如下面的ControllerAdvice将对FooController及其子类型的Controller起作用，同时也将对com.elim.app.mvc.controller包及其子包下面的Controller起作用。</li></ol><pre><code class="highlight plaintext">@ControllerAdvice(assignableTypes=FooController.class, basePackages=&quot;com.elim.app.mvc.controller&quot;)public class DefaultExceptionHandler &#123;    //...&#125;</code></pre><blockquote><p>当一个异常可以同时被多个ControllerAdvice的@ExceptionHandler标注的方法处理时只有第一个匹配的处理器方法可以处理。</p></blockquote><h4 id="exceptionhandler"><a class="markdownIt-Anchor" href="#exceptionhandler"></a> @ExceptionHandler</h4><p>springMVC提供的异常处理主要有两种方式，一种是直接实现自己的HandlerExceptionResolver，当然这也包括使用Spring已经为我们提供好的SimpleMappingExceptionResolver和DefaultHandlerExceptionResolver，另一种是使用注解的方式实现一个专门用于处理异常的Controller——ExceptionHandler</p><p>比如下面的示例中就在ControllerAdvice标注的Class中定义了两个使用ExceptionHandler标注的方法以处理对应的异常，其中handleException()方法将用来处理除java.lang.IllegalStateException以外的所有其它异常，它的处理结果是转到一个固定的视图上。而handleIllegalStateException()将用来处理java.lang.IllegalStateException，它的处理结果是以JSON的形式响应的。</p><ul><li>在@ExceptionHandler标注的处理方法中如果希望获取到当前抛出的异常，则可以在方法参数中声明一个需要处理的异常类型的参数，SpringMVC在调用对应的处理方法处理异常时将传递当前的异常对象。</li><li>@ExceptionHandler标注的处理方法可以声明任何正常的处理器方法可以声明的参数类型，比如HttpServletRequest、HttpServletResponse、java.util.Map、Model等。</li><li>@ExceptionHandler标注的处理方法的返回结果也可以跟正常的Controller处理方法拥有一样的返回类型，比如String、Model、ModelAndView、void、Object等，所以我们可以把它看作是和Controller处理方法等价的方法定义的这么一个方法。</li></ul><pre><code class="highlight plaintext">@ControllerAdvicepublic class DefaultExceptionHandler &#123;    /**         * 该方法将处理SpringMVC处理过程中抛出的所有的异常，         * 将使用该方法的返回值来替换正常的Controller方法的返回值         * @param e         * @return         */    @ExceptionHandler(Exception.class)    public ModelAndView handleException(Exception e) &#123;        return new ModelAndView(&quot;viewName&quot;);    &#125;        /**         * 该方法将处理SpringMVC过程中抛出的所有的java.lang.IllegalStateException，         * 而其它异常的处理还由上面定义的handleException()处理。当抛出了一个异常可以同时被         * 多个@ExceptionHandler标注的方法处理时，对应的异常将交由更精确的异常处理方法处理。         *          * 且抛出该异常时将把处理结果以@ResponseBody的形式返回，此时将被当作JSON返回。         * @param e         * @return         */    @ExceptionHandler(IllegalStateException.class)    @ResponseBody    public Object handleIllegalStateException(IllegalStateException e) &#123;        Map&lt;String, Object&gt; jsonObj = new HashMap&lt;&gt;();        jsonObj.put(&quot;errorMessage&quot;, e.getMessage());        return jsonObj;    &#125;    &#125;</code></pre><p><strong>使用@ExceptionHandler进行处理有一个不好的地方是进行异常处理的方法必须与出错的方法在同一个Controller里面</strong></p><pre><code class="highlight plaintext">import org.springframework.stereotype.Controller;  import org.springframework.web.bind.annotation.ExceptionHandler;  import org.springframework.web.bind.annotation.RequestMapping;  import com.tiantian.blog.web.servlet.MyException;  @Controller  public class GlobalController &#123;  /**  * 用于处理异常的  * @return  */  @ExceptionHandler(&#123;MyException.class&#125;)  public String exception(MyException e) &#123;      System.out.println(e.getMessage());      e.printStackTrace();      return &quot;exception&quot;;  &#125;    @RequestMapping(&quot;test&quot;)  public void test() &#123;      throw new MyException(&quot;出错了！&quot;);  &#125;    &#125;</code></pre><h4 id="initbinder"><a class="markdownIt-Anchor" href="#initbinder"></a> @InitBinder</h4><p>在通过处理器方法参数接收 request 请求参数绑定数据的时候，对于一些简单的数据类型 Spring 会帮我们自动进行类型转换，而对于一些复杂的类型由于 Spring 没法识别，所以也就不能帮助我们进行自动转换了，这个时候如果我们需要 Spring 来帮我们自动转换的话就需要我们给 Spring 注册一个对特定类型的识别转换器。 Spring 允许我们提供两种类型的识别转换器，一种是注册在 Controller 中的，一种是注册在 SpringMVC 的配置文件中。聪明的读者看到这里应该可以想到它们的区别了，定义在 Controller 中的是局部的，只在当前 Controller 中有效，而放在 SpringMVC 配置文件中的是全局的，所有 Controller 都可以拿来使用</p><p>自定义springMVC的属性编辑器主要有两种方式，</p><ul><li>一种是使用@InitBinder标签在运行期注册一个属性编辑器，这种编辑器只在当前Controller里面有效；</li><li>还有一种是实现自己的 WebBindingInitializer，然后定义一个 AnnotationMethodHandlerAdapter的bean，在此bean里面进行注册 ，这种属性编辑器是全局的</li></ul><p>我们可以使用 @InitBinder 注解标注在 Controller 方法上，然后在方法体里面注册数据绑定的转换器，这主要是通过 WebDataBinder 进行的。我们可以给需要注册数据绑定的转换器的方法一个 WebDataBinder 参数，然后给该方法加上 @InitBinder 注解，这样当该 Controller 中在处理请求方法时如果发现有不能解析的对象的时候，就会看该类中是否有使用 @InitBinder 标记的方法，如果有就会执行该方法，然后看里面定义的类型转换器是否与当前需要的类型匹配</p><p>使用示例一：</p><pre><code class="highlight plaintext">@Controller  @RequestMapping ( &quot;/myTest&quot; )  public class MyController &#123;        @InitBinder      public void dataBinder(WebDataBinder binder) &#123;         DateFormat dateFormat = new SimpleDateFormat( &quot;yyyyMMdd&quot; );         PropertyEditor propertyEditor = new CustomDateEditor(dateFormat, true ); // 第二个参数表示是否允许为空         binder.registerCustomEditor(Date. class , propertyEditor);      &#125;        @RequestMapping ( &quot;dataBinder/&#123;date&#125;&quot; )      public void testDate( @PathVariable Date date, Writer writer) throws IOException &#123;         writer.write(String.valueOf (date.getTime()));      &#125;  &#125;</code></pre><p>在上面的代码中当我们请求 /myTest/dataBinder/20121212.do 的时候， Spring 就会利用 @InitBinder 标记的方法里面定义的类型转换器把字符串 20121212 转换为一个 Date 对象。这样定义的类型转换器是局部的类型转换器，一旦出了这个 Controller 就不会再起作用。类型转换器是通过 WebDataBinder 对象的 registerCustomEditor 方法来注册的，要实现自己的类型转换器就要实现自己的 PropertyEditor 对象。 Spring 已经给我们提供了一些常用的属性编辑器，如 CustomDateEditor 、 CustomBooleanEditor 等</p><p>PropertyEditor 是一个接口，要实现自己的 PropertyEditor 类我们可以实现这个接口，然后实现里面的方法。但是 PropertyEditor 里面定义的方法太多了，这样做比较麻烦。在 java 中有一个封装类是实现了 PropertyEditor 接口的，它是 PropertyEditorSupport 类。所以如果需要实现自己的 PropertyEditor 的时候只需要继承 PropertyEditorSupport 类，然后重写其中的一些方法。一般就是重写 setAsText 和 getAsText 方法就可以了， setAsText 方法是用于把字符串类型的值转换为对应的对象的，而 getAsText 方法是用于把对象当做字符串来返回的。在 setAsText 中我们一般先把字符串类型的对象转为特定的对象，然后利用 PropertyEditor 的 setValue 方法设定转换后的值。在 getAsText 方法中一般先使用 getValue 方法取代当前的对象，然后把它转换为字符串后再返回给 getAsText 方法。下面是一个示例：</p><pre><code class="highlight plaintext">@InitBinder  public void dataBinder(WebDataBinder binder) &#123;  // 定义一个 User 属性编辑器  PropertyEditor userEditor = new PropertyEditorSupport() &#123;     @Override     public String getAsText() &#123;        // TODO Auto-generated method stub        User user = (User) getValue();        return user.getUsername();     &#125;     @Override     public void setAsText(String userStr) throws IllegalArgumentException &#123;        // TODO Auto-generated method stub        User user = new User(1, userStr);        setValue(user);     &#125;  &#125;;  // 使用 WebDataBinder 注册 User 类型的属性编辑器  binder.registerCustomEditor(User. class , userEditor);  &#125;</code></pre><p>使用示例二：</p><pre><code class="highlight plaintext">import java.beans.PropertyEditorSupport;  import java.io.IOException;  import java.text.SimpleDateFormat;  import java.util.Date;  import javax.servlet.http.HttpServletResponse;  import org.springframework.beans.propertyeditors.CustomDateEditor;  import org.springframework.stereotype.Controller;  import org.springframework.web.bind.WebDataBinder;  import org.springframework.web.bind.annotation.InitBinder;  import org.springframework.web.bind.annotation.PathVariable;  import org.springframework.web.bind.annotation.RequestMapping;  @Controller  public class GlobalController &#123;    @RequestMapping(&quot;test/&#123;date&#125;&quot;)  public void test(@PathVariable Date date, HttpServletResponse response) throws IOException      response.getWriter().write( date);  &#125;    @InitBinder//必须有一个参数WebDataBinder  public void initBinder(WebDataBinder binder) &#123;      binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;), false));  binder.registerCustomEditor(int.class, new PropertyEditorSupport() &#123;  @Override  public String getAsText() &#123;      // TODO Auto-generated method stub      return getValue().toString();  &#125;  @Override  public void setAsText(String text) throws IllegalArgumentException &#123;      // TODO Auto-generated method stub      System.out.println(text + &quot;...........................................&quot;);      setValue(Integer.parseInt(text));  &#125;        &#125;);  &#125;  &#125;</code></pre><hr /><p>第二种属性编辑器的方式：</p><p>如果需要定义全局的类型转换器就需要实现自己的 WebBindingInitializer 对象，然后把该对象注入到 AnnotationMethodHandlerAdapter 中，这样 Spring 在遇到自己不能解析的对象的时候就会到全局的 WebBindingInitializer 的 initBinder 方法中去找，每次遇到不认识的对象时， initBinder 方法都会被执行一遍</p><ol><li>定义自己的WebBindingInitializer</li></ol><pre><code class="highlight plaintext">public class MyWebBindingInitializer implements WebBindingInitializer &#123;        @Override      public void initBinder(WebDataBinder binder, WebRequest request) &#123;         // TODO Auto-generated method stub         DateFormat dateFormat = new SimpleDateFormat( &quot;yyyyMMdd&quot; );         PropertyEditor propertyEditor = new CustomDateEditor(dateFormat, true );         binder.registerCustomEditor(Date. class , propertyEditor);      &#125;  &#125;</code></pre><blockquote><p>定义了这么一个 WebBindingInitializer 对象之后 Spring 还是不能识别其中指定的对象，这是因为我们只是定义了 WebBindingInitializer 对象，还没有把它交给 Spring ， Spring 不知道该去哪里找解析器。要让 Spring 能够识别还需要我们在 SpringMVC 的配置文件中定义一个 AnnotationMethodHandlerAdapter 类型的 bean 对象，然后利用自己定义的 WebBindingInitializer 覆盖它的默认属性 webBindingInitializer</p></blockquote><ol><li>在springMVC的配置文件里面定义一个AnnotationMethodHandlerAdapter，并设置其WebBindingInitializer属性为我们自己定义的WebBindingInitializer对象</li></ol><pre><code class="highlight plaintext">&lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;&gt;      &lt;property name=&quot;cacheSeconds&quot; value=&quot;0&quot;/&gt;      &lt;property name=&quot;webBindingInitializer&quot;&gt;  &lt;bean class=&quot;com.xxx.blog.util.MyWebBindingInitializer&quot;/&gt;      &lt;/property&gt;  &lt;/bean&gt;</code></pre><blockquote><p>注意：当使用了&lt;mvc:annotation-driven /&gt;的时候，它 会自动注册DefaultAnnotationHandlerMapping与AnnotationMethodHandlerAdapter 两个bean。这时候第二种方式指定的全局属性编辑器就不会起作用了，解决办法就是手动的添加上述bean，并把它们加在<code>&lt;mvc:annotation-driven/&gt;</code>的前面。如果不生效，则将手动注册AnnotationMethodHandlerAdapter改为手动注册RequestMappingHandlerAdapter</p></blockquote><hr /><p>3.触发数据绑定方法的时间</p><p>当Controller处理器方法参数使用@RequestParam、@PathVariable、@RequestHeader、@CookieValue和@ModelAttribute标记的时候都会触发initBinder方法的执行，这包括使用WebBindingInitializer定义的全局方法和在Controller中使用@InitBinder标记的局部方法。而且每个使用了这几个注解标记的参数都会触发一次initBinder方法的执行，这也意味着有几个参数使用了上述注解就会触发几次initBinder方法的执行。</p><h5 id="防止xss注入"><a class="markdownIt-Anchor" href="#防止xss注入"></a> 防止XSS注入</h5><pre><code class="highlight plaintext">@InitBinderprotected void initBinder(WebDataBinder binder) &#123;    // String类型转换，将所有传递进来的String进行HTML编码，防止XSS攻击    binder.registerCustomEditor(String.class, new PropertyEditorSupport() &#123;        @Override        public void setAsText(String text) &#123;            setValue(text == null ? null : StringEscapeUtils.escapeJavaScript(text.trim()));        &#125;        @Override        public String getAsText() &#123;            Object value = getValue();            return value != null ? value.toString() : &quot;&quot;;        &#125;    &#125;);&#125;</code></pre><h4 id="modelattribute"><a class="markdownIt-Anchor" href="#modelattribute"></a> @ModelAttribute</h4><p>使用 @ModelAttribute 和 @SessionAttributes 传递和保存数据</p><p>SpringMVC 支持使用 @ModelAttribute 和 @SessionAttributes 在不同的模型和控制器之间共享数据</p><p>@ModelAttribute 主要有两种使用方式，一种是标注在方法上，一种是标注在 Controller 方法参数上</p><p>当 @ModelAttribute 标记在方法上的时候，该方法将在处理器方法执行之前执行，然后把返回的对象存放在 session 或模型属性中，属性名称可以使用 @ModelAttribute(“attributeName”) 在标记方法的时候指定，若未指定，则使用返回类型的类名称（首字母小写）作为属性名称。关于 @ModelAttribute 标记在方法上时对应的属性是存放在 session 中还是存放在模型中，我们来做一个实验，看下面一段代码。</p><pre><code class="highlight plaintext">@Controller  @RequestMapping ( &quot;/myTest&quot; )  public class MyController &#123;        @ModelAttribute ( &quot;hello&quot; )      public String getModel() &#123;         System. out .println( &quot;-------------Hello---------&quot; );         return &quot;world&quot; ;      &#125;        @ModelAttribute ( &quot;intValue&quot; )      public int getInteger() &#123;         System. out .println( &quot;-------------intValue---------------&quot; );         return 10;      &#125;        @RequestMapping ( &quot;sayHello&quot; )      public void sayHello( @ModelAttribute ( &quot;hello&quot; ) String hello, @ModelAttribute ( &quot;intValue&quot; ) int num, @ModelAttribute ( &quot;user2&quot; ) User user, Writer writer, HttpSession session) throws IOException &#123;         writer.write( &quot;Hello &quot; + hello + &quot; , Hello &quot; + user.getUsername() + num);         writer.write( &quot;\r&quot; );         Enumeration enume = session.getAttributeNames();         while (enume.hasMoreElements())             writer.write(enume.nextElement() + &quot;\r&quot; );      &#125;        @ModelAttribute ( &quot;user2&quot; )      public User getUser() &#123;         System. out .println( &quot;---------getUser-------------&quot; );         return new User(3, &quot;user2&quot; );      &#125;  &#125;</code></pre><p>当我们请求 /myTest/sayHello.do 的时候使用 @ModelAttribute 标记的方法会先执行，然后把它们返回的对象存放到模型中。最终访问到 sayHello 方法的时候，使用 @ModelAttribute 标记的方法参数都能被正确的注入值。</p><p>由执行结果我们可以看出来，此时 session 中没有包含任何属性，也就是说上面的那些对象都是存放在模型属性中，而不是存放在 session 属性中。那要如何才能存放在 session 属性中呢？这个时候我们先引入一个新的概念 @SessionAttributes ，它的用法会在讲完 @ModelAttribute 之后介绍，这里我们就先拿来用一下。我们在 MyController 类上加上 @SessionAttributes 属性标记哪些是需要存放到 session 中的。看下面的代码：</p><pre><code class="highlight plaintext">@Controller  @RequestMapping ( &quot;/myTest&quot; )  @SessionAttributes (value=&#123; &quot;intValue&quot; , &quot;stringValue&quot; &#125;, types=&#123;User. class &#125;)  public class MyController &#123;        @ModelAttribute ( &quot;hello&quot; )      public String getModel() &#123;         System. out .println( &quot;-------------Hello---------&quot; );         return &quot;world&quot; ;      &#125;        @ModelAttribute ( &quot;intValue&quot; )      public int getInteger() &#123;         System. out .println( &quot;-------------intValue---------------&quot; );         return 10;      &#125;           @RequestMapping ( &quot;sayHello&quot; )      public void sayHello(Map&lt;String, Object&gt; map, @ModelAttribute ( &quot;hello&quot; ) String hello, @ModelAttribute ( &quot;intValue&quot; ) int num, @ModelAttribute ( &quot;user2&quot; ) User user, Writer writer, HttpServletRequest request) throws IOException &#123;         map.put( &quot;stringValue&quot; , &quot;String&quot; );         writer.write( &quot;Hello &quot; + hello + &quot; , Hello &quot; + user.getUsername() + num);         writer.write( &quot;\r&quot; );         HttpSession session = request.getSession();         Enumeration enume = session.getAttributeNames();         while (enume.hasMoreElements())             writer.write(enume.nextElement() + &quot;\r&quot; );         System. out .println(session);      &#125;        @ModelAttribute ( &quot;user2&quot; )      public User getUser() &#123;         System. out .println( &quot;---------getUser-------------&quot; );         return new User(3, &quot;user2&quot; );      &#125;  &#125;</code></pre><p>在上面代码中我们指定了属性为 intValue 或 stringValue 或者类型为 User 的都会放到 Session 中，利用上面的代码当我们访问 /myTest/sayHello.do 的时候</p><p>仍然没有打印出任何 session 属性，这是怎么回事呢？怎么定义了把模型中属性名为 intValue 的对象和类型为 User 的对象存到 session 中，而实际上没有加进去呢？难道我们错啦？我们当然没有错，只是在第一次访问 /myTest/sayHello.do 的时候 @SessionAttributes 定义了需要存放到 session 中的属性，而且这个模型中也有对应的属性，但是这个时候还没有加到 session 中，所以 session 中不会有任何属性，等处理器方法执行完成后 Spring 才会把模型中对应的属性添加到 session 中。</p><p>当 @ModelAttribute 标记在处理器方法参数上的时候，表示该参数的值将从模型或者 Session 中取对应名称的属性值，该名称可以通过 @ModelAttribute(“attributeName”) 来指定，若未指定，则使用参数类型的类名称（首字母小写）作为属性名称。</p><pre><code class="highlight plaintext">@Controller  @RequestMapping ( &quot;/myTest&quot; )  public class MyController &#123;        @ModelAttribute ( &quot;hello&quot; )      public String getModel() &#123;         return &quot;world&quot; ;      &#125;        @RequestMapping ( &quot;sayHello&quot; )      public void sayHello( @ModelAttribute ( &quot;hello&quot; ) String hello, Writer writer) throws IOException &#123;         writer.write( &quot;Hello &quot; + hello);      &#125;     &#125;</code></pre><p>在上面代码中，当我们请求/myTest/sayHello.do 的时候，由于MyController 中的方法getModel 使用了注解@ModelAttribute 进行标记，所以在执行请求方法sayHello 之前会先执行getModel 方法，这个时候getModel 方法返回一个字符串world 并把它以属性名hello 保存在模型中，接下来访问请求方法sayHello 的时候，该方法的hello 参数使用@ModelAttribute(“hello”) 进行标记，这意味着将从session 或者模型中取属性名称为hello 的属性值赋给hello 参数，所以这里hello 参数将被赋予值world ，所以请求完成后将会在页面上看到Hello world 字符串</p><p>@SessionAttributes 用于标记需要在Session 中使用到的数据，包括从Session 中取数据和存数据。@SessionAttributes 一般是标记在Controller 类上的，可以通过名称、类型或者名称加类型的形式来指定哪些属性是需要存放在session 中的。</p><pre><code class="highlight plaintext">@Controller  @RequestMapping ( &quot;/myTest&quot; )  @SessionAttributes (value=&#123; &quot;user1&quot; , &quot;blog1&quot; &#125;, types=&#123;User. class , Blog. class &#125;)  public class MyController &#123;        @RequestMapping ( &quot;setSessionAttribute&quot; )      public void setSessionAttribute(Map&lt;String, Object&gt; map, Writer writer) throws IOException &#123;         User user = new User(1, &quot;user&quot; );         User user1 = new User(2, &quot;user1&quot; );         Blog blog = new Blog(1, &quot;blog&quot; );         Blog blog1 = new Blog(2, &quot;blog1&quot; );         map.put( &quot;user&quot; , user);         map.put( &quot;user1&quot; , user1);         map.put( &quot;blog&quot; , blog);         map.put( &quot;blog1&quot; , blog1);         writer.write( &quot;over.&quot; );      &#125;      @RequestMapping ( &quot;useSessionAttribute&quot; )      public void useSessionAttribute(Writer writer, @ModelAttribute ( &quot;user1&quot; ) User user1, @ModelAttribute ( &quot;blog1&quot; ) Blog blog1) throws IOException &#123;         writer.write(user1.getId() + &quot;--------&quot; + user1.getUsername());         writer.write( &quot;\r&quot; );         writer.write(blog1.getId() + &quot;--------&quot; + blog1.getTitle());      &#125;        @RequestMapping ( &quot;useSessionAttribute2&quot; )      public void useSessionAttribute(Writer writer, @ModelAttribute ( &quot;user1&quot; ) User user1, @ModelAttribute ( &quot;blog1&quot; ) Blog blog1, @ModelAttribute User user, HttpSession session) throws IOException &#123;         writer.write(user1.getId() + &quot;--------&quot; + user1.getUsername());         writer.write( &quot;\r&quot; );         writer.write(blog1.getId() + &quot;--------&quot; + blog1.getTitle());         writer.write( &quot;\r&quot; );         writer.write(user.getId() + &quot;---------&quot; + user.getUsername());         writer.write( &quot;\r&quot; );         Enumeration enume = session.getAttributeNames();         while (enume.hasMoreElements())             writer.write(enume.nextElement() + &quot; \r&quot; );      &#125;        @RequestMapping ( &quot;useSessionAttribute3&quot; )      public void useSessionAttribute( @ModelAttribute ( &quot;user2&quot; ) User user) &#123;        &#125;  &#125;</code></pre><p>在上面代码中我们可以看到在MyController 上面使用了@SessionAttributes 标记了需要使用到的Session 属性。可以通过名称和类型指定需要存放到Session 中的属性，对应@SessionAttributes 注解的value 和types 属性。当使用的是types 属性的时候，那么使用的Session 属性名称将会是对应类型的名称（首字母小写）。当value 和types 两个属性都使用到了的时候，这时候取的是它们的并集，而不是交集，所以上面代码中指定要存放在Session 中的属性有名称为user1 或blog1 的对象，或类型为User 或Blog 的对象。在上面代码中我们首先访问/myTest/setSessionAttribute.do ，该请求将会请求到MyController 的setSessionAttribute 方法，在该方法中，我们往模型里面添加了user 、user1 、blog 和blog1 四个属性，因为它们或跟类上的@SessionAttributes 定义的需要存到session 中的属性名称相同或类型相同，所以在请求完成后这四个属性都将添加到session 属性中。接下来访问/myTest/useSessionAttribute.do ，该请求将会请求MyController 的useSessionAttribute(Writer writer, @ModelAttribute(“user1”) User user1, @ModelAttribute(“blog1”) Blog blog) 方法，该方法参数中用@ModelAttribute 指定了参数user1 和参数blog1 是需要从session 或模型中绑定的，恰好这个时候session 中已经有了这两个属性，所以这个时候在方法执行之前会先绑定这两个参数。</p><p>接下来访问/myTest/useSessionAttribute2.do ，这个时候请求的是上面代码中对应的第二个useSessionAttribute 方法，方法参数user 、user1 和blog1 用@ModelAttribute 声明了需要session 或模型属性注入，我们知道在请求/myTest/setSessionAttribute.do 的时候这些属性都已经添加到了session 中</p><p>接下来访问/myTest/useSessionAttribute3.do ，这个时候请求的是上面代码中对应的第三个useSessionAttribute 方法，我们可以看到该方法的方法参数user 使用了@ModelAttribute(“user2”) 进行标记，表示user 需要session 中的user2 属性来注入，但是这个时候我们知道session 中是不存在user2 属性的，所以这个时候就会报错了。</p><h3 id="bmi健康指数案例"><a class="markdownIt-Anchor" href="#bmi健康指数案例"></a> bmi健康指数案例</h3><ul><li><h2 id="目录结构"><a class="markdownIt-Anchor" href="#目录结构"></a> 目录结构</h2></li><li>pom.xml</li></ul><pre><code class="highlight plaintext">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;com.lee.bmi&lt;/groupId&gt;  &lt;artifactId&gt;spring-bmi&lt;/artifactId&gt;  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;      &lt;dependencies&gt;              &lt;dependency&gt;                      &lt;groupId&gt;org.springframework&lt;/groupId&gt;                      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;                      &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;              &lt;/dependency&gt;              &lt;dependency&gt;                     &lt;groupId&gt;junit&lt;/groupId&gt;                     &lt;artifactId&gt;junit&lt;/artifactId&gt;                     &lt;version&gt;4.10&lt;/version&gt;              &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><ul><li>web.xml</li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; version=&quot;2.5&quot;&gt;       &lt;servlet&gt;             &lt;servlet-name&gt;&lt;u&gt;springmvc&lt;/u&gt;&lt;/servlet-name&gt;             &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;             &lt;!-- DispatcherServlet在初始化方法里面，会读取该初始化参数的值来获取spring配置文件的位置，然后启动spring容器 --&gt;             &lt;init-param&gt;                    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;                    &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;             &lt;/init-param&gt;             &lt;!-- 表示启动&lt;u&gt;tomcat&lt;/u&gt;立即启动容器实例化参数 --&gt;             &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;       &lt;/servlet&gt;       &lt;servlet-mapping&gt;             &lt;servlet-name&gt;&lt;u&gt;springmvc&lt;/u&gt;&lt;/servlet-name&gt;             &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;       &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><ul><li>springmvc.xml</li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:task=&quot;http://www.springframework.org/schema/task&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx-3.1.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop-3.1.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context-3.1.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd        http://www.springframework.org/schema/task        http://www.springframework.org/schema/task/spring-task-3.1.xsd&quot;&gt;             &lt;!-- 配置组件扫描 --&gt;       &lt;context:component-scan base-package=&quot;bmi&quot;/&gt;       &lt;!-- 配置mvc注解扫描 --&gt;       &lt;mvc:annotation-driven/&gt;       &lt;!-- 配置ViewResolver视图解析器 --&gt;       &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;             &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot;&gt;&lt;/property&gt;             &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;       &lt;/bean&gt;&lt;/beans&gt;</code></pre><ul><li>前端页面bmi_form.jsp/result.jsp</li></ul><pre><code class="highlight plaintext">bmi_form.jsp&lt;%@page pageEncoding=&quot;utf-8&quot; contentType=&quot;text/html; charset=utf-8&quot;%&gt;&lt;html&gt;       &lt;head&gt;bmi&lt;/head&gt;       &lt;body&gt;             &lt;form action=&quot;bmiContro.do&quot; method=&quot;post&quot;&gt;                    体重：&lt;input name=&quot;height&quot;/&gt;                    身高：&lt;input type=&quot;password&quot; name=&quot;weight&quot;/&gt;                    &lt;input type=&quot;submit&quot; value=&quot;测量&quot;/&gt;             &lt;/form&gt;       &lt;/body&gt;&lt;/html&gt;result.sjp&lt;%@page pageEncoding=&quot;utf-8&quot; contentType=&quot;text/html; charset=utf-8&quot;%&gt;&lt;html&gt;       &lt;head&gt;&lt;u&gt;bmi&lt;/u&gt;&lt;/head&gt;       &lt;body&gt;             &lt;h1&gt;$&#123;bmi&#125;&lt;/h1&gt;       &lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>HeightAndWeight.java</li></ul><pre><code class="highlight plaintext">package bmi;public class HeightAndWeigh &#123;       private int height;       private int weight;              public int getHeight() &#123;             return height;       &#125;       public void setHeight(int height) &#123;             this.height = height;       &#125;       public int getWeight() &#123;             return weight;       &#125;       public void setWeight(int weight) &#123;             this.weight = weight;       &#125;&#125;</code></pre><ul><li>bmiController.java</li></ul><pre><code class="highlight plaintext">package bmi;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class BmiController &#123;@RequestMapping(&quot;/toBmi.do&quot;)public String toBmi() &#123;System.out.println(&quot;toBmi&quot;);return &quot;bmi_form&quot;;&#125;@RequestMapping(&quot;/bmiContro.do&quot;)    //框架会自动吧from表单的参数封装成我们自定义的bean对象HeightAdnWeigh传入进来public String bmiContro(HeightAndWeigh haw,ModelMap mm) &#123;System.out.println(&quot;bmiContro&quot;);int bmi = haw.getWeight()/haw.getHeight()/haw.getHeight();if(bmi&gt;23) &#123;mm.addAttribute(&quot;bmi&quot;, &quot;过重&quot;);&#125;else if(bmi&lt;19) &#123;mm.addAttribute(&quot;bmi&quot;, &quot;过轻&quot;);&#125;else &#123;mm.addAttribute(&quot;bmi&quot;, &quot;正常&quot;);&#125;return &quot;result&quot;;&#125;&#125;</code></pre><h2 id="集成filter"><a class="markdownIt-Anchor" href="#集成filter"></a> 集成Filter</h2><p>有的童鞋在上一节的Web应用中可能发现了，如果注册时输入中文会导致乱码，因为Servlet默认按非UTF-8编码读取参数。为了修复这一问题，我们可以简单地使用一个EncodingFilter，在全局范围类给HttpServletRequest和HttpServletResponse强制设置为UTF-8编码。</p><p>可以自己编写一个EncodingFilter，也可以直接使用Spring MVC自带的一个CharacterEncodingFilter。配置Filter时，只需在web.xml中声明即可：</p><pre><code class="highlight plaintext">&lt;web-app&gt;    &lt;filter&gt;        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;UTF-8&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;            &lt;param-name&gt;forceEncoding&lt;/param-name&gt;            &lt;param-value&gt;true&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    ...&lt;/web-app&gt;</code></pre><p>因为这种Filter和我们业务关系不大，注意到CharacterEncodingFilter其实和Spring的IoC容器没有任何关系，两者均互不知晓对方的存在，因此，配置这种Filter十分简单。</p><p>我们再考虑这样一个问题：如果允许用户使用Basic模式进行用户验证，即在HTTP请求中添加头Authorization: Basic email:password，这个需求如何实现？</p><pre><code class="highlight plaintext">@Componentpublic class AuthFilter implements Filter &#123;    @Autowired    UserService userService;    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)            throws IOException, ServletException &#123;        HttpServletRequest req = (HttpServletRequest) request;        // 获取Authorization头:        String authHeader = req.getHeader(&quot;Authorization&quot;);        if (authHeader != null &amp;&amp; authHeader.startsWith(&quot;Basic &quot;)) &#123;            // 从Header中提取email和password:            String email = prefixFrom(authHeader);            String password = suffixFrom(authHeader);            // 登录:            User user = userService.signin(email, password);            // 放入Session:            req.getSession().setAttribute(UserController.KEY_USER, user);        &#125;        // 继续处理请求:        chain.doFilter(request, response);    &#125;&#125;</code></pre><p>现在问题来了：在Spring中创建的这个AuthFilter是一个普通Bean，Servlet容器并不知道，所以它不会起作用。</p><p>如果我们直接在web.xml中声明这个AuthFilter，注意到AuthFilter的实例将由Servlet容器而不是Spring容器初始化，因此，@Autowire根本不生效，用于登录的UserService成员变量永远是null。</p><p>所以，得通过一种方式，让Servlet容器实例化的Filter，间接引用Spring容器实例化的AuthFilter。Spring MVC提供了一个DelegatingFilterProxy，专门来干这个事情：</p><pre><code class="highlight plaintext">&lt;web-app&gt;    &lt;filter&gt;        &lt;filter-name&gt;authFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;authFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    ...&lt;/web-app&gt;</code></pre><p>我们来看实现原理：</p><ol><li>Servlet容器从web.xml中读取配置，实例化DelegatingFilterProxy，注意命名是authFilter；</li><li>Spring容器通过扫描@Component实例化AuthFilter。</li></ol><p>当DelegatingFilterProxy生效后，它会自动查找注册在ServletContext上的Spring容器，再试图从容器中查找名为authFilter的Bean，也就是我们用@Component声明的AuthFilter。</p><p>DelegatingFilterProxy将请求代理给AuthFilter，核心代码如下：</p><pre><code class="highlight plaintext">public class DelegatingFilterProxy implements Filter &#123;    private Filter delegate;    public void doFilter(...) throws ... &#123;        if (delegate == null) &#123;            delegate = findBeanFromSpringContainer();        &#125;        delegate.doFilter(req, resp, chain);    &#125;&#125;</code></pre><p>这就是一个代理模式的简单应用。我们画个图表示它们之间的引用关系如下：</p><p>如果在web.xml中配置的Filter名字和Spring容器的Bean的名字不一致，那么需要指定Bean的名字：</p><pre><code class="highlight plaintext">&lt;filter&gt;    &lt;filter-name&gt;basicAuthFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;    &lt;!-- 指定Bean的名字 --&gt;    &lt;init-param&gt;        &lt;param-name&gt;targetBeanName&lt;/param-name&gt;        &lt;param-value&gt;authFilter&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;</code></pre><h2 id="使用interceptor"><a class="markdownIt-Anchor" href="#使用interceptor"></a> 使用Interceptor</h2><p>在Web程序中，注意到使用Filter的时候，Filter由Servlet容器管理，它在Spring MVC的Web应用程序中作用范围如下：</p><p>上图虚线框就是Filter2的拦截范围，Filter组件实际上并不知道后续内部处理是通过Spring MVC提供的DispatcherServlet还是其他Servlet组件，因为Filter是Servlet规范定义的标准组件，它可以应用在任何基于Servlet的程序中。</p><p>如果只基于Spring MVC开发应用程序，还可以使用Spring MVC提供的一种功能类似Filter的拦截器：Interceptor。和Filter相比，Interceptor拦截范围不是后续整个处理流程，而是仅针对Controller拦截：</p><p>上图虚线框就是Interceptor的拦截范围，注意到Controller的处理方法一般都类似这样：</p><pre><code class="highlight plaintext">@Controllerpublic class Controller1 &#123;    @GetMapping(&quot;/path/to/hello&quot;)    ModelAndView hello() &#123;        ...    &#125;&#125;</code></pre><p>所以，Interceptor的拦截范围其实就是Controller方法，它实际上就相当于基于AOP的方法拦截。因为Interceptor只拦截Controller方法，所以要注意，返回ModelAndView并渲染后，后续处理就脱离了Interceptor的拦截范围。</p><p>使用Interceptor的好处是Interceptor本身是Spring管理的Bean，因此注入任意Bean都非常简单。此外，可以应用多个Interceptor，并通过简单的@Order指定顺序。我们先写一个LoggerInterceptor：</p><pre><code class="highlight plaintext">@Order(1)@Componentpublic class LoggerInterceptor implements HandlerInterceptor &#123;    final Logger logger = LoggerFactory.getLogger(getClass());    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        logger.info(&quot;preHandle &#123;&#125;...&quot;, request.getRequestURI());        if (request.getParameter(&quot;debug&quot;) != null) &#123;            PrintWriter pw = response.getWriter();            pw.write(&quot;&lt;p&gt;DEBUG MODE&lt;/p&gt;&quot;);            pw.flush();            return false;        &#125;        return true;    &#125;    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        logger.info(&quot;postHandle &#123;&#125;.&quot;, request.getRequestURI());        if (modelAndView != null) &#123;            modelAndView.addObject(&quot;__time__&quot;, LocalDateTime.now());        &#125;    &#125;    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;        logger.info(&quot;afterCompletion &#123;&#125;: exception = &#123;&#125;&quot;, request.getRequestURI(), ex);    &#125;&#125;</code></pre><p>一个Interceptor<strong>必须实现HandlerInterceptor接口</strong>，可以<strong>选择实现preHandle()、postHandle()和afterCompletion()方法</strong>。preHandle()是Controller方法调用<strong>前执行</strong>，postHandle()是Controller方法正常返回<strong>后执行</strong>，而afterCompletion()无论Controller方法是否抛异常都会执行，参数ex就是Controller方法抛出的异常（未抛出异常是null）。</p><p>在preHandle()中，也可以直接处理响应，然后返回false表示无需调用Controller方法继续处理了，通常在认证或者安全检查失败时直接返回错误响应。在postHandle()中，因为捕获了Controller方法返回的ModelAndView，所以可以继续往ModelAndView里添加一些通用数据，很多页面需要的全局数据如Copyright信息等都可以放到这里，无需在每个Controller方法中重复添加。</p><p>我们再继续添加一个AuthInterceptor，用于替代上一节使用AuthFilter进行Basic认证的功能：</p><pre><code class="highlight plaintext">@Order(2)@Componentpublic class AuthInterceptor implements HandlerInterceptor &#123;    final Logger logger = LoggerFactory.getLogger(getClass());    @Autowired    UserService userService;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)            throws Exception &#123;        logger.info(&quot;pre authenticate &#123;&#125;...&quot;, request.getRequestURI());        try &#123;            authenticateByHeader(request);        &#125; catch (RuntimeException e) &#123;            logger.warn(&quot;login by authorization header failed.&quot;, e);        &#125;        return true;    &#125;    private void authenticateByHeader(HttpServletRequest req) &#123;        String authHeader = req.getHeader(&quot;Authorization&quot;);        if (authHeader != null &amp;&amp; authHeader.startsWith(&quot;Basic &quot;)) &#123;            logger.info(&quot;try authenticate by authorization header...&quot;);            String up = new String(Base64.getDecoder().decode(authHeader.substring(6)), StandardCharsets.UTF_8);            int pos = up.indexOf(&#x27;:&#x27;);            if (pos &gt; 0) &#123;                String email = URLDecoder.decode(up.substring(0, pos), StandardCharsets.UTF_8);                String password = URLDecoder.decode(up.substring(pos + 1), StandardCharsets.UTF_8);                User user = userService.signin(email, password);                req.getSession().setAttribute(UserController.KEY_USER, user);                logger.info(&quot;user &#123;&#125; login by authorization header ok.&quot;, email);            &#125;        &#125;    &#125;&#125;</code></pre><p>这个AuthInterceptor是由Spring容器直接管理的，因此注入UserService非常方便。</p><p>最后，要让拦截器生效，我们在WebMvcConfigurer中注册所有的Interceptor：</p><pre><code class="highlight plaintext">@BeanWebMvcConfigurer createWebMvcConfigurer(@Autowired HandlerInterceptor[] interceptors) &#123;    return new WebMvcConfigurer() &#123;        public void addInterceptors(InterceptorRegistry registry) &#123;            for (var interceptor : interceptors) &#123;                registry.addInterceptor(interceptor);            &#125;        &#125;        ...    &#125;;&#125;</code></pre><h3 id="处理异常"><a class="markdownIt-Anchor" href="#处理异常"></a> 处理异常</h3><p>在Controller中，Spring MVC还允许定义基于@ExceptionHandler注解的异常处理方法。我们来看具体的示例代码：</p><pre><code class="highlight plaintext">@Controllerpublic class UserController &#123;    @ExceptionHandler(RuntimeException.class)    public ModelAndView handleUnknowException(Exception ex) &#123;        return new ModelAndView(&quot;500.html&quot;, Map.of(&quot;error&quot;, ex.getClass().getSimpleName(), &quot;message&quot;, ex.getMessage()));    &#125;    ...&#125;</code></pre><p>异常处理方法没有固定的方法签名，可以传入Exception、HttpServletRequest等，返回值可以是void，也可以是ModelAndView，上述代码通过@ExceptionHandler(RuntimeException.class)表示当发生RuntimeException的时候，就自动调用此方法处理。</p><p>注意到我们返回了一个新的ModelAndView，这样在应用程序内部如果发生了预料之外的异常，可以给用户显示一个出错页面，而不是简单的500 Internal Server Error或404 Not Found。例如B站的错误页：</p><p>可以编写多个错误处理方法，每个方法针对特定的异常。例如，处理LoginException使得页面可以自动跳转到登录页。</p><p>使用ExceptionHandler时，要注意它仅作用于当前的Controller，即ControllerA中定义的一个ExceptionHandler方法对ControllerB不起作用。如果我们有很多Controller，每个Controller都需要处理一些通用的异常，例如LoginException，思考一下应该怎么避免重复代码？</p><h2 id="处理cors"><a class="markdownIt-Anchor" href="#处理cors"></a> 处理CORS</h2><p>在JavaScript与REST交互的时候，有很多安全限制。默认情况下，浏览器按同源策略放行JavaScript调用API，即：</p><ul><li>如果A站在域名a.com页面的JavaScript调用A站自己的API时，没有问题；</li><li>如果A站在域名a.com页面的JavaScript调用B站b.com的API时，将被浏览器拒绝访问，因为不满足同源策略。</li></ul><p>同源要求域名要完全相同（a.com和www.a.com不同），协议要相同（http和https不同），端口要相同 。</p><p>那么，在域名a.com页面的JavaScript要调用B站b.com的API时，还有没有办法？</p><p>办法是有的，那就是CORS，全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。如果A站的JavaScript访问B站API的时候，B站能够返回响应头<strong>Access-Control-Allow-Origin: <a href="http://a.com">http://a.com</a></strong>，那么，浏览器就允许A站的JavaScript访问B站的API。</p><p>注意到跨域访问能否成功，取决于B站是否愿意给A站返回一个正确的Access-Control-Allow-Origin响应头，所以决定权永远在提供API的服务方手中。</p><p>使用Spring的@RestController开发REST应用时，同样会面对跨域问题。如果我们允许指定的网站通过页面JavaScript访问这些REST API，就必须正确地设置CORS。</p><h3 id="使用crossorigin"><a class="markdownIt-Anchor" href="#使用crossorigin"></a> 使用@CrossOrigin</h3><p>第一种方法是使用@CrossOrigin注解，可以在@RestController的class级别或方法级别定义一个@CrossOrigin，例如</p><pre><code class="highlight plaintext">@CrossOrigin(origins = &quot;http://local.liaoxuefeng.com:8080&quot;)@RestController@RequestMapping(&quot;/api&quot;)public class ApiController &#123;    ...&#125;</code></pre><p>上述定义在ApiController处的@CrossOrigin指定了只允许来自local.liaoxuefeng.com跨域访问，允许多个域访问需要写成数组形式，例如origins = {“<a href="http://a.com">http://a.com</a>”, “<a href="https://www.b.com">https://www.b.com</a>”})。如果要允许任何域访问，写成<code>origins = &quot;*&quot;</code>即可。</p><p>如果有多个REST Controller都需要使用CORS，那么，每个Controller都必须标注@CrossOrigin注解。</p><h3 id="使用corsregistry"><a class="markdownIt-Anchor" href="#使用corsregistry"></a> 使用CorsRegistry</h3><p>第二种方法是在WebMvcConfigurer中定义一个全局CORS配置，下面是一个示例：</p><pre><code class="highlight plaintext">@BeanWebMvcConfigurer createWebMvcConfigurer() &#123;    return new WebMvcConfigurer() &#123;        @Override        public void addCorsMappings(CorsRegistry registry) &#123;            registry.addMapping(&quot;/api/**&quot;)                    .allowedOrigins(&quot;http://local.liaoxuefeng.com:8080&quot;)                    .allowedMethods(&quot;GET&quot;, &quot;POST&quot;)                    .maxAge(3600);            // 可以继续添加其他URL规则:            // registry.addMapping(&quot;/rest/v2/**&quot;)...        &#125;    &#125;;&#125;</code></pre><p>这种方式可以创建一个全局CORS配置，如果仔细地设计URL结构，那么可以一目了然地看到各个URL的CORS规则，推荐使用这种方式配置CORS。</p><h3 id="使用corsfilter"><a class="markdownIt-Anchor" href="#使用corsfilter"></a> 使用CorsFilter</h3><p>第三种方法是使用Spring提供的CorsFilter，我们在集成Filter中详细介绍了将Spring容器内置的Bean暴露为Servlet容器的Filter的方法，由于这种配置方式需要修改web.xml，也比较繁琐，所以推荐使用第二种方式。</p><h2 id="异步处理"><a class="markdownIt-Anchor" href="#异步处理"></a> 异步处理</h2><p>在Servlet模型中，<strong>每个请求都是由某个线程处理</strong>，然后，将响应写入IO流，发送给客户端。从开始处理请求，到写入响应完成，都是在同一个线程中处理的。</p><p>实现Servlet容器的时候，只要每处理一个请求，就创建一个新线程处理它，就能保证正确实现了Servlet线程模型。在实际产品中，例如Tomcat，总是通过线程池来处理请求，它仍然符合一个请求从头到尾都由某一个线程处理。</p><p>这种线程模型非常重要，因为<strong>Spring的JDBC事务是基于ThreadLocal实现的</strong>，如果在处理过程中，一会由线程A处理，一会又由线程B处理，那事务就全乱套了。此外，很多安全认证，也是基于ThreadLocal实现的，可以保证在处理请求的过程中，各个线程互不影响。</p><p>但是，如果一个请求处理的时间较长，例如几秒钟甚至更长，那么，这种基于线程池的同步模型很快就会把所有线程耗尽，导致服务器无法响应新的请求。如果把长时间处理的请求改为异步处理，那么线程池的利用率就会大大提高。Servlet从3.0规范开始添加了异步支持，允许对一个请求进行异步处理。</p><p>我们先来看看在Spring MVC中如何实现对请求进行异步处理的逻辑。首先建立一个Web工程，然后编辑web.xml文件如下：</p><pre><code class="highlight plaintext">&lt;web-app&gt;    &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextClass&lt;/param-name&gt;            &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;com.itranswarp.learnjava.AppConfig&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;        &lt;async-supported&gt;true&lt;/async-supported&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p>和前面普通的MVC程序相比，这个web.xml主要对DispatcherServlet的配置多了一个&lt;<strong>async-supported</strong>&gt;，默认值是false，必须明确写成true，这样Servlet容器才会支持async处理。</p><p>下一步就是在Controller中编写async处理逻辑。我们以ApiController为例，演示如何异步处理请求。</p><p>第一种async处理方式是返回一个Callable，Spring MVC自动把返回的Callable放入线程池执行，等待结果返回后再写入响应：</p><pre><code class="highlight plaintext">@GetMapping(&quot;/users&quot;)public Callable&lt;List&lt;User&gt;&gt; users() &#123;    return () -&gt; &#123;        // 模拟3秒耗时:        try &#123;            Thread.sleep(3000);        &#125; catch (InterruptedException e) &#123;        &#125;        return userService.getUsers();    &#125;;&#125;</code></pre><p>第二种async处理方式是返回一个DeferredResult对象，然后在另一个线程中，设置此对象的值并写入响应：</p><pre><code class="highlight plaintext">@GetMapping(&quot;/users/&#123;id&#125;&quot;)public DeferredResult&lt;User&gt; user(@PathVariable(&quot;id&quot;) long id) &#123;    DeferredResult&lt;User&gt; result = new DeferredResult&lt;&gt;(3000L); // 3秒超时    new Thread(() -&gt; &#123;        // 等待1秒:        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;        &#125;        try &#123;            User user = userService.getUserById(id);            // 设置正常结果并由Spring MVC写入Response:            result.setResult(user);        &#125; catch (Exception e) &#123;            // 设置错误结果并由Spring MVC写入Response:            result.setErrorResult(Map.of(&quot;error&quot;, e.getClass().getSimpleName(), &quot;message&quot;, e.getMessage()));        &#125;    &#125;).start();    return result;&#125;</code></pre><p>使用DeferredResult时，可以设置超时，超时会自动返回超时错误响应。在另一个线程中，可以调用setResult()写入结果，也可以调用setErrorResult()写入一个错误结果。</p><p>运行程序，当我们访问<a href="http://localhost:8080/api/users/1%E6%97%B6%EF%BC%8C%E5%81%87%E5%AE%9A%E7%94%A8%E6%88%B7%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%A81%E7%A7%92%E5%90%8E%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8080/api/users/1时，假定用户存在，则浏览器在1秒后返回结果：</a></p><p>访问一个不存在的User ID，则等待1秒后返回错误结果：</p><h3 id="filter处理"><a class="markdownIt-Anchor" href="#filter处理"></a> Filter处理</h3><p>当我们使用async模式处理请求时，原有的Filter也可以工作，但我们必须在web.xml中添加<async-supported>并设置为true。我们用两个Filter：SyncFilter和AsyncFilter分别测试：</p><pre><code class="highlight plaintext">&lt;web-app ...&gt;    ...    &lt;filter&gt;        &lt;filter-name&gt;sync-filter&lt;/filter-name&gt;        &lt;filter-class&gt;com.itranswarp.learnjava.web.SyncFilter&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter&gt;        &lt;filter-name&gt;async-filter&lt;/filter-name&gt;        &lt;filter-class&gt;com.itranswarp.learnjava.web.AsyncFilter&lt;/filter-class&gt;        &lt;async-supported&gt;true&lt;/async-supported&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;sync-filter&lt;/filter-name&gt;        &lt;url-pattern&gt;/api/version&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;async-filter&lt;/filter-name&gt;        &lt;url-pattern&gt;/api/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    ...&lt;/web-app&gt;</code></pre><p>一个声明为支持<async-supported>的Filter既可以过滤async处理请求，也可以过滤正常的同步处理请求，而未声明<async-supported>的Filter无法支持async请求，如果一个普通的Filter遇到async请求时，会直接报错，因此，务必<strong>注意普通Filter的<url-pattern>不要匹配async请求路径</strong>。</p><p>在logback.xml配置文件中，我们把输出格式加上[%thread]，可以输出当前线程的名称：</p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt;    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;            &lt;Pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/Pattern&gt;        &lt;/layout&gt;    &lt;/appender&gt;    ...&lt;/configuration&gt;</code></pre><p>对于同步请求，例如/api/version，我们可以看到如下输出：</p><pre><code class="highlight plaintext">2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.SyncFilter - start SyncFilter...2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.AsyncFilter - start AsyncFilter...2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.ApiController - get version...2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.AsyncFilter - end AsyncFilter.2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.SyncFilter - end SyncFilter.</code></pre><p>可见，每个Filter和ApiController都是由同一个线程执行。</p><p>对于异步请求，例如/api/users，我们可以看到如下输出：</p><pre><code class="highlight plaintext">2020-05-16 11:23:49 [http-nio-8080-exec-4] INFO  c.i.learnjava.web.AsyncFilter - start AsyncFilter...2020-05-16 11:23:49 [http-nio-8080-exec-4] INFO  c.i.learnjava.web.ApiController - get users...2020-05-16 11:23:49 [http-nio-8080-exec-4] INFO  c.i.learnjava.web.AsyncFilter - end AsyncFilter.2020-05-16 11:23:52 [MvcAsync1] INFO  c.i.learnjava.web.ApiController - return users...</code></pre><p>可见，AsyncFilter和ApiController是由同一个线程执行的，但是，返回响应的是另一个线程。</p><p>对DeferredResult测试，可以看到如下输出：</p><pre><code class="highlight plaintext">2020-05-16 11:25:24 [http-nio-8080-exec-8] INFO  c.i.learnjava.web.AsyncFilter - start AsyncFilter...2020-05-16 11:25:24 [http-nio-8080-exec-8] INFO  c.i.learnjava.web.AsyncFilter - end AsyncFilter.2020-05-16 11:25:25 [Thread-2] INFO  c.i.learnjava.web.ApiController - deferred result is set.</code></pre><p>同样，返回响应的是另一个线程。</p><p>在实际使用时，经常用到的就是DeferredResult，因为返回DeferredResult时，可以设置超时、正常结果和错误结果，易于编写比较灵活的逻辑。</p><p>使用async异步处理响应时，要时刻牢记，在另一个异步线程中的事务和Controller方法中执行的事务不是同一个事务，在Controller中绑定的ThreadLocal信息也无法在异步线程中获取。</p><p>此外，Servlet 3.0规范添加的异步支持是针对同步模型打了一个“补丁”，虽然可以异步处理请求，但高并发异步请求时，它的处理效率并不高，因为这种异步模型并没有用到真正的“原生”异步。Java标准库提供了封装操作系统的异步IO包java.nio，是真正的多路复用IO模型，可以用少量线程支持大量并发。使用NIO编程复杂度比同步IO高很多，因此我们很少直接使用NIO。相反，大部分需要高性能异步IO的应用程序会选择Netty这样的框架，它基于NIO提供了更易于使用的API，方便开发异步应用程序。</p><h2 id="使用websocket"><a class="markdownIt-Anchor" href="#使用websocket"></a> 使用WebSocket</h2><p>WebSocket是一种基于HTTP的长链接技术。传统的HTTP协议是一种请求-响应模型，如果浏览器不发送请求，那么服务器无法主动给浏览器推送数据。如果需要定期给浏览器推送数据，例如股票行情，或者不定期给浏览器推送数据，例如在线聊天，基于HTTP协议实现这类需求，只能依靠浏览器的JavaScript定时轮询，效率很低且实时性不高。</p><p>因为HTTP本身是基于TCP连接的，所以，WebSocket在HTTP协议的基础上做了一个简单的升级，即建立TCP连接后，浏览器发送请求时，附带几个头：</p><pre><code class="highlight plaintext">GET /chat HTTP/1.1Host: www.example.comUpgrade: websocketConnection: Upgrade</code></pre><p>就表示客户端希望升级连接，变成长连接的WebSocket，服务器返回升级成功的响应：</p><pre><code class="highlight plaintext">HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: Upgrade</code></pre><p>收到成功响应后表示WebSocket“握手”成功，这样，代表WebSocket的这个TCP连接将不会被服务器关闭，而是一直保持，服务器可随时向浏览器推送消息，浏览器也可随时向服务器推送消息。双方推送的消息既可以是文本消息，也可以是二进制消息，一般来说，绝大部分应用程序会推送基于JSON的文本消息。</p><p>现代浏览器都已经支持WebSocket协议，服务器则需要底层框架支持。Java的Servlet规范从3.1开始支持WebSocket，所以，必须选择支持Servlet 3.1或更高规范的Servlet容器，才能支持WebSocket。最新版本的Tomcat、Jetty等开源服务器均支持WebSocket。</p><p>我们以实际代码演示如何在Spring MVC中实现对WebSocket的支持。首先，我们需要在pom.xml中加入以下依赖：</p><pre><code class="highlight plaintext">org.apache.tomcat.embed:tomcat-embed-websocket:10.1.1org.springframework:spring-websocket:6.0.0</code></pre><p>第一项是嵌入式Tomcat支持WebSocket的组件，第二项是Spring封装的支持WebSocket的接口。</p><p>接下来，我们需要在AppConfig中加入Spring Web对WebSocket的配置，此处我们需要创建一个WebSocketConfigurer实例：</p><pre><code class="highlight plaintext">@BeanWebSocketConfigurer createWebSocketConfigurer(        @Autowired ChatHandler chatHandler,        @Autowired ChatHandshakeInterceptor chatInterceptor)&#123;    return new WebSocketConfigurer() &#123;        public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123;            // 把URL与指定的WebSocketHandler关联，可关联多个:            registry.addHandler(chatHandler, &quot;/chat&quot;).addInterceptors(chatInterceptor);        &#125;    &#125;;&#125;</code></pre><p>此实例在内部通过WebSocketHandlerRegistry注册能处理WebSocket的WebSocketHandler，以及可选的WebSocket拦截器HandshakeInterceptor。我们注入的这两个类都是自己编写的业务逻辑，后面我们详细讨论如何编写它们，这里只需关注浏览器连接到WebSocket的URL是/chat</p><h3 id="处理websocket连接"><a class="markdownIt-Anchor" href="#处理websocket连接"></a> 处理WebSocket连接</h3><p>和处理普通HTTP请求不同，没法用一个方法处理一个URL。Spring提供了TextWebSocketHandler和BinaryWebSocketHandler分别处理文本消息和二进制消息，这里我们选择文本消息作为聊天室的协议，因此，ChatHandler需要继承自TextWebSocketHandler：</p><pre><code class="highlight plaintext">@Componentpublic class ChatHandler extends TextWebSocketHandler &#123;    ...&#125;</code></pre><p>当浏览器请求一个WebSocket连接后，如果成功建立连接，Spring会自动调用afterConnectionEstablished()方法，任何原因导致WebSocket连接中断时，Spring会自动调用afterConnectionClosed方法，因此，覆写这两个方法即可处理连接成功和结束后的业务逻辑：</p><pre><code class="highlight plaintext">@Componentpublic class ChatHandler extends TextWebSocketHandler &#123;    // 保存所有Client的WebSocket会话实例:    private Map&lt;String, WebSocketSession&gt; clients = new ConcurrentHashMap&lt;&gt;();    @Override    public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123;        // 新会话根据ID放入Map:        clients.put(session.getId(), session);        session.getAttributes().put(&quot;name&quot;, &quot;Guest1&quot;);    &#125;    @Override    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception &#123;        clients.remove(session.getId());    &#125;&#125;</code></pre><p>每个WebSocket会话以WebSocketSession表示，且已分配唯一ID。和WebSocket相关的数据，例如用户名称等，均可放入关联的getAttributes()中。</p><p>用实例变量clients持有当前所有的WebSocketSession是为了广播，即向所有用户推送同一消息时，可以这么写：</p><pre><code class="highlight plaintext">String json = ...TextMessage message = new TextMessage(json);for (String id : clients.keySet()) &#123;    WebSocketSession session = clients.get(id);    session.sendMessage(message);&#125;</code></pre><p>我们发送的消息是序列化后的JSON，可以用ChatMessage表示：</p><pre><code class="highlight plaintext">public class ChatMessage &#123;        public long timestamp;        public String name;    public String text;&#125;</code></pre><p>每收到一个用户的消息后，我们就需要广播给所有用户：</p><pre><code class="highlight plaintext">@Componentpublic class ChatHandler extends TextWebSocketHandler &#123;    ...    @Override    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception &#123;        String s = message.getPayload();        String r = ... // 根据输入消息构造待发送消息        broadcastMessage(r); // 推送给所有用户    &#125;&#125;</code></pre><p>如果要推送给指定的几个用户，那就需要在clients中根据条件查找出某些WebSocketSession，然后发送消息。</p><p>注意到我们在注册WebSocket时还传入了一个ChatHandshakeInterceptor，这个类实际上可以从HttpSessionHandshakeInterceptor继承，它的主要作用是在WebSocket建立连接后，把HttpSession的一些属性复制到WebSocketSession，例如，用户的登录信息等：</p><pre><code class="highlight plaintext">@Componentpublic class ChatHandshakeInterceptor extends HttpSessionHandshakeInterceptor &#123;    public ChatHandshakeInterceptor() &#123;        // 指定从HttpSession复制属性到WebSocketSession:        super(List.of(UserController.KEY_USER));    &#125;&#125;</code></pre><p>这样，在ChatHandler中，可以从WebSocketSession.getAttributes()中获取到复制过来的属性。</p><h3 id="客户端开发"><a class="markdownIt-Anchor" href="#客户端开发"></a> 客户端开发</h3><p>在完成了服务器端的开发后，我们还需要在页面编写一点JavaScript逻辑：</p><pre><code class="highlight plaintext">// 创建WebSocket连接:var ws = new WebSocket(&#x27;ws://&#x27; + location.host + &#x27;/chat&#x27;);// 连接成功时:ws.addEventListener(&#x27;open&#x27;, function (event) &#123;    console.log(&#x27;websocket connected.&#x27;);&#125;);// 收到消息时:ws.addEventListener(&#x27;message&#x27;, function (event) &#123;    console.log(&#x27;message: &#x27; + event.data);    var msgs = JSON.parse(event.data);    // TODO:&#125;);// 连接关闭时:ws.addEventListener(&#x27;close&#x27;, function () &#123;    console.log(&#x27;websocket closed.&#x27;);&#125;);// 绑定到全局变量:window.chatWs = ws;</code></pre><p>用户可以在连接成功后任何时候给服务器发送消息：</p><pre><code class="highlight plaintext">var inputText = &#x27;Hello, WebSocket.&#x27;;window.chatWs.send(JSON.stringify(&#123;text: inputText&#125;));</code></pre><h2 id="使用scheduler"><a class="markdownIt-Anchor" href="#使用scheduler"></a> 使用Scheduler</h2><p>我们还是以实际代码为例，建立工程spring-integration-schedule，无需额外的依赖，我们可以直接在AppConfig中加上@<strong>EnableScheduling</strong>就开启了定时任务的支持：</p><pre><code class="highlight plaintext">@Configuration@ComponentScan@EnableWebMvc@EnableScheduling@EnableTransactionManagement@PropertySource(&#123; &quot;classpath:/jdbc.properties&quot;, &quot;classpath:/task.properties&quot; &#125;)public class AppConfig &#123;    ...&#125;</code></pre><p>接下来，我们可以直接在一个Bean中编写一个public void无参数方法，然后加上@Scheduled注解：</p><pre><code class="highlight plaintext">@Componentpublic class TaskService &#123;    final Logger logger = LoggerFactory.getLogger(getClass());    @Scheduled(initialDelay = 60_000, fixedRate = 60_000)    public void checkSystemStatusEveryMinute() &#123;        logger.info(&quot;Start check system status...&quot;);    &#125;&#125;</code></pre><p>上述注解指定了启动延迟60秒，并以60秒的间隔执行任务。现在，我们直接运行应用程序，就可以在控制台看到定时任务打印的日志：</p><pre><code class="highlight plaintext">2020-06-03 18:47:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start check system status...2020-06-03 18:48:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start check system status...2020-06-03 18:49:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start check system status...</code></pre><p>如果没有看到定时任务的日志，需要检查：</p><ul><li>是否忘记了在AppConfig中标注@EnableScheduling；</li><li>是否忘记了在定时任务的方法所在的class标注@Component。</li></ul><p>除了可以使用fixedRate外，还可以使用fixedDelay，两者的区别我们已经在使用线程池一节中讲过，这里不再重复。</p><p>有的童鞋在实际开发中会遇到一个问题，因为Java的注解全部是常量，写死了fixedDelay=30000，如果根据实际情况要改成60秒怎么办，只能重新编译？</p><p>我们可以把定时任务的配置放到配置文件中，例如task.properties：</p><pre><code class="highlight plaintext">task.checkDiskSpace=30000</code></pre><p>这样就可以随时修改配置文件而无需动代码。但是在代码中，我们需要用fixedDelayString取代fixedDelay：</p><pre><code class="highlight plaintext">@Componentpublic class TaskService &#123;    ...    @Scheduled(initialDelay = 30_000, fixedDelayString = &quot;$&#123;task.checkDiskSpace:30000&#125;&quot;)    public void checkDiskSpaceEveryMinute() &#123;        logger.info(&quot;Start check disk space...&quot;);    &#125;&#125;</code></pre><p>注意到上述代码的注解参数fixedDelayString是一个属性占位符，并配有默认值30000，Spring在处理@Scheduled注解时，如果遇到String，会根据占位符自动用配置项替换，这样就可以灵活地修改定时任务的配置。</p><p>此外，fixedDelayString还可以使用更易读的Duration，例如：</p><pre><code class="highlight plaintext">@Scheduled(initialDelay = 30_000, fixedDelayString = &quot;$&#123;task.checkDiskSpace:PT2M30S&#125;&quot;)</code></pre><p>以字符串PT2M30S表示的Duration就是2分30秒，请参考LocalDateTime一节的Duration相关部分。</p><p>多个@Scheduled方法完全可以放到一个Bean中，这样便于统一管理各类定时任务。</p><h3 id="使用cron任务"><a class="markdownIt-Anchor" href="#使用cron任务"></a> 使用Cron任务</h3><p>还有一类定时任务，它不是简单的重复执行，而是按时间触发，我们把这类任务称为Cron任务，例如：</p><ul><li>每天凌晨2:15执行报表任务；</li><li>每个工作日12:00执行特定任务；</li><li>……<br />Cron源自Unix/Linux系统自带的crond守护进程，以一个简洁的表达式定义任务触发时间。在Spring中，也可以使用Cron表达式来执行Cron任务，在Spring中，它的格式是：</li></ul><pre><code class="highlight plaintext">秒 分 小时 天 月份 星期 年</code></pre><p>年是可以忽略的，通常不写。每天凌晨2:15执行的Cron表达式就是：</p><pre><code class="highlight plaintext">0 15 2 * * *</code></pre><p>每个工作日12:00执行的Cron表达式就是：</p><pre><code class="highlight plaintext">0 0 12 * * MON-FRI</code></pre><p>每个月1号，2号，3号和10号12:00执行的Cron表达式就是：</p><pre><code class="highlight plaintext">0 0 12 1-3,10 * *</code></pre><p>在Spring中，我们定义一个每天凌晨2:15执行的任务：</p><pre><code class="highlight plaintext">@Componentpublic class TaskService &#123;    ...    @Scheduled(cron = &quot;$&#123;task.report:0 15 2 * * *&#125;&quot;)    public void cronDailyReport() &#123;        logger.info(&quot;Start daily report task...&quot;);    &#125;&#125;</code></pre><p>Cron任务同样可以使用属性占位符，这样修改起来更加方便。</p><p>Cron表达式还可以表达每10分钟执行，例如：</p><pre><code class="highlight plaintext">0 */10 * * * *</code></pre><p>这样，在每个小时的0:00，10:00，20:00，30:00，40:00，50:00均会执行任务，实际上它可以取代fixedRate类型的定时任务。</p><h3 id="集成quarz"><a class="markdownIt-Anchor" href="#集成quarz"></a> 集成Quarz</h3><p>在Spring中使用定时任务和Cron任务都十分简单，但是要注意到，这些任务的调度都是在每个JVM进程中的。如果在本机启动两个进程，或者在多台机器上启动应用，这些进程的定时任务和Cron任务都是独立运行的，互不影响。</p><p>如果一些定时任务要以集群的方式运行，例如每天23:00执行检查任务，只需要集群中的一台运行即可，这个时候，可以考虑使用Quartz。</p><p>Quartz可以配置一个JDBC数据源，以便存储所有的任务调度计划以及任务执行状态。也可以使用内存来调度任务，但这样配置就和使用Spring的调度没啥区别了，额外集成Quartz的意义就不大。</p><h2 id="spring-mvc源码解析"><a class="markdownIt-Anchor" href="#spring-mvc源码解析"></a> Spring MVC源码解析</h2><h3 id="知识储备"><a class="markdownIt-Anchor" href="#知识储备"></a> 知识储备</h3><h4 id="servlet的生命周期方法"><a class="markdownIt-Anchor" href="#servlet的生命周期方法"></a> Servlet的生命周期方法</h4><p>init：Servlet对象创建之后调用</p><p>service：Servlet对象被HTTP请求访问时调用</p><p>destroy：Servlet对象销毁之前调用</p><h4 id="dispatcherservlet继承体系"><a class="markdownIt-Anchor" href="#dispatcherservlet继承体系"></a> DispatcherServlet继承体系</h4><h4 id="initializingbean接口介绍"><a class="markdownIt-Anchor" href="#initializingbean接口介绍"></a> InitializingBean接口介绍</h4><p>Spring有两种Bean的初始化（不是实例化）方法：</p><ul><li>一种时实现InitializingBean接口</li><li>一种是通过反射调用Bean标签中的init-method属性指定的方法</li></ul><blockquote><p>不同点：接口比配置效率高，但是配置消除了对spring的依赖</p></blockquote><p><strong>InitializingBean</strong>接口为bean提供了初始化方法的方式</p><ul><li>它只包括<strong>afterPropertiesSet</strong>方法</li><li>凡是实现该接口的类，在<strong>初始化bean</strong>的时候会执行该方法</li></ul><p>实现InitializingBean接口与在配置文件中指定init-method有什么不同？</p><ul><li>系统先调用afterPropertiesSet方法</li><li>然后再调用init-method方法</li></ul><h3 id="主流程dispatcherservlet"><a class="markdownIt-Anchor" href="#主流程dispatcherservlet"></a> 主流程DispatcherServlet</h3><h3 id="处理器映射器"><a class="markdownIt-Anchor" href="#处理器映射器"></a> 处理器映射器</h3><h3 id="处理器适配器"><a class="markdownIt-Anchor" href="#处理器适配器"></a> 处理器适配器</h3><h3 id="视图解析器"><a class="markdownIt-Anchor" href="#视图解析器"></a> 视图解析器</h3><h3 id="mvcannotation-driver"><a class="markdownIt-Anchor" href="#mvcannotation-driver"></a> mvc:annotation-driver</h3><h3 id="异常处理流程"><a class="markdownIt-Anchor" href="#异常处理流程"></a> 异常处理流程</h3><h3 id="文件上传流程"><a class="markdownIt-Anchor" href="#文件上传流程"></a> 文件上传流程</h3><h1 id="ssm整合"><a class="markdownIt-Anchor" href="#ssm整合"></a> SSM整合</h1><h2 id="系统分层"><a class="markdownIt-Anchor" href="#系统分层"></a> 系统分层</h2><h3 id="如何分层"><a class="markdownIt-Anchor" href="#如何分层"></a> 如何分层</h3><ul><li>把MVC中的VC合并为表示层，M拆分为业务层和持久层</li><li>上一层通过接口调用下一层提供的服务</li><li><h2 id="下一层发生变化不影响上层的代码方便代码的维护"><a class="markdownIt-Anchor" href="#下一层发生变化不影响上层的代码方便代码的维护"></a> 下一层发生变化，不影响上层的代码，方便代码的维护</h2></li></ul><h4 id="表现层"><a class="markdownIt-Anchor" href="#表现层"></a> 表现层</h4><ul><li>数据展现和控制逻辑（请求分发），表示层也就是web层，负责http响应</li><li>表现曾包括展示层和控制层，控制层负责接受请求，展示层负责结果的展示</li><li><strong>表现层的设计一般都使用MVC模型（MVC是表现层的设计模型，和其他层没有关系）</strong></li></ul><h4 id="业务层service"><a class="markdownIt-Anchor" href="#业务层service"></a> 业务层Service</h4><ul><li>业务逻辑的处理，和开发项目的需求息息相关</li><li>业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的， 事务应该放到业务层来控制）</li></ul><h4 id="持久层dao"><a class="markdownIt-Anchor" href="#持久层dao"></a> 持久层DAO</h4><ul><li>数据访问，负责数据持久化，就是和数据库交互，对数据库表进行增上改查的</li></ul><h2 id="ssm框架整合"><a class="markdownIt-Anchor" href="#ssm框架整合"></a> SSM框架整合</h2><h3 id="整合思路"><a class="markdownIt-Anchor" href="#整合思路"></a> 整合思路</h3><p>将工程的三层结构中的JavaBean分别使用Spring容器（通过XML方式）进行管理。</p><ol><li>整合持久层mapper，包括数据源、会话工程及mapper代理对象的整合；</li><li>整合业务层Service，包括事务及service的bean的配置；</li><li>整合表现层Controller，直接使用springmvc的配置。</li><li>Web.xml加载spring容器（包含多个XML文件）</li></ol><h3 id="工程搭建maven依赖"><a class="markdownIt-Anchor" href="#工程搭建maven依赖"></a> 工程搭建（maven依赖）</h3><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.lee&lt;/groupId&gt;    &lt;artifactId&gt;ssmDemo&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;name&gt;ssmDemo Maven Webapp&lt;/name&gt;    &lt;!-- FIXME change it to the project&#x27;s website --&gt;    &lt;url&gt;http://www.example.com&lt;/url&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!-- 持久层依赖 开始 --&gt;        &lt;!-- spring ioc组件需要的依赖包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- spring 事务管理和JDBC依赖包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- mysql数据库驱动包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.35&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- dbcp连接池的依赖包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;            &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;            &lt;version&gt;1.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- mybatis依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.5&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- mybatis和spring的整合依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;1.3.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 持久层依赖 结束 --&gt;        &lt;!-- 业务层依赖 开始 --&gt;        &lt;!-- 基于AspectJ的aop依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;aopalliance&lt;/groupId&gt;            &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;            &lt;version&gt;1.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 业务层依赖 结束 --&gt;        &lt;!-- 表现层依赖 开始 --&gt;        &lt;!-- spring MVC依赖包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- jstl 取决于视图对象是否是JSP --&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;jstl&lt;/artifactId&gt;            &lt;version&gt;1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 使用Mock测试需要使用该高版本的servlet-api --&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;version&gt;3.1.0&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!--@ResponsBody相关注解需要的jar包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--@ResponsBody相关注解需要的jar包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;            &lt;version&gt;2.9.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 表现层依赖 结束 --&gt;        &lt;!-- spring 单元测试组件包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 单元测试Junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 文件上传 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;            &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;            &lt;version&gt;1.3.1&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;finalName&gt;ssmDemo&lt;/finalName&gt;        &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;            &lt;plugins&gt;                &lt;!-- 配置Maven的JDK编译级别 --&gt;                &lt;plugin&gt;                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                    &lt;version&gt;3.2&lt;/version&gt;                    &lt;configuration&gt;                        &lt;source&gt;1.8&lt;/source&gt;                        &lt;target&gt;1.8&lt;/target&gt;                        &lt;encoding&gt;UTF-8&lt;/encoding&gt;                    &lt;/configuration&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;                    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;                    &lt;version&gt;2.2&lt;/version&gt;                    &lt;configuration&gt;                        &lt;port&gt;8080&lt;/port&gt;                    &lt;/configuration&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;                    &lt;version&gt;3.1.0&lt;/version&gt;                &lt;/plugin&gt;                &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;                    &lt;version&gt;3.0.2&lt;/version&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                    &lt;version&gt;3.8.0&lt;/version&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;                    &lt;version&gt;2.22.1&lt;/version&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;                    &lt;version&gt;3.2.2&lt;/version&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;                    &lt;version&gt;2.5.2&lt;/version&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;                    &lt;version&gt;2.8.2&lt;/version&gt;                &lt;/plugin&gt;            &lt;/plugins&gt;        &lt;/pluginManagement&gt;        &lt;!--maven默认不加载xml非resources目录下的xml文件，Mapper文件就无法加载，所以得加上如下配置--&gt;        &lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/java&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;/includes&gt;                &lt;filtering&gt;true&lt;/filtering&gt;            &lt;/resource&gt;        &lt;/resources&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><h3 id="工程整合配置文件"><a class="markdownIt-Anchor" href="#工程整合配置文件"></a> 工程整合（配置文件）</h3><h4 id="webxml"><a class="markdownIt-Anchor" href="#webxml"></a> web.xml</h4><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;         version=&quot;2.5&quot;&gt;  &lt;!-- 配置前端控制器加载spring子容器 --&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;ssm&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;ssm&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;  &lt;!-- 配置ContextLoaderListener监听器加载spring父容器 --&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;      classpath:spring/applicationContext-*.xml    &lt;/param-value&gt;  &lt;/context-param&gt;  &lt;!-- 监听器 --&gt;  &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;!-- POST乱码过滤器 --&gt;  &lt;filter&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;utf-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;&lt;/web-app&gt;</code></pre><h4 id="整合mapper"><a class="markdownIt-Anchor" href="#整合mapper"></a> 整合mapper</h4><p>applicationContext-dao.xml</p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!-- 读取java配置文件，替换占位符数据 --&gt;&lt;context:property-placeholderlocation=&quot;classpath:db.properties&quot; /&gt;&lt;!-- 配置数据源 --&gt;&lt;bean id=&quot;dataSource&quot;class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;&lt;property name=&quot;driverClassName&quot;value=&quot;$&#123;db.driverClassName&#125;&quot; /&gt;&lt;property name=&quot;url&quot; value=&quot;$&#123;db.url&#125;&quot; /&gt;&lt;property name=&quot;username&quot; value=&quot;$&#123;db.username&#125;&quot; /&gt;&lt;property name=&quot;password&quot; value=&quot;$&#123;db.password&#125;&quot; /&gt;&lt;/bean&gt;&lt;!-- 配置SqlSessionFactory --&gt;&lt;bean id=&quot;sqlSessionFactory&quot;class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;&lt;!-- 注入dataSource --&gt;&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;!-- mybatis批量别名配置 --&gt;&lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.lee.pojo&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 批量代理对象的生成 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;&lt;!-- 指定需要生成代理的接口所在的包名 --&gt;&lt;property name=&quot;basePackage&quot; value=&quot;com.lee.mapper&quot;&gt;&lt;/property&gt;&lt;!--使用下面配置会报错，因为使用ref会没等到$占位符号赋值就直接创建sqlSessionFactory--&gt;&lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;&lt;!--使用下面配置就不会报错sql,SessionFactory属性可以不用指定，会以Autowired方式自动注入--&gt;&lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><p>db.properties</p><pre><code class="highlight plaintext">db.driverClassName=com.mysql.jdbc.Driverdb.url=jdbc:mysql://localhost:3306/leessm?characterEncoding=UTF-8db.username=rootdb.password=123456</code></pre><p>log4j.properties</p><pre><code class="highlight plaintext">#dev env [debug] product env [info]log4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</code></pre><h4 id="整合service"><a class="markdownIt-Anchor" href="#整合service"></a> 整合Service</h4><p>applicationContext-service.xml</p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!-- 扫描业务bean --&gt;&lt;context:component-scan base-package=&quot;com.lee.service&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt;</code></pre><p>applicationContext-tx.xml（事务相关）</p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!-- 配置平台事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot;class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 事务通知 --&gt;&lt;!-- tx:advice：对应的处理器类就是TransactionInterceptor类（实现了MethodInterceptor） --&gt;&lt;!-- TransactionInterceptor类实现事务是通过transaction-manager属性指定的值进行事务管理 --&gt;&lt;tx:advice id=&quot;txAdvice&quot;transaction-manager=&quot;transactionManager&quot;&gt;&lt;!-- 设置事务管理信息 --&gt;&lt;tx:attributes&gt;&lt;!-- 增删改使用REQUIRED事务传播行为 --&gt;&lt;!-- 查询使用read-only --&gt;&lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;tx:method name=&quot;create*&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;tx:method name=&quot;remove*&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;tx:method name=&quot;del*&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;tx:method name=&quot;modify*&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;tx:method name=&quot;edit*&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot;/&gt;&lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;&lt;tx:method name=&quot;select*&quot; read-only=&quot;true&quot;/&gt;&lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 基于AspectJ + XML方式实现声明式事务 --&gt;&lt;aop:config&gt;&lt;!-- aop:advisor标签使用的是传统spring aop开发方式实现的 --&gt;&lt;!-- spring已经实现了该增强功能，spring使用的是实现MethodInterceptor接口的方式实现的 --&gt;&lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* *..*.*ServiceImpl.*(..))&quot; /&gt;&lt;/aop:config&gt;&lt;/beans&gt;</code></pre><h4 id="整合controller"><a class="markdownIt-Anchor" href="#整合controller"></a> 整合controller</h4><p>springmvc.xml</p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!-- 处理器类的扫描 --&gt;&lt;context:component-scanbase-package=&quot;com.lee.controller&quot; /&gt;&lt;!-- 配置注解的适配器和映射器，同时还注入了很多其他的bean --&gt;&lt;!-- 处理器适配器会去调用conversion-service --&gt;&lt;mvc:annotation-driven/&gt;    &lt;!-- 显式的配置视图解析器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/item/&quot;&gt;&lt;/property&gt;&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><h3 id="整合测试编写代码"><a class="markdownIt-Anchor" href="#整合测试编写代码"></a> 整合测试（编写代码）</h3><h4 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h4><pre><code class="highlight plaintext">CREATE TABLE `leessm`.`Untitled`  (  `id` int(10),  `name` varchar(20) ,  `price` float,  `pic` varchar(20) ,  `createtime` datetime ,  `detail` varchar(100) ) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;</code></pre><h4 id="持久层"><a class="markdownIt-Anchor" href="#持久层"></a> 持久层</h4><p>持久层相关代码使用mybatis逆向工程生成</p><h5 id="pojo"><a class="markdownIt-Anchor" href="#pojo"></a> pojo</h5><p>Item.java</p><pre><code class="highlight plaintext">package com.lee.pojo;import java.util.Date;public class Item &#123;    private Integer id;    private String name;    private Float price;    private String pic;    private Date createtime;    private String detail;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name == null ? null : name.trim();    &#125;    public Float getPrice() &#123;        return price;    &#125;    public void setPrice(Float price) &#123;        this.price = price;    &#125;    public String getPic() &#123;        return pic;    &#125;    public void setPic(String pic) &#123;        this.pic = pic == null ? null : pic.trim();    &#125;    public Date getCreatetime() &#123;        return createtime;    &#125;    public void setCreatetime(Date createtime) &#123;        this.createtime = createtime;    &#125;    public String getDetail() &#123;        return detail;    &#125;    public void setDetail(String detail) &#123;        this.detail = detail == null ? null : detail.trim();    &#125;    @Override    public String toString() &#123;        return &quot;Item&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +                &quot;, price=&quot; + price +                &quot;, pic=&#x27;&quot; + pic + &#x27;\&#x27;&#x27; +                &quot;, createtime=&quot; + createtime +                &quot;, detail=&#x27;&quot; + detail + &#x27;\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;</code></pre><p>ItemExample.java</p><pre><code class="highlight plaintext">package com.lee.pojo;import java.util.ArrayList;import java.util.Date;import java.util.List;public class ItemExample &#123;    protected String orderByClause;    protected boolean distinct;    protected List&lt;Criteria&gt; oredCriteria;    public ItemExample() &#123;        oredCriteria = new ArrayList&lt;Criteria&gt;();    &#125;    public void setOrderByClause(String orderByClause) &#123;        this.orderByClause = orderByClause;    &#125;    public String getOrderByClause() &#123;        return orderByClause;    &#125;    public void setDistinct(boolean distinct) &#123;        this.distinct = distinct;    &#125;    public boolean isDistinct() &#123;        return distinct;    &#125;    public List&lt;Criteria&gt; getOredCriteria() &#123;        return oredCriteria;    &#125;    public void or(Criteria criteria) &#123;        oredCriteria.add(criteria);    &#125;    public Criteria or() &#123;        Criteria criteria = createCriteriaInternal();        oredCriteria.add(criteria);        return criteria;    &#125;    public Criteria createCriteria() &#123;        Criteria criteria = createCriteriaInternal();        if (oredCriteria.size() == 0) &#123;            oredCriteria.add(criteria);        &#125;        return criteria;    &#125;    protected Criteria createCriteriaInternal() &#123;        Criteria criteria = new Criteria();        return criteria;    &#125;    public void clear() &#123;        oredCriteria.clear();        orderByClause = null;        distinct = false;    &#125;    protected abstract static class GeneratedCriteria &#123;        protected List&lt;Criterion&gt; criteria;        protected GeneratedCriteria() &#123;            super();            criteria = new ArrayList&lt;Criterion&gt;();        &#125;        public boolean isValid() &#123;            return criteria.size() &gt; 0;        &#125;        public List&lt;Criterion&gt; getAllCriteria() &#123;            return criteria;        &#125;        public List&lt;Criterion&gt; getCriteria() &#123;            return criteria;        &#125;        protected void addCriterion(String condition) &#123;            if (condition == null) &#123;                throw new RuntimeException(&quot;Value for condition cannot be null&quot;);            &#125;            criteria.add(new Criterion(condition));        &#125;        protected void addCriterion(String condition, Object value, String property) &#123;            if (value == null) &#123;                throw new RuntimeException(&quot;Value for &quot; + property + &quot; cannot be null&quot;);            &#125;            criteria.add(new Criterion(condition, value));        &#125;        protected void addCriterion(String condition, Object value1, Object value2, String property) &#123;            if (value1 == null || value2 == null) &#123;                throw new RuntimeException(&quot;Between values for &quot; + property + &quot; cannot be null&quot;);            &#125;            criteria.add(new Criterion(condition, value1, value2));        &#125;        public Criteria andIdIsNull() &#123;            addCriterion(&quot;id is null&quot;);            return (Criteria) this;        &#125;        public Criteria andIdIsNotNull() &#123;            addCriterion(&quot;id is not null&quot;);            return (Criteria) this;        &#125;        public Criteria andIdEqualTo(Integer value) &#123;            addCriterion(&quot;hljs-string&quot; style=&quot;color: #d69d85; line-height: 160%; box-sizing: content-box;&quot;&gt;&quot;id&quot;);            return (Criteria) this;        &#125;        public Criteria andIdNotEqualTo(Integer value) &#123;            addCriterion(&quot;id &lt;&gt;&quot;, value, &quot;id&quot;);            return (Criteria) this;        &#125;        public Criteria andIdGreaterThan(Integer value) &#123;            addCriterion(&quot;id &gt;&quot;, value, &quot;id&quot;);            return (Criteria) this;        &#125;        public Criteria andIdGreaterThanOrEqualTo(Integer value) &#123;            addCriterion(&quot;id &gt;=&quot;, value, &quot;id&quot;);            return (Criteria) this;        &#125;        public Criteria andIdLessThan(Integer value) &#123;            addCriterion(&quot;id &lt;&quot;, value, &quot;id&quot;);            return (Criteria) this;        &#125;        public Criteria andIdLessThanOrEqualTo(Integer value) &#123;            addCriterion(&quot;id &lt;=&quot;, value, &quot;id&quot;);            return (Criteria) this;        &#125;        public Criteria andIdIn(List&lt;Integer&gt; values) &#123;            addCriterion(&quot;id in&quot;, values, &quot;id&quot;);            return (Criteria) this;        &#125;        public Criteria andIdNotIn(List&lt;Integer&gt; values) &#123;            addCriterion(&quot;id not in&quot;, values, &quot;id&quot;);            return (Criteria) this;        &#125;        public Criteria andIdBetween(Integer value1, Integer value2) &#123;            addCriterion(&quot;id between&quot;, value1, value2, &quot;id&quot;);            return (Criteria) this;        &#125;        public Criteria andIdNotBetween(Integer value1, Integer value2) &#123;            addCriterion(&quot;id not between&quot;, value1, value2, &quot;id&quot;);            return (Criteria) this;        &#125;        public Criteria andNameIsNull() &#123;            addCriterion(&quot;name is null&quot;);            return (Criteria) this;        &#125;        public Criteria andNameIsNotNull() &#123;            addCriterion(&quot;name is not null&quot;);            return (Criteria) this;        &#125;        public Criteria andNameEqualTo(String value) &#123;            addCriterion(&quot;name =&quot;, value, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andNameNotEqualTo(String value) &#123;            addCriterion(&quot;name &lt;&gt;&quot;, value, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andNameGreaterThan(String value) &#123;            addCriterion(&quot;name &gt;&quot;, value, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andNameGreaterThanOrEqualTo(String value) &#123;            addCriterion(&quot;name &gt;=&quot;, value, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andNameLessThan(String value) &#123;            addCriterion(&quot;name &lt;&quot;, value, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andNameLessThanOrEqualTo(String value) &#123;            addCriterion(&quot;name &lt;=&quot;, value, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andNameLike(String value) &#123;            addCriterion(&quot;name like&quot;, value, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andNameNotLike(String value) &#123;            addCriterion(&quot;name not like&quot;, value, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andNameIn(List&lt;String&gt; values) &#123;            addCriterion(&quot;name in&quot;, values, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andNameNotIn(List&lt;String&gt; values) &#123;            addCriterion(&quot;name not in&quot;, values, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andNameBetween(String value1, String value2) &#123;            addCriterion(&quot;name between&quot;, value1, value2, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andNameNotBetween(String value1, String value2) &#123;            addCriterion(&quot;name not between&quot;, value1, value2, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceIsNull() &#123;            addCriterion(&quot;price is null&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceIsNotNull() &#123;            addCriterion(&quot;price is not null&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceEqualTo(Float value) &#123;            addCriterion(&quot;price =&quot;, value, &quot;price&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceNotEqualTo(Float value) &#123;            addCriterion(&quot;price &lt;&gt;&quot;, value, &quot;price&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceGreaterThan(Float value) &#123;            addCriterion(&quot;price &gt;&quot;, value, &quot;price&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceGreaterThanOrEqualTo(Float value) &#123;            addCriterion(&quot;price &gt;=&quot;, value, &quot;price&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceLessThan(Float value) &#123;            addCriterion(&quot;price &lt;&quot;, value, &quot;price&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceLessThanOrEqualTo(Float value) &#123;            addCriterion(&quot;price &lt;=&quot;, value, &quot;price&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceIn(List&lt;Float&gt; values) &#123;            addCriterion(&quot;price in&quot;, values, &quot;price&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceNotIn(List&lt;Float&gt; values) &#123;            addCriterion(&quot;price not in&quot;, values, &quot;price&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceBetween(Float value1, Float value2) &#123;            addCriterion(&quot;price between&quot;, value1, value2, &quot;price&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceNotBetween(Float value1, Float value2) &#123;            addCriterion(&quot;price not between&quot;, value1, value2, &quot;price&quot;);            return (Criteria) this;        &#125;        public Criteria andPicIsNull() &#123;            addCriterion(&quot;pic is null&quot;);            return (Criteria) this;        &#125;        public Criteria andPicIsNotNull() &#123;            addCriterion(&quot;pic is not null&quot;);            return (Criteria) this;        &#125;        public Criteria andPicEqualTo(String value) &#123;            addCriterion(&quot;pic =&quot;, value, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andPicNotEqualTo(String value) &#123;            addCriterion(&quot;pic &lt;&gt;&quot;, value, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andPicGreaterThan(String value) &#123;            addCriterion(&quot;pic &gt;&quot;, value, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andPicGreaterThanOrEqualTo(String value) &#123;            addCriterion(&quot;pic &gt;=&quot;, value, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andPicLessThan(String value) &#123;            addCriterion(&quot;pic &lt;&quot;, value, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andPicLessThanOrEqualTo(String value) &#123;            addCriterion(&quot;pic &lt;=&quot;, value, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andPicLike(String value) &#123;            addCriterion(&quot;pic like&quot;, value, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andPicNotLike(String value) &#123;            addCriterion(&quot;pic not like&quot;, value, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andPicIn(List&lt;String&gt; values) &#123;            addCriterion(&quot;pic in&quot;, values, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andPicNotIn(List&lt;String&gt; values) &#123;            addCriterion(&quot;pic not in&quot;, values, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andPicBetween(String value1, String value2) &#123;            addCriterion(&quot;pic between&quot;, value1, value2, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andPicNotBetween(String value1, String value2) &#123;            addCriterion(&quot;pic not between&quot;, value1, value2, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeIsNull() &#123;            addCriterion(&quot;createtime is null&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeIsNotNull() &#123;            addCriterion(&quot;createtime is not null&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeEqualTo(Date value) &#123;            addCriterion(&quot;createtime =&quot;, value, &quot;createtime&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeNotEqualTo(Date value) &#123;            addCriterion(&quot;createtime &lt;&gt;&quot;, value, &quot;createtime&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeGreaterThan(Date value) &#123;            addCriterion(&quot;createtime &gt;&quot;, value, &quot;createtime&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeGreaterThanOrEqualTo(Date value) &#123;            addCriterion(&quot;createtime &gt;=&quot;, value, &quot;createtime&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeLessThan(Date value) &#123;            addCriterion(&quot;createtime &lt;&quot;, value, &quot;createtime&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeLessThanOrEqualTo(Date value) &#123;            addCriterion(&quot;createtime &lt;=&quot;, value, &quot;createtime&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeIn(List&lt;Date&gt; values) &#123;            addCriterion(&quot;createtime in&quot;, values, &quot;createtime&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeNotIn(List&lt;Date&gt; values) &#123;            addCriterion(&quot;createtime not in&quot;, values, &quot;createtime&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeBetween(Date value1, Date value2) &#123;            addCriterion(&quot;createtime between&quot;, value1, value2, &quot;createtime&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeNotBetween(Date value1, Date value2) &#123;            addCriterion(&quot;createtime not between&quot;, value1, value2, &quot;createtime&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailIsNull() &#123;            addCriterion(&quot;detail is null&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailIsNotNull() &#123;            addCriterion(&quot;detail is not null&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailEqualTo(String value) &#123;            addCriterion(&quot;detail =&quot;, value, &quot;detail&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailNotEqualTo(String value) &#123;            addCriterion(&quot;detail &lt;&gt;&quot;, value, &quot;detail&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailGreaterThan(String value) &#123;            addCriterion(&quot;detail &gt;&quot;, value, &quot;detail&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailGreaterThanOrEqualTo(String value) &#123;            addCriterion(&quot;detail &gt;=&quot;, value, &quot;detail&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailLessThan(String value) &#123;            addCriterion(&quot;detail &lt;&quot;, value, &quot;detail&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailLessThanOrEqualTo(String value) &#123;            addCriterion(&quot;detail &lt;=&quot;, value, &quot;detail&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailLike(String value) &#123;            addCriterion(&quot;detail like&quot;, value, &quot;detail&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailNotLike(String value) &#123;            addCriterion(&quot;detail not like&quot;, value, &quot;detail&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailIn(List&lt;String&gt; values) &#123;            addCriterion(&quot;detail in&quot;, values, &quot;detail&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailNotIn(List&lt;String&gt; values) &#123;            addCriterion(&quot;detail not in&quot;, values, &quot;detail&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailBetween(String value1, String value2) &#123;            addCriterion(&quot;detail between&quot;, value1, value2, &quot;detail&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailNotBetween(String value1, String value2) &#123;            addCriterion(&quot;detail not between&quot;, value1, value2, &quot;detail&quot;);            return (Criteria) this;        &#125;    &#125;    public static class Criteria extends GeneratedCriteria &#123;        protected Criteria() &#123;            super();        &#125;    &#125;    public static class Criterion &#123;        private String condition;        private Object value;        private Object secondValue;        private boolean noValue;        private boolean singleValue;        private boolean betweenValue;        private boolean listValue;        private String typeHandler;        public String getCondition() &#123;            return condition;        &#125;        public Object getValue() &#123;            return value;        &#125;        public Object getSecondValue() &#123;            return secondValue;        &#125;        public boolean isNoValue() &#123;            return noValue;        &#125;        public boolean isSingleValue() &#123;            return singleValue;        &#125;        public boolean isBetweenValue() &#123;            return betweenValue;        &#125;        public boolean isListValue() &#123;            return listValue;        &#125;        public String getTypeHandler() &#123;            return typeHandler;        &#125;        protected Criterion(String condition) &#123;            super();            this.condition = condition;            this.typeHandler = null;            this.noValue = true;        &#125;        protected Criterion(String condition, Object value, String typeHandler) &#123;            super();            this.condition = condition;            this.value = value;            this.typeHandler = typeHandler;            if (value instanceof List&lt;?&gt;) &#123;                this.listValue = true;            &#125; else &#123;                this.singleValue = true;            &#125;        &#125;        protected Criterion(String condition, Object value) &#123;            this(condition, value, null);        &#125;        protected Criterion(String condition, Object value, Object secondValue, String typeHandler) &#123;            super();            this.condition = condition;            this.value = value;            this.secondValue = secondValue;            this.typeHandler = typeHandler;            this.betweenValue = true;        &#125;        protected Criterion(String condition, Object value, Object secondValue) &#123;            this(condition, value, secondValue, null);        &#125;    &#125;&#125;</code></pre><h5 id="mapper"><a class="markdownIt-Anchor" href="#mapper"></a> mapper</h5><p>ItemMapper.java</p><pre><code class="highlight plaintext">package com.lee.mapper;import java.util.List;import com.lee.pojo.Item;import com.lee.pojo.ItemExample;import org.apache.ibatis.annotations.Param;public interface ItemMapper &#123;    int countByExample(ItemExample example);    int deleteByExample(ItemExample example);    int insert(Item record);    int insertSelective(Item record);    List&lt;Item&gt; selectByExample(ItemExample example);    int updateByExampleSelective(@Param(&quot;record&quot;) Item record, @Param(&quot;example&quot;) ItemExample example);    int updateByExample(@Param(&quot;record&quot;) Item record, @Param(&quot;example&quot;) ItemExample example);&#125;</code></pre><p>ItemMapper.xml</p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.lee.mapper.ItemMapper&quot; &gt;  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.lee.pojo.Item&quot; &gt;    &lt;result column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot; /&gt;    &lt;result column=&quot;name&quot; property=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; /&gt;    &lt;result column=&quot;price&quot; property=&quot;price&quot; jdbcType=&quot;REAL&quot; /&gt;    &lt;result column=&quot;pic&quot; property=&quot;pic&quot; jdbcType=&quot;VARCHAR&quot; /&gt;    &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;    &lt;result column=&quot;detail&quot; property=&quot;detail&quot; jdbcType=&quot;VARCHAR&quot; /&gt;  &lt;/resultMap&gt;  &lt;sql id=&quot;Example_Where_Clause&quot; &gt;    &lt;where &gt;      &lt;foreach collection=&quot;oredCriteria&quot; item=&quot;criteria&quot; separator=&quot;or&quot; &gt;        &lt;if test=&quot;criteria.valid&quot; &gt;          &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; prefixOverrides=&quot;and&quot; &gt;            &lt;foreach collection=&quot;criteria.criteria&quot; item=&quot;criterion&quot; &gt;              &lt;choose &gt;                &lt;when test=&quot;criterion.noValue&quot; &gt;                  and $&#123;criterion.condition&#125;                &lt;/when&gt;                &lt;when test=&quot;criterion.singleValue&quot; &gt;                  and $&#123;criterion.condition&#125; #&#123;criterion.value&#125;                &lt;/when&gt;                &lt;when test=&quot;criterion.betweenValue&quot; &gt;                  and $&#123;criterion.condition&#125; #&#123;criterion.value&#125; and #&#123;criterion.secondValue&#125;                &lt;/when&gt;                &lt;when test=&quot;criterion.listValue&quot; &gt;                  and $&#123;criterion.condition&#125;                  &lt;foreach collection=&quot;criterion.value&quot; item=&quot;listItem&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot; &gt;                    #&#123;listItem&#125;                  &lt;/foreach&gt;                &lt;/when&gt;              &lt;/choose&gt;            &lt;/foreach&gt;          &lt;/trim&gt;        &lt;/if&gt;      &lt;/foreach&gt;    &lt;/where&gt;  &lt;/sql&gt;  &lt;sql id=&quot;Update_By_Example_Where_Clause&quot; &gt;    &lt;where &gt;      &lt;foreach collection=&quot;example.oredCriteria&quot; item=&quot;criteria&quot; separator=&quot;or&quot; &gt;        &lt;if test=&quot;criteria.valid&quot; &gt;          &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; prefixOverrides=&quot;and&quot; &gt;            &lt;foreach collection=&quot;criteria.criteria&quot; item=&quot;criterion&quot; &gt;              &lt;choose &gt;                &lt;when test=&quot;criterion.noValue&quot; &gt;                  and $&#123;criterion.condition&#125;                &lt;/when&gt;                &lt;when test=&quot;criterion.singleValue&quot; &gt;                  and $&#123;criterion.condition&#125; #&#123;criterion.value&#125;                &lt;/when&gt;                &lt;when test=&quot;criterion.betweenValue&quot; &gt;                  and $&#123;criterion.condition&#125; #&#123;criterion.value&#125; and #&#123;criterion.secondValue&#125;                &lt;/when&gt;                &lt;when test=&quot;criterion.listValue&quot; &gt;                  and $&#123;criterion.condition&#125;                  &lt;foreach collection=&quot;criterion.value&quot; item=&quot;listItem&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot; &gt;                    #&#123;listItem&#125;                  &lt;/foreach&gt;                &lt;/when&gt;              &lt;/choose&gt;            &lt;/foreach&gt;          &lt;/trim&gt;        &lt;/if&gt;      &lt;/foreach&gt;    &lt;/where&gt;  &lt;/sql&gt;  &lt;sql id=&quot;Base_Column_List&quot; &gt;    id, name, price, pic, createtime, detail  &lt;/sql&gt;  &lt;select id=&quot;selectByExample&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;com.lee.pojo.ItemExample&quot; &gt;    select    &lt;if test=&quot;distinct&quot; &gt;      distinct    &lt;/if&gt;    &lt;include refid=&quot;Base_Column_List&quot; /&gt;    from item    &lt;if test=&quot;_parameter != null&quot; &gt;      &lt;include refid=&quot;Example_Where_Clause&quot; /&gt;    &lt;/if&gt;    &lt;if test=&quot;orderByClause != null&quot; &gt;      order by $&#123;orderByClause&#125;    &lt;/if&gt;  &lt;/select&gt;  &lt;delete id=&quot;deleteByExample&quot; parameterType=&quot;com.lee.pojo.ItemExample&quot; &gt;    delete from item    &lt;if test=&quot;_parameter != null&quot; &gt;      &lt;include refid=&quot;Example_Where_Clause&quot; /&gt;    &lt;/if&gt;  &lt;/delete&gt;  &lt;insert id=&quot;insert&quot; parameterType=&quot;com.lee.pojo.Item&quot; &gt;    insert into item (id, name, price,       pic, createtime, detail      )    values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;name,jdbcType=VARCHAR&#125;, #&#123;price,jdbcType=REAL&#125;,       #&#123;pic,jdbcType=VARCHAR&#125;, #&#123;createtime,jdbcType=TIMESTAMP&#125;, #&#123;detail,jdbcType=VARCHAR&#125;      )  &lt;/insert&gt;  &lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.lee.pojo.Item&quot; &gt;    insert into item    &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot; &gt;      &lt;if test=&quot;id != null&quot; &gt;        id,      &lt;/if&gt;      &lt;if test=&quot;name != null&quot; &gt;        name,      &lt;/if&gt;      &lt;if test=&quot;price != null&quot; &gt;        price,      &lt;/if&gt;      &lt;if test=&quot;pic != null&quot; &gt;        pic,      &lt;/if&gt;      &lt;if test=&quot;createtime != null&quot; &gt;        createtime,      &lt;/if&gt;      &lt;if test=&quot;detail != null&quot; &gt;        detail,      &lt;/if&gt;    &lt;/trim&gt;    &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot; &gt;      &lt;if test=&quot;id != null&quot; &gt;        #&#123;id,jdbcType=INTEGER&#125;,      &lt;/if&gt;      &lt;if test=&quot;name != null&quot; &gt;        #&#123;name,jdbcType=VARCHAR&#125;,      &lt;/if&gt;      &lt;if test=&quot;price != null&quot; &gt;        #&#123;price,jdbcType=REAL&#125;,      &lt;/if&gt;      &lt;if test=&quot;pic != null&quot; &gt;        #&#123;pic,jdbcType=VARCHAR&#125;,      &lt;/if&gt;      &lt;if test=&quot;createtime != null&quot; &gt;        #&#123;createtime,jdbcType=TIMESTAMP&#125;,      &lt;/if&gt;      &lt;if test=&quot;detail != null&quot; &gt;        #&#123;detail,jdbcType=VARCHAR&#125;,      &lt;/if&gt;    &lt;/trim&gt;  &lt;/insert&gt;  &lt;select id=&quot;countByExample&quot; parameterType=&quot;com.lee.pojo.ItemExample&quot; resultType=&quot;java.lang.Integer&quot; &gt;    select count(*) from item    &lt;if test=&quot;_parameter != null&quot; &gt;      &lt;include refid=&quot;Example_Where_Clause&quot; /&gt;    &lt;/if&gt;  &lt;/select&gt;  &lt;update id=&quot;updateByExampleSelective&quot; parameterType=&quot;map&quot; &gt;    update item    &lt;set &gt;      &lt;if test=&quot;record.id != null&quot; &gt;        id = #&#123;record.id,jdbcType=INTEGER&#125;,      &lt;/if&gt;      &lt;if test=&quot;record.name != null&quot; &gt;        name = #&#123;record.name,jdbcType=VARCHAR&#125;,      &lt;/if&gt;      &lt;if test=&quot;record.price != null&quot; &gt;        price = #&#123;record.price,jdbcType=REAL&#125;,      &lt;/if&gt;      &lt;if test=&quot;record.pic != null&quot; &gt;        pic = #&#123;record.pic,jdbcType=VARCHAR&#125;,      &lt;/if&gt;      &lt;if test=&quot;record.createtime != null&quot; &gt;        createtime = #&#123;record.createtime,jdbcType=TIMESTAMP&#125;,      &lt;/if&gt;      &lt;if test=&quot;record.detail != null&quot; &gt;        detail = #&#123;record.detail,jdbcType=VARCHAR&#125;,      &lt;/if&gt;    &lt;/set&gt;    &lt;if test=&quot;_parameter != null&quot; &gt;      &lt;include refid=&quot;Update_By_Example_Where_Clause&quot; /&gt;    &lt;/if&gt;  &lt;/update&gt;  &lt;update id=&quot;updateByExample&quot; parameterType=&quot;map&quot; &gt;    update item    set id = #&#123;record.id,jdbcType=INTEGER&#125;,      name = #&#123;record.name,jdbcType=VARCHAR&#125;,      price = #&#123;record.price,jdbcType=REAL&#125;,      pic = #&#123;record.pic,jdbcType=VARCHAR&#125;,      createtime = #&#123;record.createtime,jdbcType=TIMESTAMP&#125;,      detail = #&#123;record.detail,jdbcType=VARCHAR&#125;    &lt;if test=&quot;_parameter != null&quot; &gt;      &lt;include refid=&quot;Update_By_Example_Where_Clause&quot; /&gt;    &lt;/if&gt;  &lt;/update&gt;&lt;/mapper&gt;</code></pre><h4 id="业务层"><a class="markdownIt-Anchor" href="#业务层"></a> 业务层</h4><p>ItemService.java</p><pre><code class="highlight plaintext">package com.lee.service;import com.lee.pojo.Item;import java.util.List;public interface ItemService &#123;    List&lt;Item&gt; queryItemList();    Item queryItemById(Integer id);    void updateItem(Item item);&#125;</code></pre><p>ItemServiceImpl.java</p><pre><code class="highlight plaintext">package com.lee.service;import com.lee.mapper.ItemMapper;import com.lee.pojo.Item;import com.lee.pojo.ItemExample;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class ItemServiceImpl implements ItemService &#123;    @Autowired    ItemMapper mapper;    @Override    public List&lt;Item&gt; queryItemList() &#123;        // 使用逆向工程代码完成持久层查询        ItemExample example = new ItemExample();        // Criteria criteria = example.createCriteria();        // criteria.andIdEqualTo(1);        List&lt;Item&gt; list = mapper.selectByExample(example);        return list;    &#125;    @Override    public Item queryItemById(Integer id) &#123;        return null;    &#125;    @Override    public void updateItem(Item item) &#123;    &#125;&#125;</code></pre><h4 id="表现层-2"><a class="markdownIt-Anchor" href="#表现层-2"></a> 表现层</h4><p>ItemController.java</p><pre><code class="highlight plaintext">package com.lee.controller;import com.lee.pojo.Item;import com.lee.service.ItemService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import java.util.List;@Controllerpublic class ItemController &#123;    @Autowired    ItemService service;    @RequestMapping(&quot;queryItem&quot;)    public ModelAndView queryItem()&#123;        List&lt;Item&gt; items = service.queryItemList();        ModelAndView modelAndView = new ModelAndView();        //设置数据模型，相当于request的setAttrbute方法，实质上，底层也确实是转成了request        //先将k/v数据放入map中，最终根据视图对象不同，在进行后续处理        modelAndView.addObject(&quot;itemList&quot;,items);        //设置视图（逻辑路径）        modelAndView.setViewName(&quot;item-list&quot;);        return modelAndView;    &#125;&#125;</code></pre><p>item-list.jsp</p><pre><code class="highlight plaintext">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;         pageEncoding=&quot;UTF-8&quot; %&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot; %&gt;&lt;%@page isELIgnored=&quot;false&quot; %&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;查询商品列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath &#125;/itemList.do&quot; method=&quot;post&quot;&gt;    查询条件：    &lt;table width=&quot;100%&quot; border=1&gt;        &lt;tr&gt;            &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;查询&quot;/&gt;&lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;    商品列表：    &lt;table width=&quot;100%&quot; border=1&gt;        &lt;tr&gt;            &lt;td&gt;商品名称&lt;/td&gt;            &lt;td&gt;商品价格&lt;/td&gt;            &lt;td&gt;生产日期&lt;/td&gt;            &lt;td&gt;商品描述&lt;/td&gt;            &lt;td&gt;操作&lt;/td&gt;        &lt;/tr&gt;        &lt;c:forEach items=&quot;$&#123;itemList &#125;&quot; var=&quot;item&quot; varStatus=&quot;status&quot;&gt;            &lt;tr&gt;                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;itemList[$&#123;status.index &#125;].name&quot; value=&quot;$&#123;item.name &#125;&quot;/&gt;&lt;/td&gt;                &lt;td&gt;$&#123;item.price &#125;&lt;/td&gt;                &lt;td&gt;&lt;fmt:formatDate value=&quot;$&#123;item.createtime&#125;&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&lt;/td&gt;                &lt;td&gt;$&#123;item.detail &#125;&lt;/td&gt;                &lt;td&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/itemEdit.do?id=$&#123;item.id&#125;&quot;&gt;修改&lt;/a&gt;&lt;/td&gt;            &lt;/tr&gt;        &lt;/c:forEach&gt;    &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>测试运行结果</strong></p><h2 id="实战技巧"><a class="markdownIt-Anchor" href="#实战技巧"></a> 实战技巧</h2><h3 id="中文乱码解决方案"><a class="markdownIt-Anchor" href="#中文乱码解决方案"></a> 中文乱码解决方案</h3><ul><li>以前使用方法<ul><li>表单方式要使用post方式提交</li><li>request.setCharacterEncoding(“utf-8”)</li></ul></li><li>服务端要和浏览器端编码规则一致才可以解决乱码问题<ul><li>浏览器编码在返回报文的表头中，你给浏览器发送的页面是什么编码，浏览器就返回什么编码</li></ul></li></ul><h4 id="数据库乱码"><a class="markdownIt-Anchor" href="#数据库乱码"></a> 数据库乱码</h4><ul><li>设置mysql编码为utf-8</li></ul><pre><code class="highlight plaintext">CREATE TABLE hero (    id int(11) AUTO_INCREMENT,    name varchar(30) ,     hp float ,    damage int(11) ,PRIMARY KEY (id) )  DEFAULT CHARSET=utf8;</code></pre><h4 id="解决get乱码"><a class="markdownIt-Anchor" href="#解决get乱码"></a> 解决get乱码</h4><p><strong>方式一</strong></p><ul><li>修改tomcat配置文件添加编码与工程一致</li></ul><pre><code class="highlight plaintext">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;               connectionTimeout=&quot;20000&quot;               redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot; /&gt;</code></pre><p><strong>方式二</strong></p><ul><li>对参数进行重新编码</li></ul><pre><code class="highlight plaintext">String username = new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;);</code></pre><h4 id="解决post乱码"><a class="markdownIt-Anchor" href="#解决post乱码"></a> 解决post乱码</h4><p><strong>方式一</strong></p><ul><li>在表单提交时，如果遇到中文字符会出现乱码现象，String提供了一个<strong>CharacterEncodingFilter</strong>过滤器，可用来解决乱码问题</li><li>使用CharacterEncodingFilter需要<strong>注意</strong>以下问题<ul><li>表单数据以post方式提交</li><li>在web.xml中配置CharacterEncodingFilter过滤器</li><li>页面编码和过滤器指定编码要保持一致</li></ul></li><li>修改web.xml文件</li></ul><pre><code class="highlight plaintext">&lt;filter&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;!--/*表示所有的页面进行拦截--&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><p><strong>方式二</strong></p><p>使用@RequestMapping注解中的consumes属性，指定响应体的编码</p><h4 id="jsp乱码"><a class="markdownIt-Anchor" href="#jsp乱码"></a> jsp乱码</h4><p>在jsp首行添加</p><pre><code class="highlight plaintext">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;</code></pre><h4 id="responsebody-乱码"><a class="markdownIt-Anchor" href="#responsebody-乱码"></a> @responsebody 乱码</h4><p><strong>方式一</strong></p><p>在springMVC中添加</p><pre><code class="highlight plaintext">&lt;mvc:annotation-driven&gt;&lt;!-- 消息转换器,解决responseBody返回中外乱码问题 --&gt;&lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;&lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;&lt;property name=&quot;supportedMediaTypes&quot; value=&quot;text/plain;charset=UTF-8&quot; /&gt;&lt;/bean&gt;&lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;</code></pre><p><strong>方式二</strong></p><p>使用@RequestMapping注解中的produce属性，指定响应体的编码</p><h4 id="html页面编码"><a class="markdownIt-Anchor" href="#html页面编码"></a> html页面编码</h4><pre><code class="highlight plaintext">&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;    &lt;title&gt;用AJAX以JSON方式提交数据&lt;/title&gt;&lt;/head&gt;</code></pre><h3 id="拦截器"><a class="markdownIt-Anchor" href="#拦截器"></a> 拦截器</h3><p>SpringMVC的拦截器主要是针对特定处理器进行拦截的</p><h4 id="什么是拦截器"><a class="markdownIt-Anchor" href="#什么是拦截器"></a> 什么是拦截器</h4><p>SpringMVC拦截器（<strong>Interceptor</strong>）实现对每一个请求处理前后进行相关的业务处理，类似与servlet中的<strong>Filter</strong></p><p>spring提供的一个特殊的的组件，当DispatcherServlet收到请求后，如果有拦截器，会先调用拦截器，然后调用相应的处理器（Controller）</p><blockquote><p>过滤器属于servlet规范，过滤器在DispatcherServlet之前；</p><p>而拦截器属于spring框架，在dispatcherServlet之后</p></blockquote><h4 id="如何写一个拦截器"><a class="markdownIt-Anchor" href="#如何写一个拦截器"></a> 如何写一个拦截器</h4><p>SpringMVC 中的Interceptor 拦截请求是通过HandlerInterceptor来实现的</p><p>在SpringMVC中定义一个Interceptor非常简单，主要有4种方式：</p><ol><li><strong>实现Spring的HandlerInterceptor接口</strong>；</li><li>继承实现了HandlerInterceptor接口的类，比如Spring 已经提供的实现了HandlerInterceptor 接口的抽象类HandlerInterceptorAdapter；</li><li>实现Spring的WebRequestInterceptor接口；</li><li>继承实现了WebRequestInterceptor的类；</li></ol><p>写一个Java类，实现HandlerInterceptor接口实现具体的拦截处理逻辑，比如：session验证配置拦截器</p><h4 id="定义拦截器实现登陆检查"><a class="markdownIt-Anchor" href="#定义拦截器实现登陆检查"></a> 定义拦截器（实现登陆检查）</h4><h5 id="先定义拦截器"><a class="markdownIt-Anchor" href="#先定义拦截器"></a> 先定义拦截器</h5><ul><li>Spring的HandlerMapping处理器支持拦截器应用，当需要为某些请求提供特殊功能时，例如对用户进行身份认证</li><li><strong>拦截器必须实现HandlerInterceptor接口</strong>，这个接口有三个方法<ul><li><strong>preHandle(…)</strong><ul><li><strong>处理器执行前</strong>被调用，方法返回true标识会继续调用其他拦截器核处理器，返回<strong>false</strong>表示中断流程，不会执行后续拦截器和处理器</li></ul></li><li><strong>postHandle(…)</strong><ul><li><strong>处理器执行后，视图处理前</strong>调用，此时可以通过modelAndView对象对模型数据进行处理或对视图进行处理</li></ul></li><li><strong>afterCompletion(…)</strong><ul><li><strong>整个请求处理完毕后调用</strong>，如果性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，只有preHandle返回true时才会执行afterCompletion方法</li></ul></li></ul></li><li>自定义拦截器示例代码</li></ul><pre><code class="highlight plaintext">public class SomeInterceptor implements HandlerInterceptor&#123;        /**      * 在业务处理器处理请求之前被调用      * 如果返回false      *     从当前的拦截器往回执行所有拦截器的afterCompletion(),再退出拦截器链     * 如果返回true      *    执行下一个拦截器,直到所有的拦截器都执行完毕      *    再执行被拦截的Controller      *    然后进入拦截器链,      *    从最后一个拦截器往回执行所有的postHandle()      *    接着再从最后一个拦截器往回执行所有的afterCompletion()      */  //应用场景：登录认证、身份授权   public boolean preHandle(HttpServletRequest req,HttpServletResponse res,Object handler) throws Exception&#123;        //处理器执行前调用        System.out.println(&quot;preHandle()&quot;);        return true;    &#125;    /**     * 在业务处理器处理请求执行完成后,生成视图之前执行的动作        * 可在modelAndView中加入数据，比如当前时间，可以把公共模型数据传到前台，可以统一指定视图 *      */         public void postHandle(HttpServletRequest req,HttpServletResponse res,Object handler,ModelAndView mv) throws Exception&#123;     System.out.println(&quot;postHandler&quot;);        //处理器执行后调用    &#125;    /**      * 在DispatcherServlet完全处理完请求后被调用,可用于清理资源等       *       * 当有拦截器抛出异常时,会从当前拦截器往回执行所有的拦截器的afterCompletion()  * 访问视图之后调用     */    //应用场景：统一异常处理、统一日志处理    public void afterCompletion(HttpServletRequest req,HttpServletResponse res,Object handler,Exception e)&#123;    System.out.println(&quot;afterCompletion()&quot;);        //请求完成处理后调用    &#125;&#125;</code></pre><blockquote><p>提示：自定义拦截器时，实现HandlerInterceptor接口需要实现接口定义的所有方法，如果只需要某一个方法可以继承HandlerInterceptorAdapter</p><p><strong>方法执行顺序</strong></p></blockquote><h5 id="配置拦截器"><a class="markdownIt-Anchor" href="#配置拦截器"></a> 配置拦截器</h5><p>如果有多个拦截器，那么配置到springmvc.xml中<strong>最上面的拦截器，拦截优先级最高</strong></p><p><strong>全局拦截器配置（推荐）</strong></p><p>自定义连接器的spring.xml配置如下</p><ul><li>如果要拦截其他路径：<ul><li>/** 拦截所有</li><li>/* 只拦截一层，如只拦截/hello.do，不拦截/demo/hello.do</li><li>/category/** 拦截/category路径下的所有</li></ul></li></ul><blockquote><p>SpringMVC的全局拦截器配置，其实是把配置的拦截器注入到每个已初始化的HandlerMapping中了</p></blockquote><pre><code class="highlight plaintext">&lt;!-- 配置全局mapping的拦截器 --&gt;&lt;mvc:interceptors&gt;     &lt;!-- 公共拦截器可以拦截所有请求，而且可以有多个 --&gt;     &lt;!-- 当设置多个拦截器时，先按顺序调用preHandle方法，然后逆序调用每个拦截器的postHandle和afterCompletion方法 --&gt;     &lt;bean class=&quot;com.kkb.ssm.interceptor.MyHandlerInterceptor1&quot; /&gt;    &lt;bean class=&quot;com.kkb.ssm.interceptor.MyHandlerInterceptor2&quot; /&gt;&lt;!-- 如果有多个拦截器，则按照顺序进行配置 --&gt;    &lt;!-- 定义在mvc:interceptor下面的表示是对特定的请求才进行拦截的 --&gt; &lt;mvc:interceptor&gt;&lt;!-- /**表示所有URL和子URL路径 --&gt;&lt;mvc:mapping path=&quot;/test/**&quot; /&gt;        &lt;!--exclude-mapping配置表示此路径不拦截--&gt;        &lt;mvc:exclude-mapping path=&quot;/login/*&quot;/&gt;         &lt;!-- 特定请求的拦截器只能有一个 --&gt;&lt;bean class=&quot;com.kkb.ssm.interceptor.MyHandlerInterceptor3&quot; /&gt;&lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;</code></pre><p><strong>针对单个handlerMapping配置</strong></p><p>只有通过该处理器映射器查找到的处理器，才能使用该拦截器。</p><p>如果现在有两个处理器映射器：其中一个设置了处理器拦截器，另外一个没有设置，如果通过第二个映射器查找到的处理器，是无法使用拦截器的</p><pre><code class="highlight plaintext">&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&gt;&lt;property name=&quot;interceptors&quot;&gt;&lt;list&gt;&lt;ref bean=&quot;interceptor&quot; /&gt;&lt;/list&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;interceptor&quot; class=&quot;com.kkb.ssm.interceptor.MyHandlerInterceptor&quot; /&gt;</code></pre><h4 id="session验证案例"><a class="markdownIt-Anchor" href="#session验证案例"></a> session验证案例</h4><ul><li>session需要手动用<code>httpSession.setAttribute(&quot;admin&quot;,adminCode);</code>方法放值，session中有值后才可以用来session验证</li></ul><h5 id="controller"><a class="markdownIt-Anchor" href="#controller"></a> Controller</h5><ul><li>loginController</li></ul><pre><code class="highlight plaintext">@RequestMapping(&quot;/toLogin.do&quot;)public String toLogin() &#123;System.out.println(&quot;toLogin()&quot;);return &quot;login&quot;;&#125;@RequestMapping(&quot;/login.do&quot;)public String login(HttpServletRequest request, HttpSession httpSession) &#123;String adminCode = request.getParameter(&quot;adminCode&quot;);String password = request.getParameter(&quot;pwd&quot;);System.out.println(adminCode);try &#123;Admin admin = loginService.checkLogin(adminCode, password);//登陆成功，将用户名存储到session对象中，方便以后session验证httpSession.setAttribute(&quot;admin&quot;,adminCode);&#125; catch (Exception e) &#123;if(e instanceof ApplicationException) &#123;request.setAttribute(&quot;admin_flag&quot;, e.getMessage());return &quot;login&quot;;&#125;return &quot;error&quot;;&#125;return &quot;redirect:toIndex.do&quot;;&#125;</code></pre><h5 id="定义与配置拦截器"><a class="markdownIt-Anchor" href="#定义与配置拦截器"></a> 定义与配置拦截器</h5><ul><li><strong>定义拦截器</strong></li></ul><pre><code class="highlight plaintext">package com.lee.netctoss.interceptors;/** * 用于session验证的拦截器 */import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class SomeInterceptor implements HandlerInterceptor &#123;    /*        DispatcherServlet收到请求之后，会先调用parHandle方法        返回true:则继续向后调用        返回false:则不在向后调用        第三个参数：表示处理器方法的反射对象     */    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        System.out.println(&quot;preHandle()&quot;);        HttpSession httpSession = request.getSession();        Object obj = httpSession.getAttribute(&quot;admin&quot;);        if (obj == null)&#123;            //没有登陆，重定向到登陆页面            response.sendRedirect(&quot;toLogin.do&quot;);            return false;        &#125;        //已经登陆过则允许访问        return true;    &#125;    /*        Controller的方法已经执行完毕，正准备处理结果(ModelAndView)返回给DisPatcherServlet之前，执行postHandler方法，可以在改方法里面修改处理结果     */    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        System.out.println(&quot;postHandler&quot;);    &#125;    /*        最后执行的方法        注意：只有当perHandle方法返回值为true时，该方法才会执行        ex:是处理器所抛出的异常，可以写一个拦截器，用来处理这些异常        比如：我们可以使用拦截器处理所有处理器抛出的异常     */    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;        System.out.println(&quot;afterCompletion()&quot;);    &#125;&#125;</code></pre><ul><li><strong>配置拦截器</strong></li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:task=&quot;http://www.springframework.org/schema/task&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;     xmlns:p=&quot;http://www.springframework.org/schema/p&quot;     xmlns:util=&quot;http://www.springframework.org/schema/util&quot;    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;    xmlns:cache=&quot;http://www.springframework.org/schema/cache&quot;    xsi:schemaLocation=&quot;    http://www.springframework.org/schema/context    http://www.springframework.org/schema/context/spring-context.xsd    http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/tx    http://www.springframework.org/schema/tx/spring-tx.xsd    http://www.springframework.org/schema/jdbc    http://www.springframework.org/schema/jdbc/spring-jdbc-3.1.xsd    http://www.springframework.org/schema/cache    http://www.springframework.org/schema/cache/spring-cache-3.1.xsd    http://www.springframework.org/schema/aop    http://www.springframework.org/schema/aop/spring-aop.xsd    http://www.springframework.org/schema/util    http://www.springframework.org/schema/util/spring-util.xsd    http://www.springframework.org/schema/mvc    http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd    http://www.springframework.org/schema/task    http://www.springframework.org/schema/task/spring-task-3.1.xsd&quot;&gt;    &lt;!-- 配置组件扫描 --&gt;&lt;context:component-scan base-package=&quot;com.lee.netctoss&quot;/&gt;&lt;!-- 配置mvc注解扫描 --&gt;&lt;mvc:annotation-driven/&gt;&lt;!-- 配置ViewResolver视图解析器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot;&gt;&lt;/property&gt;&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 读取配置文件 --&gt;&lt;util:properties id=&quot;config&quot; location=&quot;classpath:db.properties&quot;/&gt;&lt;!-- 数据库连接池 --&gt;&lt;bean id=&quot;ds&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;&lt;property name=&quot;driverClassName&quot; value=&quot;#&#123;config.driverClassName&#125;&quot;&gt;&lt;/property&gt;&lt;property name=&quot;url&quot; value=&quot;#&#123;config.url&#125;&quot;&gt;&lt;/property&gt;&lt;property name=&quot;username&quot; value=&quot;#&#123;config.username&#125;&quot;&gt;&lt;/property&gt;&lt;property name=&quot;password&quot; value=&quot;#&#123;config.password&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--拦截器配置--&gt;&lt;!--如果有多个拦截器，会按照配置的先后顺序执行--&gt;&lt;mvc:interceptors&gt;&lt;mvc:interceptor&gt;&lt;!--哪些请求拦截--&gt;&lt;!--拦截所有的要用/** ，/* 只能拦截/hello.do，不能拦截/demo/hello.do--&gt;&lt;mvc:mapping path=&quot;/**&quot;/&gt;&lt;!--哪些请求不拦截--&gt; &lt;mvc:exclude-mapping path=&quot;/toLogin.do&quot;/&gt;&lt;mvc:exclude-mapping path=&quot;/login.do&quot;/&gt;&lt;!--拦截器的类名--&gt;&lt;bean class=&quot;com.lee.netctoss.interceptors.SomeInterceptor&quot;/&gt;&lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;&lt;/beans&gt;</code></pre><h3 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h3><p>springmvc在处理请求过程中出现异常信息交由异常处理器进行处理，自定义异常处理器可以实现一个系统的异常处理逻辑</p><p>可以将异常抛给spring，由spring来处理这些异常</p><ul><li>Spring MVC处理异常的方式有以下三种<ol><li>使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver</li><li>实现HandlerExceptionResolver接口自定义异常处理器</li><li>使用@ExceptionHandler注解实现异常处理</li></ol></li></ul><p>当发生异常的时候，SpringMVC会如下处理：</p><p>（1）SpringMVC会先从配置文件找异常解析器HandlerExceptionResolver</p><p>（2）如果找到了异常异常解析器，那么接下来就会判断该异常解析器能否处理当前发生的异常</p><p>（3）如果可以处理的话，那么就进行处理，然后给前台返回对应的异常视图</p><p>（4）如果没有找到对应的异常解析器或者是找到的异常解析器不能处理当前的异常的时候，就看当前的Controller中有没有提供对应的异常处理器，如果提供了就由Controller自己进行处理并返回对应的视图</p><p>（5）如果配置文件里面没有定义对应的异常解析器，而当前Controller中也没有定义的话，那么该异常就会被抛出来。</p><h4 id="异常概念"><a class="markdownIt-Anchor" href="#异常概念"></a> 异常概念</h4><p>异常包含<strong>编译时异常</strong>和<strong>运行时异常</strong>，其中编译时异常也叫预期异常。运行时异常只有在项目运行的情况下才会发现，编译的时候不需要关心。</p><ul><li><strong>运行时异常</strong>，比如：空指针异常、数组越界异常，对于这样的异常，只能通过程序员丰富的经验来解决和测试人员不断的严格测试来解决。</li><li><strong>编译时异常</strong>，比如：数据库异常、文件读取异常、自定义异常等。对于这样的异常，必须使用try catch代码块或者throws关键字来处理异常</li></ul><h4 id="异常处理思路"><a class="markdownIt-Anchor" href="#异常处理思路"></a> 异常处理思路</h4><p>系统中异常包括两类：预期异常（编译时异常）和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。</p><p>系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理，如下图：</p><h4 id="使用simplemappingexceptionresolver"><a class="markdownIt-Anchor" href="#使用simplemappingexceptionresolver"></a> 使用SimpleMappingExceptionResolver</h4><ul><li>使用只需要在Spring的XML配置文件中定义就可以了</li><li><strong>异常处理页面获取异常对象名exception适合全局处理简单异常</strong></li><li>TimeoutException为异常类型</li><li>login为视图页面</li></ul><pre><code class="highlight plaintext">    &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;    &lt;property name=&quot;exceptionMapping&quot;&gt;        &lt;props&gt;            &lt;prop key=&quot;java.lang.Exception&quot;&gt;error&lt;/prop&gt;            &lt;prop key=&quot;com.tarena.TimeoutException&quot;&gt;login&lt;/prop&gt;        &lt;props&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h4 id="实现handlerexceptionresolver接口自定义异常处理器"><a class="markdownIt-Anchor" href="#实现handlerexceptionresolver接口自定义异常处理器"></a> 实现HandlerExceptionResolver接口自定义异常处理器</h4><p>为了区别不同的异常通常根据异常类型自定义异常类，这里我们创建一个自定义系统异常，如果controller、service、dao抛出此类异常说明是系统预期处理的异常信息</p><pre><code class="highlight plaintext">public class BusinessException extends Exception &#123;private static final long serialVersionUID = 1L;//异常信息private String message;public BusinessException(String message) &#123;super(message);this.message = message;&#125;public String getMessage() &#123;return message;&#125;public void setMessage(String message) &#123;this.message = message;&#125;&#125;</code></pre><p>自定义异常处理器</p><pre><code class="highlight plaintext">public class BusinessExceptionResolver implements HandlerExceptionResolver &#123;@Overridepublic ModelAndView resolveException(HttpServletRequest request,HttpServletResponse response, Object handler, Exception ex) &#123;//自定义预期异常BusinessException businessException = null; //如果抛出的是系统自定义的异常if(ex instanceof BusinessException)&#123;businessException = (BusinessException) ex;&#125;else&#123;businessException = new BusinessException(&quot;未知错误&quot;);&#125;ModelAndView modelAndView = new ModelAndView();//把错误信息传递到页面modelAndView.addObject(&quot;message&quot;, businessException.getMessage());//指向错误页面modelAndView.setViewName(&quot;error&quot;);return modelAndView;&#125;&#125;</code></pre><p>错误页面</p><pre><code class="highlight plaintext">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;错误信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;message &#125;&lt;/body&gt;&lt;/html&gt;</code></pre><p>自定义的异常处理器需要在Spring的XML配置文件中定义下才可以使用</p><pre><code class="highlight plaintext">&lt;!--自定义异常处理器（全局）--&gt;&lt;bean id=&quot;exceptionHandler&quot; class=&quot;com.kkb.ssm.resolver.BusinessExceptionResolver&quot;/&gt;</code></pre><p>异常测试</p><pre><code class="highlight plaintext">@RequestMapping(value = &quot;/showItemEdit&quot;)public String showItemEdit(Integer id,Model model) throws Exception&#123;// 查询要显示的商品内容Item item = itemService.queryItemById(id);if(item == null) throw new BusinessException(&quot;查询不到商品无法修改&quot;);model.addAttribute(&quot;item&quot;, item);// 由于配置了ViewResolver，所以此处只写逻辑视图名称即可return &quot;item/item-edit&quot;;&#125;</code></pre><h4 id="exceptionhandler注解实现异常处理"><a class="markdownIt-Anchor" href="#exceptionhandler注解实现异常处理"></a> @ExceptionHandler注解实现异常处理</h4><ul><li>首先编写一个BaseController类</li><li>适合局部处理有“处理过程”的异常</li><li>然后其他的Controller继承BaseController类即可</li></ul><pre><code class="highlight plaintext">//该注解可以对Controller进行增强@ControllerAdvice  public class BaseController&#123;         //应用到所有@RequestMapping注解的方法，在其执行之前把返回值放入ModelMap中         public Map&lt;String,Map&gt;  ma()&#123;            Map&lt;String,Map&gt; map = new HashMap();            map.put(&quot;name&quot;,&quot;tom&quot;);            return map;         &#125;                              //应用到所有带参数的@RequestMapping的方法，在其执行之前初始化数据绑定@InitBinderpublic void initBinder(WebDataBinder dataBinder)&#123;   DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-mm-dd&quot;);   dataBinder.registerCustomEditor(Date.class,new CustomDateEditor(dateFormat));   System.out.println(&quot;...initBider...&quot;);&#125;                        //应用到所有@RequestMapping注解的方法，在其有抛出指定异常时执行        @ExceptionHandler(Exception.class)        public String execute(HttpServletRequest request,Exception ex)&#123;            request.setAttribute(&quot;ex&quot;,ex);            //可以根据异常类型返回不同的视图名        &#125;    &#125;</code></pre><h4 id="responsestatus"><a class="markdownIt-Anchor" href="#responsestatus"></a> @ResponseStatus</h4><p>带有@ResponseStatus注解的异常类会被ResponseStatusExceptionResolver 解析。可以实现自定义的一些异常,同时在页面上进行显示。具体的使用方法如下:</p><ul><li>value属性：指定状态码</li><li>code属性：指定状态码</li><li>reason属性：错误描述（注：如果期望返回状态码为2XX，则一定不要填写reason属性，reason属性只要不为空，返回的状态码就错误状态码）</li></ul><blockquote><p><strong>注解底层还是通过设置  response.setStatus来实现.</strong></p></blockquote><blockquote><p>该注解在@RequestMapping方法执行完成，Spring解析返回值之前，进行了responseStatus设置</p></blockquote><hr /><p><strong>定义在自定义异常类上</strong></p><ul><li>如果定义在自定义异常类上，如果controller抛出这个异常，则springMVC会把返回的状态码设置为@ResponseStatus中指定的状态码</li><li>在SpringMvc中如果有某个 @RequestMapping方法抛出该异常,  只要开启<a href="">mvc:annotation-driven/</a></li></ul><ol><li>首先自定义一个异常类</li></ol><pre><code class="highlight plaintext">@ResponseStatus(value = HttpStatus.FORBIDDEN,reason = &quot;用户名和密码不匹配!&quot;)public class UserNameNotMatchPasswordException extends RuntimeException&#123;        &#125;</code></pre><ol><li>人为抛出一个异常:</li></ol><pre><code class="highlight plaintext">@RequestMapping(&quot;/testResponseStatusExceptionResolver&quot;)  public String testResponseStatusExceptionResolver(@RequestParam(&quot;i&quot;) int i)&#123;      if (i==13)&#123;          throw new UserNameNotMatchPasswordException();      &#125;      System.out.println(&quot;testResponseStatusExceptionResolver....&quot;);      return &quot;success&quot;;  &#125;</code></pre><ol><li>输入如下额路径:</li></ol><p><a href="">http://localhost:8090/testResponseStatusExceptionResolver?i=13</a></p><hr /><p><strong>定义在Controller方法上</strong></p><ul><li>定义在Controller方法上时，每次访问返回的状态码都为你指定的状态码</li><li>@ResponseStatus(code=A,reason=B)标注在 @RequestMapping方法上，作用效果与 response.sendError(A,B)是一样的.</li></ul><pre><code class="highlight plaintext">@ResponseStatus(reason = &quot;测试&quot;,value = HttpStatus.NOT_FOUND)@RequestMapping(&quot;/testResponseStatusExceptionResolver&quot;)public String testResponseStatusExceptionResolver(@RequestParam(&quot;i&quot;) int i)&#123;    if (i==13)&#123;        throw new UserNameNotMatchPasswordException();    &#125;    System.out.println(&quot;testResponseStatusExceptionResolver....&quot;);    return &quot;success&quot;;&#125;</code></pre><p>每次访问都会返回你指定的状态码</p><blockquote><p>如果只是为了指示返回状态码，最好不要添加reason属性（如果添加了reason属性，且reason不为&quot;&quot;，且code &gt; 0(哪怕状态码是200)，会对当前请求走错误处理）</p></blockquote><hr /><p><strong>定义在@ControllerAdvice中</strong></p><ul><li>@ControllerAdvice标注初衷我想就是程序运行过程中发生异常，对异常如何处理？  而@ResponseStatus标注在@ControllerAdvice类或者该类下的@ExceptionHandler上，区别大概就是，原来比如请求程序抛出异常，异常被捕获，走@ExceptionHandler，正常走完状态码是200.</li><li>@ControllerAdvice或者 @ExceptionHandler标注了@ReponseStatus，那走完状态码就是500.如果你再给@ResponseStatus添加了reason属性，不管捕获异常方法咋返回，都是服务器的错误码捕获界面，比如上面我的例子，给@ResponseStatus添加reason=”your defined message”.不管怎么说，下面界面比一大堆异常堆栈信息看起来更简洁，但我还是不推荐使用诶,原因啊，界面不友好.</li></ul><pre><code class="highlight plaintext">@ControllerAdvice@ResponseStatuspublic class MyControllerAdvice &#123;     @ExceptionHandler(&#123;ArithmeticException.class&#125;)    public ModelAndView fix(Exception e)&#123;        Map map=new HashMap();        map.put(&quot;ex&quot;,e.getMessage());        return new ModelAndView(&quot;error&quot;,map);    &#125; &#125;</code></pre><h4 id="对于框架内部异常或代码无法捕获的异常"><a class="markdownIt-Anchor" href="#对于框架内部异常或代码无法捕获的异常"></a> 对于框架内部异常或代码无法捕获的异常</h4><ul><li>对于此种异常，可以再web.xml通过<error-page>定义，目前绝大多数服务器都支持此配置，配置示例如下</li></ul><pre><code class="highlight plaintext">&lt;error-page&gt;        &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt;        &lt;location&gt;/WEB-INF/views/error/500.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt;       &lt;error-code&gt;404&lt;/error-code&gt;       &lt;location&gt;/WEB-INF/views/error/404.jsp&lt;/location&gt;&lt;/error-page&gt;</code></pre><h3 id="文件上传"><a class="markdownIt-Anchor" href="#文件上传"></a> 文件上传</h3><h4 id="springmvc文件上传简介"><a class="markdownIt-Anchor" href="#springmvc文件上传简介"></a> SpringMVC文件上传简介</h4><ul><li>再springMVC中，文件上传功能可以由即插即用的CommonsMultipartResolver解析器组件实现，它定义再org.springframework.web.multipart包里，Spring提供的CommonsMultipartResolver解析器可以支持Commons FileUpload和COS FileUpload两种上传组件</li></ul><h4 id="commonsmultipartresolver组件"><a class="markdownIt-Anchor" href="#commonsmultipartresolver组件"></a> CommonsMultipartResolver组件</h4><ul><li>CommonsMultipartResolver解析器可以调用common-fileupload.jar的功能，将请求提交的文件信息结息出来，该组件使用步骤如下<ul><li>引入common-fileupload.jar和<br />common-io.jar开发包</li><li>再spring配置文件中添加CommonsMultipartResolver组件的bean定义</li></ul></li></ul><pre><code class="highlight plaintext">&lt;!--这个bean的id不能修改，是底层写死的，写错了就找不到改类了--&gt;&lt;bean id=&quot;multipartReslver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;</code></pre><h4 id="实现步骤"><a class="markdownIt-Anchor" href="#实现步骤"></a> 实现步骤</h4><p><strong>maven依赖</strong></p><pre><code class="highlight plaintext">&lt;dependency&gt;&lt;groupId&gt;commons-fileupload&lt;/groupId&gt;&lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;&lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>jsp页面（上传）</strong></p><ul><li>再JSP视图表单中，<form>标记必须追加<strong>enctype=&quot;multipart/form-data&quot;设置</strong>，指定表单数据的提交格式，默认情况，提交格式是application/x-www-form-urlencoded（key/value格式），不能用于文件上传<ul><li><h2 id="enctypemultipartform-data格式表单"><a class="markdownIt-Anchor" href="#enctypemultipartform-data格式表单"></a> enctype=&quot;multipart/form-data&quot;格式表单</h2></li><li><h2 id="enctypeapplicationx-www-form-urlencoded格式表单"><a class="markdownIt-Anchor" href="#enctypeapplicationx-www-form-urlencoded格式表单"></a> enctype=&quot;application/x-www-form-urlencoded&quot;格式表单</h2></li></ul></li><li>method属性也必须设置为<strong>post方式</strong>提交</li></ul><pre><code class="highlight plaintext">&lt;form action=&quot;upload.from&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;     &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;     &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;/&gt;&lt;/form&gt;</code></pre><p><strong>Controller实现</strong></p><ul><li>再Controller处理方法中，可以使用@RequestParam注解将CommonsMultipartResolver解析出的文件赋值给MultipartFile参数对象，该对象包含了上传的文件信息</li></ul><pre><code class="highlight plaintext">@RequestMapping(value=&quot;/upload.from&quot;)//@RequestParam写不写都可以public String upload( @RequestParam(value=&quot;file&quot;,required=false)MultipartFile file,HttpServletRequest request,ModelMao model)&#123;        //获取10位的随机数        String name = RandomStringUtils.randomAlphanumeric(10);        //创建文件名    String newFileName = name + &quot;.jpg&quot;;    //获取到WEB目录下的image目录，用于存放上传后的文件        File newFile = new File(request.getServletContext().getRealPath(&quot;/image&quot;), newFileName);    //调用file.getImage().transferTo(newFile); 复制文件    file.getImage().transferTo(newFile);        //一般将文件全路径名存放到数据库中        //把生成的随机文件名提交给视图        ModelAndView mav = new ModelAndView(&quot;showUploadedFile&quot;);        mav.addObject(&quot;imageName&quot;, newFileName);        return mav;&#125;</code></pre><hr /><p>另一个controller处理逻辑</p><pre><code class="highlight plaintext">@RequestMapping(value = &quot;/updateItem&quot;)public String updateItem(Model model,Item item,MultipartFile pictureFile) throws Exception &#123;if(pictureFile != null)&#123;System.out.println(pictureFile.getOriginalFilename());//原始图片名称String originalFilename = pictureFile.getOriginalFilename();//如果没有图片名称，则上传不成功if(originalFilename != null &amp;&amp; originalFilename.length()&gt;0)&#123;//存放图片的物理路径String picPath = &quot;E:\\03-teach\\07-upload\\temp\\&quot;;//新文件的名称，substring是对文件扩展名的截取 String newFileName = UUID.randomUUID()+originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));//确保目录是否存在File dirFile = new File(picPath);if(!dirFile.exists())&#123;      dirFile.mkdirs();&#125;//新的文件File newFile = new File(picPath+newFileName);//把上传的文件保存成一个新的文件pictureFile.transferTo(newFile);//同时需要把新的文件名更新到数据库中item.setPic(newFileName);&#125;else&#123;throw new BusinessException(&quot;图片名称不存在，上传不成功&quot;);&#125;&#125;// 根据页面传入的商品信息，调用修改方法，进行修改（此时还没有讲参数绑定，暂时无法进行）itemService.updateItem(item);return &quot;success&quot;;&#125;</code></pre><p><strong>showUploadedFile.jsp显示图片界面</strong></p><pre><code class="highlight plaintext">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot; isELIgnored=&quot;false&quot;%&gt; &lt;img src=&quot;image/$&#123;imageName&#125;&quot;/&gt;</code></pre><p><strong>限制上传文件大小</strong></p><ul><li>CommonsMultipartResolver解析器可以设置对上传文件大小的限定，配置示例如下</li></ul><pre><code class="highlight plaintext">&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;property name=&quot;maxUploadSize&quot; value=&quot;102400&quot;/&gt;&lt;/bean&gt;</code></pre><ul><li>当设置maxUploadSize大小限制后，如果上传文件大于指定大小，会抛出MaxUploadSizeExceededException异常，可以采用异常处理给客户显示友好提示</li><li>在处理上传的Controller组件中定义@ExceptionHandler异常处理方法</li><li><strong>@ExceptionHandler异常处理示例</strong></li></ul><pre><code class="highlight plaintext">    @ExceptionHandler    public ModelAndView doException(Exception ex)&#123;        Map&lt;String,Object&gt;model = new HashMap&lt;String,Object&gt;();        if(ex instanceof MaxUploadSizeExceededException)&#123;            long size = ((MaxUploadSizeExceededException)ex).getMaxUploadSize();            model.put(&quot;errors&quot;,&quot;文件应小于&quot;+ex.getMessage());        &#125;else&#123;            model.put(&quot;errors&quot;,&quot;未知错误：&quot;+ex.getMessage());        &#125;        return new ModelAndView(&quot;upload&quot;,model);    &#125;    提示:CommonsMultipartResolver的resolveLazily属性指定为true，将文件解析演出加载，才能出发上面的异常处理</code></pre><h4 id="限制文件上传类型"><a class="markdownIt-Anchor" href="#限制文件上传类型"></a> 限制文件上传类型</h4><pre><code class="highlight plaintext">public enum FileType &#123;        /**          * JEPG.          */          JPEG(&quot;FFD8FF&quot;),                /**          * PNG.          */          PNG(&quot;89504E47&quot;),                /**          * GIF.          */          GIF(&quot;47494638&quot;),                /**          * TIFF.          */          TIFF(&quot;49492A00&quot;),                /**          * Windows Bitmap.          */          BMP(&quot;424D&quot;),                /**          * CAD.          */          DWG(&quot;41433130&quot;),                /**          * Adobe Photoshop.          */          PSD(&quot;38425053&quot;),                /**          * Rich Text Format.          */          RTF(&quot;7B5C727466&quot;),                /**          * XML.          */          XML(&quot;3C3F786D6C&quot;),                /**          * HTML.          */          HTML(&quot;68746D6C3E&quot;),          /**          * CSS.          */          CSS(&quot;48544D4C207B0D0A0942&quot;),          /**          * JS.          */          JS(&quot;696B2E71623D696B2E71&quot;),          /**          * Email [thorough only].          */          EML(&quot;44656C69766572792D646174653A&quot;),                /**          * Outlook Express.          */          DBX(&quot;CFAD12FEC5FD746F&quot;),                /**          * Outlook (pst).          */          PST(&quot;2142444E&quot;),                /**          * MS Word/Excel.          */          XLS_DOC(&quot;D0CF11E0&quot;), XLSX_DOCX(&quot;504B030414000600080000002100&quot;),          /**          * Visio          */          VSD(&quot;d0cf11e0a1b11ae10000&quot;),          /**          * MS Access.          */          MDB(&quot;5374616E64617264204A&quot;),          /**          * WPS文字wps、表格et、演示dps都是一样的          */          WPS(&quot;d0cf11e0a1b11ae10000&quot;),          /**          * torrent          */          TORRENT(&quot;6431303A637265617465&quot;),          /**          * WordPerfect.          */          WPD(&quot;FF575043&quot;),                /**          * Postscript.          */          EPS(&quot;252150532D41646F6265&quot;),                /**          * Adobe Acrobat.          */          PDF(&quot;255044462D312E&quot;),                /**          * Quicken.          */          QDF(&quot;AC9EBD8F&quot;),                /**          * Windows Password.          */          PWL(&quot;E3828596&quot;),                /**          * ZIP Archive.          */          ZIP(&quot;504B0304&quot;),                /**          * RAR Archive.          */          RAR(&quot;52617221&quot;),          /**          * JSP Archive.          */          JSP(&quot;3C2540207061676520&quot;),          /**          * JAVA Archive.          */          JAVA(&quot;7061636B61676520&quot;),          /**          * CLASS Archive.          */          CLASS(&quot;CAFEBABE0000002E00&quot;),          /**          * JAR Archive.          */          JAR(&quot;504B03040A000000&quot;),          /**          * MF Archive.          */          MF(&quot;4D616E69666573742D56&quot;),          /**          *EXE Archive.          */          EXE(&quot;4D5A9000030000000400&quot;),          /**          *CHM Archive.          */          CHM(&quot;49545346030000006000&quot;),          /*          * INI(&quot;235468697320636F6E66&quot;), SQL(&quot;494E5345525420494E54&quot;), BAT(          * &quot;406563686F206f66660D&quot;), GZ(&quot;1F8B0800000000000000&quot;), PROPERTIES(          * &quot;6C6F67346A2E726F6F74&quot;), MXP(          * &quot;04000000010000001300&quot;),          */          /**          * Wave.          */          WAV(&quot;57415645&quot;),                /**          * AVI.          */          AVI(&quot;41564920&quot;),                /**          * Real Audio.          */          RAM(&quot;2E7261FD&quot;),                /**          * Real Media.          */          RM(&quot;2E524D46&quot;),                /**          * MPEG (mpg).          */          MPG(&quot;000001BA&quot;),                /**          * Quicktime.          */          MOV(&quot;6D6F6F76&quot;),                /**          * Windows Media.          */          ASF(&quot;3026B2758E66CF11&quot;),                /**          * MIDI.          */          MID(&quot;4D546864&quot;),          /**          * MP4.          */          MP4(&quot;00000020667479706d70&quot;),          /**          * MP3.          */          MP3(&quot;49443303000000002176&quot;),          /**          * FLV.          */          FLV(&quot;464C5601050000000900&quot;);          private String value = &quot;&quot;;                /**          * Constructor.          *           * @param type          */          private FileType(String value) &#123;              this.value = value;          &#125;                public String getValue() &#123;              return value;          &#125;                public void setValue(String value) &#123;              this.value = value;          &#125;&#125;</code></pre><pre><code class="highlight plaintext">public final class FileTypeJudge &#123;        /**      * Constructor      */      private FileTypeJudge() &#123;      &#125;        /**      * 将文件头转换成16进制字符串      *       * @param 原生byte      * @return 16进制字符串      */      private static String bytesToHexString(byte[] src) &#123;            StringBuilder stringBuilder = new StringBuilder();          if (src == null || src.length &lt;= 0) &#123;              return null;          &#125;          for (int i = 0; i &lt; src.length; i++) &#123;              int v = src[i] &amp; 0xFF;              String hv = Integer.toHexString(v);              if (hv.length() &lt; 2) &#123;                  stringBuilder.append(0);              &#125;              stringBuilder.append(hv);          &#125;          return stringBuilder.toString();      &#125;        /**      * 得到文件头      *       * @param filePath      *            文件路径      * @return 文件头      * @throws IOException      */      private static String getFileContent(InputStream is) throws IOException &#123;            byte[] b = new byte[28];            InputStream inputStream = null;            try &#123;              is.read(b, 0, 28);          &#125; catch (IOException e) &#123;              e.printStackTrace();              throw e;          &#125; finally &#123;              if (inputStream != null) &#123;                  try &#123;                      inputStream.close();                  &#125; catch (IOException e) &#123;                      e.printStackTrace();                      throw e;                  &#125;              &#125;          &#125;          return bytesToHexString(b);      &#125;        /**      * 判断文件类型      *       * @param filePath      *            文件路径      * @return 文件类型      */      public static FileType getType(InputStream is) throws IOException &#123;            String fileHead = getFileContent(is);          if (fileHead == null || fileHead.length() == 0) &#123;              return null;          &#125;          fileHead = fileHead.toUpperCase();          FileType[] fileTypes = FileType.values();            for (FileType type : fileTypes) &#123;              if (fileHead.startsWith(type.getValue())) &#123;                  return type;              &#125;          &#125;            return null;      &#125;      /**     *      * @param value 表示文件类型     * @return 1 表示图片,2 表示文档,3 表示视频,4 表示种子,5 表示音乐,6 表示其它     * @return     */    public static Integer isFileType(FileType value) &#123;          Integer type = 6;// 其他          // 图片          FileType[] pics = &#123; FileType.JPEG, FileType.PNG, FileType.GIF, FileType.TIFF, FileType.BMP, FileType.DWG, FileType.PSD &#125;;            FileType[] docs = &#123; FileType.RTF, FileType.XML, FileType.HTML, FileType.CSS, FileType.JS, FileType.EML, FileType.DBX, FileType.PST, FileType.XLS_DOC, FileType.XLSX_DOCX, FileType.VSD,                  FileType.MDB, FileType.WPS, FileType.WPD, FileType.EPS, FileType.PDF, FileType.QDF, FileType.PWL, FileType.ZIP, FileType.RAR, FileType.JSP, FileType.JAVA, FileType.CLASS,                  FileType.JAR, FileType.MF, FileType.EXE, FileType.CHM &#125;;            FileType[] videos = &#123; FileType.AVI, FileType.RAM, FileType.RM, FileType.MPG, FileType.MOV, FileType.ASF, FileType.MP4, FileType.FLV, FileType.MID &#125;;            FileType[] tottents = &#123; FileType.TORRENT &#125;;            FileType[] audios = &#123; FileType.WAV, FileType.MP3 &#125;;            FileType[] others = &#123;&#125;;            // 图片          for (FileType fileType : pics) &#123;              if (fileType.equals(value)) &#123;                  type = 1;              &#125;          &#125;          // 文档          for (FileType fileType : docs) &#123;              if (fileType.equals(value)) &#123;                  type = 2;              &#125;          &#125;          // 视频          for (FileType fileType : videos) &#123;              if (fileType.equals(value)) &#123;                  type = 3;              &#125;          &#125;          // 种子          for (FileType fileType : tottents) &#123;              if (fileType.equals(value)) &#123;                  type = 4;              &#125;          &#125;          // 音乐          for (FileType fileType : audios) &#123;              if (fileType.equals(value)) &#123;                  type = 5;              &#125;          &#125;          return type;      &#125;        public static void main(String args[]) throws Exception &#123;           System.out.println(                 FileTypeJudge.isFileType(                         FileTypeJudge.getType(                                 new FileInputStream(                                         new File(&quot;C:\\Users\\ituser1\\Desktop\\123.pptx&quot;)))));        for (FileType type : FileType.values()) &#123;              System.out.print(type + &quot;\t&quot;);          &#125;      &#125;  &#125;</code></pre><h3 id="文件下载"><a class="markdownIt-Anchor" href="#文件下载"></a> 文件下载</h3><p>方式一：</p><ul><li>使用apache.commons包中的FileUtils工具类</li></ul><pre><code class="highlight plaintext">public void downloadTemplate(HttpServletRequest request, HttpServletResponse response) &#123;    String dataDirectory = request.getServletContext().getRealPath(&quot;/WEB-INF/download&quot;);    String fileName = &quot;HostBatchTemplate.xlsx&quot;;    File file = new File(dataDirectory, fileName);    response.setCharacterEncoding(&quot;UTF-8&quot;);    response.setContentType(&quot;application/vnd.ms-excel&quot;);    response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot;+fileName);    //response.setContentType(&quot;application/msexcel&quot;);//定义输出类型        try(OutputStream os = response.getOutputStream()) &#123;        byte[] bytes = FileUtils.readFileToByteArray(file);        os.write(bytes);        os.flush();    &#125; catch (IOException e) &#123;        logger.error(e.getMessage());    &#125;&#125;</code></pre><p>方式二：</p><pre><code class="highlight plaintext">@RequestMapping(value = &quot;getUeditorImg/&#123;imgname&#125;/&#123;imgType&#125;&quot;, method = RequestMethod.GET)      public void getUeditorImg(@PathVariable String imgname, @PathVariable String imgType,              HttpServletResponse response) &#123;          if (&quot;null&quot;.equals(imgname) || &quot;null&quot;.equals(imgType) || StringUtils.isBlank(imgname)                  || StringUtils.isNotBlank(imgType)) &#123;              return;          &#125;          BufferedInputStream in = null;          BufferedOutputStream out = null;          try &#123;              DateFormat df = new SimpleDateFormat(&quot;yyyyMMdd&quot;);              String timeStr = imgname.substring(0, imgname.length() - 6);              String dateFile = df.format(new Date(Long.parseLong(timeStr)));              File file = new File(UEDITOR_IMG_PATH + &quot;/&quot; + dateFile + &quot;/&quot; + imgname + &quot;.&quot; + imgType);              in = new BufferedInputStream(new FileInputStream(file));              out = new BufferedOutputStream(response.getOutputStream());              response.setContentType(new MimetypesFileTypeMap().getContentType(file));// 设置response内容的类型              response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename=&quot; + imgname + &quot;.&quot; + imgType);// 设置头部信息              byte[] buffer = new byte[10240];              int length = 0;              while ((length = in.read(buffer)) &gt; 0) &#123;                  out.write(buffer, 0, length);              &#125;              out.flush();          &#125; catch (IOException e) &#123;              getLogger().error(e.getMessage(), e);              writeError500(response, e);          &#125; finally &#123;              try &#123;                  if (in != null) &#123;                      in.close();                  &#125;                  if (out != null) &#123;                      out.close();                  &#125;              &#125; catch (IOException e) &#123;                  e.printStackTrace();              &#125;          &#125;      &#125;</code></pre><h3 id="json数据交互"><a class="markdownIt-Anchor" href="#json数据交互"></a> JSON数据交互</h3><p>JSON数据格式比较简单，解析比较方便，在接口调用及html页面Ajax调用时比较常用</p><p><strong>JSON交互方式</strong></p><ul><li>请求时K/V，响应是JSON（推荐）</li><li>请求时JSON，响应是JSON</li></ul><p><strong>加入依赖</strong></p><pre><code class="highlight plaintext">&lt;dependency&gt;&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;version&gt;2.9.6&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="kvjson"><a class="markdownIt-Anchor" href="#kvjson"></a> kv/json</h4><p><strong>JSP页面</strong></p><pre><code class="highlight plaintext">function responseKV()&#123;$.ajax(&#123;type:&quot;post&quot;,url:&#x27;$&#123;pageContext.request.contextPath &#125;/responseKV&#x27;,//输入是key/value时，默认就指定好了contentType了，不需要再指定了//contentType:&#x27;application/json;charset=utf-8&#x27;,//data为key/value形式data:&#x27;name=json测试&amp;price=999&#x27;,success:function(data)&#123;alert(data);&#125;&#125;);&#125;</code></pre><p><strong>controller类</strong></p><pre><code class="highlight plaintext">// 输入是key/value，输出是json// @ResponseBody 将返回值转成json串响应给前台@RequestMapping(&quot;/responseKV&quot;)@ResponseBodypublic Item responseKV(Item item) &#123;return item;&#125;</code></pre><h4 id="jsonjson"><a class="markdownIt-Anchor" href="#jsonjson"></a> json/json</h4><p><strong>jsp页面</strong></p><pre><code class="highlight plaintext">function requestJson()&#123;$.ajax(&#123;type:&quot;post&quot;,url:&#x27;$&#123;pageContext.request.contextPath &#125;/requestJson&#x27;,//输入是json是 ，需要指定contentType为application/jsoncontentType:&#x27;application/json;charset=utf-8&#x27;,data:&#x27;&#123;&quot;name&quot;:&quot;json测试&quot;,&quot;price&quot;:999&#125;&#x27;,success:function(data)&#123;alert(data.name);&#125;&#125;);&#125;</code></pre><p><strong>controller类</strong></p><p>@RequestBody的作用是将返回值转成json串响应给前台</p><pre><code class="highlight plaintext">@Controllerpublic class JsonController &#123;// 输入是json，输出是json// @RequestBody 将请求的json串转成java对象// @ResponseBody 将返回值转成json串响应给前台@RequestMapping(&quot;/requestJson&quot;)    @ResponseBodypublic Item requestJson(@RequestBody Item item) &#123;return item;&#125;&#125;</code></pre><h3 id="mock测试模拟测试"><a class="markdownIt-Anchor" href="#mock测试模拟测试"></a> Mock测试（模拟测试）</h3><p>在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个<strong>虚拟的对象</strong>来创建以便测试的测试方法，就是<strong>mock测试</strong></p><blockquote><p>Servlet、Request、Response等Servlet API相关对象本来是由Servlet容器（tomcat）创建的</p></blockquote><p>这个虚拟的对象就是mock对象，mock对象就是真实对象在调试期间的代替品</p><h4 id="mock各模块介绍"><a class="markdownIt-Anchor" href="#mock各模块介绍"></a> Mock各模块介绍</h4><p>基于RESTful风格的springMVC的测试，我们可以测试完整的springMVC流程，即从<strong>URL请求到控制器处理，在到视图渲染都可以测试</strong></p><p><strong>MockMVCBuilder</strong></p><ul><li>MockMVCBuilder是用来构造MockMVC的构造器</li><li>其主要有两个实现：StandaloneMockMvcBuilder和DefaultMockMvcBuilder，分别对应之前的两种测试方式。</li><li>对于我们来说直接使用静态工厂MockMvcBuilders创建即可</li></ul><p><strong>MockMVCBuilders</strong></p><ul><li>负责创建MockMVCBuilder对象</li><li>两种创建方式<ul><li><code>standaloneSetup(Object... controllers)</code>:通过参数指定一组控制器，这样就不需要从上下文获取了</li><li><code>webAppContextSetup(WebApplicationContext wac)</code>：指定WebApplicationContext，将会从该上下文获取相应的控制器并得到相应的MockMvc</li></ul></li></ul><p><strong>MockMVC</strong></p><ul><li>对于服务端的spring MVC测试支持主入口点</li><li>通过MockMVCBuilder构造</li><li>MockMVCBuilder由MockMVCBuilders建造者的静态方法去构建</li><li>核心方法：<ul><li>perform(RequestBuilder rb) ：执行一个RequestBuilder请求，会自动执行SpringMVC的流程并映射到相应的控制器执行处理，该方法的返回值是一个ResultActions；</li><li>ResultActions<ul><li>andExpect()：添加ResultMatcher验证规则，验证控制器执行完成后结果是否正确；</li><li>andDo()：添加ResultHandler结果处理器，比如调试时打印结果到控制台；</li><li>andReturn()：最后返回相应的MvcResult；然后进行自定义验证/进行下一步的异步处理；</li></ul></li></ul></li></ul><p><strong>MockMvcRequestBuilders</strong></p><ul><li>用来构建请求的</li><li>其主要有两个子类MockHttpServletRequestBuilder和MockMultipartHttpServletRequestBuilder（如文件上传使用），即用来Mock客户端请求需要的所有数据。</li></ul><p><strong>MockMvcResultMatchers</strong></p><ul><li>用来匹配执行完请求后的<strong>结果验证</strong></li><li>如果匹配失败将抛出相应的异常</li><li>包含了很多验证API方法</li></ul><p><strong>MockMvcResultHandlers</strong></p><ul><li>结果处理器，表示要对结果做点什么事情</li><li>比如此处使用MockMvcResultHandlers.print()输出整个响应结果信息。<br /><strong>MvcResult</strong></li><li>单元测试执行结果，可以针对执行结果进行<strong>自定义验证逻辑。</strong></li></ul><h4 id="mockmvc使用"><a class="markdownIt-Anchor" href="#mockmvc使用"></a> MockMVC使用</h4><p><strong>maven依赖</strong></p><pre><code class="highlight plaintext">&lt;!-- spring 单元测试组件包 --&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-test&lt;/artifactId&gt;&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 单元测试Junit --&gt;&lt;dependency&gt;&lt;groupId&gt;junit&lt;/groupId&gt;&lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Mock测试使用的json-path依赖 --&gt;&lt;dependency&gt;&lt;groupId&gt;com.jayway.jsonpath&lt;/groupId&gt;&lt;artifactId&gt;json-path&lt;/artifactId&gt;&lt;version&gt;2.2.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>测试类</strong></p><ul><li>@WebAppConfiguration：用于声明一个ApplicationContext集成测试加载WebApplicationContext</li></ul><pre><code class="highlight plaintext">import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.MediaType;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.MvcResult;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;import org.springframework.test.web.servlet.result.MockMvcResultHandlers;import org.springframework.test.web.servlet.result.MockMvcResultMatchers;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;//@WebAppConfiguration：可以在单元测试的时候，不用启动Servlet容器，就可以获取一个Web应用上下文@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:spring/*.xml&quot;)@WebAppConfigurationpublic class TestMockMVC &#123;@Autowiredprivate WebApplicationContext wac;private MockMvc mockMvc;@Beforepublic void setup() &#123;// 初始化一个MockMVC对象的方式有两种：单独设置、web应用上下文设置// 建议使用Web应用上下文设置mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();&#125;@Testpublic void test() throws Exception &#123;// 通过perform去发送一个HTTP请求// andExpect：通过该方法，判断请求执行是否成功// andDo :对请求之后的结果进行输出MvcResult result = mockMvc.perform(MockMvcRequestBuilders.get(&quot;/item/showEdit&quot;).param(&quot;id&quot;, &quot;1&quot;)).andExpect(MockMvcResultMatchers.view().name(&quot;item/item-edit&quot;)).andExpect(MockMvcResultMatchers.status().isOk()).andDo(MockMvcResultHandlers.print()).andReturn();System.out.println(&quot;================================&quot;);System.out.println(result.getHandler());&#125;@Testpublic void test2() throws Exception &#123;// 通过perform去发送一个HTTP请求// andExpect：通过该方法，判断请求执行是否成功// andDo :对请求之后的结果进行输出MvcResult result = mockMvc.perform(get(&quot;/item/findItem&quot;).param(&quot;id&quot;, &quot;1&quot;).accept(MediaType.APPLICATION_JSON)).andExpect(status().isOk()).andExpect(content().contentTypeCompatibleWith(MediaType.APPLICATION_JSON)).andExpect(jsonPath(&quot;$.id&quot;).value(1)).andExpect(jsonPath(&quot;$.name&quot;).value(&quot;台式机123&quot;)).andDo(print()).andReturn();System.out.println(&quot;================================&quot;);System.out.println(result.getHandler());&#125;&#125;</code></pre><h3 id="restful支持"><a class="markdownIt-Anchor" href="#restful支持"></a> RESTful支持</h3><h4 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h4><p><strong>什么是REST</strong></p><p>REST（英文：Representational State Transfer，简称 REST，意思是：（资源）<strong>表述性状态转化</strong>）描述了一个架构样式的网络系统， 比如 web 应用程序。</p><p>它是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于<strong>客户端和服务器</strong>交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><p>它本身并没有什么实用性，其核心价值在于如何设计出符合 REST 风格的网络接口</p><p><strong>什么是RESTful</strong></p><p>REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful</p><p><strong>RESTful的特性</strong></p><ul><li><strong>资源</strong>（Resources）：网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个 URI（统一资源定位符）指向它，每种资源对应一个特定的 URI 。要获取这个资源，访问它的 URI 就可以，因此 URI 即为每一个资源的独一无二的识别符。</li><li><strong>表现层</strong>（Representation）：把资源具体呈现出来的形式，叫做它的表现层<br />（Representation）。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式。</li><li><strong>状态转化</strong>（State Transfer）：每发出一个请求，就代表了客户端和服务器的一次交互过程。HTTP协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器， 必须通过某种手段，让服务器端发生“状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是 “ 表现层状态转化” 。具体说， 就是 HTTP 协议里面，四个表示操作方式的动词：GET 、POST 、PUT 、DELETE 。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源</li></ul><p><strong>如何设计RESTful应用程序的API</strong></p><ul><li><strong>路径设计</strong>：数据库设计完毕之后，基本上就可以确定有哪些资源要进行操作，相对于的路径也可以设计出来</li><li><strong>动词设计</strong>：也就是针对资源的具体操作类型，由HTTP动词表示，常用的HTTP动词如下：POST、DELETE、PUT、GET</li></ul><p><strong>RESTful的示例</strong></p><pre><code class="highlight plaintext">/account/1  HTTP GET ：   得到 id = 1 的 account/account/1  HTTP DELETE： 删除 id = 1 的 account/account/1  HTTP PUT：    更新 id = 1 的 account</code></pre><h4 id="springmvc对restful的支持"><a class="markdownIt-Anchor" href="#springmvc对restful的支持"></a> springMVC对RESTful的支持</h4><p><strong>@PathVariable</strong></p><ul><li><strong>URL-PATTERN</strong> ：设置为/，方便拦截RESTful 请求。</li><li>@<strong>PathVariable</strong>：可以解析出来URL中的模板变量（{id}）</li></ul><pre><code class="highlight plaintext">URL:http://localhost:8080/ssm/item/1/zhangsanController:@RequestMapping(“&#123;id&#125;/&#123;name&#125;”)@ResponseBodypublic Item queryItemById(@PathVariable Integer id, @PathVariable String name)</code></pre><hr /><p><strong>使用@PathVariable接收数组</strong></p><pre><code class="highlight plaintext">http://127.0.0.1:8088/years/1,2,3/districtId/1</code></pre><pre><code class="highlight plaintext">@RestControllerpublic class IndexController &#123;    @RequestMapping(&quot;/years/&#123;years&#125;/districtId/&#123;districtId&#125;&quot;)    public String testMethod(@PathVariable String[] years, @PathVariable int districtId) &#123;        String myStr = &quot;&quot;;        for (String temp : years) &#123;            myStr += temp;        &#125;        return &quot;Years is :&quot; + myStr + &quot;&lt;br&gt; districtId is :&quot; + districtId;    &#125;&#125;</code></pre><hr /><p><strong>RESTful的CRUD</strong></p><ul><li>@<strong>RequestMapping</strong>：通过设置method属性的CRUD，可以将同一个URL映射到不同的HandlerMethod方法上</li><li>@<strong>GetMapping</strong>、@<strong>PostMapping</strong>、@<strong>PutMapping</strong>、@<strong>DeleteMapping</strong>注解等价@RequestMapping注解的method属性设置</li></ul><p><strong>RESTful的资源表述</strong></p><ul><li>RESTful服务中一个重要的特性就是<strong>一种资源可以有多种表现形式</strong>，在SpringMVC中可以使用<strong>ContentNegotiatingManager</strong>这个<strong>内容协商管理器</strong>来实现这种方式。</li><li>内容协商的方式有三种：<ul><li><strong>扩展名</strong>,比如.json表示我要JSON格式数据、.xml表示我要XML格式数据</li><li><strong>请求参数</strong>：默认是”format”</li><li><strong>请求头设置Accept参数</strong>，比如设置Accept为application/json表示要JSON格式数据</li></ul></li><li>不过现在RESTful响应的数据一般都是<strong>JSON格式</strong>，所以一般也不使用内容协商管理器，直接使用**@ResponseBody**注解将数据按照JSON格式返回</li></ul><h4 id="静态资源访问mvcresources"><a class="markdownIt-Anchor" href="#静态资源访问mvcresources"></a> 静态资源访问<code>&lt;mvc:resources&gt;</code></h4><p>以前页面可以显示图片是通过servlet跳转到jsp，jsp访问的本地图片，通过配置<a href="">mvc:resources</a>可以直接通过url方法服务器的图片</p><p><strong>如果在DispatcherServlet中设置url-pattern为/则必须对静态资源进行访问处理</strong></p><p>在springmvc.xml文件中，使用mvc:resources标签，具体如下：</p><pre><code class="highlight plaintext">&lt;!--配置静态资源chu&#x27;li--&gt;&lt;!--location：本地资源路径--&gt;&lt;!--mapping：拦截到的网路资源路径--&gt;&lt;!-- 当DispatcherServlet配置为/来拦截请求的时候，需要配置静态资源的访问映射 --&gt;&lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot;/&gt;&lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot;/&gt;&lt;mvc:resources location=&quot;/img/&quot; mapping=&quot;/img/**&quot;/&gt;</code></pre><p>Springmvc会把mapping映射到ResourceHttpRequestHandler，这样静态资源在经过DispatcherServlet转发时就可以找到对应的Handler了</p><h3 id="springmvc父子容器"><a class="markdownIt-Anchor" href="#springmvc父子容器"></a> SpringMVC父子容器</h3><p>springMVC。xml是通过子容器DispatcherServlet加载的，所以为子容器，父容器为ApplicationContext</p><h3 id="跨域处理"><a class="markdownIt-Anchor" href="#跨域处理"></a> 跨域处理</h3><p>由于浏览器对于Javascript的<strong>同源策略</strong>的限制，导致A网站不能通过JS（主要就是Ajax请求）去访问B网站的数据，于是跨域问题就出现了。</p><p>跨域指的是<strong>域名、端口、协议</strong>的组合不同就是跨域。</p><pre><code class="highlight plaintext">http://www.kkb.com/https://www.kkb.comhttp://www.kkb.cnhttp://www.kkb.com:8080/</code></pre><p><strong>为什么要有同源策略？</strong></p><p>我们举例说明：比如一个黑客程序，他利用IFrame把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了</p><h4 id="cors"><a class="markdownIt-Anchor" href="#cors"></a> CORS</h4><p>CORS是一个<strong>W3C</strong>标准，全称是&quot;<strong>跨域资源共享</strong>&quot;（Cross-origin resource</p><p>sharing）。</p><p>它允许浏览器向跨源服务器，发出<strong>XMLHttpRequest</strong>请求，从而克服了AJAX只能同源使用的限制。</p><p>CORS需要<strong>浏览器和服务器同时支持</strong>。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p><p>CORS原理：只需要向响应头header中注入<strong>Access-Control-Allow-Origin</strong>，这样浏览器检测到header中的Access-Control-Allow-Origin，则就可以跨域操作了</p><h4 id="cors请求分类"><a class="markdownIt-Anchor" href="#cors请求分类"></a> CORS请求分类</h4><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）</p><p>只要同时满足以下两大条件，就属于<strong>简单请求</strong></p><p>凡是不同时满足上面两个条件，就属于<strong>非简单请求</strong>。</p><p>浏览器对这两种请求的处理，是不一样的</p><h5 id="简单请求"><a class="markdownIt-Anchor" href="#简单请求"></a> 简单请求</h5><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<strong>Origin</strong>字段</p><p><strong>请求信息</strong></p><p><strong>响应信息</strong></p><p><strong>字段说明</strong></p><ul><li>Access-Control-Allow-Origin<ul><li>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</li></ul></li><li>Access-Control-Allow-Credentials<ul><li>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可</li></ul></li></ul><h5 id="非简单请求"><a class="markdownIt-Anchor" href="#非简单请求"></a> 非简单请求</h5><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;<strong>预检</strong>&quot;请求（preflight）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错</p><p><strong>请求信息</strong></p><p>HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。</p><p>浏览器发现，这是一个非简单请求，就自动发出一个&quot;预检&quot;请求，要求服务器确认可以这样请求。下面是这个&quot;预检&quot;请求的HTTP头信息</p><p>&quot;预检&quot;请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。</p><p>除了Origin字段，&quot;预检&quot;请求的头信息包括两个特殊字段。</p><ul><li><strong>Access-Control-Request-Method</strong><br />该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</li><li><strong>Access-Control-Request-Headers</strong><br />该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header</li></ul><blockquote><p><strong>一旦服务器通过了&quot;预检&quot;请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样</strong>，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段</p></blockquote><h4 id="cors实现"><a class="markdownIt-Anchor" href="#cors实现"></a> CORS实现</h4><p>使用<strong>springmvc的拦截器</strong>实现</p><h5 id="跨域提交cookie"><a class="markdownIt-Anchor" href="#跨域提交cookie"></a> 跨域提交Cookie</h5><pre><code class="highlight plaintext">public class AllowOriginInterceptor implements HandlerInterceptor &#123;     @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object arg2) throws Exception &#123;       // 有跨域行为时参考网址 http://namezhou.iteye.com/blog/2384434       if (request.getHeader(&quot;Origin&quot;) != null) &#123;           response.setContentType(&quot;text/html;charset=UTF-8&quot;);           // 允许哪一个URL          response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);           // 允许那种请求方法          response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE&quot;);          response.setHeader(&quot;XDomainRequestAllowed&quot;, &quot;1&quot;);           System.out.println(&quot;正在跨域&quot;);       &#125;       return true;    &#125; &#125;</code></pre><blockquote><p>然后配置拦截器</p></blockquote><h5 id="跨域提交cookie-2"><a class="markdownIt-Anchor" href="#跨域提交cookie-2"></a> 跨域提交Cookie</h5><p><strong>注意事项</strong></p><ul><li><strong>Access-Control-Allow-Credentials</strong> 为 <strong>true</strong>的时候，Access-Control-Allow-Origin一定不能设置为”* ”，否则<strong>报错</strong></li><li>如果有多个拦截器，一定要把处理跨域请求的拦截器放到<strong>首位</strong></li></ul><p><strong>js代码</strong></p><ul><li>jquery Ajax</li></ul><pre><code class="highlight plaintext">$.ajax(&#123;url: &#x27;自己要请求的url&#x27;,method:&#x27;请求方式&#x27;,  //GET POST PUT DELETExhrFields:&#123;withCredentials:true&#125;,success:function(data)&#123;   //自定义请求成功做什么&#125;,error:function()&#123;//自定义请求失败做什么&#125;&#125;)</code></pre><ul><li>angular JS</li></ul><pre><code class="highlight plaintext">1. 全局 在模块配置中添加app.config([&#x27;$httpProvider&#x27;,function($httpProvider) &#123;   $httpProvider.defaults.withCredentials = true; &#125; ]);2. 单个请求$http.get(url, &#123;withCredentials: true&#125;);$http.post(url,data, &#123;withCredentials: true&#125;);$httpProvider.defaults.withCredentials = true;</code></pre><p><strong>java代码</strong></p><pre><code class="highlight plaintext">public class AllowOriginInterceptor implements HandlerInterceptor &#123;     @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object arg2) throws Exception &#123;       // 有跨域行为时参考网址 http://namezhou.iteye.com/blog/2384434       if (request.getHeader(&quot;Origin&quot;) != null) &#123;           response.setContentType(&quot;text/html;charset=UTF-8&quot;);           // 允许哪一个URL 访问 request.getHeader(&quot;Origin&quot;) 根据请求来的url动态允许          response.setHeader(&quot;Access-Control-Allow-Origin&quot;, request.getHeader(&quot;Origin&quot;));           // 允许那种请求方法          response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE,HEAD&quot;);           response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;0&quot;);           // 允许请求头里的参数列表           response.setHeader(&quot;Access-Control-Allow-Headers&quot;,                  &quot;Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With,userId,token&quot;);           // 允许对方带cookie访问     response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);          response.setHeader(&quot;XDomainRequestAllowed&quot;, &quot;1&quot;);           System.out.println(&quot;正在跨域&quot;);       &#125;       return true;    &#125;&#125;</code></pre><h3 id="pathvariable和requestparam的区别"><a class="markdownIt-Anchor" href="#pathvariable和requestparam的区别"></a> @PathVariable和@RequestParam的区别</h3><p><strong>用法上的不同</strong>：从名字上可以看出来，PathVariable只能用于接收url路径上的参数，而RequestParam只能用于接收请求带的params</p><p>看下面一个例子：</p><pre><code class="highlight plaintext">package com.lrm.springbootdemo.web;import org.springframework.web.bind.annotation.*;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;@RestController@RequestMapping(&quot;/api/v1&quot;)public class HelloController &#123;    @GetMapping(&quot;/books/&#123;username&#125;&quot;)    public Object testPathVariable(@PathVariable String username)&#123;        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;username&quot;,username);        return map;    &#125;    @PostMapping(&quot;/books2&quot;)    public Object testRequestParam(@RequestParam(&quot;name&quot;) String name,                       @RequestParam(&quot;author&quot;) String author,                       @RequestParam(&quot;isbn&quot;) String isbn) &#123;        Map&lt;String, Object&gt; book = new HashMap&lt;String, Object&gt;();        book.put(&quot;name&quot;, name);        book.put(&quot;author&quot;, author);        book.put(&quot;isbn&quot;, isbn);        return book;    &#125;    @PostMapping(&quot;/books2/&#123;id&#125;&quot;)    public Object test(@PathVariable(&quot;id&quot;) long id,@RequestParam(&quot;name&quot;) String name,                       @RequestParam(&quot;author&quot;) String author,                       @RequestParam(&quot;isbn&quot;) String isbn) &#123;        Map&lt;String, Object&gt; book = new HashMap&lt;String, Object&gt;();        book.put(&quot;id&quot;,id);        book.put(&quot;name&quot;, name);        book.put(&quot;author&quot;, author);        book.put(&quot;isbn&quot;, isbn);        return book;    &#125;&#125;</code></pre><p>其中testPathVariable这个方法中的username参数只能使用@PathVariable来接收，因为username参数是url的path上携带的参数。username是无法使用RequestParam来接受的。</p><p>testRequestParam这个方法只能用于</p><pre><code class="highlight plaintext">localhost:8080/api/v1/books2/12?name=java in action&amp;author=ric&amp;isbn=dsdas2334</code></pre><p>这种模式的请求，因为RequestParam只能用于接收请求上带的params，testPathVariable是无法接收上面的name、author、isbn参数的。</p><p><strong>内部参数不同</strong></p><p>PathVariable有value，name，required这三个参数，而RequestParam也有这三个参数，并且比PathVariable多一个参数defaultValue（该参数用于当请求体中不包含对应的参数变量时，参数变量使用defaultValue指定的默认值）</p><p><strong>PathVariable一般用于get和delete请求，RequestParam一般用于post请求</strong></p>]]>
    </content>
    <id>http://example.com/2023/03/16/Spring_MVC/</id>
    <link href="http://example.com/2023/03/16/Spring_MVC/"/>
    <published>2023-03-16T04:00:00.000Z</published>
    <summary>Spring MVC是Spring框架一个非常重要的功能模块，实现了MVC结构，便于简单，快速开发MVC结构的Web程序，Spring Web MVC提供的API封装了Web开发中常用的功能，简化了Web过程。springMVC是为了解决表现层问题的web框架，他们都是基于MVC设计模式的，表现层的主要职责就是处理前端HTTP请求</summary>
    <title>Spring MVC</title>
    <updated>2026-02-26T09:19:24.591Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    <content>
      <![CDATA[<h1 id="spring"><a class="markdownIt-Anchor" href="#spring"></a> $Spring</h1><ul><li><a href="">Spring IOC</a><ul><li><a href="">1. Spring是什么？</a><ul><li><a href="">优点</a></li><li><a href="">Spring的组成</a></li><li><a href="">spring体系结构</a></li><li><a href="">spring容器的核心</a><ul><li><a href="">IoC</a></li><li><a href="">AOP</a></li></ul></li><li><a href="">为什么使用IoC</a></li><li><a href="">Spring IoC源码分析</a><ul><li><a href="">什么是IoC容器</a></li><li><a href="">如何创建IoC容器</a></li><li><a href="">如何创建web环境中的IoC容器</a></li><li><a href="">容器初始化主流程分析</a><ul><li><a href="">创建Bean Factory子流程</a></li><li><a href="">加载解析BeanDefinition子流程（loadDefinitions方法）</a></li><li><a href="">创建bean流程分析</a></li></ul></li></ul></li></ul></li><li><a href="">2.Spring使用</a><ul><li><a href="">启动spring容器</a><ul><li><a href="">spring Maven依赖</a></li><li><a href="">spring核心配置文件 applicationContext.xml</a></li><li><a href="">启动spring容器</a></li></ul></li><li><a href="">Spring Bean定义</a><ul><li><a href="">bean属性</a></li><li><a href="">Bean和spring容器的关系</a></li></ul></li><li><a href="">如何创建对象</a><ul><li><a href="">bean标签详解</a></li><li><a href="">实例化bean的三种方式</a></li><li><a href="">spring 原理</a></li></ul></li><li><a href="">作用域（scope）</a><ul><li><a href="">spring scope原理</a></li></ul></li><li><a href="">生命周期 init-method/destroy-method</a></li><li><a href="">后置处理器</a><ul><li><a href="">Spring_Bean后置处理器</a></li><li><a href="">基础案例</a></li><li><a href="">高级案例</a></li><li><a href="">后置对象原理</a></li></ul></li><li><a href="">延迟加载（lazy-init=“true”）</a></li><li><a href="">Spring Bean定义继承（parent）</a><ul><li><a href="">Bean定义模板（abstract=“true”）</a></li></ul></li><li><a href="">Spring bean依赖关系</a></li><li><a href="">动态工厂DynamicFactory</a><ul><li><a href="">Spring动态工厂原理</a></li></ul></li><li><a href="">静态工厂</a></li></ul></li><li><a href="">3.IOC(Inversion Of Controll 控制反转)</a><ul><li><a href="">IOC实现原理</a></li><li><a href="">DI(Dependency Injection)依赖注入</a><ul><li><a href="">DI概述</a></li><li><a href="">DI 依赖注入原理</a></li></ul></li><li><a href="">1.Set方式注入（property）</a><ul><li><a href="">使用p名称空间注入数据</a></li><li><a href="">Spring注入内部Beans</a></li></ul></li><li><a href="">2构造器方式注入</a></li><li><a href="">3自动装配（了解）</a></li><li><a href="">4 注入基本/集合类型的值</a></li><li><a href="">5 引用的方式注入集合类型的值</a></li><li><a href="">6 注入空值</a></li><li><a href="">7 读取配置文件properties的值</a></li><li><a href="">8 使用spring表达式</a></li></ul></li><li><a href="">Spring IoC注解</a><ul><li><a href="">1.什么是组件扫描</a></li><li><a href="">2.如何进行组件扫描</a></li><li><a href="">3.作用域原型/单例 AND 延迟加载 AND 初始化和销毁 回掉方法</a></li><li><a href="">4 依赖注入相关的注解</a><ul><li><a href="">@Autowired</a></li><li><a href="">@Resource（重点）</a></li><li><a href="">@Value</a><ul><li><a href="">@value(“#{}”)和@value(“${}”)的区别</a></li><li><a href="">通过util:properties</a></li><li><a href="">通过PropertyPlaceholderConfigurer</a></li><li><a href="">通过PreferencesPlaceholderConfigurer</a></li><li><a href="">通过PropertiesFactoryBean</a></li></ul></li></ul></li></ul></li><li><a href="">Java类取代spring xml配置</a><ul><li><a href="">@Configuration和@Bean注解</a></li><li><a href="">@ComponentScan</a></li><li><a href="">@PropertySource</a></li><li><a href="">@Resource</a></li><li><a href="">@Import</a></li><li><a href="">注入List</a></li><li><a href="">生命周期回调</a></li><li><a href="">创建第三方Bean</a></li><li><a href="">初始化和销毁</a></li><li><a href="">使用别名</a></li><li><a href="">@Profile</a></li><li><a href="">@Conditional</a></li><li><a href="">注入Bean的依赖性</a></li><li><a href="">通过注解获取容器</a></li><li><a href="">使用FactoryBean</a></li></ul></li><li><a href="">Spring 分模块开发</a><ul><li><a href="">如何加载多个配置文件</a></li></ul></li><li><a href="">Spring 整合Junit</a></li><li><a href="">Spring中事件处理</a><ul><li><a href="">Spring中的事件处理</a></li><li><a href="">监听上下文</a></li><li><a href="">案例</a><ul><li><a href="">Spring中的自定义事件</a></li></ul></li></ul></li></ul></li></ul><h1 id="spring-ioc"><a class="markdownIt-Anchor" href="#spring-ioc"></a> Spring IOC</h1><pre><code class="highlight plaintext">spring.io</code></pre><h2 id="1-spring是什么"><a class="markdownIt-Anchor" href="#1-spring是什么"></a> 1. Spring是什么？</h2><ul><li>Spring是一个开源的轻量级的应用开发框架，其目的是用于简化企业级应用程序开发，<strong>减少侵入</strong></li><li>Spring提供的IOC和AOP应用，可以将组建的耦合度降至最低，即解耦，便于系统日后的维护和升级</li><li><strong>宗旨</strong><ul><li>不发明重复的轮子</li></ul></li><li>Spring的本质是管理软件中的对象，如何创建对象和维护对象之间的关系</li></ul><hr /><ul><li>是spring框架中的一个核心模块，用来管理对象</li><li>在Spring中，任何的Java类都被当成Bean处理，这些Bean通过容器管理和应用</li><li>Spring容器实现了IOC和AOP机制，这些机制可以简化Bean对象创建和Bean对象之间的解耦</li><li>Spring容器有<strong>BeanFactory</strong>和<strong>ApplicationContext 建议使用</strong>两种类型</li></ul><h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3><ol><li><strong>方便解耦，简化开发</strong> 通过spring提供的ioc容器，我们可以将对象之间的依赖关系交给spring控制，避免硬编码所造成的过度程序耦合。有了spring，用户不用再为单例模式，属性文件解析等底层的需求编写代码，可以更加专注于上层的应用</li><li><strong>AOP编程支持</strong> 通过spring提供的AOP功能，方便的进行面向切面的编程，许多不容易用传统OOP实现的功能可以使用AOP轻松的应付</li><li><strong>声明式事务的支持</strong> 在spring中，我们可以从单调烦闷的事务管理的代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量</li><li><strong>方便程序的测试</strong> 可以用非容器依赖的编程方式进行几乎所有的测试工作，在spring里，测试不再是昂贵的操作，而是随手可做的事情，例如：spring对Junit4支持，可以通过注解方便的测试Spring程序</li><li><strong>方便集成各种优秀的框架</strong> spring对于主流的应用框架提供了集成支持，如hibernate，JPA，Struts，Hessian，Quartz等</li><li><strong>降低Java EE API的使用难度</strong> Spring对于很多难用的Java EE API（如：JDBCJavaMail,远程调用等）提供了一个薄薄的封装层，通过spring的简易封装，这些Java EE API的使用难度大为降低</li><li><strong>Java源码四经典学习范例</strong> spring的源码设计精妙，结构清晰，匠心独运，处处提心着大师对Java设计模式的灵活运用以及对Java技术的高深造诣，spring框架源码无疑式Java技术的最佳实践范例，如果想在短时间迅速提高自己的Java技术水平和应用开发水平，学习和研究spring源码将会使你收到意想不到的效果</li></ol><p><strong>总结起来，spring有如下优点</strong></p><ol><li>低倾入式设计，代码污染极低</li><li>独立于各种应用服务器，基于spring框架的应用，可以真正实现一次编写，到处运行的承诺</li><li>spring的DI机制降低了业务对象替换的复杂性，提高了组件之间的解耦</li><li>spring的AOP支持允许将一些通用任务如安全，事务，日志等进行集中式管理，从而提供了更好的复用</li><li>spring的orm和dao提供了第三方持久层框架的良好整合，并简化了底层的数据库访问</li><li>spring并不强制应用完全依赖于spring，开发者可以自由选用spring框架的部分或者全部</li></ol><h3 id="spring的组成"><a class="markdownIt-Anchor" href="#spring的组成"></a> Spring的组成</h3><ul><li>DAO<ul><li>Spring DAO : 对JDBC的抽象，简化了数据访问异常的处理，Spring提供了对JDBC的操作支持：JdbcTemplate模板工具类</li></ul></li><li>ORM<ul><li>Spring可以和ORM框架整合，例如Spring整合Hibernate框架，其中Spring还提供HibernateDaoSupport工具类，简化了Hibernate操作</li></ul></li><li>AOP<ul><li>Spring提供了面向切面的编程，可以给某一层提供事物管理，例如再Service层添加事物控制</li></ul></li><li>JEE<ul><li>J2EE开发规范的支持，例如EJB</li></ul></li><li>WEB<ul><li>Spring提供了对Struts，Springmvc的支持，支持WEB开发，于此同事Spring自身也提供了基于MVC的解决方案</li></ul></li><li>CORE<ul><li>核心类库，提供IOC容器对象的创建和处理以来对象关系</li></ul></li><li>Context<ul><li>提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）</li></ul></li><li>MVC<ul><li>提供面向Web应用的Model-View-Controller实现</li></ul></li></ul><h3 id="spring体系结构"><a class="markdownIt-Anchor" href="#spring体系结构"></a> spring体系结构</h3><h3 id="spring容器的核心"><a class="markdownIt-Anchor" href="#spring容器的核心"></a> spring容器的核心</h3><p>spring框架的核心就是<strong>ioc（控制反转）和AOP（面向切面编程）</strong></p><ul><li>IoC简单理解就是<strong>控制对象创建的角色</strong>由程序员反转为Spring IoC容器</li><li>AOP简单理解就是针对目标对象进行动态代理，横向增强JavaBean的功能</li></ul><h4 id="ioc"><a class="markdownIt-Anchor" href="#ioc"></a> IoC</h4><p>Spring IoC容器的本质就是<strong>创建类实例的工厂</strong>，并且对类实例进行管理</p><p>Spring IoC容器需要<strong>通过Bean工厂来是实现</strong>，在spring框架中，主要有两个工厂接口：BeanFactory接口和ApplicationContext接口（该接口实现了Bean Factory接口）</p><ul><li>其中BeanFactory接口时Spring早期创建Bean对象的工厂接口</li><li>而我们现在大多数是通过ApplicationContext接口进行Bean工厂的创建</li></ul><p>Spring IoC容器<strong>加载Bean信息</strong>的方式有XML配置方式和注解方式</p><ul><li>XML配置方式：bean标签</li><li>注解方式：@Component、@Controller、@Service、@Repository，需要使用context:component-scan标签配合使用</li></ul><p>Spring IoC<strong>容器的创建方式</strong>主要有两种场景：Java Application中创建（jar包）和在Web Application（war包）中创建（重点）</p><ul><li>在Java application中创建Spring IoC容器主要通过applicationContext接口的两个实现类来完成：<code>ClassPathXmlApplicationContext</code>和<code>FileSystemXmlApplicationContext</code></li><li>在Web Application中创建sprig IoC容器主要是通过ApplicationContext接口的子接口<code>WebApplicationContext</code>来实现的<ul><li>WebApplicationContext是通过<code>ContextLoaderListener</code>（实现ServletcontextListener接口）创建后，放入<code>ServletContext</code>域对象中的</li></ul></li></ul><p>Spring DI(依赖注入)是基于IoC使用的，简单理解就是Bean工厂在生成Bean对象的时候，如果Bean对象需要装配一个属性，那么就会通过DI将属性值注入给对象的属性</p><ul><li>依赖注入的方式主要有<strong>构造方法注入</strong>和<strong>set方式注入</strong></li><li>set方式注入又分为<strong>手动装配方式注入</strong>和<strong>自动装配方式注入</strong><ul><li>手动装配方式（XML方式）：Bean标签的子标签propery，需要在类中指定set方法</li><li>自动装配方式（注解方式）：<code>@Autowired</code>注解，<code>@Resource</code>注解<ul><li>@Autowired：一部分功能是<strong>查找实例</strong>，从spring容器中根据类型（Java类）获取对应的实例，另一部分功能就是<strong>赋值</strong>，将找到的实例，装配给另一个实例的属性值（注意：一个Java类型在同一个spring容器中，只能有一个实例）</li><li>@Resource：一部分功能是<strong>查找实例</strong>，从spring容器中根据Bean的名称（bean标签的名称）获取对应的实例。另一部分功能就是<strong>赋值</strong>，将找到的实例，装配给另一个实力的属性值</li></ul></li></ul></li></ul><h4 id="aop"><a class="markdownIt-Anchor" href="#aop"></a> AOP</h4><p>Spring AOP实现原理是什么？</p><ul><li>动态代理技术（反射）：<strong>基于JDK的动态代理</strong>和使用<strong>CGLib的动态代理</strong></li><li>动态代理方式选择：根据是否实现接口来选择哪种代理方式</li></ul><h3 id="为什么使用ioc"><a class="markdownIt-Anchor" href="#为什么使用ioc"></a> 为什么使用IoC</h3><p>Spring提供的容器又称为IoC容器，什么是IoC？</p><p>IoC全称Inversion of Control，直译为控制反转。那么何谓IoC？在理解IoC之前，我们先看看通常的Java组件是如何协作的。</p><p>我们假定一个在线书店，通过BookService获取书籍：</p><pre><code class="highlight plaintext">public class BookService &#123;    private HikariConfig config = new HikariConfig();    private DataSource dataSource = new HikariDataSource(config);    public Book getBook(long bookId) &#123;        try (Connection conn = dataSource.getConnection()) &#123;            ...            return book;        &#125;    &#125;&#125;</code></pre><p>为了从数据库查询书籍，BookService持有一个DataSource。为了实例化一个HikariDataSource，又不得不实例化一个HikariConfig。</p><p>现在，我们继续编写UserService获取用户：</p><pre><code class="highlight plaintext">public class UserService &#123;    private HikariConfig config = new HikariConfig();    private DataSource dataSource = new HikariDataSource(config);    public User getUser(long userId) &#123;        try (Connection conn = dataSource.getConnection()) &#123;            ...            return user;        &#125;    &#125;&#125;</code></pre><p>因为UserService也需要访问数据库，因此，我们不得不也实例化一个HikariDataSource。</p><p>在处理用户购买的CartServlet中，我们需要实例化UserService和BookService：</p><pre><code class="highlight plaintext">public class CartServlet extends HttpServlet &#123;    private BookService bookService = new BookService();    private UserService userService = new UserService();    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        long currentUserId = getFromCookie(req);        User currentUser = userService.getUser(currentUserId);        Book book = bookService.getBook(req.getParameter(&quot;bookId&quot;));        cartService.addToCart(currentUser, book);        ...    &#125;&#125;</code></pre><p>类似的，在购买历史HistoryServlet中，也需要实例化UserService和BookService：</p><pre><code class="highlight plaintext">public class HistoryServlet extends HttpServlet &#123;    private BookService bookService = new BookService();    private UserService userService = new UserService();&#125;</code></pre><p>上述每个组件都采用了一种简单的通过new创建实例并持有的方式。仔细观察，会发现以下缺点：</p><ol><li>实例化一个组件其实很难，例如，BookService和UserService要创建HikariDataSource，实际上需要读取配置，才能先实例化HikariConfig，再实例化HikariDataSource。</li><li>没有必要让BookService和UserService分别创建DataSource实例，完全可以共享同一个DataSource，但谁负责创建DataSource，谁负责获取其他组件已经创建的DataSource，不好处理。类似的，CartServlet和HistoryServlet也应当共享BookService实例和UserService实例，但也不好处理。</li><li>很多组件需要销毁以便释放资源，例如DataSource，但如果该组件被多个组件共享，如何确保它的使用方都已经全部被销毁？</li><li>随着更多的组件被引入，例如，书籍评论，需要共享的组件写起来会更困难，这些组件的依赖关系会越来越复杂。</li><li>测试某个组件，例如BookService，是复杂的，因为必须要在真实的数据库环境下执行。</li></ol><p>从上面的例子可以看出，如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。</p><p>因此，核心问题是：</p><ul><li>谁负责创建组件？</li><li>谁负责根据依赖关系组装组件？<br />销毁时，如何按依赖顺序正确销毁？</li></ul><p>解决这一问题的核心方案就是IoC。</p><p>传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制，例如：CartServlet创建了BookService，在创建BookService的过程中，又创建了DataSource组件。这种模式的缺点是，一个组件如果要使用另一个组件，必须先知道如何正确地创建它。</p><p>在IoC模式下，<strong>控制权发生了反转</strong>，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，例如，BookService自己并不会创建DataSource，而是等待外部通过setDataSource()方法来注入一个DataSource：</p><pre><code class="highlight plaintext">public class BookService &#123;    private DataSource dataSource;    public void setDataSource(DataSource dataSource) &#123;        this.dataSource = dataSource;    &#125;&#125;</code></pre><p>不直接new一个DataSource，而是注入一个DataSource，这个小小的改动虽然简单，却带来了一系列好处：</p><ol><li>BookService不再关心如何创建DataSource，因此，不必编写读取数据库配置之类的代码；</li><li>DataSource实例被注入到BookService，同样也可以注入到UserService，因此，共享一个组件非常简单；</li><li>测试BookService更容易，因为注入的是DataSource，可以使用内存数据库，而不是真实的MySQL配置。</li></ol><p>因此，IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：<strong>将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期</strong>。</p><p>因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。一种最简单的配置是通过XML文件来实现，例如：</p><pre><code class="highlight plaintext">&lt;beans&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;HikariDataSource&quot; /&gt;    &lt;bean id=&quot;bookService&quot; class=&quot;BookService&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;/bean&gt;    &lt;bean id=&quot;userService&quot; class=&quot;UserService&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为dataSource的组件通过属性dataSource（即调用setDataSource()方法）注入到另外两个组件中。</p><p>在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。</p><h3 id="spring-ioc源码分析"><a class="markdownIt-Anchor" href="#spring-ioc源码分析"></a> Spring IoC源码分析</h3><h4 id="什么是ioc容器"><a class="markdownIt-Anchor" href="#什么是ioc容器"></a> 什么是IoC容器</h4><p>所谓的IoC容器就是指spring中bean工厂里面的Map存储结构（存储了Bean实例）</p><p><strong>spring框架中的工厂有哪些？</strong></p><ul><li><code>ApplicationContext</code>接口（）<ul><li>实现了BeanFactory接口</li><li>实现ApplicationContext接口的工厂，可以获取到容器中具体的Bean对象</li></ul></li><li><code>BeanFactory</code>工厂（是Spring框架早期的创建Bean对象的工厂接口）<ul><li>实现BeanFactory接口的工厂也可以获取到Bean对象</li></ul></li></ul><blockquote><p>其实通过源码分析，不管是<code>BeanFactory</code>还是<code>ApplicationContext</code>，其实最终的底层<code>BeanFactory</code>都是<code>DefaultListableBeanFactory</code></p></blockquote><p><strong>ApplicationContext和BeanFactory的区别？</strong></p><ul><li><code>BeanFactory</code>采取延迟加载，第一次getBean时才会初始化Bean。</li><li><code>ApplicationContext</code>是加载完applicationContext.xml时，就创建具体的Bean对象的实例。（只对BeanDefition中描述为是单例的bean，才进行饿汉式加载）</li></ul><p><strong>继承结构</strong></p><h4 id="如何创建ioc容器"><a class="markdownIt-Anchor" href="#如何创建ioc容器"></a> 如何创建IoC容器</h4><p><strong>创建方式</strong></p><p>Application接口常用实现类</p><ul><li><code>ClassPathXmlApplicationContext</code>: 它是从类的根路径下加载配置文件，推荐使用这种</li><li><code>FileSystemXmlApplicationContext</code>: 它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置</li><li><code>AnnotationConfigApplicationContext</code>: 当我们使用注解配置容器对象时，需要使用此类来创建spring容器，它用来读取注解</li></ul><p><strong>Java应用中创建IoC容器</strong></p><pre><code class="highlight plaintext">ApplicationContext context = new ClassPathXmlApplicationContext(xml路径)</code></pre><h4 id="如何创建web环境中的ioc容器"><a class="markdownIt-Anchor" href="#如何创建web环境中的ioc容器"></a> 如何创建web环境中的IoC容器</h4><p>web.xml中配置ContextLoaderListener接口，并配置ContextConfigLocation参数</p><ol><li><p>web服务器tomcat启动会加载web.xml（启动<strong>ContextLoaderListener</strong>监听器）</p></li><li><p>web服务器启动后，会创建ServletContext（web上下文，也就是web容器）此时会触发ContextLoaderListener监听器的<strong>contextInitialized</strong>()方法</p></li><li><p>contextInitialized()方法中会调用<strong>initWebApplicationContext</strong>()方法，该方法负责创建spring容器（<strong>DefaultListableBeanFctory</strong>）和生产bean对象</p></li><li><p>initWebApplicationContext()方法负责创建WebApplicationContext，通过createWebApplicationContext()方法</p></li></ol><blockquote><p>WebApplicationContext是一个接口，此处创建的是它的默认实现类，XmlWebApplicationContext（Web容器中真正的实例）</p></blockquote><ol><li><p>加载spring配置文件，并创建beans，通过configureAndRefreshWebApplicationContext()方法</p></li><li><p>将spring容器context挂载到ServletContext这个web容器的上下文中，通过servletContext.setAttribute()方法</p></li></ol><hr /><p><strong>Web三类八种监听器</strong></p><p><strong>监听域对象的生命周期：</strong></p><p>ServletContextListener:</p><ul><li>创建：服务器启动</li><li>销毁：服务器正常关闭</li><li>spring ContextLoaderListener（服务器启动时负责加载spring配置文件）</li></ul><p>HttpSessionListener</p><ul><li>创建：第一次访问request.getHttpSession()</li><li>销毁：调用invalidate()，非法关闭，国企</li></ul><p>ServletRequestListener</p><ul><li>创建：每一次访问</li><li>销毁：响应结束</li></ul><p><strong>监听域对象的属性：（添加，删除，替换）</strong></p><ul><li>ServletContextAttributeListener</li><li>HttpSessionAttributeListener</li><li>ServletRequestAttributeListener</li></ul><p><strong>监听HttpSession中JavaBean的改变：</strong></p><ul><li>HttpSessionBindingListener（HttpSession和JavaBean对象的绑定和解绑）</li><li>HttpSessionActivationListener（HttpSession的序列化，活化、钝化）</li></ul><h4 id="容器初始化主流程分析"><a class="markdownIt-Anchor" href="#容器初始化主流程分析"></a> 容器初始化主流程分析</h4><p>主流程入口</p><pre><code class="highlight plaintext">ApplicationContext context = new ClassPathXmlApplicationContext（“spring.xml”）</code></pre><p>ClassPathXmlApplicationContext类：重载的构造方法依次调用，进入下面代码</p><p>AbstractApplicationContext的refresh方法：初始化spring容器的核心代码</p><pre><code class="highlight plaintext">public void refresh() throws BeansException, IllegalStateException &#123;    synchronized (this.startupShutdownMonitor) &#123;        // Prepare this context for refreshing.        prepareRefresh();        // 1.创建真正的Spring容器（DefaultListableBeanFactory）        // 2.加载BeanDefition（描述要初始化的Bean的信息）        // 3.将BeanDefition注册到BeanDefitionRegistry        // Tell the subclass to refresh the internal bean factory.        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();        // Prepare the bean factory for use in this context.        prepareBeanFactory(beanFactory);        try &#123;            // Allows post-processing of the bean factory in context subclasses.            postProcessBeanFactory(beanFactory);            // 执行实现了BeanFactoryPostProcessor接口的Bean            // 比如PropertyPlaceHolderConfigurer（context:property-placeholer）就是此处被调用的，替换掉BeanDefition中的占位符（$&#123;&#125;）中的内容            // Invoke factory processors registered as beans in the context.            invokeBeanFactoryPostProcessors(beanFactory);            // 注册BeanPostProcessor（后置处理器）            // 比如容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器（实现@Autowired注解功能）            // Register bean processors that intercept bean creation.            registerBeanPostProcessors(beanFactory);            // Initialize message source for this context.            initMessageSource();            // Initialize event multicaster for this context.            initApplicationEventMulticaster();            // Initialize other special beans in specific context subclasses.            onRefresh();            // Check for listener beans and register them.            registerListeners();            // 初始化非懒加载方式的单例Bean实例            // Instantiate all remaining (non-lazy-init) singletons.            finishBeanFactoryInitialization(beanFactory);            // Last step: publish corresponding event.            finishRefresh();        &#125;catch (BeansException ex) &#123;            if (logger.isWarnEnabled()) &#123;                logger.warn(&quot;Exception encountered during context initialization - &quot; +                        &quot;cancelling refresh attempt: &quot; + ex);            &#125;            // Destroy already created singletons to avoid dangling resources.            destroyBeans();            // Reset &#x27;active&#x27; flag.            cancelRefresh(ex);            // Propagate exception to caller.            throw ex;        &#125;        finally &#123;            // Reset common introspection caches in Spring&#x27;s core, since we            // might not ever need metadata for singleton beans anymore...            resetCommonCaches();        &#125;    &#125;&#125;</code></pre><p>流程说明：</p><ol><li>ResourceLoader从存储介质中加载Spring配置信息，并使用Resource表示这个配置文件的资源；</li><li>BeanDefinitionReader读取Resource所指向的配置文件资源，然后解析配置文件。配置文件中每一个<bean>解析成一个BeanDefinition对象，并保存到BeanDefinitionRegistry中；</li><li>容器扫描BeanDefinitionRegistry中的BeanDefinition，使用Java的反射机制自动识别出Bean工厂后处理后器（实现BeanFactoryPostProcessor接口）的Bean，然后调用这些Bean工厂后处理器对BeanDefinitionRegistry中的BeanDefinition进行加工处理。主要完成以下两项工作：<ul><li>对使用到占位符的<bean>元素标签进行解析，得到最终的配置值，这意味对一些半成品式的BeanDefinition对象进行加工处理并得到成品的BeanDefinition对象；</li><li>对BeanDefinitionRegistry中的BeanDefinition进行扫描，通过Java反射机制找出所有属性编辑器的Bean（实现java.beans.PropertyEditor接口的Bean），并自动将它们注册到Spring容器的属性编辑器注册表中（PropertyEditorRegistry）；</li></ul></li><li>Spring容器从BeanDefinitionRegistry中取出加工后的BeanDefinition，并调用InstantiationStrategy着手进行Bean实例化的工作；</li><li>在实例化Bean时，Spring容器使用BeanWrapper对Bean进行封装，BeanWrapper提供了很多以Java反射机制操作Bean的方法，它将结合该Bean的BeanDefinition以及容器中属性编辑器，完成Bean属性的设置工作；</li><li>利用容器中注册的Bean后处理器（实现BeanPostProcessor接口的Bean）对已经完成属性设置工作的Bean进行后续加工，直接装配出一个准备就绪的Bean。<br />Spring容器确实堪称一部设计精密的机器，其内部拥有众多的组件和装置。Spring的高明之处在于，它使用众多接口描绘出了所有装置的蓝图，构建好Spring的骨架，继而通过继承体系层层推演，不断丰富，最终让Spring成为有血有肉的完整的框架。所以查看Spring框架的源码时，有两条清晰可见的脉络：<ul><li>接口层描述了容器的重要组件及组件间的协作关系；</li><li>继承体系逐步实现组件的各项功能。</li></ul></li><li>接口层清晰地勾勒出Spring框架的高层功能，框架脉络呼之欲出。有了接口层抽象的描述后，不但Spring自己可以提供具体的实现，任何第三方组织也可以提供不同实现， 可以说Spring完善的接口层使框架的扩展性得到了很好的保证。纵向继承体系的逐步扩展，分步骤地实现框架的功能，这种实现方案保证了框架功能不会堆积在某些类的身上，造成过重的代码逻辑负载，框架的复杂度被完美地分解开了。</li></ol><p>Spring组件按其所承担的角色可以划分为两类：</p><ul><li>物料组件：Resource、BeanDefinition、PropertyEditor以及最终的Bean等，它们是加工流程中被加工、被消费的组件，就像流水线上被加工的物料；</li><li>加工设备组件：ResourceLoader、BeanDefinitionReader、BeanFactoryPostProcessor、InstantiationStrategy以及BeanWrapper等组件像是流水线上不同环节的加工设备，对物料组件进行加工处理。</li></ul><h5 id="创建bean-factory子流程"><a class="markdownIt-Anchor" href="#创建bean-factory子流程"></a> 创建Bean Factory子流程</h5><p>子流程入口（从主流程refresh方法中的第二步开始）</p><p>调用AbstractApplicationContext中的obtainFreshBeanFactory方法</p><p>调用AbstractRefreshableApplicationContext的refreshBeanFactory方法</p><h5 id="加载解析beandefinition子流程loaddefinitions方法"><a class="markdownIt-Anchor" href="#加载解析beandefinition子流程loaddefinitions方法"></a> 加载解析BeanDefinition子流程（loadDefinitions方法）</h5><p>此处依次调用多个类的loadBeanDefinitions方法（AbstractXmlApplicationContextà</p><p>AbstractBeanDefinitionReaderà XmlBeanDefinitionReader），一直调用到XmlBeanDefinitionReader 类的doLoadBeanDefinitions方法</p><p>对于doLoadDocument方法不是我们关注的重点，我们进入到该类的registerBeanDefinitions方法看看</p><p>此处有两个地方是我们关注的：一个createRederContext方法，一个是DefaultBeanDefinitionDocumentReader类的registerBeanDefinitions方法，先进入createRederContext方法看看</p><p>至此，14个NamespaceHandlerResolver初始化成功。然后我们再进入DefaultBeanDefinitionDocumentReader类的registerBeanDefinitions方法</p><p>继续进入到该类的doRegisterBeanDefinitions方法看看，这是真正干活的方法</p><p>继续进入parseBeanDefinitions方法</p><p>我们看到有两种解析方案，先看看parseDefaultElement方法</p><p>不过我们重点看看BeanDefinitionParserDelegate类的parseCustomElement方法（AOP标签、tx标签的解析都是在该步骤中完成的）</p><p>getNamespaceURI方法的作用一目了然，我们就不去追踪了，接下来我们进入DefaultNamespaceHandlerResolver类的resolve方法看看：</p><p>在上面代码中，我们看到了一行代码：namespaceHandler.init();这个方法是很重要的。它实现了自定义标签到处理类的注册工作，不过NamespaceHandler是一个接口，具体的init方法需要不同的实现类进行实现，我们通过AopNamespaceHandler了解一下init的作用，其中aop:config标签是由ConfigBeanDefinitionParser类进行处理：</p><p>至此，我们了解到了xml中的aop标签都是由哪些类进行处理的了。不过init方法只是注册了标签和处理类的对应关系，那么什么时候调用处理类进行解析的呢？我们再回到BeanDefinitionParserDelegate类的parseCustomElement方法看看</p><p>我们看到，最后一行执行了parse方法，那么parse方法，在哪呢？我们需要到NamespaceHandlerSupport类中去看看，它是实现NamespaceHandler接口的，并且AopNamespaceHandler是继承了NamespaceHandlerSupport类，那么该方法也会继承到AopNamespaceHandler类中。</p><p>至此，整个XML文档的解析工作，包括bean标签以及自定义标签如何解析为BeanDefinition信息的过程，我们已经了解了</p><h5 id="创建bean流程分析"><a class="markdownIt-Anchor" href="#创建bean流程分析"></a> 创建bean流程分析</h5><p>子流程入口</p><p>我们进入finishBeanFactoryInitialization方法看看：</p><p>继续进入DefaultListableBeanFactory类的preInstantiateSingletons方法，我们找到下面部分的代码，看到工厂Bean或者普通Bean，最终都是通过getBean的方法获取实例的。</p><p>继续跟踪下去，我们进入到了AbstractBeanFactory类的doGetBean方法，这个方法中的代码很多，我们直接找到核心部分：</p><p>接着进入到AbstractAutowireCapableBeanFactory类的方法，找到以下代码部分</p><p>我们终于找到核心的地方了，进入doCreateBean方法看看，该方法我们关注两块重点区域：</p><p>对于如何创建Bean的实例，和填充属性，暂时先不去追踪了，我们先去看看initializeBean方法是如何调用BeanPostProcessor的，因为这个牵扯到我们对于AOP动态代理的理解</p><h2 id="2spring使用"><a class="markdownIt-Anchor" href="#2spring使用"></a> 2.Spring使用</h2><h3 id="启动spring容器"><a class="markdownIt-Anchor" href="#启动spring容器"></a> 启动spring容器</h3><h4 id="spring-maven依赖"><a class="markdownIt-Anchor" href="#spring-maven依赖"></a> spring Maven依赖</h4><p>Spring框架的基础依赖</p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.lee.SimpleSpring&lt;/groupId&gt;    &lt;artifactId&gt;SimpleSpring&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;    &lt;!--Spring核心组件中的四个依赖--&gt;        &lt;!--spring5.0 核心工具包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--spring5.0 Bean管理工具包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;            &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;c        &lt;/dependency&gt;        &lt;!--spring5.0 context管理工具包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--spring5.0 AOP工具包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;            &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 单元测试Junit--&gt;        &lt;dependency&gt;              &lt;groupId&gt;junit&lt;/groupId&gt;              &lt;artifactId&gt;junit&lt;/artifactId&gt;              &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;            &lt;/dependencies&gt;    &lt;!--这里的配置影响构建过程--&gt;    &lt;build&gt;          &lt;plugins&gt;              &lt;!-- 配置Maven的JDK编译级别 --&gt;              &lt;plugin&gt;                   &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                   &lt;artifactId&gt;maven-compiler-plugin&lt;/u&gt;&lt;/artifactId&gt;                   &lt;version&gt;3.2&lt;/version&gt;                   &lt;configuration&gt;                            &lt;source&gt;1.8&lt;/source&gt;                            &lt;target&gt;1.8&lt;/target&gt;                            &lt;encoding&gt;UTF-8&lt;/encoding&gt;                   &lt;/configuration&gt;              &lt;/plugin&gt;          &lt;/plugins&gt;     &lt;/build&gt;&lt;/project&gt;</code></pre><h4 id="spring核心配置文件-applicationcontextxml"><a class="markdownIt-Anchor" href="#spring核心配置文件-applicationcontextxml"></a> spring核心配置文件 applicationContext.xml</h4><p>xml命名空间：xmlns表示的那几行</p><p>如果命名空间没有声明，则下面无法使用</p><p>例子： <code>xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</code></p><p><code>xsi:schemaLocation=&quot;http://www.springframework.org/schema/context</code>    <code>http://www.springframework.org/schema/context/spring-context.xsd</code></p><p><strong>xmlns与xsi:schemaLocation是一一对应的</strong></p><blockquote><p>在spring的xml配置文件中配置一个bean标签，该标签最终会被加载为一个BeanDefition对象（描述对象信息）</p></blockquote><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;     &lt;bean id=&quot;teacher&quot; class=&quot;com.lee.beans.Teacher&quot;&gt;        &lt;property name=&quot;tname&quot; value=&quot;leeBo&quot;&gt;&lt;/property&gt;     &lt;/bean&gt;          &lt;bean id=&quot;student&quot; class=&quot;com.lee.beans.Student&quot;&gt;        &lt;property name=&quot;sname&quot; value=&quot;mike&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;age&quot; value=&quot;22&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;teacher&quot; ref=&quot;teacher&quot;&gt;&lt;/property&gt;     &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>一般的目录结构：</p><h4 id="启动spring容器-2"><a class="markdownIt-Anchor" href="#启动spring容器-2"></a> 启动spring容器</h4><pre><code class="highlight plaintext">       public static void main(String[] args) &#123;             //启动spring容器             ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);             System.err.println(ac);       &#125;</code></pre><hr /><ul><li>使用BeanFactory启动容器<ul><li>第一步利用框架提供的XmlBeanFactory()API去生成工厂bean以及利用<strong>ClassPathResource</strong>()去加载在路劲CLASSPATH下可用的bean配置文件，<strong>XmlBeanFactory</strong>()负责创建并初始化所有的对象，即在配置文件中提到的bean</li></ul></li></ul><pre><code class="highlight plaintext">import ....public class MainApp &#123;   public static void main(String[] args) &#123;      XmlBeanFactory factory = new XmlBeanFactory                             (new ClassPathResource(&quot;Beans.xml&quot;));      HelloWorld obj = (HelloWorld) factory.getBean(&quot;helloWorld&quot;);      obj.getMessage();   &#125;&#125;</code></pre><p>BeanFactory和ApplicationContext的区别在于，BeanFactory的实现是按需创建，即第一次获取Bean时才创建这个Bean，而ApplicationContext会一次性创建所有的Bean。实际上，ApplicationContext接口是从BeanFactory接口继承而来的，并且，ApplicationContext提供了一些额外的功能，包括国际化支持、事件和通知机制等。通常情况下，我们总是使用ApplicationContext，很少会考虑使用BeanFactory。</p><ul><li><strong>ApplicationContext</strong>继承自BeanFactory接口，该容器为较高级的容器，有BeanFacory所具有的全部功能，并增加了企业所需要的功能</li><li>最常被使用的ApplicationContext接口实现<ul><li><strong>FileSystemXmlApplicationContext</strong>：该容器从XML文件中加载被定义的bean，需要提供XML文件的完整路劲</li><li><strong>ClassPathXmlApplicationContext</strong>：该容器从XML文件中加载被定义的bean，不需要完整路径，正确配置CLASSPATH环境变量，容器会从CLASSPATH中搜索bean配置文件</li><li><strong>WebXmlApplicationContext</strong>：该容器会在一个web应用程序的范围内加载在XML文件中已被定义的bean</li></ul></li><li>实例化方法如下：</li></ul><pre><code class="highlight plaintext">//加载文件系统中的配置文件实例化String conf = &quot;C:\applicationContext.xml&quot;;ApplicationContext ac = new FileSystemXmlApplicationContext(conf);//加载工程classpath下的配置文件实例化String conf = &quot;applicationContext.xml&quot;;ApplicationContext ac = new ClassPathXmlApplicationContext(conf);</code></pre><h3 id="spring-bean定义"><a class="markdownIt-Anchor" href="#spring-bean定义"></a> Spring Bean定义</h3><ul><li><strong>bean对象是构成应用程序的支柱也是由Spring IOC容器管理的，bean是一个被实例化，组装，并通过Spring IOC容器所管理的对象</strong></li></ul><hr /><ul><li><strong>如何创建一个Bean</strong></li><li><strong>bean的生命周期</strong></li><li><strong>bean的以来关系</strong></li></ul><h4 id="bean属性"><a class="markdownIt-Anchor" href="#bean属性"></a> bean属性</h4><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><strong>id</strong></td><td>id标签是bean的唯一标识，IoC容器中bean的id标签不能重复，否则报错。</td></tr><tr><td><strong>class</strong></td><td>强制的，用来指定创建bean的类路径</td></tr><tr><td><strong>scope</strong></td><td>指定由特定的bean定义创建的对象的作用域</td></tr><tr><td><strong>autowire</strong></td><td>autowire表示bean的自动装配</td></tr><tr><td>factory-method</td><td>factory-method工厂方法属性，通过该属性，我们可以调用一个指定的静态工厂方法，创建bean实例</td></tr><tr><td>factory-bean</td><td>顾名思义，factory-bean就是生成bean的工厂对象，factory-bean属性和factory-method属性一起使用，首先要创建生成bean的工厂类和方法</td></tr><tr><td>init-method</td><td>bean的初始方法，在创建好bean后调用该方法</td></tr><tr><td>destory-method</td><td>是bean的销毁方法，在销毁bean之前调用该方法，一般在该方法中释放资源</td></tr><tr><td>name</td><td>唯一的bean标识符,与id等义</td></tr></tbody></table><h4 id="bean和spring容器的关系"><a class="markdownIt-Anchor" href="#bean和spring容器的关系"></a> Bean和spring容器的关系</h4><h3 id="如何创建对象"><a class="markdownIt-Anchor" href="#如何创建对象"></a> 如何创建对象</h3><h4 id="bean标签详解"><a class="markdownIt-Anchor" href="#bean标签详解"></a> bean标签详解</h4><p><strong>bean标签的作用</strong></p><ul><li>用于配置对象让spring来创建的</li><li>默认情况下它调用的是类中的无参构造器，如果没有无参构造函数，则不能创建成功</li></ul><p><strong>bean标签属性</strong></p><ul><li><strong>id</strong>：给对象在容器中提供一个<strong>唯一标识</strong>，用于获取对象</li><li><strong>class</strong>：指定类的全限定名，用于反射出啊关键对象，默认情况下调用<strong>无参构造函数</strong></li><li><strong>scope</strong>：指定对象的作用范围<ul><li>singleton：默认值，单例的（在整个容器中只有一个对象）</li><li>prototype：多例的</li><li>request：web项目中，spring创建一个bean对象，将对象存入到request域中</li><li>session：web项目中，spring创建一个bean对象，将对象存入到session域中</li><li>global session：web项目中，应用在Portlet环境，如果没有Portlet环境那么globalSession相当于session</li></ul></li><li>init-method：指定类中的初始化方法名称</li><li>destroy-method：指定类中销毁方法名称，比如DataSource的配置中一般需要指定destroy-method=“close”</li></ul><p><strong>bean的作用范围：</strong></p><ul><li>单例对象：scope=“singleton”<ul><li>一个应用只有一个对象的实例。它的作用范围就是整个引用。</li><li>生命周期：<ul><li>对象出生：当应用加载，创建容器时，对象就被创建了。</li><li>对象活着：只要容器在，对象一直活着。</li><li>对象死亡：当应用卸载，销毁容器时，对象就被销毁了。</li></ul></li></ul></li><li>多例对象：scope=“prototype”<ul><li>每次访问对象时，都会重新创建对象实例。</li><li>生命周期：<ul><li>对象出生：当使用对象时，创建新的对象实例。</li><li>对象活着：只要对象在使用中，就一直活着。</li><li>对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了。</li></ul></li></ul></li></ul><h4 id="实例化bean的三种方式"><a class="markdownIt-Anchor" href="#实例化bean的三种方式"></a> 实例化bean的三种方式</h4><ul><li><strong>方式1 使用无参构造器（重点）</strong></li></ul><ol><li>给类添加无参构造器（或者缺省构造器）<ul><li>在默认情况下：他会根据默认无参构造函数来创建类对象</li><li>如果bean中没有默认无参构造函数，将会创建失败</li><li><code>&lt;bean /&gt;</code><ul><li>id：给对象在容器中提供一个唯一标识。用于获取对象</li><li>class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数</li></ul></li></ul></li></ol><blockquote><p>如果我们没有创建构造器，系统会为我们自动创建一个无参构造器，如果我们创建了构造器，那么系统将不会为我们创建无参构造器</p></blockquote><pre><code class="highlight plaintext">package com.lee.first;public class Student &#123;       public Student()&#123;             System.out.println(&quot;Student()&quot;);       &#125;&#125;</code></pre><ol><li>使用<bean>元素<ul><li>①xmlns=“<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>”，默认命名空间：它没有空间名，用于Spring Bean的定义；</li><li>②xmlns:xsi=“<a href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>”，xsi命名空间：这个命名空间用于为每个文档中命名空间指定相应的Schema样式文件，是标准组织定义的标准命名空间</li></ul></li></ol><pre><code class="highlight plaintext">applicationContet.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;       &lt;!--IoC XML配置方式管理bean--&gt;        &lt;!--使用无参构造器创建属性--&gt;        &lt;!-- id属性：整个spring容器中要求唯一 --&gt;            &lt;!--class属性：类的全限定名（要求包含包名）,容器会自动调用无参构造器创建对象--&gt;       &lt;bean id=&quot;stu1&quot; class=&quot;com.lee.first.Student&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;date1&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><ol><li>调用容器的getBean方法来获得对象</li></ol><pre><code class="highlight plaintext">@Testpublic void test1&#123;    //创建spring容器     ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);     //从容器中获取Bean实例     //方式一：根据类型从容器中获取Bean实例     Student stu = ac.getBean(Student.class);     //方式二：根据bean的id从容器中获取bean实例     Student stu = (Student)ac.getBean(&quot;stu1&quot;);     System.out.println(stu);   &#125;</code></pre><ul><li><strong>方式2 使用静态工厂方法（了解）</strong><ol><li>通过调用类的静态方法来创建对象</li></ol></li><li><code>&lt;bean factory-method=&quot;&quot;/&gt;</code><ul><li>id属性用于指定 bean名称</li><li>class属性用于指定工厂类型</li><li>factory-method属性用于指定工厂中创建bean对象的方法，必须用static修饰的方法</li></ul></li></ul><pre><code class="highlight plaintext"> applicationContet.xml&lt;!--    使用静态工厂方法创建对象    factory-method属性：指定一个   静态方法   spring容器会调用这个静态方法来创建对象   当使用getBean方法调用cal1时，返回的是Calendar类中getInstance方法的返回值       --&gt;       &lt;bean id=&quot;cal1&quot; class=&quot;java.util.Calendar&quot; factory-method=&quot;getInstance&quot;&gt;&lt;/bean&gt;</code></pre><ul><li><strong>方式3 使用实例工厂方法来创建对象（了解）</strong><ol><li>通过调用对象的实例方法来创建对象</li></ol></li></ul><pre><code class="highlight plaintext"> applicationContet.xml       &lt;!--     使用实例工厂方法创建对象    factory-bean属性：指定一个bean的id    factory-method属性：指定一个方法    spring容器会调用这个bean的对应的方法来创建对象    表示调用id为cal1的类的getTime方法        --&gt;&lt;bean id=&quot;time1&quot; factory-bean=&quot;cal1&quot; factory-method=&quot;getTime&quot;&gt;&lt;/bean&gt;</code></pre><blockquote><p><strong>Bean的别名</strong></p><p>为已经定义好的Bena，再增加另外一个名字引用</p><p><code>&lt;alias name=&quot;fromName&quot; alias=&quot;toName&quot;/&gt;</code></p></blockquote><h4 id="spring-原理"><a class="markdownIt-Anchor" href="#spring-原理"></a> spring 原理</h4><ol><li>spring框架启动时<code>ApplicationContext ac = new ClassPathXmlApplicationContext(conf);</code>，会加载核心配置文件，实际就是通过xml解析器解析配置文件中的xml属性</li><li>然后用每个<bean>标签中的classpath通过<code>class.forName(classpath)</code>获取Class对象，然后<code>clazz.newInstance()</code>创建出实例对象，把该bean的id和实际对象存入Map中</li><li>每当<code>factory.getBean(beanId);</code>时，就通过Map键值取得value值返回</li></ol><pre><code class="highlight plaintext">public class BeanDefined &#123;private String beanId;private String classPath;public String getBeanId() &#123;return beanId;&#125;public void setBeanId(String beanId) &#123;this.beanId = beanId;&#125;public String getClassPath() &#123;return classPath;&#125;public void setClassPath(String classPath) &#123;this.classPath = classPath;&#125;&#125;</code></pre><p>模拟spring工厂的getBean方法，初始版</p><pre><code class="highlight plaintext">import java.util.List;public class BeanFactory &#123;   private List&lt;BeanDefined&gt; beanDefinedList;public List&lt;BeanDefined&gt; getBeanDefinedList() &#123;return beanDefinedList;&#125;public void setBeanDefinedList(List&lt;BeanDefined&gt; beanDefinedList) &#123;this.beanDefinedList = beanDefinedList;&#125;public Object getBean(String beanId) throws Exception&#123;   Object instance;   for(BeanDefined beanObj:beanDefinedList)&#123;     if(beanId.equals(beanObj.getBeanId()))&#123;     String classPath = beanObj.getClassPath();      Class classFile= Class.forName(classPath); //在默认情况下，Spring工厂是通过调用当前类默认工作方法创建实例对象 instance= classFile.newInstance(); return instance;     &#125;   &#125;   return null;&#125;&#125;</code></pre><p><strong>测试使用</strong></p><pre><code class="highlight plaintext">public class TestMain &#123;public static void main(String[] args) throws Exception &#123;  //1.声明注册bean  BeanDefined beanObj = new BeanDefined();  beanObj.setBeanId(&quot;teacher&quot;);  beanObj.setClassPath(&quot;com.kaikeba.beans.Teacher&quot;);    List beanList = new ArrayList();  beanList.add(beanObj);//spring核心配置    //2.声明一个Spring提供BeanFacotory  BeanFactory factory = new BeanFactory();  factory.setBeanDefinedList(beanList);    //3.开发人员向BeanFactory索要实例对象.  Teacher t= (Teacher) factory.getBean(&quot;teacher&quot;);  System.out.println(t);&#125;&#125;</code></pre><h3 id="作用域scope"><a class="markdownIt-Anchor" href="#作用域scope"></a> 作用域（scope）</h3><ul><li>默认情况下，容器对于某个bean，只会创建一个实例</li><li>Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是<strong>Spring中的缺省作用域</strong></li><li>Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们<code>getBean(beanId)</code>获取bean的时候才会去创建一个对象，而且我们<strong>每次获取到的对象都不是同一个对象</strong>。</li></ul><blockquote><p><strong>根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域</strong></p></blockquote><table><thead><tr><th>作用域</th><th>描述</th></tr></thead><tbody><tr><td>singleton</td><td>在spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，<strong>默认值</strong></td></tr><tr><td>prototype</td><td>每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()</td></tr><tr><td>request</td><td>每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境</td></tr><tr><td>session</td><td>同一个HTTP Session共享一个Bean，不同Session使用不同的Bean，仅适用于WebApplicationContext环境</td></tr><tr><td>global Session</td><td>一般用于Portlet应用环境，该运用域仅适用于WebApplicationContext环境</td></tr></tbody></table><pre><code class="highlight plaintext">      &lt;!--             scope属性：用来配置作用域，缺省值是singleton（单例，即一个bean只创建一个实例）            如果值为prototype（原型，即一个bean会创建多个实例）       --&gt;      &lt;bean id=&quot;s1&quot; class=&quot;scope.ScopeBean&quot; scope=&quot;prototype&quot;/&gt;</code></pre><ul><li>默认情况下，下列代码输出true，当设置完scope属性之后，每次getBean都会创建新的对象</li></ul><pre><code class="highlight plaintext">      //测试作用域@Test      public void test1()&#123;            //启动spring容器            ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;scope.xml&quot;);            //获得对象            ScopeBean s1 = ac.getBean(&quot;s1&quot;,ScopeBean.class);            ScopeBean s2 = ac.getBean(&quot;s1&quot;,ScopeBean.class);            System.out.println(s1 == s2);      &#125;</code></pre><h4 id="spring-scope原理"><a class="markdownIt-Anchor" href="#spring-scope原理"></a> spring scope原理</h4><pre><code class="highlight plaintext">public class BeanDefined &#123;private String beanId;private String classPath;private String scope =&quot;singleton&quot;;public String getScope() &#123;return scope;&#125;public void setScope(String scope) &#123;this.scope = scope;&#125;public String getBeanId() &#123;return beanId;&#125;public void setBeanId(String beanId) &#123;this.beanId = beanId;&#125;public String getClassPath() &#123;return classPath;&#125;public void setClassPath(String classPath) &#123;this.classPath = classPath;&#125;&#125;</code></pre><pre><code class="highlight plaintext">import java.util.HashMap;import java.util.List;import java.util.Map;public class BeanFactory &#123;   private List&lt;BeanDefined&gt; beanDefinedList;   private Map&lt;String ,Object&gt; SpringIoc;//已经创建好实例对象public BeanFactory(List&lt;BeanDefined&gt; beanDefinedList) throws Exception &#123;this.beanDefinedList = beanDefinedList;SpringIoc  = new HashMap(); //所有scope=&quot;singleton&quot; 采用单类模式管理bean对象for(BeanDefined beanObj:this.beanDefinedList)&#123;if(&quot;singleton&quot;.equals(beanObj.getScope()))&#123;Class classFile= Class.forName(beanObj.getClassPath());Object instance= classFile.newInstance();SpringIoc.put(beanObj.getBeanId(), instance);&#125;&#125;&#125;public List&lt;BeanDefined&gt; getBeanDefinedList() &#123;return beanDefinedList;&#125;public void setBeanDefinedList(List&lt;BeanDefined&gt; beanDefinedList) &#123;this.beanDefinedList = beanDefinedList;&#125;public Object getBean(String beanId) throws Exception&#123;   Object instance = null;   for(BeanDefined beanObj:beanDefinedList)&#123;     if(beanId.equals(beanObj.getBeanId()))&#123;     String classPath = beanObj.getClassPath();      Class classFile= Class.forName(classPath); String scope=beanObj.getScope(); if(&quot;prototype&quot;.equals(scope))&#123;//.getBean每次都要返回一个全新实例对象    instance= classFile.newInstance(); &#125;else&#123; instance=SpringIoc.get(beanId); &#125; return instance;     &#125;   &#125;   return null;&#125;   &#125;</code></pre><p><strong>测试使用</strong></p><pre><code class="highlight plaintext">public class TestMain &#123;public static void main(String[] args) throws Exception &#123;  //1.声明注册bean  BeanDefined beanObj = new BeanDefined();  beanObj.setBeanId(&quot;teacher&quot;);  beanObj.setClassPath(&quot;com.kaikeba.beans.Teacher&quot;);  //beanObj.setScope(&quot;prototype&quot;);    List beanList = new ArrayList();  beanList.add(beanObj);//spring核心配置    //2.声明一个Spring提供BeanFacotory  BeanFactory factory = new BeanFactory(beanList);     //3.开发人员向BeanFactory索要实例对象.  Teacher t= (Teacher) factory.getBean(&quot;teacher&quot;);  System.out.println(&quot;t=&quot;+t);  Teacher t2= (Teacher) factory.getBean(&quot;teacher&quot;);  System.out.println(&quot;t2=&quot;+t2);&#125;&#125;</code></pre><h3 id="生命周期-init-methoddestroy-method"><a class="markdownIt-Anchor" href="#生命周期-init-methoddestroy-method"></a> 生命周期 init-method/destroy-method</h3><ul><li>Bean的生命周期为<ul><li>bean的定义-beand的初始化-bean的使用-bean的销毁</li></ul></li><li>初始化方法<ul><li>使用<strong>init-method</strong>属性来指定初始化方法名</li><li>注：spring容器创建对象之后，会立即调用初始化方法</li></ul></li><li>销毁方法<ul><li>使用<strong>destroy-method</strong>属性来指定销毁方法名</li><li>注：spring容器再关闭之前，会先销毁对象，再销毁对象之前，会先调用对象的销毁方法。</li><li>只有作用域为单例时，销毁方法才会执行，当为原型时销毁方法就不会执行。</li></ul></li><li>在顶级的<beans/>元素中的default-init-method属性，可以为容器所有<bean>指定初始化方法，<ul><li><code>&lt;beans default-init-method=&quot;init&quot;&gt;&lt;/beans&gt;</code></li></ul></li><li>在顶级的<beans/>元素总default-destroy-method属性，可以为容器所有<bean>指定销毁方法<ul><li><code>&lt;beans default-destroy-method=&quot;destroy&quot;&gt;&lt;/beans&gt;</code></li></ul></li></ul><pre><code class="highlight plaintext">     &lt;!--             init-method属性：用来指定初始化方法            即spring创建该对象的时候会立即调用init-method属性中标注的方法来完成初始化            destroy-method属性：用来指定销毁方法       --&gt;       &lt;bean id=&quot;mb1&quot; class=&quot;scope.MessageBean&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;/&gt;</code></pre><ul><li>bean类和测试类，配置初始化方法后，创建该对象就会先执行初始化方法，关闭容器时会先执行销毁方法</li></ul><pre><code class="highlight plaintext">package scope;public class MessageBean &#123;      public MessageBean()&#123;            System.out.println(&quot;MessageBean()&quot;);      &#125;      //初始化方法      public void init()&#123;            System.out.println(&quot;init()&quot;);      &#125;      public void sendMsg()&#123;            System.out.println(&quot;sendMsg()&quot;);      &#125;      //销毁方法      public void destroy()&#123;            System.out.println(&quot;destroy()&quot;);      &#125;&#125;      //测试生命周期      @Test      public void test2()&#123;            //启动spring容器            //ApplicationContext:接口（无close方法）            //AbstractApplicationContext:上述接口的子接口（有close方法）            //ClassPathXmlApplicationContext:实现了上述接口            AbstractApplicationContext ac = new ClassPathXmlApplicationContext(&quot;scope.xml&quot;);            //获得对象            MessageBean mb = ac.getBean(&quot;mb1&quot;,MessageBean.class);            mb.sendMsg();            //关闭容器            //容器关闭之前会先执行对象的销毁方法            ac.close();      &#125;输出：MessageBean()init()sendMsg()destroy()</code></pre><h3 id="后置处理器"><a class="markdownIt-Anchor" href="#后置处理器"></a> 后置处理器</h3><h4 id="spring_bean后置处理器"><a class="markdownIt-Anchor" href="#spring_bean后置处理器"></a> Spring_Bean后置处理器</h4><p><strong>只要定义该处理器：</strong></p><p>该处理器不针对与某一个类或者接口，是拦截<strong>所有</strong></p><p>后面初始化所有的bean的时候都会经过该处理器，无论<strong>单例</strong>还是<strong>原型</strong>，<strong>只要创建bean实例就会经过该后置处理器</strong></p><p>所以我们要拦截某个特定的接口时，一定要清晰判断，以放拦截所有报错</p><hr /><ul><li>Bean后置处理器运行在调用初始化方法前后对Bean进行额外的处理</li><li><strong>ApplicationContext</strong>会自动检测由<strong>BeanPostProcessor</strong>接口的实现定义的bean，注册这些bean后置处理器，然后通过在容器中创建bean，在适当的时候调用它</li><li>你可以配置多个 BeanPostProcessor 接口，通过设置 BeanPostProcessor 实现的 Ordered 接口提供的 order 属性来控制这些 BeanPostProcessor 接口的执行顺序。</li><li>BeanPostProcessor 可以对 bean（或对象）实例进行操作，这意味着 Spring IoC 容器实例化一个 bean 实例，然后 BeanPostProcessor 接口进行它们的工作</li></ul><h4 id="基础案例"><a class="markdownIt-Anchor" href="#基础案例"></a> 基础案例</h4><ul><li>HelloWorld.java</li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;public class HelloWorld &#123;   private String message;   public void setMessage(String message)&#123;      this.message  = message;   &#125;   public void getMessage()&#123;      System.out.println(&quot;Your Message : &quot; + message);   &#125;   public void init()&#123;      System.out.println(&quot;Bean is going through init.&quot;);   &#125;   public void destroy()&#123;      System.out.println(&quot;Bean will destroy now.&quot;);   &#125;&#125;</code></pre><ul><li>这是实现BeanPostProcessor非常简单的例子，他在任何bean的初始化的之前和之后输入该Bean的名称，也可以在初始化bean的之前和之后实现更加复杂的逻辑，因为你有两个访问内置bean对象的后置处理程序的方法</li><li>InitHelloWorld.java</li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;import org.springframework.beans.factory.config.BeanPostProcessor;import org.springframework.beans.BeansException;public class InitHelloWorld implements BeanPostProcessor &#123;    //bean表示这个bean本身，beanName表示这个bean的id   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;      System.out.println(&quot;BeforeInitialization : &quot; + beanName);      //这里可以返回bean对象，或者返回它的监控代理对象      return bean;     &#125;   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;      System.out.println(&quot;AfterInitialization : &quot; + beanName);      return bean;  //这里可以返回bean对象，或者返回它的监控代理对象   &#125;&#125;</code></pre><ul><li>MainApp.java</li><li>需要注册一个AbstractApplicationContext类中声明的关闭hook的registerShutdownHook() 方法，它将确保正常关闭，并且调用相关的destroy方法</li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;import org.springframework.context.support.AbstractApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123;   public static void main(String[] args) &#123;      AbstractApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;);      HelloWorld obj = (HelloWorld) context.getBean(&quot;helloWorld&quot;);      obj.getMessage();      context.registerShutdownHook();   &#125;&#125;</code></pre><ul><li>Beans.xml</li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;   &lt;bean id=&quot;helloWorld&quot; class=&quot;com.tutorialspoint.HelloWorld&quot;       init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;       &lt;property name=&quot;message&quot; value=&quot;Hello World!&quot;/&gt;   &lt;/bean&gt;   &lt;bean class=&quot;com.tutorialspoint.InitHelloWorld&quot; /&gt;&lt;/beans&gt;</code></pre><ul><li>输出</li></ul><pre><code class="highlight plaintext">BeforeInitialization : helloWorldBean is going through init.AfterInitialization : helloWorldYour Message : Hello World!Bean will destroy now.</code></pre><h4 id="高级案例"><a class="markdownIt-Anchor" href="#高级案例"></a> 高级案例</h4><p>接口</p><pre><code class="highlight plaintext">public interface BaseService &#123;        public String doSome();&#125;</code></pre><p>接口实现类</p><pre><code class="highlight plaintext">public class ISomeService implements BaseService &#123;public String doSome() &#123;// TODO Auto-generated method stubreturn &quot;Hello mike&quot;;//增强效果，doSome方法返回值都是大写&#125;&#125;</code></pre><p>前后置增强类<strong>BeanPostProcessor</strong></p><ul><li><strong>所有</strong>的bean对象初始化都会经过该后置对象</li><li>我们可以自行定义我们需要拦截的某个接口的实现类或者某个类</li></ul><pre><code class="highlight plaintext">import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;import com.kaikeba.serviceImpl.ISomeService;public class MyBeanPostProcessor implements BeanPostProcessor &#123;public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;System.out.println(&quot;bean对象初始化之前。。。。。&quot;);return bean;//return  bean对象监控代理对象&#125;public Object postProcessAfterInitialization(final Object beanInstance, String beanName) throws BeansException &#123;// 为当前bean对象注册代理监控对象，负责增强bean对象方法能力Class beanClass = beanInstance.getClass();       // if (beanInstance instanceof BaseService) &#123;&#125;  //可以使用该语句拦截某一个接口的所有实现类        //这里只拦截了ISomeService的实例对象if (beanClass == ISomeService.class) &#123;Object proxy = Proxy.newProxyInstance(beanInstance.getClass().getClassLoader(),beanInstance.getClass().getInterfaces(), new InvocationHandler() &#123;/* *  * method:doSome args:doSome执行接受实参 proxy:代理监控对对象 **/public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;System.out.println(&quot;ISomeService doSome 被拦截&quot;);String result = (String) method.invoke(beanInstance, args);// beanInstance.doSomereturn result.toUpperCase();&#125;&#125;);return proxy;&#125;return beanInstance;&#125;&#125;</code></pre><p>注册</p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;    xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context         http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;         &lt;!-- 注册bean:被监控实现类 --&gt;      &lt;bean id=&quot;isomeService&quot; class=&quot;com.kaikeba.serviceImpl.ISomeService&quot;&gt;&lt;/bean&gt;       &lt;!-- 注册代理实现类 --&gt;      &lt;bean class=&quot;com.kaikeba.util.MyBeanPostProcessor&quot;&gt;&lt;/bean&gt;   &lt;/beans&gt;</code></pre><p>测试</p><pre><code class="highlight plaintext">public class Test &#123;    public static void main(String[] args) &#123;        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;springConfig.xml&quot;);        BaseService baseService = (BaseService) ac.getBean(&quot;isomeservice&quot;);        System.out.println(baseService.doSome());    &#125;&#125;</code></pre><h4 id="后置对象原理"><a class="markdownIt-Anchor" href="#后置对象原理"></a> 后置对象原理</h4><p>后置对象接口</p><pre><code class="highlight plaintext">public interface BeanPostProcessor &#123;default Object postProcessBeforeInitialization(Object bean, String beanName) throws Exception &#123;return bean;&#125;default Object postProcessAfterInitialization(Object bean, String beanName) throws Exception &#123;return bean;&#125;&#125;</code></pre><p>接口实现</p><pre><code class="highlight plaintext">public class MyBeanPostProcessor implements BeanPostProcessor &#123;public Object postProcessBeforeInitialization(Object bean, String beanName) throws Exception &#123;System.out.println(&quot;bean对象初始化之前。。。。。&quot;);return bean;//return  bean对象监控代理对象&#125;public Object postProcessAfterInitialization(final Object beanInstance, String beanName) throws Exception &#123;// 为当前bean对象注册代理监控对象，负责增强bean对象方法能力Class beanClass = beanInstance.getClass();if (beanClass == ISomeService.class) &#123;Object proxy = Proxy.newProxyInstance(beanInstance.getClass().getClassLoader(),beanInstance.getClass().getInterfaces(), new InvocationHandler() &#123;/* *  * method:doSome args:doSome执行接受实参 proxy:代理监控对对象 **/public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;System.out.println(&quot;ISomeService doSome 被拦截&quot;);String result = (String) method.invoke(beanInstance, args);// beanInstance.doSomereturn result.toUpperCase();&#125;&#125;);return proxy;&#125;return beanInstance;&#125;&#125;</code></pre><pre><code class="highlight plaintext">public class BeanDefined &#123;/* *   &lt;bean id  ,class,  scope.factory-bean,factory-method&gt; **/private String beanId;private String classPath;private String scope =&quot;singleton&quot;;private String factoryBean=null;private String factoryMethod=null;public String getFactoryBean() &#123;return factoryBean;&#125;public void setFactoryBean(String factoryBean) &#123;this.factoryBean = factoryBean;&#125;public String getFactoryMethod() &#123;return factoryMethod;&#125;public void setFactoryMethod(String factoryMethod) &#123;this.factoryMethod = factoryMethod;&#125;public String getScope() &#123;return scope;&#125;public void setScope(String scope) &#123;this.scope = scope;&#125;public String getBeanId() &#123;return beanId;&#125;public void setBeanId(String beanId) &#123;this.beanId = beanId;&#125;public String getClassPath() &#123;return classPath;&#125;public void setClassPath(String classPath) &#123;this.classPath = classPath;&#125;&#125;</code></pre><p><strong>spring实现后置对象基本原理</strong></p><pre><code class="highlight plaintext">import java.lang.reflect.Method;import java.util.HashMap;import java.util.List;import java.util.Map;public class BeanFactory &#123;   private List&lt;BeanDefined&gt; beanDefinedList;   private Map&lt;String ,Object&gt; SpringIoc;//已经创建好实例对象   private BeanPostProcessor processorObj;//后置对象   public List&lt;BeanDefined&gt; getBeanDefinedList() &#123;return beanDefinedList;&#125;public BeanFactory(List&lt;BeanDefined&gt; beanDefinedList) throws Exception &#123;this.beanDefinedList = beanDefinedList;SpringIoc  = new HashMap(); //所有scope=&quot;singleton&quot; 采用单类模式管理bean对象for(BeanDefined beanObj:this.beanDefinedList)&#123;if(&quot;singleton&quot;.equals(beanObj.getScope()))&#123;Class classFile= Class.forName(beanObj.getClassPath());Object instance= classFile.newInstance();//判断当前对象是一个bean对象还是后置处理处理对象isProcessor(instance,classFile);SpringIoc.put(beanObj.getBeanId(), instance);&#125;&#125;&#125;    //判断是否是后置对象处理器    private void isProcessor(Object instance,Class classFile)&#123;             Class interfaceArray[] = classFile.getInterfaces();             if(interfaceArray==null)&#123;             return;             &#125;                          for(int i=0;i&lt;interfaceArray.length;i++)&#123;             Class interfaceType = interfaceArray[i];             if(interfaceType == BeanPostProcessor.class)&#123;//证明当前实例对象是后置处理器             this.processorObj = (BeanPostProcessor)instance;             &#125;             &#125;    &#125;public void setBeanDefinedList(List&lt;BeanDefined&gt; beanDefinedList) &#123;this.beanDefinedList = beanDefinedList;&#125;public Object getBean(String beanId) throws Exception&#123;   Object instance = null;   Object proxyObj = null;//当前实例对象的代理监控对象   for(BeanDefined beanObj:beanDefinedList)&#123;     if(beanId.equals(beanObj.getBeanId()))&#123;     String classPath = beanObj.getClassPath();      Class classFile= Class.forName(classPath); String scope=beanObj.getScope(); String factoryBean = beanObj.getFactoryBean(); String factoryMehtod=beanObj.getFactoryMethod(); if(&quot;prototype&quot;.equals(scope))&#123;//.getBean每次都要返回一个全新实例对象    if(factoryBean!=null &amp;&amp; factoryMehtod!=null)&#123;//用户希望使用指定工厂创建实例对象       Object factoryObj=  SpringIoc.get(factoryBean);       Class factoryClass=factoryObj.getClass();       Method methodObj= factoryClass.getDeclaredMethod(factoryMehtod, null);       methodObj.setAccessible(true);       instance= methodObj.invoke(factoryObj, null);  &#125;else&#123;  instance= classFile.newInstance();  &#125; &#125;else&#123; instance=SpringIoc.get(beanId); &#125;  if(this.processorObj!=null)&#123; proxyObj = this.processorObj.postProcessBeforeInitialization(instance, beanId); //实例对象初始化。Spring依赖注入 proxyObj = this.processorObj.postProcessAfterInitialization(instance, beanId); //此时返回proxyObj可能就是原始bean对象，也有可能就是代理对象 return proxyObj; &#125;else&#123; return instance; &#125;      &#125;   &#125;   return null;&#125;   &#125;</code></pre><h3 id="延迟加载lazy-inittrue"><a class="markdownIt-Anchor" href="#延迟加载lazy-inittrue"></a> 延迟加载（lazy-init=“true”）</h3><ul><li>spring容器直接启动时，会读一遍配置文件，会将所有所用域为<strong>单例</strong>的bean创建好，原型的bean（即scope属性值为prototype<br />）会在getBean（）的时候创建</li><li>lazy-init=“true” 时，spring容器对于作用域为单例的bean，就不会再创建相应的实例了</li></ul><pre><code class="highlight plaintext">      &lt;!--             lazy-init属性：指定是否延迟加载，如果值为true,表示延迟加载       --&gt;&lt;bean id=&quot;mb1&quot; class=&quot;scope.MessageBean&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot; lazy-init=&quot;true&quot;/&gt;</code></pre><h3 id="spring-bean定义继承parent"><a class="markdownIt-Anchor" href="#spring-bean定义继承parent"></a> Spring Bean定义继承（parent）</h3><ul><li>Spring Bean 定义的继承与 Java 类的继承无关，但是继承的概念是一样的。你可以定义一个父 bean 的定义作为模板和其他子 bean 就可以从父 bean 中继承所需的配置</li><li>使用<strong>parent</strong>属性定义自己的父亲，子bean继承了message2属性，重写message1属性，引入一个属性message3</li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;   &lt;bean id=&quot;helloWorld&quot; class=&quot;com.tutorialspoint.HelloWorld&quot;&gt;      &lt;property name=&quot;message1&quot; value=&quot;Hello World!&quot;/&gt;      &lt;property name=&quot;message2&quot; value=&quot;Hello Second World!&quot;/&gt;   &lt;/bean&gt;   &lt;bean id=&quot;helloIndia&quot; class=&quot;com.tutorialspoint.HelloIndia&quot; parent=&quot;helloWorld&quot;&gt;      &lt;property name=&quot;message1&quot; value=&quot;Hello India!&quot;/&gt;      &lt;property name=&quot;message3&quot; value=&quot;Namaste India!&quot;/&gt;   &lt;/bean&gt;&lt;/beans&gt;</code></pre><h4 id="bean定义模板abstracttrue"><a class="markdownIt-Anchor" href="#bean定义模板abstracttrue"></a> Bean定义模板（abstract=“true”）</h4><ul><li>创建一个Bean定义模板，让其他bean定义使用，指定模板时，不应该指定类的属性，指定<code>abstract=&quot;true&quot;</code></li><li>抽象的父亲并不等被实例化</li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;   &lt;bean id=&quot;beanTeamplate&quot; abstract=&quot;true&quot;&gt;      &lt;property name=&quot;message1&quot; value=&quot;Hello World!&quot;/&gt;      &lt;property name=&quot;message2&quot; value=&quot;Hello Second World!&quot;/&gt;      &lt;property name=&quot;message3&quot; value=&quot;Namaste India!&quot;/&gt;   &lt;/bean&gt;   &lt;bean id=&quot;helloIndia&quot; class=&quot;com.tutorialspoint.HelloIndia&quot; parent=&quot;beanTeamplate&quot;&gt;      &lt;property name=&quot;message1&quot; value=&quot;Hello India!&quot;/&gt;      &lt;property name=&quot;message3&quot; value=&quot;Namaste India!&quot;/&gt;   &lt;/bean&gt;&lt;/beans&gt;</code></pre><h3 id="spring-bean依赖关系"><a class="markdownIt-Anchor" href="#spring-bean依赖关系"></a> Spring bean依赖关系</h3><ul><li>当一个bean对另一个bean存在依赖关系，可以利用<bean>元素的<strong>depends-on</strong>属性指定</li><li><strong>1 depends-on用来表示一个bean A的实例化依靠另一个bean B的实例化， 但是A并不需要持有一个B的对象，如果需要的话就不用depends-on，直接用set依赖注入就可以了</strong></li></ul><pre><code class="highlight plaintext">&lt;bean id=&quot;beanOne&quot; class=&quot;ExampleBean&quot; depends-on=&quot;manager&quot;/&gt;&lt;bean id=&quot;manager&quot; class=&quot;ManagerBean&quot;/&gt;多个依赖关系时，用逗号隔开</code></pre><ul><li><strong>2 如果A既依赖于B，而A又需要持有B的实例，那么使用构造器注入就可以了</strong></li><li><strong>3 同样是如果A既依赖于B，而A又需要持有B的实例，那么也可以使用setter方式注入</strong></li><li><strong>4 如果A不依赖于B，但是需要B的实例，单单使用setter就好了</strong></li></ul><h3 id="动态工厂dynamicfactory"><a class="markdownIt-Anchor" href="#动态工厂dynamicfactory"></a> 动态工厂DynamicFactory</h3><p>动态工厂就是配置我们自己的bean对象创建工厂，不使用spring的工厂逻辑</p><p>适用场合：在不同的环境下需要不同的bean创建方式</p><p><strong>定义一个基础的bean</strong></p><pre><code class="highlight plaintext">public class Teacher &#123;       private String tname;public String getTname() &#123;return tname;&#125;public void setTname(String tname) &#123;this.tname = tname;&#125;   &#125;</code></pre><p><strong>bean创建工厂1</strong></p><pre><code class="highlight plaintext">import com.kaikeba.beans.Teacher;public class TeacherFactory &#123;  public Teacher createTeacher()&#123;      Teacher teacher =    new Teacher();      System.out.println(&quot;TeacherFactory 负责创建 teacher类实例对象..&quot;);      return teacher;  &#125;&#125;</code></pre><p><strong>bean创建工厂2</strong></p><pre><code class="highlight plaintext">import com.kaikeba.beans.Teacher;public class TeacherFactory2 &#123; public Teacher createTeacher()&#123;      Teacher teacher =    new Teacher();      teacher.setTname(&quot;Mr&quot;);      System.out.println(&quot;TeacherFactory 负责创建 teacher类实例对象..&quot;);      return teacher; &#125;&#125;</code></pre><p><strong>动态工厂的注册方式</strong></p><p>注册好后，teacher类的创建方式就不是由spring的规则来创建，就是使用我们自己定义的teacherFactory来创建，如果像更换创建方式，也不用重新编译，可以直接修改该文件即可</p><pre><code class="highlight plaintext"> &lt;!-- 注册工厂 --&gt; &lt;bean id=&quot;factory1&quot; class=&quot;com.kaikeba.util.TeacherFactory&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;factory2&quot; class=&quot;com.kaikeba.util.TeacherFactory2&quot;&gt;&lt;/bean&gt;&lt;!--       Spring容器，当前teacher类的实例化操作，由动态工厂进行创建，此时scope属性依然有效，为单例就只调用一次创建工厂，在初始化时调用；为原型时，每次getBean时都会调用一次创建工厂创建一个对象 --&gt; &lt;bean id=&quot;teacher&quot;       class=&quot;com.kaikeba.beans.Teacher&quot; scope=&quot;singleton&quot; factory-bean=&quot;factory2&quot; factory-method=&quot;createTeacher&quot;&gt;       &lt;/bean&gt;</code></pre><blockquote><p><strong>此种方式如果用户访问量过大，会造成大量的资源消耗</strong></p></blockquote><h4 id="spring动态工厂原理"><a class="markdownIt-Anchor" href="#spring动态工厂原理"></a> Spring动态工厂原理</h4><pre><code class="highlight plaintext">public class Teacher &#123;    private String tname;public String getTname() &#123;return tname;&#125;public void setTname(String tname) &#123;this.tname = tname;&#125; &#125;</code></pre><pre><code class="highlight plaintext">public class TeacherFactory &#123;  public Teacher createTeacher()&#123;      Teacher teacher =    new Teacher();      System.out.println(&quot;TeacherFactory 负责创建 teacher类实例对象..&quot;);      return teacher;  &#125;&#125;</code></pre><pre><code class="highlight plaintext">public class BeanDefined &#123;/* *   &lt;bean id  ,class,  scope.factory-bean,factory-method&gt; **/private String beanId;private String classPath;private String scope =&quot;singleton&quot;;private String factoryBean=null;private String factoryMethod=null;public String getFactoryBean() &#123;return factoryBean;&#125;public void setFactoryBean(String factoryBean) &#123;this.factoryBean = factoryBean;&#125;public String getFactoryMethod() &#123;return factoryMethod;&#125;public void setFactoryMethod(String factoryMethod) &#123;this.factoryMethod = factoryMethod;&#125;public String getScope() &#123;return scope;&#125;public void setScope(String scope) &#123;this.scope = scope;&#125;public String getBeanId() &#123;return beanId;&#125;public void setBeanId(String beanId) &#123;this.beanId = beanId;&#125;public String getClassPath() &#123;return classPath;&#125;public void setClassPath(String classPath) &#123;this.classPath = classPath;&#125;&#125;</code></pre><pre><code class="highlight plaintext">import java.lang.reflect.Method;import java.util.HashMap;import java.util.List;import java.util.Map;public class BeanFactory &#123;   private List&lt;BeanDefined&gt; beanDefinedList;   private Map&lt;String ,Object&gt; SpringIoc;//已经创建好实例对象   public List&lt;BeanDefined&gt; getBeanDefinedList() &#123;return beanDefinedList;&#125;public BeanFactory(List&lt;BeanDefined&gt; beanDefinedList) throws Exception &#123;this.beanDefinedList = beanDefinedList;SpringIoc  = new HashMap(); //所有scope=&quot;singleton&quot; 采用单类模式管理bean对象(但不包括有创建工厂的bean)for(BeanDefined beanObj:this.beanDefinedList)&#123;if(&quot;singleton&quot;.equals(beanObj.getScope())&amp;&amp;(beanObj.getFactoryBean()==null||beanObj.getFactoryBean()==&quot;&quot;))&#123;Class classFile= Class.forName(beanObj.getClassPath());Object instance= classFile.newInstance();SpringIoc.put(beanObj.getBeanId(), instance);&#125;&#125;//这里单独创建有动态工厂的beanfor(BeanDefined beanObj:this.beanDefinedList)&#123;if(beanObj.getFactoryBean()!=null||beanObj.getFactoryBean()!=&quot;&quot;)&#123;Object factoryObj=  SpringIoc.get(beanObj.getFactoryBean);Class factoryClass=factoryObj.getClass();Method methodObj= factoryClass.getDeclaredMethod(beanObj.getFactoryMehtod, null);methodObj.setAccessible(true);SpringIoc.put(beanObj.getBeanId(), methodObj.invoke(factoryObj, null));&#125;&#125;&#125;public void setBeanDefinedList(List&lt;BeanDefined&gt; beanDefinedList) &#123;this.beanDefinedList = beanDefinedList;&#125;public Object getBean(String beanId) throws Exception&#123;   Object instance = null;   for(BeanDefined beanObj:beanDefinedList)&#123;     if(beanId.equals(beanObj.getBeanId()))&#123;     String classPath = beanObj.getClassPath();      Class classFile= Class.forName(classPath); String scope=beanObj.getScope(); String factoryBean = beanObj.getFactoryBean(); String factoryMehtod=beanObj.getFactoryMethod(); if(&quot;prototype&quot;.equals(scope))&#123;//.getBean每次都要返回一个全新实例对象    if(factoryBean!=null &amp;&amp; factoryMehtod!=null)&#123;//用户希望使用指定工厂创建实例对象       Object factoryObj=  SpringIoc.get(factoryBean);       Class factoryClass=factoryObj.getClass();       Method methodObj= factoryClass.getDeclaredMethod(factoryMehtod, null);       methodObj.setAccessible(true);       instance= methodObj.invoke(factoryObj, null);  &#125;else&#123;  instance= classFile.newInstance();  &#125; &#125;else&#123; instance=SpringIoc.get(beanId); &#125; return instance;     &#125;   &#125;   return null;&#125;&#125;</code></pre><p><strong>测试使用</strong></p><pre><code class="highlight plaintext">public class TestMain &#123;public static void main(String[] args) throws Exception &#123;  //1.声明注册bean  BeanDefined beanObj = new BeanDefined();  beanObj.setBeanId(&quot;teacher&quot;);  beanObj.setClassPath(&quot;com.kaikeba.beans.Teacher&quot;);  beanObj.setFactoryBean(&quot;factory1&quot;);  beanObj.setFactoryMethod(&quot;createTeacher&quot;);  beanObj.setScope(&quot;prototype&quot;);    BeanDefined beanObj2 = new BeanDefined();  beanObj2.setBeanId(&quot;factory1&quot;);  beanObj2.setClassPath(&quot;com.kaikeba.beans.TeacherFactory&quot;);    List configuration = new ArrayList();  configuration.add(beanObj);//spring核心配置  configuration.add(beanObj2);    //2.声明一个Spring提供BeanFacotory  BeanFactory factory = new BeanFactory(configuration);   //3.开发人员向BeanFactory索要实例对象.  Teacher t= (Teacher) factory.getBean(&quot;teacher&quot;);  System.out.println(&quot;t=&quot;+t);&#125;&#125;</code></pre><h3 id="静态工厂"><a class="markdownIt-Anchor" href="#静态工厂"></a> 静态工厂</h3><p>静态工厂和动态工厂的使用方法基本相同</p><p><strong>作用</strong>：节省内存的消耗</p><pre><code class="highlight plaintext">public class TeacherFactory &#123; //这里只需要把方法改为静态方法即可    public static Teacher createTeacher()&#123;         Teacher teacher = new Teacher();         System.out.println(&quot;TeacherFactory 负责创建 teacher类实例对象..&quot;);         return teacher;     &#125; &#125;</code></pre><p><strong>配置文件</strong></p><p>只需要把class属性改为创建工厂的类路径即可</p><pre><code class="highlight plaintext">&lt;bean id=&quot;teacher&quot; class=&quot;com.lee.util.TeacherFactory&quot; factory-method=&quot;createTeacher&quot;&gt;&lt;/bean&gt;</code></pre><h2 id="3iocinversion-of-controll-控制反转"><a class="markdownIt-Anchor" href="#3iocinversion-of-controll-控制反转"></a> 3.IOC(Inversion Of Controll 控制反转)</h2><ul><li><p><strong>IOC就是一个生产和管理bean的容器就行了，原来需要在调用类中new的东西，现在都是通过容器生成，同时，要是产生的是单例的bean，他还可以给管理bean的生命周期</strong></p></li><li><p>对象之间的依赖关系由容器来建立（而不是对象自己直接通过new调用或建立关系）</p></li><li><p>IOC实现方法有DI和依赖查找</p></li><li><p><strong>Spring容器采用DI方式</strong></p></li><li><p>IoC是Spring框架的核心内容，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象</p></li></ul><h3 id="ioc实现原理"><a class="markdownIt-Anchor" href="#ioc实现原理"></a> IOC实现原理</h3><ul><li>控制反转也叫依赖注入，IOC利用java反射机制，AOP利用代理模式。所谓控制反转是指，本来被调用者的实例是有调用者来创建的，这样的缺点是耦合性太强，IOC则是统一交给spring来管理创建，将对象交给容器管理，你只需要在spring配置文件总配置相应的bean，以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类</li></ul><h3 id="didependency-injection依赖注入"><a class="markdownIt-Anchor" href="#didependency-injection依赖注入"></a> DI(Dependency Injection)依赖注入</h3><ul><li>容器通过调用对象提供的set方法或者构造器来建立依赖关系</li><li><strong>IOC是目标，DI是手段</strong></li><li>DI主要有两种注入方式，即Setter注入和构造器注入</li></ul><h4 id="di概述"><a class="markdownIt-Anchor" href="#di概述"></a> DI概述</h4><p><strong>什么是依赖？</strong></p><ul><li>依赖指的就是Bean实例中的属性</li><li>属性分为：简单类型（8种基本类型和String类型）的属性、POJO类型的属性、集合数组类型的属性</li></ul><p><strong>什么是依赖注入？</strong></p><ul><li>依赖注入：Dependency Injection。它是 spring 框架核心 ioc 的具体实现</li></ul><p><strong>为什么要进行依赖注入？</strong></p><ul><li>我们的程序在编写时，通过控制反转，把对象的创建交给了 spring，但是代码中不可能出现没有依赖的情况</li><li>ioc 解耦只是降低他们的依赖关系，但不会消除。例如：我们的业务层仍会调用持久层的方法。那这种业务层和持久层的依赖关系，在使用 spring 之后，就让 spring 来维护了</li><li>简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取</li></ul><h4 id="di-依赖注入原理"><a class="markdownIt-Anchor" href="#di-依赖注入原理"></a> DI 依赖注入原理</h4><p><strong>Spring框架通过反射机制，调用属性对应Set方法进行赋值</strong></p><pre><code class="highlight plaintext">import java.util.HashMap;import java.util.Map;public class BeanDefined &#123;/* *  *    *   &lt;bean id  ,class,  scope.factory-bean,factory-method&gt; **/private String beanId;private String classPath;private String scope =&quot;singleton&quot;;private String factoryBean=null;private String factoryMethod=null;private Map&lt;String,String&gt; propertyMap=new HashMap();public Map&lt;String, String&gt; getPropertyMap() &#123;return propertyMap;&#125;public void setPropertyMap(Map&lt;String, String&gt; propertyMap) &#123;this.propertyMap = propertyMap;&#125;public String getFactoryBean() &#123;return factoryBean;&#125;public void setFactoryBean(String factoryBean) &#123;this.factoryBean = factoryBean;&#125;public String getFactoryMethod() &#123;return factoryMethod;&#125;public void setFactoryMethod(String factoryMethod) &#123;this.factoryMethod = factoryMethod;&#125;public String getScope() &#123;return scope;&#125;public void setScope(String scope) &#123;this.scope = scope;&#125;public String getBeanId() &#123;return beanId;&#125;public void setBeanId(String beanId) &#123;this.beanId = beanId;&#125;public String getClassPath() &#123;return classPath;&#125;public void setClassPath(String classPath) &#123;this.classPath = classPath;&#125;&#125;</code></pre><pre><code class="highlight plaintext">import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Set;public class BeanFactory &#123;   private List&lt;BeanDefined&gt; beanDefinedList;   private Map&lt;String ,Object&gt; SpringIoc;//已经创建好实例对象   private BeanPostProcessor processorObj;//后置对象   public List&lt;BeanDefined&gt; getBeanDefinedList() &#123;return beanDefinedList;&#125;//依赖注入public void setValue(Object instance,Class classFile,Map propertyMap) throws NoSuchFieldException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException&#123;     //循环便利  propertyMap&lt;属性名,属性值&gt;      Method methodArray[]= classFile.getDeclaredMethods();     Set fieldNameSet = propertyMap.keySet();     Iterator fieldIterator = fieldNameSet.iterator();     while(fieldIterator.hasNext())&#123;     String fieldName = (String) fieldIterator.next();     String value = (String) propertyMap.get(fieldName);     Field fieldObj = classFile.getDeclaredField(fieldName);//同名属性对象     for(int i=0;i&lt;methodArray.length;i++)&#123;     Method methodObj  = methodArray[i];     String methodName =&quot;set&quot;+fieldName;// sid == setsid     if(methodName.equalsIgnoreCase(methodObj.getName()))&#123;       Class fieldType=   fieldObj.getType();//属性的数据类型 Integer,String,Double,boolean,list           if(fieldType == String.class)&#123;           methodObj.invoke(instance, value);           &#125;else if(fieldType == Integer.class)&#123;           methodObj.invoke(instance, Integer.valueOf(value));           &#125;else if(fieldType == Boolean.class)&#123;           methodObj.invoke(instance, Boolean.valueOf(value));           &#125;else if(fieldType==List.class)&#123;             List tempList = new ArrayList();             String dataArray[]=value.split(&quot;,&quot;);             for(int j=0;j&lt;dataArray.length;j++)&#123;             tempList.add(dataArray[j]);             &#125;             methodObj.invoke(instance, tempList);           &#125;else&#123; //此时属性类型是数组           String dataArray[]=value.split(&quot;,&quot;);           Object data[] = new Object[1];           data[0]=dataArray;           methodObj.invoke(instance, data);           &#125;              break;     &#125;     &#125;     &#125;&#125;public BeanFactory(List&lt;BeanDefined&gt; beanDefinedList) throws Exception &#123;this.beanDefinedList = beanDefinedList;SpringIoc  = new HashMap(); //所有scope=&quot;singleton&quot; 采用单类模式管理bean对象for(BeanDefined beanObj:this.beanDefinedList)&#123;if(&quot;singleton&quot;.equals(beanObj.getScope()))&#123;Class classFile= Class.forName(beanObj.getClassPath());Object instance= classFile.newInstance();//判断当前对象是一个bean对象还是后置处理处理对象isProcessor(instance,classFile);SpringIoc.put(beanObj.getBeanId(), instance);&#125;&#125;&#125;    private void isProcessor(Object instance,Class classFile)&#123;             Class interfaceArray[] = classFile.getInterfaces();             if(interfaceArray==null)&#123;             return;             &#125;                          for(int i=0;i&lt;interfaceArray.length;i++)&#123;             Class interfaceType = interfaceArray[i];             if(interfaceType == BeanPostProcessor.class)&#123;//证明当前实例对象是后置处理器             this.processorObj = (BeanPostProcessor)instance;             &#125;             &#125;    &#125;public void setBeanDefinedList(List&lt;BeanDefined&gt; beanDefinedList) &#123;this.beanDefinedList = beanDefinedList;&#125;public Object getBean(String beanId) throws Exception&#123;   Object instance = null;   Object proxyObj = null;//当前实例对象的代理监控对象   for(BeanDefined beanObj:beanDefinedList)&#123;     if(beanId.equals(beanObj.getBeanId()))&#123;     String classPath = beanObj.getClassPath();      Class classFile= Class.forName(classPath); String scope=beanObj.getScope(); String factoryBean = beanObj.getFactoryBean(); String factoryMehtod=beanObj.getFactoryMethod(); Map propertyMap = beanObj.getPropertyMap(); if(&quot;prototype&quot;.equals(scope))&#123;//.getBean每次都要返回一个全新实例对象    if(factoryBean!=null &amp;&amp; factoryMehtod!=null)&#123;//用户希望使用指定工厂创建实例对象       Object factoryObj=  SpringIoc.get(factoryBean);       Class factoryClass=factoryObj.getClass();       Method methodObj= factoryClass.getDeclaredMethod(factoryMehtod, null);       methodObj.setAccessible(true);       instance= methodObj.invoke(factoryObj, null);  &#125;else&#123;  instance= classFile.newInstance();  &#125; &#125;else&#123; instance=SpringIoc.get(beanId); &#125;  if(this.processorObj!=null)&#123; proxyObj = this.processorObj.postProcessBeforeInitialization(instance, beanId); //实例对象初始化。Spring依赖注入 setValue(instance,classFile,propertyMap); proxyObj = this.processorObj.postProcessAfterInitialization(instance, beanId); //此时返回proxyObj可能就是原始bean对象，也有可能就是代理对象 return proxyObj; &#125;else&#123; //实例对象初始化 setValue(instance,classFile,propertyMap); return instance; &#125;      &#125;   &#125;   return null;&#125;   &#125;</code></pre><h3 id="1set方式注入property"><a class="markdownIt-Anchor" href="#1set方式注入property"></a> 1.Set方式注入（property）</h3><ul><li><p><strong>类中提供相应的set方法</strong></p></li><li><p><strong>在配置<bean>中添加<property>元�</strong>�</p></li><li><p>Spring容器会先将配置文件中的A和B创建好，然后把B对象的引用地址通过A类的setB(B b)方法赋值给A对象的b成员私有变量，实现A类对B类的调用，这种实现方法就叫做依赖注入。</p></li><li><p>从而解决代码之间耦合度太高的问题</p></li><li><p>原来是自己想要什么对象就创建什么对象，耦合度太高，spring就相当于一个公司，我们提出自己的诉求，让spring帮忙找我需要的对象。</p></li></ul><pre><code class="highlight plaintext">      &lt;!--             property元素：表示使用set方法来注入依赖关系            name属性指定属性名（给name大写然后前面加set,即setB(),就是调用A的setB()方法传入id为b1的对象）            ref属性指定属性值（是被注入的bean的id）(传入id为b1的对象)            A和B的先后创建顺序不重要，spring容器会把所有容器创建好之后再处理依赖关系       --&gt;      &lt;bean id=&quot;a1&quot; class=&quot;ioc.A&quot;&gt;            &lt;property name=&quot;b&quot; ref=&quot;b1&quot;&gt;&lt;/property&gt;      &lt;/bean&gt;</code></pre><pre><code class="highlight plaintext">package ioc;public class A &#123;      private B b;      public void setB(B b) &#123;            System.out.println(&quot;setB()&quot;);           this.b = b;      &#125;      public A()&#123;            System.out.println(&quot;A()&quot;);      &#125;      public void execute()&#123;            //new B().f1();  这样写A和B的耦合度太高            System.out.println(&quot;execute()&quot;);            b.f1();      &#125;&#125;package ioc;public class B &#123;      public B()&#123;            System.out.println(&quot;B()&quot;);      &#125;      public void f1()&#123;            System.out.println(&quot;B is f1()&quot;);      &#125;&#125;</code></pre><ul><li>调用测试方法，输出：</li></ul><pre><code class="highlight plaintext">      @Test      //测试set方式的注入      public void test5()&#123;            //启动容器            ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;ioc.xml&quot;);            A a1 = ac.getBean(&quot;a1&quot;,A.class);            a1.execute();      &#125;      输出：B()A()setB()execute()B is f1()</code></pre><ul><li><strong>如果想要新建一个C类让A类调用，而不去修改A类源代码，解决办法</strong></li><li>创建一个接口，让B和C都去实现它，然后再A的代码也改为接口就可以实现直接修改xml文件而更改A类所调用的方法的类。</li></ul><pre><code class="highlight plaintext">package ioc;public interface IB &#123;      public void f1();&#125;package ioc;public class B implements IB&#123;      public B()&#123;            System.out.println(&quot;B()&quot;);      &#125;            public void f1()&#123;            System.out.println(&quot;B is f1()&quot;);      &#125;&#125;package ioc;public class C implements IB&#123;      public C()&#123;            System.out.println(&quot;C()&quot;);      &#125;      public void f1()&#123;            System.out.println(&quot;C is f1()&quot;);      &#125;&#125;package ioc;public class A &#123;      private IB b;  //这里修改为IB接口      public void setB(IB b) &#123;            System.out.println(&quot;setB()&quot;);            this.b = b;      &#125;      public A()&#123;            System.out.println(&quot;A()&quot;);       &#125;         public void execute()&#123;            //new B().f1();  这样写A和B的耦合度太高            System.out.println(&quot;execute()&quot;);            b.f1();      &#125;&#125;</code></pre><ul><li>修改为接口的形式后，要想修改A类注入的其他类，直接修改ref的值即可</li></ul><pre><code class="highlight plaintext">&lt;bean id=&quot;a1&quot; class=&quot;ioc.A&quot;&gt;            &lt;property name=&quot;b&quot; ref=&quot;c1&quot;&gt;&lt;/property&gt;      &lt;/bean&gt;</code></pre><h4 id="使用p名称空间注入数据"><a class="markdownIt-Anchor" href="#使用p名称空间注入数据"></a> 使用p名称空间注入数据</h4><p>如果你有许多的设值函数方法，那么在 XML 配置文件中使用 p-namespace 是非常方便的</p><ul><li>首先子schema的名称空间中加入该行：<code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code></li><li>使用p名称空间的语法<ul><li><code>p:属性名=&quot;&quot;</code></li><li><code>p:属性名-ref=&quot;&quot;</code></li></ul></li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;   &lt;bean id=&quot;john-classic&quot; class=&quot;com.example.Person&quot;&gt;      &lt;property name=&quot;name&quot; value=&quot;John Doe&quot;/&gt;      &lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;   &lt;/bean&gt;   &lt;bean name=&quot;jane&quot; class=&quot;com.example.Person&quot;&gt;      &lt;property name=&quot;name&quot; value=&quot;John Doe&quot;/&gt;   &lt;/bean&gt;&lt;/beans&gt;简写后-------------------------------------------------------------------&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;   &lt;bean id=&quot;john-classic&quot; class=&quot;com.example.Person&quot;      p:name=&quot;John Doe&quot;      p:spouse-ref=&quot;jane&quot;/&gt;   &lt;/bean&gt;   &lt;bean name=&quot;jane&quot; class=&quot;com.example.Person&quot;      p:name=&quot;John Doe&quot;/&gt;   &lt;/bean&gt;&lt;/beans&gt;</code></pre><h4 id="spring注入内部beans"><a class="markdownIt-Anchor" href="#spring注入内部beans"></a> Spring注入内部Beans</h4><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;   &lt;bean id=&quot;outerBean&quot; class=&quot;...&quot;&gt;      &lt;property name=&quot;target&quot;&gt;         &lt;bean id=&quot;innerBean&quot; class=&quot;...&quot;/&gt;      &lt;/property&gt;   &lt;/bean&gt;&lt;/beans&gt;</code></pre><h3 id="2构造器方式注入"><a class="markdownIt-Anchor" href="#2构造器方式注入"></a> 2构造器方式注入</h3><ul><li><p><strong>1.添加相应的构造器</strong></p></li><li><p><strong>2.配置constructor-arg元�</strong>�</p><ul><li><code>index</code>：指定参数在构造函数参数列表的索引位置</li><li><code>name</code>：指定参数在构造函数的名称</li><li><code>value</code>：它能给基本数据类型和String类型赋值</li><li><code>ref</code>：他能赋值引用类型</li></ul></li><li><p>当构造器有多个值时，可以使用index参数配置参数的位置</p></li><li><p>如果要把一个引用传递给一个对象，需要使用标签的<strong>ref</strong>属性；如果要直接传递一个值，应该使用<strong>value</strong>属性</p></li><li><p>配置xml</p></li></ul><pre><code class="highlight plaintext">      &lt;bean id=&quot;b1&quot; class=&quot;ioc2.B&quot;&gt;&lt;/bean&gt;      &lt;!--              构造器方式注入            constructor-arg元素：用来配置构造器方式的注入，其中，            index属性指定参数的下标（从0开始）       --&gt;      &lt;bean id=&quot;a1&quot; class=&quot;ioc2.A&quot;&gt;            &lt;constructor-arg index=&quot;0&quot; ref=&quot;b1&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/constructor-arg&gt;            &lt;constructor-arg name=&quot;name&quot; value=&quot;zhangsan&quot;&gt;&lt;/constructor-arg&gt;      &lt;/bean&gt;</code></pre><pre><code class="highlight plaintext">package ioc2;public class A &#123;      private B b;      public A()&#123;            System.out.println(&quot;A()&quot;);      &#125;       //构造器传入      public A(B b)&#123;            this.b = b;            System.out.println(&quot;A(b)&quot;);      &#125;      public void execute()&#123;            System.out.println(&quot;execute()&quot;);            b.f1();      &#125;&#125;package ioc2;public class B &#123;      public B()&#123;            System.out.println(&quot;B()&quot;);      &#125;      public void f1()&#123;            System.out.println(&quot;B is f1()&quot;);      &#125;&#125;</code></pre><ul><li>测试输出</li></ul><pre><code class="highlight plaintext">public class TestCase2 &#123;      @Test      public void test()&#123;            ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;ioc2.xml&quot;);            A a = ac.getBean(&quot;a1&quot;,A.class);            a.execute();      &#125;      输出：B()A(b)execute()B is f1()</code></pre><h3 id="3自动装配了解"><a class="markdownIt-Anchor" href="#3自动装配了解"></a> 3自动装配（了解）</h3><ul><li>容器依据某种规则，自动建立对象之间的依赖关系</li><li>默认情况下，容器不会自动装配</li><li>可以通过指定autowire属性来告诉容器进行自动装配（容器仍然需要通过调用set方法或者构造器来完成关系的建立）<ul><li><strong>byName</strong>：private Waiter wt;根据wt来找相同的id对象注入到setWt()方法中</li><li><strong>byType</strong>：private Waiter wt;根据Waiter属性来找相同的class对应的对象注入到setWaiter()方法中</li><li><s><strong>constructor</strong></s>：与byType的方式类似，不同之处在于它应用于构造器参数</li></ul></li></ul><pre><code class="highlight plaintext">&lt;!--             autowire属性：表示让容器自动装配            如果值为：            byName:容器依据属性名(成员变量名)查找(id)对应的bean,然后调用对应的（set加属性名大写）方法来完成注入                        注意：如果找不到对应的bean,注入null.不可能找到多个符合条件的bean，因为id唯一            byType:容器依据属性的类型查找对应的属性（class）相同的bean,然后调用对应的set方法来完成注入。                        注意：找不到对应的bean,注入null,找到多个就会报错。            constructor:与byType类似，不同的是调用对应的构造器来完成注入。       --&gt;       &lt;bean id=&quot;wt&quot; class=&quot;ioc2.Waiter&quot;/&gt;      &lt;bean id=&quot;rest&quot; class=&quot;ioc2.Restaurant&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;</code></pre><pre><code class="highlight plaintext">package ioc2;public class Restaurant &#123;      private Waiter wt;         public Restaurant()&#123;            System.out.println(&quot;Restaurant()&quot;);      &#125;            public void setWt(Waiter wt)&#123;            this.wt = wt;            System.out.println(&quot;setWt()&quot;);      &#125;      public String toString()&#123;            return &quot;Restaurant [wt=&quot;+wt+&quot;]&quot;;      &#125;&#125;package ioc2;public class Waiter &#123;      public Waiter()&#123;            System.out.println(&quot;waiter&quot;);      &#125;&#125;      @Test      //测试自动装配      public void test2()&#123;            ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;ioc2.xml&quot;);            Restaurant rest = ac.getBean(&quot;rest&quot;,Restaurant.class);            System.out.println(rest);      &#125;输出：waiterRestaurant()setWt()Restaurant [wt=ioc2.Waiter@1877ab81]</code></pre><h3 id="4-注入基本集合类型的值"><a class="markdownIt-Anchor" href="#4-注入基本集合类型的值"></a> 4 注入基本/集合类型的值</h3><ul><li>注入基本类型的值：使用value属性/标签即可，容器将字符串从java.lang.String类型转化为实际的属性或参数类型后给Bean对象注入</li><li>如果集合内是简单类型，使用value子标签，如果是POJO(引用)类型，则使用bean标签</li></ul><p>List Set Map Properties</p><ul><li>代码如下</li></ul><pre><code class="highlight plaintext">      &lt;bean id=&quot;vb1&quot; class=&quot;value.ValueBean&quot;&gt;&lt;!-- 上下两种写法都可以 --&gt;            &lt;property name=&quot;name&quot; value=&quot;胡八一&quot;&gt;&lt;/property&gt;      &lt;property name=&quot;age&quot;&gt;&lt;value&gt;30&lt;/value&gt;&lt;/property&gt;            &lt;!--两种方式都可以--&gt;      &lt;property name=&quot;otherName&quot; value=&quot;张三,李四,王五&quot;&gt;&lt;/property&gt;      &lt;property name=&quot;otherName&quot;&gt;                  &lt;array&gt;                       &lt;value&gt;张三&lt;/value&gt;                        &lt;value&gt;李四&lt;/value&gt;                        &lt;bean&gt;&lt;/bean&gt;                  &lt;/arrya&gt;            &lt;/property&gt;                  &lt;property name=&quot;city&quot;&gt;                  &lt;list&gt;                       &lt;value&gt;北京&lt;/value&gt;                        &lt;value&gt;上海&lt;/value&gt;                        &lt;value&gt;广州&lt;/value&gt;                  &lt;/list&gt;            &lt;/property&gt;                  &lt;property name=&quot;interest&quot;&gt;                  &lt;set&gt;                        &lt;value&gt;盗墓&lt;/value&gt;                       &lt;value&gt;战斗&lt;/value&gt;                        &lt;value&gt;喝酒&lt;/value&gt;                  &lt;/set&gt;            &lt;/property&gt;                  &lt;property name=&quot;score&quot;&gt;                  &lt;map&gt;                        &lt;entry key=&quot;english&quot; value=&quot;60&quot;&gt;&lt;/entry&gt;                        &lt;entry key=&quot;math&quot; value=&quot;66&quot;&gt;&lt;/entry&gt;                  &lt;/map&gt;            &lt;/property&gt;                  &lt;property name=&quot;db&quot;&gt;                  &lt;props&gt;                        &lt;prop key=&quot;username&quot;&gt;Tiger&lt;/prop&gt;                        &lt;prop key=&quot;password&quot;&gt;1234&lt;/prop&gt;                  &lt;/props&gt;            &lt;/property&gt;      &lt;/bean&gt;</code></pre><pre><code class="highlight plaintext">package value;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;public class ValueBean &#123;private String name;private int age;    private String[] otherName;private List&lt;String&gt; city;private Set&lt;String&gt; interest;private Map&lt;String,Double&gt; score;private Properties db;    public ValueBean()&#123;System.out.println(&quot;ValueBean()&quot;);&#125;public void setName(String name) &#123;this.name = name;&#125;public void setAge(int age) &#123;this.age = age;&#125;public void setCity(List&lt;String&gt; city) &#123;this.city = city;&#125;public void setInterest(Set&lt;String&gt; interest) &#123;this.interest = interest;&#125;public void setScore(Map&lt;String, Double&gt; score) &#123;this.score = score;&#125;public void setDb(Properties db) &#123;this.db = db;&#125;@Overridepublic String toString() &#123;return &quot;ValueBean [name=&quot; + name + &quot;, age=&quot; + age + &quot;, city=&quot; + city + &quot;, interest=&quot; + interest + &quot;, score=&quot;+ score + &quot;, db=&quot; + db + &quot;]&quot;;&#125;&#125;      @Test      public void test3()&#123;            ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;value.xml&quot;);            ValueBean vb = ac.getBean(&quot;vb1&quot;,ValueBean.class);            System.out.println(vb);      &#125;输出:ValueBean()ValueBean [name=胡八一, age=30, city=[北京, 上海, 广州], interest=[盗墓, 战斗, 喝酒], score=&#123;english=60.0, math=66.0&#125;, db=&#123;password=1234, username=Tiger&#125;]</code></pre><h3 id="5-引用的方式注入集合类型的值"><a class="markdownIt-Anchor" href="#5-引用的方式注入集合类型的值"></a> 5 引用的方式注入集合类型的值</h3><pre><code class="highlight plaintext">&lt;!--             util表示命名空间            将集合类型的值配置为一个bean,       --&gt;      &lt;util:list id=&quot;cityBean&quot;&gt;            &lt;value&gt;上海&lt;/value&gt;            &lt;value&gt;深圳&lt;/value&gt;            &lt;value&gt;武汉&lt;/value&gt;      &lt;/util:list&gt;      &lt;util:set id=&quot;interestBean&quot;&gt;            &lt;value&gt;书法&lt;/value&gt;            &lt;value&gt;绘画&lt;/value&gt;            &lt;value&gt;拳击&lt;/value&gt;      &lt;/util:set&gt;      &lt;util:map id=&quot;scoreBean&quot;&gt;            &lt;entry key=&quot;english&quot; value=&quot;80&quot;&gt;&lt;/entry&gt;            &lt;entry key=&quot;math&quot; value=&quot;99&quot;&gt;&lt;/entry&gt;      &lt;/util:map&gt;      &lt;util:properties id=&quot;dbBean&quot;&gt;            &lt;prop key=&quot;username&quot;&gt;Sally&lt;/prop&gt;            &lt;prop key=&quot;password&quot;&gt;1234&lt;/prop&gt;      &lt;/util:properties&gt;      &lt;!-- 引用的方式注入集合类型的值 --&gt;      &lt;bean id=&quot;vb2&quot; class=&quot;value.ValueBean&quot;&gt;            &lt;property name=&quot;city&quot; ref=&quot;cityBean&quot;&gt;&lt;/property&gt;            &lt;property name=&quot;interest&quot; ref=&quot;interestBean&quot;&gt;&lt;/property&gt;            &lt;property name=&quot;score&quot; ref=&quot;scoreBean&quot;&gt;&lt;/property&gt;            &lt;property name=&quot;db&quot; ref=&quot;dbBean&quot;&gt;&lt;/property&gt;      &lt;/bean&gt;</code></pre><h3 id="6-注入空值"><a class="markdownIt-Anchor" href="#6-注入空值"></a> 6 注入空值</h3><ul><li>例子相当于 Java 代码：exampleBean.setEmail(“”)</li></ul><pre><code class="highlight plaintext">&lt;bean id=&quot;...&quot; class=&quot;exampleBean&quot;&gt;   &lt;property name=&quot;email&quot; value=&quot;&quot;/&gt;&lt;/bean&gt;</code></pre><ul><li>例子相当于 Java 代码：exampleBean.setEmail(null)</li></ul><pre><code class="highlight plaintext">&lt;bean id=&quot;...&quot; class=&quot;exampleBean&quot;&gt;   &lt;property name=&quot;email&quot;&gt;&lt;null/&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h3 id="7-读取配置文件properties的值"><a class="markdownIt-Anchor" href="#7-读取配置文件properties的值"></a> 7 读取配置文件properties的值</h3><p>config.properties</p><pre><code class="highlight plaintext">pagesize=10</code></pre><p>value.xml</p><pre><code class="highlight plaintext">location:表示配置文件的路劲&lt;!-- 读取properties文件的内容             classpath:按照类路劲来搜索（实际就是按照resource来找,如果有文件夹，就config/config.properties）             spring容器会根基路径来找到对应的properties文件，然后读取该文件的内容到Properties对象       --&gt;      &lt;util:properties id=&quot;config&quot; location=&quot;classpath:config.properties&quot;&gt;&lt;/util:properties&gt;</code></pre><p>@test</p><pre><code class="highlight plaintext">      @Testpublic class TestCase2 &#123;      //测试 读取properties文件      public void test5()&#123;            ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;value.xml&quot;);            System.out.println(ac.getBean(&quot;config&quot;));      &#125;&#125;</code></pre><h3 id="8-使用spring表达式"><a class="markdownIt-Anchor" href="#8-使用spring表达式"></a> 8 使用spring表达式</h3><ul><li>Spring引入了一种表达式语言，这和统一的EL再语法上很相似，这种表达式语言可以读取一个bean对象/集合中的数据</li></ul><blockquote><p><strong>注意事项，要想使用spring表达式读取属性值，必须要被读取bean有相应的get方法</strong></p></blockquote><pre><code class="highlight plaintext">&lt;!-- 通过#来读取其他bean的属性值，前提是其他bean的该属性需要有get方法，否则无法读取值 --&gt;配置文件properties的bean      &lt;util:properties id=&quot;config&quot; location=&quot;classpath:config.properties&quot;&gt;&lt;/util:properties&gt;      &lt;bean id=&quot;sp1&quot; class=&quot;value.SpelBean&quot;&gt;表示读取bean的属性                  &lt;property name=&quot;name&quot; value=&quot;#&#123;vb1.name&#125;&quot;&gt;&lt;/property&gt;表示用下标读取list                        &lt;property name=&quot;city&quot; value=&quot;#&#123;vb1.city[1]&#125;&quot;&gt;&lt;/property&gt;表示用map的key读取value                        &lt;property name=&quot;score&quot; value=&quot;#&#123;vb1.score.english&#125;&quot;&gt;&lt;/property&gt;表示读取配置文件            &lt;property name=&quot;pageSize&quot; value=&quot;#&#123;config.pagesize&#125;&quot;&gt;&lt;/property&gt;      &lt;/bean&gt;                 &lt;bean id=&quot;vb1&quot; class=&quot;value.ValueBean&quot;&gt;            &lt;property name=&quot;name&quot; value=&quot;胡八一&quot;&gt;&lt;/property&gt;            &lt;property name=&quot;age&quot; value=&quot;30&quot;&gt;&lt;/property&gt;            &lt;property name=&quot;city&quot;&gt;                  &lt;list&gt;                        &lt;value&gt;北京&lt;/value&gt;                        &lt;value&gt;上海&lt;/value&gt;                        &lt;value&gt;广州&lt;/value&gt;                  &lt;/list&gt;            &lt;/property&gt;            &lt;property name=&quot;interest&quot;&gt;                  &lt;set&gt;                        &lt;value&gt;盗墓&lt;/value&gt;                        &lt;value&gt;战斗&lt;/value&gt;                        &lt;value&gt;喝酒&lt;/value&gt;                  &lt;/set&gt;            &lt;/property&gt;            &lt;property name=&quot;score&quot;&gt;                  &lt;map&gt;                        &lt;entry key=&quot;english&quot; value=&quot;60&quot;&gt;&lt;/entry&gt;                        &lt;entry key=&quot;math&quot; value=&quot;66&quot;&gt;&lt;/entry&gt;                  &lt;/map&gt;            &lt;/property&gt;            &lt;property name=&quot;db&quot;&gt;                  &lt;props&gt;                        &lt;prop key=&quot;username&quot;&gt;Tiger&lt;/prop&gt;                        &lt;prop key=&quot;password&quot;&gt;1234&lt;/prop&gt;                  &lt;/props&gt;            &lt;/property&gt;      &lt;/bean&gt;</code></pre><pre><code class="highlight plaintext">package value;public class SpelBean &#123;      private String name;      private String city;      private double score;      private String pageSize;      public SpelBean()&#123;            System.out.println(&quot;SpelBean()&quot;);      &#125;      public void setName(String name) &#123;            this.name = name;      &#125;      public void setCity(String city) &#123;            this.city = city;      &#125;      public void setScore(double score) &#123;            this.score = score;      &#125;      public void setPageSize(String pageSize) &#123;            this.pageSize = pageSize;      &#125;  &#125;</code></pre><p>输出</p><pre><code class="highlight plaintext">SpelBean [name=胡八一, city=上海, score=60.0, pageSize=10]</code></pre><h2 id="spring-ioc注解"><a class="markdownIt-Anchor" href="#spring-ioc注解"></a> Spring IoC注解</h2><p>学习基于注解的 IoC 配置，大家脑海里首先得有一个认知，即<strong>注解配置和 xml 配置要实现的功能都是一样的</strong>，都是要降低程序间的耦合。只是配置的形式不一样。</p><p>关于实际的开发中到底使用xml 还是注解，每家公司有着不同的使用习惯。所以这两种配置方式我们都需要掌握</p><p><strong>注解的优势：</strong></p><p>配置简单，维护方便（我们找到类，就相当于找到了对应的配置）</p><p><strong>XML的优势：</strong></p><p>修改时，不用改源码。不涉及重新编译和部署</p><h3 id="1什么是组件扫描"><a class="markdownIt-Anchor" href="#1什么是组件扫描"></a> 1.什么是组件扫描</h3><ul><li>spring容器启动后，会扫描该包及其子包下面的所有的类如果改类前面有特定的注解（比如@Component）,则spring容器会将其纳入容器进行管理（相当于这里配置了一个bean元素）</li><li>指定扫描路径后，并不是该路径下的所有组件类都扫描到spring容器，只有再组件类定义前面有以下注解标记时，才会扫描都Spring容器</li><li>以下注解都是一个作用，但语义不同<blockquote><p>@Componect 通用注解</p><p>@Named 通用注解</p><p>@Repository 持久化层注解扫描</p><p>@Service 业务层组件扫描</p><p>@Controller 表现层组件扫描</p></blockquote></li></ul><hr /><blockquote><p><strong>上述注解有个value属性，用来指定bean的id</strong>，如果不写，则bean的默认id就是<strong>类名首字母小写</strong></p></blockquote><h3 id="2如何进行组件扫描"><a class="markdownIt-Anchor" href="#2如何进行组件扫描"></a> 2.如何进行组件扫描</h3><ul><li>1 一个无参构造器</li><li>2 类标注解 @Component</li><li>3 xml的<beans>中写包名<ul><li><code>&lt;context:component-scan base-package=&quot;org.example&quot;</code></li></ul></li><li>上面的配置，容器实例化时会自动扫描org.example包及其子包下所有组件类</li></ul><pre><code class="highlight plaintext">package annotation;import org.springframework.stereotype.Component;//相当于再spring配置文件中有一条bean，它的id为sb1,缺省值为someBean@Component(&quot;sb1&quot;)public class SomeBean &#123;      public SomeBean()&#123;            System.out.println(&quot;SomeBean()&quot;);      &#125;&#125;</code></pre><p>applicationContext.xml</p><pre><code class="highlight plaintext">      &lt;!-- 配置组件扫描 --&gt;      &lt;!--两种方式都可以--&gt;      &lt;context:annotation-config/&gt;      &lt;!--             base-package属性：指定要扫描的包名，spring容器会扫描该包及其子包下面的所有的类            如果改类前面有特定的注解（比如@Component）,则spring容器会将其纳入容器进行管理（相当于这里配置了一个bean元素）       --&gt;       &lt;beans&gt;      &lt;context:component-scan base-package=&quot;annotation&quot;&gt;&lt;/context:component-scan&gt;    &lt;/beans&gt;</code></pre><h3 id="3作用域原型单例-and-延迟加载-and-初始化和销毁-回掉方法"><a class="markdownIt-Anchor" href="#3作用域原型单例-and-延迟加载-and-初始化和销毁-回掉方法"></a> 3.作用域原型/单例 AND 延迟加载 AND 初始化和销毁 回掉方法</h3><ul><li><code>@Scope('singleton')</code> <strong>单例</strong></li><li><code>@Lazy(true)</code><strong>延迟加载</strong></li><li><code>@PostConstruct</code> <strong>初始化</strong></li><li><code>@PreDestroy</code> <strong>销毁</strong><ul><li>注：初始化和销毁要单独导入tomcat相关包</li></ul></li></ul><pre><code class="highlight plaintext">package annotation;import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;import org.springframework.context.annotation.Lazy;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;//相当于再spring配置文件中有一条bean，它的id为sb1,缺省值为someBean@Component(&quot;sb1&quot;)//指定作用域，原型/单例，prototype原型/singleton单例@Scope(&quot;singleton&quot;)//默认单例都是容器启动就创建对象，延迟加载再启动容器时不创建对象，使用对象时再创建@Lazy(true)public class SomeBean &#123;//@PostConstruct和@PreDestroy都是sun的包，需要导入tomcat对应依赖包@PostConstructpublic void init()&#123;System.out.println(&quot;init()&quot;);&#125;//销毁方法需要作用域为单例@PreDestroypublic void destroy()&#123;System.out.println(&quot;destroy()&quot;);&#125;public SomeBean()&#123;System.out.println(&quot;SomeBean()&quot;);&#125;&#125;</code></pre><h3 id="4-依赖注入相关的注解"><a class="markdownIt-Anchor" href="#4-依赖注入相关的注解"></a> 4 依赖注入相关的注解</h3><table><thead><tr><th>属性</th><th>解释</th></tr></thead><tbody><tr><td><s>@Required</s></td><td>@Required 注释应用于 bean 属性的 setter 方法，它用来<strong>检查</strong>受影响的 bean 属性在配置时必须放在 XML 配置文件中，否则容器就会抛出一个 BeanInitializationException 异常</td></tr><tr><td>@Autowired/@Qualifier</td><td>一般成对使用，autowired默认使用byType方式传入，需要用Quelifier来指定bean的id</td></tr><tr><td>@Resource</td><td>只能用于setter,先按byName方式，然后用byType方式，也可以直接指定要传入的bean的id</td></tr></tbody></table><h4 id="autowired"><a class="markdownIt-Anchor" href="#autowired"></a> @Autowired</h4><ul><li><strong>@Autowired</strong><ul><li>可以处理构造器注入和Setter注入</li><li>默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如：<code>@Autowired(required=false)</code></li><li>a.当采用set方式注入时，可以将@Autowired添加到set方法前面，如果不使用@Qualifier,则容器会使用byType的方式来注入，有可能出错，所以建议使用@Qualifier，明确指定要注入的bean的id</li><li>b.也可以直接将两个注解添加到属性前（写在属性前容器会自动跳过set方法，用反射机制跳过private给赋值）</li><li>c.当采用构造器方式注入时，可以将该注解添加到对应的构造器前面即可</li></ul></li><li><strong>@Qualifier</strong><ul><li>在自动按照类型注入的基础之上，再按照 Bean 的 id 注入</li><li>它在给字段注入时不能独立使用，必须和@Autowire 一起使用；但是给方法参数注入时，可以独立使用</li></ul></li></ul><pre><code class="highlight plaintext">public class UserService&#123;    //@Autowired    //@Qualifier(&quot;mysqlUserDao&quot;)    private UserDao userDao;    @Autowired    public void setUserDao(@Qualifier(&quot;mysqlUserDao&quot;)userDao dao)&#123;        this.userDao = dao;    &#125;&#125;</code></pre><pre><code class="highlight plaintext">package annotation;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Component;@Component(&quot;rest&quot;)public class Restaurant &#123;      //两种写法都可以，写在成员变量前面可以省掉写set方法      //    @Autowired      //    @Qualifier(&quot;wt&quot;)      private Waiter wt;      public Restaurant()&#123;            System.out.println(&quot;Restaurant()&quot;);      &#125;      //@Autowired告诉容器set方法注入      //@Qualifier告诉容器注入对象id为wt      @Autowired      public void setWt(@Qualifier(&quot;wt&quot;)Waiter wt) &#123;            System.out.println(&quot;setWt()&quot;);            this.wt = wt;      &#125;      public String toString() &#123;            return &quot;Restaurant [wt=&quot; + wt + &quot;]&quot;;      &#125;&#125;package annotation;import org.springframework.stereotype.Component;@Component(&quot;wt&quot;)public class Waiter &#123;      public Waiter()&#123;            System.out.println(&quot;Waiter()&quot;);      &#125;&#125;annotation.xml&lt;context:component-scan base-package=&quot;annotation&quot;/&gt;</code></pre><ul><li><s>@Inject/@Named</s><ul><li>和@Autowired用法一致，需要额外导包</li><li>Inject注解标记是Spring3.0开始增添的对JSR-330标准的支持，使用前需要添加JSR-330的jar包,使用方法与@Autowired相似</li></ul></li></ul><pre><code class="highlight plaintext">public class UserService&#123;    private UserDao userDao;    @Inject    public void  setUserDao(@Named(&quot;mysqlUserDao&quot;)UserDao dao)&#123;        this.userDao = dao;    &#125;&#125;</code></pre><h4 id="resource重点"><a class="markdownIt-Anchor" href="#resource重点"></a> @Resource（重点）</h4><ul><li><strong>@Resource（重点）</strong><ul><li>默认按照<strong>名称（byName）进行装配</strong>，名称可以通过name属性进行指定</li><li>该注解属于J2EE</li><li>只能处理Setter注入，但是大部分情况都是Setter注入</li><li>Resource注解标记可以用在<strong>字段定义</strong>或<strong>setter方法定义</strong>前面(区别就是字段前面只是单纯的赋值，方法前面可以捎带执行方法内的其他语句)</li><li>如果没有指定name属性，当注解写在字段上时，<strong>默认首先按字段名匹配注入，当找不到与名称匹配的bean时才按照类型进行装配</strong></li><li>当遇到多个匹配Bean时注入会发生错误，可以显示指定名称（但是需要注意的是，如果<strong>name属性一旦指定</strong>，就<strong>只会</strong>按照名称进行装配），例如<code>@Resource(name=&quot;empDao1&quot;)</code></li></ul></li></ul><pre><code class="highlight plaintext">@Component(&quot;us&quot;)public class UserService&#123;    @Resource(name=&quot;userDao&quot;)    private UserDao userDao;    @Resource    public void setUserDao(UserDao dao)&#123;        this.userDao = dao;    &#125;&#125;</code></pre><h4 id="value"><a class="markdownIt-Anchor" href="#value"></a> @Value</h4><ul><li>可以给基本类型和String类型注入值</li><li>可以使用占位符获取properties属性文件中的值</li></ul><h5 id="value和value的区别"><a class="markdownIt-Anchor" href="#value和value的区别"></a> @value(“#{}”)和@value(“${}”)的区别</h5><p><strong>@value(“${}”)</strong></p><p>一般用来获取properties属性文件中的值，获取的前提是需要在applicationContext.xml文件中配置properties文件</p><pre><code class="highlight plaintext">@Value(“$&#123;name&#125;”)//name是properties文件中的keyprivate String name;</code></pre><p>applicationContext.xml配置文件</p><pre><code class="highlight plaintext">&lt;!-- 加载配置属性文件 --&gt;&lt;context:property-placeholder location=&quot;classpath:sys.properties&quot; /&gt;</code></pre><p><strong>@value(“#{}”)</strong></p><p>此种用法SpEl表达式通常用来获取bean的属性，或者调用bean的某个方法。当然还有可以表示常量</p><pre><code class="highlight plaintext">public class LoginController &#123;@Value(&quot;#&#123;1&#125;&quot;)private int number; //获取数字 1@Value(&quot;#&#123;&#x27;Spring Expression Language&#x27;&#125;&quot;) //获取字符串常量private String str;@Value(&quot;#&#123;dataSource.url&#125;&quot;) //获取bean的属性private String jdbcUrl;    ... ...&#125;</code></pre><h5 id="通过utilproperties"><a class="markdownIt-Anchor" href="#通过utilproperties"></a> 通过util:properties</h5><ul><li>可以使用该注解来注入基本类型的值</li><li>@Value注解可以注入Spring表达式值，使用方法</li><li>首先在XML配置中指定要注入的properties文件<ul><li><code>&lt;util:properties location=&quot;classpath:db.properties&quot;/&gt;</code></li></ul></li><li>然后再setter方法前使用@Value注解</li></ul><pre><code class="highlight plaintext">public class JDBCDateSource&#123;    @Value(&quot;#&#123;jdbcProps.url&#125;&quot;)    private String url;    @Value(&quot;#&#123;jdbcProps.driver&#125;&quot;)    public void setUrl(String driver)&#123;        Class.forName(driver);    &#125;&#125;</code></pre><h5 id="通过propertyplaceholderconfigurer"><a class="markdownIt-Anchor" href="#通过propertyplaceholderconfigurer"></a> 通过PropertyPlaceholderConfigurer</h5><ul><li>dev.properties</li></ul><pre><code class="highlight plaintext">tag=123</code></pre><ul><li>spring.xml 配置</li></ul><pre><code class="highlight plaintext">&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;&lt;property name=&quot;location&quot; value=&quot;dev.properties&quot; /&gt;&lt;/bean&gt;</code></pre><ul><li>使用</li></ul><pre><code class="highlight plaintext">@Value(&quot;$&#123;tag&#125;&quot;)private String tag;</code></pre><h5 id="通过preferencesplaceholderconfigurer"><a class="markdownIt-Anchor" href="#通过preferencesplaceholderconfigurer"></a> 通过PreferencesPlaceholderConfigurer</h5><ul><li>配置</li></ul><pre><code class="highlight plaintext">&lt;bean id=&quot;appConfig&quot; class=&quot;org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer&quot;&gt;&lt;property name=&quot;location&quot; value=&quot;dev.properties&quot; /&gt;&lt;/bean&gt;</code></pre><ul><li>使用</li></ul><pre><code class="highlight plaintext">@Value(&quot;$&#123;tag&#125;&quot;)private String tag;</code></pre><h5 id="通过propertiesfactorybean"><a class="markdownIt-Anchor" href="#通过propertiesfactorybean"></a> 通过PropertiesFactoryBean</h5><ul><li>配置</li></ul><pre><code class="highlight plaintext">&lt;bean id=&quot;config&quot; class=&quot;org.springframework.beans.factory.config.PropertiesFactoryBean&quot;&gt;&lt;property name=&quot;location&quot; value=&quot;dev.properties&quot; /&gt;&lt;/bean&gt;</code></pre><ul><li>使用</li></ul><pre><code class="highlight plaintext">@Value(&quot;#&#123;config[&#x27;tag&#x27;]&#125;&quot;)private String tag;</code></pre><h2 id="java类取代spring-xml配置"><a class="markdownIt-Anchor" href="#java类取代spring-xml配置"></a> Java类取代spring xml配置</h2><h3 id="configuration和bean注解"><a class="markdownIt-Anchor" href="#configuration和bean注解"></a> @Configuration和@Bean注解</h3><p>@<strong>Configuration</strong></p><ul><li>@<strong>Configuration</strong>相当于配置文件中<strong>的<beans/>根标签</strong></li><li>从Spring3.0，@Configuration用于定义配置类，<strong>可替换xml配置文件</strong></li><li>配置类内部包含有一个或多个被@Bean注解的方法，这些方法将会被<code>AnnotationConfigApplicationContext</code>或<code>AnnotationConfigWebApplicationContext</code>类进行扫描，并用于构建bean定义，初始化Spring容器</li><li><strong>属性</strong><ul><li>value:用于指定配置类的字节码</li></ul></li></ul><p>@<strong>Bean</strong></p><ul><li>@<strong>Bean</strong>相当于<bean/>，只能注解在方法和注解上，一般在方法上使用</li><li>带有@<strong>Configuration</strong>的注解类表示这个类可以使用Spring IOC容器作为bean定义的来源，@<strong>Bean</strong>注解告诉Spring，一个带有@Bean的注解方法将返回一个对象，该对象应该被注册在Spring应用程序上下文中的bean</li><li><strong>属性</strong><ul><li>name：给当前@Bean 注解方法创建的对象指定一个名称(即 bean 的 id）</li><li>如果不指定，<strong>默认与标注的方法名相同</strong></li><li>@Bean注解默认作用域为单例singleton作用域，可通过@Scope(“prototype”)设置为原型作用域；</li></ul></li></ul><blockquote><p>使用零配置和注解虽然方便，不需要编写麻烦的xml文件，但并非为了取代xml，应该根据实例需要选择，或二者结合使用，毕竟使用一个类作为容器的配置信息是硬编码的，<strong>无法在发布后修改</strong></p></blockquote><ul><li>案例</li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;import org.springframework.context.annotation.*;@Configurationpublic class SpringConfiguration &#123;   @Bean    public HelloWorld helloWorld()&#123;      return new HelloWorld();   &#125;      //spring容器初始化时，会调用配置类的无参构造函数   public SpringConfiguration()&#123;       System.out.println(“容器启动初始化。。。”);   &#125;&#125;</code></pre><ul><li>上面的代码将等同于下面的XML配置</li></ul><pre><code class="highlight plaintext">&lt;beans&gt;   &lt;bean id=&quot;helloWorld&quot; class=&quot;com.tutorialspoint.HelloWorld&quot; /&gt;&lt;/beans&gt;</code></pre><ul><li>在这里，带有@Bean注解的方法名称作为bean的id,它创建并返回实际的bean，你的配置类可以声明多个@Bean，一旦定义了<strong>配置类</strong>，就可以使用AnnotationConfigApplicationContext来加载并把他们提供给spring容器</li></ul><pre><code class="highlight plaintext">public static void main(String[] args) &#123;   ApplicationContext ctx =    new AnnotationConfigApplicationContext(HelloWorldConfig.class); //这个HolloWorldConfig就是一个配置类，里面@Bean声明的方法就相当于在spring容器中添加了一个bean配置   HelloWorld helloWorld = ctx.getBean(HelloWorld.class);   helloWorld.setMessage(&quot;Hello World!&quot;);   helloWorld.getMessage();&#125;</code></pre><ul><li>或者可以加载各种配置类</li></ul><pre><code class="highlight plaintext">public static void main(String[] args) &#123;   AnnotationConfigApplicationContext ctx =    new AnnotationConfigApplicationContext();   ctx.register(AppConfig.class, OtherConfig.class);   ctx.register(AdditionalConfig.class);   ctx.refresh();   MyService myService = ctx.getBean(MyService.class);   myService.doStuff();&#125;</code></pre><h3 id="componentscan"><a class="markdownIt-Anchor" href="#componentscan"></a> @ComponentScan</h3><p>@<strong>ComponentScan</strong></p><ul><li>相当于context:component-scan标签</li><li>组件扫描器，扫描@Component、@Controller、@Service、@Repository注解的类。</li><li>该注解是编写在类上面的，一般配合@Configuration注解一起使用</li><li><strong>属性</strong><ul><li>basePackages：用于指定要扫描的包</li><li>value：和basePackages作用一样</li></ul></li></ul><pre><code class="highlight plaintext">@Configuration@ComponentScan(basePackages=&quot;com.kkb.spring.service&quot;)public class SpringConfiguration &#123;         public SpringConfiguration() &#123;                  System.out.println(&quot;容器初始化...&quot;);         &#125;&#125;</code></pre><h3 id="propertysource"><a class="markdownIt-Anchor" href="#propertysource"></a> @PropertySource</h3><p>在开发应用程序时，经常需要读取配置文件。最常用的配置方法是以key=value的形式写在.properties文件中。</p><p>例如，MailService根据配置的app.zone=Asia/Shanghai来决定使用哪个时区。要读取配置文件，我们可以使用上一节讲到的Resource来读取位于classpath下的一个app.properties文件。但是，这样仍然比较繁琐。</p><p>Spring容器还提供了一个更简单的@PropertySource来自动读取配置文件。我们只需要在@Configuration配置类上再添加一个注解：</p><pre><code class="highlight plaintext">@Configuration@ComponentScan@PropertySource(&quot;app.properties&quot;) // 表示读取classpath的app.propertiespublic class AppConfig &#123;    @Value(&quot;$&#123;app.zone:Z&#125;&quot;)    String zoneId;    @Bean    ZoneId createZoneId() &#123;        return ZoneId.of(zoneId);    &#125;&#125;</code></pre><p>Spring容器看到@PropertySource(“app.properties”)注解后，自动读取这个配置文件，然后，我们使用@Value正常注入：</p><pre><code class="highlight plaintext">@Value(&quot;$&#123;app.zone:Z&#125;&quot;)String zoneId;</code></pre><p>注意注入的字符串语法，它的格式如下：</p><ul><li>&quot;${app.zone}&quot;表示读取key为app.zone的value，如果key不存在，启动将报错；</li><li>&quot;${app.zone:Z}&quot;表示读取key为app.zone的value，但如果key不存在，就使用默认值Z。</li></ul><p>这样一来，我们就可以根据app.zone的配置来创建ZoneId。</p><p>还可以把注入的注解写到方法参数中：</p><pre><code class="highlight plaintext">@BeanZoneId createZoneId(@Value(&quot;$&#123;app.zone:Z&#125;&quot;) String zoneId) &#123;    return ZoneId.of(zoneId);&#125;</code></pre><p>可见，先使用@PropertySource读取配置文件，然后通过@Value以${key:defaultValue}的形式注入，可以极大地简化读取配置的麻烦。</p><p>另一种注入配置的方式是先通过一个简单的JavaBean持有所有的配置，例如，一个SmtpConfig：</p><pre><code class="highlight plaintext">@Componentpublic class SmtpConfig &#123;    @Value(&quot;$&#123;smtp.host&#125;&quot;)    private String host;    @Value(&quot;$&#123;smtp.port:25&#125;&quot;)    private int port;    public String getHost() &#123;        return host;    &#125;    public int getPort() &#123;        return port;    &#125;&#125;</code></pre><p>然后，在需要读取的地方，使用#{smtpConfig.host}注入：</p><pre><code class="highlight plaintext">@Componentpublic class MailService &#123;    @Value(&quot;#&#123;smtpConfig.host&#125;&quot;)    private String smtpHost;    @Value(&quot;#&#123;smtpConfig.port&#125;&quot;)    private int smtpPort;&#125;</code></pre><p>注意观察#{}这种注入语法，它和${key}不同的是，#{}表示从JavaBean读取属性。&quot;#{smtpConfig.host}&quot;的意思是，从名称为smtpConfig的Bean读取host属性，即调用getHost()方法。一个Class名为SmtpConfig的Bean，它在Spring容器中的默认名称就是smtpConfig，除非用@Qualifier指定了名称。</p><p>使用一个独立的JavaBean持有所有属性，然后在其他Bean中以#{bean.property}注入的好处是，多个Bean都可以引用同一个Bean的某个属性。例如，如果SmtpConfig决定从数据库中读取相关配置项，那么MailService注入的@Value(“#{smtpConfig.host}”)仍然可以不修改正常运行。</p><p>示例：</p><pre><code class="highlight plaintext">@Configuration@PropertySource(“classpath:jdbc.properties”)public class JdbcConfig &#123;    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)    private String driver;    @Value(&quot;$&#123;jdbc.url&#125;&quot;)    private String url;    @Value(&quot;$&#123;jdbc.username&#125;&quot;)    private String username;    @Value(&quot;$&#123;jdbc.password&#125;&quot;)    private String password;    /**    创建一个数据源，并存入 spring 容器中    @return    */    @Bean(name=&quot;dataSource&quot;)    public DataSource createDataSource() &#123;        try &#123;            ComboPooledDataSource ds = new ComboPooledDataSource();             ds.setDriverClass(driver);            ds.setJdbcUrl(url);             ds.setUser(username);             ds.setPassword(password);             return ds;        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;</code></pre><p>jdbc.properties</p><pre><code class="highlight plaintext">jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql:///springjdbc.username=root jdbc.password=root</code></pre><h3 id="resource"><a class="markdownIt-Anchor" href="#resource"></a> @Resource</h3><p>在Java程序中，我们经常会读取配置文件、资源文件等。使用Spring容器时，我们也可以把“文件”注入进来，方便程序读取。</p><p>例如，AppService需要读取logo.txt这个文件，通常情况下，我们需要写很多繁琐的代码，主要是为了定位文件，打开InputStream。</p><p>Spring提供了一个org.springframework.core.io.Resource（注意不是jarkata.annotation.Resource或javax.annotation.Resource），它可以像String、int一样使用@Value注入：</p><pre><code class="highlight plaintext">@Componentpublic class AppService &#123;    @Value(&quot;classpath:/logo.txt&quot;)    private Resource resource;    private String logo;    @PostConstruct    public void init() throws IOException &#123;        try (var reader = new BufferedReader(                new InputStreamReader(resource.getInputStream(), StandardCharsets.UTF_8))) &#123;            this.logo = reader.lines().collect(Collectors.joining(&quot;\n&quot;));        &#125;    &#125;&#125;</code></pre><p>注入Resource最常用的方式是通过classpath，即类似classpath:/logo.txt表示在classpath中搜索logo.txt文件，然后，我们直接调用Resource.getInputStream()就可以获取到输入流，避免了自己搜索文件的代码。也可以直接指定文件的路径，例如：</p><pre><code class="highlight plaintext">@Value(&quot;file:/path/to/logo.txt&quot;)private Resource resource;</code></pre><p>但使用classpath是最简单的方式。上述工程结构如下：</p><h3 id="import"><a class="markdownIt-Anchor" href="#import"></a> @Import</h3><p>@<strong>import</strong></p><ul><li>注解允许从另一个配置类中加载@Bean定义</li><li>用来组合多个配置类</li><li>相当于spring标签中的import标签</li><li>在引入其他配置类时，可以不用再写@Configuration 注解。当然，写上也没问题</li><li><strong>属性</strong><ul><li>value：用来指定其他配置类的字节码文件</li></ul></li></ul><pre><code class="highlight plaintext">@Configurationpublic class ConfigA &#123;   @Bean   public A a() &#123;      return new A();    &#125;&#125;</code></pre><ul><li>可以在另一个bean声明中导入上述Bean声明</li></ul><pre><code class="highlight plaintext">@Configuration@Import(ConfigA.class)public class ConfigB &#123;   @Bean   public B a() &#123;      return new A();    &#125;&#125;</code></pre><ul><li>现在，当实例化上下文时，不需要同时指定ConfigA.class和ConfigB.class，只有ConfigB类需要提供</li></ul><pre><code class="highlight plaintext">public static void main(String[] args) &#123;   ApplicationContext ctx =    new AnnotationConfigApplicationContext(ConfigB.class);   // now both beans A and B will be available...   A a = ctx.getBean(A.class);   B b = ctx.getBean(B.class);&#125;</code></pre><h3 id="注入list"><a class="markdownIt-Anchor" href="#注入list"></a> 注入List</h3><p>有些时候，我们会有一系列接口相同，不同实现类的Bean。例如，注册用户时，我们要对email、password和name这3个变量进行验证。为了便于扩展，我们先定义验证接口：</p><pre><code class="highlight plaintext">public interface Validator &#123;    void validate(String email, String password, String name);&#125;</code></pre><p>然后，分别使用3个Validator对用户参数进行验证：</p><pre><code class="highlight plaintext">@Componentpublic class EmailValidator implements Validator &#123;    public void validate(String email, String password, String name) &#123;        if (!email.matches(&quot;^[a-z0-9]+\\@[a-z0-9]+\\.[a-z]&#123;2,10&#125;$&quot;)) &#123;            throw new IllegalArgumentException(&quot;invalid email: &quot; + email);        &#125;    &#125;&#125;@Componentpublic class PasswordValidator implements Validator &#123;    public void validate(String email, String password, String name) &#123;        if (!password.matches(&quot;^.&#123;6,20&#125;$&quot;)) &#123;            throw new IllegalArgumentException(&quot;invalid password&quot;);        &#125;    &#125;&#125;@Componentpublic class NameValidator implements Validator &#123;    public void validate(String email, String password, String name) &#123;        if (name == null || name.isBlank() || name.length() &gt; 20) &#123;            throw new IllegalArgumentException(&quot;invalid name: &quot; + name);        &#125;    &#125;&#125;</code></pre><p>最后，我们通过一个Validators作为入口进行验证：</p><pre><code class="highlight plaintext">@Componentpublic class Validators &#123;    @Autowired    List&lt;Validator&gt; validators;    public void validate(String email, String password, String name) &#123;        for (var validator : this.validators) &#123;            validator.validate(email, password, name);        &#125;    &#125;&#125;</code></pre><p>注意到Validators被注入了一个List<Validator>，Spring会自动把<strong>所有类型为Validator的Bean装配为一个List注入</strong>进来，这样一来，我们每新增一个Validator类型，就自动被Spring装配到Validators中了，非常方便。</p><p>因为Spring是通过扫描classpath获取到所有的Bean，而List是有序的，要指定List中Bean的顺序，可以加上@Order注解：</p><pre><code class="highlight plaintext">@Component@Order(1)public class EmailValidator implements Validator &#123;    ...&#125;@Component@Order(2)public class PasswordValidator implements Validator &#123;    ...&#125;@Component@Order(3)public class NameValidator implements Validator &#123;    ...&#125;</code></pre><h3 id="生命周期回调"><a class="markdownIt-Anchor" href="#生命周期回调"></a> 生命周期回调</h3><ul><li>@Bean注解支持任意的初始化和销毁的回调方法，就像在bean元素中spring的xml的初始化方法和销毁方法的属性</li></ul><pre><code class="highlight plaintext">public class Foo &#123;   public void init() &#123;      // initialization logic   &#125;   public void cleanup() &#123;      // destruction logic   &#125;&#125;@Configurationpublic class AppConfig &#123;   @Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;cleanup&quot; )   public Foo foo() &#123;      return new Foo();   &#125;&#125;</code></pre><ul><li><strong>指定bean的范围</strong></li><li>默认范围时单例，但是你可以重写带有@Scope注解的该方法</li></ul><pre><code class="highlight plaintext">@Configurationpublic class AppConfig &#123;   @Bean   @Scope(&quot;prototype&quot;)   public Foo foo() &#123;      return new Foo();   &#125;&#125;</code></pre><h3 id="创建第三方bean"><a class="markdownIt-Anchor" href="#创建第三方bean"></a> 创建第三方Bean</h3><p>如果一个Bean不在我们自己的package管理之内，例如ZoneId，如何创建它？</p><p>答案是我们自己在@Configuration类中编写一个Java方法创建并返回它，注意给方法标记一个@Bean注解：</p><pre><code class="highlight plaintext">@Configuration@ComponentScanpublic class AppConfig &#123;    // 创建一个Bean:    @Bean    ZoneId createZoneId() &#123;        return ZoneId.of(&quot;Z&quot;);    &#125;&#125;</code></pre><p>Spring对标记为@Bean的方法只调用一次，因此返回的Bean仍然是单例。</p><h3 id="初始化和销毁"><a class="markdownIt-Anchor" href="#初始化和销毁"></a> 初始化和销毁</h3><p>有些时候，一个Bean在注入必要的依赖后，需要进行初始化（监听消息等）。在容器关闭时，有时候还需要清理资源（关闭连接池等）。我们通常会定义一个init()方法进行初始化，定义一个shutdown()方法进行清理，然后，引入JSR-250定义的Annotation：</p><ul><li>jakarta.annotation:jakarta.annotation-api:2.1.1</li></ul><p>在Bean的初始化和清理方法上标记@PostConstruct和@PreDestroy：</p><pre><code class="highlight plaintext">@Componentpublic class MailService &#123;    @Autowired(required = false)    ZoneId zoneId = ZoneId.systemDefault();    @PostConstruct    public void init() &#123;        System.out.println(&quot;Init mail service with zonehljs-keyword&quot; style=&quot;color: #569cd6; line-height: 160%; box-sizing: content-box;&quot;&gt;this.zoneId);    &#125;    @PreDestroy    public void shutdown() &#123;        System.out.println(&quot;Shutdown mail service&quot;);    &#125;&#125;</code></pre><p>Spring容器会对上述Bean做如下初始化流程：</p><ul><li>调用构造方法创建MailService实例；</li><li>根据@Autowired进行注入；</li><li>调用标记有@PostConstruct的init()方法进行初始化。</li></ul><p>而销毁时，容器会首先调用标记有@PreDestroy的shutdown()方法。</p><p>Spring只根据Annotation查找无参数方法，对方法名不作要求。</p><h3 id="使用别名"><a class="markdownIt-Anchor" href="#使用别名"></a> 使用别名</h3><p>默认情况下，对一种类型的Bean，容器只创建一个实例。但有些时候，我们需要对一种类型的Bean创建多个实例。</p><p>例如，同时连接多个数据库，就必须创建多个DataSource实例。如果我们在@Configuration类中创建了多个同类型的Bean：</p><pre><code class="highlight plaintext">@Configuration@ComponentScanpublic class AppConfig &#123;    @Bean    ZoneId createZoneOfZ() &#123;        return ZoneId.of(&quot;Z&quot;);    &#125;    @Bean    ZoneId createZoneOfUTC8() &#123;        return ZoneId.of(&quot;UTC+08:00&quot;);    &#125;&#125;</code></pre><p>Spring会报NoUniqueBeanDefinitionException异常，意思是出现了重复的Bean定义。这个时候，需要给每个Bean添加不同的名字：</p><pre><code class="highlight plaintext">@Configuration@ComponentScanpublic class AppConfig &#123;    @Bean(&quot;z&quot;)    ZoneId createZoneOfZ() &#123;        return ZoneId.of(&quot;Z&quot;);    &#125;    @Bean    @Qualifier(&quot;utc8&quot;)    ZoneId createZoneOfUTC8() &#123;        return ZoneId.of(&quot;UTC+08:00&quot;);    &#125;&#125;</code></pre><p>可以用@Bean(“name”)指定别名，也可以用@Bean+@Qualifier(“name”)指定别名。</p><p>存在多个同类型的Bean时，注入ZoneId又会报错：</p><pre><code class="highlight plaintext">NoUniqueBeanDefinitionException: No qualifying bean of type &#x27;java.time.ZoneId&#x27; available: expected single matching bean but found 2</code></pre><p>意思是期待找到唯一的ZoneId类型Bean，但是找到两。因此，注入时，要指定Bean的名称：</p><pre><code class="highlight plaintext">@Componentpublic class MailService &#123;        @Autowired(required = false)        @Qualifier(&quot;z&quot;) // 指定注入名称为&quot;z&quot;的ZoneId        ZoneId zoneId = ZoneId.systemDefault();    ...&#125;</code></pre><p>还有一种方法是把其中某个Bean指定为@Primary：</p><pre><code class="highlight plaintext">@Configuration@ComponentScanpublic class AppConfig &#123;    @Bean    @Primary // 指定为主要Bean    @Qualifier(&quot;z&quot;)    ZoneId createZoneOfZ() &#123;        return ZoneId.of(&quot;Z&quot;);    &#125;    @Bean    @Qualifier(&quot;utc8&quot;)    ZoneId createZoneOfUTC8() &#123;        return ZoneId.of(&quot;UTC+08:00&quot;);    &#125;&#125;</code></pre><p>这样，在注入时，如果没有指出Bean的名字，Spring会注入标记有@Primary的Bean。这种方式也很常用。例如，对于主从两个数据源，通常将主数据源定义为@Primary：</p><pre><code class="highlight plaintext">@Configuration@ComponentScanpublic class AppConfig &#123;    @Bean    @Primary    DataSource createMasterDataSource() &#123;        ...    &#125;    @Bean    @Qualifier(&quot;slave&quot;)    DataSource createSlaveDataSource() &#123;        ...    &#125;&#125;</code></pre><p>其他Bean默认注入的就是主数据源。如果要注入从数据源，那么只需要指定名称即可。</p><h3 id="profile"><a class="markdownIt-Anchor" href="#profile"></a> @Profile</h3><p>开发应用程序时，我们会使用开发环境，例如，使用内存数据库以便快速启动。而运行在生产环境时，我们会使用生产环境，例如，使用MySQL数据库。如果应用程序可以根据自身的环境做一些适配，无疑会更加灵活。</p><p>Spring为应用程序准备了Profile这一概念，用来表示不同的环境。例如，我们分别定义开发、测试和生产这3个环境：</p><ul><li>native</li><li>test</li><li>production</li></ul><p>创建某个Bean时，Spring容器可以根据注解@Profile来决定是否创建。例如，以下配置：</p><pre><code class="highlight plaintext">@Configuration@ComponentScanpublic class AppConfig &#123;    @Bean    @Profile(&quot;!test&quot;)    ZoneId createZoneId() &#123;        return ZoneId.systemDefault();    &#125;    @Bean    @Profile(&quot;test&quot;)    ZoneId createZoneIdForTest() &#123;        return ZoneId.of(&quot;America/New_York&quot;);    &#125;&#125;</code></pre><p>如果当前的Profile设置为test，则Spring容器会调用createZoneIdForTest()创建ZoneId，否则，调用createZoneId()创建ZoneId。注意到@Profile(“!test”)表示非test环境。</p><p>在运行程序时，加上JVM参数-Dspring.profiles.active=test就可以指定以test环境启动。</p><p>实际上，Spring允许指定多个Profile，例如：</p><pre><code class="highlight plaintext">-Dspring.profiles.active=test,master</code></pre><p>可以表示test环境，并使用master分支代码。</p><p>要满足多个Profile条件，可以这样写：</p><pre><code class="highlight plaintext">@Bean@Profile(&#123; &quot;test&quot;, &quot;master&quot; &#125;) // 满足test或masterZoneId createZoneId() &#123;    ...&#125;</code></pre><h3 id="conditional"><a class="markdownIt-Anchor" href="#conditional"></a> @Conditional</h3><p>除了根据@Profile条件来决定是否创建某个Bean外，Spring还可以根据@Conditional决定是否创建某个Bean。</p><p>例如，我们对SmtpMailService添加如下注解：</p><pre><code class="highlight plaintext">@Component@Conditional(OnSmtpEnvCondition.class)public class SmtpMailService implements MailService &#123;    ...&#125;</code></pre><p>它的意思是，如果满足OnSmtpEnvCondition的条件，才会创建SmtpMailService这个Bean。OnSmtpEnvCondition的条件是什么呢？我们看一下代码：</p><pre><code class="highlight plaintext">public class OnSmtpEnvCondition implements Condition &#123;    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;        return &quot;true&quot;.equalsIgnoreCase(System.getenv(&quot;smtp&quot;));    &#125;&#125;</code></pre><p>因此，OnSmtpEnvCondition的条件是存在环境变量smtp，值为true。这样，我们就可以通过环境变量来控制是否创建SmtpMailService。</p><p>Spring只提供了@Conditional注解，具体判断逻辑还需要我们自己实现。Spring Boot提供了更多使用起来更简单的条件注解，例如，如果配置文件中存在app.smtp=true，则创建MailService：</p><pre><code class="highlight plaintext">@Component@ConditionalOnProperty(name=&quot;app.smtp&quot;, havingValue=&quot;true&quot;)public class MailService &#123;    ...&#125;</code></pre><p>如果当前classpath中存在类javax.mail.Transport，则创建MailService：</p><pre><code class="highlight plaintext">@Component@ConditionalOnClass(name = &quot;javax.mail.Transport&quot;)public class MailService &#123;    ...&#125;</code></pre><p>后续我们会介绍Spring Boot的条件装配。我们以文件存储为例，假设我们需要保存用户上传的头像，并返回存储路径，在本地开发运行时，我们总是存储到文件：</p><pre><code class="highlight plaintext">@Component@ConditionalOnProperty(name = &quot;app.storage&quot;, havingValue = &quot;file&quot;, matchIfMissing = true)public class FileUploader implements Uploader &#123;    ...&#125;</code></pre><p>在生产环境运行时，我们会把文件存储到类似AWS S3上：</p><pre><code class="highlight plaintext">@Component@ConditionalOnProperty(name = &quot;app.storage&quot;, havingValue = &quot;s3&quot;)public class S3Uploader implements Uploader &#123;    ...&#125;</code></pre><p>其他需要存储的服务则注入Uploader：</p><pre><code class="highlight plaintext">@Componentpublic class UserImageService &#123;    @Autowired    Uploader uploader;&#125;</code></pre><p>当应用程序检测到配置文件存在app.storage=s3时，自动使用S3Uploader，如果存在配置app.storage=file，或者配置app.storage不存在，则使用FileUploader。</p><h3 id="注入bean的依赖性"><a class="markdownIt-Anchor" href="#注入bean的依赖性"></a> 注入Bean的依赖性</h3><ul><li>当@Bean依赖其他的Bean时，表达这种依赖性非常简单，只要有一个bean方法调用另一个即可</li><li>这里，foo Bean通过构造函数注入来接受参数</li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;import org.springframework.context.annotation.*;@Configurationpublic class AppConfig &#123;   @Bean   public Foo foo() &#123;      return new Foo(bar());   &#125;   @Bean   public Bar bar() &#123;      return new Bar();   &#125;&#125;</code></pre><h3 id="通过注解获取容器"><a class="markdownIt-Anchor" href="#通过注解获取容器"></a> 通过注解获取容器</h3><p><strong>Java应用（AnnotationConfigApplicationContext）</strong></p><pre><code class="highlight plaintext">ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfiguration.class);UserService service = context.getBean(UserService.class);service.saveUser();</code></pre><p><strong>Web应用（AnnotationConfigWebApplicationContext</strong></p><pre><code class="highlight plaintext">&lt;web-app&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextClass&lt;/param-name&gt;        &lt;param-value&gt;            org.springframework.web.context.            support.AnnotationConfigWebApplicationContext        &lt;/param-value&gt;    &lt;/context-param&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;            com.kkb.spring.test.SpringConfiguration        &lt;/param-value&gt;    &lt;/context-param&gt;    &lt;listener&gt;        &lt;listener-class&gt;            org.springframework.web.context.ContextLoaderListener        &lt;/listener-class&gt;    &lt;/listener&gt;&lt;/web-app&gt;</code></pre><h3 id="使用factorybean"><a class="markdownIt-Anchor" href="#使用factorybean"></a> 使用FactoryBean</h3><p>我们在设计模式的工厂方法中讲到，很多时候，可以通过工厂模式创建对象。Spring也提供了工厂模式，允许定义一个工厂，然后由工厂创建真正的Bean。</p><p>用工厂模式创建Bean需要实现FactoryBean接口。我们观察下面的代码：</p><pre><code class="highlight plaintext">@Componentpublic class ZoneIdFactoryBean implements FactoryBean&lt;ZoneId&gt; &#123;    String zone = &quot;Z&quot;;    @Override    public ZoneId getObject() throws Exception &#123;        return ZoneId.of(zone);    &#125;    @Override    public Class&lt;?&gt; getObjectType() &#123;        return ZoneId.class;    &#125;&#125;</code></pre><p>当一个Bean实现了FactoryBean接口后，Spring会先实例化这个工厂，然后调用getObject()创建真正的Bean。getObjectType()可以指定创建的Bean的类型，因为指定类型不一定与实际类型一致，可以是接口或抽象类。</p><p>因此，如果定义了一个FactoryBean，要注意Spring创建的Bean实际上是这个FactoryBean的getObject()方法返回的Bean。为了和普通Bean区分，我们通常都以XxxFactoryBean命名。</p><p>由于可以用@Bean方法创建第三方Bean，本质上@Bean方法就是工厂方法，所以，FactoryBean已经用得越来越少了。</p><h2 id="spring-分模块开发"><a class="markdownIt-Anchor" href="#spring-分模块开发"></a> Spring 分模块开发</h2><p>分模块开发的场景描述：</p><ul><li>表现层：spring配置文件，只想管理表现层的Bean</li><li>业务层：spring配置文件，只想管理业务层的Bean，并且进行事务控制</li><li>持久层：spring配置文件，只想管理持久层的Bean，并且还有需要管理数据源的Bean</li></ul><p><strong>为了方便管理项目中不同层的Bean对象，一般都是将一个spring配置文件，分解为多个spring配置文件</strong></p><h3 id="如何加载多个配置文件"><a class="markdownIt-Anchor" href="#如何加载多个配置文件"></a> 如何加载多个配置文件</h3><p><strong>1. 同时指定多个配置文件的地址一起加载</strong></p><pre><code class="highlight plaintext">ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext1.xml&quot;,&quot;applicationContext2.xml&quot;,&quot;applicationContext3.xml&quot;);</code></pre><p><strong>2. 定义一个import.xml文件，通过import标签将其他多个spring配置文件导入到该文件中，tomcat启动时只需要加载import.xml就可以</strong></p><pre><code class="highlight plaintext">&lt;beans&gt;    &lt;!--import中放入其他的配置文件--&gt;    &lt;import resource=&quot;&quot;&gt;&lt;/import&gt;&lt;/beans&gt;</code></pre><h2 id="spring-整合junit"><a class="markdownIt-Anchor" href="#spring-整合junit"></a> Spring 整合Junit</h2><p><strong>要解决的问题</strong></p><p>为了避免每次测试业务代码，都手动的写一遍启动spring框架的代码，我们需要的是程序能自动帮我们创建容器。一旦程序能自动为我们创建 spring 容器，我们就无须手动创建了，问题也就解决了。</p><p>但紧接的问题就是junit它本身不认识spring，更无法帮助创建Spring容器了，不过好在Junit 给我们暴露了一个注解（@<strong>RunWith</strong>），可以让我们替换掉它的运行器。</p><p>这时，我们需要依靠 spring 框架，因为它提供了一个<strong>运行器</strong>，可以读取配置文件（或注解）来创建容器。我们只需要告诉它配置文件在哪就行了。</p><hr /><p><strong>具体实现</strong></p><ol><li>添加依赖</li></ol><pre><code class="highlight plaintext">&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;    &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol><li>通过@RunWith注解，指定spring的运行器<ul><li>Spring的运行器是<strong>SpringJunit4ClassRunner</strong></li></ul></li><li>通过<code>@ContextConfiguration</code>注解，指定spring运行器需要的配置文件路径</li><li>通过<code>@Autowired</code>注解给测试类中的变量注入数据</li></ol><pre><code class="highlight plaintext">import com.lee.util.BaseService;import javafx.application.Application;import org.junit.runner.RunWith;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;//@RunWith：Junit自身的注解，它的作用是可以指定一个新的运行器，进行单元测试//SpringJUnit4ClassRunner：spring提供的单元测试运行器@RunWith(SpringJUnit4ClassRunner.class)//@ContextConfiguration:SpringJUnit4ClassRunner运行器需要的上下文配置信息，方便创建spring容器//classes：纯注解方式，读取配置类//locations：XML方式，读取配置文件@ContextConfiguration(locations = &quot;classpath:springConfig.xml&quot;)//@ContextConfiguration(classes = SpringConfiguration.class)public class Test &#123;    @Resource    private UserService userService;    @Test    public void test1()&#123;        userService.saveUser();    &#125;&#125;</code></pre><h2 id="spring中事件处理"><a class="markdownIt-Anchor" href="#spring中事件处理"></a> Spring中事件处理</h2><h3 id="spring中的事件处理"><a class="markdownIt-Anchor" href="#spring中的事件处理"></a> Spring中的事件处理</h3><ul><li>Spring的核心时<strong>ApplicationContext</strong>，它负责管理beans的完整生命周期，当加载beans时，ApplicationContext发布某些类型的事件，例如，当上下文启动时，ContextStartedEvent发布，当上下文停止时，ContextStoppedEvent发布</li><li>通过<strong>ApplicationEvent</strong>类和<strong>ApplicationListener</strong>接口来提供在ApplicationContext中处理事件。如果一个bean实现ApplicationListener，那么每次ApplicationEvent被发布到ApplicationContext上，那么bean会被通知</li><li>spring提供了以下标准事件</li></ul><table><thead><tr><th>序号</th><th>Spring内置事件&amp;描述</th></tr></thead><tbody><tr><td>1</td><td><strong>ContextRefreshedEvent</strong> ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在 ConfigurableApplicationContext 接口中使用 refresh() 方法来发生</td></tr><tr><td>2</td><td><strong>ContextStartedEvent</strong> 当使用 ConfigurableApplicationContext 接口中的 start() 方法启动 ApplicationContext 时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</td></tr><tr><td>3</td><td><strong>ContextStoppedEvent</strong> 当使用 ConfigurableApplicationContext 接口中的 stop() 方法停止 ApplicationContext 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作。</td></tr><tr><td>4</td><td><strong>ContextClosedEvent</strong> 当使用 ConfigurableApplicationContext 接口中的 close() 方法关闭 ApplicationContext 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启。</td></tr><tr><td>5</td><td><strong>RequestHandledEvent</strong> 这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务</td></tr></tbody></table><ul><li>由于spring的事件处理是单线程的，所以如果一个事件被发布，直至并且除非所有的接收者都得到消息，该进程被阻塞并且流程将不会继续</li></ul><h3 id="监听上下文"><a class="markdownIt-Anchor" href="#监听上下文"></a> 监听上下文</h3><ul><li>为了监听上下文事件，一个 bean 应该实现只有一个方法 <strong>onApplicationEvent</strong>() 的 <strong>ApplicationListener</strong>接口。因此，我们写一个例子来看看事件是如何传播的，以及如何可以用代码来执行基于某些事件所需的任务。</li></ul><h3 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例</h3><pre><code class="highlight plaintext">package com.tutorialspoint;public class HelloWorld &#123;   private String message;   public void setMessage(String message)&#123;      this.message  = message;   &#125;   public void getMessage()&#123;      System.out.println(&quot;Your Message : &quot; + message);   &#125;&#125;</code></pre><ul><li>CStartEventHandler.java</li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;import org.springframework.context.ApplicationListener;import org.springframework.context.event.ContextStartedEvent;public class CStartEventHandler  implements ApplicationListener&lt;ContextStartedEvent&gt;&#123;   public void onApplicationEvent(ContextStartedEvent event) &#123;      System.out.println(&quot;ContextStartedEvent Received&quot;);   &#125;&#125;</code></pre><ul><li>CStopEvnetHandler.java</li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;import org.springframework.context.ApplicationListener;import org.springframework.context.event.ContextStoppedEvent;public class CStopEventHandler  implements ApplicationListener&lt;ContextStoppedEvent&gt;&#123;   public void onApplicationEvent(ContextStoppedEvent event) &#123;      System.out.println(&quot;ContextStoppedEvent Received&quot;);   &#125;&#125;</code></pre><ul><li>MainApp.java</li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123;   public static void main(String[] args) &#123;      ConfigurableApplicationContext context =       new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;);      // Let us raise a start event.      context.start();      HelloWorld obj = (HelloWorld) context.getBean(&quot;helloWorld&quot;);      obj.getMessage();      // Let us raise a stop event.      context.stop();   &#125;&#125;</code></pre><ul><li>Beans.xml</li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;   &lt;bean id=&quot;helloWorld&quot; class=&quot;com.tutorialspoint.HelloWorld&quot;&gt;      &lt;property name=&quot;message&quot; value=&quot;Hello World!&quot;/&gt;   &lt;/bean&gt;   &lt;bean id=&quot;cStartEventHandler&quot;          class=&quot;com.tutorialspoint.CStartEventHandler&quot;/&gt;   &lt;bean id=&quot;cStopEventHandler&quot;          class=&quot;com.tutorialspoint.CStopEventHandler&quot;/&gt;&lt;/beans&gt;</code></pre><ul><li>运行结果</li></ul><pre><code class="highlight plaintext">ContextStartedEvent ReceivedYour Message : Hello World!ContextStoppedEvent Received</code></pre><h4 id="spring中的自定义事件"><a class="markdownIt-Anchor" href="#spring中的自定义事件"></a> Spring中的自定义事件</h4><ul><li>CustomEvent.java -先定义事件<ul><li>通过继承ApplicationEvent,创建一个事件类 CustomEvent。这个类必须定义一个默认的构造函数，它应该从 ApplicationEvent 类中继承的构造函数</li></ul></li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;import org.springframework.context.ApplicationEvent;public class CustomEvent extends ApplicationEvent&#123;    public CustomEvent(Object source) &#123;      super(source);   &#125;   public String toString()&#123;      return &quot;My Custom Event&quot;;   &#125;&#125;</code></pre><ul><li>CustomEventPublisher.java -事件的发行者<ul><li>一旦定义事件类，你可以从任何类中发布它，假定 EventClassPublisher 实现了 ApplicationEventPublisherAware。你还需要在 XML 配置文件中声明这个类作为一个 bean，之所以容器可以识别 bean 作为事件发布者，是因为它实现了 ApplicationEventPublisherAware 接口</li></ul></li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;import org.springframework.context.ApplicationEventPublisher;import org.springframework.context.ApplicationEventPublisherAware;public class CustomEventPublisher    implements ApplicationEventPublisherAware &#123;   private ApplicationEventPublisher publisher;   public void setApplicationEventPublisher              (ApplicationEventPublisher publisher)&#123;      this.publisher = publisher;   &#125;   public void publish() &#123;      CustomEvent ce = new CustomEvent(this);      publisher.publishEvent(ce);   &#125;&#125;</code></pre><ul><li>CustomEventHandler.java --事件处理者<ul><li>发布的事件可以在一个类中被处理，假定 EventClassHandler 实现了 ApplicationListener 接口，而且实现了自定义事件的 onApplicationEvent 方法</li></ul></li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;import org.springframework.context.ApplicationListener;public class CustomEventHandler    implements ApplicationListener&lt;CustomEvent&gt;&#123;   public void onApplicationEvent(CustomEvent event) &#123;      System.out.println(event.toString());   &#125;&#125;</code></pre><ul><li>MainApp.java</li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123;   public static void main(String[] args) &#123;      ConfigurableApplicationContext context =       new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;);          CustomEventPublisher cvp =       (CustomEventPublisher) context.getBean(&quot;customEventPublisher&quot;);      cvp.publish();        cvp.publish();   &#125;&#125;</code></pre><ul><li>Beans.xml</li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;   &lt;bean id=&quot;customEventHandler&quot;       class=&quot;com.tutorialspoint.CustomEventHandler&quot;/&gt;   &lt;bean id=&quot;customEventPublisher&quot;       class=&quot;com.tutorialspoint.CustomEventPublisher&quot;/&gt;&lt;/beans&gt;</code></pre><ul><li>输出</li></ul><pre><code class="highlight plaintext">My Custom EventMy Custom Event</code></pre>]]>
    </content>
    <id>http://example.com/2023/03/05/Spring/</id>
    <link href="http://example.com/2023/03/05/Spring/"/>
    <published>2023-03-05T04:00:00.000Z</published>
    <summary>Spring是一个开源的轻量级的应用开发框架，其目的是用于简化企业级应用程序开发，Spring提供的IOC和AOP应用，可以将组建的耦合度降至最低，即解耦，便于系统日后的维护和升级</summary>
    <title>Spring</title>
    <updated>2026-02-26T09:17:16.655Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Spark" scheme="http://example.com/tags/Spark/"/>
    <content>
      <![CDATA[<h1 id="spark"><a class="markdownIt-Anchor" href="#spark"></a> Spark</h1><h2 id="spark是什么"><a class="markdownIt-Anchor" href="#spark是什么"></a> Spark是什么</h2><p>Spark 是一个开源的大数据处理引擎，它提供了一整套开发 API，包括流计算和机器学习。它支持批处理和流处理。Spark 的一个显著特点是它能够在内存中进行迭代计算，从而加快数据处理速度。</p><h2 id="orc文件处理"><a class="markdownIt-Anchor" href="#orc文件处理"></a> Orc文件处理</h2><p>Spark脱敏Orc文件代码示例：</p><pre><code class="highlight java"><span class="keyword">import</span> com.suninfo.adm.duplicating.RandomWrapper;<span class="keyword">import</span> com.suninfo.adm.functions.GenerateCompanyName;<span class="keyword">import</span> com.suninfo.adm.functions.GenerateIPV4Address;<span class="keyword">import</span> org.apache.hadoop.conf.Configuration;<span class="keyword">import</span> org.apache.hadoop.fs.Path;<span class="keyword">import</span> org.apache.hadoop.security.UserGroupInformation;<span class="keyword">import</span> org.apache.hadoop.security.authentication.util.KerberosName;<span class="keyword">import</span> org.apache.spark.sql.SparkSession;<span class="keyword">import</span> org.apache.spark.sql.Dataset;<span class="keyword">import</span> org.apache.spark.sql.Row;<span class="keyword">import</span> org.apache.spark.sql.api.java.UDF1;<span class="keyword">import</span> org.apache.spark.sql.types.DataTypes;<span class="keyword">import</span> org.apache.spark.sql.types.StringType;<span class="keyword">import</span> org.apache.spark.sql.types.StructType;<span class="keyword">import</span> org.apache.spark.util.LongAccumulator;<span class="keyword">import</span> java.util.*;<span class="keyword">import</span> <span class="keyword">static</span> org.apache.spark.sql.functions.*;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalOrcProcessor</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">LongAccumulator</span> <span class="variable">processedRecordsAccumulator</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">// 使用懒加载Holder模式确保线程安全且高效的初始化</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DataMaskingHolder</span> &#123;        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">GenerateCompanyName</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> createDataMasking();        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">GenerateIPV4Address</span> <span class="variable">INSTANCEIMV4</span> <span class="operator">=</span> createDataMaskingIpv4();        <span class="keyword">private</span> <span class="keyword">static</span> GenerateCompanyName <span class="title function_">createDataMasking</span><span class="params">()</span> &#123;            <span class="keyword">try</span> &#123;                <span class="type">GenerateCompanyName</span> <span class="variable">masking</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenerateCompanyName</span>();                masking.parse(<span class="string">&quot;&#123;\n&quot;</span> +                        <span class="string">&quot;  \&quot;truncationLen\&quot;: 1,\n&quot;</span> +                        <span class="string">&quot;  \&quot;nameType\&quot;: 9\n&quot;</span> +                        <span class="string">&quot;&#125;&quot;</span>, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">RandomWrapper</span>(<span class="number">1</span>));                <span class="keyword">return</span> masking;            &#125; <span class="keyword">catch</span> (Exception e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failed to initialize DataMasking&quot;</span>, e);            &#125;        &#125;        <span class="keyword">private</span> <span class="keyword">static</span> GenerateIPV4Address <span class="title function_">createDataMaskingIpv4</span><span class="params">()</span> &#123;            <span class="keyword">try</span> &#123;                <span class="type">GenerateIPV4Address</span> <span class="variable">masking</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenerateIPV4Address</span>();                masking.parse(<span class="string">&quot;&#123;\n&quot;</span> +                        <span class="string">&quot;  \&quot;truncationLen\&quot;: 1,\n&quot;</span> +                        <span class="string">&quot;  \&quot;nameType\&quot;: 9\n&quot;</span> +                        <span class="string">&quot;&#125;&quot;</span>, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">RandomWrapper</span>(<span class="number">1</span>));                <span class="keyword">return</span> masking;            &#125; <span class="keyword">catch</span> (Exception e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failed to initialize DataMasking&quot;</span>, e);            &#125;        &#125;    &#125;    <span class="comment">// 优化的UDF，避免每行检查初始化</span>    <span class="keyword">private</span> <span class="keyword">static</span> UDF1&lt;String, String&gt; optimizedMaskUDF = value -&gt; &#123;        <span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;        <span class="keyword">return</span> DataMaskingHolder.INSTANCE.generateMaskedRow(value);    &#125;;    <span class="keyword">private</span> <span class="keyword">static</span> UDF1&lt;String, String&gt; optimizedMaskIpv4UDF = value -&gt; &#123;        <span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;        <span class="keyword">return</span> DataMaskingHolder.INSTANCEIMV4.generateMaskedRow(value);    &#125;;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;        <span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();        <span class="comment">// 明确设置版本相关的配置</span>        conf.set(<span class="string">&quot;dfs.client.use.datanode.hostname&quot;</span>, <span class="string">&quot;true&quot;</span>);        conf.set(<span class="string">&quot;hadoop.security.authentication&quot;</span>, <span class="string">&quot;simple&quot;</span>);        conf.set(<span class="string">&quot;fs.hdfs.impl&quot;</span>, <span class="string">&quot;org.apache.hadoop.hdfs.DistributedFileSystem&quot;</span>);        conf.set(<span class="string">&quot;fs.hdfs.impl.disable.cache&quot;</span>,<span class="string">&quot;true&quot;</span>);        conf.addResource(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;F:\\Administrator\\Desktop\\hadoop\\hadoop201\\hdfs-site.xml&quot;</span>));        conf.set(<span class="string">&quot;hadoop.security.authentication&quot;</span>, <span class="string">&quot;Kerberos&quot;</span>);        UserGroupInformation.reset();        <span class="type">String</span> <span class="variable">kerb5FileName</span> <span class="operator">=</span> <span class="string">&quot;F:\\Administrator\\Desktop\\hadoop\\hadoop201\\krb5.conf&quot;</span>;        System.setProperty(<span class="string">&quot;java.security.krb5.conf&quot;</span>, kerb5FileName);        <span class="comment">//System.setProperty(&quot;javax.security.auth.useSubjectCredsOnly&quot;, &quot;false&quot;);</span>        sun.security.krb5.Config.refresh();        conf.set(<span class="string">&quot;hadoop.security.authentication&quot;</span>, <span class="string">&quot;Kerberos&quot;</span>);        <span class="comment">//conf.set(&quot;dfs.data.transfer.protection&quot;, hadoopConnectionInfo.getKerberosProtection());</span>        UserGroupInformation.setConfiguration(conf);        KerberosName.resetDefaultRealm();        <span class="type">String</span> <span class="variable">keytabFileName</span> <span class="operator">=</span> <span class="string">&quot;F:\\Administrator\\Desktop\\hadoop\\hadoop201\\hdfs.keytab&quot;</span>;        UserGroupInformation.loginUserFromKeytab(<span class="string">&quot;hdfs/hadoop1&quot;</span>, keytabFileName);        <span class="type">long</span> <span class="variable">currentTimeMillis</span> <span class="operator">=</span> System.currentTimeMillis();<span class="comment">//        String inputPath = args[0];</span><span class="comment">//        String outputPath = args[1];</span><span class="comment">//        int parallelism = Integer.parseInt(args[2]);</span>        <span class="type">String</span> <span class="variable">inputPath</span> <span class="operator">=</span> <span class="string">&quot;hdfs://192.168.218.201:9000/user/hive/warehouse/user_produce_big_orc_p/&quot;</span>;        <span class="type">String</span> <span class="variable">outputPath</span> <span class="operator">=</span> <span class="string">&quot;hdfs://192.168.218.201:9000/tmp/test/&quot;</span>;        <span class="type">int</span> <span class="variable">parallelism</span> <span class="operator">=</span> <span class="number">16</span>;        System.setProperty(<span class="string">&quot;HADOOP_USER_NAME&quot;</span>, <span class="string">&quot;root&quot;</span>);        <span class="type">int</span> <span class="variable">availableProcessors</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();        HashMap&lt;String, Object&gt; confHashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = conf.iterator();        <span class="keyword">while</span> (iterator.hasNext()) &#123;            Map.Entry&lt;String, String&gt; next = iterator.next();            confHashMap.put(next.getKey(), next.getValue());        &#125;        <span class="type">SparkSession</span> <span class="variable">spark</span> <span class="operator">=</span> SparkSession.builder()                .appName(<span class="string">&quot;Local ORC Processor Optimized&quot;</span>)                .master(<span class="string">&quot;local[&quot;</span> + availableProcessors + <span class="string">&quot;]&quot;</span>)                .config(<span class="string">&quot;spark.hadoop.fs.defaultFS&quot;</span>, <span class="string">&quot;hdfs://Hadoop1:9000&quot;</span>)                .config(<span class="string">&quot;spark.driver.memory&quot;</span>, getOptimalMemory())                .config(<span class="string">&quot;spark.sql.adaptive.enabled&quot;</span>, <span class="string">&quot;true&quot;</span>)                .config(<span class="string">&quot;spark.default.parallelism&quot;</span>, String.valueOf(parallelism))                .config(<span class="string">&quot;spark.sql.shuffle.partitions&quot;</span>, String.valueOf(parallelism))                .config(<span class="string">&quot;spark.serializer&quot;</span>, <span class="string">&quot;org.apache.spark.serializer.KryoSerializer&quot;</span>)                .config(<span class="string">&quot;spark.hadoop.hadoop.security.authentication&quot;</span>, <span class="string">&quot;kerberos&quot;</span>)                .config(<span class="string">&quot;hadoop.security.authentication&quot;</span>, <span class="string">&quot;kerberos&quot;</span>)                .config(<span class="string">&quot;spark.kerberos.keytab&quot;</span>, keytabFileName)                .config(<span class="string">&quot;spark.kerberos.principal&quot;</span>, <span class="string">&quot;hdfs/hadoop1&quot;</span>)                .config(confHashMap)                .getOrCreate();        <span class="comment">// 创建累加器</span>        processedRecordsAccumulator = spark.sparkContext().longAccumulator(<span class="string">&quot;processedRecords&quot;</span>);        <span class="keyword">try</span> &#123;            <span class="comment">// 修改UDF，处理时更新累加器</span>            UDF1&lt;String, String&gt; countingMaskUDF = value -&gt; &#123;                <span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;                processedRecordsAccumulator.add(<span class="number">1</span>);                <span class="keyword">return</span> value;            &#125;;            <span class="comment">// 注册UDF</span>            spark.udf().register(<span class="string">&quot;countingMaskUDF&quot;</span>, countingMaskUDF, DataTypes.StringType);            spark.udf().register(<span class="string">&quot;optimizedMaskUDF&quot;</span>, optimizedMaskUDF, DataTypes.StringType);            spark.udf().register(<span class="string">&quot;optimizedMaskIpv4UDF&quot;</span>, optimizedMaskIpv4UDF, DataTypes.StringType);            <span class="comment">// 读取ORC文件</span>            Dataset&lt;Row&gt; df = spark.read()                    .format(<span class="string">&quot;orc&quot;</span>)                    .load(inputPath);            System.out.println(<span class="string">&quot;原始数据分区数: &quot;</span> + df.rdd().getNumPartitions());            System.out.println(<span class="string">&quot;设置并行度: &quot;</span> + parallelism);            <span class="comment">// 优化分区策略</span>            Dataset&lt;Row&gt; repartitionedDf = optimizePartitioning(df, parallelism);            <span class="comment">// 批量处理列，减少UDF调用次数</span>            Dataset&lt;Row&gt; processedDF = processColumnsBatch(repartitionedDf);            <span class="comment">// 优化写入</span>            processedDF.write()                    .format(<span class="string">&quot;orc&quot;</span>)                    .option(<span class="string">&quot;compression&quot;</span>, <span class="string">&quot;snappy&quot;</span>)                    .mode(<span class="string">&quot;overwrite&quot;</span>)                    .save(outputPath);            System.out.println(<span class="string">&quot;处理完成！输出路径: &quot;</span> + outputPath);            System.out.println(<span class="string">&quot;耗时: &quot;</span> + (System.currentTimeMillis() - currentTimeMillis) / <span class="number">1000</span> + <span class="string">&quot;秒&quot;</span>);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="keyword">finally</span> &#123;            spark.stop();        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 优化分区策略</span><span class="comment">     */</span>    <span class="keyword">private</span> <span class="keyword">static</span> Dataset&lt;Row&gt; <span class="title function_">optimizePartitioning</span><span class="params">(Dataset&lt;Row&gt; df, <span class="type">int</span> parallelism)</span> &#123;        <span class="type">long</span> <span class="variable">dataSize</span> <span class="operator">=</span> df.count();        System.out.println(<span class="string">&quot;数据量: &quot;</span> + dataSize);        <span class="comment">// 根据数据量动态调整分区数</span>        <span class="type">int</span> <span class="variable">optimalPartitions</span> <span class="operator">=</span> calculateOptimalPartitions(dataSize, parallelism);        <span class="keyword">if</span> (df.rdd().getNumPartitions() &lt; optimalPartitions) &#123;            Dataset&lt;Row&gt; repartitioned = df.repartition(optimalPartitions);            System.out.println(<span class="string">&quot;重新分区到: &quot;</span> + optimalPartitions + <span class="string">&quot; 个分区&quot;</span>);            <span class="keyword">return</span> repartitioned;        &#125;        <span class="keyword">return</span> df;    &#125;    <span class="comment">/**</span><span class="comment">     * 根据数据量计算最优分区数</span><span class="comment">     */</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateOptimalPartitions</span><span class="params">(<span class="type">long</span> dataSize, <span class="type">int</span> baseParallelism)</span> &#123;        <span class="comment">// 每个分区处理约10万行数据</span>        <span class="type">long</span> <span class="variable">rowsPerPartition</span> <span class="operator">=</span> <span class="number">100000L</span>;        <span class="type">int</span> <span class="variable">calculatedPartitions</span> <span class="operator">=</span> (<span class="type">int</span>) Math.max(<span class="number">1</span>, dataSize / rowsPerPartition);        <span class="keyword">return</span> Math.min(calculatedPartitions, baseParallelism * <span class="number">2</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 批量处理列，优化性能</span><span class="comment">     */</span>    <span class="keyword">private</span> <span class="keyword">static</span> Dataset&lt;Row&gt; <span class="title function_">processColumnsBatch</span><span class="params">(Dataset&lt;Row&gt; df)</span> &#123;        <span class="type">StructType</span> <span class="variable">schema</span> <span class="operator">=</span> df.schema();        String[] columns = df.columns();        System.out.println(<span class="string">&quot;处理列数: &quot;</span> + columns.length);        <span class="comment">// 收集所有需要处理的String列</span>        List&lt;String&gt; stringColumns = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        <span class="keyword">for</span> (String column : columns) &#123;            <span class="keyword">if</span> (schema.apply(column).dataType() <span class="keyword">instanceof</span> StringType) &#123;                stringColumns.add(column);            &#125;        &#125;        System.out.println(<span class="string">&quot;找到String类型列数: &quot;</span> + stringColumns.size());        <span class="comment">// 如果不需要处理，直接返回</span>        <span class="keyword">if</span> (stringColumns.isEmpty()) &#123;            <span class="keyword">return</span> df;        &#125;        <span class="comment">// 批量构建处理表达式</span>        Dataset&lt;Row&gt; processedDF = df;<span class="comment">//        for (String column : stringColumns) &#123;</span><span class="comment">//            // 使用SQL表达式而不是callUDF，性能更好</span><span class="comment">//            processedDF = processedDF.withColumn(column,</span><span class="comment">//                    expr(&quot;concat(&quot; + column + &quot;, optimizedMaskUDF(&quot; + column + &quot;), &#x27;*&#x27;)&quot;));</span><span class="comment">//        &#125;</span>        processedDF = processedDF.withColumn(<span class="string">&quot;company&quot;</span>,callUDF(<span class="string">&quot;countingMaskUDF&quot;</span>, col(<span class="string">&quot;company&quot;</span>))).withColumn(<span class="string">&quot;company&quot;</span>,                    expr(<span class="string">&quot;concat(company,&#x27;|&#x27;, optimizedMaskUDF(company), &#x27;**&#x27;)&quot;</span>)).withColumn(<span class="string">&quot;ipv4&quot;</span>,expr(<span class="string">&quot;concat(ipv4,&#x27;|&#x27;, optimizedMaskIpv4UDF(ipv4), &#x27;**&#x27;)&quot;</span>));        <span class="keyword">return</span> processedDF;    &#125;<span class="comment">//    /**</span><span class="comment">//     * 备选方案：使用mapPartitions进行批量处理（性能更好）</span><span class="comment">//     */</span><span class="comment">//    private static Dataset&lt;Row&gt; processWithMapPartitions(Dataset&lt;Row&gt; df) &#123;</span><span class="comment">//        // 只有在UDF处理逻辑复杂且数据量大时使用</span><span class="comment">//        return df.mapPartitions(partition -&gt; &#123;</span><span class="comment">//            // 在分区内初始化一次UDF资源</span><span class="comment">//            GenerateCompanyName localMasking = DataMaskingHolder.INSTANCE;</span><span class="comment">//</span><span class="comment">//            List&lt;Row&gt; result = new ArrayList&lt;&gt;();</span><span class="comment">//            while (partition.hasNext()) &#123;</span><span class="comment">//                Row originalRow = partition.next();</span><span class="comment">//                Object[] newValues = new Object[originalRow.size()];</span><span class="comment">//</span><span class="comment">//                for (int i = 0; i &lt; originalRow.size(); i++) &#123;</span><span class="comment">//                    Object value = originalRow.get(i);</span><span class="comment">//                    if (value instanceof String) &#123;</span><span class="comment">//                        String masked = localMasking.generateMaskedRow((String) value);</span><span class="comment">//                        newValues[i] = value + masked + &quot;*&quot;;</span><span class="comment">//                    &#125; else &#123;</span><span class="comment">//                        newValues[i] = value;</span><span class="comment">//                    &#125;</span><span class="comment">//                &#125;</span><span class="comment">//                result.add(RowFactory.create(newValues));</span><span class="comment">//            &#125;</span><span class="comment">//            return result.iterator();</span><span class="comment">//        &#125;, df.encoder());</span><span class="comment">//    &#125;</span>    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getOptimalMemory</span><span class="params">()</span> &#123;        <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / (<span class="number">1024</span> * <span class="number">1024</span>);        <span class="type">long</span> <span class="variable">optimalMemory</span> <span class="operator">=</span> Math.min(maxMemory * <span class="number">3</span> / <span class="number">4</span>, <span class="number">8192</span>);        System.out.println(<span class="string">&quot;设置Spark内存: &quot;</span> + optimalMemory + <span class="string">&quot;MB&quot;</span>);        <span class="keyword">return</span> optimalMemory + <span class="string">&quot;m&quot;</span>;    &#125;&#125;</code></pre><h2 id="parquet文件处理"><a class="markdownIt-Anchor" href="#parquet文件处理"></a> parquet文件处理</h2><p>spark脱敏parquet文件代码示例：</p><pre><code class="highlight java"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;<span class="keyword">import</span> org.apache.hadoop.fs.Path;<span class="keyword">import</span> org.apache.hadoop.security.UserGroupInformation;<span class="keyword">import</span> org.apache.hadoop.security.authentication.util.KerberosName;<span class="keyword">import</span> org.apache.spark.SparkConf;<span class="keyword">import</span> org.apache.spark.sql.Dataset;<span class="keyword">import</span> org.apache.spark.sql.Row;<span class="keyword">import</span> org.apache.spark.sql.SparkSession;<span class="keyword">import</span> org.w3c.dom.Document;<span class="keyword">import</span> org.w3c.dom.Node;<span class="keyword">import</span> org.w3c.dom.NodeList;<span class="keyword">import</span> org.w3c.dom.*;<span class="keyword">import</span> java.util.*;<span class="keyword">import</span> javax.xml.parsers.DocumentBuilder;<span class="keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;<span class="keyword">import</span> java.security.PrivilegedAction;<span class="keyword">import</span> java.util.HashMap;<span class="keyword">import</span> java.util.Iterator;<span class="keyword">import</span> java.util.Map;<span class="keyword">import</span> <span class="keyword">static</span> org.apache.spark.sql.functions.*;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SparkParquet</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;<span class="comment">//        String inputPath = args[0];</span><span class="comment">//        String outputPath = args[1];</span><span class="comment">//        String kerberosSrcPath = args[2];</span><span class="comment">//        String kerberosDestPath = args[3];</span><span class="comment">//</span>        <span class="type">String</span> <span class="variable">inputPath</span> <span class="operator">=</span> <span class="string">&quot;hdfs://192.168.218.201:9000/user/hive/warehouse/user_produce_big_parquet_p/partitioned_id=1/000012_0&quot;</span>;        <span class="type">String</span> <span class="variable">outputPath</span> <span class="operator">=</span> <span class="string">&quot;hdfs://192.168.218.201:9000/tmp/test_parquet/&quot;</span>;        <span class="type">String</span> <span class="variable">kerberosSrcPath</span> <span class="operator">=</span> <span class="string">&quot;F:\\Administrator\\Desktop\\hadoop\\hadoop201\\&quot;</span>;        <span class="type">String</span> <span class="variable">kerberosDestPath</span> <span class="operator">=</span> <span class="string">&quot;F:\\Administrator\\Desktop\\hadoop\\hadoop202\\&quot;</span>;        <span class="type">Configuration</span> <span class="variable">srcConf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();        <span class="comment">// 明确设置版本相关的配置</span>        srcConf.set(<span class="string">&quot;dfs.client.use.datanode.hostname&quot;</span>, <span class="string">&quot;true&quot;</span>);        srcConf.set(<span class="string">&quot;fs.hdfs.impl&quot;</span>, <span class="string">&quot;org.apache.hadoop.hdfs.DistributedFileSystem&quot;</span>);        srcConf.addResource(<span class="keyword">new</span> <span class="title class_">Path</span>(kerberosSrcPath+<span class="string">&quot;/hdfs-site.xml&quot;</span>));        srcConf.set(<span class="string">&quot;hadoop.security.authentication&quot;</span>, <span class="string">&quot;Kerberos&quot;</span>);        UserGroupInformation.reset();        <span class="type">String</span> <span class="variable">kerb5FileName</span> <span class="operator">=</span> kerberosSrcPath+<span class="string">&quot;/krb5.conf&quot;</span>;        System.setProperty(<span class="string">&quot;java.security.krb5.conf&quot;</span>, kerb5FileName);        sun.security.krb5.Config.refresh();        srcConf.set(<span class="string">&quot;hadoop.security.authentication&quot;</span>, <span class="string">&quot;Kerberos&quot;</span>);        UserGroupInformation.setConfiguration(srcConf);        KerberosName.resetDefaultRealm();        <span class="type">String</span> <span class="variable">keytabFileName</span> <span class="operator">=</span> kerberosSrcPath + <span class="string">&quot;/hdfs.keytab&quot;</span>;        Map&lt;String, String&gt; confMap = parseCoreSiteXml();        <span class="type">SparkConf</span> <span class="variable">sparkConf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SparkConf</span>();        confMap.forEach((k,v)-&gt;&#123;            sparkConf.set(<span class="string">&quot;spark.hadoop.&quot;</span>+k, v);        &#125;);<span class="comment">//        UserGroupInformation.loginUserFromKeytab(&quot;hdfs/hadoop1&quot;, keytabFileName);</span>        <span class="type">UserGroupInformation</span> <span class="variable">dstUgi</span> <span class="operator">=</span> UserGroupInformation.loginUserFromKeytabAndReturnUGI(<span class="string">&quot;hdfs/hadoop1&quot;</span>, keytabFileName);        dstUgi.doAs((PrivilegedAction&lt;Void&gt;) () -&gt; &#123;            <span class="comment">// 创建SparkSession（本地模式）</span>            <span class="type">SparkSession</span> <span class="variable">spark</span> <span class="operator">=</span> SparkSession.builder()                    .config(sparkConf)                    .appName(<span class="string">&quot;Parquet Phone Masker&quot;</span>)                    .master(<span class="string">&quot;local[*]&quot;</span>)  <span class="comment">// 使用本地模式，[*]表示使用所有CPU核心</span>                    .config(<span class="string">&quot;spark.sql.parquet.compression.codec&quot;</span>, <span class="string">&quot;snappy&quot;</span>)  <span class="comment">// 压缩格式</span>                    .getOrCreate();            TreeMap&lt;String, String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();            Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = spark.sparkContext().hadoopConfiguration().iterator();            <span class="keyword">while</span> (iterator.hasNext()) &#123;                Map.Entry&lt;String, String&gt; next = iterator.next();                <span class="keyword">if</span>( next.getValue().contains(<span class="string">&quot;kerberos&quot;</span>))&#123;                    treeMap.put(next.getKey(), next.getValue());                    System.out.println(next.getKey()+<span class="string">&quot;  &quot;</span>+next.getValue());                &#125;            &#125;            <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> System.currentTimeMillis();            <span class="keyword">try</span> &#123;                <span class="comment">// 1. 读取Parquet文件</span>                System.out.println(<span class="string">&quot;正在读取Parquet文件: &quot;</span> + inputPath);                Dataset&lt;Row&gt; df = spark.read()                        .option(<span class="string">&quot;mergeSchema&quot;</span>, <span class="string">&quot;true&quot;</span>)                        .parquet(inputPath);                <span class="comment">// 显示数据结构和样本</span>                System.out.println(<span class="string">&quot;数据模式 (Schema):&quot;</span>);                df.printSchema();                <span class="comment">// 2. 检查phone列是否存在</span>                String[] columns = df.columns();                <span class="type">boolean</span> <span class="variable">hasPhoneColumn</span> <span class="operator">=</span> <span class="literal">false</span>;                <span class="keyword">for</span> (String column : columns) &#123;                    <span class="keyword">if</span> (column.equalsIgnoreCase(<span class="string">&quot;phone&quot;</span>)) &#123;                        hasPhoneColumn = <span class="literal">true</span>;                        <span class="keyword">break</span>;                    &#125;                &#125;                <span class="comment">// 3. 修改phone列为****</span>                Dataset&lt;Row&gt; maskedDf = df;                <span class="keyword">if</span> (hasPhoneColumn) &#123;                    <span class="comment">// 使用lit函数创建常量值&quot;****&quot;</span>                    maskedDf = df.withColumn(<span class="string">&quot;phone&quot;</span>, lit(<span class="string">&quot;****&quot;</span>));                    System.out.println(<span class="string">&quot;已将 &#x27;phone&#x27; 列替换为 &#x27;****&#x27;&quot;</span>);                &#125;                <span class="comment">// 4. 写入新的Parquet文件</span>                System.out.println(<span class="string">&quot;正在写入处理后的文件: &quot;</span> + outputPath);                maskedDf.write()                        .mode(<span class="string">&quot;overwrite&quot;</span>)  <span class="comment">// 如果文件已存在则覆盖</span>                        .parquet(outputPath);            &#125; <span class="keyword">catch</span> (Exception e) &#123;                System.err.println(<span class="string">&quot;处理过程中发生错误:&quot;</span>);                e.printStackTrace();            &#125; <span class="keyword">finally</span> &#123;                <span class="comment">// 关闭SparkSession</span>                spark.close();            &#125;            System.out.println(<span class="string">&quot;程序执行完成! 耗时：&quot;</span> + (System.currentTimeMillis() - l)/<span class="number">1000</span>);            <span class="keyword">return</span> <span class="literal">null</span>;        &#125;);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title function_">parseCoreSiteXml</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        Map&lt;String, String&gt; configMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();        <span class="comment">// 1. 创建解析器</span>        <span class="type">DocumentBuilderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();        <span class="type">DocumentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> factory.newDocumentBuilder();        <span class="comment">// 2. 解析XML文件</span>        <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> builder.parse(SparkParquet.class.getClassLoader().getResourceAsStream(<span class="string">&quot;core-site111.xml&quot;</span>));        doc.getDocumentElement().normalize();        <span class="comment">// 3. 获取所有property节点</span>        <span class="type">NodeList</span> <span class="variable">propertyList</span> <span class="operator">=</span> doc.getElementsByTagName(<span class="string">&quot;property&quot;</span>);        <span class="comment">// 4. 遍历每个property，提取name和value</span>        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; propertyList.getLength(); i++) &#123;            <span class="type">Node</span> <span class="variable">propertyNode</span> <span class="operator">=</span> propertyList.item(i);            <span class="keyword">if</span> (propertyNode.getNodeType() == Node.ELEMENT_NODE) &#123;                <span class="type">Element</span> <span class="variable">propertyElement</span> <span class="operator">=</span> (Element) propertyNode;                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> getTagValue(<span class="string">&quot;name&quot;</span>, propertyElement);                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> getTagValue(<span class="string">&quot;value&quot;</span>, propertyElement);                <span class="keyword">if</span> (name != <span class="literal">null</span> &amp;&amp; value != <span class="literal">null</span>) &#123;                    configMap.put(name, value);                &#125;            &#125;        &#125;        <span class="keyword">return</span> configMap;    &#125;    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getTagValue</span><span class="params">(String tag, Element element)</span> &#123;        <span class="type">NodeList</span> <span class="variable">nodeList</span> <span class="operator">=</span> element.getElementsByTagName(tag);        <span class="keyword">if</span> (nodeList.getLength() &gt; <span class="number">0</span>) &#123;            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nodeList.item(<span class="number">0</span>);            <span class="keyword">return</span> node.getTextContent();        &#125;        <span class="keyword">return</span> <span class="literal">null</span>;    &#125;&#125;</code></pre>]]>
    </content>
    <id>http://example.com/2023/02/25/Spark/</id>
    <link href="http://example.com/2023/02/25/Spark/"/>
    <published>2023-02-25T04:00:00.000Z</published>
    <summary>Spark 是一个开源的大数据处理引擎，它提供了一整套开发 API，包括流计算和机器学习。它支持批处理和流处理。Spark 的一个显著特点是它能够在内存中进行迭代计算，从而加快数据处理速度。</summary>
    <title>Spark</title>
    <updated>2026-02-27T03:03:56.964Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    <content>
      <![CDATA[<h1 id="redis"><a class="markdownIt-Anchor" href="#redis"></a> Redis</h1><p>[toc]</p><h2 id="redis下载安装"><a class="markdownIt-Anchor" href="#redis下载安装"></a> Redis下载安装</h2><h3 id="什么是redis"><a class="markdownIt-Anchor" href="#什么是redis"></a> 什么是Redis</h3><ul><li><strong>Redis</strong>是一个开源的使用ANSI <strong>C语言</strong>编写、支持网络、可基于内存亦可持久化的日志型、<strong>Key-Value</strong> <strong>内存数据库</strong></li><li>它提供了<strong>五种数据类型</strong>来存储，<strong>字符串类型，散列类型，列表类型，集合类型，有序集合类型</strong></li><li>换句话说，Redis就像是一个HashMap，不过不是在JVM中运行，而是以一个独立进程的形式运行。</li><li>一般说来，会被当作缓存使用。 因为它比数据库(mysql)快，所以常用的数据，可以考虑放在这里，这样就提高了性能。</li><li>redis是一种<strong>NoSQL</strong>数据库</li></ul><h3 id="什么是nosql"><a class="markdownIt-Anchor" href="#什么是nosql"></a> 什么是NoSQL?</h3><p>NoSQL，即Not-Only-SQL(不仅仅是SQL)，泛指非关系型的数据库</p><p>NoSQL数据库是为了解决<strong>高并发，高可用，高扩展，大数据存储</strong>问题而产生的数据库解决方案</p><p>NoSQL可以作为关系型数据库的良好补充，但是<strong>不能替代关系型数据库</strong></p><blockquote><p>关系型数据库指：数据结构是一种有行有列的数据库</p></blockquote><h3 id="nosql数据库分类"><a class="markdownIt-Anchor" href="#nosql数据库分类"></a> NoSQL数据库分类</h3><p><strong>key-value</strong>存储数据库</p><ul><li>相关产品：Tokyo Cabinet/Tyrant，Redis，Voldemort，Berkeley DB</li><li>典型应用：内容缓存，主要用于处理大量数据的高访问负载</li><li>数据模型：一系列键值对</li><li>优势：快速查询</li><li>劣势：存储的数据缺少结构化</li></ul><p><strong>列存储数据库</strong></p><ul><li>相关产品：Cassandra, HBase, Riak</li><li>典型应用：分布式的文件系统</li><li>数据模型：以列簇式存储，将同一列数据存在一起</li><li>优势：查找速度快，可扩展性强，更容易进行分布式扩展</li><li>劣势：功能相对局限</li></ul><p><strong>文档型数据库</strong></p><ul><li>相关产品：CouchDB、MongoDB</li><li>典型应用：Web应用（与Key-Value类似，Value是结构化的）</li><li>数据模型： 一系列键值对</li><li>优势：数据结构要求不严格</li><li>劣势：</li></ul><p><strong>图形(Graph)数据库</strong></p><ul><li>相关数据库：Neo4J、InfoGrid、Infinite Graph</li><li>典型应用：社交网络</li><li>数据模型：图结构</li><li>优势：利用图结构相关算法。</li><li>劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案</li></ul><h3 id="redis的应用场景"><a class="markdownIt-Anchor" href="#redis的应用场景"></a> Redis的应用场景</h3><ul><li><p>内存数据库（登录信息、购物车信息、用户浏览记录等）</p></li><li><p>缓存服务器（商品数据、广告数据等等）。（最多使用）</p></li><li><p>解决分布式集群架构中的session分离问题（session共享）。</p></li><li><p>任务队列。（秒杀、抢购、12306等等）</p></li><li><p>支持发布订阅的消息模式</p></li><li><p>应用排行榜。</p></li><li><p>网站访问统计。</p></li><li><p>数据过期处理（可以精确到毫秒）</p></li></ul><h2 id="redis运行"><a class="markdownIt-Anchor" href="#redis运行"></a> Redis运行</h2><h3 id="windows版本"><a class="markdownIt-Anchor" href="#windows版本"></a> Windows版本</h3><h4 id="下载安装"><a class="markdownIt-Anchor" href="#下载安装"></a> 下载安装</h4><p>下载Redis Windows版本解压即可</p><h4 id="运行服务端"><a class="markdownIt-Anchor" href="#运行服务端"></a> 运行服务端</h4><ul><li>通过cmd运行命令行</li></ul><pre><code class="highlight plaintext">d:cd softwarecd D:\software\redis-64.3.0.503redis-server.exe</code></pre><ul><li>这样就启动了服务端</li></ul><h4 id="运行客户端"><a class="markdownIt-Anchor" href="#运行客户端"></a> 运行客户端</h4><ul><li>cmd命令行运行</li></ul><pre><code class="highlight plaintext">d:cd softwarecd D:\software\redis-64.3.0.503redis-cli.exe</code></pre><ul><li>可以使用如图所示的命令行访问redis服务器</li></ul><h3 id="linux版本"><a class="markdownIt-Anchor" href="#linux版本"></a> Linux版本</h3><h4 id="redis下载"><a class="markdownIt-Anchor" href="#redis下载"></a> Redis下载</h4><ul><li>官网地址：<u><a href="http://redis.io/">http://redis.io/</a></u></li><li>中文官网地址：<u><a href="http://www.redis.cn/">http://www.redis.cn/</a></u></li><li>下载地址：<u><a href="http://download.redis.io/releases/">http://download.redis.io/releases/</a></u></li></ul><h4 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h4><ol><li><p>将redis-3.0.0.tar.gz包用ftp工具拷贝到服务器</p></li><li><p>安装c语言需要的GCC环境</p></li></ol><pre><code class="highlight shell">yum install gcc-c++</code></pre><ol start="3"><li>解压缩Redis源码压缩包</li></ol><pre><code class="highlight linux">tar -zxf redis-3.2.9.tar.gz</code></pre><ol start="4"><li>编译Redis源码，进入redis-3.0.0目录，执行编译命令</li></ol><pre><code class="highlight plaintext">mike</code></pre><ol start="5"><li>安装Redis，通过PREFIX指定安装目录(在redis-3.0.0目录)</li></ol><pre><code class="highlight plaintext">make install PREFIX=/usr/local/redis</code></pre><h4 id="redis启动"><a class="markdownIt-Anchor" href="#redis启动"></a> Redis启动</h4><p><strong>前端启动</strong></p><p>进入redis安装目录</p><pre><code class="highlight plaintext">./redis-server</code></pre><blockquote><p>启动缺点：客户端窗口<code>ctrl+c</code>关闭则redis-server程序结束，不推荐使用此方法</p></blockquote><p><strong>后端启动（守护进程启动）</strong></p><ol><li>拷贝redis-3.2.9/redis.conf配置文件到Redis安装目录的bin目录</li></ol><pre><code class="highlight plaintext">cp /home/leeboer/leeftp/redis-3.0.0/redis.conf /usr/local/redis/bin/</code></pre><ol start="2"><li>修改redis.conf，将daemonize由no改为yes</li></ol><pre><code class="highlight plaintext">vim redis.conf</code></pre><blockquote><p>进入vim编辑器，可以使用“/”键进行搜索</p></blockquote><ol start="3"><li><p>修改redis.conf中的61行代码，<code>bind 127.0.0.1</code> 改为 <code>bind &lt;redis实例所在机器的真实IP&gt;</code></p><ul><li>这里指定了ip后，就只有指定的ip可以访问redis</li></ul></li><li><p>执行命令</p></li></ol><pre><code class="highlight plaintext">./redis-server redis.conf</code></pre><p><strong>后端启动的关闭方式</strong></p><p>非正常关闭</p><pre><code class="highlight plaintext">kill 5586</code></pre><p>正常关闭</p><pre><code class="highlight plaintext">./redis-cli shutdown</code></pre><p><strong>其他命令</strong></p><pre><code class="highlight plaintext">redis-server ：启动redis服务redis-cli ：进入redis命令客户redis-benchmark： 性能测试的工具redis-check-aof ： aof文件进行检查的工具redis-check-dump ：  rdb文件进行检查的工具redis-sentinel ：  启动哨兵监控服务</code></pre><h3 id="简单运用"><a class="markdownIt-Anchor" href="#简单运用"></a> 简单运用</h3><ul><li>输入指令</li></ul><pre><code class="highlight plaintext">set hero gareenget hero</code></pre><ul><li>如图就实现了向服务器设置hero这个键值，并从服务器获取hero对应的值</li></ul><h2 id="redis客户端"><a class="markdownIt-Anchor" href="#redis客户端"></a> Redis客户端</h2><h3 id="自带命令行客户端"><a class="markdownIt-Anchor" href="#自带命令行客户端"></a> 自带命令行客户端</h3><p><strong>命令格式</strong></p><ul><li>-h ：redis服务器的ip地址</li><li>-p ：redis实例的端口号</li></ul><pre><code class="highlight plaintext">./redis-cli -h 127.0.0.1 -p 6379</code></pre><p><strong>修改redis.conf配置文件（解决IP绑定问题）</strong></p><p><code>bind 127.0.0.1</code>     绑定的IP才能访问redis服务器，注释掉该配置</p><p><code>protected-mode yes</code>  是否开启保护模式，由yes该为no</p><p><strong>默认方式</strong></p><p>如果不指定主机和端口也可以</p><ul><li>默认主机地址是127.0.0.1</li><li>默认端口是6379</li></ul><pre><code class="highlight plaintext">./redis-cli</code></pre><h3 id="图形客户端"><a class="markdownIt-Anchor" href="#图形客户端"></a> 图形客户端</h3><p>前提：需要安装图形界面管理器</p><h4 id="关闭防火墙命令"><a class="markdownIt-Anchor" href="#关闭防火墙命令"></a> 关闭防火墙命令</h4><p>永久关闭</p><pre><code class="highlight plaintext">chkconfig iptables off/on</code></pre><p>本次关闭</p><pre><code class="highlight plaintext">service iptables stop</code></pre><h4 id="多数据库支持"><a class="markdownIt-Anchor" href="#多数据库支持"></a> 多数据库支持</h4><p>默认一共是16个数据库，每个数据库之间是相互隔离（但是可以使用flushall一次清空所有的库）。数据库的数量是在redis.conf中配置的。</p><p>切换数据库使用命令：select 数据库编号（0-15）</p><pre><code class="highlight plaintext">例如：select 1</code></pre><h3 id="程序客户端java"><a class="markdownIt-Anchor" href="#程序客户端java"></a> 程序客户端（java）</h3><p>在实际工作中却需要用到Java代码才能访问，使用第三方jar包 ：Jedis就能方便地访问Redis的各种服务了</p><h4 id="jedis介绍"><a class="markdownIt-Anchor" href="#jedis介绍"></a> Jedis介绍</h4><p>Redis不仅使用命令客户端来操作，而且可以使用<strong>程序客户端</strong>操作</p><p>现在基本上主流的语言都有客户端支持，比如<strong>Java</strong>、C、C#、C++、php、Node.js、Go等。</p><p>在官方网站里列一些Java的客户端，有<strong>Jedis</strong>、Redisson、Jredis、JDBC-Redis、等其中官方推荐使用Jedis和Redisson。</p><p>在<strong>企业中用的最多的就是Jedis</strong>，下面我们就重点学习下Jedis。</p><p>Jedis同样也是托管在github上，地址：<u><a href="https://github.com/xetorthio/jedis">https://github.com/xetorthio/jedis</a></u></p><h4 id="添加jar包"><a class="markdownIt-Anchor" href="#添加jar包"></a> 添加jar包</h4><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h4 id="单实例连接"><a class="markdownIt-Anchor" href="#单实例连接"></a> 单实例连接</h4><p>注意事项：需要去设置redis服务器的防火墙策略（临时关闭、永久关闭、端口暴露）</p><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJedis</span><span class="params">()</span> &#123;<span class="comment">//创建一个Jedis的连接</span><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);<span class="comment">//执行redis命令</span>jedis.set(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;hello world&quot;</span>);<span class="comment">//从redis中取值</span><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;key1&quot;</span>);<span class="comment">//打印结果</span>System.out.println(result);<span class="comment">//关闭连接</span>jedis.close();&#125;</code></pre><blockquote><p>注意：使用Windows版本的redis，要保持redis 的cmd窗口一直打开，服务运行</p></blockquote><p><strong>详细使用案例</strong></p><pre><code class="highlight java"><span class="keyword">package</span> redis;<span class="keyword">import</span> java.util.HashMap;<span class="keyword">import</span> java.util.Iterator;<span class="keyword">import</span> java.util.List;<span class="keyword">import</span> java.util.Map; <span class="keyword">import</span> org.junit.Before;<span class="keyword">import</span> org.junit.Test; <span class="keyword">import</span> redis.clients.jedis.Jedis;<span class="keyword">import</span> redis.clients.jedis.JedisPool;  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRedisManyCommands</span> &#123;     JedisPool pool;     Jedis jedis;     <span class="meta">@Before</span>     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;            jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>);                &#125;      <span class="comment">/**</span><span class="comment">     * Redis存储初级的字符串</span><span class="comment">     * CRUD</span><span class="comment">     */</span>     <span class="meta">@Test</span>     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBasicString</span><span class="params">()</span>&#123;         <span class="comment">//-----添加数据---------- </span>        jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;meepo&quot;</span>);<span class="comment">//向key--&gt;name中放入了value--&gt;meepo </span>        System.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));<span class="comment">//执行结果：meepo </span>         <span class="comment">//-----修改数据----------- </span>        <span class="comment">//1、在原来基础上修改 </span>        jedis.append(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;dota&quot;</span>);   <span class="comment">//很直观，类似map 将dota append到已经有的value之后 </span>        System.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));<span class="comment">//执行结果:meepodota </span>         <span class="comment">//2、直接覆盖原来的数据 </span>        jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;poofu&quot;</span>);         System.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));<span class="comment">//执行结果：poofu </span>         <span class="comment">//删除key对应的记录 </span>        jedis.del(<span class="string">&quot;name&quot;</span>);         System.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));<span class="comment">//执行结果：null </span>         <span class="comment">/**</span><span class="comment">         * mset相当于</span><span class="comment">         * jedis.set(&quot;name&quot;,&quot;meepo&quot;);</span><span class="comment">         * jedis.set(&quot;dota&quot;,&quot;poofu&quot;);</span><span class="comment">         */</span>         jedis.mset(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;meepo&quot;</span>,<span class="string">&quot;dota&quot;</span>,<span class="string">&quot;poofu&quot;</span>);         System.out.println(jedis.mget(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;dota&quot;</span>));      &#125;      <span class="comment">/**</span><span class="comment">     * jedis操作Map</span><span class="comment">     */</span>     <span class="meta">@Test</span>     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMap</span><span class="params">()</span>&#123;         Map&lt;String,String&gt; user=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();         user.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;meepo&quot;</span>);         user.put(<span class="string">&quot;pwd&quot;</span>,<span class="string">&quot;password&quot;</span>);         jedis.hmset(<span class="string">&quot;user&quot;</span>,user);         <span class="comment">//取出user中的name，执行结果:[meepo]--&gt;注意结果是一个泛型的List </span>        <span class="comment">//第一个参数是存入redis中map对象的key，后面跟的是放入map中的对象的key，后面的key可以跟多个，是可变参数 </span>        List&lt;String&gt; rsmap = jedis.hmget(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;name&quot;</span>);         System.out.println(rsmap);          <span class="comment">//删除map中的某个键值 </span><span class="comment">//        jedis.hdel(&quot;user&quot;,&quot;pwd&quot;); </span>        System.out.println(jedis.hmget(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;pwd&quot;</span>)); <span class="comment">//因为删除了，所以返回的是null </span>        System.out.println(jedis.hlen(<span class="string">&quot;user&quot;</span>)); <span class="comment">//返回key为user的键中存放的值的个数1 </span>        System.out.println(jedis.exists(<span class="string">&quot;user&quot;</span>));<span class="comment">//是否存在key为user的记录 返回true </span>        System.out.println(jedis.hkeys(<span class="string">&quot;user&quot;</span>));<span class="comment">//返回map对象中的所有key  [pwd, name] </span>        System.out.println(jedis.hvals(<span class="string">&quot;user&quot;</span>));<span class="comment">//返回map对象中的所有value  [meepo, password] </span>         Iterator&lt;String&gt; iter=jedis.hkeys(<span class="string">&quot;user&quot;</span>).iterator();         <span class="keyword">while</span> (iter.hasNext())&#123;             <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();             System.out.println(key+<span class="string">&quot;:&quot;</span>+jedis.hmget(<span class="string">&quot;user&quot;</span>,key));         &#125;      &#125;      <span class="comment">/**</span><span class="comment">     * jedis操作List</span><span class="comment">     */</span>     <span class="meta">@Test</span>     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;         <span class="comment">//开始前，先移除所有的内容 </span>        jedis.del(<span class="string">&quot;java framework&quot;</span>);         <span class="comment">// 第一个是key，第二个是起始位置，第三个是结束位置，jedis.llen获取长度 -1表示取得所有</span>        System.out.println(jedis.lrange(<span class="string">&quot;java framework&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));        <span class="comment">//先向key java framework中存放三条数据 </span>       jedis.lpush(<span class="string">&quot;java framework&quot;</span>,<span class="string">&quot;spring&quot;</span>);        jedis.lpush(<span class="string">&quot;java framework&quot;</span>,<span class="string">&quot;struts&quot;</span>);        jedis.lpush(<span class="string">&quot;java framework&quot;</span>,<span class="string">&quot;hibernate&quot;</span>);        <span class="comment">//再取出所有数据jedis.lrange是按范围取出， </span>       <span class="comment">// 第一个是key，第二个是起始位置，第三个是结束位置，jedis.llen获取长度 -1表示取得所有 </span>       System.out.println(jedis.lrange(<span class="string">&quot;java framework&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));     &#125;      <span class="comment">/**</span><span class="comment">     * jedis操作Set</span><span class="comment">     */</span>     <span class="meta">@Test</span>     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span>&#123;         <span class="comment">//添加 </span>        jedis.sadd(<span class="string">&quot;sname&quot;</span>,<span class="string">&quot;meepo&quot;</span>);         jedis.sadd(<span class="string">&quot;sname&quot;</span>,<span class="string">&quot;dota&quot;</span>);         jedis.sadd(<span class="string">&quot;sname&quot;</span>,<span class="string">&quot;poofu&quot;</span>);         jedis.sadd(<span class="string">&quot;sname&quot;</span>,<span class="string">&quot;noname&quot;</span>);        <span class="comment">//移除noname </span>        jedis.srem(<span class="string">&quot;sname&quot;</span>,<span class="string">&quot;noname&quot;</span>);         System.out.println(jedis.smembers(<span class="string">&quot;sname&quot;</span>));<span class="comment">//获取所有加入的value </span>        System.out.println(jedis.sismember(<span class="string">&quot;sname&quot;</span>, <span class="string">&quot;meepo&quot;</span>));<span class="comment">//判断 meepo 是否是sname集合的元素 </span>        System.out.println(jedis.srandmember(<span class="string">&quot;sname&quot;</span>));         System.out.println(jedis.scard(<span class="string">&quot;sname&quot;</span>));<span class="comment">//返回集合的元素个数 </span>    &#125;      <span class="meta">@Test</span>     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;         <span class="comment">//keys中传入的可以用通配符 </span>        System.out.println(jedis.keys(<span class="string">&quot;*&quot;</span>)); <span class="comment">//返回当前库中所有的key  [sose, sanme, name, dota, foo, sname, java framework, user, braand] </span>        System.out.println(jedis.keys(<span class="string">&quot;*name&quot;</span>));<span class="comment">//返回的sname   [sname, name] </span>        System.out.println(jedis.del(<span class="string">&quot;sanmdde&quot;</span>));<span class="comment">//删除key为sanmdde的对象  删除成功返回1 删除失败（或者不存在）返回 0 </span>        System.out.println(jedis.ttl(<span class="string">&quot;sname&quot;</span>));<span class="comment">//返回给定key的有效时间，如果是-1则表示永远有效 </span>        jedis.setex(<span class="string">&quot;timekey&quot;</span>, <span class="number">10</span>, <span class="string">&quot;min&quot;</span>);<span class="comment">//通过此方法，可以指定key的存活（有效时间） 时间为秒 </span>        Thread.sleep(<span class="number">5000</span>);<span class="comment">//睡眠5秒后，剩余时间将为&lt;=5 </span>        System.out.println(jedis.ttl(<span class="string">&quot;timekey&quot;</span>));   <span class="comment">//输出结果为5 </span>        jedis.setex(<span class="string">&quot;timekey&quot;</span>, <span class="number">1</span>, <span class="string">&quot;min&quot;</span>);        <span class="comment">//设为1后，下面再看剩余时间就是1了 </span>        System.out.println(jedis.ttl(<span class="string">&quot;timekey&quot;</span>));  <span class="comment">//输出结果为1 </span>        System.out.println(jedis.exists(<span class="string">&quot;key&quot;</span>));<span class="comment">//检查key是否存在 </span>        System.out.println(jedis.rename(<span class="string">&quot;timekey&quot;</span>,<span class="string">&quot;time&quot;</span>));         System.out.println(jedis.get(<span class="string">&quot;timekey&quot;</span>));<span class="comment">//因为移除，返回为null </span>        System.out.println(jedis.get(<span class="string">&quot;time&quot;</span>)); <span class="comment">//因为将timekey 重命名为time 所以可以取得值 min </span>         <span class="comment">//jedis 排序 </span>        <span class="comment">//注意，此处的rpush和lpush是List的操作。是一个双向链表（但从表现来看的） </span>        jedis.del(<span class="string">&quot;a&quot;</span>);<span class="comment">//先清除数据，再加入数据进行测试 </span>        jedis.rpush(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;1&quot;</span>);         jedis.lpush(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;6&quot;</span>);         jedis.lpush(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;3&quot;</span>);         jedis.lpush(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;9&quot;</span>);         System.out.println(jedis.lrange(<span class="string">&quot;a&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));<span class="comment">// [9, 3, 6, 1] </span>        System.out.println(jedis.sort(<span class="string">&quot;a&quot;</span>)); <span class="comment">//[1, 3, 6, 9]  //输入排序后结果 </span>        System.out.println(jedis.lrange(<span class="string">&quot;a&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));      &#125; &#125;</code></pre><h4 id="连接池连接"><a class="markdownIt-Anchor" href="#连接池连接"></a> 连接池连接</h4><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJedisPool</span><span class="params">()</span> &#123;<span class="comment">//创建一连接池对象</span><span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);<span class="comment">//从连接池中获得连接</span><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource();<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;key1&quot;</span>) ;System.out.println(result);<span class="comment">//关闭连接</span>jedis.close();<span class="comment">//关闭连接池</span>jedisPool.close();&#125;</code></pre><h4 id="spring整合jedispool"><a class="markdownIt-Anchor" href="#spring整合jedispool"></a> Spring整合JedisPool</h4><p>添加spring和jedis相关jar包的jar包</p><p><strong>配置spring配置文件</strong></p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd </span></span><span class="string"><span class="tag">http://www.springframework.org/schema/mvc </span></span><span class="string"><span class="tag">http://www.springframework.org/schema/mvc/spring-mvc.xsd </span></span><span class="string"><span class="tag">http://www.springframework.org/schema/context </span></span><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd </span></span><span class="string"><span class="tag">http://www.springframework.org/schema/aop </span></span><span class="string"><span class="tag">http://www.springframework.org/schema/aop/spring-aop.xsd </span></span><span class="string"><span class="tag">http://www.springframework.org/schema/tx </span></span><span class="string"><span class="tag">http://www.springframework.org/schema/tx/spring-tx.xsd &quot;</span>&gt;</span><span class="comment">&lt;!-- 连接池配置 --&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisPoolConfig&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisPoolConfig&quot;</span>&gt;</span><span class="comment">&lt;!-- 最大连接数 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxTotal&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span> /&gt;</span><span class="comment">&lt;!-- 最大空闲连接数 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span><span class="comment">&lt;!-- 每次释放连接的最大数目 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;numTestsPerEvictionRun&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1024&quot;</span> /&gt;</span><span class="comment">&lt;!-- 释放连接的扫描间隔（毫秒） --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30000&quot;</span> /&gt;</span><span class="comment">&lt;!-- 连接最小空闲时间 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1800000&quot;</span> /&gt;</span><span class="comment">&lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;softMinEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span><span class="comment">&lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWaitMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1500&quot;</span> /&gt;</span><span class="comment">&lt;!-- 在获取连接的时候检查有效性, 默认false --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span><span class="comment">&lt;!-- 在空闲时检查有效性, 默认false --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span><span class="comment">&lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;blockWhenExhausted&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="comment">&lt;!-- redis单机 通过连接池 --&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisPool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisPool&quot;</span></span><span class="tag"><span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;poolConfig&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jedisPoolConfig&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;host&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.242.130&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;port&quot;</span> <span class="attr">value</span>=<span class="string">&quot;6379&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></code></pre><p>测试代码</p><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJedisPool</span><span class="params">()</span> &#123;<span class="type">JedisPool</span> <span class="variable">pool</span> <span class="operator">=</span> (JedisPool) applicationContext.getBean(<span class="string">&quot;jedisPool&quot;</span>);<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="keyword">try</span> &#123;jedis = pool.getResource();jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lisi&quot;</span>);<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);System.out.println(name);&#125; <span class="keyword">catch</span> (Exception ex) &#123;ex.printStackTrace();&#125; <span class="keyword">finally</span> &#123;<span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;<span class="comment">// 关闭连接</span>jedis.close();&#125;&#125;&#125;</code></pre><h2 id="redis数据类型"><a class="markdownIt-Anchor" href="#redis数据类型"></a> Redis数据类型</h2><p>官方命令大全网址：<u><a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></u></p><p>Redis中存储数据是通过<strong>key-value</strong>格式存储数据的，其中value可以定义五种数据类型：</p><ul><li><p><strong>String（字符类型）</strong></p></li><li><p><strong>Hash（散列类型）</strong></p></li><li><p><strong>List（列表类型）</strong></p></li><li><p><strong>Set（集合类型）</strong></p></li><li><p><strong>SortedSet（有序集合类型，简称zset）</strong></p></li></ul><blockquote><p>注意：在redis中的命令语句中，命令是忽略大小写的，而key是不忽略大小写的</p></blockquote><h3 id="string-字符串"><a class="markdownIt-Anchor" href="#string-字符串"></a> String 字符串</h3><table><thead><tr><th>代码</th><th>解释</th></tr></thead><tbody><tr><td><strong>SET key value</strong></td><td><strong>赋值</strong>，设置key=value</td></tr><tr><td><strong>GET key</strong></td><td><strong>取值</strong>，获得键key对应的值</td></tr><tr><td>GETRANGE key start end</td><td>得到字符串的子字符串存放在一个键</td></tr><tr><td><strong>GETSET key value</strong></td><td><strong>取值并赋值</strong>，设置键的字符串值，并返回旧值</td></tr><tr><td>GETBIT key offset</td><td>返回存储在键位值的字符串值的偏移</td></tr><tr><td><strong>MGET key1 [key2…]</strong></td><td><strong>同时获取多个键值</strong>，得到所有的给定键的值</td></tr><tr><td>SETBIT key offset value</td><td>设置或清除该位在存储在键的字符串值偏移</td></tr><tr><td>SETEX key seconds value</td><td>键到期时设置值</td></tr><tr><td><strong>SETNX key value</strong></td><td><strong>仅当不存在时赋值</strong>，设置键的值，只有当该键不存在，<strong>该命令可以实现分布式锁的功能</strong></td></tr><tr><td>SETRANGE key offset value</td><td>覆盖字符串的一部分从指定键的偏移</td></tr><tr><td><strong>STRLEN key</strong></td><td><strong>获取字符串长度</strong>，得到存储在键的值的长度</td></tr><tr><td><strong>MSET key value [key value…]</strong></td><td><strong>同时设置多个键值</strong>设置多个键和多个值</td></tr><tr><td>MSETNX key value [key value…]</td><td>设置多个键多个值，只有在当没有按键的存在时</td></tr><tr><td>PSETEX key milliseconds value</td><td>设置键的毫秒值和到期时间</td></tr><tr><td><strong>INCR key</strong></td><td><strong>递增数字</strong>，增加键的整数值一次</td></tr><tr><td><strong>INCRBY key increment</strong></td><td><strong>增加指定的整数</strong>，由给定的数量递增键的整数值</td></tr><tr><td>INCRBYFLOAT key increment</td><td>由给定的数量递增键的浮点值</td></tr><tr><td><strong>DECR key</strong></td><td><strong>递减数字</strong>，递减键一次的整数值</td></tr><tr><td><strong>DECRBY key decrement</strong></td><td><strong>减少指定整数</strong>，由给定数目递减键的整数值</td></tr><tr><td><strong>APPEND key value</strong></td><td><strong>向尾部追加值</strong>，追加值到一个键</td></tr><tr><td>DEL key</td><td>如果存在删除键</td></tr><tr><td>DUMP key</td><td>返回存储在指定键的值的序列化版本</td></tr><tr><td>EXISTS key</td><td>此命令检查该键是否存在</td></tr><tr><td>EXPIRE key seconds</td><td>指定键的过期时间</td></tr><tr><td>EXPIREAT key timestamp</td><td>指定的键过期时间。在这里，时间是在Unix时间戳格式</td></tr><tr><td>PEXPIRE key milliseconds</td><td>设置键以毫秒为单位到期</td></tr><tr><td>PEXPIREAT key milliseconds-timestemp</td><td>设置键在Unix时间戳指定为毫秒到期</td></tr><tr><td>KEYS pattern</td><td>查找与指定模式匹配的所有键</td></tr><tr><td>MOVE key db</td><td>移动键到另一个数据库</td></tr><tr><td>PERSIST key</td><td>移除过期的键</td></tr><tr><td>PTTL key</td><td>以毫秒为单位获取剩余时间的到期键。</td></tr><tr><td>TTL key</td><td>获取键到期的剩余时间。</td></tr><tr><td>RANDOMKEY</td><td>从Redis返回随机键</td></tr><tr><td>RENAME key newkey</td><td>更改键的名称</td></tr><tr><td>RENAMENX key newkey</td><td>重命名键，如果新的键不存在</td></tr><tr><td>TYPE key</td><td>返回存储在键的数据类型的值。</td></tr></tbody></table><ul><li><strong>使用示例</strong></li></ul><p><strong>赋值</strong><br />语法：SET key value</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; set test 123OK</code></pre><p><strong>取值</strong><br />语法：GET key</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; get test&quot;123“</code></pre><p><strong>取值并赋值</strong><br />语法：GETSET key value</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; getset s2 222&quot;111&quot;127.0.0.1:6379&gt; get s2&quot;222&quot;</code></pre><p><strong>数值增减</strong><br />注意实现：</p><ol><li>当value为<strong>整数数据</strong>时，才能使用以下命令操作数值的增减。</li><li>数值递增都是<strong>原子</strong>操作。</li></ol><pre><code class="highlight plaintext">非原子性操作示例：可能多个线程同时访问时会得到相同的i，但我们期望每次访问都+1int i = 1;i++;System.out.println(i)</code></pre><ul><li><strong>递增数字</strong><br />语法：INCR key</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; incr num(integer) 1127.0.0.1:6379&gt; incr num(integer) 2127.0.0.1:6379&gt; incr num(integer) 3</code></pre><ul><li><strong>增加指定的整数</strong><br />语法：INCRBY key increment</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; incrby num 2(integer) 5127.0.0.1:6379&gt; incrby num 2(integer) 7127.0.0.1:6379&gt; incrby num 2(integer) 9</code></pre><ul><li><strong>递减数值</strong><br />语法：DECR key</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; decr num(integer) 9127.0.0.1:6379&gt; decr num(integer) 8</code></pre><ul><li><strong>减少指定的整数</strong><br />语法：DECRBY key decrement</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; decr num(integer) 6127.0.0.1:6379&gt; decr num(integer) 5127.0.0.1:6379&gt; decrby num 3(integer) 2127.0.0.1:6379&gt; decrby num 3(integer) -1</code></pre><p><strong>仅当不存在时赋值</strong><br />语法：setnx key value</p><pre><code class="highlight plaintext">redis&gt; EXISTS job                # job 不存在(integer) 0redis&gt; SETNX job &quot;programmer&quot;    # job 设置成功(integer) 1redis&gt; SETNX job &quot;code-farmer&quot;   # 尝试覆盖 job ，失败(integer) 0redis&gt; GET job                   # 没有被覆盖&quot;programmer&quot;</code></pre><p><strong>向尾部追加值</strong><br />APPEND命令，向键值的末尾追加value。如果键不存在则将该键的值设置为value，即相当于 SET key value。返回值是追加后字符串的总长度。</p><p>语法：APPEND key value</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; set str helloOK127.0.0.1:6379&gt; append str &quot; world!&quot;(integer) 12127.0.0.1:6379&gt; get str &quot;hello world!&quot;</code></pre><p><strong>获取字符串长度</strong><br />STRLEN命令，返回键值的长度，如果键不存在则返回0。</p><p>语法：STRLEN key</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; strlen str (integer) 0127.0.0.1:6379&gt; set str helloOK127.0.0.1:6379&gt; strlen str (integer) 5</code></pre><p><strong>同时设置/获取多个键值</strong><br />语法：<br />MSET key value [key value …]<br />MGET key [key …]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3OK127.0.0.1:6379&gt; get k1&quot;v1&quot;127.0.0.1:6379&gt; mget k1 k31) &quot;v1&quot;2) &quot;v3&quot;</code></pre><p><strong>应用场景之自增主键</strong></p><ul><li>需求：商品编号、订单号采用INCR命令生成。</li><li>设计：key命名要有一定的设计</li><li>实现：定义商品编号key：items:id</li></ul><pre><code class="highlight plaintext">192.168.101.3:7003&gt; INCR items:id(integer) 2192.168.101.3:7003&gt; INCR items:id(integer) 3</code></pre><h3 id="list-列表"><a class="markdownIt-Anchor" href="#list-列表"></a> List 列表</h3><p><strong>ArrayList和LinkedList的区别</strong></p><p>ArrayList使用<strong>数组方式</strong>存储数据，所以根据索引查询数据速度快，而新增或者删除元素时需要设计到位移操作，所以比较慢。</p><p>LinkedList使用<strong>双向链表</strong>方式存储数据，每个元素都记录前后元素的指针，所以插入、删除数据时只是更改前后元素的指针指向即可，速度非常快。然后通过下标查询元素时需要从头开始索引，所以比较慢，但是如果查询前几个元素或后几个元素速度比较快</p><hr /><p>Redis的列表类型（list）可以存储一个有序的字符串列表，常用的操作是<strong>向列表两端添加元素，或者获得列表的某一个片段</strong>。</p><p>列表类型内部是使用<strong>双向链表（double linked list）实现</strong>的，所以向列表两端添加元素的时间复杂度为0(1)，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的</p><table><thead><tr><th>代码</th><th>解释</th></tr></thead><tbody><tr><td>BLPOP key1 [key2 ] timeout</td><td>取出并获取列表中的第一个元素，或阻塞，直到有可用</td></tr><tr><td>BRPOP key1 [key2 ] timeout</td><td>取出并获取列表中的最后一个元素，或阻塞，直到有可用</td></tr><tr><td><strong>BRPOPLPUSH source destination timeout</strong></td><td><strong>将元素从一个列表转移到另一个列表中</strong>，从列表中弹出一个值，它推到另一个列表并返回它;或阻塞，直到有可用</td></tr><tr><td><strong>LINDEX key index</strong></td><td><strong>获取指定索引的元素值</strong>从一个列表其索引获取对应的元素</td></tr><tr><td><strong>LINSERT key BEFORE/AFTER pivot value</strong></td><td><strong>向列表中插入元素</strong>，在列表中的其他元素之后或之前插入一个元素</td></tr><tr><td><strong>LLEN key</strong></td><td><strong>获取列表的长度</strong></td></tr><tr><td><strong>LPOP key</strong></td><td><strong>获取并取出列表中的第一个元素，弹出元素</strong></td></tr><tr><td><strong>LPUSH key value1 [value2]</strong></td><td><strong>向列表左边增加元素</strong>,在前面加上一个或多个值的列表</td></tr><tr><td>LPUSHX key value</td><td>在前面加上一个值列表，仅当列表中存在</td></tr><tr><td><strong>LRANGE key start stop</strong></td><td>从一个列表获取各种元素</td></tr><tr><td><strong>LREM key count value</strong></td><td><strong>LREM命令会删除列表中前count个值为value的元素，返回实际删除的元素个数</strong>从列表中删除元素</td></tr><tr><td><strong>LSET key index value</strong></td><td><strong>指定一个索引的元素值</strong>，在列表中的索引设置一个元素的值</td></tr><tr><td><strong>LTRIM key start stop</strong></td><td><strong>只保留列表的指定片段</strong>，修剪列表到指定的范围内</td></tr><tr><td><strong>RPOP key</strong></td><td><strong>取出并获取列表中的最后一个元素，弹出元素</strong></td></tr><tr><td>RPOPLPUSH source destination</td><td>删除最后一个元素的列表，将其附加到另一个列表并返回它</td></tr><tr><td><strong>RPUSH key value1 [value2]</strong></td><td><strong>向列表右边增加元素</strong>，添加一个或多个值到列表</td></tr><tr><td>RPUSHX key value</td><td>添加一个值列表，仅当列表中存在</td></tr></tbody></table><ul><li><strong>使用示例</strong></li></ul><p><strong>向列表两端增加元素</strong></p><ul><li><strong>向列表左边增加元素</strong><br />语法：LPUSH key value [value …]</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; lpush list:1 1 2 3(integer) 3</code></pre><ul><li><strong>向列表右边增加元素</strong><br />语法：RPUSH key value [value …]</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; rpush list:1 4 5 6(integer) 3</code></pre><p><strong>查看列表</strong><br />语法：LRANGE key start stop<br />LRANGE命令是列表类型最常用的命令之一，获取列表中的某一片段，将返回start、stop之间的所有元素（包含两端的元素），索引从0开始。索引可以是负数，如：“-1”代表最后边的一个元素。</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; lrange list:1 0 21) &quot;2&quot;2) &quot;1&quot;3) &quot;4&quot;</code></pre><p><strong>从列表两端弹出元素</strong><br />LPOP命令从列表左边弹出一个元素，会分两步完成：</p><ol><li>第一步是将列表左边的元素从列表中移除</li><li>第二步是返回被移除的元素值。</li></ol><p>语法：<br />LPOP key<br />RPOP key</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; lpop list:1&quot;3“127.0.0.1:6379&gt; rpop list:1&quot;6“</code></pre><p><strong>获取列表中元素的个数</strong><br />语法：LLEN key</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; llen list:1(integer) 2</code></pre><p><strong>删除列表中指定个数的值</strong><br />LREM命令会删除列表中前count个值为value的元素，返回实际删除的元素个数。根据count值的不同，该命令的执行方式会有所不同：</p><ol><li>当count&gt;0时， LREM会从列表左边开始删除。</li><li>当count&lt;0时， LREM会从列表后边开始删除。</li><li>当count=0时， LREM删除所有值为value的元素。</li></ol><p>语法：LREM key count value</p><p><strong>获得/设置指定索引的元素值</strong></p><ul><li><strong>获得指定索引的元素值</strong><br />语法：LINDEX key index</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; lindex l:list 2&quot;1&quot;</code></pre><ul><li><strong>设置指定索引的元素值</strong><br />语法：LSET key index value</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; lset l:list 2 2OK127.0.0.1:6379&gt; lrange l:list 0 -11) &quot;6&quot;2) &quot;5&quot;3) &quot;2&quot;4) &quot;2&quot;</code></pre><p><strong>只保留列表指定片段</strong><br />指定范围和LRANGE一致</p><p>语法：LTRIM key start stop</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; lrange l:list 0 -11) &quot;6&quot;2) &quot;5&quot;3) &quot;0&quot;4) &quot;2&quot;127.0.0.1:6379&gt; ltrim l:list 0 2OK127.0.0.1:6379&gt; lrange l:list 0 -11) &quot;6&quot;2) &quot;5&quot;3) &quot;0&quot;</code></pre><p><strong>向列表中插入元素</strong><br />该命令首先会在列表中从左到右查找值为pivot的元素，然后根据第二个参数是BEFORE还是AFTER来决定将value插入到该元素的前面还是后面。</p><p>语法：LINSERT key BEFORE|AFTER pivot value</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; lrange list 0 -11) &quot;3&quot;2) &quot;2&quot;3) &quot;1&quot;127.0.0.1:6379&gt; linsert list after 3 4(integer) 4127.0.0.1:6379&gt; lrange list 0 -11) &quot;3&quot;2) &quot;4&quot;3) &quot;2&quot;4) &quot;1&quot;</code></pre><p><strong>将元素从一个列表转移到另一个列表中</strong><br />语法：RPOPLPUSH source destination</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; rpoplpush list newlist &quot;1&quot;127.0.0.1:6379&gt; lrange newlist 0 -11) &quot;1&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;3&quot;2) &quot;4&quot;3) &quot;2&quot;</code></pre><p><strong>应用之商品评论列表</strong></p><ul><li>需求1：用户针对某一商品发布评论，一个商品会被不同的用户进行评论，存储商品评论时，要按时间顺序排序。</li><li>需求2：用户在前端页面查询该商品的评论，需要安装时间顺序降序排序。</li></ul><p>思路：</p><ol><li>使用list存储商品评论信息，KEY是该商品的ID，VALUE是商品评论信息列表</li><li>商品编号为1001的商品评论key【items: comment:1001】</li></ol><pre><code class="highlight plaintext">192.168.101.3:7001&gt; LPUSH items:comment:1001 &#x27;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;商品不错，很好！！&quot;,&quot;date&quot;:1430295077289&#125;&#x27;</code></pre><h3 id="hash-哈希表"><a class="markdownIt-Anchor" href="#hash-哈希表"></a> Hash 哈希表</h3><p>hash叫<strong>散列类型</strong>，它提供了字段和字段值的映射。字段值只能是字符串类型，不支持散列类型、集合类型等其它类型</p><table><thead><tr><th>代码</th><th>命令</th></tr></thead><tbody><tr><td><strong>HDEL key field[field…]</strong></td><td><strong>删除一个或多个字段，返回值是被删除的字段个数</strong>，删除对象的一个或几个属性域，不存在的属性将被忽略</td></tr><tr><td><strong>HEXISTS key field</strong></td><td><strong>判断字段是否存在</strong>，查看对象是否存在该属性域</td></tr><tr><td><strong>HGET key field</strong></td><td><strong>一次获取一个字段值</strong>，获取对象中该field属性域的值</td></tr><tr><td><strong>HGETALL key</strong></td><td><strong>获取所有字段的key和value</strong>，获取对象的所有属性域和值</td></tr><tr><td><strong>HINCRBY key field value increment</strong></td><td><strong>增加数字</strong>，将该对象中指定域的值增加给定的value，原子自增操作，只能是integer的属性值可以使用</td></tr><tr><td>HINCRBYFLOAT key field increment</td><td>将该对象中指定域的值增加给定的浮点数</td></tr><tr><td><strong>HKEYS key</strong></td><td><strong>只获取字段名</strong>，获取对象的所有属性字段</td></tr><tr><td><strong>HVALS key</strong></td><td><strong>只获取字段值</strong>，获取对象的所有属性值</td></tr><tr><td><strong>HLEN key</strong></td><td><strong>获取字段数量</strong>，获取对象的所有属性字段的总数</td></tr><tr><td><strong>HMGET key field[field…]</strong></td><td><strong>一次获取多个字段的值</strong>，获取对象的一个或多个指定字段的值</td></tr><tr><td><strong>HSET key field value</strong></td><td><strong>设置一个字段的值</strong>，设置对象指定字段的值</td></tr><tr><td><strong>HMSET key field value [field value …]</strong></td><td><strong>设置多个字段的值</strong>，同时设置对象中一个或多个字段的值</td></tr><tr><td><strong>HSETNX key field value</strong></td><td><strong>当字段不存在时赋值</strong>，只在对象不存在指定的字段时才设置字段的值</td></tr><tr><td>HSTRLEN key field</td><td>返回对象指定field的value的字符串长度，如果该对象或者field不存在，返回0.</td></tr><tr><td>HSCAN key cursor [MATCH pattern] [COUNT count]</td><td>类似SCAN命令</td></tr></tbody></table><ul><li><strong>使用示例</strong></li></ul><p><strong>赋值</strong><br />HSET命令不区分插入和更新操作，当执行插入操作时HSET命令返回1，当执行更新操作时返回0。</p><ul><li><strong>一次只能设置一个字段值</strong><br />语法：HSET key field value</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; hset user username zhangsan (integer) 1</code></pre><ul><li><strong>一次可以设置多个字段值</strong><br />语法：HMSET key field value [field value …]</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; hmset user age 20 username lisi OK</code></pre><ul><li><strong>当字段不存在时赋值</strong>，类似HSET，区别在于如果字段存在，该命令不执行任何操作<br />语法：HSETNX key field value</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; hsetnx user age 30如果user中没有age字段则设置age值为30，否则不做任何操作(integer) 0</code></pre><p><strong>取值</strong></p><ul><li><strong>一次只能获取一个字段值</strong><br />语法：HGET key field</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; hget user username&quot;zhangsan“</code></pre><ul><li><strong>一次可以获取多个字段值</strong><br />语法：HMGET key field [field …]</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; hmget user age username1) &quot;20&quot;2) &quot;lisi&quot;</code></pre><ul><li><strong>获取所有字段值</strong><br />语法：HGETALL key</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; hgetall user1) &quot;age&quot;2) &quot;20&quot;3) &quot;username&quot;4) &quot;lisi&quot;</code></pre><p><strong>删除字段</strong><br />可以删除一个或多个字段，返回值是被删除的字段个数</p><p>语法：HDEL key field [field …]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; hdel user age(integer) 1127.0.0.1:6379&gt; hdel user age name(integer) 0127.0.0.1:6379&gt; hdel user age username(integer) 1</code></pre><p><strong>增加数字</strong><br />语法：HINCRBY key field increment</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; hincrby user age 2将用户的年龄加2(integer) 22127.0.0.1:6379&gt; hget user age获取用户的年龄&quot;22“</code></pre><p><strong>判断字段是否存在</strong><br />语法：HEXISTS key field</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; hexists user age查看user中是否有age字段(integer) 1127.0.0.1:6379&gt; hexists user name查看user中是否有name字段(integer) 0</code></pre><p><strong>只获取字段名或字段值</strong><br />语法：<br />HKEYS key<br />HVALS key</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; hmset user age 20 name lisi OK127.0.0.1:6379&gt; hkeys user1) &quot;age&quot;2) &quot;name&quot;127.0.0.1:6379&gt; hvals user1) &quot;20&quot;2) &quot;lisi&quot;</code></pre><p><strong>获取字段数量</strong><br />语法：HLEN key</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; hlen user(integer) 2</code></pre><p><strong>获取所有字段</strong><br />作用：获得hash的所有信息，包括key和value<br />语法：hgetall key</p><p><strong>应用之存储商品信息</strong><br />注意事项：存储那些对象数据，特别是对象属性经常发生增删改操作的数据。</p><ul><li><p>商品信息字段<br />【商品id、商品名称、商品描述、商品库存、商品好评】</p></li><li><p>定义商品信息的key<br />商品ID为1001的信息在 Redis中的key为：[items:1001]</p></li></ul><p>存储商品信息</p><pre><code class="highlight plaintext">192.168.101.3:7003&gt; HMSET items:1001 id 3 name apple price 999.9OK</code></pre><p>获取商品信息</p><pre><code class="highlight plaintext">192.168.101.3:7003&gt; HGET items:1001 id&quot;3&quot;192.168.101.3:7003&gt; HGETALL items:10011) &quot;id&quot;2) &quot;3&quot;3) &quot;name&quot;4) &quot;apple&quot;5) &quot;price&quot;6) &quot;999.9&quot;</code></pre><h3 id="set-集合"><a class="markdownIt-Anchor" href="#set-集合"></a> set 集合</h3><p>set类型即<strong>集合类型</strong>，其中的数据是<strong>不重复且没有顺序</strong></p><p>集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型的Redis内部是使用值为空的散列表实现，所有这些操作的时间复杂度都为0(1)。</p><p>Redis还提供了多个集合之间的交集、并集、差集的运算。</p><table><thead><tr><th>代码</th><th>解释</th></tr></thead><tbody><tr><td><strong>SADD key member [member …]</strong></td><td><strong>增加元素</strong>，添加一个或者多个元素到集合(set)里，已存在的元素忽略</td></tr><tr><td><strong>SCARD key</strong></td><td><strong>获取集合里面的元素数量</strong></td></tr><tr><td><strong>SDIFF key [key …]</strong></td><td><strong>属于A并且不属于B的元素构成的集合</strong>，获得队列不存在的元素</td></tr><tr><td>SDIFFSTORE destination key [key …]</td><td>获得队列不存在的元素，并存储在一个关键的结果集</td></tr><tr><td><strong>SINTER key [key …]</strong></td><td><strong>获得两个集合的交集</strong></td></tr><tr><td>SINTERSTORE destination key [key …]</td><td>获得两个集合的交集，并存储在一个集合中</td></tr><tr><td><strong>SISMEMBER key member</strong></td><td><strong>判断元素是否再集合中</strong>，确定一个给定的值是一个集合的成员</td></tr><tr><td><strong>SMEMBERS key</strong></td><td><strong>获取集合里面的所有元素</strong></td></tr><tr><td>SMOVE source destination member</td><td>移动集合里面的一个key到另一个集合</td></tr><tr><td><strong>SPOP key [count]</strong></td><td><strong>从集合中弹出一个元素</strong>，获取并删除一个集合里面的元素，注意：由于集合是无序的，所有SPOP命令会从集合中随机选择一个元素弹出</td></tr><tr><td>SRANDMEMBER key [count]</td><td>从集合里面随机获取一个元素</td></tr><tr><td><strong>SREM key member [member …]</strong></td><td><strong>删除元素</strong>，从集合里删除一个或多个元素，不存在的元素会被忽略</td></tr><tr><td><strong>SUNION key [key …]</strong></td><td><strong>A和B的并集，属于A或者属于B的元素构成的集合</strong>，添加多个set元素</td></tr><tr><td>SUNIONSTORE destination key [key …]</td><td>合并set元素，并将结果存入新的set里面</td></tr><tr><td>SSCAN key cursor [MATCH pattern] [COUNT count]</td><td>迭代set里面的元素</td></tr></tbody></table><ul><li><strong>使用示例</strong></li></ul><p><strong>增加/删除元素</strong><br />语法：SADD key member [member …]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; sadd set a b c(integer) 3127.0.0.1:6379&gt; sadd set a(integer) 0</code></pre><p>语法：SREM key member [member …]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; srem set c d(integer) 1</code></pre><p><strong>获得集合中的所有元素</strong><br />语法：SMEMBERS key</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; smembers set1) &quot;b&quot;2) &quot;a”</code></pre><p><strong>判断元素是否在集合中</strong><br />语法：SISMEMBER key member</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; sismember set a(integer) 1127.0.0.1:6379&gt; sismember set h(integer) 0</code></pre><p><strong>集合运算命令</strong></p><ul><li><strong>集合的差集运算 A-B</strong><br />属于A并且不属于B的元素构成的集合。</li></ul><p>语法：SDIFF key [key …]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; sadd setA 1 2 3(integer) 3127.0.0.1:6379&gt; sadd setB 2 3 4(integer) 3127.0.0.1:6379&gt; sdiff setA setB 1) &quot;1&quot;127.0.0.1:6379&gt; sdiff setB setA 1) &quot;4&quot;</code></pre><ul><li><strong>集合的交集运算 A ∩ B</strong><br />属于A且属于B的元素构成的集合。</li></ul><p>语法：SINTER key [key …]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; sinter setA setB 1) &quot;2&quot;2) &quot;3&quot;</code></pre><ul><li><strong>集合的并集运算 A ∪ B</strong><br />属于A或者属于B的元素构成的集合（结果也无重复值）</li></ul><p>语法：SUNION key [key …]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; sunion setA setB1) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;4) &quot;4&quot;</code></pre><p><strong>获得集合中元素的个数</strong><br />语法：SCARD key</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; smembers setA 1) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;127.0.0.1:6379&gt; scard setA (integer) 3</code></pre><p><strong>从集合中弹出一个元素</strong><br />注意：由于集合是无序的，所有SPOP命令会从集合中随机选择一个元素弹出</p><p>语法：SPOP key</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; spop setA &quot;1“</code></pre><h3 id="zsetsorted-set有序集合"><a class="markdownIt-Anchor" href="#zsetsorted-set有序集合"></a> Zset(Sorted Set)有序集合</h3><p>在集合类型的基础上，有序集合类型为集合中的<strong>每个元素都关联一个分数</strong>，这使得我们不仅可以完成插入、删除和判断元素是否存在在集合中，还能够获得分数最高或最低的前N个元素、获取指定分数范围内的元素等与分数有关的操作。</p><p>在某些方面有序集合和列表类型有些<strong>相似</strong>。</p><ol><li><p>二者都是有序的。</p></li><li><p>二者都可以获得某一范围的元素。</p></li></ol><p>但是，二者有着很大<strong>区别</strong>：</p><ol><li><p>列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会变慢。</p></li><li><p>有序集合类型使用散列表实现，所有即使读取位于中间部分的数据也很快。</p></li><li><p>列表中不能简单的调整某个元素的位置，但是有序集合可以（通过更改分数实现）</p></li><li><p>有序集合要比列表类型更耗内存。</p></li></ol><table><thead><tr><th>代码</th><th>解释</th></tr></thead><tbody><tr><td><strong>ZADD key score1 member1 [score2 member2]</strong></td><td><strong>增加元素</strong>，添加一个或多个成员到有序集合，或者如果它已经存在更新其分数</td></tr><tr><td><strong>ZCARD key</strong></td><td><strong>得到的有序集合成员的数量</strong></td></tr><tr><td><strong>ZCOUNT key min max</strong></td><td><strong>获得指定分数范围内的元素个数</strong>，计算一个有序集合成员与给定值范围内的分数</td></tr><tr><td><strong>ZINCRBY key increment member</strong></td><td><strong>增加某个元素的分数</strong>，在有序集合增加成员的分数</td></tr><tr><td>ZINTERSTORE destination numkeys key [key …]</td><td>多重交叉排序集合，并存储生成一个新的键有序集合。</td></tr><tr><td>ZLEXCOUNT key min max</td><td>计算一个给定的字典范围之间的有序集合成员的数量</td></tr><tr><td><strong>ZRANGE key start stop [WITHSCORES]</strong></td><td><strong>获取排名再某个范围内的元素列表</strong>，由索引返回一个成员范围的有序集合（从低到高）</td></tr><tr><td>ZRANGEBYLEX key min max [LIMIT offset count]</td><td>返回一个成员范围的有序集合（由字典范围）</td></tr><tr><td><strong>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</strong></td><td><strong>获取指定分数范围内的元素</strong>，返回有序集key中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员，有序集成员按 score 值递增(从小到大)次序排列</td></tr><tr><td><strong>ZRANK key member</strong></td><td><strong>获取元素的排名（从小到大）</strong>，确定成员的索引中有序集合</td></tr><tr><td><strong>ZREM key member [member …]</strong></td><td><strong>删除元素</strong>，从有序集合中删除一个或多个成员，不存在的成员将被忽略</td></tr><tr><td>ZREMRANGEBYLEX key min max</td><td>删除所有成员在给定的字典范围之间的有序集合</td></tr><tr><td><strong>ZREMRANGEBYRANK key start stop</strong></td><td><strong>按照排名范围删除元素</strong>，在给定的索引之内删除所有成员的有序集合</td></tr><tr><td><strong>ZREMRANGEBYSCORE key min max</strong></td><td><strong>按照分数范围删除元素</strong>，在给定的分数之内删除所有成员的有序集合</td></tr><tr><td>ZREVRANGE key start stop [WITHSCORES]</td><td>返回一个成员范围的有序集合，通过索引，以分数排序，从高分到低分</td></tr><tr><td>ZREVRANGEBYSCORE key max min [WITHSCORES]</td><td>返回一个成员范围的有序集合，以socre排序从高到低</td></tr><tr><td><strong>ZREVRANK key member</strong></td><td><strong>获取元素的排名（）从大到小</strong>，确定一个有序集合成员的索引，以分数排序，从高分到低分</td></tr><tr><td><strong>ZSCORE key member</strong></td><td><strong>获取元素的分数</strong>，获取给定成员相关联的分数在一个有序集合</td></tr><tr><td>ZUNIONSTORE destination numkeys key [key …]</td><td>添加多个集排序，所得排序集合存储在一个新的键</td></tr><tr><td>ZSCAN key cursor [MATCH pattern] [COUNT count]</td><td>增量迭代排序元素集和相关的分数</td></tr></tbody></table><ul><li><strong>使用示例</strong></li></ul><p><strong>增加元素</strong><br />向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。</p><p>语法：ZADD key score member [score member …]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; zadd scoreboard 80 zhangsan 89 lisi 94 wangwu (integer) 3127.0.0.1:6379&gt; zadd scoreboard 97 lisi (integer) 0</code></pre><p><strong>获得排名在某个范围的元素列表</strong></p><ul><li>按照元素分数<strong>从小到大</strong>的顺序返回索引从start到stop之间的所有元素（包含两端的元素）</li></ul><p>语法：ZRANGE key start stop [WITHSCORES]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; zrange scoreboard 0 21) &quot;zhangsan&quot;2) &quot;wangwu&quot;3) &quot;lisi“</code></pre><ul><li>按照元素分数<strong>从大到小</strong>的顺序返回索引从start到stop之间的所有元素（包含两端的元素）</li></ul><p>语法：ZREVRANGE key start stop [WITHSCORES]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; zrevrange scoreboard 0 21) &quot; lisi &quot;2) &quot;wangwu&quot;3) &quot; zhangsan “</code></pre><blockquote><p>如果需要获得元素的分数的可以在命令尾部加上WITHSCORES参数</p></blockquote><pre><code class="highlight plaintext">127.0.0.1:6379&gt; zrange scoreboard 0 1 WITHSCORES1) &quot;zhangsan&quot;2) &quot;80&quot;3) &quot;wangwu&quot;4) &quot;94&quot;</code></pre><p><strong>获取元素的分数</strong><br />语法：ZSCORE key member</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; zscore scoreboard lisi &quot;97&quot;</code></pre><p><strong>删除元素</strong><br />移除有序集key中的一个或多个成员，不存在的成员将被忽略。<br />当key存在但不是有序集类型时，返回一个错误。</p><p>语法：ZREM key member [member …]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; zrem scoreboard lisi(integer) 1</code></pre><p><strong>获得指定分数范围的元素</strong><br />语法：ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 90 97 WITHSCORES1) &quot;wangwu&quot;2) &quot;94&quot;3) &quot;lisi&quot;4) &quot;97&quot;127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 70 100 limit 1 21) &quot;wangwu&quot;2) &quot;lisi&quot;</code></pre><p><strong>增加某个元素的分数</strong><br />返回值是更改后的分数</p><p>语法：ZINCRBY  key increment member</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; ZINCRBY scoreboard 4 lisi &quot;101“</code></pre><p><strong>获得集合中元素的数量</strong><br />语法：ZCARD key</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; ZCARD scoreboard(integer) 3</code></pre><p><strong>获得指定分数范围内的元素个数</strong><br />语法：ZCOUNT key min max</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; ZCOUNT scoreboard 80 90(integer) 1</code></pre><p><strong>按照排名范围删除元素</strong><br />语法：ZREMRANGEBYRANK key start stop</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; ZREMRANGEBYRANK scoreboard 0 1(integer) 2 127.0.0.1:6379&gt; ZRANGE scoreboard 0 -11) &quot;lisi&quot;</code></pre><p><strong>按照分数范围删除元素</strong><br />语法：ZREMRANGEBYSCORE key min max</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; zadd scoreboard 84 zhangsan(integer) 1127.0.0.1:6379&gt; ZREMRANGEBYSCORE scoreboard 80 100(integer) 1</code></pre><p><strong>获取元素的排名</strong></p><ul><li><strong>从小到大</strong><br />语法：ZRANK key member</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; ZRANK scoreboard lisi (integer) 0</code></pre><ul><li><strong>从大到小</strong><br />语法：ZREVRANK key member</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; ZREVRANK scoreboard zhangsan (integer) 1</code></pre><p><strong>应用之商品销售排行榜</strong></p><ul><li>需求：根据商品销售量对商品进行排行显示</li><li>思路：定义商品销售排行榜（sorted set集合），Key为items:sellsort，分数为商品销售量。</li></ul><p>写入商品销售量：</p><ul><li>商品编号1001的销量是9，商品编号1002的销量是10</li></ul><pre><code class="highlight plaintext">192.168.101.3:7007&gt; ZADD items:sellsort 9 1001 10 1002</code></pre><ul><li>商品编号1001的销量加1</li></ul><pre><code class="highlight plaintext">192.168.101.3:7001&gt; ZINCRBY items:sellsort 1 1001</code></pre><ul><li>商品销量前10名：</li></ul><pre><code class="highlight plaintext">192.168.101.3:7001&gt; ZRANGE items:sellsort 0 9 withscores</code></pre><h3 id="通用命令"><a class="markdownIt-Anchor" href="#通用命令"></a> 通用命令</h3><p><strong>keys pattern</strong></p><p>返回满足给定pattern的所有key</p><pre><code class="highlight redis">redis 127.0.0.1:6379&gt; keys mylist*1) &quot;mylist&quot;2) &quot;mylist5&quot;3) &quot;mylist6&quot;4) &quot;mylist7&quot;5) &quot;mylist8&quot;</code></pre><p><strong>DEL key</strong></p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; del test(integer) 1</code></pre><p><strong>exists key</strong></p><p>确认一个key是否存在</p><pre><code class="highlight plaintext">redis 127.0.0.1:6379&gt; exists HongWan(integer) 0redis 127.0.0.1:6379&gt; exists age(integer) 1</code></pre><p><strong>expire</strong></p><p>Redis在实际使用过程中更多的用作缓存，然而缓存的数据一般都是需要设置生存时间的，即：到期后数据销毁</p><ul><li><strong>expire key seconds</strong> 设置key的生存实践（单位：秒）key再多少秒之后会自动删除</li><li><strong>ttl key</strong> 查看key剩余的生存时间</li><li><strong>persist key</strong> 清除生存时间</li><li><strong>pexpire key milliseconds</strong> 设置时间单位为毫秒</li></ul><pre><code class="highlight plaintext">192.168.101.3:7002&gt; set test 1             设置test的值为1OK192.168.101.3:7002&gt; get test                获取test的值&quot;1&quot;192.168.101.3:7002&gt; EXPIRE test 5     设置test的生存时间为5秒(integer) 1192.168.101.3:7002&gt; TTL test                     查看test的生于生成时间还有1秒删除(integer) 1192.168.101.3:7002&gt; TTL test(integer) -2192.168.101.3:7002&gt; get test                获取test的值，已经删除(nil)</code></pre><p><strong>rename oldkey  newkey</strong></p><p>重命名key</p><pre><code class="highlight plaintext">redis 127.0.0.1:6379[1]&gt; keys *1) &quot;age&quot;redis 127.0.0.1:6379[1]&gt; rename age age_newOKredis 127.0.0.1:6379[1]&gt; keys *1) &quot;age_new&quot;redis 127.0.0.1:6379[1]&gt;</code></pre><p><strong>type key</strong></p><p>显示指定key的数据类型</p><pre><code class="highlight plaintext">redis 127.0.0.1:6379&gt; type addrstringredis 127.0.0.1:6379&gt; type myzset2zsetredis 127.0.0.1:6379&gt; type mylistlist</code></pre><h2 id="redis-spring-集成"><a class="markdownIt-Anchor" href="#redis-spring-集成"></a> Redis Spring 集成</h2><h3 id="导入相关jar包"><a class="markdownIt-Anchor" href="#导入相关jar包"></a> 导入相关jar包</h3><ul><li>spring相关jar包</li><li>Jedis相关jar包</li></ul><h3 id="redisproperties"><a class="markdownIt-Anchor" href="#redisproperties"></a> redis.properties</h3><ul><li>指定连接Redis服务器的相关信息</li></ul><pre><code class="highlight properties"><span class="comment">#ip地址</span><span class="attr">redis.hostName</span>=<span class="string">127.0.0.1</span><span class="comment">#端口号</span><span class="attr">redis.port</span>=<span class="string">6379</span><span class="comment">#如果有密码</span><span class="attr">redis.password</span>=<span class="string"></span><span class="comment">#客户端超时时间单位是毫秒 默认是2000</span><span class="attr">redis.timeout</span>=<span class="string">2000</span><span class="comment"> </span><span class="comment">#最大空闲数</span><span class="attr">redis.maxIdle</span>=<span class="string">10</span><span class="comment">#连接池的最大数据库连接数。设为0表示无限制,如果是jedis 2.4以后用redis.maxTotal</span><span class="attr">redis.maxActive</span>=<span class="string">10</span><span class="comment">#控制一个pool可分配多少个jedis实例,用来替换上面的redis.maxActive,如果是jedis 2.4以后用该属性</span><span class="attr">redis.maxTotal</span>=<span class="string">10</span><span class="comment">#最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制。</span><span class="attr">redis.maxWaitMillis</span>=<span class="string">1000</span><span class="comment">#连接的最小空闲时间 默认1800000毫秒(30分钟)</span><span class="attr">redis.minEvictableIdleTimeMillis</span>=<span class="string">300000</span><span class="comment">#每次释放连接的最大数目,默认3</span><span class="attr">redis.numTestsPerEvictionRun</span>=<span class="string">1024</span><span class="comment">#逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1</span><span class="attr">redis.timeBetweenEvictionRunsMillis</span>=<span class="string">30000</span><span class="comment">#是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个</span><span class="attr">redis.testOnBorrow</span>=<span class="string">false</span><span class="comment">#在空闲时检查有效性, 默认false</span><span class="attr">redis.testWhileIdle</span>=<span class="string">false</span></code></pre><h3 id="applicationcontextxml"><a class="markdownIt-Anchor" href="#applicationcontextxml"></a> applicationContext.xml</h3><ul><li>配置连接池，连接工厂等，以上都是为了<br />RedisTemplate服务，这个类就是提供常用的Redis方法</li><li>然后又把这个 RedisTemplate 类的实例，注入到 RedisUtil 工具类里，方便调用</li></ul><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span> <span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>   </span><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span>   </span><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span>   </span><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span>   </span><span class="tag">    <span class="attr">xmlns:cache</span>=<span class="string">&quot;http://www.springframework.org/schema/cache&quot;</span> </span><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans     </span></span><span class="string"><span class="tag">                        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd     </span></span><span class="string"><span class="tag">                        http://www.springframework.org/schema/context     </span></span><span class="string"><span class="tag">                        http://www.springframework.org/schema/context/spring-context-4.2.xsd     </span></span><span class="string"><span class="tag">                        http://www.springframework.org/schema/mvc     </span></span><span class="string"><span class="tag">                        http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd </span></span><span class="string"><span class="tag">                        http://www.springframework.org/schema/cache  </span></span><span class="string"><span class="tag">                        http://www.springframework.org/schema/cache/spring-cache-4.2.xsd&quot;</span>&gt;</span>     <span class="comment">&lt;!-- 加载配置文件 --&gt;</span>    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:*.properties&quot;</span> /&gt;</span>    <span class="comment">&lt;!-- redis连接池配置--&gt;</span>     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisPoolConfig&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisPoolConfig&quot;</span> &gt;</span>         <span class="comment">&lt;!--最大空闲数--&gt;</span>         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.maxIdle&#125;&quot;</span> /&gt;</span>         <span class="comment">&lt;!--连接池的最大数据库连接数  --&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxTotal&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.maxTotal&#125;&quot;</span> /&gt;</span>        <span class="comment">&lt;!--最大建立连接等待时间--&gt;</span>         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWaitMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.maxWaitMillis&#125;&quot;</span> /&gt;</span>         <span class="comment">&lt;!--逐出连接的最小空闲时间 默认1800000毫秒(30分钟)--&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.minEvictableIdleTimeMillis&#125;&quot;</span> /&gt;</span>        <span class="comment">&lt;!--每次逐出检查时 逐出的最大数目 如果为负数就是 : 1/abs(n), 默认3--&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;numTestsPerEvictionRun&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.numTestsPerEvictionRun&#125;&quot;</span> /&gt;</span>        <span class="comment">&lt;!--逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1--&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.timeBetweenEvictionRunsMillis&#125;&quot;</span> /&gt;</span>        <span class="comment">&lt;!--是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个--&gt;</span>         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.testOnBorrow&#125;&quot;</span> /&gt;</span>         <span class="comment">&lt;!--在空闲时检查有效性, 默认false  --&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.testWhileIdle&#125;&quot;</span> /&gt;</span>     &lt;/bean &gt;         <span class="comment">&lt;!--redis连接工厂 --&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisConnectionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;poolConfig&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jedisPoolConfig&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="comment">&lt;!--IP地址 --&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hostName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.hostName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="comment">&lt;!--端口号  --&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;port&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.port&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="comment">&lt;!--如果Redis设置有密码  --&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.password&#125;&quot;</span> /&gt;</span>        <span class="comment">&lt;!--客户端超时时间单位是毫秒  --&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.timeout&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>          <span class="comment">&lt;!--redis操作模版,使用该对象可以操作redis  --&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;redisTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.core.RedisTemplate&quot;</span></span><span class="tag">        <span class="attr">p:connection-factory-ref</span>=<span class="string">&quot;jedisConnectionFactory&quot;</span> &gt;</span>         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;keySerializer&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">bean</span></span><span class="tag">                <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hashKeySerializer&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">bean</span></span><span class="tag">                <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;valueSerializer&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">bean</span></span><span class="tag">                <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.serializer.JdkSerializationRedisSerializer&quot;</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hashValueSerializer&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">bean</span></span><span class="tag">                <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.serializer.JdkSerializationRedisSerializer&quot;</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>    &lt;/bean &gt;          <span class="comment">&lt;!--自定义redis工具类,在需要缓存的地方注入此类  --&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;redisUtil&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.how2java.RedisUtil&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;redisTemplate&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;redisTemplate&quot;</span> /&gt;</span>    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>     <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></code></pre><h3 id="redisutil"><a class="markdownIt-Anchor" href="#redisutil"></a> RedisUtil</h3><ul><li>RedisUtil工具类，封装了Redis Template这个类，以提供更为便利的对于Redis的访问</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.how2java; <span class="keyword">import</span> java.util.List;<span class="keyword">import</span> java.util.Map;<span class="keyword">import</span> java.util.Set;<span class="keyword">import</span> java.util.concurrent.TimeUnit; <span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<span class="keyword">import</span> org.springframework.util.CollectionUtils; <span class="comment">/**</span><span class="comment"> * 基于spring和redis的redisTemplate工具类</span><span class="comment"> * 针对所有的hash 都是以h开头的方法</span><span class="comment"> * 针对所有的Set 都是以s开头的方法                    不含通用方法</span><span class="comment"> * 针对所有的List 都是以l开头的方法</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisUtil</span> &#123;    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRedisTemplate</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;        <span class="built_in">this</span>.redisTemplate = redisTemplate;    &#125;    <span class="comment">//=============================common============================</span>    <span class="comment">/**</span><span class="comment">     * 指定缓存失效时间</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">expire</span><span class="params">(String key,<span class="type">long</span> time)</span>&#123;        <span class="keyword">try</span> &#123;            <span class="keyword">if</span>(time&gt;<span class="number">0</span>)&#123;                redisTemplate.expire(key, time, TimeUnit.SECONDS);            &#125;            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 根据key 获取过期时间</span><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getExpire</span><span class="params">(String key)</span>&#123;        <span class="keyword">return</span> redisTemplate.getExpire(key,TimeUnit.SECONDS);    &#125;         <span class="comment">/**</span><span class="comment">     * 判断key是否存在</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKey</span><span class="params">(String key)</span>&#123;        <span class="keyword">try</span> &#123;            <span class="keyword">return</span> redisTemplate.hasKey(key);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 删除缓存</span><span class="comment">     * <span class="doctag">@param</span> key 可以传一个值 或多个</span><span class="comment">     */</span>    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(String ... key)</span>&#123;        <span class="keyword">if</span>(key!=<span class="literal">null</span>&amp;&amp;key.length&gt;<span class="number">0</span>)&#123;            <span class="keyword">if</span>(key.length==<span class="number">1</span>)&#123;                redisTemplate.delete(key[<span class="number">0</span>]);            &#125;<span class="keyword">else</span>&#123;                redisTemplate.delete(CollectionUtils.arrayToList(key));            &#125;        &#125;    &#125;         <span class="comment">//============================String=============================</span>    <span class="comment">/**</span><span class="comment">     * 普通缓存获取</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@return</span> 值</span><span class="comment">     */</span>    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span>&#123;        <span class="keyword">return</span> key==<span class="literal">null</span>?<span class="literal">null</span>:redisTemplate.opsForValue().get(key);    &#125;         <span class="comment">/**</span><span class="comment">     * 普通缓存放入</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> value 值</span><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key,Object value)</span> &#123;         <span class="keyword">try</span> &#123;            redisTemplate.opsForValue().set(key, value);            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;             &#125;         <span class="comment">/**</span><span class="comment">     * 普通缓存放入并设置时间</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> value 值</span><span class="comment">     * <span class="doctag">@param</span> time 时间(秒) time要大于0 如果time小于等于0 将设置无限期</span><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key,Object value,<span class="type">long</span> time)</span>&#123;        <span class="keyword">try</span> &#123;            <span class="keyword">if</span>(time&gt;<span class="number">0</span>)&#123;                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);            &#125;<span class="keyword">else</span>&#123;                set(key, value);            &#125;            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 递增</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> by 要增加几(大于0)</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">incr</span><span class="params">(String key, <span class="type">long</span> delta)</span>&#123;         <span class="keyword">if</span>(delta&lt;<span class="number">0</span>)&#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递增因子必须大于0&quot;</span>);        &#125;        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);    &#125;         <span class="comment">/**</span><span class="comment">     * 递减</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> by 要减少几(小于0)</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">decr</span><span class="params">(String key, <span class="type">long</span> delta)</span>&#123;         <span class="keyword">if</span>(delta&lt;<span class="number">0</span>)&#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递减因子必须大于0&quot;</span>);        &#125;        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);     &#125;          <span class="comment">//================================Map=================================</span>    <span class="comment">/**</span><span class="comment">     * HashGet</span><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span><span class="comment">     * <span class="doctag">@return</span> 值</span><span class="comment">     */</span>    <span class="keyword">public</span> Object <span class="title function_">hget</span><span class="params">(String key,String item)</span>&#123;        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);    &#125;         <span class="comment">/**</span><span class="comment">     * 获取hashKey对应的所有键值</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@return</span> 对应的多个键值</span><span class="comment">     */</span>    <span class="keyword">public</span> Map&lt;Object,Object&gt; <span class="title function_">hmget</span><span class="params">(String key)</span>&#123;        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);    &#125;         <span class="comment">/**</span><span class="comment">     * HashSet</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span><span class="comment">     * <span class="doctag">@return</span> true 成功 false 失败</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String,Object&gt; map)</span>&#123;         <span class="keyword">try</span> &#123;            redisTemplate.opsForHash().putAll(key, map);            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * HashSet 并设置时间</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String,Object&gt; map, <span class="type">long</span> time)</span>&#123;         <span class="keyword">try</span> &#123;            redisTemplate.opsForHash().putAll(key, map);            <span class="keyword">if</span>(time&gt;<span class="number">0</span>)&#123;                expire(key, time);            &#125;            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> item 项</span><span class="comment">     * <span class="doctag">@param</span> value 值</span><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key,String item,Object value)</span> &#123;         <span class="keyword">try</span> &#123;            redisTemplate.opsForHash().put(key, item, value);            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> item 项</span><span class="comment">     * <span class="doctag">@param</span> value 值</span><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)  注意:如果已存在的hash表有时间,这里将会替换原有的时间</span><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key,String item,Object value,<span class="type">long</span> time)</span> &#123;         <span class="keyword">try</span> &#123;            redisTemplate.opsForHash().put(key, item, value);            <span class="keyword">if</span>(time&gt;<span class="number">0</span>)&#123;                expire(key, time);            &#125;            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 删除hash表中的值</span><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span><span class="comment">     * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hdel</span><span class="params">(String key, Object... item)</span>&#123;         redisTemplate.opsForHash().delete(key,item);    &#125;         <span class="comment">/**</span><span class="comment">     * 判断hash表中是否有该项的值</span><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hHasKey</span><span class="params">(String key, String item)</span>&#123;        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);    &#125;         <span class="comment">/**</span><span class="comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> item 项</span><span class="comment">     * <span class="doctag">@param</span> by 要增加几(大于0)</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hincr</span><span class="params">(String key, String item,<span class="type">double</span> by)</span>&#123;         <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);    &#125;         <span class="comment">/**</span><span class="comment">     * hash递减</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> item 项</span><span class="comment">     * <span class="doctag">@param</span> by 要减少记(小于0)</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hdecr</span><span class="params">(String key, String item,<span class="type">double</span> by)</span>&#123;         <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item,-by);     &#125;          <span class="comment">//============================set=============================</span>    <span class="comment">/**</span><span class="comment">     * 根据key获取Set中的所有值</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sGet</span><span class="params">(String key)</span>&#123;        <span class="keyword">try</span> &#123;            <span class="keyword">return</span> redisTemplate.opsForSet().members(key);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">null</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 根据value从一个set中查询,是否存在</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> value 值</span><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sHasKey</span><span class="params">(String key,Object value)</span>&#123;        <span class="keyword">try</span> &#123;            <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 将数据放入set缓存</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span><span class="comment">     * <span class="doctag">@return</span> 成功个数</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSet</span><span class="params">(String key, Object...values)</span> &#123;        <span class="keyword">try</span> &#123;            <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="number">0</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 将set数据放入缓存</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span><span class="comment">     * <span class="doctag">@return</span> 成功个数</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSetAndTime</span><span class="params">(String key,<span class="type">long</span> time,Object...values)</span> &#123;        <span class="keyword">try</span> &#123;            <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().add(key, values);            <span class="keyword">if</span>(time&gt;<span class="number">0</span>) expire(key, time);            <span class="keyword">return</span> count;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="number">0</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 获取set缓存的长度</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sGetSetSize</span><span class="params">(String key)</span>&#123;        <span class="keyword">try</span> &#123;            <span class="keyword">return</span> redisTemplate.opsForSet().size(key);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="number">0</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 移除值为value的</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">setRemove</span><span class="params">(String key, Object ...values)</span> &#123;        <span class="keyword">try</span> &#123;            <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().remove(key, values);            <span class="keyword">return</span> count;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="number">0</span>;        &#125;    &#125;    <span class="comment">//===============================list=================================</span>         <span class="comment">/**</span><span class="comment">     * 获取list缓存的内容</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> start 开始</span><span class="comment">     * <span class="doctag">@param</span> end 结束  0 到 -1代表所有值</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">lGet</span><span class="params">(String key,<span class="type">long</span> start, <span class="type">long</span> end)</span>&#123;        <span class="keyword">try</span> &#123;            <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">null</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 获取list缓存的长度</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lGetListSize</span><span class="params">(String key)</span>&#123;        <span class="keyword">try</span> &#123;            <span class="keyword">return</span> redisTemplate.opsForList().size(key);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="number">0</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 通过索引 获取list中的值</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> index 索引  index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> Object <span class="title function_">lGetIndex</span><span class="params">(String key,<span class="type">long</span> index)</span>&#123;        <span class="keyword">try</span> &#123;            <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">null</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 将list放入缓存</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> value 值</span><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value)</span> &#123;        <span class="keyword">try</span> &#123;            redisTemplate.opsForList().rightPush(key, value);            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 将list放入缓存</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> value 值</span><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;        <span class="keyword">try</span> &#123;            redisTemplate.opsForList().rightPush(key, value);            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) expire(key, time);            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 将list放入缓存</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> value 值</span><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> &#123;        <span class="keyword">try</span> &#123;            redisTemplate.opsForList().rightPushAll(key, value);            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 将list放入缓存</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> value 值</span><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value, <span class="type">long</span> time)</span> &#123;        <span class="keyword">try</span> &#123;            redisTemplate.opsForList().rightPushAll(key, value);            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) expire(key, time);            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 根据索引修改list中的某条数据</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> index 索引</span><span class="comment">     * <span class="doctag">@param</span> value 值</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lUpdateIndex</span><span class="params">(String key, <span class="type">long</span> index,Object value)</span> &#123;        <span class="keyword">try</span> &#123;            redisTemplate.opsForList().set(key, index, value);            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 移除N个值为value</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> count 移除多少个</span><span class="comment">     * <span class="doctag">@param</span> value 值</span><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lRemove</span><span class="params">(String key,<span class="type">long</span> count,Object value)</span> &#123;        <span class="keyword">try</span> &#123;            <span class="type">Long</span> <span class="variable">remove</span> <span class="operator">=</span> redisTemplate.opsForList().remove(key, count, value);            <span class="keyword">return</span> remove;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="number">0</span>;        &#125;    &#125;     &#125;</code></pre><h3 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h3><pre><code class="highlight java"><span class="keyword">package</span> com.how2java; <span class="keyword">import</span> java.util.HashMap;<span class="keyword">import</span> java.util.Map; <span class="keyword">import</span> org.springframework.context.ApplicationContext;<span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext; <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRedis</span> &#123;         <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        ApplicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);         RedisUtil redisUtil=(RedisUtil) context.getBean(<span class="string">&quot;redisUtil&quot;</span>);                 <span class="comment">//=====================testString======================</span>        redisUtil.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;how2java&quot;</span>);        System.out.println(redisUtil.get(<span class="string">&quot;name&quot;</span>));        redisUtil.del(<span class="string">&quot;name&quot;</span>);        System.out.println(redisUtil.get(<span class="string">&quot;name&quot;</span>));                 <span class="comment">//=====================testNumber======================</span>        <span class="type">long</span> <span class="variable">incr</span> <span class="operator">=</span> redisUtil.incr(<span class="string">&quot;number&quot;</span>, <span class="number">1</span>);        System.out.println(incr);        incr =redisUtil.incr(<span class="string">&quot;number&quot;</span>, <span class="number">1</span>);        System.out.println(incr);                 <span class="comment">//=====================testMap======================       </span>        Map&lt;String,Object&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;meepo&quot;</span>);        map.put(<span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;password&quot;</span>);        redisUtil.hmset(<span class="string">&quot;user&quot;</span>, map);        System.out.println(redisUtil.hget(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;name&quot;</span>));    &#125;     &#125;</code></pre><h2 id="redis事务"><a class="markdownIt-Anchor" href="#redis事务"></a> Redis事务</h2><h3 id="redis事务介绍"><a class="markdownIt-Anchor" href="#redis事务介绍"></a> Redis事务介绍</h3><p>Redis的事务是通过<strong>MULTI，EXEC，DISCARD和WATCH</strong>这四个命令来完成的。</p><p>Redis的单个命令都是<strong>原子性</strong>的，所以这里确保事务性的对象是<strong>命令集合</strong>。</p><p>Redis将命令集合序列化并确保处于同一事务的<strong>命令集合连续且不被打断</strong>的执行</p><p>Redis<strong>不支持回滚</strong>操作</p><h3 id="相关命令"><a class="markdownIt-Anchor" href="#相关命令"></a> 相关命令</h3><p><strong>multi</strong></p><p>用于标记事务块的开始</p><p>Redis会将后续的命令逐个放入队列中，然后使用<u>EXEC命令</u>原子化的执行这个命令序列</p><p><strong>exec</strong></p><p><u>在一个事务中执行所有先前放入队列的命令</u>，然后恢复正常的连接状态</p><p><strong>discard</strong></p><p><u>清除所有先前在一个事务中放入队列的命令</u>，然后恢复正常的连接状态</p><p><strong>watch key [key…]</strong></p><p>当某个<strong>事务需要按条件执行时</strong>，就要使用这个命令将给定的<strong>键设置为受监控的状态</strong></p><p>注意事项：使用该命令可以实现redis的<strong>乐观锁</strong></p><p><strong>unwatch</strong></p><p>清除所有先前为一个事务监控的键</p><h3 id="事务失败处理"><a class="markdownIt-Anchor" href="#事务失败处理"></a> 事务失败处理</h3><p><strong>Redis语法错误</strong>（可以理解为编译期错误）</p><ul><li>整个事务都不会执行</li></ul><p><strong>Redis类型错误</strong>（可以理解为运行期错误）</p><ul><li>正确的命令执行</li></ul><p>Redis不支持事务回滚</p><ul><li>大多数事务失败是因为<strong>语法错误或者类型错误</strong>，这两种错误，在开发阶段都是可以预见的</li><li>redis为了<strong>性能方面</strong>就忽略了事务回滚</li></ul><h2 id="redis修改密码"><a class="markdownIt-Anchor" href="#redis修改密码"></a> Redis修改密码</h2><p><code>vim /redis-4.0.11/redis.conf</code>中修改下列代码即可</p><pre><code class="highlight plaintext">requirepass foobared</code></pre><p>保护模式</p><pre><code class="highlight plaintext">protected-mode yes</code></pre><p>端口</p><pre><code class="highlight plaintext">port 6379</code></pre><h2 id="redis实现分布式锁"><a class="markdownIt-Anchor" href="#redis实现分布式锁"></a> Redis实现分布式锁</h2><h3 id="锁的处理"><a class="markdownIt-Anchor" href="#锁的处理"></a> 锁的处理</h3><p>单应用中使用锁：单进程多线程</p><ul><li><strong>synchronize，lock</strong></li></ul><p>分布式应用中使用锁，多进程</p><h3 id="分布式锁的实现方式"><a class="markdownIt-Anchor" href="#分布式锁的实现方式"></a> 分布式锁的实现方式</h3><p>基于数据库的乐观锁实现分布式锁</p><p>基于zookeeper临时节点的分布式锁</p><p>基于redis的分布式锁</p><h3 id="分布式锁的注意事项"><a class="markdownIt-Anchor" href="#分布式锁的注意事项"></a> 分布式锁的注意事项</h3><p><strong>互斥性</strong></p><p>在任意时刻，只有一个客户端能持有锁</p><p><strong>同一性</strong></p><p>加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了</p><p><strong>可重入性</strong></p><p>即使有一个客户端在持有锁的期间奔溃而没有主动解锁，也能保证后续其他客户端能加锁</p><h3 id="实现分布式锁"><a class="markdownIt-Anchor" href="#实现分布式锁"></a> 实现分布式锁</h3><h4 id="组件依赖"><a class="markdownIt-Anchor" href="#组件依赖"></a> 组件依赖</h4><p>首先我们要通过Maven引入Jedis开源组件，在pom.xml文件加入下面的代码：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h4 id="获取锁"><a class="markdownIt-Anchor" href="#获取锁"></a> 获取锁</h4><p><strong>方式一：使用set命令实现</strong>（推荐）</p><p>这个set()方法一共有五个形参：</p><ul><li><strong>第一个为key</strong>，我们使用key来当锁，因为key是唯一的。</li><li><strong>第二个为value</strong>，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。</li><li><strong>第三个为nxxx</strong>，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li><li><strong>第四个为expx</strong>，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</li><li><strong>第五个为time</strong>，与第四个参数相呼应，代表key的过期时间。</li></ul><p>总的来说，执行上面的set()方法就只会导致两种结果：</p><ol><li>当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。</li><li>已有锁存在，不做任何操作。</li></ol><p>心细的童鞋就会发现了，我们的加锁代码满足我们可靠性里描述的三个条件。</p><ul><li>首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。</li><li>其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。</li><li>最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。</li></ul><blockquote><p>由于我们只考虑Redis单机部署的场景，所以容错性我们暂不考虑。</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 使用redis的set命令实现获取分布式锁</span><span class="comment"> * <span class="doctag">@param</span> lockKey   可以就是锁</span><span class="comment"> * <span class="doctag">@param</span> requestId请求ID，保证同一性</span><span class="comment"> * <span class="doctag">@param</span> expireTime过期时间，避免死锁</span><span class="comment"> * <span class="doctag">@return</span></span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">getLock</span><span class="params">(String lockKey,String requestId,<span class="type">int</span> expireTime)</span> &#123;<span class="comment">//NX:保证互斥性</span>    <span class="comment">//参数三：NX/XX  存在设置键/不存在设置建</span>    <span class="comment">//参数四：EX/PX  秒/毫秒</span>    <span class="comment">//参数五：毫秒时间</span><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, expireTime);<span class="keyword">if</span>(<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</code></pre><p><strong>方式二：使用setnx命令实现</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">getLock</span><span class="params">(String lockKey,String requestId,<span class="type">int</span> expireTime)</span> &#123;<span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> jedis.setnx(lockKey, requestId);<span class="keyword">if</span>(result == <span class="number">1</span>) &#123;        <span class="comment">//设置有效期</span>jedis.expire(lockKey, expireTime);<span class="keyword">return</span> <span class="literal">true</span>;&#125;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</code></pre><h4 id="释放锁"><a class="markdownIt-Anchor" href="#释放锁"></a> 释放锁</h4><p><strong>方式一：del命令实现</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 释放分布式锁</span><span class="comment"> * <span class="doctag">@param</span> lockKey</span><span class="comment"> * <span class="doctag">@param</span> requestId</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">(String lockKey,String requestId)</span> &#123;    <span class="keyword">if</span> (requestId.equals(jedis.get(lockKey))) &#123;jedis.del(lockKey);    &#125;&#125;</code></pre><p><strong>方式二：redis+lua脚本实现</strong>（推荐）</p><p>可以看到，我们解锁只需要两行代码就搞定了！</p><ul><li>第一行代码，我们写了一个简单的Lua脚本代码，上一次见到这个编程语言还是在《黑客与画家》里，没想到这次居然用上了。</li><li>第二行代码，我们将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。eval()方法是将Lua代码交给Redis服务端执行。</li></ul><p>那么这段Lua代码的功能是什么呢？</p><ul><li>其实很简单，首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。</li></ul><p>那么为什么要使用Lua语言来实现呢？</p><ul><li>因为要确保上述操作是原子性的。<br />那么为什么执行eval()方法可以确保原子性，源于Redis的特性，下面是官网对eval命令的部分解释：简单来说，就是在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。</li></ul><pre><code class="highlight java">   <span class="comment">/**</span><span class="comment">     * 释放分布式锁</span><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span><span class="comment">     */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">releaseLock</span><span class="params">(String lockKey, String requestId)</span> &#123;<span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));<span class="keyword">if</span> (result.equals(<span class="number">1L</span>)) &#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</code></pre><h2 id="redis持久化方案"><a class="markdownIt-Anchor" href="#redis持久化方案"></a> Redis持久化方案</h2><p>Redis是一个<strong>内存</strong>数据库，为了保证数据的持久新，它提供了两种持久化方案</p><ul><li>REB方式（默认）</li><li>AOF方式</li></ul><h3 id="rdb方式"><a class="markdownIt-Anchor" href="#rdb方式"></a> RDB方式</h3><p>RDB是Redis<strong>默认</strong>采用的持久化方式。</p><p>RDB方式是通过<strong>快照</strong>（snapshotting）完成的，当<strong>符合一定条件</strong>时Redis会自动将内存中的数据进行快照并持久化到硬盘</p><p>Redis会在<strong>指定的情况</strong>下触发快照</p><ul><li><strong>符合自定义配置的快照规则</strong></li><li><strong>执行save或者bgsave命令</strong></li><li><strong>执行flushall命令</strong></li><li><strong>执行主从复制操作</strong></li></ul><h4 id="配置步骤"><a class="markdownIt-Anchor" href="#配置步骤"></a> 配置步骤</h4><p>在<strong>redis.conf</strong>中设置自定义快照规则</p><p><strong>1.RDB持久化条件</strong></p><pre><code class="highlight plaintext">save &lt;seconds&gt; &lt;changes&gt;</code></pre><p>示例：</p><ul><li>save 900 1  ： 表示15分钟（900秒钟）内至少1个键被更改则进行快照。</li><li>save 300 10 ： 表示5分钟（300秒）内至少10个键被更改则进行快照。</li><li>save 60 10000 ：表示1分钟内至少10000个键被更改则进行快照</li></ul><blockquote><p>可以<strong>配置多个条件</strong>（每行配置一个条件），每个条件之间是“<strong>或</strong>”的关系</p></blockquote><p><strong>2.配置dir指定rdb快照文件的位置</strong></p><pre><code class="highlight plaintext"># Note that you must specify a directory here, not a file name.dir ./</code></pre><p><strong>3.配置dbfilename指定rdb快照文件的名称</strong></p><pre><code class="highlight plaintext"># The filename where to dump the DBdbfilename dump.rdb</code></pre><blockquote><p>Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。</p></blockquote><blockquote><p>根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟</p></blockquote><p><strong>关闭方式</strong></p><p>注释掉下面的三行代码即可</p><pre><code class="highlight plaintext">save 900 1save 300 10save 60 10000</code></pre><h4 id="快照的实现原理"><a class="markdownIt-Anchor" href="#快照的实现原理"></a> 快照的实现原理</h4><p><strong>快照过程</strong></p><p>redis使用fork函数<strong>复制</strong>一份当前进程的<strong>副本</strong>(子进程)</p><p><strong>父进程</strong>继续接收并处理客户端发来的命令，而<strong>子进程</strong>开始将内存中的数据写入硬盘中的临时文件。</p><p>当子进程写入完所有数据后会<strong>用该临时文件替换旧的RDB文件</strong>，至此，一次快照操作完成</p><p><strong>注意事项</strong></p><blockquote><p>redis在进行<strong>快照的过程中不会修改RDB文件</strong>，只有快照结束后才会将旧的文件替换成新的，也就是说任何时候RDB文件都是完整的。</p></blockquote><blockquote><p>这就使得我们可以通过定时备份RDB文件来实现redis数据库的备份，<strong>RDB文件是经过压缩的二进制文件</strong>，占用的空间会小于内存中的数据，更加利于传输</p></blockquote><h4 id="rdb的优缺点"><a class="markdownIt-Anchor" href="#rdb的优缺点"></a> RDB的优缺点</h4><p><strong>缺点</strong></p><p>使用RDB方式实现持久化，一旦Redis异常退出，就会<strong>丢失最后一次快照以后更改的所有数据</strong>。这个时候我们就需要根据具体的应用场景，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受范围。如果数据相对来说比较重要，希望将损失降到最小，则可以使用<strong>AOF</strong>方式进行持久化</p><p><strong>优点</strong></p><p>RDB可以最大化Redis的性能：父进程在保存RDB文件时唯一要做的就是fork出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无序执行任何磁盘I/O操作。同时这个也是一个缺点，如果数据集比较大的时候，fork可以能比较耗时，造成服务器在一段时间内停止处理客户端的请求</p><h3 id="aof方式"><a class="markdownIt-Anchor" href="#aof方式"></a> AOF方式</h3><p>默认情况下Redis没有开启AOF（append only file）方式的持久化</p><p>开启AOF持久化后每执行一条<strong>会更改Redis中的数据的命令</strong>，Redis就会将该命令写入硬盘中的AOF文件，这一过程显然会<strong>降低Redis的性能</strong>，但大部分情况下这个影响是能够接受的，另外使<strong>用较快的硬盘可以提高AOF的性能</strong></p><h4 id="开启方式"><a class="markdownIt-Anchor" href="#开启方式"></a> 开启方式</h4><p>可以通过修改<strong>redis.conf</strong>配置文件中的appendonly参数开启</p><pre><code class="highlight plaintext">appendonly yes</code></pre><p>AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的</p><pre><code class="highlight plaintext">dir ./</code></pre><p>默认的文件名是appendonly.aof，可以通过appendfilename参数修改</p><pre><code class="highlight plaintext">appendfilename appendonly.aof</code></pre><h4 id="aof重写原理优化aof文件"><a class="markdownIt-Anchor" href="#aof重写原理优化aof文件"></a> AOF重写原理（优化AOF文件）</h4><p>Redis 可以在 AOF<strong>文件体积变得过大</strong>时，自动地在后台对 AOF 进行<strong>重写</strong></p><p>重写后的新 AOF 文件包含了恢复当前数据集所需的<strong>最小命令集合</strong>。</p><p>整个重写操作是绝对安全的，因为 Redis 在创建<strong>新 AOF 文件的</strong>过程中，会继续将命令追加到<strong>现有的 AOF 文件</strong>里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦<strong>新 AOF 文件</strong>创建完毕，Redis 就会从旧 AOF 文件<strong>切换</strong>到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</p><p>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松</p><p><strong>参数说明</strong></p><p>表示当前aof文件大小超过上一次aof文件大小的百分之多少的时候会进行重写。如果之前没有重写过，以启动时aof文件大小为准</p><pre><code class="highlight plaintext"># auto-aof-rewrite-percentage 100</code></pre><p>限制允许重写最小aof文件大小，也就是文件大小小于64mb的时候，不需要进行优化</p><pre><code class="highlight plaintext"># auto-aof-rewrite-min-size 64mb</code></pre><h4 id="同步磁盘数据"><a class="markdownIt-Anchor" href="#同步磁盘数据"></a> 同步磁盘数据</h4><p>Redis每次更改数据的时候， aof机制都会将命令记录到aof文件，但是实际上由于操作系统的缓存机制，数据并没有实时写入到硬盘，而是进入硬盘缓存。再通过硬盘缓存机制去刷新到保存到文件</p><p><strong>参数说明</strong></p><p>每次执行写入都会进行同步  ， 这个是最安全但是是效率比较低的方式</p><pre><code class="highlight plaintext">appendfsync always</code></pre><p>每一秒执行（推荐）</p><pre><code class="highlight plaintext">appendfsync everysec</code></pre><p>不主动进行同步操作，由操作系统去执行，这个是最快但是最不安全的方式</p><pre><code class="highlight plaintext">appendfsync no</code></pre><h4 id="aof文件损坏后如何修复"><a class="markdownIt-Anchor" href="#aof文件损坏后如何修复"></a> AOF文件损坏后如何修复</h4><p>服务器可能在程序正在对 AOF 文件进行写入时停机， 如果停机造成了 AOF 文件出错（corrupt）， 那么 Redis 在重启时会拒绝载入这个 AOF 文件， 从而确保数据的一致性不会被破坏</p><p><strong>当发生这种情况时， 可以用以下方法来修复出错的 AOF 文件：</strong></p><ol><li><p>为现有的 AOF 文件创建一个备份。</p></li><li><p>使用 Redis 附带的 redis-check-aof 程序，对原来的 AOF 文件进行修复。</p></li></ol><pre><code class="highlight plaintext">redis-check-aof --fix readonly.aof</code></pre><ol start="3"><li>重启 Redis 服务器，等待服务器载入修复后的 AOF 文件，并进行数据恢复</li></ol><h3 id="如何选择rdb和aof"><a class="markdownIt-Anchor" href="#如何选择rdb和aof"></a> 如何选择RDB和AOF</h3><p>一般来说,如果对数据的安全性要求非常高的话，应该同时使用两种持久化功能。</p><p>如果可以承受数分钟以内的数据丢失，那么可以只使用 RDB 持久化。</p><p>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快 。</p><p>两种持久化策略可以同时使用，也可以使用其中一种。如果同时使用的话， 那么Redis重启时，会优先使用AOF文件来还原数据</p><h2 id="redis主从复制"><a class="markdownIt-Anchor" href="#redis主从复制"></a> Redis主从复制</h2><p><strong>从机 只可以读，不可以写</strong></p><p>持久化保证了即使redis服务重启也不会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，不过通过redis的主从复制机制就可以避免这种单点故障</p><p>说明：</p><ul><li><p>主redis中的数据有两个副本（replication）即从redis1和从redis2，即使一台redis服务器宕机其它两台redis服务也可以继续提供服务。</p></li><li><p>主redis中的数据和从redis上的数据保持实时同步，当<strong>主redis写入数据时通过主从复制机制会复制到两个从redis服务上</strong>。</p></li><li><p>只有一个主redis，可以有多个从redis。</p></li><li><p>主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求</p></li><li><p>一个redis可以即是主又是从，如下图：</p></li></ul><h3 id="主从配置"><a class="markdownIt-Anchor" href="#主从配置"></a> 主从配置</h3><p><strong>主redis配置</strong></p><p>无需特殊的配置</p><p><strong>从redis配置（从机只可读）</strong></p><p>修改从服务器上的redis.conf文件</p><pre><code class="highlight plaintext"># slaveof &lt;masterip&gt; &lt;masterport&gt;slaveof 192.168.101.3 6379</code></pre><blockquote><p>上边的配置说明当前【从服务器】对应的【主服务器】的IP是192.168.101.3，端口是6379</p></blockquote><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><ol><li><p>slave第一次或者重连到master上以后，会向master发送一个<strong>SYNC</strong>的命令</p></li><li><p>master收到SYNC的时候，会做两件事<br />a)    执行<strong>bgsave</strong>（rdb的快照文件）<br />b)    master会把新收到的修改命令存入到缓冲区</p></li></ol><blockquote><p>缺点：<strong>没有办法对master进行动态选举</strong>(使用哨兵实现)</p></blockquote><hr /><p>Redis的主从同步，分为<strong>全量同步</strong>和<strong>增量同步</strong>。</p><p>只有从机第一次连接上主机是全量同步</p><p>断线重连有可能触发全量同步也有可能是增量同步（master判断runid是否一致）</p><p>除此之外的情况都是增量同步</p><h4 id="全量同步"><a class="markdownIt-Anchor" href="#全量同步"></a> 全量同步</h4><p>Redis的全量同步过程主要分三个阶段：</p><ul><li><p>同步快照阶段：Master创建并发送<strong>快照</strong>给Slave,Slave载入并解析快照。Master同时将此阶段所产生的新的写命令存储到缓冲区。</p></li><li><p>同步写缓冲阶段：Master向Slave同步存储在缓冲区的写操作命令。</p></li><li><p>同步增量阶段：Master向Slave同步写操作命令。</p></li></ul><h4 id="增量同步"><a class="markdownIt-Anchor" href="#增量同步"></a> 增量同步</h4><ul><li><p>Redis增量同步主要指<strong>Slave完成初始化后开始正常工作</strong>时，<strong>Master发生的写操作同步到Slave的过程</strong>。</p></li><li><p>通常情况下，Master每执行一个写命令就会向Slave发送相同的<strong>写命令</strong>，然后Slave接收并执行。</p></li></ul><h2 id="redis-sentinel哨兵机制"><a class="markdownIt-Anchor" href="#redis-sentinel哨兵机制"></a> Redis Sentinel哨兵机制</h2><p><strong>Redis主从复制的缺点：没有办法对master进行动态选举，需要使用Sentinel机制完成动态选举</strong></p><p>Sentinel(哨兵)进程是用于<strong>监控redis集群中Master主服务器工作的状态</strong></p><p>在Master主服务器发生故障的时候，可以实现Master和Slave服务器的切换，保证系统的高可用（HA）</p><p>其已经被集成在redis2.6+的版本中，Redis的哨兵模式到了2.8版本之后就稳定了下来</p><h3 id="哨兵进程的作用"><a class="markdownIt-Anchor" href="#哨兵进程的作用"></a> 哨兵进程的作用</h3><p><strong>监控(Monitoring）</strong>: 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。</p><p><strong>提醒(Notification）</strong>： 当被监控的某个Redis节点出现问题时, 哨兵(sentinel) 可以通过API 向管理员或者其他应用程序发送通知。</p><p><strong>自动故障迁移(Automatic failover）</strong>：当一个Master不能正常工作时，哨兵(sentinel)<br />会开始一次自动故障迁移操作。</p><ul><li><p>它会将失效Master的其中一个Slave升级为新的Master, 并让失效Master的其他Slave改为复制新的Master；</p></li><li><p>当客户端试图连接失效的Master时，集群也会向客户端返回新Master的地址，使得集群可以使用现在的Master替换失效Master。</p></li><li><p>Master和Slave服务器切换后，Master的redis.conf、Slave的redis.conf和sentinel.conf的配置文件的内容都会发生相应的改变，即，Master主服务器的redis.conf配置文件中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换。</p></li></ul><h3 id="哨兵进程的工作原理"><a class="markdownIt-Anchor" href="#哨兵进程的工作原理"></a> 哨兵进程的工作原理</h3><ol><li><p>每个Sentinel（哨兵）进程以<strong>每秒钟一次</strong>的频率向整个集群中的<strong>Master主服务器</strong>，<strong>Slave从服务器以及其他Sentinel（哨兵）进程</strong>发送一个 <strong>PING</strong> 命令。</p></li><li><p>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过<br /><code>down-after-milliseconds</code> 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进<strong>程标记为主观下线（SDOWN）</strong>。</p></li><li><p>如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的<strong>所有 Sentinel（哨兵）<strong>进程要以每秒一次的频率</strong>确认Master主服务器</strong>的确<strong>进入了主观下线状态</strong>。</p></li><li><p>当<strong>有足够数量的 Sentinel（哨兵）进程</strong>（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为<strong>客观下线（ODOWN）</strong>。</p></li><li><p>在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。</p></li><li><p>当Master主服务器被 Sentinel（哨兵）进程标记为**客观下线（ODOWN）**时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</p></li><li><p>若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。</p></li></ol><h3 id="开启方式-2"><a class="markdownIt-Anchor" href="#开启方式-2"></a> 开启方式</h3><p><strong>修改从机(从机主机都可以)的sentinel.conf</strong></p><blockquote><p>sentinel.conf该文件需要从redis解压包中找到并拷贝到redis安装目录</p></blockquote><blockquote><p>哨兵的端口默认26379</p></blockquote><p><code>master ip</code>：主机的ip地址<br /><code>master-name</code>：reids的名字（非必须）<br /><code>quorum</code>：表示投票后，执行命令的最少人数</p><pre><code class="highlight shell"><span class="meta prompt_">#</span><span class="language-bash">sentinel monitor &lt;master-name&gt; &lt;master ip&gt; &lt;master port&gt; &lt;quorum&gt;</span>sentinel monitor mymaster 192.168.10.133 6379 1</code></pre><p>其他配置项说明</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">Example sentinel.conf</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">哨兵sentinel实例运行的端口 默认26379</span>port 26379<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">哨兵sentinel的工作目录</span>dir /tmp<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">哨兵sentinel监控的redis主节点的 ip port</span> <span class="meta prompt_"># </span><span class="language-bash">master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符<span class="string">&quot;.-_&quot;</span>组成。</span><span class="meta prompt_"># </span><span class="language-bash">quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span><span class="meta prompt_"># </span><span class="language-bash">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span>  sentinel monitor mymaster 127.0.0.1 6379 2<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span><span class="meta prompt_"># </span><span class="language-bash">设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span><span class="meta prompt_"># </span><span class="language-bash">sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span>sentinel auth-pass mymaster MySUPER--secret-0123passw0rd<span class="meta prompt_"></span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span><span class="meta prompt_"># </span><span class="language-bash">sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span>sentinel down-after-milliseconds mymaster 30000<span class="meta prompt_"> </span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><span class="meta prompt_"># </span><span class="language-bash">sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span>sentinel parallel-syncs mymaster 1<span class="meta prompt_"></span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span> <span class="meta prompt_">#</span><span class="language-bash">1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span><span class="meta prompt_">#</span><span class="language-bash">2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span><span class="meta prompt_">#</span><span class="language-bash">3.当想要取消一个正在进行的failover所需要的时间。</span>  <span class="meta prompt_">#</span><span class="language-bash">4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span><span class="meta prompt_"># </span><span class="language-bash">默认三分钟</span><span class="meta prompt_"># </span><span class="language-bash">sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span>sentinel failover-timeout mymaster 180000<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">SCRIPTS EXECUTION</span><span class="meta prompt_">#</span><span class="language-bash">配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span><span class="meta prompt_">#</span><span class="language-bash">对于脚本的运行结果有以下规则：</span><span class="meta prompt_">#</span><span class="language-bash">若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span><span class="meta prompt_">#</span><span class="language-bash">若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span><span class="meta prompt_">#</span><span class="language-bash">如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span><span class="meta prompt_">#</span><span class="language-bash">一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span><span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span><span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">通知脚本</span><span class="meta prompt_"># </span><span class="language-bash">sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span>  sentinel notification-script mymaster /var/redis/notify.sh<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">客户端重新配置主节点参数脚本</span><span class="meta prompt_"># </span><span class="language-bash">当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span><span class="meta prompt_"># </span><span class="language-bash">以下参数将会在调用脚本时传给脚本:</span><span class="meta prompt_"># </span><span class="language-bash">&lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><span class="meta prompt_"># </span><span class="language-bash">目前&lt;state&gt;总是“failover”,</span><span class="meta prompt_"># </span><span class="language-bash">&lt;role&gt;是“leader”或者“observer”中的一个。</span> <span class="meta prompt_"># </span><span class="language-bash">参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span><span class="meta prompt_"># </span><span class="language-bash">这个脚本应该是通用的，能被多次调用，不是针对性的。</span><span class="meta prompt_"># </span><span class="language-bash">sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span> sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</code></pre><p><strong>通过redis-sentinel启动</strong>哨兵服务</p><pre><code class="highlight plaintext">./redis-sentinel sentinel.conf</code></pre><blockquote><p>可以使用<code>info replication</code>命令查看当前主机redis的属性</p></blockquote><h2 id="redis-cluster集群"><a class="markdownIt-Anchor" href="#redis-cluster集群"></a> Redis Cluster集群</h2><p>redis3.0以后推出的redis cluster 集群方案，redis cluster集群保证了高可用、高性能、高可扩展性</p><p>redis cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份，当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点(<strong>Redis Cluster有内置复用哨兵的部分代码，不用单独开启哨兵进程</strong>)，从而保证集群不会挂掉</p><blockquote><p>Redis Cluster不用单独的配置主从，也不用单独的配置哨兵</p></blockquote><h3 id="redis-cluster架构图"><a class="markdownIt-Anchor" href="#redis-cluster架构图"></a> Redis Cluster架构图</h3><p>架构细节:<br />(1) 所有的redis节点彼此互联(<strong>PING-PONG机制</strong>),内部使用二进制协议优化传输速度和带宽.<br />(2) 节点的fail是通过集群中超过半数的节点检测失效时才生效.<br />(3) 客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可<br />(4) redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护<br /><strong>node &lt; -&gt; slot&lt;-&gt;value</strong><br />redis节点&lt;-&gt;槽&lt;-&gt;值</p><blockquote><p><strong>在创建redis cluster的时候，需要根据redis的节点数分配槽</strong></p></blockquote><blockquote><p>Redis 集群中内置了 <strong>16384 个哈希槽</strong>，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点</p></blockquote><h3 id="redis-cluster投票容错"><a class="markdownIt-Anchor" href="#redis-cluster投票容错"></a> Redis Cluster投票：容错</h3><p>最小节点数：<strong>3台</strong></p><p>(1)<strong>节点失效判断</strong>：集群中所有master参与投票,如果<u>半数以上master节点</u>与其中一个master节点通信超过(<u>cluster-node-timeout</u>超时时间    ),认为该master节点挂掉.<br />(2)<strong>集群失效判断</strong>:什么时候整个集群不可用(cluster_state:fail)?</p><ul><li>如果集群任意master挂掉,且当前master没有slave，则集群进入fail状态。也可以理解成集群的[0-16383]slot映射不完全时进入fail状态。</li><li>如果集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态</li></ul><h3 id="安装ruby环境"><a class="markdownIt-Anchor" href="#安装ruby环境"></a> 安装Ruby环境</h3><p>redis集群需要使用集群<strong>管理脚本redis-trib.rb</strong>，它的执行相应依赖ruby环境</p><ol><li>安装ruby</li></ol><pre><code class="highlight plaintext">yum install rubyyum install rubygems</code></pre><ol start="2"><li>安装ruby和redis的接口程序redis-3.2.2.gem</li></ol><pre><code class="highlight plaintext">gem install redis -V 3.2.2</code></pre><ol start="3"><li>复制redis-3.2.9/src/redis-trib.rb文件到/usr/local/redis目录</li></ol><pre><code class="highlight plaintext">cp redis-3.2.9/src/redis-trib.rb /usr/local/redis-cluster/ -r</code></pre><h3 id="安装redis集群"><a class="markdownIt-Anchor" href="#安装redis集群"></a> 安装Redis集群</h3><p>Redis集群最少需要<strong>三台主服务器，三台从服务器</strong>。</p><p><em>因为我们没有6太服务器，所以就是用一台机器的不同端口号来演示，实际上是6太机器，端口号相同，ip地址不同</em></p><p>端口号分别为：<strong>7001~7006</strong></p><blockquote><p><strong>注意事项</strong>：6个节点必须是空的，没有任何的数据</p></blockquote><p><strong>第一步</strong>：创建7001实例，并编辑redis.conf文件，修改port为7001。</p><blockquote><p>注意：创建实例，即拷贝单机版安装时，生成的bin目录，为7001目录</p></blockquote><p><strong>第二步</strong>：修改redis.conf配置文件，打开<code>Cluster-enable yes</code></p><p><strong>第三步</strong>：复制7001，创建7002~7006实例，<strong>注意端口修改</strong>。</p><p><strong>第四步</strong>：启动所有的实例</p><ul><li>可以写一个一键启动的脚本<code>start-all.sh</code></li></ul><p><strong>第五步</strong>：创建Redis集群（在redis-cluster<br />目录下）</p><ul><li>create表示创建集群</li><li>–replicas表示主从复制的副本数，1表示一主一从，2表示一主两从，3表示一主三从</li><li>该示例前边三个是主节点，后面三个是从节点</li><li>执行命令后<code>./redis-trib.rb create --replicas 1</code> 后续还需输入 <code>yes</code></li></ul><pre><code class="highlight plaintext">./redis-trib.rb create --replicas 1 192.168.10.133:7001 192.168.10.133:7002 192.168.10.133:7003 192.168.10.133:7004 192.168.10.133:7005  192.168.10.133:7006&gt;&gt;&gt; Creating clusterConnecting to node 192.168.10.133:7001: OKConnecting to node 192.168.10.133:7002: OKConnecting to node 192.168.10.133:7003: OKConnecting to node 192.168.10.133:7004: OKConnecting to node 192.168.10.133:7005: OKConnecting to node 192.168.10.133:7006: OK&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Using 3 masters:192.168.10.133:7001192.168.10.133:7002192.168.10.133:7003Adding replica 192.168.10.133:7004 to 192.168.10.133:7001Adding replica 192.168.10.133:7005 to 192.168.10.133:7002Adding replica 192.168.10.133:7006 to 192.168.10.133:7003M: d8f6a0e3192c905f0aad411946f3ef9305350420 192.168.10.133:7001   slots:0-5460 (5461 slots) masterM: 7a12bc730ddc939c84a156f276c446c28acf798c 192.168.10.133:7002   slots:5461-10922 (5462 slots) masterM: 93f73d2424a796657948c660928b71edd3db881f 192.168.10.133:7003   slots:10923-16383 (5461 slots) masterS: f79802d3da6b58ef6f9f30c903db7b2f79664e61 192.168.10.133:7004   replicates d8f6a0e3192c905f0aad411946f3ef9305350420S: 0bc78702413eb88eb6d7982833a6e040c6af05be 192.168.10.133:7005   replicates 7a12bc730ddc939c84a156f276c446c28acf798cS: 4170a68ba6b7757e914056e2857bb84c5e10950e 192.168.10.133:7006   replicates 93f73d2424a796657948c660928b71edd3db881fCan I set the above configuration? (type &#x27;yes&#x27; to accept): yes&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join....&gt;&gt;&gt; Performing Cluster Check (using node 192.168.10.133:7001)M: d8f6a0e3192c905f0aad411946f3ef9305350420 192.168.10.133:7001   slots:0-5460 (5461 slots) masterM: 7a12bc730ddc939c84a156f276c446c28acf798c 192.168.10.133:7002   slots:5461-10922 (5462 slots) masterM: 93f73d2424a796657948c660928b71edd3db881f 192.168.10.133:7003   slots:10923-16383 (5461 slots) masterM: f79802d3da6b58ef6f9f30c903db7b2f79664e61 192.168.10.133:7004   slots: (0 slots) master   replicates d8f6a0e3192c905f0aad411946f3ef9305350420M: 0bc78702413eb88eb6d7982833a6e040c6af05be 192.168.10.133:7005   slots: (0 slots) master   replicates 7a12bc730ddc939c84a156f276c446c28acf798cM: 4170a68ba6b7757e914056e2857bb84c5e10950e 192.168.10.133:7006   slots: (0 slots) master   replicates 93f73d2424a796657948c660928b71edd3db881f[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered.[root@localhost-0723 redis]#</code></pre><h3 id="命令客户端连接集群"><a class="markdownIt-Anchor" href="#命令客户端连接集群"></a> 命令客户端连接集群</h3><pre><code class="highlight plaintext">./redis-cli –h 127.0.0.1 –p 7001 –c</code></pre><blockquote><p>注意：-c 表示是以redis集群方式进行连接</p></blockquote><pre><code class="highlight shell">./redis-cli -p 7006 -c127.0.0.1:7006&gt; set key1 123<span class="meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [9189] located at 127.0.0.1:7002</span>OK127.0.0.1:7002&gt;</code></pre><h3 id="查看集群命令"><a class="markdownIt-Anchor" href="#查看集群命令"></a> 查看集群命令</h3><p>查看集群状态</p><pre><code class="highlight plaintext">127.0.0.1:7003&gt; cluster infocluster_state:okcluster_slots_assigned:16384cluster_slots_ok:16384cluster_slots_pfail:0cluster_slots_fail:0cluster_known_nodes:6cluster_size:3cluster_current_epoch:6cluster_my_epoch:3cluster_stats_messages_sent:926cluster_stats_messages_received:926</code></pre><p>查看集群中的节点</p><pre><code class="highlight plaintext">127.0.0.1:7003&gt; cluster nodes7a12bc730ddc939c84a156f276c446c28acf798c 127.0.0.1:7002 master - 0 1443601739754 2 connected 5461-1092293f73d2424a796657948c660928b71edd3db881f 127.0.0.1:7003 myself,master - 0 0 3 connected 10923-16383d8f6a0e3192c905f0aad411946f3ef9305350420 127.0.0.1:7001 master - 0 1443601741267 1 connected 0-54604170a68ba6b7757e914056e2857bb84c5e10950e 127.0.0.1:7006 slave 93f73d2424a796657948c660928b71edd3db881f 0 1443601739250 6 connectedf79802d3da6b58ef6f9f30c903db7b2f79664e61 127.0.0.1:7004 slave d8f6a0e3192c905f0aad411946f3ef9305350420 0 1443601742277 4 connected0bc78702413eb88eb6d7982833a6e040c6af05be 127.0.0.1:7005 slave 7a12bc730ddc939c84a156f276c446c28acf798c 0 1443601740259 5 connected127.0.0.1:7003&gt;</code></pre><h3 id="维护节点"><a class="markdownIt-Anchor" href="#维护节点"></a> 维护节点</h3><p>集群创建成功后可以继续向集群中添加节点</p><p><strong>添加主节点</strong></p><p>先创建7007节点，添加7007结点作为新节点</p><pre><code class="highlight plaintext">./redis-trib.rb add-node 127.0.0.1:7007 127.0.0.1:7001</code></pre><p>查看集群节点发现7007已经添加到集群中了</p><p><strong>hash槽重新分配（数据迁移）</strong></p><p>添加完主节点需要对主节点进行hash槽分配，这样该主节才可以存储数据</p><p>查看集群中槽占用情况</p><ul><li>redis集群有16384个槽，集群中的每个结点分配自已槽，通过查看集群结点可以看到槽占用情况</li></ul><p>给刚添加的7007节点分配槽</p><ol><li>连接上集群（连接集群中任意一个可用节点都行）</li></ol><pre><code class="highlight plaintext">./redis-trib.rb reshard 192.168.10.133:7001</code></pre><ol start="2"><li>输入要分配的槽数量</li></ol><blockquote><p>输入：3000，表示要给目标节点分配3000个槽</p></blockquote><ol start="3"><li>输入接受槽点的节点id</li></ol><blockquote><p>PS：这里准备给7007分配槽，通过cluster nodes查看7007结点id为：<code>15b809eadae88955e36bcdbb8144f61bbbaf38fb</code></p></blockquote><ol start="4"><li>输入源节点id</li></ol><pre><code class="highlight plaintext">输入：all</code></pre><ol start="5"><li>输入yes开始移动槽到目标节点</li></ol><p><strong>添加从节点</strong></p><p>语法：</p><pre><code class="highlight plaintext">./redis-trib.rb add-node --slave --master-id  主节点id   新节点的ip和端口   旧节点ip和端口（集群中任一节点都可以）</code></pre><p>添加7008从节点，将7008作为7007的从节点，执行如下命令</p><pre><code class="highlight plaintext">./redis-trib.rb add-node --slave --master-id  35da64607a02c9159334a19164e68dd95a3b943c 192.168.10.103:7008 192.168.10.103:7001</code></pre><blockquote><p><code>35da64607a02c9159334a19164e68dd95a3b943c</code>是7007结点的id，可通过<code>cluster nodes</code>查看</p></blockquote><blockquote><p>注意：如果原来该结点在集群中的配置信息已经生成到cluster-config-file指定的配置文件中（如果cluster-config-file没有指定则默认为nodes.conf），这时可能会报错：<code>[ERR] Node XXXXXX is not empty. Either the node already knows other nodes (check with  CLUSTER NODES) or contains some key in database 0</code></p></blockquote><blockquote><p>解决方法是删除生成的配置文件<code>nodes.conf</code>，删除后再执行<code>./redis-trib.rb add-node</code>指令</p></blockquote><p>查看集群中的结点，刚添加的7008为7007的从节点：</p><p><strong>删除节点</strong></p><pre><code class="highlight plaintext">./redis-trib.rb del-node 127.0.0.1:7005 4b45eb75c8b428fbd77ab979b85080146a9bc017</code></pre><p>删除已经占有hash槽的结点会失败，报错如下：</p><p><code>[ERR] Node 127.0.0.1:7005 is not empty! Reshard data away and try again.</code></p><p>需要将该结点占用的hash槽分配出去（参考hash槽重新分配章节）</p><h3 id="jedis连接集群"><a class="markdownIt-Anchor" href="#jedis连接集群"></a> Jedis连接集群</h3><p>需要开启防火墙，或者直接关闭防火墙</p><pre><code class="highlight plaintext">service iptables stop</code></pre><h4 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h4><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJedisCluster</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;<span class="comment">//创建一连接，JedisCluster对象,在系统中是单例存在</span>Set&lt;HostAndPort&gt; nodes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.10.133&quot;</span>, <span class="number">7001</span>));nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.10.133&quot;</span>, <span class="number">7002</span>));nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.10.133&quot;</span>, <span class="number">7003</span>));nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.10.133&quot;</span>, <span class="number">7004</span>));nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.10.133&quot;</span>, <span class="number">7005</span>));nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.10.133&quot;</span>, <span class="number">7006</span>));<span class="type">JedisCluster</span> <span class="variable">cluster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisCluster</span>(nodes);<span class="comment">//执行JedisCluster对象中的方法，方法和redis一一对应。</span>cluster.set(<span class="string">&quot;cluster-test&quot;</span>, <span class="string">&quot;my jedis cluster test&quot;</span>);<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> cluster.get(<span class="string">&quot;cluster-test&quot;</span>);System.out.println(result);<span class="comment">//程序结束时需要关闭JedisCluster对象</span>cluster.close();&#125;</code></pre><h4 id="使用spring"><a class="markdownIt-Anchor" href="#使用spring"></a> 使用spring</h4><p>配置applicationContext.xml</p><pre><code class="highlight xml"><span class="comment">&lt;!-- 连接池配置 --&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisPoolConfig&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisPoolConfig&quot;</span>&gt;</span><span class="comment">&lt;!-- 最大连接数 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxTotal&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span> /&gt;</span><span class="comment">&lt;!-- 最大空闲连接数 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span><span class="comment">&lt;!-- 每次释放连接的最大数目 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;numTestsPerEvictionRun&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1024&quot;</span> /&gt;</span><span class="comment">&lt;!-- 释放连接的扫描间隔（毫秒） --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30000&quot;</span> /&gt;</span><span class="comment">&lt;!-- 连接最小空闲时间 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1800000&quot;</span> /&gt;</span><span class="comment">&lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;softMinEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span><span class="comment">&lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWaitMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1500&quot;</span> /&gt;</span><span class="comment">&lt;!-- 在获取连接的时候检查有效性, 默认false --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span><span class="comment">&lt;!-- 在空闲时检查有效性, 默认false --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span><span class="comment">&lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;blockWhenExhausted&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="comment">&lt;!-- redis集群 --&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisCluster&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisCluster&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">set</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.101.3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7001&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.101.3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7002&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.101.3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7003&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.101.3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7004&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.101.3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7005&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.101.3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7006&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;/<span class="name">set</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jedisPoolConfig&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre><p>测试代码</p><pre><code class="highlight java"><span class="keyword">private</span> ApplicationContext applicationContext;<span class="meta">@Before</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;applicationContext = <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);&#125;<span class="comment">// redis集群</span><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJedisCluster</span><span class="params">()</span> &#123;<span class="type">JedisCluster</span> <span class="variable">jedisCluster</span> <span class="operator">=</span> (JedisCluster) applicationContext.getBean(<span class="string">&quot;jedisCluster&quot;</span>);jedisCluster.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> jedisCluster.get(<span class="string">&quot;name&quot;</span>);System.out.println(value);&#125;</code></pre><h2 id="redislua整合使用"><a class="markdownIt-Anchor" href="#redislua整合使用"></a> Redis+LUA整合使用</h2><p>Lua 是一种轻量小巧的<strong>脚本语言</strong>，用标准<strong>C语言</strong>编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能</p><h3 id="redis中使用lua的好处"><a class="markdownIt-Anchor" href="#redis中使用lua的好处"></a> Redis中使用LUA的好处</h3><ol><li><p><strong>减少网络开销</strong>，在Lua脚本中可以把多个命令放在同一个脚本中运行</p></li><li><p><strong>原子操作</strong>，redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。换句话说，编写脚本的过程中无需担心会出现竞态条件</p></li><li><p><strong>复用性</strong>，客户端发送的脚本会永远存储在redis中，这意味着其他客户端可以复用这一脚本来完成同样的逻辑</p></li></ol><h3 id="lua的安装学习lua时安装"><a class="markdownIt-Anchor" href="#lua的安装学习lua时安装"></a> <s>LUA的安装（学习lua时安装）</s></h3><p><strong>下载</strong></p><p>地址：<u><a href="http://www.lua.org/download.html">http://www.lua.org/download.html</a></u></p><p>可以本地下载上传到linux，也可以使用curl命令在linux系统中进行在线下载</p><pre><code class="highlight plaintext">curl -R -O http://www.lua.org/ftp/lua-5.3.5.tar.gz</code></pre><p><strong>安装</strong></p><pre><code class="highlight plaintext">yum -y install readline-devel ncurses-develtar -zxvf lua-5.3.5.tar.gzmake linuxmake install</code></pre><p>如果报错，说找不到readline/readline.h, 可以通过yum命令安装</p><pre><code class="highlight plaintext">yum -y install readline-devel ncurses-devel</code></pre><p>安装完以后再make linux  / make install</p><p>最后，直接输入 lua命令即可进入lua的控制台</p><h3 id="lua常见语法"><a class="markdownIt-Anchor" href="#lua常见语法"></a> LUA常见语法</h3><p>详见：<u><a href="http://www.runoob.com/lua/lua-tutorial.html">http://www.runoob.com/lua/lua-tutorial.html</a></u></p><h3 id="redis-lua整合使用"><a class="markdownIt-Anchor" href="#redis-lua整合使用"></a> Redis + LUA整合使用</h3><p><u><em>在redis中使用LUA不需要安装LUA，redis内置了</em></u></p><p>从Redis2.6.0版本开始，通过<strong>内置的Lua解释器</strong>，可以使用EVAL命令对Lua脚本进行求值</p><h4 id="相关命令-2"><a class="markdownIt-Anchor" href="#相关命令-2"></a> 相关命令</h4><p><strong>eval命令</strong></p><pre><code class="highlight plaintext">EVAL script numkeys key [key ...] arg [arg ...]</code></pre><p>命令说明：</p><ul><li><p><code>script参数</code>：是一段Lua脚本程序，它会被运行在Redis服务器上下文中，这段脚本不必(也不应该)定义为一个Lua函数。</p></li><li><p><code>numkeys参数</code>：用于指定键名参数的个数。</p></li><li><p><code>key [key ...]参数</code>： 从EVAL的第三个参数开始算起，使用了numkeys个键（key），表示在脚本中所用到的那些Redis键(key)，这些键名参数可以在Lua中通过全局变量KEYS数组，用1为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。</p></li><li><p><code>arg [arg ...]参数</code>：，可以在Lua中通过全局变量ARGV数组访问，访问的形式和KEYS变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。</p></li></ul><p>例如</p><pre><code class="highlight plaintext">&gt; eval &quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot; 2 key1 key2 first second1) &quot;key1&quot;2) &quot;key2&quot;3) &quot;first&quot;4) &quot;second&quot;</code></pre><p><strong>lua脚本中调用redis命令</strong></p><pre><code class="highlight plaintext">redis.call()：redis.pcall()：这两个函数的唯一区别在于它们使用不同的方式处理执行命令所产生的错误示例：&gt; eval &quot;return redis.call(&#x27;set&#x27;,KEYS[1],&#x27;bar&#x27;)&quot; 1 fooOK</code></pre><p><strong>evalsha</strong></p><ul><li><p>EVAL 命令要求你在<strong>每次执行脚本</strong>的时候都<strong>发送一次脚本主体</strong>(script body)。</p></li><li><p>Redis 有一个<strong>内部的缓存机制</strong>，因此它不会每次都重新编译脚本，不过在很多场合，付出无谓的带宽来传送脚本主体并不是最佳选择。</p></li><li><p>为了<strong>减少带宽的消耗</strong>， Redis 实现了 <strong>EVALSHA 命令</strong>，它的作用和 EVAL 一样，都用于对脚本求值，但它接受的第一个参数不是脚本，而是脚本的 SHA1 校验和(sum)</p></li></ul><p>EVALSHA 命令的表现如下</p><ul><li><p>如果服务器还记得给定的 SHA1 校验和所指定的脚本，那么执行这个脚本</p></li><li><p>如果服务器不记得给定的 SHA1 校验和所指定的脚本，那么它返回一个特殊的错误，提醒用户使用 EVAL 代替 EVALSHA</p></li></ul><pre><code class="highlight plaintext">&gt; evalsha 6b1bf486c81ceb7edf3c093f4c48582e38c0e791 0&quot;bar&quot;</code></pre><p><strong>script命令</strong></p><p><code>SCRIPT FLUSH</code> ：清除所有脚本缓存</p><p><code>SCRIPT EXISTS</code> ：根据给定的脚本校验和，检查指定的脚本是否存在于脚本缓存</p><p><code>SCRIPT LOAD</code> ：将一个脚本装入脚本缓存，<strong>返回SHA1摘要</strong>，但并不立即运行它</p><p><code>SCRIPT KILL</code> ：杀死当前正在运行的脚本</p><p><strong>redis-cli --eval</strong></p><p>可以使用redis-cli命令直接执行脚本</p><pre><code class="highlight plaintext">$ redis-cli --eval script KEYS[1] KEYS[2] , ARGV[1] ARGV[2] ...</code></pre><hr /><p>或者可以执行一个脚本文件</p><pre><code class="highlight plaintext">$ redis-cli --eval redis.lua</code></pre><p>redis.lua</p><pre><code class="highlight lua"><span class="keyword">local</span> value=redis.clal(<span class="string">&quot;get&quot;</span>,<span class="string">&quot;s2&quot;</span>)<span class="keyword">return</span> value</code></pre><h4 id="java种使用"><a class="markdownIt-Anchor" href="#java种使用"></a> Java种使用</h4><h2 id="redis消息模式"><a class="markdownIt-Anchor" href="#redis消息模式"></a> Redis消息模式</h2><h3 id="队列模式"><a class="markdownIt-Anchor" href="#队列模式"></a> 队列模式</h3><p>使用<strong>list类型</strong>的<code>lpush和rpop</code>实现消息队列(一般的抢购秒杀都使用该种技术)</p><p>注意事项：</p><ul><li><p>消息接收方如果不知道队列中是否有消息，会一直发送rpop命令，如果这样的话，会每一次都建立一次连接，这样显然不好。</p></li><li><p>可以使用<strong>brpop</strong>命令，它如果从队列中取不出来数据，会一直阻塞，在一定范围内没有取出则返回null、</p></li></ul><h3 id="发布订阅模式"><a class="markdownIt-Anchor" href="#发布订阅模式"></a> 发布订阅模式</h3><p><strong>订阅消息（<u>subscribe</u>）</strong></p><p>示例：</p><pre><code class="highlight plaintext">subscribe kkb-channel</code></pre><p><strong>发布消息（<u>publish</u>）</strong></p><p>示例：</p><pre><code class="highlight plaintext">publish kkb-channel “我是灭霸詹”</code></pre><p><strong>Redis发布订阅命令</strong></p><h2 id="缓存穿透缓存击穿缓存失效"><a class="markdownIt-Anchor" href="#缓存穿透缓存击穿缓存失效"></a> 缓存穿透,缓存击穿,缓存失效</h2><h3 id="缓存数据的步骤"><a class="markdownIt-Anchor" href="#缓存数据的步骤"></a> 缓存数据的步骤</h3><ol><li><p>查询缓存，如果没有数据，则查询数据库</p></li><li><p>查询数据库，如果数据不为空，将结果写入缓存</p></li></ol><h3 id="缓存穿透"><a class="markdownIt-Anchor" href="#缓存穿透"></a> 缓存穿透</h3><p><strong>什么叫缓存穿透？</strong></p><p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。如果key对应的value是一定不存在的，并且对该key并发请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p><p><strong>如何解决？</strong></p><p>1：<strong>对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存</strong>。</p><p>2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。（<strong>布隆表达式</strong>）</p><h3 id="缓存雪崩"><a class="markdownIt-Anchor" href="#缓存雪崩"></a> 缓存雪崩</h3><p><strong>什么叫缓存雪崩？</strong></p><p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。</p><p><strong>如何解决？</strong></p><p>1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p><p>2：<strong>不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀</strong>。</p><p>3：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期（此点为补充）</p><h3 id="缓存击穿"><a class="markdownIt-Anchor" href="#缓存击穿"></a> 缓存击穿</h3><p><strong>什么叫缓存击穿？</strong></p><ul><li><p>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。</p></li><li><p>缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p></li></ul><p><strong>如何解决？</strong></p><p>使用redis的setnx互斥锁先进行判断，这样其他线程就处于等待状态，保证不会有大并发操作去操作数据库。</p><pre><code class="highlight plaintext">if(redis.sexnx()==1)&#123;       //查询数据库       //加入线程&#125;</code></pre><h2 id="缓存淘汰策略之lru"><a class="markdownIt-Anchor" href="#缓存淘汰策略之lru"></a> 缓存淘汰策略之LRU</h2><h3 id="redis内置缓存淘汰策略"><a class="markdownIt-Anchor" href="#redis内置缓存淘汰策略"></a> redis内置缓存淘汰策略</h3><p><strong>最大缓存</strong></p><ul><li><p>在 redis 中，允许用户设置最大使用内存大小<u>maxmemory</u>，默认为0，没有指定最大缓存，如果有新的数据添加，超过最大内存，则会使redis崩溃，所以一定要设置。</p></li><li><p>redis 内存数据集大小上升到一定大小的时候，就会实行<u>数据淘汰策略</u>。</p></li></ul><p><strong>淘汰策略</strong></p><p>redis淘汰策略配置：maxmemory-policy voltile-lru，支持热配置</p><p><strong>redis 提供 6种数据淘汰策略：</strong></p><p>voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p><p>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p><p>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p><p>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</p><p>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</p><p>no-enviction（驱逐）：禁止驱逐数据</p><h3 id="lru原理"><a class="markdownIt-Anchor" href="#lru原理"></a> LRU原理</h3><p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”</p><h3 id="lru实现"><a class="markdownIt-Anchor" href="#lru实现"></a> LRU实现</h3><p>最常见的实现是使用一个链表保存缓存数据，详细算法实现如下：</p><p>1. 新数据插入到链表头部；</p><p>2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</p><p>3. 当链表满的时候，将链表尾部的数据丢弃。</p><blockquote><p>在Java中可以使用LinkHashMap去实现LRU</p></blockquote><h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3><p><strong>【命中率】</strong></p><p>当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。</p><p><strong>【复杂度】</strong></p><p>实现简单。</p><p><strong>【代价】</strong></p><p>命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部</p>]]>
    </content>
    <id>http://example.com/2023/01/04/Redis/</id>
    <link href="http://example.com/2023/01/04/Redis/"/>
    <published>2023-01-04T04:00:00.000Z</published>
    <summary>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value内存数据库。Redis安装，Spring集成，事务，分布式锁，持久化，主从，LUA。</summary>
    <title>Redis</title>
    <updated>2026-02-27T01:18:47.919Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="zookeeper" scheme="http://example.com/tags/zookeeper/"/>
    <content>
      <![CDATA[<h1 id="zookeeper"><a class="markdownIt-Anchor" href="#zookeeper"></a> zookeeper</h1><p>[toc]</p><h2 id="zookeeper概述"><a class="markdownIt-Anchor" href="#zookeeper概述"></a> Zookeeper概述</h2><h3 id="zookeeper简介"><a class="markdownIt-Anchor" href="#zookeeper简介"></a> Zookeeper简介</h3><p>zookeeper是一个开源的分布式应用程序协调服务器，其为分布式系统提供一致性服务。其一致性是通过基于Paxos算法的ZAB协议完成的，其主要功能包括：配置维护，域名服务，分布式同步，集群管理等。</p><h4 id="功能简介"><a class="markdownIt-Anchor" href="#功能简介"></a> 功能简介</h4><p><strong>配置维护</strong></p><p>分布式系统中，很多服务都是部署在集群中的，即多台服务器中部署着完全相同的应用，起着完全相同的作用，当然，集群中的这些服务器的配置文件是完全相同的。</p><p>若集群中服务器的配置文件需要进行更改，那么我们就需要逐台秀太这些服务器中的配置，数千台的服务器，手工维护的风险是很大的</p><p>这时候zookeeper就可以排上用场了，其对于配置文件的维护采用的是“发布/订阅模式”，发布者将修改好的集群的配置文件发布到zookeeper服务器的文件系统中，那么订阅者马上就可以接收到通知，并主动同步zookeeper里的配置文件，zookeeper具有同步操作的原子性，确保每个服务器的配置文件都可以被正确的修改</p><p><strong>域名服务</strong></p><p>在分布式应用中，一个项目包含多个工程，而这些工程中，有些工程是专门为其他工程提供服务的，一个项目中可能会存在多种提供不同服务的工程，而一种服务有可能存在多个提供者（服务器），所以，用于消费这些服务的客户端工程若要消费这些服务，就变得异常复杂</p><p>此时，zookeeper就可以上场了，为每个服务起个名称，将这些服务的名称与通过这些服务的主机地址注册都zookeeper中，形成一个服务映射表，服务消费者只需要通过服务名称即可享受到服务，而无需了解服务具体的提供者是谁，服务的减少，添加，变更，只需要改zookeeper中的服务映射表即可</p><p>阿里的Dobbo就是使用zookeeper作为服务域名服务器的</p><p><strong>分布式同步</strong></p><p>在分布式系统中，很多运算(对请求的处理)过程是由分布式机群中的若干服务器共同计算完成的，并且它们之间的运算还具有逻辑上的先后顺序。如何保证这些服务器运行期间的同步性呢? <br />      使用Zookeeper可以协调这些服务器间运算的过程。让这些服务器都同时监听Zookeeper上的同一个znode (Zookeeper文件系统中的一个数据存储节点)，一旦其中一个服务器Update了znode, 那么另一个相应服务器能够收到通知，并作出相应处理。</p><p><strong>集群管理</strong></p><p>集群管理中最麻烦的就是节点故障管理。Zookeeper可以让集群选出一个健康的节点作为Master, Master随时监控着当前集群中的每个节点的健康状况，一旦某个节点发生故障，Master会把这个情况立即通知给集群中的其它节点，使其它节点对于任务的分配做出相应调整。Zookeeper不仅可以发现故障，也会对故障进行甄别，如果该故障可以修复，Zookeeper可以自动修复，若不能修复则会告诉系统管理员错误的原因让管理员迅速定位问题。。<br />      但这里也有个问题: Master 故障了，那怎么办? Zookeeper内部有一个“选举算法”， 当Master故障出现时，Zookeeper 能马上选出新的Master对集群进行管理</p><h4 id="一致性要求"><a class="markdownIt-Anchor" href="#一致性要求"></a> 一致性要求</h4><p>什么是zk的一致性呢？就需要满足以下几点要求</p><p><strong>顺序一致性</strong></p><p>从同一个客户端发起的n多个事务请求（写请求），最终将会严格按照其发起顺序被应用到zookeeper中</p><p><strong>原子性</strong></p><p>所有事务请求的结果在集群中所有机器上的应用情况是一致的。也就是说要么整个集群所有主机都成功应用了某一个事务，要么都没有应用，不会出现集群中部分主机应用了该事务，而另外一部分没有应用的情况。</p><p><strong>单一视图</strong></p><p>无论客户端连接的是哪个ZooKeeper服务器，其看到的服务端数据模型都是一致的。</p><p><strong>可靠性</strong></p><p>一且服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来，除非有另一个事务又对其进行了变更。</p><p><strong>实时性</strong></p><p>通常人们看到实时性的第一反应是，一旦一个事务被成功应用，那么客户端能够立即从服务端上读取到这个事务变更后的最新数据状态。这里需要注意的是，ZooKeeper仅仅保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。</p><h3 id="zookeeper中的重要概念"><a class="markdownIt-Anchor" href="#zookeeper中的重要概念"></a> zookeeper中的重要概念</h3><h4 id="session"><a class="markdownIt-Anchor" href="#session"></a> Session</h4><p>Session是指客户端会话。</p><p>ZooKeeper 对外的服务端口<strong>默认是2181</strong>，客户端启动时，首先会与zk服务器建立一个TCP长连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个长连接，客户端能够通过心跳检测保持与服务器的有效会话，也能够向ZooKeeper服务器发送请求并接受响应，同时还能通过该连接接收来自服务器的Watcher事件通知。</p><p>Session的<strong>SessionTimeout值用来设置一个客户端会话的超时时间</strong>。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在SessionTimeout规定的时间内客户端能够重新连接上集群中任意台服务器，那么之前创建的会话仍然有效。</p><h4 id="znode"><a class="markdownIt-Anchor" href="#znode"></a> znode</h4><p>zookeeper的文件系统采用树形层次化的目录结构，与Unix文件系统非常相似。每个目录在zookeeper中叫做一个znode,每个znode拥有一个唯一的路径标识，即名称。Znode可以包含数据和子znode (临时节点不能有子znode)。Znode 中的数据可以有多个版本，所以查询某路径下的数据需带上版本号。客户端应用可以在znode上设置监视器(Watcher)</p><h4 id="watcher机制"><a class="markdownIt-Anchor" href="#watcher机制"></a> Watcher机制</h4><p>zk通过<strong>Watcher机制实现了发布/订阅模式</strong>。k提供了分布式数据的发布订阅功能，一个发布者能够让多个订阅者同时监听某一主题对象， 当这个主题对象状态发生变化时，会通知所有订阅者，使它们能够做出相应的处理。zk引入了watcher机制来实现这种分布式的通知功能。zk允许客户端向服务端注册一个Watcher监听，当服务端的一些指定事件触发这个Watcher,那么就会向指定客户端发送一个事件通知。而这个事件通知则是通过TCP长连接的Session完成的</p><h4 id="acl"><a class="markdownIt-Anchor" href="#acl"></a> ACL</h4><p>ACL全称为Access Control List (访问控制列表),<strong>用于控制资源的访问权限，是zk数据安全的保障</strong>。zk利用ACL策略控制znode节点的访问权限，如节点数据读写、节点创建、节点删除、读取子节点列表、设置节点权限等。</p><p>在传统的文件系统中，ACL分为两个维度:组与权限。一个属组可以包含多种权限，一个文件或目录拥有了某个组的权限即拥有了组里的所有权限。文件或子目录默认会继承其父目录的ACL。</p><p>而在Zookeeper中，znode的ACL是没有继承关系的，每个znode的权限都是独立控制的，只有客户端满足znode设置的权限要求时，才能完成相应的操作。Zookeeper 的ACL分为三个维度：<strong>授权策略scheme，用户id，用户权限permission</strong></p><h3 id="paxos算法"><a class="markdownIt-Anchor" href="#paxos算法"></a> Paxos算法</h3><h4 id="算法简介"><a class="markdownIt-Anchor" href="#算法简介"></a> 算法简介</h4><p>Paxos算法是莱斯利&quot;伯特(Leslie tamport)1990年提出的一种基于消息传递的、具有高容错性的一致性算法。Google Chubby (分布式锁服务)的作者Mike Burrows说过，世上只有一种一致性算法，那就是Paxos, 所有其他致性算法 都是Paxos算法的不完整版。Paxos算法是一种公认的晦涩难懂的算法，并且工程实现上也具有很大难度。较有名的Paxos工程实现有Google Chubby、ZAB、 微信的PhxPaxos等。，</p><p>Paxos算法是用于解决什么问题的呢? Paxos 算法要解决的问题是，在分布式系统中如何就某个决议达成一致。</p><h4 id="paxos与拜占庭将军问题"><a class="markdownIt-Anchor" href="#paxos与拜占庭将军问题"></a> Paxos与拜占庭将军问题</h4><p>拜占庭将军问题(Byzantine failures),是由Paxos算法作者莱斯利兰伯特提出的点对点通信中的基本问题。该问题要说明的含义是，在存在消息丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的。</p><p>Paxos算法的前提是不存在拜占庭将军问题，即信道是安全的、可靠的，集群节点间传  国中J递的消息是不会被篡改的。在实际工程实践中，大多数系统都是部署在一个局域网内，因此消息被篡改的情况很少:另一方面，由于硬件和网络原因而造成的消息不完整问题，现在已经不再是问题，只需要一套简单的校验算法即可，因此，在实际工程中各个服务器间传递过程可以认为不存在拜占庭将军问题</p><p>一般情况下，分布式系统中各个节点间采用两种通讯模型，共享内存（shared Memory）,消息传递（Messages Passing）。而Paxos是基于消息传递通讯模型的</p><h4 id="算法描述"><a class="markdownIt-Anchor" href="#算法描述"></a> 算法描述</h4><h5 id="三种角色"><a class="markdownIt-Anchor" href="#三种角色"></a> 三种角色</h5><p>在Paxos算法中有三种角色，分别具有三种不同的行为。但很多时候，一一个进程可能同时充当着多种角色。</p><ul><li>Proposer:提案(Proposal) 的提议者。</li><li>Acceptor:提案的表决者，即是否accept该提案。只有半数以上的Acceptor接受了某提案，那么该提案者被认定为“选定”。</li><li>Learners:提案的学习者。当提案被选定，其会同步并执行提案</li></ul><p>一个提案的表决者(Acceptor)会存在多个，但在一个集群中，提议者(Proposer)是可能存在多个的，不同的提议者（Proposer）会提出不同的提案。而一致性算法则可以保证如下几点：</p><ul><li>没有提案被提出则不会有提案被选定</li><li>每个提议者在提出提案时都会为该提案指定一个具有全局唯性的、 递增的提案编号 N,即在整个集群中是唯一的。</li><li>每个表决者在accept某提案后，会将该提案的编号N记录在本地，这样每个表决者中保存的已经被accept的提案中会存在一个编号最大的提案，其编号假设为maxN。每个表决者仅会accept编号大于自己本地maxN的提案。</li><li>在众多提案中最终只能有一个提案被选定。</li><li>一旦一个提案被选定，则其它服务器会主动同步(Learn)该是案到本地。</li></ul><h5 id="算法过程描述"><a class="markdownIt-Anchor" href="#算法过程描述"></a> 算法过程描述</h5><p>Paxos算法的执行过程划分为两个阶段：准备阶段prepare与接受阶段accept</p><ul><li><strong>prepare 阶段</strong></li></ul><p>提议者(Proposer)准备提交一个编号为 N的提议， 于是其 首先向所有表决者(Acceptor)发送prepare(N)请求，用于试探集群是否支持该编号的提议。</p><p>每个表决者(Acceptor)中 都保存着自己曾经accept过的提议中的最大编号maxN。当一个表决者接收到其它主机发送来的prepare(N)请求时，其会比较N与maxN的值。若N小于等于maxN,则说明该提议己过时，当勤表决者采取不回应或回应Error的方式来拒绝该prepare请求;若N大于maxN,则说明该提议是可以接受的，当前表决者会将其曾经已经accept的编号最大的提案Proposal(mid,maxN,value)反馈给提议者，以向提议者展示自己支持的提案意愿。其中第一个参数mid表示表决者Acceptor的标识id,第二个参数表示其曾接受的提案的最大编号maxN,第三个参数表示该提案的真正内容value.当然，若当前表决者还未曾accept过任何提议，则会将Propalimid,null,nul)反馈给提议者。</p><ul><li><strong>accept 阶段</strong></li></ul><p>当提议者(Proposer)发 出prepare(N)后，若收到了超过半数的表决者(Accepter)的反馈，那么该提议者就会将其真正的提案Proposal(N,value)发送给所有的表决者。</p><p>当表决者(Acceptor)接收到提议者发送的Proposal(N,value)提案后，会再次拿出自己曾经accept过的提议中的最大编号maxN,及曾经反馈过的prepare的最大编号，让N与它们进行比较，若N大于等于这两个编号，则当前表决者accept 该提案，并反馈给提议者。若N小于这两个编号，则表决者采取不回应或回应Error的方式来拒绝该提议</p><p>若提议者 没有接收到超过半数的表决者的accept反馈，则重新进入prepare阶段，递增提案号，重新提出prepare请求。若提议者接收到的反馈数量超过了半数，则其它的未向提议者发送accept反馈的表决者将成为Learner,主动同步提议者的该提案。</p><h5 id="算法过程举例"><a class="markdownIt-Anchor" href="#算法过程举例"></a> 算法过程举例</h5><p>假设有三台主机，它们要从中选出一个Leader。这三台主机在不同的时间分别充当关提案的提议者Proposer、表决者Acceptor及学习者Learnor 三种不同的角色。</p><p>这里首先介绍一下该举例的前提:每个提议者(Proposer)都想提议自己要当Leader,假设三个提议者Proposer-1、Proposer-2、Proposer-3 提议的提案初始编号依次为20、10、30。每个提议者都要将提案发送给所有的表决者(Acceptor),为了便于理解，假设都只有两个(超过半数)表决者收到消息: Accepter-2 与Acceptor-3 收到了Proposer-2 的消息: Accepter-1与Acceptor-2收到了Proposer-1 的消息; Accepter-2与Acceptor-3收到了Proposer-3 的消息。</p><h4 id="paxos算法优化"><a class="markdownIt-Anchor" href="#paxos算法优化"></a> Paxos算法优化</h4><p>前面所述的Paxos算法在实际工程应用过程中，根据不同的实际需求存在诸多不便之处，所以也就出现了很多对于基本Paxos算法的优化算法，例如，Multi Paxos、Fast Paxos、EPaxos.而<strong>Zookeeper的Leader选举算法</strong>FastLeaderElection则<strong>是Fast Paxos 算法的工程应用</strong></p><h3 id="zab协议"><a class="markdownIt-Anchor" href="#zab协议"></a> ZAB协议</h3><p>ZAB，Zookeeper Atomic Broadcast, zk原子消息广播协议，是<strong>专为ZooKeeper设计的一种支持崩溃恢复的原子广播协议</strong>，是<strong>一种Pasox协议的优化算法</strong>。在Zookeeper中， 主要依赖ZAB协议来实现分布式数据一致性。</p><p>Zookeeper使用一个单一主进程来接收并处理客户端的所有事务请求，即写请求。当服务器数据的状态发生变更后，集群采用ZAB原子广播协议，以事务提案Proposal的形式广播到所有的副本进程上。ZAB协议能够保证一个全局的变更序列,即可以为每一个事务 分配一一个全局的递增编号xid.。</p><p>当Zookeeper客户端连接到Zookeeper集群的一个节点后，若客户端提交的是读请求，那么当前节点就直接根据自己保存的数据对其进行响应;如果是写请求且当前节点不是Leader,那么节点就会将该写请求转发给Leader, Leader会以提案的方式广播该写操作，只要有超过半数节点同意该写操作，则该写操作请求就会被提交。 然后Leader 会再次广播给所有订阅者，即Learner,通知它们同步数据</p><h4 id="三类角色"><a class="markdownIt-Anchor" href="#三类角色"></a> 三类角色</h4><p>为了避免Zookeeper的单点问题，zk也是以集群的形式出现的。集群中的角色主要有以下三类:</p><ul><li><p>Leader: zk集群写请求的唯一处理者， 并负责进行投票的发起和决议，更新系统状态。Leader是很民主的，并不是说其在接收到写请求后马上就修改其中保存的数据，而是首先根据写请求提出一个提议，在大多数zkServer均同意时才会做出修改。</p></li><li><p>Follower: 接收客户端请求，处理读请求，并向客户端返回结果，将写请求转给Leader，在选主(选Leader)过程中参与投票。</p></li><li><p>Obsenver:可以理解为无选主投票权与写操作投票权的Flollower,其不属于法定人数范围，主要是为了协助Follower处理更多的读请求。如果Zookeeper集群的读请求负载质高时，劳必要增加处理读请求的服务器数量:若增加的这些服务器都是以Follower的身份出现。则会大大降低写操作的效率。因为Leader发出的所有写操作提议，均需要通过法定人数半数以上同意。过多的Follwer会增加Leader与Follower的通信压力，降低写操作效率。同样，过多的Follower会延长Leader的选举时长，降低整个集群的可用性。此时，可选择增加Observer服务器，既提高了处理读操作的吞吐量。又没有墙加法定人数。只要法定人数不变，无论是写操作投票还是选主投票，其都不会增加通信压力，都不会影响投票效率。</p></li></ul><h4 id="三种模式"><a class="markdownIt-Anchor" href="#三种模式"></a> 三种模式</h4><p>ZAB协议中对zkServer的状态描述有三种模式:恢复模式、同步模式和广播模式。</p><ul><li><p><strong>恢复模式</strong>：在服务重启过程中，或在Leader崩溃后，就进入了恢复模式，要恢复到zk集群正常的工作状态</p></li><li><p><strong>同步模式</strong>：在所有的zkServer启动完毕，或Leader崩溃后又被选举出来时，就进入了同步模式，各个Follower需要马上将Leader 中的数据同步到自己的主机中。当大多数zkServer完成了与Leader的状态同步以后，恢复模式就结束了。所以，同步模式包含在恢复模式过程中。</p></li><li><p><strong>广播模式</strong>：当Leader的提议被大多数zkServer同意后，Leader会修改自身数据，然后将修改后的数据广播给其他Follower</p></li></ul><h4 id="zxid"><a class="markdownIt-Anchor" href="#zxid"></a> zxid</h4><p>zxid为64位长度的Long类型，其中高32位表示<strong>纪元epoch</strong>,低32位表示<strong>事务标识xid</strong>.即zxid由两部分构成: epoch 与xid.。</p><p>每个Leader都会具有一个不同的epoch值，表示一个时期、时代。每一次新的选举开启时都会生成一个新的epoch,新的Leader产生,则会更新所有zkServer 的zxid中的epoch。</p><p>xid则为zk的事务id,每一个写操作都是一个事务，都会有一个xid. xid为一个依次递增的流水号。每一个写操作都需要由Leader发起一一个提案，由所有Follower表决是否同意本次写操作，而每个提案都具有一个zxid。</p><h4 id="消息广播算法"><a class="markdownIt-Anchor" href="#消息广播算法"></a> 消息广播算法</h4><p>当集群中已经有过半的Follower与Leader服务器完成了状态同步，那么整个zk集群就可以进入消息广播模式了。</p><p>如果集群中的其他节点收到客户端的事务请求，那么这些非Leader服务器会首先将这个事务请求转发给Leader服务器。Leader服务器会为其生成对应的事务提案Proposal, 并将其发送给集群中其余所有的主机，然后再分别收集它们的选票，在选票过半后进行事务提交。其具体过程如下:</p><ul><li><p>Leader接收到消息请求后，将消息赋予一个全局唯一的64位自增id, 即zxid,通过zxid的大小比较即可实现事务的有序性管理。</p></li><li><p>为了保证Leader向Follower发送提案的有序，Leader会为每个Follower创建一个 FIFO队列，并将提案副本写入到各个队列。然后再通过这些队列将提案发送给各个Follower.</p></li><li><p>当Follower接收到提案后，会先将提案的zxid与本地记录的事务日志中的最大的zxid进行比较。若当前提案的zxid大于最大zxid,则将当前提案记录到本地事务日志中，并向Leader返回一个ACK</p></li><li><p>当Leader接收到过半的ACKs后，对于之前回复过Leader的Follower, Leader 会向其发送COMMIT消息，批准这些Follower在本地执行该消息:对于之前未回复过Leader的Follower, Leader 会将这些Follower对应的队列中的提案发送给这些Follower,发送的同时会携带COMMIT消息。当Follower收到COMMIT消息后，就会执行该消息。</p></li></ul><h4 id="恢复模式两个原则"><a class="markdownIt-Anchor" href="#恢复模式两个原则"></a> 恢复模式两个原则</h4><p>当集群正在启动过程中，或Leader与超过半数的主机断连后，集群就进入了恢复模式。对于要恢复的数据状态需要遵循两个原则。</p><p><strong>已被处理过的消息不能丢</strong></p><p>当Leader收到超过半数Follower的ACKS后，就向各个Follower广播COMMIT 消息，批准各个Server执行该写操作事务。当各个Server在接收到Leader的COMMIT消息后就会在本地执行该写操作，然后会向客户端响应写操作成功。但是如果在非全部Follower 收到月  COMMIT消息之前Leader 就挂了，这将导致一种后果: 部分Server 已经执行了该事务，而部分Server尚未收到COMMIT消息，所以其并没有执行该事务。当新的Leader被选举出，集群经过恢复模式后需要保证所有Server上都执行了那些已经被部分Server执行过的事务。</p><p>为了保证“已被处理过的消息不能丢”的目的，ZAB的恢复模式使用了以下的策略:</p><ul><li>选举拥有proposal 最大值(即zxid 最大)的节点作为新的Leader: 由于所有提案被COMMIT之前必须有合法数量的Follower ACK,即必须有合法数量的服务器的事务日志上有该提案的proposal, 因此，只要有合法数量的节点正常工作，就必然有一个节点保  国中存了所有被COmMIT消息的proposal 状态。</li><li>新的Leader 先将自身拥有而并非所有Follower 都有的proposal 发送给Follower, 再将这些proposal的COMMIT命令发送给Follower,以保证所有的Follower 都保存并执行了所有的proposal.通过以上策略，能保证已经被处理的消息不会丢。</li></ul><p><strong>被丢弃的消息不能再现</strong></p><p>当Leader 接收到事务请求并生成了proposal,但还未向Follower发送时就挂了。由于其他Follower并没有收到此proposal,即并不知道该proposal的存在，因此在经过恢复模式重新选举产生了新的Leader后，这个事务被跳过。在整个集群尚未进入正常服务状态时，之前挂了的Leader主机重新启动并注册成为了Follower.但由于保留了被跳过的proposal,所以其与整个系统的状态是不一致的，需要将该proposal删除。</p><p>ZAB通过设计巧妙的zxid实现了这一目的。一个zxid是64位，高32是纪元epoch编号，每一次选举epoch的值都会增一。低32位是事务标识xid,每产生一个事务， 该xid值都会增一。这样设计的好处是旧的Leader挂了后重启，它不会被选举为新的Leader,因为此时它的zxid 肯定小于当前新的epoch。当旧的Leader作为Follower 接入新的Leader后，新的Leader会让其将所有旧的epoch 号的未被COMMIT的proposal 清除。</p><h4 id="leader选举算法paxos实现"><a class="markdownIt-Anchor" href="#leader选举算法paxos实现"></a> leader选举算法（paxos实现）</h4><p>当集群正在启动过程中，或Leader与超过半数的主机断连后，集群就进入了恢复模式。而恢复模式中最重要的阶段就是Leader 选举。</p><p>在集群 启动过程中的Leader选举过程(算法)与Leader断连后的Leader选举过程稍微有一些区别，基本相同</p><p><strong>集群启动中的 Leader 选举</strong></p><p>若进行Leader 选举，则至少需要两台主机，这里以三台主机组成的集群为例。。</p><p>在集群初始化阶段，当第台 服务器Server1启动时，其会给自己投票，然后发布自己的投票结果。投票包含所推举的服务器的myid和ZXID,使用(myid, ZXID)来表示，此时Server1的投票为(1，0)。由于其它机器还没有启动所以它收不到反馈信息，Server1 的状态一直属于Looking,即属于韭服务状态。。</p><p>当第二台服务器Server2启动时，此时两台机器可以相互通信，每台机器都试图找到Leader,选举过程如下:</p><ol><li><p>每个Server发出一个投票。此时Server1的投票为(1, 0), Server2的投票为(2,0),然后各自将这个投票发给集群中其他机器。，</p></li><li><p>接受来自各个服务器的投票。集群的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票、是否来自LOOKING状态的服务器。。</p></li><li><p>处理投票。针对每一个投票，服务器都需要将别人的投票和自己的投票进行PK, PK规则如下:。</p><ul><li>优先检查ZXID。ZXID 比较大的服务器优先作为Leader。。</li><li>如果ZXID相同，那么就比较myid。myid 较大的服务器作为Leader服务器。。对于Server1而言，它的投票是(1, 0),接收Server2的投票为(2, 0)。其首先会比较两者的ZXID,均为0，再比较myid,此时Server2的myid最大，于是Server1更新自己的投票为(2, 0),然后重新投票。对于Server2而言，其和须更新自己的投票，只是再次向集群中所有主机发出上一次投票信息即可。</li></ul></li><li><p>统计投票。每次投票后，每一台zkServer 都会统计投票信息，判断是否已经有过半机器接受到相同的投票信息。对于Server1、Server2而言，都统计出集群中已经有两台主机接受了(2, 0)的投票信息，此时便认为已经选出了新的Leader,即Server2。</p></li><li><p>改变服务器状态。一旦确定了Leader, 每个服务器就会更新自己的状态，如果是Follower,那么就变更为FOLLOWING,如果是Leader,就变更为LEADING。</p></li><li><p>添加主机。在新的Leader选举出来后Server3启动，其想发出新一轮的选举。但由于当前集群中各个主机的状态并不是LOOKING，而是各司其职的正常服务，所以其只能是以Follower的身份加入到集群中。</p></li></ol><p><strong>断连后的Leader选举</strong></p><p>在Zookeeper运行期间，Leader 与非Leader服务器各司其职，即便当有非Leader服务器宕机或新加入时也不会影响Leader。但是若Leader服务器挂了，那么整个集群将暂停对外服务，进入新轮的Leader选举，其过程和启动时期的Leader选举过程基本一致。</p><p>假设正在运行的有Server1、Server2、 Server3 三台服务器，当前Leader是Server2,若某一时刻Server2挂了，此时便开始新一轮的Leader选举了。选举过程如下:</p><ol><li>变更状态。Leader挂后，余下的非Observer服务器都会将自己的服务器状态由FOLLOWING变更为LOOKING,然后开始进入Leader 选举过程。</li><li>每个Server 会发出一个投票，仍然会首先投自己。不过，在运行期间每个服务器上的ZXID可能是不同，此时假定Server1的ZXID为111. Server3 的ZXID为333;在第一轮投票中，Server1和Server3都会投自己，产生投票(1,111)，(3,333)， 然后各自将投票发送给集群中所有机器。</li><li>接收来自各个服务器的投票。与启动时过程相同。集群的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票、是否来自LOOKING状态的服务器。</li><li>处理投票。与启动时过程相同，此时，Server1将会成为Leader。</li><li>统计投票。与启动时过程相同。针对每一个投票， 服务器都需要将别人的投票和自己的投票进行PK。对于Server1而言，它的投票是(1, 111)，接收Server3的投票为(3, 333)。其首先会比较两者的ZXID, Server3投票的zxid为333大于Server1 投票的zxid的111,于是Server1更新自己的投票为(3, 333),然后重新投票。对于Server3而言，其无须更新自己的投票，只是再次向集群中所有主机发出上一.次投票信息即可。经过票数统计，最终Server3当选新的Leader。</li><li>改变服务器的状态。与启动时过程相同。一旦确定 了Leader,每个服务器就会更新国英」自己的状态。Server1 变更为FOLLOWING, Server3 变更为LEADING.</li></ol><h4 id="恢复模式下的数据同步"><a class="markdownIt-Anchor" href="#恢复模式下的数据同步"></a> 恢复模式下的数据同步</h4><p>当完成Leader选举后，就要进入到恢复模式下的数据同步阶段。Leader 服务器会为每一个 Follower 服务器准备一个队列，并将那些没有被各个Follower服务器同步的事务以Proposal的形式逐条发给各个Follower服务器，并在每一个Proposal后都紧跟一个commit消息，表示该事务已经被提交，Follower可以直接接收并执行。当follower服务器将所有尚未同步的事务proposal都从leader服务器同步过来并成功执行后，会向准leader发送ACK信息。leader服务器在收到该ACK后就会将该follower加入到真正可用的follower列表。</p><h3 id="cap原则"><a class="markdownIt-Anchor" href="#cap原则"></a> CAP原则</h3><p>CAP原则又称CAP定理，指的是在一个分布式系统中, Consistency(<strong>一致性</strong>) Availability(<strong>可用性</strong>)、Partition tolerance (<strong>分区容错性</strong>),三者不可兼得。<br />      ●<strong>一致性</strong>©:分布式系统的所有主机中在同时刻是否可以保证具有完全相同的数据备份。若具有，则该分布式系统具有一致性。C<br />      ●  <strong>可用性</strong>(A):在集群中部分节点发生故障后，是否会影响对客户端读写请求的响应。注意，若在短时间内会影响，其也不具有这里所说的“可用性”。山<br />      ●  <strong>分区容错性</strong>(P):分布式系统中的一台主机称为一个分区。那么，什么是分布式系统的“错误”呢?分布式系统中各个主机无法保证数据的一致性是一 种错误; 分布式系统无法及时响应客户端请求，即不具有可用性也是一种错误。对于分布式系统，必须要具有对这些错误的“包容性”，即容错性，这是必须的。</p><h4 id="三二原则"><a class="markdownIt-Anchor" href="#三二原则"></a> 三二原则</h4><p>对于分布式系统，在CAP原则中分区容错性P是必须要保证的。但其并不能同时保证一致性与可用性。因为现在的分布式系统在满足了一致性的前提下，会牺牲可用性在满足了可用性的前提下，会牺牲一致性。所以，CAP原则对于一个分布式系统来说，只可能满足两项，即要么CP,要么AP。这就是CAP的三二原则。</p><p></p><h4 id="zk于cp"><a class="markdownIt-Anchor" href="#zk于cp"></a> zk于cp</h4><p>zk遵循的是CP原则，即保证了一致性，但牺牲了可用性。体现在哪里呢?。</p><p>当Leader宕机后，zk集群会马上进行新的Leader的选举。但选举时长在30-120秒间，整个选举期间zk集群是不接受客户端的读写操作的，即zk集群是处于瘫痪状态的。所以，其不满足可用性。</p><p>为什么Leader的选举需要这么长的时间呢?为了保证zk集群各个节点中数据的一致性，zk集群做了两类数据同步:初始化同步与更新同步。当新的Leader被选举出后，各个Follower需要将新Leader的数据同步到自己的缓存中，这是初始化同步;当Leader的数据被客户端修改后，其会向Follower发出广播，然后各个Follower会主动同步Leader的更新数据，这是更新同步。无论是初始化同步还是更新同步，zk 集群为了保证数据的一致性，若发现超过半数的Follower同步超时，则其会再次进行同步，而这个过程中zk集群是处于不可用状态的。</p><p>由于zk采用了CP原则，所以导致其可用性降低，这是其致命的问题。Spring Cloud的Eureka在分布式系统中所起的作用类似于zk，但其采用了AP原则，其牺牲了一致性，但保证了可用性</p><h2 id="zookeeper安装与集群搭建"><a class="markdownIt-Anchor" href="#zookeeper安装与集群搭建"></a> zookeeper安装与集群搭建</h2><h3 id="zookeeper环境准备"><a class="markdownIt-Anchor" href="#zookeeper环境准备"></a> zookeeper环境准备</h3><p><strong>下载</strong></p><p>下载完成后上传到Linux服务器</p><p><a href="http://mirrors.hust.edu.cn/apache/zookeeper/">http://mirrors.hust.edu.cn/apache/zookeeper/</a></p><p><strong>解压</strong>：解压到/usr/local目录</p><pre><code class="highlight plaintext">tar -zxvf /home/leeboer/leeftp/zookeeper-3.4.13.tar.gz -C /usr/local/</code></pre><p>可执行的命令在zookeeper根目录的bin目录下：</p><p><strong>注册path</strong></p><p>注册之前我们先建立一个软连接（防止以后更换zookeeper要重新注册path）</p><pre><code class="highlight plaintext">ln -s ./zookeeper-3.4.13 /usr/local/zookeeper</code></pre><p>将zookeeper的bin目录注册到path目录下：</p><pre><code class="highlight plaintext">vim /etc/profile</code></pre><p>在文档末尾写如下配置：</p><pre><code class="highlight plaintext">export ZK_HOME=/usr/local/zookeeperexport PATH=$ZK_HOME/bin:$PATH</code></pre><p>然后重新加载该文件</p><pre><code class="highlight plaintext">source /etc/profile</code></pre><h3 id="配置zookeeper"><a class="markdownIt-Anchor" href="#配置zookeeper"></a> 配置zookeeper</h3><p>该文件为zookeeper的样例<code>/zookeeper/conf/zoo_sample.cfg</code></p><p>拷贝一份：</p><pre><code class="highlight plaintext">cp zoo_sample.cfg zoo.cfg</code></pre><p>然后编辑<code>zoo.cfg</code></p><pre><code class="highlight plaintext"># The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial # synchronization phase can takeinitLimit=10# The number of ticks that can pass between # sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just # example sakes.# 快照存储的目录，(默认目录为/tmp/zookeeper)一定要更换！dataDir=/usr/data/zookeeper# the port at which the clients will connect# 端口clientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns=60## Be sure to read the maintenance section of the # administrator guide before turning on autopurge.## http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount=3# Purge task interval in hours# Set to &quot;0&quot; to disable auto purge feature#autopurge.purgeInterval=1 ~</code></pre><p><strong>启动zookeeper</strong></p><pre><code class="highlight plaintext">zkServer.sh start</code></pre><p><strong>重新启动</strong></p><pre><code class="highlight plaintext">zkServer.sh restart</code></pre><p><strong>关闭zookeeper</strong></p><pre><code class="highlight plaintext">zkServer.sh stop</code></pre><p><strong>查看zookeeper的状态</strong></p><pre><code class="highlight plaintext">zkServer.sh status</code></pre><p><strong>查看进程</strong></p><pre><code class="highlight plaintext">ps aux|grep aookeeper</code></pre><h2 id="zookeeper集群搭建"><a class="markdownIt-Anchor" href="#zookeeper集群搭建"></a> zookeeper集群搭建</h2><p>在刚才上面指定的zookeeper快照目录下<code>/usr/data/zookeeper</code></p><p>创建文件<code>myid</code>,内容写 1 就可以</p><pre><code class="highlight plaintext">echo 1 &gt; myid</code></pre><p><strong>配置zookeeper配置文件</strong></p><p><code>vim /usr/local/zookeeper/conf/zoo.cfg </code>加入：</p><ul><li>ip：连接端口号（数据同步时使用/随便写）：选举端口号（选举时使用/随便写）</li><li>如果需要指定observer，只需在最后加上 <code>:observer</code> 即可</li></ul><pre><code class="highlight plaintext">server.1=192.168.79.13:288:3888server.2=192.168.79.14:288:3888server.3=192.168.79.15:288:3888server.4=192.168.79.16:288:3888:observer</code></pre><blockquote><p>server.1/server.2/server.3每个zookeeper的配置文件都是上述这样即可</p></blockquote><blockquote><p>注意：server.4是observer，需要在配置文件中单独加一段配置</p></blockquote><pre><code class="highlight plaintext">peerType=observer</code></pre><p><strong>然后依次启动各个zookeeper即可</strong></p><pre><code class="highlight plaintext">zkServer.sh start</code></pre><blockquote><p>第一台启动时查看状态</p></blockquote><blockquote><p>第二台启动时查看状态</p></blockquote><blockquote><p>第三台启动时查看状态</p></blockquote><blockquote><p>当第二台挂掉后第三台自动选举为leader（因为myid大）</p></blockquote><h2 id="leader的选举机制"><a class="markdownIt-Anchor" href="#leader的选举机制"></a> leader的选举机制</h2><h3 id="myid"><a class="markdownIt-Anchor" href="#myid"></a> myid</h3><p>这是zk集群中服务器的唯一标识，称为myid。例如：有三个zk服务器，那么编号分别为1，2，3</p><h3 id="逻辑时钟"><a class="markdownIt-Anchor" href="#逻辑时钟"></a> 逻辑时钟</h3><p>逻辑时钟，Logicalock，是一个整型树，改概念在选举时称为logicalclock，而在zxid中则为epoch的值，即epoch和logicalclock是同一个值，在不同情况下的不同名称</p><h3 id="zk状态"><a class="markdownIt-Anchor" href="#zk状态"></a> zk状态</h3><ul><li><strong>LOOKING</strong>：选举状态（查找leader的状态）</li><li><strong>FOLLOWING</strong>：跟随状态，同步leader状态，处于该状态的服务器称为Follower。</li><li><strong>OBSERVING</strong>：观察状态，同步leader状态，处于该状态的服务器称为Observer</li><li><strong>LEADING</strong>：领导状态。处于该状态的服务器称为Leader</li></ul>]]>
    </content>
    <id>http://example.com/2022/12/29/zookeeper/</id>
    <link href="http://example.com/2022/12/29/zookeeper/"/>
    <published>2022-12-29T04:00:00.000Z</published>
    <summary>zookeeper是一个开源的分布式应用程序协调服务器，其为分布式系统提供一致性服务。其一致性是通过基于Paxos算法的ZAB协议完成的，其主要功能包括：配置维护，域名服务，分布式同步，集群管理等。</summary>
    <title>zookeeper</title>
    <updated>2026-02-27T01:41:21.403Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    <content>
      <![CDATA[<h1 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> $Linux</h1><h1 id="liunx"><a class="markdownIt-Anchor" href="#liunx"></a> Liunx</h1><ul><li><a href="">Liunx</a><ul><li><a href="">简介</a><ul><li><a href="">常见的Linux系统版本</a></li><li><a href="">应用领域</a></li><li><a href="">了解红帽认证</a></li></ul></li><li><a href="">系统目录结构</a></li><li><a href="">键盘操作技巧</a></li><li><a href="">使用命令</a><ul><li><a href="">识别命令</a><ul><li><a href="">type 显示命令的类型</a></li><li><a href="">which 显示一个可执行命令的位置</a></li></ul></li><li><a href="">得到帮助文档</a><ul><li><a href="">help 得到shell内部命令帮助文档</a></li><li><a href="">–help - 显示用法信息</a></li><li><a href="">whatis 显示非常简洁的命令说明</a></li></ul></li><li><a href="">alias 创建自己的命令</a></li><li><a href="">命令执行顺序</a></li></ul></li><li><a href="">命令展开</a><ul><li><a href="">路径名展开</a></li><li><a href="">波浪线展开</a></li><li><a href="">算数表达式展开</a></li><li><a href="">花括号展开</a></li><li><a href="">双引号</a></li><li><a href="">单引号</a></li><li><a href="">转义字符</a></li></ul></li><li><a href="">系统命令</a><ul><li><a href="">常用系统工作命令</a><ul><li><a href="">echo</a></li><li><a href="">date</a></li><li><a href="">reboot重启/poweroff关机</a></li><li><a href="">su/sudo</a></li><li><a href="">systemctl</a></li></ul></li><li><a href="">系统状态检测命令</a><ul><li><a href="">ifconfig命令</a></li><li><a href="">uname命令</a></li><li><a href="">uptime命令</a></li><li><a href="">free命令</a></li><li><a href="">who</a></li><li><a href="">last</a></li><li><a href="">history</a></li></ul></li><li><a href="">配置主机名称</a></li><li><a href="">配置网卡信息</a></li><li><a href="">Yum</a></li><li><a href="">计划任务服务程序</a><ul><li><a href="">一次性计划任务</a></li><li><a href="">长期性计划任务</a></li></ul></li></ul></li><li><a href="">文件权限</a><ul><li><a href="">文件属主和属组</a><ul><li><a href="">更改文件属组 chgrp</a></li><li><a href="">更改文件属主 chown</a></li></ul></li><li><a href="">文件权限 chmod</a></li><li><a href="">文件的特殊权限</a><ul><li><a href="">SUID</a></li><li><a href="">SGID</a></li><li><a href="">SBIT</a></li></ul></li><li><a href="">文件的隐藏属性</a><ul><li><a href="">chattr</a></li><li><a href="">lsattr</a></li></ul></li></ul></li><li><a href="">文件/目录</a><ul><li><a href="">处理目录常用命令</a><ul><li><a href="">ls(列出目录)</a></li><li><a href="">cd(切换目录)</a></li><li><a href="">pwd(显示目前所在的目录)</a></li><li><a href="">mkdir(创建新目录)</a></li><li><a href="">rmdir(删除空目录)</a></li><li><a href="">rm(移除文件或目录)</a></li><li><a href="">cp(复制文件或目录)</a></li><li><a href="">mv(移动文件与目录，或修改名称)</a></li><li><a href="">touch</a></li><li><a href="">dd</a></li><li><a href="">file(查看文件类型)</a></li></ul></li><li><a href="">软硬方式连接</a><ul><li><a href="">ln</a></li></ul></li><li><a href="">文件内容查看</a><ul><li><a href="">cat(由第一行开始显示文件内容)</a></li><li><a href="">tac(由最后一行开始显示文件内容)</a></li><li><a href="">nl(可以显示行号)</a></li><li><a href="">more(一页一页翻动)</a></li><li><a href="">less(一页一页翻动)</a></li><li><a href="">head(取出文件前几行)</a></li><li><a href="">tail(取出文件后几行)</a></li><li><a href="">tr(替换文本内容)</a></li><li><a href="">wc(统计行数)</a></li><li><a href="">stat(查看文件信息)</a></li><li><a href="">cut(提取列)</a></li><li><a href="">diff(比较)</a></li></ul></li><li><a href="">查找</a><ul><li><a href="">find</a></li><li><a href="">whereis</a></li><li><a href="">locate</a></li><li><a href="">which</a></li><li><a href="">grep</a></li></ul></li></ul></li><li><a href="">归档备份</a><ul><li><a href="">解压缩</a><ul><li><a href="">gzip</a></li><li><a href="">bzip2</a></li></ul></li><li><a href="">归档文件</a><ul><li><a href="">tar 打�</a>�</li><li><a href="">zip</a></li></ul></li></ul></li><li><a href="">用户/用户组管理</a><ul><li><a href="">用户账号的管理</a><ul><li><a href="">useradd(添加新用户)</a></li><li><a href="">userdel(删除账号)</a></li><li><a href="">usermod(修改账号)</a></li><li><a href="">passwd(用户口令的管理)</a></li></ul></li><li><a href="">用户组的管理</a><ul><li><a href="">group(增加用户组)</a></li><li><a href="">groupdel(删除用户组)</a></li><li><a href="">groupmod(修改用户组)</a></li><li><a href="">切换用户组</a></li></ul></li><li><a href="">与用户账号有关的系统文件</a><ul><li><a href="">/etc/passwd 用户信息</a></li><li><a href="">/etc/group 用户组</a></li><li><a href="">批量添加用户</a></li></ul></li></ul></li><li><a href="">管道符/重定向/环境变量</a><ul><li><a href="">输入输出重定向</a></li><li><a href="">管道命令符</a></li><li><a href="">命令行的通配符</a></li><li><a href="">常用的转义字符</a></li><li><a href="">重要的环境变量</a></li></ul></li><li><a href="">存储结构/磁盘划分</a><ul><li><a href="">物理设备的命名规则</a></li><li><a href="">挂载硬件设备</a><ul><li><a href="">mount</a></li><li><a href="">umount</a></li></ul></li><li><a href="">添加硬盘设备</a><ul><li><a href="">fdisk命令（分区）</a></li><li><a href="">mkfs（格式化）</a></li><li><a href="">du（查看文件数据占用量）</a></li></ul></li><li><a href="">添加交换分区</a></li></ul></li><li><a href="">vi/vim</a></li><li><a href="">进程</a><ul><li><a href="">ps 查看进程</a></li><li><a href="">top 显示任务</a></li><li><a href="">进程相关命令</a><ul><li><a href="">停止/暂停</a></li><li><a href="">放置到后台执行</a></li><li><a href="">jobs 显示活跃任务</a></li><li><a href="">fg/bg</a></li><li><a href="">pidof</a></li><li><a href="">kill /killall</a></li></ul></li></ul></li><li><a href="">shell环境变量</a><ul><li><a href="">查看环境变量</a></li><li><a href="">建立环境变量</a></li><li><a href="">export命令</a></li><li><a href="">修改shell环境</a></li></ul></li><li><a href="">软件包管理</a><ul><li><a href="">yum命令</a><ul><li><a href="">yum搜索软件�</a>�</li><li><a href="">yum安装软件�</a>�</li><li><a href="">yum卸载软件</a></li><li><a href="">yum更新软件�</a>�</li><li><a href="">配置阿里镜像</a></li><li><a href="">查找软件并删除</a></li></ul></li><li><a href="">rpm</a><ul><li><a href="">通过软件包文件来安装软件</a></li><li><a href="">经过软件包来升级软件</a></li><li><a href="">列出所安装的软件�</a>�</li><li><a href="">删除软件</a></li></ul></li></ul></li><li><a href="">网络系统</a><ul><li><a href="">检查和检测网络</a><ul><li><a href="">ping</a></li><li><a href="">netstat</a></li></ul></li><li><a href="">网络中传输文件</a><ul><li><a href="">ftp</a></li><li><a href="">wget 下载</a></li><li><a href="">scp远程拷贝</a></li></ul></li><li><a href="">SSH</a></li><li><a href="">防火墙</a><ul><li><a href="">打开防火墙</a></li><li><a href="">关闭防火墙</a></li><li><a href="">iptables</a><ul><li><a href="">策略与规则链</a></li><li><a href="">基本命令参数</a></li><li><a href="">允许某个ip某个端口访问</a></li><li><a href="">示例</a></li></ul></li><li><a href="">Firewalld</a><ul><li><a href="">终端管理工具</a></li><li><a href="">示例</a></li><li><a href="">图形管理工具</a></li></ul></li></ul></li><li><a href="">开放指定端口</a></li><li><a href="">服务的访问控制列表</a></li></ul></li><li><a href="">常用命令</a><ul><li><a href="">dirname/basename(截取路径)</a></li><li><a href="">w3m</a></li><li><a href="">split</a></li><li><a href="">cpulimit</a><ul><li><a href="">安�</a>�</li><li><a href="">使用</a></li></ul></li></ul></li></ul></li></ul><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><h3 id="常见的linux系统版本"><a class="markdownIt-Anchor" href="#常见的linux系统版本"></a> 常见的Linux系统版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、硬盘及文件系统控制及多任务功能的系统核心程序。而Linux发行套件系统是我们常说的Linux操作系统，也即是由Linux内核与各种常用软件的集合产品。全球大约有数百款的Linux系统版本，每个系统版本都有自己的特性和目标人群，下面将可以从用户的角度选出最热门的几款进行介绍。</p><ul><li>Linux的发行版<ul><li>指将Liunx内核与应用软件做一个打包</li><li>知名发行版有：Ubuntu，RedHat，CentOS，Debian，Fedora，SuSE，OpenSUSE，ArchLiunx，SolusOS</li></ul></li></ul><hr /><ul><li><strong>redhat</strong> 红帽企业系统（RedHatEnterpriseLinux,RHEL.）</li><li><img src="image/.png" alt=".png" /><ul><li>红帽公司是全球最大的开源技术厂商，RHEL是全世界内使用最广泛的Linux系统。</li><li>RHEL系统具有极强的性能与稳定性，并且在全球范围内拥有完善的技术支持。</li><li>RHEL系统也是本书、红帽认证以及众多生产环境中使用的系统。</li></ul></li></ul><hr /><ul><li><strong>CentOS</strong></li><li><img src="image/-1.png" alt="-1.png" /><ul><li>通过把RHEL系统重新编译并发布给用户免费使用的Linux系统，具有广泛的使用人群。CentOS当前已被红帽公司“收编”</li></ul></li></ul><hr /><ul><li><strong>Fedora</strong></li><li><img src="image/-2.png" alt="-2.png" /><ul><li>由红帽公司发布的桌面版系统套件（目前已经不限于桌面版）</li><li>用户可免费体验到最新的技术或工具，这些技术或工具在成熟后会被加入到RHEL系统中，因此Fedora也称为RHEL系统的“试验田”。</li><li>运维人员如果想时刻保持自己的技术领先，就应该多关注此类Linux系统的发展变化及新特性，不断改变自己的学习方向。</li></ul></li></ul><hr /><ul><li><strong>openSUSE</strong></li><li><img src="image/-3.png" alt="-3.png" /><ul><li>源自德国的一款著名的Linux系统，在全球范围内有着不错的声誉及市场占有率。</li></ul></li></ul><hr /><ul><li><strong>Gentoo</strong></li><li><img src="image/-4.png" alt="-4.png" /><ul><li>具有极高的自定制性，操作复杂，因此适合有经验的人员使用。读者可以在学习完本书后尝试一下该系统。</li></ul></li></ul><hr /><ul><li><strong>Debian</strong></li><li><img src="image/-5.png" alt="-5.png" /><ul><li>稳定性、安全性强，提供了免费的基础支持，可以良好地支持各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。</li></ul></li></ul><hr /><ul><li><strong>Ubuntu</strong></li><li><img src="image/-6.png" alt="-6.png" /><ul><li>是一款派生自Debian的操作系统，对新款硬件具有极强的兼容能力。Ubuntu与Fedora都是极其出色的Linux桌面系统，而且Ubuntu也可用于服务器领域。</li></ul></li></ul><p>现在国内大多数Linux相关的图书都是围绕CentOS系统编写的，作者大多也会给出围绕CentOS进行写作的一系列理由，但是很多理由都站不住脚，根本没有剖析到CentOS系统与RHEL系统的本质关系。CentOS系统是通过把RHEL系统释放出的程序源代码经过二次编译之后生成的一种Linux系统，其命令操作和服务配置方法与RHEL完全相同，但是去掉了很多收费的服务套件功能，而且还不提供任何形式的技术支持，出现问题后只能由运维人员自己解决。经过这般分析基本上可以判断出，选择CentOS的理由只剩下—免费！当人们大举免费、开源、正义的旗帜来宣扬CentOS系统的时候，殊不知CentOS系统其实早在2014年年初就已经被红帽公司“收编”，当前只是战略性的免费而已。再者说，根据GNU GPL许可协议，我们同样也可以免费使用RHEL系统，甚至是修改其代码创建衍生产品。开源系统在自由程度上没有任何差异，更无关道德问题。</p><h3 id="应用领域"><a class="markdownIt-Anchor" href="#应用领域"></a> 应用领域</h3><ul><li>Linux应用领域<ul><li>嵌入设备，超级计算机，服务器</li><li>通常服务器使用LAMP（Liunx+Apache+MySQL+PHP）或LNMP（Linux+Nginx+MySQL+PHP）组合</li></ul></li><li>Linux vs Windows</li></ul><table><thead><tr><th>比较</th><th>Windows</th><th>Linux</th></tr></thead><tbody><tr><td>界面</td><td>界面统一，外壳程序固定所有Windows程序菜单几乎一致，快捷键也几乎相同</td><td>图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux的终端机是从UNIX传承下来，基本命令和操作方法也几乎一致。</td></tr><tr><td>驱动程序</td><td>驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的Windows下的驱动，也会比较头痛</td><td>由志愿者开发，由Linux核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在Windows下很难支持的也容易找到驱动。HP、Intel、AMD等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解</td></tr><tr><td>使用</td><td>使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利</td><td>图形界面使用简单，容易入门。文字界面，需要学习才能掌握</td></tr><tr><td>学习</td><td>系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难</td><td>系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易</td></tr><tr><td>软件</td><td>每一种特定功能可能都需要商业软件的支持，需要购买相应的授权</td><td>大部分软件都可以自由获取，同样功能的软件选择较少</td></tr></tbody></table><h3 id="了解红帽认证"><a class="markdownIt-Anchor" href="#了解红帽认证"></a> 了解红帽认证</h3><p>红帽公司成立于1993年，是全球首家收入超10亿美元的开源公司，总部位于美国，分支机构遍布全球。红帽公司作为全球领先的开源和Linux系统提供商，其产品已被业界广泛认可并使用，尤其是RHEL系统在业内拥有超高的Linux系统市场占有率。红帽公司除了提供操作系统之外，还提供了虚拟化、中间件、应用程序、管理和面向服务架构的解决方案。</p><p>红帽认证是由红帽公司推出的Linux认证，该认证被认为是Linux行业乃至整个IT领域价值最高的认证之一。红帽认证考试全部采用上机形式，在考察学生基础理论能力的同时还考察了实践动手操作以及排错能力。红帽公司针对红帽认证制定了完善的专业评估与认证标准，其认证主要包括红帽认证系统管理员（RHCSA）、红帽认证工程师（RHCE）与红帽认证架构师（RHCA）。</p><p>2014年6月10日，红帽公司在发布新版红帽企业版系统（RHEL 7）的当天即在红帽英文官网更新了其对RHCSA与RHCE培训政策的调整，考生只有先通过红帽RHCSA认证后才能考取红帽RHCE认证。</p><p><img src="image/-7.png" alt="-7.png" /></p><h2 id="系统目录结构"><a class="markdownIt-Anchor" href="#系统目录结构"></a> 系统目录结构</h2><p>登录系统后，在当前命令窗口下输入命令：</p><pre><code class="highlight plaintext">ls /</code></pre><p>你会看到如下图所示:</p><p><img src="image/-8.png" alt="-8.png" /></p><p>树状目录结构：</p><p><img src="image/-9.png" alt="-9.png" /></p><p>系统启动必须：</p><ul><li><strong>/boot</strong>：这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li><li><strong>/etc</strong>：这个目录用来存放所有的系统管理所需要的配置文件和子目录，更改该目录下的文件可能导致系统无法启动。</li><li><strong>/lib</strong>：存放基本代码库（比如c++库），其作用类似于Windows的DDL文件，几乎所有的应用程序都需要用到这些共享库。</li><li><strong>/sys</strong>：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</li></ul><p>指令集合：</p><ul><li><strong>/bin</strong>：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li><li><strong>/sbin</strong>：s就是super user的意思，这里存放的是系统管理员使用的系统管理程序。</li></ul><p>外部文件管理：</p><ul><li><strong>/dev</strong> ：dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</li><li><strong>/media</strong>：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li><li><strong>/mnt</strong>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</li></ul><p>临时文件：</p><ul><li><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run</li><li><strong>/tmp</strong>：这个目录用来存放一些临时文件。</li><li><strong>/lost+found</strong>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li></ul><p>账户：</p><ul><li><strong>/root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。</li><li><strong>/home</strong>：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li><li><strong>/usr</strong>：这是一个很重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于Windows的program files目录。</li><li><strong>/usr/bin</strong>：系统用户使用的应用程序。</li><li><strong>/usr/sbin</strong>：超级用户使用的比较高级的管理程序和系统守护程序。</li><li><strong>usr/src</strong>：内核源代码默认的放置位置。</li></ul><p>运行过程中要用：</p><ul><li><strong>/var</strong>：这个目录中存放着不断扩充的东西，我们习惯将那些经常被修改的目录存放到这个目录下，包括各种日志文件。</li><li><strong>/proc</strong>：管理内存空间！虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。</li></ul><p>扩展用：</p><ul><li><strong>/opt</strong>：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</li><li><strong>/srv</strong>：该目录存放一些服务启动之后需要提取的数据。</li><li><strong>/selinux</strong>：这个目录是Redhat/CentOS所持有的目录，Selinux是一个安全机制，类似于Windows的防火墙，到那时这套机制比较复杂，这个目录就是存放selinux相关文件的。</li></ul><hr /><p>在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。</p><blockquote><p>/etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。</p></blockquote><blockquote><p>/bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在/bin/ls 目录下的。</p></blockquote><blockquote><p>值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给root使用的指令。</p></blockquote><blockquote><p>/var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在/var/log 目录下，另外mail的预设放置也是在这里。</p></blockquote><h2 id="键盘操作技巧"><a class="markdownIt-Anchor" href="#键盘操作技巧"></a> 键盘操作技巧</h2><p>开玩笑地说，我经常把 Unix 描述为“这个操作系统是为喜欢敲键盘的人们服务的。” 当然，Unix 甚至还有一个命令行，这个事实是个确凿的证据，证明了我所说的话。 但是命令行用户不喜欢敲入那么多字。那又为什么如此多的命令会有这样简短的命令名，像 cp，ls，mv，和 rm？事实上，命令行最为珍视的目标之一就是懒惰；用最少的击键次数 来完成最多的工作。另一个目标是你的手指永远不必离开键盘，永不触摸鼠标。在这一 章节，我们将看一下 bash 特性，这些特性使键盘使用起来更加迅速，更加高效。以下命令将会露面：</p><ul><li>clear － 清空屏幕</li><li>history － 显示历史列表内容</li></ul><p><strong>移动光标</strong></p><table><thead><tr><th>按键</th><th>行动</th></tr></thead><tbody><tr><td>Ctrl-a</td><td>移动光标到行首。</td></tr><tr><td>Ctrl-e</td><td>移动光标到行尾。</td></tr><tr><td>Ctrl-f</td><td>光标前移一个字符；和右箭头作用一样。</td></tr><tr><td>Ctrl-b</td><td>光标后移一个字符；和左箭头作用一样。</td></tr><tr><td>Alt-f</td><td>光标前移一个字。</td></tr><tr><td>Alt-b</td><td>光标后移一个字。</td></tr><tr><td>Ctrl-l</td><td>清空屏幕，移动光标到左上角。clear 命令完成同样的工作。</td></tr></tbody></table><p><strong>修改文本</strong></p><table><thead><tr><th>按键</th><th>行动</th></tr></thead><tbody><tr><td>Ctrl-d</td><td>删除光标位置的字符。</td></tr><tr><td>Ctrl-t</td><td>光标位置的字符和光标前面的字符互换位置。</td></tr><tr><td>Alt-t</td><td>光标位置的字和其前面的字互换位置。</td></tr><tr><td>Alt-l</td><td>把从光标位置到字尾的字符转换成小写字母。</td></tr><tr><td>Alt-u</td><td>把从光标位置到字尾的字符转换成大写字母。</td></tr></tbody></table><p><strong>剪切/粘贴文本</strong></p><table><thead><tr><th>按键</th><th>行动</th></tr></thead><tbody><tr><td>Ctrl-k</td><td>剪切从光标位置到行尾的文本。</td></tr><tr><td>Ctrl-u</td><td>剪切从光标位置到行首的文本。</td></tr><tr><td>Alt-d</td><td>剪切从光标位置到词尾的文本。</td></tr><tr><td>Alt-Backspace</td><td>剪切从光标位置到词头的文本。如果光标在一个单词的开头，剪切前一个单词。</td></tr><tr><td>Ctrl-y</td><td>把剪切环中的文本粘贴到光标位置。</td></tr></tbody></table><p><strong>搜索历史命令</strong></p><p>在任何时候，我们都可以浏览历史列表的内容，通过：</p><pre><code class="highlight plaintext">$ history | less</code></pre><p>在默认情况下，bash 会存储你所输入的最后 500 个命令。在随后的章节里，我们会知道 怎样调整这个数值。比方说我们想要找到列出目录 /usr/bin 内容的命令。一种方法，我们可以这样做：</p><pre><code class="highlight plaintext">$ history | grep /usr/bin</code></pre><p>比方说在我们的搜索结果之中，我们得到一行，包含了有趣的命令，像这样；</p><pre><code class="highlight plaintext">88  ls -l /usr/bin &gt; ls-output.txt</code></pre><p>数字 “88” 是这个命令在历史列表中的行号。随后在使用另一种展开类型时，叫做 历史命令展开，我们会用到这个数字。我们可以这样做，来使用我们所发现的行：</p><pre><code class="highlight plaintext">$ !88</code></pre><h2 id="使用命令"><a class="markdownIt-Anchor" href="#使用命令"></a> 使用命令</h2><p>命令可以是下面四种形式之一：</p><ul><li><strong>可执行程序</strong>，就像我们所看到的位于目录/usr/bin 中的文件一样。 属于这一类的程序，可以编译成二进制文件，诸如用 C 和 C++语言写成的程序, 也可以是由脚本语言写成的程序，比如说 shell，perl，python，ruby，等等。</li><li><strong>内建于 shell 自身的命令</strong>。bash 支持若干命令，内部叫做 shell 内部命令 (builtins)。例如，cd 命令，就是一个 shell 内部命令。</li><li><strong>shell 函数</strong>。这些是小规模的 shell 脚本，它们混合到环境变量中。 在后续的章节里，我们将讨论配置环境变量以及书写 shell 函数。但是现在， 仅仅意识到它们的存在就可以了。</li><li><strong>命令别名</strong>。我们可以定义自己的命令，建立在其它命令之上。</li></ul><h3 id="识别命令"><a class="markdownIt-Anchor" href="#识别命令"></a> 识别命令</h3><h4 id="type-显示命令的类型"><a class="markdownIt-Anchor" href="#type-显示命令的类型"></a> type 显示命令的类型</h4><p>type 命令是 shell 内部命令，它会显示命令的类别，给出一个特定的命令名（做为参数）。 它像这样工作：</p><pre><code class="highlight plaintext">type command</code></pre><p>例子：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ type typetype is a shell builtins[me@linuxbox ~]$ type lsls is aliased to `ls --color=tty`[me@linuxbox ~]$ type cpcp is /bin/cp</code></pre><p>我们看到这三个不同命令的检测结果。注意，ls 命令（在 Fedora 系统中）的检查结果，ls 命令实际上 是 ls 命令加上选项”–color=tty”的别名。现在我们知道为什么 ls 的输出结果是有颜色的！</p><h4 id="which-显示一个可执行命令的位置"><a class="markdownIt-Anchor" href="#which-显示一个可执行命令的位置"></a> which 显示一个可执行命令的位置</h4><p>有时候在一个操作系统中，不只安装了可执行程序的一个版本。然而在桌面系统中，这并不普遍， 但在大型服务器中，却很平常。为了确定所给定的执行程序的准确位置，使用 which 命令：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ which ls/bin/ls</code></pre><p>这个命令只对可执行程序有效，不包括内部命令和命令别名，别名是真正的可执行程序的替代物。 当我们试着使用 shell 内部命令时，例如，cd 命令，我们或者得不到回应，或者是个错误信息：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ which cd/usr/bin/which: no cd in(/opt/jre1.6.0_03/bin:/usr/lib/qt-3.3/bin:/usr/kerberos/bin:/opt/jre1.6.0_03/bin:/usr/lib/ccache:/usr/local/bin:/usr/bin:/bin:/home/me/bin)</code></pre><h3 id="得到帮助文档"><a class="markdownIt-Anchor" href="#得到帮助文档"></a> 得到帮助文档</h3><h4 id="help-得到shell内部命令帮助文档"><a class="markdownIt-Anchor" href="#help-得到shell内部命令帮助文档"></a> help 得到shell内部命令帮助文档</h4><p>bash 有一个内建的帮助工具，可供每一个 shell 内部命令使用。输入“help”，接着是 shell 内部命令名。例如：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ help cdcd: cd [-L|-P] [dir]Change ...</code></pre><p>注意表示法：出现在命令语法说明中的方括号，表示可选的项目。一个竖杠字符 表示互斥选项。在上面 cd 命令的例子中：</p><pre><code class="highlight plaintext">cd [-L|-P] [dir]</code></pre><p>这种表示法说明，cd 命令可能有一个“-L”选项或者“-P”选项，进一步，可能有参数“dir”。</p><h4 id="help-显示用法信息"><a class="markdownIt-Anchor" href="#help-显示用法信息"></a> –help - 显示用法信息</h4><p>许多可执行程序支持一个 --help 选项，这个选项是显示命令所支持的语法和选项说明。例如：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ mkdir --helpUsage: mkdir [OPTION] DIRECTORY...Create ...</code></pre><h4 id="whatis-显示非常简洁的命令说明"><a class="markdownIt-Anchor" href="#whatis-显示非常简洁的命令说明"></a> whatis 显示非常简洁的命令说明</h4><p>whatis 程序显示匹配特定关键字的手册页的名字和一行命令说明：</p><blockquote><p>最晦涩难懂的手册页</p><p>正如我们所看到的，Linux 和类 Unix 的系统提供的手册页，只是打算作为参考手册使用， 而不是教材。许多手册页都很难阅读，但是我认为由于阅读难度而能拿到特等奖的手册页应该是 bash 手册页。因为我正在为这本书做我的研究，所以我很仔细地浏览了整个 bash 手册，为的是确保我讲述了 大部分的 bash 主题。当把 bash 参考手册整个打印出来，其篇幅有八十多页且内容极其紧密， 但对于初学者来说，其结构安排毫无意义。</p><p>另一方面，bash 参考手册的内容非常简明精确，同时也非常完善。所以，如果你有胆量就查看一下， 并且期望有一天你能读懂它。</p></blockquote><h3 id="alias-创建自己的命令"><a class="markdownIt-Anchor" href="#alias-创建自己的命令"></a> alias 创建自己的命令</h3><p>现在是时候，感受第一次编程经历了！我们将用 alias 命令创建我们自己的命令。但在 开始之前，我们需要展示一个命令行小技巧。<strong>可以把多个命令放在同一行上，命令之间 用”;”分开</strong>。它像这样工作：</p><pre><code class="highlight plaintext">command1; command2; command3...</code></pre><p>我们会用到下面的例子：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ cd /usr; ls; cd -bin  games    kerberos  lib64    local  share  tmp...[me@linuxbox ~]$</code></pre><p>正如我们看到的，我们在一行上联合了三个命令。首先更改目录到/usr，然后列出目录 内容，最后回到原始目录（用命令”cd ~”）,结束在开始的地方。现在，通过 alia 命令 把这一串命令转变为一个命令。我们要做的第一件事就是为我们的新命令构想一个名字。 比方说”test”。在使用”test”之前，查明是否”test”命令名已经存在系统中，是个很不错 的主意。为了查清此事，可以使用 type 命令：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ type testtest is a shell builtin</code></pre><p>哦！”test”名字已经被使用了。试一下”foo”:</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ type foobash: type: foo: not found</code></pre><p>太棒了！”foo”还没被占用。创建命令别名：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ alias foo=&#x27;cd /usr; ls; cd -&#x27;</code></pre><p><strong>创建命令</strong> 注意命令结构：</p><pre><code class="highlight plaintext">alias name=&#x27;string&#x27;</code></pre><blockquote><p>在命令”alias”之后，输入“name”，紧接着（没有空格）是一个等号，等号之后是 一串用引号引起的字符串，字符串的内容要赋值给 name。我们定义了别名之后， 这个命令别名可以使用在任何地方。</p></blockquote><p><strong>删除别名</strong></p><pre><code class="highlight plaintext">[me@linuxbox ~]$ unalias foo[me@linuxbox ~]$ type foobash: type: foo: not found</code></pre><p><strong>查看所有的别名</strong></p><pre><code class="highlight plaintext">[me@linuxbox ~]$ aliasalias l.=&#x27;ls -d .* --color=tty&#x27;</code></pre><h3 id="命令执行顺序"><a class="markdownIt-Anchor" href="#命令执行顺序"></a> 命令执行顺序</h3><p>Linux顺序执行共有三种符号：</p><ul><li><strong>command1 &amp;&amp; command2</strong>: &amp;&amp;左边的command1执行成功(返回0表示成功)后，&amp;&amp;右边的command2才能被执行。</li><li><strong>command1 || command2</strong>: 如果||左边的command1执行失败(返回1表示失败)，就执行&amp;&amp;右边的command2。</li><li><strong>command1 ; command2</strong>: 命令顺序执行</li></ul><pre><code class="highlight plaintext">#第一个命令执行不成功,第二个命令才执行[tough@toughhou shell]cata||touchacat:a:Nosuchfileordirectory[tough@toughhoushell]  ls a  getpath.sh #第一个命令执行成功,第二个命令不执行[tough@toughhou shell]cata||touchb[tough@toughhoushell]  ls a  getpath.sh #只有第一个命令(touch a)执行成功,才执行第二个命令(touch b) [tough@toughhou shell]touch a &amp;&amp; touch b[tough@toughhou shell] ls a  b  getpath.sh #因为第一个命令执行不成功,所以第二个命令没执行[tough@toughhou shell]cat a1 &amp;&amp; touch c    cat: a1: No such file or directory    [tough@toughhou shell] ls a  b  getpath.sh #命令顺序执行[tough@toughhou shell]$ pwd;more a;date /home/tough/shell 123 Sun Oct 13 10:24:55 CST 2013 &lt;br&gt;&lt;br data-tomark-pass&gt;&lt;br data-tomark-pass&gt;</code></pre><h2 id="命令展开"><a class="markdownIt-Anchor" href="#命令展开"></a> 命令展开</h2><p>每一次你输入一个命令，然后按下 enter 键，在 bash 执行你的命令之前，bash 会对输入 的字符完成几个步骤处理。我们已经知道两三个案例，怎样一个简单的字符序列，例如<code>“*”</code>, 对 shell 来说，有很多的涵义。</p><p>使这个发生的过程叫做（字符）展开。通过展开， 你输入的字符，在 shell 对它起作用之前，会展开成为别的字符。</p><h3 id="路径名展开"><a class="markdownIt-Anchor" href="#路径名展开"></a> 路径名展开</h3><p>这种通配符工作机制叫做路径名展开。如果我们试一下在之前的章节中使用的技巧， 我们会看到它们真是要展开的字符。给出一个家目录，它看起来像这样：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ lsDesktop   ls-output.txt   Pictures   Templates....</code></pre><p>我们能够执行以下参数展开模式：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo D*Desktop  Documents</code></pre><p>和：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo *sDocuments Pictures Templates Videos</code></pre><p>甚至是：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo [[:upper:]]*Desktop Documents Music Pictures Public Templates Videos</code></pre><p>查看家目录之外的目录：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo /usr/*/share/usr/kerberos/share  /usr/local/share</code></pre><h3 id="波浪线展开"><a class="markdownIt-Anchor" href="#波浪线展开"></a> 波浪线展开</h3><p>可能你从我们对 cd 命令的介绍中回想起来，波浪线字符(“~”)有特殊的意思。当它用在 一个单词的开头时，它会展开成指定用户的家目录名，如果没有指定用户名，则是当前用户的家目录：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo ~/home/me</code></pre><p>如果有用户”foo”这个帐号，然后：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo ~foo/home/foo</code></pre><h3 id="算数表达式展开"><a class="markdownIt-Anchor" href="#算数表达式展开"></a> 算数表达式展开</h3><p>shell 允许算术表达式通过展开来执行。这允许我们把 shell 提示当作计算器来使用：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo $((2 + 2))4</code></pre><p>算术表达式展开使用这种格式：</p><pre><code class="highlight plaintext">$((expression))</code></pre><p>（以上括号中的）表达式是指算术表达式，它由数值和算术操作符组成。算术表达式只支持整数（全部是数字，不带小数点），但是能执行很多不同的操作。这里是 一些它支持的操作符：</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>/</td><td>除（但是记住，因为展开只是支持整数除法，所以结果是整数。）</td></tr><tr><td>%</td><td>取余，只是简单的意味着，“余数”</td></tr><tr><td>**</td><td>取幂</td></tr></tbody></table><p>在算术表达式中空格并不重要，并且表达式可以嵌套。例如，5的平方乘以3：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo $(($((5**2)) * 3))75</code></pre><p>一对括号可以用来把多个子表达式括起来。通过这个技术，我们可以重写上面的例子， 同时用一个展开代替两个，来得到一样的结果：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo $(((5**2) * 3))75</code></pre><p>这是一个使用除法和取余操作符的例子。注意整数除法的结果：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo Five divided by two equals $((5/2))Five divided by two equals 2[me@linuxbox ~]$ echo with $((5%2)) left over.with 1 left over.</code></pre><h3 id="花括号展开"><a class="markdownIt-Anchor" href="#花括号展开"></a> 花括号展开</h3><p>可能最奇怪的展开是花括号展开。通过它，你可以从一个包含花括号的模式中 创建多个文本字符串。这是一个例子：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo Front-&#123;A,B,C&#125;-BackFront-A-Back Front-B-Back Front-C-Back</code></pre><p>花括号展开模式可能包含一个开头部分叫做报头，一个结尾部分叫做附言。花括号表达式本身可 能包含一个由逗号分开的字符串列表，或者一系列整数，或者单个的字符串。这种模式不能 嵌入空白字符。这个例题使用了一系列整数：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo Number_&#123;1..5&#125;Number_1  Number_2  Number_3  Number_4  Number_5</code></pre><p>例如， 如果我们是摄影师，有大量的相片。我们想把这些相片按年月先后组织起来。首先， 我们要创建一系列以数值”年－月”形式命名的目录。通过这种方式，目录名按照 年代顺序排列。我们可以键入整个目录列表，但是工作量太大了，并且易于出错。 反而，我们可以这样做：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ mkdir Pics[me@linuxbox ~]$ cd Pics[me@linuxbox Pics]$ mkdir &#123;2007..2009&#125;-0&#123;1..9&#125; &#123;2007..2009&#125;-&#123;10..12&#125;[me@linuxbox Pics]$ ls2007-01 2007-07 2008-01 2008-07 2009-01 2009-072007-02 2007-08 2008-02 2008-08 2009-02 2009-082007-03 2007-09 2008-03 2008-09 2009-03 2009-092007-04 2007-10 2008-04 2008-10 2009-04 2009-102007-05 2007-11 2008-05 2008-11 2009-05 2009-112007-06 2007-12 2008-06 2008-12 2009-06 2009-12</code></pre><h3 id="双引号"><a class="markdownIt-Anchor" href="#双引号"></a> 双引号</h3><p>我们将要看一下引用的第一种类型，双引号。如果你把文本放在双引号中， shell 使用的特殊字符，除了 <code>$，\ (反斜杠），和 </code>（倒引号）之外`， 则失去它们的特殊含义，被当作普通字符来看待。这意味着单词分割，路径名展开， 波浪线展开，和花括号展开都被禁止，然而参数展开，算术展开，和命令替换 仍然执行。使用双引号，我们可以处理包含空格的文件名。比方说我们是不幸的 名为 two words.txt 文件的受害者。如果我们试图在命令行中使用这个 文件，单词分割机制会导致这个文件名被看作两个独自的参数，而不是所期望 的单个参数：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ ls -l two words.txtls: cannot access two: No such file or directoryls: cannot access words.txt: No such file or directory</code></pre><p>使用双引号，我们可以阻止单词分割，得到期望的结果；进一步，我们甚至可以修复 破损的文件名。</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ ls -l &quot;two words.txt&quot;-rw-rw-r-- 1 me   me   18 2008-02-20 13:03 two words.txt[me@linuxbox ~]$ mv &quot;two words.txt&quot; two_words.txt</code></pre><p>你瞧！现在我们不必一直输入那些讨厌的双引号了。记住，在双引号中，参数展开，算术表达式展开，和命令替换仍然有效：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo &quot;$USER $((2+2)) $(cal)&quot;me 4    February 2008Su Mo Tu We Th Fr Sa</code></pre><p>在默认情况下，单词分割机制会在单词中寻找空格，制表符，和换行符，并把它们看作 单词之间的界定符。它们只作为分隔符使用。因为它们把单词分为不同的参数，在范例中， 命令行包含一个带有四个不同参数的命令。如果我们加上双引号：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo this is a   testthis is a test[me@linuxbox ~]$ echo &quot;this is a    test&quot;this is a    test</code></pre><p>单词分割被禁止，内嵌的空格也不会被当作界定符，它们成为参数的一部分。 一旦加上双引号，我们的命令行就包含一个带有一个参数的命令。</p><h3 id="单引号"><a class="markdownIt-Anchor" href="#单引号"></a> 单引号</h3><p>如果需要禁止所有的展开，我们使用单引号。以下例子是无引用，双引号，和单引号的比较结果：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USERtext /home/me/ls-output.txt a b foo 4 me[me@linuxbox ~]$ echo &quot;text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER&quot;text ~/*.txt   &#123;a,b&#125; foo 4 me[me@linuxbox ~]$ echo &#x27;text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER&#x27;text ~/*.txt  &#123;a,b&#125; $(echo foo) $((2+2)) $USER</code></pre><blockquote><p>正如我们所看到的，随着引用程度加强，越来越多的展开被禁止。</p></blockquote><h3 id="转义字符"><a class="markdownIt-Anchor" href="#转义字符"></a> 转义字符</h3><p>有时候我们只想引用单个字符。我们可以在字符之前加上一个反斜杠，在这个上下文中叫做转义字符。 经常在双引号中使用转义字符，来有选择地阻止展开。</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo &quot;The balance for user $USER is: \$5.00&quot;The balance for user me is: $5.00</code></pre><p>使用转义字符来消除文件名中一个字符的特殊含义，是很普遍的。例如，在文件名中可能使用 一些对于 shell 来说，有特殊含义的字符。这些字符包括”$”, “!”, “ “等字符。在文件名 中包含特殊字符，你可以这样做：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ mv bad\&amp;filename good_filename</code></pre><blockquote><p>为了允许反斜杠字符出现，输入”\“来转义。注意在单引号中，反斜杠失去它的特殊含义，它 被看作普通字符。</p></blockquote><h2 id="系统命令"><a class="markdownIt-Anchor" href="#系统命令"></a> 系统命令</h2><h3 id="常用系统工作命令"><a class="markdownIt-Anchor" href="#常用系统工作命令"></a> 常用系统工作命令</h3><h4 id="echo"><a class="markdownIt-Anchor" href="#echo"></a> echo</h4><p>echo命令用于<strong>在终端输出字符串或变量提取后的值</strong>，格式为</p><pre><code class="highlight plaintext">echo [字符串 | $变量]</code></pre><p>例如，把指定字符串“<a href="http://Linuxprobe.com">Linuxprobe.com</a>”输出到终端屏幕的命令为：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# echo Linuxprobe.Com</code></pre><p>该命令会在终端屏幕上显示如下信息：</p><pre><code class="highlight plaintext">Linuxprobe.Com</code></pre><p>下面，我们使用$变量的方式提取变量SHELL的值，并将其输出到屏幕上：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# echo $SHELL/bin/bash</code></pre><h4 id="date"><a class="markdownIt-Anchor" href="#date"></a> date</h4><p>date命令用于<strong>显示及设置系统的时间或日期</strong>，格式为</p><pre><code class="highlight plaintext">date [选项] [+指定的格式]</code></pre><p>只需在强大的<strong>date命令中输入以“+”号开头的参数，即可按照指定格式来输出系统的时间或日期</strong>，这样在日常工作时便可以把备份数据的命令与指定格式输出的时间信息结合到一起。例如，把打包后的文件自动按照“年-月-日”的格式打包成“backup-2017-9-1.tar.gz”，用户只需要看一眼文件名称就能大概了解到每个文件的备份时间了。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>%t</td><td>跳格[Tab键]</td></tr><tr><td>%Y</td><td>年</td></tr><tr><td>%m</td><td>月</td></tr><tr><td>%d</td><td>日</td></tr><tr><td>%H</td><td>小时（00～23）</td></tr><tr><td>%I</td><td>小时（00～12）</td></tr><tr><td>%M</td><td>分钟（00～59）</td></tr><tr><td>%S</td><td>秒（00～59）</td></tr><tr><td>%j</td><td>今年中的第几天</td></tr></tbody></table><p>按照默认格式查看当前系统时间的date命令如下所示：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# dateMon Aug 24 16:11:23 CST 2017</code></pre><p>按照“年-月-日 小时:分钟:秒”的格式查看当前系统时间的date命令如下所示：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# date &quot;+%Y-%m-%d %H:%M:%S&quot;2017-08-24 16:29:12</code></pre><p>将<strong>系统的当前时间设置</strong>为2017年9月1日8点30分的date命令如下所示：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# date -s &quot;20170901 8:30:00&quot;Fri Sep 1 08:30:00 CST 2017</code></pre><p>date命令中的参数%j可用来查看今天是当年中的第几天。这个参数能够很好地区分备份时间的新旧，即数字越大，越靠近当前时间。该参数的使用方式以及显示结果如下所示。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# date &quot;+%j&quot;244</code></pre><p>设置系统时间命令：</p><pre><code class="highlight plaintext">#date –set（月/日/年 时：分：秒）例：#date –set “10/11/10 10:15”</code></pre><p>查看硬件时间的命令：</p><pre><code class="highlight plaintext"># hwclock</code></pre><p>设置硬件时间的命令：</p><pre><code class="highlight plaintext"># hwclock –set –date = （月/日/年 时：分：秒）</code></pre><blockquote><p>上述提到的是手动设置时间到一个时间点，可能与当前网络的时间有误差。下面介绍一下与时间服务器上的时间同步的方法</p></blockquote><p><strong>设置系统时间与网络时间同步</strong></p><ol><li>安装ntpdate工具</li></ol><pre><code class="highlight plaintext">yum -y install ntp ntpdate</code></pre><ol><li>设置系统时间与网络时间同步</li></ol><pre><code class="highlight plaintext">ntpdate cn.pool.ntp.orgor =&gt;   ntpdate -u ntp.api.bz</code></pre><ol><li>将系统时间写入硬件时间</li></ol><pre><code class="highlight plaintext">hwclock –w</code></pre><ol><li>查看硬件时</li></ol><pre><code class="highlight plaintext">hwclock -show</code></pre><h4 id="reboot重启poweroff关机"><a class="markdownIt-Anchor" href="#reboot重启poweroff关机"></a> reboot重启/poweroff关机</h4><p><strong>reboot命令</strong>用于<strong>重启系统</strong></p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此默认只能使用root管理员来重启，其命令如下：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# reboot</code></pre><hr /><p><strong>poweroff命令</strong>用于<strong>关闭系统</strong></p><p>该命令与reboot命令相同，都会涉及硬件资源的管理权限，因此默认只有root管理员才可以关闭电脑，其命令如下：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# poweroff</code></pre><h4 id="susudo"><a class="markdownIt-Anchor" href="#susudo"></a> su/sudo</h4><p><strong>su命令可以解决切换用户身份的需求</strong>，使得当前用户在不退出登录的情况下，顺畅地切换到其他用户，比如从root管理员切换至普通用户：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# id uid=0(root) gid=0(root) groups=0(root)[root@linuxprobe ~]# su - linuxprobeLast login: Wed Jan 4 01:17:25 EST 2017 on pts/0[linuxprobe@linuxprobe ~]$ id uid=1000(linuxprobe) gid=1000(linuxprobe) groups=1000(linuxprobe) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</code></pre><blockquote><p>su命令与用户名之间有一个<strong>减号</strong>（-），这意味着完全切换到新的用户，即<strong>把环境变量信息也变更为新用户的相应信息</strong>，而不是保留原始的信息。强烈建议在切换用户身份时添加这个减号（-）</p></blockquote><blockquote><p>当从root管理员切换到普通用户时是不需要密码验证的，而从普通用户切换成root管理员就需要进行密码验证了</p></blockquote><hr /><p><strong>使用sudo命令把特定命令的执行权限赋予给指定用户</strong>，这样既可保证普通用户能够完成特定的工作，也可以避免泄露root管理员密码。我们要做的就是合理配置sudo服务，以便兼顾系统的安全性和用户的便捷性。sudo服务的配置原则也很简单—在保证普通用户完成相应工作的前提下，尽可能少地赋予额外的权限。</p><p>sudo命令用于给普通用户提供额外的权限来完成原本root管理员才能完成的任务，格式为</p><pre><code class="highlight plaintext">sudo [参数] 命令名称</code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-h</td><td>列出帮助信息</td></tr><tr><td>-l</td><td>列出当前用户可执行的命令</td></tr><tr><td>-u</td><td>用户名或UID值 以指定的用户身份执行命令</td></tr><tr><td>-k</td><td>清空密码的有效时间，下次执行sudo时需要再次进行密码验证</td></tr><tr><td>-b</td><td>在后台执行指定的命令</td></tr><tr><td>-p</td><td>更改询问密码的提示语</td></tr></tbody></table><h4 id="systemctl"><a class="markdownIt-Anchor" href="#systemctl"></a> systemctl</h4><p>在RHEL 7系统中是使用systemctl命令来管理服务的。</p><p>管理服务RHEL6与RHEL7管理服务的差别：</p><table><thead><tr><th>System V init命令（RHEL 6系统）</th><th>systemctl命令（RHEL 7系统） 作用</th></tr></thead><tbody><tr><td>service foo start</td><td>systemctl startfoo.service 启动服务</td></tr><tr><td>service foo restart</td><td>systemctl restartfoo.service 重启服务</td></tr><tr><td>service foo stop</td><td>systemctl stop foo.service 停止服务</td></tr><tr><td>service foo reload</td><td>systemctl reload foo.service 重新加载配置文件（不终止服务）</td></tr><tr><td>service foo status</td><td>systemctl status foo.service 查看服务状态表</td></tr><tr><td>chkconfig foo on</td><td>systemctl enable foo.service 开机自动启动</td></tr><tr><td>chkconfig foo off</td><td>systemctl disable foo.service 开机不自动启动</td></tr><tr><td>chkconfig foo</td><td>systemctl is-enabled foo.service 查看特定服务是否为开机自启动</td></tr><tr><td>chkconfig —list</td><td>systemctl list-unit-files — type=service查看各个级别下服务的启动与禁用情况</td></tr></tbody></table><p><strong>自定义systemctl命令启动服务</strong></p><p>在/usr/lib/systemd/system路径中自定义一个以.service结尾的脚本。</p><ul><li>定义完成后即可使用systemctl start sdmclient/systemctl stop sdmclient等命令</li></ul><p>如 sdmclient.service：</p><pre><code class="highlight plaintext">[Unit]Description=sdmclientAfter=network.target[Service]Type=forkingExecStart=/bin/bash /opt/SDM/client/client-cmds/Common/Linux/sdmclient7 startExecReload=/bin/bash /opt/SDM/client/client-cmds/Common/Linux/sdmclient7 restartExecStop=/bin/bash /opt/SDM/client/client-cmds/Common/Linux/sdmclient7 stopUser=root[Install]WantedBy=multi-user.target</code></pre><h3 id="系统状态检测命令"><a class="markdownIt-Anchor" href="#系统状态检测命令"></a> 系统状态检测命令</h3><p>作为一名合格的运维人员，想要更快、更好地了解Linux服务器，必须具备快速查看Linux系统运行状态的能力，因此接下来会逐个讲解与网卡网络、系统内核、系统负载、内存使用情况、当前启用终端数量、历史登录记录、命令执行记录以及救援诊断等相关命令的使用方法。这些命令都超级实用，还请读者用心学习，加以掌握</p><h4 id="ifconfig命令"><a class="markdownIt-Anchor" href="#ifconfig命令"></a> ifconfig命令</h4><p>ifconfig命令用于<strong>获取网卡配置与网络状态等信息</strong>，格式为</p><pre><code class="highlight plaintext">ifconfig [网络设备] [参数]</code></pre><p>使用ifconfig命令来查看本机当前的网卡配置与网络状态等信息时，其实主要查看的就是网卡名称、inet参数后面的IP地址、ether参数后面的网卡物理地址（又称为MAC地址），以及RX、TX的接收数据包与发送数据包的个数及累计流量（即下面加粗的信息内容）：</p><p><img src="image/-10.png" alt="-10.png" /></p><h4 id="uname命令"><a class="markdownIt-Anchor" href="#uname命令"></a> uname命令</h4><p>uname命令用于<strong>查看系统内核与系统版本等信息</strong>，格式</p><pre><code class="highlight plaintext">uname [-a]</code></pre><p>在使用uname命令时，一般会固定搭配上-a参数来完整地查看当前系统的内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# uname -aLinux linuxprobe.com 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2017 x86_64 x86_64 x86_64 GNU/Linux</code></pre><p>顺带一提，如果要查看当前系统版本的详细信息，则需要查看redhat-release文件，其命令以及相应的结果如下：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# cat /etc/redhat-releaseRed Hat Enterprise Linux Server release 7.0 (Maipo)</code></pre><h4 id="uptime命令"><a class="markdownIt-Anchor" href="#uptime命令"></a> uptime命令</h4><p>uptime用于<strong>查看系统的负载信息</strong>，格式为</p><pre><code class="highlight plaintext">uptime</code></pre><p>uptime命令真的很棒，它可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息。平均负载值指的是系统在最近1分钟、5分钟、15分钟内的压力情况（下面加粗的信息部分）；负载值越低越好，尽量不要长期超过1，在生产环境中不要超过5。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# uptime22:49:55 up 10 min, 2 users, load average: 0.01, 0.19, 0.18</code></pre><h4 id="free命令"><a class="markdownIt-Anchor" href="#free命令"></a> free命令</h4><p>free用于<strong>显示当前系统中内存的使用量信息</strong>，格式为</p><pre><code class="highlight plaintext">free [-h]</code></pre><p>为了保证Linux系统不会因资源耗尽而突然宕机，运维人员需要时刻关注内存的使用量。在使用free命令时，可以结合使用-h参数以更人性化的方式输出当前内存的实时使用量信息。</p><p>执行free -h命令后的输出信息</p><table><thead><tr><th></th><th>内存总量</th><th>已用量</th><th>可用量</th><th>进程共享的内存量</th><th>磁盘缓存的内存量</th><th>缓存的内存量</th></tr></thead><tbody><tr><td></td><td>total</td><td>used</td><td>free</td><td>shared</td><td>buffers</td><td>cached</td></tr><tr><td>Mem:</td><td>1.8G</td><td>1.3G</td><td>542M</td><td>9.8M</td><td>1.6M</td><td>413M</td></tr><tr><td>Swap:</td><td>2.0G</td><td>0B</td><td>2.0G</td><td></td><td></td><td></td></tr></tbody></table><h4 id="who"><a class="markdownIt-Anchor" href="#who"></a> who</h4><p>who用于<strong>查看当前登入主机的用户终端信息</strong></p><pre><code class="highlight plaintext">who [参数]</code></pre><p>这三个简单的字母可以快速显示出所有正在登录本机的用户的名称以及他们正在开启的终端信息。</p><p>执行who命令的结果：</p><table><thead><tr><th>登陆的用户名</th><th>终端设备</th><th>登陆到系统的时间</th></tr></thead><tbody><tr><td>root</td><td>pts/0</td><td>2020-06-04 09:16 (192.168.212.156)</td></tr><tr><td>root</td><td>pts/1</td><td>2020-06-10 09:35 (192.168.212.165)</td></tr><tr><td>root</td><td>pts/2</td><td>2020-06-04 09:06 (192.168.212.156)</td></tr><tr><td>root</td><td>pts/4</td><td>2020-06-09 15:20 (192.168.212.156)</td></tr><tr><td>root</td><td>pts/8</td><td>2020-06-08 09:55 (192.168.212.189)</td></tr><tr><td>root</td><td>pts/9</td><td>2020-06-08 10:17 (192.168.212.189)</td></tr><tr><td>root</td><td>pts/10</td><td>2020-06-08 10:18 (192.168.212.189)</td></tr></tbody></table><h4 id="last"><a class="markdownIt-Anchor" href="#last"></a> last</h4><p>last命令用于<strong>查看所有系统的登录记录</strong>，格式为</p><pre><code class="highlight plaintext">last [参数]</code></pre><p>使用last命令可以查看本机的登录记录。但是，由于这些信息都是以日志文件的形式保存在系统中，因此黑客可以很容易地对内容进行篡改。千万不要单纯以该命令的输出信息而判断系统有无被恶意入侵！</p><p><img src="image/-11.png" alt="-11.png" /></p><h4 id="history"><a class="markdownIt-Anchor" href="#history"></a> history</h4><p>history命令用于<strong>显示历史执行过的命令</strong>，格式为</p><pre><code class="highlight plaintext">history [-c]</code></pre><p>history命令应该是作者最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，还可以自定义/etc/profile文件中的HISTSIZE变量值。在使用history命令时，如果使用-c参数则会清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><p><img src="image/-12.png" alt="-12.png" /></p><p>要<strong>清空当前用户在本机上执行的Linux命令历史记录信息</strong>，可执行如下命令：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# history -c</code></pre><h3 id="配置主机名称"><a class="markdownIt-Anchor" href="#配置主机名称"></a> 配置主机名称</h3><p>为了便于在局域网中查找某台特定的主机，或者对主机进行区分，除了要有IP地址外，还要为主机配置一个主机名，主机之间可以通过这个类似于域名的名称来相互访问。在Linux系统中，主机名大多保存在/etc/hostname文件中，接下来将/etc/hostname文件的内容修改为“<a href="http://linuxprobe.com">linuxprobe.com</a>”，步骤如下。</p><ul><li>第1步：使用Vim编辑器修改“/etc/hostname”主机名称文件。</li><li>第2步：把原始主机名称删除后追加“<a href="http://linuxprobe.com">linuxprobe.com</a>”。注意，使用Vim编辑器修改主机名称文件后，要在末行模式下执行:wq!命令才能保存并退出文档。</li><li>第3步：保存并退出文档，然后使用hostname命令检查是否修改成功。</li></ul><pre><code class="highlight plaintext">$ vim /etc/hostnamelinuxprobe.com</code></pre><p>hostname命令用于查看当前的主机名称，但有时主机名称的改变不会立即同步到系统中，所以如果发现修改完成后还显示原来的主机名称，可重启虚拟机后再行查看：</p><pre><code class="highlight plaintext">$ hostnamelinuxprobe.com</code></pre><h3 id="配置网卡信息"><a class="markdownIt-Anchor" href="#配置网卡信息"></a> 配置网卡信息</h3><p>网卡IP地址配置的是否正确是两台服务器是否可以相互通信的前提。在Linux系统中，一切都是文件，因此配置网络服务的工作其实就是在编辑网卡配置文件.</p><p>如果您具备一定的运维经验或者熟悉早期的Linux系统，则在学习本书时会遇到一些不容易接受的差异变化。在RHEL 5、RHEL 6中，网卡配置文件的前缀为eth，第1块网卡为eth0，第2块网卡为eth1；以此类推。而在RHEL 7中，网卡配置文件的前缀则以ifcfg开始，加上网卡名称共同组成了网卡配置文件的名字，例如ifcfg-eno16777736；好在除了文件名变化外也没有其他大的区别。</p><p>现在有一个名称为ifcfg-eno16777736的网卡设备，我们将其配置为开机自启动，并且IP地址、子网、网关等信息由人工指定，其步骤应该如下所示。</p><ul><li>第1步：首先<strong>切换到/etc/sysconfig/network-scripts目录</strong>中（存放着网卡的配置文件）。</li><li>第2步：使用Vim编辑器修改网卡文件ifcfg-eno16777736，逐项写入下面的配置参数并保存退出。由于每台设备的硬件及架构是不一样的，因此请读者使用ifconfig命令自行确认各自网卡的默认名称。</li></ul><pre><code class="highlight plaintext">设备类型：TYPE=Ethernet地址分配模式：BOOTPROTO=static网卡名称：NAME=eno16777736是否启动：ONBOOT=yesIP地址：IPADDR=192.168.10.10子网掩码：NETMASK=255.255.255.0网关地址：GATEWAY=192.168.10.1DNS地址：DNS1=192.168.10.1</code></pre><ul><li>第3步：重启网络服务并测试网络是否联通。</li></ul><p>进入到网卡配置文件所在的目录，然后编辑网卡配置文件，在其中填入下面的信息：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# cd /etc/sysconfig/network-scripts/[root@linuxprobe network-scripts]# vim ifcfg-eno16777736TYPE=EthernetBOOTPROTO=staticNAME=eno16777736ONBOOT=yesIPADDR=192.168.10.10NETMASK=255.255.255.0GATEWAY=192.168.10.1DNS1=192.168.10.1</code></pre><p>执行<strong>重启网卡设备的命令</strong>（在正常情况下不会有提示信息），然后通过ping命令测试网络能否联通。由于在Linux系统中ping命令不会自动终止，因此需要手动按下Ctrl-c键来强行结束进程。</p><pre><code class="highlight plaintext">[root@linuxprobe network-scripts]# systemctl restart network[root@linuxprobe network-scripts]# ping 192.168.10.10PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.64 bytes from 192.168.10.10: icmp_seq=1 ttl=64 time=0.081 ms64 bytes from 192.168.10.10: icmp_seq=2 ttl=64 time=0.083 ms64 bytes from 192.168.10.10: icmp_seq=3 ttl=64 time=0.059 ms64 bytes from 192.168.10.10: icmp_seq=4 ttl=64 time=0.097 ms^C--- 192.168.10.10 ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 2999msrtt min/avg/max/mdev = 0.059/0.080/0.097/0.013 ms</code></pre><h3 id="yum"><a class="markdownIt-Anchor" href="#yum"></a> Yum</h3><p>yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。</p><p>基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p><p>yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p><p>语法:</p><pre><code class="highlight plaintext">yum [options] [command] [package ...]</code></pre><ul><li>options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为&quot;yes&quot;），-q（不显示安装的过程）等等。</li><li>command：要进行的操作。</li><li>package操作的对象。</li></ul><hr /><ul><li>1.列出所有可更新的软件清单命令：yum check-update</li><li>2.更新所有软件命令：yum update</li><li>3.仅安装指定的软件命令：yum install &lt;package_name&gt;</li><li>4.仅更新指定的软件命令：yum update &lt;package_name&gt;</li><li>5.列出所有可安裝的软件清单命令：yum list</li><li>6.删除软件包命令：yum remove &lt;package_name&gt;</li><li>7.查找软件包 命令：yum search <keyword></li><li>8.清除缓存命令:<ul><li>yum clean packages: 清除缓存目录下的软件包</li><li>yum clean headers: 清除缓存目录下的 headers</li><li>yum clean oldheaders: 清除缓存目录下旧的 headers</li><li>yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers</li></ul></li></ul><h3 id="计划任务服务程序"><a class="markdownIt-Anchor" href="#计划任务服务程序"></a> 计划任务服务程序</h3><p>经验丰富的系统运维工程师可以使得Linux在无需人为介入的情况下，在指定的时间段自动启用或停止某些服务或命令，从而实现运维的自动化。尽管我们现在已经有了功能彪悍的脚本程序来执行一些批处理工作，但是，如果仍然需要在每天凌晨两点敲击键盘回车键来执行这个脚本程序，这简直太痛苦了（当然，也可以训练您的小猫在半夜按下回车键）。接下来，刘遄老师将向大家讲解如何设置服务器的计划任务服务，把周期性、规律性的工作交给系统自动完成</p><p>计划任务分为一次性计划任务与长期性计划任务，大家可以按照如下方式理解</p><ul><li><strong>一次性计划任务</strong>：今晚11点30分开启网站服务。</li><li><strong>长期性计划任务</strong>：每周一的凌晨3点25分把/home/wwwroot目录打包备份为backup.tar.gz。</li></ul><h4 id="一次性计划任务"><a class="markdownIt-Anchor" href="#一次性计划任务"></a> 一次性计划任务</h4><p>一次性计划任务只执行一次，一般用于满足临时的工作需求。我们可以用at命令实现这种功能，只需要写成“<strong>at 时间</strong>”的形式就可以。</p><p>如果想要<strong>查看</strong>已设置好但还未执行的一次性计划任务，可以使用“<strong>at -l</strong>”命令；要想将其<strong>删除</strong>，可以用“<strong>atrm</strong> 任务序号”</p><p>在使用at命令来设置一次性计划任务时，默认采用的是交互式方法。例如，使用下述命令将系统设置为在今晚23:30分自动重启网站服务。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# at 23:30at &gt; systemctl restart httpdat &gt; 此处请同时按下Ctrl+d来结束编写计划任务job 3 at Mon Apr 27 23:30:00 2015[root@linuxprobe ~]# at -l3 Mon Apr 27 23:30:00 2016 a root</code></pre><p>想挑战一下难度更大但简捷性更高的方式，可以把前面学习的管道符（任意门）放到两条命令之间，让at命令接收前面echo命令的输出信息，以达到通过非交互式的方式创建计划一次性任务的目的。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# echo &quot;systemctl restart httpd&quot; | at 23:30job 4 at Mon Apr 27 23:30:00 2015[root@linuxprobe ~]# at -l3 Mon Apr 27 23:30:00 2016 a root4 Mon Apr 27 23:30:00 2016 a root</code></pre><p>如果我们不小心设置了两个一次性计划任务，可以使用下面的命令轻松<strong>删除其中一个</strong>：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# atrm 3[root@linuxprobe ~]# at -l4 Mon Apr 27 23:30:00 2016 a root</code></pre><h4 id="长期性计划任务"><a class="markdownIt-Anchor" href="#长期性计划任务"></a> 长期性计划任务</h4><p>如果我们希望Linux系统能够周期性地、有规律地执行某些具体的任务，那么Linux系统中默认启用的crond服务简直再适合不过了。</p><ul><li>创建、编辑计划任务的命令为“<strong>crontab -e</strong>”</li><li>查看当前计划任务的命令为“<strong>crontab -l</strong>”</li><li>删除某条计划任务的命令为“<strong>crontab -r</strong>”</li></ul><p>另外，如果您是以管理员的身份登录的系统，还可以在crontab命令中加上-u参数来编辑他人的计划任务</p><p>在正式部署计划任务前，请先跟刘遄老师念一下口诀“分、时、日、月、星期 命令”。这是使用crond服务设置任务的参数格式（其格式见表4-6）。<strong>需要注意的是，如果有些字段没有设置，则需要使用星号<code>（*）</code>占位</strong>，如图所示。</p><p><img src="image/-13.png" alt="-13.png" /></p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>分钟</td><td>取值为0～59的整数</td></tr><tr><td>小时</td><td>取值为0～23的任意整数</td></tr><tr><td>日期</td><td>取值为1～31的任意整数</td></tr><tr><td>月份</td><td>取值为1～12的任意整数</td></tr><tr><td>星期</td><td>取值为0～7的任意整数，其中0与7均为星期日</td></tr><tr><td>命令</td><td>要执行的命令或程序脚本</td></tr></tbody></table><p>假设在每周一、三、五的凌晨3点25分，都需要使用tar命令把某个网站的数据目录进行打包处理，使其作为一个备份文件。我们可以使用crontab -e命令来创建计划任务。为自己创建计划任务无需使用-u参数，具体的实现效果的参数如crontab -l命令结果所示：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# crontab -eno crontab for root - using an empty onecrontab: installing new crontab</code></pre><blockquote><p>输入上述命令进入编辑器，键入下列语句即可</p></blockquote><pre><code class="highlight plaintext">[root@linuxprobe ~]# crontab -l25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar.gz /home/wwwroot</code></pre><p>需要说明的是，<strong>除了用逗号（,）来分别表示多个时间段</strong>，例如“8,9,12”表示8月、9月和12月。</p><p><strong>还可以用减号（-）来表示一段连续的时间周期</strong>（例如字段“日”的取值为“12-15”，则表示每月的12～15日）。</p><p><strong>以及用除号（/）表示执行任务的间隔时间</strong>（例如“*/2”表示每隔2分钟执行一次任务）。</p><p>如果在crond服务中需要同时包含多条计划任务的命令语句，应每行仅写一条。例如我们再添加一条计划任务，它的功能是每周一至周五的凌晨1点钟自动清空/tmp目录内的所有文件。尤其需要注意的是，在crond服务的计划任务参数中，所有命令一定要用绝对路径的方式来写，如果不知道绝对路径，请用whereis命令进行查询，rm命令路径为下面输出信息中加粗部分。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# whereis rmrm: /usr/bin/rm /usr/share/man/man1/rm.1.gz /usr/share/man/man1p/rm.1p.gz[root@linuxprobe ~]# crontab -ecrontab: installing new crontab[root@linuxprobe ~]# crontab -l25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar.gz /home/wwwroot0 1 * * 1-5 /usr/bin/rm -rf /tmp/*</code></pre><blockquote><p>在crond服务的配置参数中，可以像Shell脚本那样以#号开头写上注释信息，这样在日后回顾这段命令代码时可以快速了解其功能、需求以及编写人员等重要信息。</p></blockquote><blockquote><p><strong>计划任务中的“分”字段必须有数值</strong>，绝对不能为空或是<code>*</code>号，<strong>而“日”和“星期”字段不能同时使用</strong>，否则就会发生冲突</p></blockquote><h2 id="文件权限"><a class="markdownIt-Anchor" href="#文件权限"></a> 文件权限</h2><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><p>在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如：</p><pre><code class="highlight plaintext">[root@www /]# ls -ltotal 64dr-xr-xr-x   2 root root 4096 Dec 14  2012 bindr-xr-xr-x   4 root root 4096 Apr 19  2012 boot……</code></pre><p>实例中，bin文件的第一个属性用&quot;d&quot;表示。&quot;d&quot;在Linux中代表该文件是一个目录文件。</p><p>在Linux中<strong>第一个字符</strong>代表：</p><ul><li>当为[ d ]则是目录</li><li>当为[ - ]则是文件；</li><li>若是[ l ]则表示为链接文档(link file)；</li><li>若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li><li>若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li></ul><p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表<strong>可读</strong>(read)、[ w ]代表<strong>可写</strong>(write)、[ x ]代表<strong>可执行</strong>(execute)。</p><p>要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。每个文件的属性由左边第一部分的10个字符来确定（如下图）</p><p><img src="image/-14.png" alt="-14.png" /></p><p>从左至右用0-9这些数字来表示。</p><ul><li>第0位确定文件类型</li><li>第1-3位确定属主（该文件的所有者）拥有该文件的权限。</li><li>第4-6位确定属组（所有者的同组用户）拥有该文件的权限</li><li>第7-9位确定其他用户拥有该文件的权限。</li></ul><hr /><ul><li>第1、4、7位表示读权限，如果用&quot;r&quot;字符表示，则有读权限，如果用&quot;-&quot;字符表示，则没有读权限；</li><li>第2、5、8位表示写权限，如果用&quot;w&quot;字符表示，则有写权限，如果用&quot;-&quot;字符表示没有写权限；</li><li>第3、6、9位表示可执行权限，如果用&quot;x&quot;字符表示，则有执行权限，如果用&quot;-&quot;字符表示，则没有执行权限。</li></ul><h3 id="文件属主和属组"><a class="markdownIt-Anchor" href="#文件属主和属组"></a> 文件属主和属组</h3><pre><code class="highlight plaintext">[root@www /]# ls -ltotal 64drwxr-xr-x 2 root  root  4096 Feb 15 14:46 crondrwxr-xr-x 3 mysql mysql 4096 Apr 21  2014 mysql……</code></pre><p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p><p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p><p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p><p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p><p>在以上实例中，mysql 文件是一个目录文件，属主和属组都为 mysql，属主有可读、可写、可执行的权限；与属主同组的其他用户有可读和可执行的权限；其他用户也有可读和可执行的权限。</p><blockquote><p>对于 root 用户来说，一般情况下，文件的权限对其不起作用。</p></blockquote><h4 id="更改文件属组-chgrp"><a class="markdownIt-Anchor" href="#更改文件属组-chgrp"></a> 更改文件属组 chgrp</h4><p>语法：</p><pre><code class="highlight plaintext">chgrp [-R] 属组名 文件名</code></pre><p>参数选项</p><ul><li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li></ul><h4 id="更改文件属主-chown"><a class="markdownIt-Anchor" href="#更改文件属主-chown"></a> 更改文件属主 chown</h4><p>语法：</p><pre><code class="highlight plaintext">chown [–R] 属主名 文件名chown [-R] 属主名:属组名 文件名</code></pre><p>案例：</p><ul><li>进入 /root 目录（~）将install.log的拥有者改为bin这个账号：</li></ul><pre><code class="highlight plaintext">[root@www ~] cd ~[root@www ~]# chown bin install.log[root@www ~]# ls -l-rw-r--r--  1 bin  users 68495 Jun 25 08:53 install.log</code></pre><ul><li>将install.log的拥有者与群组改回为root：</li></ul><pre><code class="highlight plaintext">[root@www ~]# chown root:root install.log[root@www ~]# ls -l-rw-r--r--  1 root root 68495 Jun 25 08:53 install.log</code></pre><h3 id="文件权限-chmod"><a class="markdownIt-Anchor" href="#文件权限-chmod"></a> 文件权限 chmod</h3><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p><p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p><hr /><p><strong>数字类型更改文件权限</strong></p><p>语法：</p><pre><code class="highlight plaintext">chmod [-R] xyz 文件名 // -R 代表递归，即目录下所有文件都会更改属性// x 代表属主权限// y 代表属组权限// z 代表其他权限</code></pre><p>文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><ul><li>r ：4</li><li>w：2</li><li>x ：1</li></ul><p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：</p><ul><li>owner = rwx = 4+2+1 = 7</li><li>group = rwx = 4+2+1 = 7</li><li>others= — = 0+0+0 = 0</li></ul><p>所以等一下我们设定权限的变更时，该文件的权限数字就是770啦！变更权限的指令chmod的语法是这样的：</p><pre><code class="highlight plaintext">chmod [-R] xyz 文件或目录</code></pre><p>选项与参数：</p><ul><li>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。</li><li>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</li></ul><p>案例：</p><ul><li>举例来说，如果要将.bashrc这个文件所有的权限都设定启用，那么命令如下：</li></ul><pre><code class="highlight plaintext">[root@www ~]# ls -al .bashrc-rw-r--r--  1 root root 395 Jul  4 11:45 .bashrc[root@www ~]# chmod 777 .bashrc[root@www ~]# ls -al .bashrc-rwxrwxrwx  1 root root 395 Jul  4 11:45 .bashrc</code></pre><blockquote><p>那如果要将权限变成 -rwxr-xr-- 呢？那么权限的分数就成为 <code>[4+2+1][4+0+1][4+0+0]=754</code>。</p></blockquote><hr /><p><strong>符号类型更改文件权限</strong></p><p>语法:</p><pre><code class="highlight plaintext">chmod [-R] u=rwx,g=rwx,o-rwx 文件名// -R 代表递归，即目录下所有文件都会更改属性// u 代表属主// g 代表属组// o 代表其他</code></pre><p>还有一个改变权限的方法，从之前的介绍中我们可以发现，基本上就九个权限分别是：</p><ul><li>(1)user</li><li>(2)group</li><li>(3)others</li></ul><p>那么我们就可以使用 u, g, o 来代表三种身份的权限！</p><p>此外， a 则代表 all，即全部的身份。读写的权限可以写成 r, w, x，也就是可以使用下表的方式来看：</p><p><img src="image/-15.png" alt="-15.png" /></p><p>案例：</p><ul><li>如果我们需要将文件权限设置为 -rwxr-xr-- ，可以使用 <code>chmod u=rwx,g=rx,o=r</code> 文件名 来设定:</li></ul><pre><code class="highlight plaintext">#  touch test1    // 创建 test1 文件# ls -al test1    // 查看 test1 默认权限-rw-r--r-- 1 root root 0 Nov 15 10:32 test1# chmod u=rwx,g=rx,o=r  test1    // 修改 test1 权限# ls -al test1-rwxr-xr-- 1 root root 0 Nov 15 10:32 test1</code></pre><ul><li>而如果是要将权限去掉而不改变其他已存在的权限呢？例如要拿掉全部人的可执行权限，则：</li></ul><pre><code class="highlight plaintext">#  chmod  a-x test1# ls -al test1-rw-r--r-- 1 root root 0 Nov 15 10:32 test1</code></pre><h3 id="文件的特殊权限"><a class="markdownIt-Anchor" href="#文件的特殊权限"></a> 文件的特殊权限</h3><p>在复杂多变的生产环境中，单纯设置文件的rwx权限无法满足我们对安全和灵活性的需求，因此便有了SUID、SGID与SBIT的特殊权限位。这是一种对文件权限进行设置的特殊功能，可以与一般权限同时使用，以弥补一般权限不能实现的功能。下面具体解释这3个特殊权限位的功能以及用法。</p><h4 id="suid"><a class="markdownIt-Anchor" href="#suid"></a> SUID</h4><p>SUID是一种对二进制程序进行设置的特殊权限，可以让二进制程序的执行者临时拥有属主的权限（仅对拥有执行权限的二进制程序有效）。</p><p>例如，所有用户都可以执行passwd命令来修改自己的用户密码，而用户密码保存在/etc/shadow文件中。仔细查看这个文件就会发现它的默认权限是000，也就是说除了root管理员以外，所有用户都没有查看或编辑该文件的权限。但是，在使用passwd命令时如果加上SUID特殊权限位，就可让普通用户临时获得程序所有者的身份，把变更的密码信息写入到shadow文件中。这很像我们在古装剧中见到的手持尚方宝剑的钦差大臣，他手持的尚方宝剑代表的是皇上的权威，因此可以惩戒贪官，但这并不意味着他永久成为了皇上。因此这只是一种有条件的、临时的特殊权限授权方法。</p><p>查看passwd命令属性时发现所有者的权限由rwx变成了rws，其中x改变成s就意味着该文件被赋予了SUID权限。另外有读者会好奇，那么如果原本的权限是rw-呢？如果原先权限位上没有x执行权限，那么被赋予特殊权限后将变成大写的S。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# ls -l /etc/shadow----------. 1 root root 1004 Jan 3 06:23 /etc/shadow[root@linuxprobe ~]# ls -l /bin/passwd-rwsr-xr-x. 1 root root 27832 Jan 29 2017 /bin/passwd</code></pre><h4 id="sgid"><a class="markdownIt-Anchor" href="#sgid"></a> SGID</h4><p>SGID的第一种功能是参考SUID而设计的，不同点在于执行程序的用户获取的不再是文件所有者的临时权限，而是获取到文件所属组的权限。举例来说，在早期的Linux系统中，/dev/kmem是一个字符设备文件，用于存储内核程序要访问的数据，权限为：</p><ul><li>cr—r——- 1 root system 2, 1 Feb 11 2017 kmem</li></ul><p>大家看出问题了吗？除了root管理员或属于system组成员外，所有用户都没有读取该文件的权限。由于在平时我们需要查看系统的进程状态，为了能够获取到进程的状态信息，可在用于查看系统进程状态的ps命令文件上增加SGID特殊权限位。查看ps命令文件的属性信息：</p><pre><code class="highlight plaintext">-r-xr-sr-x 1 bin system 59346 Feb 11 2017 ps</code></pre><p>这样一来，由于ps命令被增加了SGID特殊权限位，所以当用户执行该命令时，也就临时获取到了system用户组的权限，从而可以顺利地读取设备文件了</p><p>前文提到，每个文件都有其归属的所有者和所属组，当创建或传送一个文件后，这个文件就会自动归属于执行这个操作的用户（即该用户是文件的所有者）。如果现在需要在一个部门内设置共享目录，让部门内的所有人员都能够读取目录中的内容，那么就可以创建部门共享目录后，在该目录上设置SGID特殊权限位。这样，部门内的任何人员在里面创建的任何文件都会归属于该目录的所属组，而不再是自己的基本用户组。此时，我们用到的就是SGID的第二个功能，即在某个目录中创建的文件自动继承该目录的用户组（只可以对目录进行设置）。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# cd /tmp[root@linuxprobe tmp]# mkdir testdir[root@linuxprobe tmp]# ls -ald testdir/drwxr-xr-x. 2 root root 6 Feb 11 11:50 testdir/[root@linuxprobe tmp]# chmod -Rf 777 testdir/[root@linuxprobe tmp]# chmod -Rf g+s testdir/[root@linuxprobe tmp]# ls -ald testdir/drwxrwsrwx. 2 root root 6 Feb 11 11:50 testdir/</code></pre><p>在使用上述命令设置好目录的777权限（确保普通用户可以向其中写入文件），并为该目录设置了SGID特殊权限位后，就可以切换至一个普通用户，然后尝试在该目录中创建文件，并查看新创建的文件是否会继承新创建的文件所在的目录的所属组名称：</p><pre><code class="highlight plaintext">[root@linuxprobe tmp]# su - linuxprobeLast login: Wed Feb 11 11:49:16 CST 2017 on pts/0[linuxprobe@linuxprobe ~]$ cd /tmp/testdir/[linuxprobe@linuxprobe testdir]$ echo &quot;linuxprobe.com&quot; &gt; test[linuxprobe@linuxprobe testdir]$ ls -al test-rw-rw-r--. 1 linuxprobe root 15 Feb 11 11:50 test</code></pre><h4 id="sbit"><a class="markdownIt-Anchor" href="#sbit"></a> SBIT</h4><p>现在，大学里的很多老师都要求学生将作业上传到服务器的特定共享目录中，但总是有几个“破坏分子”喜欢删除其他同学的作业，这时就要设置SBIT（Sticky Bit）特殊权限位了（也可以称之为特殊权限位之粘滞位）。SBIT特殊权限位可确保用户只能删除自己的文件，而不能删除其他用户的文件。换句话说，当对某个目录设置了SBIT粘滞位权限后，那么该目录中的文件就只能被其所有者执行删除操作了。</p><p>最初不知道是哪位非资深技术人员将Sticky Bit直译成了“粘滞位”，刘遄老师建议将其称为“保护位”，这既好记，又能立刻让人了解它的作用。RHEL 7系统中的/tmp作为一个共享文件的目录，默认已经设置了SBIT特殊权限位，因此除非是该目录的所有者，否则无法删除这里面的文件。</p><p>与前面所讲的SUID和SGID权限显示方法不同，当目录被设置SBIT特殊权限位后，文件的其他人权限部分的x执行权限就会被替换成t或者T，原本有x执行权限则会写成t，原本没有x执行权限则会被写成T。</p><pre><code class="highlight plaintext">[root@linuxprobe tmp]# su - linuxprobeLast login: Wed Feb 11 12:41:20 CST 2017 on pts/0[linuxprobe@linuxprobe tmp]$ ls -ald /tmpdrwxrwxrwt. 17 root root 4096 Feb 11 13:03 /tmp[linuxprobe@linuxprobe ~]$ cd /tmp[linuxprobe@linuxprobe tmp]$ ls -alddrwxrwxrwt. 17 root root 4096 Feb 11 13:03 .[linuxprobe@linuxprobe tmp]$ echo &quot;Welcome to linuxprobe.com&quot; &gt; test[linuxprobe@linuxprobe tmp]$ chmod 777 test[linuxprobe@linuxprobe tmp]$ ls -al test -rwxrwxrwx. 1 linuxprobe linuxprobe 10 Feb 11 12:59 test</code></pre><p>其实，文件能否被删除并不取决于自身的权限，而是看其所在目录是否有写入权限（其原理会在下个章节讲到）。为了避免现在很多读者不放心，所以上面的命令还是赋予了这个test文件最大的777权限（rwxrwxrwx）。我们切换到另外一个普通用户，然后尝试删除这个其他人创建的文件就会发现，即便读、写、执行权限全开，但是由于SBIT特殊权限位的缘故，依然无法删除该文件：</p><pre><code class="highlight plaintext">[root@linuxprobe tmp]# su - blackshieldLast login: Wed Feb 11 12:41:29 CST 2017 on pts/1[blackshield@linuxprobe ~]$ cd /tmp[blackshield@linuxprobe tmp]$ rm -f testrm: cannot remove ‘test’: Operation not permitted</code></pre><p>当然，要是也想对其他目录来设置SBIT特殊权限位，用chmod命令就可以了。对应的参数o+t代表设置SBIT粘滞位权限：</p><pre><code class="highlight plaintext">[blackshield@linuxprobe tmp]$ exitLogout[root@linuxprobe tmp]# cd ~[root@linuxprobe ~]# mkdir linux[root@linuxprobe ~]# chmod -R o+t linux/[root@linuxprobe ~]# ls -ld linux/drwxr-xr-t. 2 root root 6 Feb 11 19:34 linux/</code></pre><h3 id="文件的隐藏属性"><a class="markdownIt-Anchor" href="#文件的隐藏属性"></a> 文件的隐藏属性</h3><p>Linux系统中的文件除了具备一般权限和特殊权限之外，还有一种隐藏权限，即被隐藏起来的权限，默认情况下不能直接被用户发觉。有用户曾经在生产环境和RHCE考试题目中碰到过明明权限充足但却无法删除某个文件的情况，或者仅能在日志文件中追加内容而不能修改或删除内容，这在一定程度上阻止了黑客篡改系统日志的图谋，因此这种“奇怪”的文件也保障了Linux系统的安全性。</p><h4 id="chattr"><a class="markdownIt-Anchor" href="#chattr"></a> chattr</h4><p>chattr命令用于设置文件的隐藏权限，格式为</p><pre><code class="highlight plaintext">chattr [参数] 文件</code></pre><p>如果想要把某个隐藏功能添加到文件上，则需要在命令后面追加“+参数”，如果想要把某个隐藏功能移出文件，则需要追加“-参数”</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>i</td><td>无法对文件进行修改；若对目录设置了该参数，则仅能修改其中的子文件内容而不能新建或删除文件</td></tr><tr><td>a</td><td>仅允许补充（追加）内容，无法覆盖/删除内容（Append Only）</td></tr><tr><td>S</td><td>文件内容在变更后立即同步到硬盘（sync）</td></tr><tr><td>s</td><td>彻底从硬盘中删除，不可恢复（用0填充原文件所在硬盘区域）</td></tr><tr><td>A</td><td>不再修改这个文件或目录的最后访问时间（atime）</td></tr><tr><td>b</td><td>不再修改文件或目录的存取时间</td></tr><tr><td>D</td><td>检查压缩文件中的错误</td></tr><tr><td>d</td><td>使用dump命令备份时忽略本文件/目录</td></tr><tr><td>c</td><td>默认将文件或目录进行压缩</td></tr><tr><td>u</td><td>当删除该文件后依然保留其在硬盘中的数据，方便日后恢复</td></tr><tr><td>t</td><td>让文件系统支持尾部合并（tail-merging）</td></tr><tr><td>x</td><td>可以直接访问压缩文件中的内容</td></tr></tbody></table><p>实践是检验真理的唯一标准。如果您没有亲眼见证过隐藏权限强大功能的美妙，就一定不会相信原来Linux系统会如此安全。接下来我们再次新建一个普通文件，并为其设置不允许删除与覆盖（+a参数）权限，然后再尝试将这个文件删除：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# echo &quot;for Test&quot; &gt; linuxprobe[root@linuxprobe ~]# chattr +a linuxprobe[root@linuxprobe ~]# rm linuxproberm: remove regular file ‘linuxprobe’? yrm: cannot remove ‘linuxprobe’: Operation not permitted</code></pre><h4 id="lsattr"><a class="markdownIt-Anchor" href="#lsattr"></a> lsattr</h4><p>lsattr命令用于显示文件的隐藏权限，格式为</p><pre><code class="highlight plaintext">lsattr [参数] 文件</code></pre><p>在Linux系统中，文件的隐藏权限必须使用lsattr命令来查看，平时使用的ls之类的命令则看不出端倪：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# ls -al linuxprobe-rw-r--r--. 1 root root 9 Feb 12 11:42 linuxprobe</code></pre><p>一旦使用lsattr命令后，文件上被赋予的隐藏权限马上就会原形毕露。此时可以按照显示的隐藏权限的类型（字母），使用chattr命令将其去掉：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# lsattr linuxprobe-----a---------- linuxprobe[root@linuxprobe ~]# chattr -a linuxprobe[root@linuxprobe ~]# lsattr linuxprobe ---------------- linuxprobe[root@linuxprobe ~]# rm linuxprobe rm: remove regular file ‘linuxprobe’? y</code></pre><h2 id="文件目录"><a class="markdownIt-Anchor" href="#文件目录"></a> 文件/目录</h2><p>我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。</p><p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。在开始本教程前我们需要先知道什么是绝对路径与相对路径。</p><p><strong>绝对路径</strong>：</p><ul><li>路径的写法，由根目录 / 写起，例如： /usr/share/doc 这个目录。</li></ul><p><strong>相对路径</strong>：</p><ul><li>路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： cd …/man 这就是相对路径的写法啦！</li></ul><h3 id="处理目录常用命令"><a class="markdownIt-Anchor" href="#处理目录常用命令"></a> 处理目录常用命令</h3><ul><li>ls: 列出目录及文件名</li><li>cd：切换目录pwd：显示目前的目录</li><li>mkdir：创建一个新的目录</li><li>rmdir：删除一个空的目录</li><li>cp: 复制文件或目录</li><li>rm: 移除文件或目录</li><li>mv: 移动文件与目录，或修改文件与目录的名称</li></ul><h4 id="ls列出目录"><a class="markdownIt-Anchor" href="#ls列出目录"></a> ls(列出目录)</h4><p>在Linux系统当中， ls 命令可能是最常被运行的。</p><p>语法：</p><pre><code class="highlight plaintext">[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称[root@www ~]# ls [--color=&#123;never,auto,always&#125;] 目录名称[root@www ~]# ls [--full-time] 目录名称</code></pre><p>选项与参数：</p><ul><li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li><li>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</li><li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li></ul><p>案例：</p><ul><li>将家目录下的所有文件列出来(含属性与隐藏档)</li></ul><pre><code class="highlight plaintext">[root@www ~]# ls -al ~</code></pre><h4 id="cd切换目录"><a class="markdownIt-Anchor" href="#cd切换目录"></a> cd(切换目录)</h4><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p><p>语法：</p><pre><code class="highlight plaintext">cd [相对路径或绝对路径]</code></pre><blockquote><p>符号 “.” 指的是工作目录，”…” 指的是工作目录的父目录</p></blockquote><table><thead><tr><th>快捷键</th><th>运行结果</th></tr></thead><tbody><tr><td>cd</td><td>更改工作目录到你的家目录</td></tr><tr><td>cd -</td><td>更改工作目录到先前的工作目录</td></tr><tr><td>cd ~user_name</td><td>更改工作目录到用户家目录。例如, cd ~bob 会更改工作目录到用户“bob”的家目录。</td></tr></tbody></table><p>案例：</p><pre><code class="highlight plaintext">#使用 mkdir 命令创建 runoob 目录[root@www ~]# mkdir runoob#使用绝对路径切换到 runoob 目录[root@www ~]# cd /root/runoob/#使用相对路径切换到 runoob 目录[root@www ~]# cd ./runoob/# 表示回到自己的家目录，亦即是 /root 这个目录[root@www runoob]# cd ~# 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；[root@www ~]# cd ..</code></pre><h4 id="pwd显示目前所在的目录"><a class="markdownIt-Anchor" href="#pwd显示目前所在的目录"></a> pwd(显示目前所在的目录)</h4><p>pwd 是 Print Working Directory 的缩写，也就是显示目前所在目录的命令。</p><p>语法：</p><pre><code class="highlight plaintext">[root@www ~]# pwd [-P]</code></pre><p>选项与参数：</p><ul><li>-P ：显示出确实的路径，而非使用连结 (link) 路径。</li></ul><blockquote><p>当我们首次登录系统（或者启动终端仿真器会话）后，当前工作目录是我们的家目录。 每个用户都有他自己的家目录，当用户以普通用户的身份操控系统时，家目录是唯一 允许用户对文件进行写入的地方</p></blockquote><p>实例：</p><ul><li>单纯显示出目前的工作目录：</li></ul><pre><code class="highlight plaintext">[root@www ~]# pwd/root   &lt;== 显示出目录啦～</code></pre><ul><li>实例显示出实际的工作目录，而非连结档本身的目录名而已。</li></ul><pre><code class="highlight plaintext">[root@www ~]# cd /var/mail   &lt;==注意，/var/mail是一个连结档[root@www mail]# pwd/var/mail         &lt;==列出目前的工作目录[root@www mail]# pwd -P/var/spool/mail   &lt;==怎么回事？有没有加 -P 差很多～[root@www mail]# ls -ld /var/maillrwxrwxrwx 1 root root 10 Sep  4 17:54 /var/mail -&gt; spool/mail# 看到这里应该知道为啥了吧？因为 /var/mail 是连结档，连结到 /var/spool/mail # 所以，加上 pwd -P 的选项后，会不以连结档的数据显示，而是显示正确的完整路径啊！</code></pre><h4 id="mkdir创建新目录"><a class="markdownIt-Anchor" href="#mkdir创建新目录"></a> mkdir(创建新目录)</h4><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p><p>语法：</p><pre><code class="highlight plaintext">mkdir [-mp] 目录名称 . . .</code></pre><p>选项与参数：</p><ul><li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li><li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li></ul><p>实例：</p><ul><li>请到/tmp底下尝试创建数个新目录看看：</li></ul><pre><code class="highlight plaintext">[root@www ~]# cd /tmp[root@www tmp]# mkdir test    &lt;==创建一名为 test 的新目录[root@www tmp]# mkdir test1/test2/test3/test4mkdir: cannot create directory `test1/test2/test3/test4&#x27;: No such file or directory       &lt;== 没办法直接创建此目录啊！[root@www tmp]# mkdir -p test1/test2/test3/test4</code></pre><blockquote><p>加了这个 -p 的选项，可以自行帮你创建多层目录！</p></blockquote><ul><li>创建权限为 rwx–x–x 的目录。</li></ul><pre><code class="highlight plaintext">[root@www tmp]# mkdir -m 711 test2[root@www tmp]# ls -ldrwxr-xr-x  3 root  root 4096 Jul 18 12:50 testdrwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1drwx--x--x  2 root  root 4096 Jul 18 12:54 test2</code></pre><blockquote><p>上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx–x–x 的权限。</p></blockquote><blockquote><p><strong>注意表示法</strong>: 在描述一个命令时（如上所示），当有三个圆点跟在一个命令的参数后面， 这意味着那个参数可以重复</p></blockquote><pre><code class="highlight plaintext">mkdir dir1mkdir dir1 dir2 dir3</code></pre><h4 id="rmdir删除空目录"><a class="markdownIt-Anchor" href="#rmdir删除空目录"></a> rmdir(删除空目录)</h4><p>语法：</p><pre><code class="highlight plaintext">rmdir [-p] 目录名称</code></pre><p>选项与参数：</p><ul><li>-p ：连同上一级『空的』目录也一起删除</li></ul><p>案例：</p><ul><li>删除 runoob 目录</li></ul><pre><code class="highlight plaintext">[root@www tmp]# rmdir runoob/</code></pre><h4 id="rm移除文件或目录"><a class="markdownIt-Anchor" href="#rm移除文件或目录"></a> rm(移除文件或目录)</h4><p>语法：</p><pre><code class="highlight plaintext">rm [-fir] 文件或目录 . . .</code></pre><p>选项与参数：</p><table><thead><tr><th>选项</th><th>意义</th></tr></thead><tbody><tr><td>-i, --interactive</td><td>在删除已存在的文件前，提示用户确认信息。 如果不指定这个选项，rm 会默默地删除文件</td></tr><tr><td>-r, --recursive</td><td>递归地删除文件，这意味着，如果要删除一个目录，而此目录 又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。</td></tr><tr><td>-f, --force</td><td>忽视不存在的文件，不显示提示信息。这选项颠覆了“–interactive”选项。</td></tr><tr><td>-v, --verbose</td><td>在执行 rm 命令时，显示翔实的操作信息。</td></tr></tbody></table><p>案例：</p><p>将刚刚在 cp 的实例中创建的 bashrc 删除掉！</p><pre><code class="highlight plaintext">[root@www tmp]# rm -i bashrcrm: remove regular file `bashrc&#x27;? y</code></pre><blockquote><p>如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</p></blockquote><table><thead><tr><th>命令</th><th>运行结果</th></tr></thead><tbody><tr><td>rm file1</td><td>默默地删除文件</td></tr><tr><td>rm -i file1</td><td>除了在删除文件之前，提示用户确认信息之外，和上面的命令作用一样。</td></tr><tr><td>rm -r file1 dir1</td><td>删除文件 file1, 目录 dir1，及 dir1 中的内容。</td></tr><tr><td>rm -rf file1 dir1</td><td>同上，除了如果文件 file1，或目录 dir1 不存在的话，rm 仍会继续执行。</td></tr></tbody></table><blockquote><p>一定要小心rm命令，类 Unix 的操作系统，比如说 Linux，没有复原命令。一旦你用 rm 删除了一些东西， 它就消失了，<strong>尤其要小心通配符</strong></p></blockquote><blockquote><p>小贴士。 无论什么时候，rm 命令用到通配符（除了仔细检查输入的内容外！）， 用 ls 命令来测试通配符。这会让你看到要删除的文件列表。然后按下上箭头按键，重新调用 刚刚执行的命令，用 rm 替换 ls</p></blockquote><h4 id="cp复制文件或目录"><a class="markdownIt-Anchor" href="#cp复制文件或目录"></a> cp(复制文件或目录)</h4><p>cp即拷贝文件和目录</p><p>语法：</p><pre><code class="highlight plaintext">cp [-adfilprsu] 来源(source) 目标(destination)cp [options] source1 source2 source3 . . .  directory</code></pre><blockquote><p>如果目标文件是目录，则会把源文件复制到该目录中；</p></blockquote><blockquote><p>如果目标文件也是普通文件，则会询问是否要覆盖它；</p></blockquote><blockquote><p>如果目标文件不存在，则执行正常的复制操作。</p></blockquote><p>选项与参数：</p><table><thead><tr><th>选 项</th><th>意义</th></tr></thead><tbody><tr><td>-a, --archive</td><td>复制文件和目录，以及它们的属性，包括所有权和权限。 通常，复本具有用户所操作文件的默认属性。相当于-pdr</td></tr><tr><td>-i, --interactive</td><td>在重写已存在文件之前，提示用户确认。如果这个选项不指定， cp 命令会默认重写文件。</td></tr><tr><td>-r, --recursive</td><td>递归地复制目录及目录中的内容。当复制目录时， 需要这个选项（或者-a 选项）。</td></tr><tr><td>-u, --update</td><td>当把文件从一个目录复制到另一个目录时，仅复制 目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。</td></tr><tr><td>-v, --verbose</td><td>显示翔实的命令操作信息</td></tr><tr><td>-d</td><td>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身</td></tr><tr><td>-f</td><td>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</td></tr><tr><td>-l</td><td>进行硬式连结(hard link)的连结档创建，而非复制文件本身；</td></tr><tr><td>-p</td><td>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</td></tr><tr><td>-s</td><td>复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</td></tr></tbody></table><p>案例：</p><p>用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc</p><pre><code class="highlight plaintext">[root@www ~]# cp ~/.bashrc /tmp/bashrc[root@www ~]# cp -i ~/.bashrc /tmp/bashrccp: overwrite `/tmp/bashrc&#x27;? n  &lt;==n不覆盖，y为覆盖</code></pre><table><thead><tr><th>命令</th><th>运行结果</th></tr></thead><tbody><tr><td>cp file1 file2</td><td>复制文件 file1 内容到文件 file2。如果 file2 已经存在， file2 的内容会被 file1 的内容重写。如果 file2 不存在，则会创建 file2。</td></tr><tr><td>cp -i file1 file2</td><td>这条命令和上面的命令一样，除了如果文件 file2 存在的话，在文件 file2 被重写之前， 会提示用户确认信息。</td></tr><tr><td>cp file1 file2 dir1</td><td>复制文件 file1 和文件 file2 到目录 dir1。目录 dir1 必须存在。</td></tr><tr><td>cp dir1/* dir2</td><td>使用一个通配符，在目录 dir1 中的所有文件都被复制到目录 dir2 中。 dir2 必须已经存在。</td></tr><tr><td>cp -r dir1 dir2</td><td>复制目录 dir1 中的内容到目录 dir2。如果目录 dir2 不存在， 创建目录 dir2，操作完成后，目录 dir2 中的内容和 dir1 中的一样。 如果目录 dir2 存在，则目录 dir1 (和目录中的内容)将会被复制到 dir2 中。</td></tr></tbody></table><h4 id="mv移动文件与目录或修改名称"><a class="markdownIt-Anchor" href="#mv移动文件与目录或修改名称"></a> mv(移动文件与目录，或修改名称)</h4><p>语法：</p><pre><code class="highlight plaintext">mv [-fiu] source destinationmv [options] source1 source2 source3 .... directory</code></pre><p>选项与参数：</p><table><thead><tr><th>选项</th><th>意义</th></tr></thead><tbody><tr><td>-i --interactive</td><td>在重写一个已经存在的文件之前，提示用户确认信息。 <strong>如果不指定这个选项，mv 命令会默认重写文件内容</strong>。</td></tr><tr><td>-u --update</td><td>当把文件从一个目录移动另一个目录时，只是移动不存在的文件， 或者文件内容新于目标目录相对应文件的内容。</td></tr><tr><td>-f</td><td>force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</td></tr><tr><td>-v</td><td>显示详细的操作信息；</td></tr></tbody></table><p>案例：</p><p>复制一文件，创建一目录，将文件移动到目录中</p><pre><code class="highlight plaintext">[root@www ~]# cd /tmp[root@www tmp]# cp ~/.bashrc bashrc[root@www tmp]# mkdir mvtest[root@www tmp]# mv bashrc mvtest</code></pre><p>将某个文件移动到某个目录去，就是这样做！</p><p>将刚刚的目录名称更名为 mvtest2</p><pre><code class="highlight plaintext">[root@www tmp]# mv mvtest mvtest2</code></pre><table><thead><tr><th>命令</th><th>意义</th></tr></thead><tbody><tr><td>mv file1 file2</td><td>移动 file1 到 file2。如果 file2 存在，它的内容会被 file1 的内容重写。 如果 file2 不存在，则创建 file2。 每种情况下，file1 不再存在。</td></tr><tr><td>mv -i file1 file2</td><td>除了如果 file2 存在的话，在 file2 被重写之前，用户会得到 提示信息外，这个和上面的选项一样。</td></tr><tr><td>mv file1 file2 dir1</td><td>移动 file1 和 file2 到目录 dir1 中。dir1 必须已经存在。</td></tr><tr><td>mv dir1 dir2</td><td>如果目录 dir2 不存在，创建目录 dir2，并且移动目录 dir1 的内容到 目录 dir2 中，同时删除目录 dir1。如果目录 dir2 存在，移动目录 dir1（及它的内容）到目录 dir2。</td></tr></tbody></table><h4 id="touch"><a class="markdownIt-Anchor" href="#touch"></a> touch</h4><p>touch命令用于<strong>创建空白文件或设置文件的时间</strong>，格式为</p><pre><code class="highlight plaintext">touch [选项] [文件]</code></pre><p>在创建空白的文本文件方面，这个touch命令相当简捷，简捷到没有必要铺开去讲。比如，touch linuxprobe命令可以创建出一个名为linuxprobe的空白文本文件。对touch命令来讲，有难度的操作主要是体现在设置文件内容的修改时间（mtime）、文件权限或属性的更改时间（ctime）与文件的读取时间（atime）上面。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>仅修改“读取时间”（atime）</td></tr><tr><td>-m</td><td>仅修改“修改时间”（mtime）</td></tr><tr><td>-d</td><td>同时修改atime与mtime</td></tr></tbody></table><p>接下来，我们先使用ls命令查看一个文件的修改时间，然后修改这个文件，最后再通过touch命令把修改后的文件时间设置成修改之前的时间（很多黑客就是这样做的呢）：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# ls -l anaconda-ks.cfg -rw-------. 1 root root 1213 May  4 15:44 anaconda-ks.cfg[root@linuxprobe ~]# echo &quot;Visit the LinuxProbe.com to learn linux skills&quot; &gt;&gt; anaconda-ks.cfg[root@linuxprobe ~]# ls -l anaconda-ks.cfg-rw-------. 1 root root 1260 Aug  2 01:26 anaconda-ks.cfg[root@linuxprobe ~]# touch -d &quot;2017-05-04 15:44&quot; anaconda-ks.cfg [root@linuxprobe ~]# ls -l anaconda-ks.cfg -rw-------. 1 root root 1260 May  4 15:44 anaconda-ks.cfg</code></pre><h4 id="dd"><a class="markdownIt-Anchor" href="#dd"></a> dd</h4><p>dd命令用于<strong>按照指定大小和个数的数据块来复制文件或转换文件</strong>，格式为</p><pre><code class="highlight plaintext">dd [参数]</code></pre><p>dd命令是一个比较重要而且比较有特色的一个命令，它能够让用户按照指定大小和个数的数据块来复制文件的内容。当然如果愿意的话，还可以在复制过程中转换其中的数据。</p><p>Linux系统中有一个名为/dev/zero的设备文件，每次在课堂上解释它时都充满哲学理论的色彩。因为这个文件不会占用系统存储空间，但却可以提供无穷无尽的数据，因此可以使用它作为dd命令的输入文件，来生成一个指定大小的文件。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>if</td><td>输入的文件名称</td></tr><tr><td>of</td><td>输出的文件名称</td></tr><tr><td>bs</td><td>设置每个“块”的大小</td></tr><tr><td>count</td><td>设置要复制“块”的个数</td></tr></tbody></table><p>例如我们可以用dd命令从/dev/zero设备文件中取出一个大小为560MB的数据块，然后保存成名为560_file的文件。在理解了这个命令后，以后就能随意创建任意大小的文件了：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# dd if=/dev/zero of=560_file count=1 bs=560M1+0 records in1+0 records out587202560 bytes (587 MB) copied, 27.1755 s, 21.6 MB/s</code></pre><p>dd命令的功能也绝不仅限于复制文件这么简单。如果您想把光驱设备中的光盘制作成iso格式的镜像文件，在Windows系统中需要借助于第三方软件才能做到，但在Linux系统中可以直接使用dd命令来压制出光盘镜像文件，将它变成一个可立即使用的iso镜像：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# dd if=/dev/cdrom of=RHEL-server-7.0-x86_64-LinuxProbe.Com.iso7311360+0 records in7311360+0 records out3743416320 bytes (3.7 GB) copied, 370.758 s, 10.1 MB/s</code></pre><h4 id="file查看文件类型"><a class="markdownIt-Anchor" href="#file查看文件类型"></a> file(查看文件类型)</h4><p>file命令用于查看文件的类型，格式为</p><pre><code class="highlight plaintext">file 文件名</code></pre><p>在Linux系统中，由于文本、目录、设备等所有这些一切都统称为文件，而我们又不能单凭后缀就知道具体的文件类型，这时就需要使用file命令来查看文件类型了</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# file anaconda-ks.cfganaconda-ks.cfg: ASCII text[root@linuxprobe ~]# file /dev/sda/dev/sda: block special</code></pre><h3 id="软硬方式连接"><a class="markdownIt-Anchor" href="#软硬方式连接"></a> 软硬方式连接</h3><p>在Windows系统中，快捷方式就是指向原始文件的一个链接文件，可以让用户从不同的位置来访问原始的文件；原文件一旦被删除或剪切到其他地方后，会导致链接文件失效。但是，这个看似简单的东西在Linux系统中可不太一样。</p><p>在Linux系统中存在硬链接和软连接两种文件。</p><p><strong>硬链接</strong>（hard link）：可以将它理解为一个“指向原始文件inode的指针”，系统不为它分配独立的inode和文件。所以，硬链接文件与原始文件其实是同一个文件，只是名字不同。我们每添加一个硬链接，该文件的inode连接数就会增加1；而且只有当该文件的inode连接数为0时，才算彻底将它删除。换言之，由于硬链接实际上是指向原文件inode的指针，因此即便原始文件被删除，依然可以通过硬链接文件来访问。需要注意的是，由于技术的局限性，我们不能跨分区对目录文件进行链接。</p><p><strong>软链接</strong>（也称为符号链接[symbolic link]）：仅仅包含所链接文件的路径名，因此能链接目录文件，也可以跨越文件系统进行链接。但是，当原始文件被删除后，链接文件也将失效，从这一点上来说与Windows系统中的“快捷方式”具有一样的性质。<strong>如果链接目录，则更改软链接目录内文件和更改原始目录文件是相同的效果</strong></p><h4 id="ln"><a class="markdownIt-Anchor" href="#ln"></a> ln</h4><p>ln命令用于创建链接文件，格式为</p><pre><code class="highlight plaintext">ln [选项] 目标 软链接名</code></pre><p>其可用的参数以及作用如表6-6所示。在使用ln命令时，是否添加-s参数，将创建出性质不同的两种“快捷方式”。因此如果没有扎实的理论知识和实践经验做铺垫，尽管能够成功完成实验，但永远不会明白为什么会成功。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-s</td><td>创建“符号链接”（如果不带-s参数，则默认创建硬链接）</td></tr><tr><td>-f</td><td>强制创建文件或目录的链接</td></tr><tr><td>-i</td><td>覆盖前先询问</td></tr><tr><td>-v</td><td>显示创建链接的过程</td></tr></tbody></table><p>为了更好地理解软链接、硬链接的不同性质，接下来创建一个类似于Windows系统中快捷方式的软链接。这样，当原始文件被删除后，就无法读取新建的链接文件了。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# echo &quot;Welcome to linuxprobe.com&quot; &gt; readme.txt[root@linuxprobe ~]# ln -s readme.txt readit.txt[root@linuxprobe ~]# cat readme.txt Welcome to linuxprobe.com[root@linuxprobe ~]# cat readit.txt Welcome to linuxprobe.com[root@linuxprobe ~]# ls -l readme.txt -rw-r--r-- 1 root root 26 Jan 11 00:08 readme.txt[root@linuxprobe ~]# rm -f readme.txt [root@linuxprobe ~]# cat readit.txt cat: readit.txt: No such file or directory</code></pre><p>接下来针对一个原始文件创建一个硬链接，即相当于针对原始文件的硬盘存储位置创建了一个指针，这样一来，新创建的这个硬链接就不再依赖于原始文件的名称等信息，也不会因为原始文件的删除而导致无法读取。同时可以看到创建硬链接后，原始文件的硬盘链接数量增加到了2。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# echo &quot;Welcome to linuxprobe.com&quot; &gt; readme.txt[root@linuxprobe ~]# ln readme.txt readit.txt[root@linuxprobe ~]# cat readme.txt Welcome to linuxprobe.com[root@linuxprobe ~]# cat readit.txt Welcome to linuxprobe.com[root@linuxprobe ~]# ls -l readme.txt -rw-r--r-- 2 root root 26 Jan 11 00:13 readme.txt[root@linuxprobe ~]# rm -f readme.txt [root@linuxprobe ~]# cat readit.txt Welcome to linuxprobe.com</code></pre><p><strong>总结</strong></p><p>依此您可以做一些相关的测试，可以得到以下全部结论：</p><ul><li>1).删除符号连接f3,对f1,f2无影响；</li><li>2).删除硬连接f2，对f1,f3也无影响；</li><li>3).删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效；</li><li>4).同时删除原文件f1,硬连接f2，整个文件会真正的被删除。</li></ul><h3 id="文件内容查看"><a class="markdownIt-Anchor" href="#文件内容查看"></a> 文件内容查看</h3><p>Linux系统中使用以下命令来查看文件的内容：</p><ul><li>cat  由第一行开始显示文件内容</li><li>tac  从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li><li>nl   显示的时候，顺道输出行号！</li><li>more 一页一页的显示文件内容</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li><li>head 只看头几行</li><li>tail 只看尾巴几行</li></ul><p>你可以使用man [命令]来查看各个命令的使用文档，如 ：man cp。</p><h4 id="cat由第一行开始显示文件内容"><a class="markdownIt-Anchor" href="#cat由第一行开始显示文件内容"></a> cat(由第一行开始显示文件内容)</h4><p>cat命令用于查看纯文本文件（内容较少的）</p><p>语法：</p><pre><code class="highlight plaintext">cat [-AbEnTv]</code></pre><p>选项与参数：</p><ul><li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li><li>-b ：<strong>列出行号，仅针对非空白行做行号显示</strong>，空白行不标行号！</li><li>-E ：将结尾的断行字节 $ 显示出来；</li><li>-n ：<strong>列印出行号</strong>，连同空白行也会有行号，与 -b 的选项不同；</li><li>-T ：将 [tab] 按键以 ^I 显示出来；</li><li>-v ：列出一些看不出来的特殊字符</li></ul><p>案例：</p><ul><li>检看 /etc/issue 这个文件的内容：</li></ul><pre><code class="highlight plaintext">[root@www ~]# cat /etc/issueCentOS release 6.4 (Final)Kernel \r on an \m</code></pre><h4 id="tac由最后一行开始显示文件内容"><a class="markdownIt-Anchor" href="#tac由最后一行开始显示文件内容"></a> tac(由最后一行开始显示文件内容)</h4><p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p><pre><code class="highlight plaintext">[root@www ~]# tac /etc/issueKernel \r on an \mCentOS release 6.4 (Final)</code></pre><h4 id="nl可以显示行号"><a class="markdownIt-Anchor" href="#nl可以显示行号"></a> nl(可以显示行号)</h4><p>显示行号</p><p>语法：</p><pre><code class="highlight plaintext">nl [-bnw] 文件</code></pre><p>选项与参数：</p><ul><li>-b ：指定行号指定的方式，主要有两种：<ul><li>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；</li><li>-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li></ul></li><li>-n ：列出行号表示的方法，主要有三种：<ul><li>-n ln ：行号在荧幕的最左方显示；</li><li>-n rn ：行号在自己栏位的最右方显示，且不加 0 ；</li><li>-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li></ul></li><li>-w ：行号栏位的占用的位数。</li></ul><p>案例：</p><ul><li>用 nl 列出 /etc/issue 的内容</li></ul><pre><code class="highlight plaintext">[root@www ~]# nl /etc/issue     1  CentOS release 6.4 (Final)     2  Kernel \r on an \m</code></pre><h4 id="more一页一页翻动"><a class="markdownIt-Anchor" href="#more一页一页翻动"></a> more(一页一页翻动)</h4><p>more命令用于查看纯文本文件（内容较多的）</p><p>语法：</p><pre><code class="highlight plaintext">more /etc/man_db.config</code></pre><p>案例：</p><pre><code class="highlight plaintext">[root@www ~]# more /etc/man_db.config ## Generated automatically from man.conf.in by the# configure script.## man.conf from man-1.6d....(中间省略)....--More--(28%)  &lt;== 重点在这一行喔！你的光标也会在这里等待你的命令</code></pre><p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p><ul><li>空白键 (space)：代表向下翻一页；</li><li>Enter：代表向下翻『一行』；</li><li>/字串：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li><li>:f：立刻显示出档名以及目前显示的行数；</li><li>q：代表立刻离开 more ，不再显示该文件内容。</li><li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li></ul><h4 id="less一页一页翻动"><a class="markdownIt-Anchor" href="#less一页一页翻动"></a> less(一页一页翻动)</h4><p>语法：</p><pre><code class="highlight plaintext">less /etc/man.config</code></pre><p>案例：</p><ul><li>一页一页翻动，以下实例输出/etc/man.config文件的内容：</li></ul><pre><code class="highlight plaintext">[root@www ~]# less /etc/man.config## Generated automatically from man.conf.in by the# configure script.## man.conf from man-1.6d....(中间省略)....:   &lt;== 这里可以等待你输入命令！</code></pre><p>less运行时可以输入的命令有：</p><ul><li>空白键    ：向下翻动一页；</li><li>[pagedown]：向下翻动一页；</li><li>[pageup]  ：向上翻动一页；</li><li>/字串     ：向下搜寻『字串』的功能；</li><li>?字串     ：向上搜寻『字串』的功能；</li><li>n         ：重复前一个搜寻 (与 / 或 ? 有关！)</li><li>N         ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li><li>q         ：离开 less 这个程序；</li></ul><h4 id="head取出文件前几行"><a class="markdownIt-Anchor" href="#head取出文件前几行"></a> head(取出文件前几行)</h4><p>取出文件前面几行</p><p>语法：</p><pre><code class="highlight plaintext">head [-n number] 文件</code></pre><p>选项与参数：</p><ul><li>-n ：后面接数字，代表显示几行的意思</li></ul><p>案例：</p><pre><code class="highlight plaintext">[root@www ~]# head /etc/man.config</code></pre><p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p><pre><code class="highlight plaintext">[root@www ~]# head -n 20 /etc/man.config</code></pre><h4 id="tail取出文件后几行"><a class="markdownIt-Anchor" href="#tail取出文件后几行"></a> tail(取出文件后几行)</h4><p>取出文件后面几行</p><p>语法：</p><pre><code class="highlight plaintext">tail [-n number] 文件</code></pre><p>选项与参数：</p><ul><li>-n ：后面接数字，代表显示几行的意思</li><li>-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测</li></ul><pre><code class="highlight plaintext">[root@www ~]# tail /etc/man.config# 默认的情况中，显示最后的十行！若要显示最后的 20 行，就得要这样：[root@www ~]# tail -n 20 /etc/man.config</code></pre><h4 id="tr替换文本内容"><a class="markdownIt-Anchor" href="#tr替换文本内容"></a> tr(替换文本内容)</h4><p>tr命令用于替换文本文件中的字符，格式为</p><pre><code class="highlight plaintext">tr [原始字符] [目标字符]</code></pre><p>在很多时候，我们想要快速地替换文本中的一些词汇，又或者把整个文本内容都进行替换，如果进行手工替换，难免工作量太大，尤其是需要处理大批量的内容时，进行手工替换更是不现实。这时，就可以先使用cat命令读取待处理的文本，然后通过管道符（详见第3章）把这些文本内容传递给tr命令进行替换操作即可。例如，把某个文本内容中的英文全部替换为大写：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# cat anaconda-ks.txt | tr [a-z] [A-Z]</code></pre><h4 id="wc统计行数"><a class="markdownIt-Anchor" href="#wc统计行数"></a> wc(统计行数)</h4><p>wc命令用于统计指定文本的行数、字数、字节数，格式为</p><pre><code class="highlight plaintext">wc [参数] 文本</code></pre><p>每次我在课堂上讲到这个命令时，总有同学会联想到一种公共设施，其实这两者毫无关联。Linux系统中的wc命令用于统计文本的行数、字数、字节数等。如果为了方便自己记住这个命令的作用，也可以联想到上厕所时好无聊，无聊到数完了手中的如厕读物上有多少行字</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-l</td><td>只显示行数</td></tr><tr><td>-w</td><td>只显示单词数</td></tr><tr><td>-c</td><td>只显示字节数</td></tr></tbody></table><p>在Linux系统中，passwd是用于保存系统账户信息的文件，要统计当前系统中有多少个用户，可以使用下面的命令来进行查询，是不是很神奇：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# wc -l /etc/passwd38 /etc/passwd</code></pre><h4 id="stat查看文件信息"><a class="markdownIt-Anchor" href="#stat查看文件信息"></a> stat(查看文件信息)</h4><p>stat命令用于查看文件的具体存储信息和时间等信息，格式为</p><pre><code class="highlight plaintext">stat 文件名称</code></pre><p>stat命令可以用于查看文件的存储信息和时间等信息，命令stat anaconda-ks.cfg会显示出文件的三种时间状态（已加粗）：Access、Modify、Change。这三种时间的区别将在下面的touch命令中详细详解：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# stat anaconda-ks.cfgFile: ‘anaconda-ks.cfg’Size: 1213 Blocks: 8 IO Block: 4096 regular fileDevice: fd00h/64768d Inode: 68912908 Links: 1Access: (0600/-rw-------) Uid: ( 0/ root) Gid: ( 0/ root)Context: system_u:object_r:admin_home_t:s0Access: 2017-07-14 01:46:18.721255659 -0400Modify: 2017-05-04 15:44:36.916027026 -0400Change: 2017-05-04 15:44:36.916027026 -0400Birth: -</code></pre><h4 id="cut提取列"><a class="markdownIt-Anchor" href="#cut提取列"></a> cut(提取列)</h4><p>命令<strong>cut命令用于按“列”提取文本字符</strong>，格式为</p><pre><code class="highlight plaintext">cut [参数] 文本</code></pre><p>在Linux系统中，如何准确地提取出最想要的数据，这也是我们应该重点学习的内容。一般而言，按基于“行”的方式来提取数据是比较简单的，只需要设置好要搜索的关键词即可。但是如果按列搜索，不仅要使用-f参数来设置需要看的列数，还需要使用-d参数来设置间隔符号。</p><p>passwd在保存用户数据信息时，用户信息的每一项值之间是采用冒号来间隔的，接下来我们使用下述命令尝试提取出passwd文件中的用户名信息，即提取以冒号（：）为间隔符号的第一列内容：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# head -n 2 /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologin[root@linuxprobe ~]# cut -d: -f1 /etc/passwdrootbindaemonadmlpsyncshutdownhaltmailoperatorgamesftpnobodydbuspolkitdunboundcolordusbmuxdavahiavahi-autoipdlibstoragemgmtsaslauth</code></pre><h4 id="diff比较"><a class="markdownIt-Anchor" href="#diff比较"></a> diff(比较)</h4><p>diff命令用于比较多个文本文件的差异，格式为</p><pre><code class="highlight plaintext">diff [参数] 文件</code></pre><p>在使用diff命令时，不仅可以<strong>使用—brief参数来确认两个文件是否不同</strong>，还可以<strong>使用-c参数来详细比较出多个文件的差异之处</strong>，这绝对是判断文件是否被篡改的有力神器。</p><p>接下来使用diff —brief命令显示比较后的结果，判断文件是否相同：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# diff --brief diff_A.txt diff_B.txtFiles diff_A.txt and diff_B.txt differ</code></pre><p>最后使用带有-c参数的diff命令来描述文件内容具体的不同：</p><pre><code class="highlight plaintext"> [root@linuxprobe ~]# diff -c diff_A.txt diff_B.txt** diff_A.txt 2017-08-30 18:07:45.230864626 +0800--- diff_B.txt 2017-08-30 18:08:52.203860389 +0800********* 1,5 **! Welcome to linuxprobe.comRed Hat certified! Free Linux LessonsProfessional guidanceLinux Course--- 1,7 ----! Welcome tooo linuxprobe.com!Red Hat certified! Free Linux LeSSonS! ////////.....////////Professional guidanceLinux Course</code></pre><h3 id="查找"><a class="markdownIt-Anchor" href="#查找"></a> 查找</h3><ul><li><strong>which</strong>       查看可执行文件的位置</li><li><strong>whereis</strong>    查看文件的位置</li><li><strong>locate</strong>       配 合数据库查看文件位置</li><li><strong>find</strong>          实际搜寻硬盘查询文件名称</li></ul><h4 id="find"><a class="markdownIt-Anchor" href="#find"></a> find</h4><p>find是最常见和最强大的查找命令，你可以用它找到任何你想找的文件</p><p>语法：</p><ul><li>&lt;<strong>指定目录</strong>&gt;： 所要搜索的目录及其所有子目录。默认为当前目录。</li><li>&lt;<strong>指定条件</strong>&gt;： 所要搜索的文件的特征。</li><li>&lt;<strong>指定动作</strong>&gt;： 对搜索结果进行特定的处理。</li></ul><pre><code class="highlight plaintext">$ find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;</code></pre><p>参数：</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-<strong>name</strong></td><td>匹配名称（可以使用通配符）</td></tr><tr><td>-perm</td><td>匹配权限（mode为完全匹配，-mode为包含即可）</td></tr><tr><td>-user</td><td>匹配所有者</td></tr><tr><td>-group</td><td>匹配所有组</td></tr><tr><td>-mtime -n +n</td><td>匹配修改内容的时间（-n指n天以内，+n指n天以前）</td></tr><tr><td>-atime -n +n</td><td>匹配访问文件的时间（-n指n天以内，+n指n天以前）</td></tr><tr><td>-ctime -n +n</td><td>匹配修改文件权限的时间（-n指n天以内，+n指n天以前）</td></tr><tr><td>-nouser</td><td>匹配无所有者的文件</td></tr><tr><td>-nogroup</td><td>匹配无所有组的文件</td></tr><tr><td>-newer f1 !f2</td><td>匹配比文件f1新但比f2旧的文件</td></tr><tr><td>—type b/d/c/p/l/f</td><td>匹配文件类型（后面的字幕字母依次表示块设备、目录、字符设备、管道、链接文件、文本文件）</td></tr><tr><td>-size</td><td>匹配文件的大小（+50KB为查找超过50KB的文件，而-50KB为查找小于50KB的文件）</td></tr><tr><td>-prune</td><td>忽略某个目录</td></tr><tr><td>-exec …… {};</td><td>后面可跟用于进一步处理搜索结果的命令，{}表示find命令搜索出的每一个文件，并且命令的结尾必须是“;”</td></tr></tbody></table><p>示例：</p><ul><li>搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。</li></ul><pre><code class="highlight plaintext">$ find . -name &quot;my*&quot;</code></pre><ul><li>搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息</li></ul><pre><code class="highlight plaintext">$ find . -name &quot;my*&quot; -ls</code></pre><ul><li>在整个文件系统中找出所有归属于linuxprobe用户的文件并复制到/root/findresults目录</li></ul><pre><code class="highlight plaintext">$ find / -user linuxprobe -exec cp -a &#123;&#125; /root/findresults/ \;</code></pre><h4 id="whereis"><a class="markdownIt-Anchor" href="#whereis"></a> whereis</h4><p>whereis命令只能用于程序名的搜索</p><p>语法：</p><pre><code class="highlight plaintext">$ whereis [-bmsu] 文件或者目录名称</code></pre><p>参数：</p><ul><li>-b ： 只找二进制文件</li><li>-m： 只找在说明文件manual路径下的文件</li><li>-s ： 只找source源文件</li><li>-u ： 没有说明文档的文件</li></ul><blockquote><p>和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新</p></blockquote><p>实例：</p><pre><code class="highlight plaintext">$ whereis passwd passwd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz /usr/share/man/man5/passwd.5.gz #将和passwd文件相关的文件都查找出来 $ whereis -b passwd passwd: /usr/bin/passwd /etc/passwd #只将二进制文件 查找出来</code></pre><h4 id="locate"><a class="markdownIt-Anchor" href="#locate"></a> locate</h4><p>locate命令其实是“find -name”的另一种写法，但是要<strong>比后者快得多</strong>，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。</p><p>Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，<strong>可以在使用locate之前，先使用updatedb命令</strong>，手动更新数据库</p><p>语法：</p><pre><code class="highlight plaintext">$ locate 文件或者目录名称</code></pre><p>示例：</p><pre><code class="highlight plaintext">[root@redhat ~]# locate passwd</code></pre><h4 id="which"><a class="markdownIt-Anchor" href="#which"></a> which</h4><p>which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p><p>which是通过 PATH环境变量到该路径内查找可执行文件，所以基本的功能是寻找可执行文件</p><p>语法：</p><pre><code class="highlight plaintext">$ which 可执行文件名称</code></pre><p>示例：</p><pre><code class="highlight plaintext">$ which passwd /usr/bin/passwd</code></pre><h4 id="grep"><a class="markdownIt-Anchor" href="#grep"></a> grep</h4><p>grep（General Regular Expression Parser，通用规则表达式分析程序）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来</p><p>语法：</p><pre><code class="highlight plaintext">grep [选项] pattern [文件名]</code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>将可执行文件(binary)当作文本文件（text）来搜索</td></tr><tr><td>-c</td><td>仅显示找到的行数</td></tr><tr><td>-i</td><td>忽略大小写</td></tr><tr><td>-n</td><td><strong>显示搜索到信息的行号</strong></td></tr><tr><td>-v</td><td><strong>反选信息</strong>（即没有包含关键词的所有信息行）</td></tr><tr><td>-r</td><td>递归搜索文件夹</td></tr><tr><td>-l</td><td>只显示搜索出文件的文件名</td></tr><tr><td>–include</td><td>指定文件后缀名</td></tr></tbody></table><pre><code class="highlight plaintext">#递归搜索当前目录py结尾文件中是否包含xtrabackupgrep -lr &quot;xtrabackup&quot; --include=&quot;*.py&quot; ./</code></pre><p>在Linux系统中，/etc/passwd文件是保存着所有的用户信息，而一旦用户的登录终端被设置成/sbin/nologin，则不再允许登录系统，因此可以使用grep命令来查找出当前系统中不允许登录系统的所有用户信息：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# grep /sbin/nologin /etc/passwdbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologin………………省略部分输出过程信息………………</code></pre><p>为了更好的探究 grep 程序，让我们创建一些文本文件来搜寻：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ ls /bin &gt; dirlist-bin.txt[me@linuxbox ~]$ ls /usr/bin &gt; dirlist-usr-bin.txt[me@linuxbox ~]$ ls /sbin &gt; dirlist-sbin.txt[me@linuxbox ~]$ ls /usr/sbin &gt; dirlist-usr-sbin.txt[me@linuxbox ~]$ ls dirlist*.txtdirlist-bin.txt     dirlist-sbin.txt    dirlist-usr-sbin.txtdirlist-usr-bin.txt</code></pre><p>我们能够对我们的文件列表执行简单的搜索，像这样：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ grep bzip dirlist*.txtdirlist-bin.txt:bzip2dirlist-bin.txt:bzip2recover</code></pre><p><strong>正则匹配</strong></p><pre><code class="highlight plaintext">[me@linuxbox ~]$ grep -h &#x27;^zip&#x27; dirlist*.txtzipzipcloakzipgrepzipinfozipnotezipsplit[me@linuxbox ~]$ grep -h &#x27;zip$&#x27; dirlist*.txtgunzipgzipfunzipgpg-zippreunzipprezipunzipzip[me@linuxbox ~]$ grep -h &#x27;^zip$&#x27; dirlist*.txtzip[me@linuxbox ~]$ grep -i &#x27;^..j.r$&#x27; /usr/share/dict/wordsMajormajor[me@linuxbox ~]$ grep -h &#x27;[bg]zip&#x27; dirlist*.txtbzip2bzip2recovergzip</code></pre><h2 id="归档备份"><a class="markdownIt-Anchor" href="#归档备份"></a> 归档备份</h2><h3 id="解压缩"><a class="markdownIt-Anchor" href="#解压缩"></a> 解压缩</h3><h4 id="gzip"><a class="markdownIt-Anchor" href="#gzip"></a> gzip</h4><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>把输出写入到标准输出，并且保留原始文件。也有可能用–stdout 和–to-stdout 选项来指定。</td></tr><tr><td>-d</td><td>解压缩。正如 gunzip 命令一样。也可以用–decompress 或者–uncompress 选项来指定.</td></tr><tr><td>-f</td><td>强制压缩，即使原始文件的压缩文件已经存在了，也要执行。也可以用–force 选项来指定。</td></tr><tr><td>-h</td><td>显示用法信息。也可用–help 选项来指定。</td></tr><tr><td>-l</td><td>列出每个被压缩文件的压缩数据。也可用–list 选项。</td></tr><tr><td>-r</td><td>若命令的一个或多个参数是目录，则递归地压缩目录中的文件。也可用–recursive 选项来指定。</td></tr><tr><td>-t</td><td>测试压缩文件的完整性。也可用–test 选项来指定。</td></tr><tr><td>-v</td><td>显示压缩过程中的信息。也可用–verbose 选项来指定。</td></tr><tr><td>-number</td><td>设置压缩指数。number 是一个在1（最快，最小压缩）到9（最慢，最大压缩）之间的整数。 数值1和9也可以各自用–fast 和–best 选项来表示。默认值是整数6。</td></tr></tbody></table><p>这个 <strong>gzip</strong> 程序被用来压缩一个或多个文件。当执行 gzip 命令时，则原始文件的压缩版会替代原始文件。 相对应的 <strong>gunzip</strong> 程序被用来把压缩文件复原为没有被压缩的版本。这里有个例子：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ ls -l /etc &gt; foo.txt[me@linuxbox ~]$ ls -l foo.*-rw-r--r-- 1 me     me 15738 2008-10-14 07:15 foo.txt[me@linuxbox ~]$ gzip foo.txt[me@linuxbox ~]$ ls -l foo.*-rw-r--r-- 1 me     me 3230 2008-10-14 07:15 foo.txt.gz[me@linuxbox ~]$ gunzip foo.txt.gz[me@linuxbox ~]$ ls -l foo.*-rw-r--r-- 1 me     me 15738 2008-10-14 07:15 foo.txt</code></pre><h4 id="bzip2"><a class="markdownIt-Anchor" href="#bzip2"></a> bzip2</h4><p>这个 bzip2 程序，由 Julian Seward 开发，与 gzip 程序相似，但是使用了不同的压缩算法， 舍弃了压缩速度，而实现了更高的压缩级别。在大多数情况下，它的工作模式等同于 gzip。 由 bzip2 压缩的文件，用扩展名 .bz2 来表示：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ ls -l /etc &gt; foo.txt[me@linuxbox ~]$ ls -l foo.txt-rw-r--r-- 1 me     me      15738 2008-10-17 13:51 foo.txt[me@linuxbox ~]$ bzip2 foo.txt[me@linuxbox ~]$ ls -l foo.txt.bz2-rw-r--r-- 1 me     me      2792 2008-10-17 13:51 foo.txt.bz2[me@linuxbox ~]$ bunzip2 foo.txt.bz2</code></pre><p>正如我们所看到的，bzip2 程序使用起来和 gzip 程序一样。我们之前讨论的 gzip 程序的所有选项（除了-r） ，bzip2 程序同样也支持。注意，然而，压缩级别选项（-number）对于 bzip2 程序来说，有少许不同的含义。 伴随着 bzip2 程序，有 bunzip2 和 bzcat 程序来解压缩文件。bzip2 文件也带有 bzip2recover 程序，其会 试图恢复受损的 .bz2 文件。</p><h3 id="归档文件"><a class="markdownIt-Anchor" href="#归档文件"></a> 归档文件</h3><p>一个常见的，与文件压缩结合一块使用的文件管理任务是归档。归档就是收集许多文件，并把它们 捆绑成一个大文件的过程。归档经常作为系统备份的一部分来使用。当把旧数据从一个系统移到某 种类型的长期存储设备中时，也会用到归档程序。</p><h4 id="tar-打包"><a class="markdownIt-Anchor" href="#tar-打包"></a> tar 打包</h4><p>tar命令用于对文件进行打包压缩或解压，格式为</p><pre><code class="highlight plaintext">tar [选项] [文件]</code></pre><p>在Linux系统中，常见的文件格式比较多，其中主要使用的是.tar或.tar.gz或.tar.bz2格式，我们不用担心格式太多而记不住，其实这些格式大部分都是由tar命令来生成的。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>创建压缩文件</td></tr><tr><td>-x</td><td>解开压缩文件</td></tr><tr><td>-t</td><td>查看压缩包内有哪些文件</td></tr><tr><td>-z</td><td>用Gzip压缩或解压</td></tr><tr><td>-j</td><td>用bzip2压缩或解压</td></tr><tr><td>-v</td><td>显示压缩或解压的过程</td></tr><tr><td>-f</td><td>目标文件名<strong>必须放在最后</strong></td></tr><tr><td>-p</td><td>保留原始的权限与属性</td></tr><tr><td>-P</td><td>使用绝对路径来压缩</td></tr><tr><td>-C</td><td>指定解压到的目录</td></tr></tbody></table><blockquote><p>-c参数用于创建压缩文件，-x参数用于解压文件，因此这两个参数不能同时使用</p></blockquote><blockquote><p>-z参数指定使用Gzip格式来压缩或解压文件，-j参数指定使用bzip2格式来压缩或解压文件</p></blockquote><blockquote><p>使用-v参数向用户不断显示压缩或解压的过程</p></blockquote><blockquote><p>-C参数用于指定要解压到哪个指定的目录。</p></blockquote><blockquote><p>-f参数特别重要，它必须放到参数的最后一位，代表要压缩或解压的软件包名称</p></blockquote><p>一般使用压缩/解压命令组合：</p><pre><code class="highlight plaintext">tar -czvf 压缩包名称.tar.gz 要打包的目录tar -xzvf 压缩包名称.tar.gz -C 要解压到的目录</code></pre><p>案例：</p><ul><li>使用tar命令把/etc目录通过gzip格式进行打包压缩，并把文件命名为etc.tar.gz：</li></ul><pre><code class="highlight plaintext">[root@linuxprobe ~]# tar czvf etc.tar.gz /etctar: Removing leading `/&#x27; from member names/etc//etc/fstab/etc/crypttab/etc/mtab/etc/fonts//etc/fonts/conf.d//etc/fonts/conf.d/65-0-madan.conf/etc/fonts/conf.d/59-liberation-sans.conf/etc/fonts/conf.d/90-ttf-arphic-uming-embolden.conf/etc/fonts/conf.d/59-liberation-mono.conf/etc/fonts/conf.d/66-sil-nuosu.conf………………省略部分压缩过程信息………………</code></pre><ul><li>接下来将打包后的压缩包文件指定解压到/root/etc目录中（先使用mkdir命令来创建/root/etc目录）：</li></ul><pre><code class="highlight plaintext">[root@linuxprobe ~]# mkdir /root/etc[root@linuxprobe ~]# tar xzvf etc.tar.gz -C /root/etcetc/etc/fstabetc/crypttabetc/mtabetc/fonts/etc/fonts/conf.d/etc/fonts/conf.d/65-0-madan.confetc/fonts/conf.d/59-liberation-sans.confetc/fonts/conf.d/90-ttf-arphic-uming-embolden.confetc/fonts/conf.d/59-liberation-mono.confetc/fonts/conf.d/66-sil-nuosu.confetc/fonts/conf.d/65-1-vlgothic-gothic.confetc/fonts/conf.d/65-0-lohit-bengali.confetc/fonts/conf.d/20-unhint-small-dejavu-sans.conf………………省略部分解压过程信息………………</code></pre><h4 id="zip"><a class="markdownIt-Anchor" href="#zip"></a> zip</h4><p>这个 zip 程序既是压缩工具，也是一个打包工具。这程序使用的文件格式，Windows 用户比较熟悉， 因为它读取和写入.zip 文件。然而，在 Linux 中 gzip 是主要的压缩程序，而 bzip2则位居第二。</p><pre><code class="highlight plaintext">$ zip -r playground.zip playground</code></pre><p>使用 unzip 程序，来直接抽取一个 zip 文件的内容。</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ cd foo[me@linuxbox foo]$ unzip ../playground.zip</code></pre><h2 id="用户用户组管理"><a class="markdownIt-Anchor" href="#用户用户组管理"></a> 用户/用户组管理</h2><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p><p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p><p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p><ul><li>用户账号的添加、删除与修改。</li><li>用户口令的管理。</li><li>用户组的管理。</li></ul><h3 id="用户账号的管理"><a class="markdownIt-Anchor" href="#用户账号的管理"></a> 用户账号的管理</h3><p>用户账号的管理工作主要涉及到用户账号的添加、修改和删除。</p><p>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。</p><h4 id="useradd添加新用户"><a class="markdownIt-Anchor" href="#useradd添加新用户"></a> useradd(添加新用户)</h4><p>语法：</p><pre><code class="highlight plaintext">useradd 选项 用户名</code></pre><p>参数说明：</p><ul><li>-c comment 指定一段注释性描述。</li><li>-d 目录 指定用户主目录(默认为/home/username)，如果此目录不存在，则同时使用-m选项，可以创建主目录。</li><li>-g 用户组 指定用户所属的用户组。</li><li>-G 用户组，用户组 指定用户所属的附加组。</li><li>-s Shell文件 指定用户的登录Shell。</li><li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li><li>-e 账户的到期时间，格式为YYYY-MM-DD</li><li>-N 不创建与用户同名的基本用户组</li><li>用户名 : 指定新账号的登录名。</li></ul><p>案例：</p><ul><li>此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录 /home/sam（/home为默认的用户主目录所在的父目录）</li></ul><pre><code class="highlight plaintext"># useradd –d  /home/sam -m sam</code></pre><ul><li>此命令新建了一个用户gem，该用户的登录Shell是 /bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组</li></ul><pre><code class="highlight plaintext"># useradd -s /bin/sh -g group –G adm,root gem</code></pre><blockquote><p>增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。</p></blockquote><blockquote><p>Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理</p></blockquote><h4 id="userdel删除账号"><a class="markdownIt-Anchor" href="#userdel删除账号"></a> userdel(删除账号)</h4><p>如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录</p><p>删除一个已有的用户账号使用userdel命令，其格式如下：</p><p>语法：</p><pre><code class="highlight plaintext">userdel 选项 用户名</code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-f</td><td>强制删除用户</td></tr><tr><td>-r</td><td>同时删除用户及用户家目录</td></tr></tbody></table><blockquote><p>常用的选项是-r，作用是把主目录一起删除</p></blockquote><p>例如：</p><pre><code class="highlight plaintext"># userdel -r sam</code></pre><blockquote><p>此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录</p></blockquote><h4 id="usermod修改账号"><a class="markdownIt-Anchor" href="#usermod修改账号"></a> usermod(修改账号)</h4><p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。</p><p>修改已有用户的信息使用usermod命令，其格式如下：</p><pre><code class="highlight plaintext">usermod 选项 用户名</code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>填写用户账户的备注信息</td></tr><tr><td>-d</td><td>-m 参数-m与参数-d连用，可重新指定用户的家目录并自动把旧的数据转移过去</td></tr><tr><td>-e</td><td>账户的到期时间，格式为YYYY-MM-DD</td></tr><tr><td>-g</td><td>变更所属用户组</td></tr><tr><td>-G</td><td>变更扩展用户组</td></tr><tr><td>-L</td><td>锁定用户禁止其登录系统</td></tr><tr><td>-U</td><td>解锁用户，允许其登录系统</td></tr><tr><td>-s</td><td>变更默认终端</td></tr><tr><td>-u</td><td>修改用户的UID</td></tr></tbody></table><p>例子：</p><p>此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer</p><pre><code class="highlight plaintext"># usermod -s /bin/ksh -d /home/z –g developer sam</code></pre><h4 id="passwd用户口令的管理"><a class="markdownIt-Anchor" href="#passwd用户口令的管理"></a> passwd(用户口令的管理)</h4><p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p><p>指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：</p><pre><code class="highlight plaintext">passwd 选项 用户</code></pre><p>可使用的选项：</p><ul><li>-l 锁定口令，即禁用账号。</li><li>-u 口令解锁。</li><li>-d 使该用户可用空密码登录系统。</li><li>-e 强迫用户下次登录时修改口令。</li><li>-S 显示用户的密码是否可以被锁定，以及密码所采用的加密算法名称</li></ul><blockquote><p>如果默认用户名，则修改当前用户的口令。</p></blockquote><p>例子：</p><p>假设当前用户是sam，则下面的命令修改该用户自己的口令：</p><pre><code class="highlight plaintext">$ passwd Old password:****** New password:******* Re-enter new password:*******</code></pre><p>如果是超级用户，可以用下列形式指定任何用户的口令：</p><pre><code class="highlight plaintext"># passwd sam New password:******* Re-enter new password:*******</code></pre><blockquote><p>普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。</p></blockquote><p>为用户<strong>指定空口令</strong>时，执行下列形式的命令：</p><pre><code class="highlight plaintext"># passwd -d sam</code></pre><blockquote><p>此命令将用户 sam 的口令删除，这样用户 sam 下一次登录时，系统就不再允许该用户登录了</p></blockquote><p>passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如：</p><pre><code class="highlight plaintext"># pwsswd -l sam</code></pre><h3 id="用户组的管理"><a class="markdownIt-Anchor" href="#用户组的管理"></a> 用户组的管理</h3><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p><p>用户组的管理涉及用户组的添加、删除和修改。<strong>组的增加、删除和修改实际上就是对/etc/group文件的更新</strong>。</p><h4 id="group增加用户组"><a class="markdownIt-Anchor" href="#group增加用户组"></a> group(增加用户组)</h4><p>语法：</p><pre><code class="highlight plaintext">groupadd 选项 用户组</code></pre><p>可以使用的选项有：</p><ul><li>-g GID 指定新用户组的组标识号（GID）</li><li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同</li></ul><p>实例:</p><pre><code class="highlight plaintext"># groupadd group1</code></pre><blockquote><p>此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。</p></blockquote><p>实例2：</p><pre><code class="highlight plaintext"># groupadd -g 101 group2</code></pre><blockquote><p>此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101</p></blockquote><h4 id="groupdel删除用户组"><a class="markdownIt-Anchor" href="#groupdel删除用户组"></a> groupdel(删除用户组)</h4><p>语法：</p><pre><code class="highlight plaintext">groupdel 用户组</code></pre><p>例如：</p><p>从命令中删除用户组：</p><pre><code class="highlight plaintext"># groupdel group1</code></pre><h4 id="groupmod修改用户组"><a class="markdownIt-Anchor" href="#groupmod修改用户组"></a> groupmod(修改用户组)</h4><p>语法：</p><pre><code class="highlight plaintext">groupmod 选项 用户组</code></pre><p>常用选项：</p><ul><li>-g GID 为用户组指定新的组标识号。</li><li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li><li>-n新用户组 将用户组的名字改为新名字</li></ul><p>实例：</p><ul><li>此命令将组group2的组标识号修改为102</li></ul><pre><code class="highlight plaintext"># groupmod -g 102 group2</code></pre><ul><li>此命令将组group2的标识号改为10000，组名修改为group3</li></ul><pre><code class="highlight plaintext"># groupmod –g 10000 -n group3 group2</code></pre><h4 id="切换用户组"><a class="markdownIt-Anchor" href="#切换用户组"></a> 切换用户组</h4><p>用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：</p><pre><code class="highlight plaintext">$ newgrp root</code></pre><p>这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。</p><h3 id="与用户账号有关的系统文件"><a class="markdownIt-Anchor" href="#与用户账号有关的系统文件"></a> 与用户账号有关的系统文件</h3><p>完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。</p><p>与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。下面分别介绍这些文件的内容。</p><h4 id="etcpasswd-用户信息"><a class="markdownIt-Anchor" href="#etcpasswd-用户信息"></a> /etc/passwd 用户信息</h4><p>Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。这个文件对所有用户都是可读的。它的内容类似下面的例子：</p><pre><code class="highlight plaintext">＃ cat /etc/passwdroot:x:0:0:Superuser:/:daemon:x:1:1:System daemons:/etc:bin:x:2:2:Owner of system commands:/bin:sys:x:3:3:Owner of system files:/usr/sys:adm:x:4:4:System accounting:/usr/adm:uucp:x:5:5:UUCP administrator:/usr/lib/uucp:auth:x:7:21:Authentication administrator:/tcb/files/auth:cron:x:9:16:Cron daemon:/usr/spool/cron:listen:x:37:4:Network daemon:/usr/net/nls:lp:x:71:18:Printer administrator:/usr/spool/lp:sam:x:200:50:Sam san:/home/sam:/bin/sh</code></pre><p>含义如下：</p><ul><li>&quot;用户名&quot;是代表用户账号的字符串</li><li>“口令”一些系统中，存放着加密后的用户口令字</li><li>“用户标识号”是一个整数，系统内部用它来标识用户</li><li>“组标识号”字段记录的是用户所属的用户组</li><li>“注释性描述”字段记录着用户的一些个人情况</li><li>“主目录”，也就是用户的起始工作目录</li><li>用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell</li></ul><pre><code class="highlight plaintext">用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</code></pre><blockquote><p>由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件<strong>是/etc/shadow文件</strong>。 有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p></blockquote><blockquote><p>/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生</p></blockquote><hr /><p><strong>/etc/shadow文件格式</strong></p><ul><li>&quot;登录名&quot;是与/etc/passwd文件中的登录名相一致的用户账号</li><li>&quot;口令&quot;字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。</li><li>&quot;最后一次修改时间&quot;表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。</li><li>&quot;最小时间间隔&quot;指的是两次修改口令之间所需的最小天数。</li><li>&quot;最大时间间隔&quot;指的是口令保持有效的最大天数。</li><li>&quot;警告时间&quot;字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</li><li>&quot;不活动时间&quot;表示的是用户没有登录活动但账号仍能保持有效的最大天数。</li><li>&quot;失效时间&quot;字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</li></ul><pre><code class="highlight plaintext">登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</code></pre><h4 id="etcgroup-用户组"><a class="markdownIt-Anchor" href="#etcgroup-用户组"></a> /etc/group 用户组</h4><p>将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。</p><p>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。</p><p>当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。</p><p>用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。</p><p>用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：</p><pre><code class="highlight plaintext">组名:口令:组标识号:组内用户列表</code></pre><ul><li>&quot;组名&quot;是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。</li><li>&quot;口令&quot;字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*</li><li>&quot;组标识号&quot;与用户标识号类似，也是一个整数，被系统内部用来标识组。</li><li>&quot;组内用户列表&quot;是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</li></ul><p>例子：</p><pre><code class="highlight plaintext">root::0:rootbin::2:root,binsys::3:root,uucpadm::4:root,admdaemon::5:root,daemonlp::7:root,lpusers::20:root,sam</code></pre><h4 id="批量添加用户"><a class="markdownIt-Anchor" href="#批量添加用户"></a> 批量添加用户</h4><p>添加和删除用户对每位Linux系统管理员都是轻而易举的事，比较棘手的是如果要添加几十个、上百个甚至上千个用户时，我们不太可能还使用useradd一个一个地添加，必然要找一种简便的创建大量用户的方法。Linux系统提供了创建大量用户的工具，可以让您立即创建大量用户，方法如下：</p><ol><li><strong>先编辑一个文本用户文件</strong><br />每一列按照/etc/passwd密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。一个范例文件user.txt内容如下：</li></ol><pre><code class="highlight plaintext">user001::600:100:user:/home/user001:/bin/bashuser002::601:100:user:/home/user002:/bin/bashuser003::602:100:user:/home/user003:/bin/bashuser004::603:100:user:/home/user004:/bin/bashuser005::604:100:user:/home/user005:/bin/bashuser006::605:100:user:/home/user006:/bin/bash</code></pre><ol><li><strong>以root身份执行命令</strong> /usr/sbin/newusers，从刚创建的用户文件user.txt中导入数据，创建用户：</li></ol><pre><code class="highlight plaintext"># newusers &lt; user.txt</code></pre><ol><li><strong>执行命令</strong>/usr/sbin/pwunconv<br />将 /etc/shadow 产生的 shadow 密码解码，然后回写到 /etc/passwd 中，并将/etc/shadow的shadow密码栏删掉。这是为了方便下一步的密码转换工作，即先取消 shadow password 功能</li></ol><pre><code class="highlight plaintext"># pwunconv</code></pre><ol><li><strong>编辑每个用户的密码对照文件</strong></li></ol><pre><code class="highlight plaintext">user001:123456user002:123456user003:123456user004:123456user005:123456user006:123456</code></pre><ol><li>以root身份执行命令/usr/sbin/chpasswd<br />创建用户密码，chpasswd 会将经过 /usr/bin/passwd 命令编码过的密码写入 /etc/passwd 的密码栏</li></ol><pre><code class="highlight plaintext"># chpasswd &lt; passwd.txt</code></pre><ol><li>确定密码经编码写入/etc/passwd的密码栏后<br />执行命令 /usr/sbin/pwconv 将密码编码为 shadow password，并将结果写入 /etc/shadow。</li></ol><pre><code class="highlight plaintext"># pwconv</code></pre><blockquote><p>这样就完成了大量用户的创建了，之后您可以到/home下检查这些用户宿主目录的权限设置是否都正确，并登录验证用户密码是否正确。</p></blockquote><h2 id="管道符重定向环境变量"><a class="markdownIt-Anchor" href="#管道符重定向环境变量"></a> 管道符/重定向/环境变量</h2><p>既然我们已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><h3 id="输入输出重定向"><a class="markdownIt-Anchor" href="#输入输出重定向"></a> 输入输出重定向</h3><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。</p><p>相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及清空写入与追加写入两种模式</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>标准输入重定向（STDIN，文件描述符为0）</td><td>默认从键盘输入，也可从其他文件或命令中输入。</td></tr><tr><td>标准输出重定向（STDOUT，文件描述符为1）</td><td>默认输出到屏幕。</td></tr><tr><td>错误输出重定向（STDERR，文件描述符为2）</td><td>默认输出到屏幕。</td></tr></tbody></table><p>比如我们分别查看两个文件的属性信息，其中第二个文件是不存在的，虽然针对这两个文件的操作都分别会在屏幕上输出一些数据信息，但这两个操作的差异其实很大：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# touch linuxprobe[root@linuxprobe ~]# ls -l linuxprobe -rw-r--r--. 1 root root 0 Aug 5 05:35 linuxprobe[root@linuxprobe ~]# ls -l xxxxxxls: cannot access xxxxxx: No such file or directory</code></pre><p>在上述命令中，名为linuxprobe的文件是存在的，输出信息是该文件的一些相关权限、所有者、所属组、文件大小及修改时间等信息，这也是该命令的<strong>标准输出信息</strong>。</p><p>而名为xxxxxx的第二个文件是不存在的，因此在执行完ls命令之后显示的报错提示信息也是该命令的<strong>错误输出信息</strong>。</p><p>那么，要想把原本输出到屏幕上的数据转而写入到文件当中，就要区别对待这两种输出信息。</p><p><strong>输入重定向</strong>中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p><strong>输出重定向</strong>中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><blockquote><p><strong>对于重定向中的标准输出模式，可以省略文件描述符1不写，而错误输出模式的文件描述符2是必须要写的</strong>。</p></blockquote><p>通过标准输出重定向将man bash命令原本要输出到屏幕的信息写入到文件readme.txt中，然后显示readme.txt文件中的内容。具体命令如下：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# man bash &gt; readme.txt[root@linuxprobe ~]# cat readme.txt</code></pre><p><img src="image/-16.png" alt="-16.png" /></p><p>案例：</p><p>不同命令的标准输出和错误输出还是有区别的。例如查看当前目录中某个文件的信息，这里以linuxprobe文件为例。因为这个文件是真实存在的，<strong>因此使用标准输出即可将原本要输出到屏幕的信息写入到文件中，而错误的输出重定向则依然把信息输出到了屏幕上</strong>。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# ls -l linuxprobe -rw-r--r--. 1 root root 0 Mar  1 13:30 linuxprobe[root@linuxprobe ~]# ls -l linuxprobe &gt; /root/stderr.txt [root@linuxprobe ~]# ls -l linuxprobe 2&gt; /root/stderr.txt -rw-r--r--. 1 root root 0 Mar  1 13:30 linuxprobe</code></pre><p>如果想把命令的报错信息写入到文件，该怎么操作呢？当用户在执行一个自动化的Shell脚本时，这个操作会特别有用，而且特别实用，因为它可以把整个脚本执行过程中的报错信息都记录到文件中，便于安装后的排错工作。接下来我们以一个不存在的文件进行实验演示：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# ls -l xxxxxx cannot access xxxxxx: No such file or directory[root@linuxprobe ~]# ls -l xxxxxx &gt; /root/stderr.txtcannot access xxxxxx: No such file or directory[root@linuxprobe ~]# ls -l xxxxxx 2&gt; /root/stderr.txt[root@linuxprobe ~]# cat /root/stderr.txt ls: cannot access xxxxxx: No such file or directory</code></pre><p>输入重定向相对来说有些冷门，在工作中遇到的概率会小一点。输入重定向的作用是把文件直接导入到命令中。接下来使用输入重定向把readme.txt文件导入给wc -l命令，统计一下文件中的内容行数。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# wc -l &lt; readme.txt</code></pre><h3 id="管道命令符"><a class="markdownIt-Anchor" href="#管道命令符"></a> 管道命令符</h3><p>管道是Linux中的一种跨进程通信的机制，和重定向不同，管道用做进程与进程之间传送数据。做为Linux中默认的脚本语言，shell中也是可以使用管道的，在shell中，管道用|表示</p><p>格式：</p><pre><code class="highlight plaintext">命令A | 命令B | . . .</code></pre><p>（1）使用管道进行数据筛选内容中包含root的行</p><pre><code class="highlight plaintext">ls -l /|grep root</code></pre><p>这个例子中，ls命令输出的内容传给了grep命令进行筛选</p><p>（2）也可以同时用多个管道使用多个管道把数据筛选并统计</p><pre><code class="highlight plaintext">ls -l / | grep root | wc -l</code></pre><p>这个例子中，ls命令输出的内容传给了grep命令进行筛选，然后转给wc命令统计行数。</p><p>（3）用翻页的形式查看/etc目录中的文件列表及属性信息</p><pre><code class="highlight plaintext">ls -l /etc/ | more</code></pre><hr /><p>为了更好的理解管道，写两个脚本来体验一下：</p><p>in.sh文件</p><pre><code class="highlight plaintext">#! /bin/bashread msgecho &quot;Receive :$&#123;msg&#125;&quot;</code></pre><p>out.sh文件</p><pre><code class="highlight plaintext">#! /bin/bashecho &#x27;hello&#x27;</code></pre><p>执行：</p><pre><code class="highlight plaintext">./out.sh |./in.sh输出：Receive :hello</code></pre><blockquote><p>符合我们预期，<a href="http://xn--helloout-ue0mp4cm79e503f.xn--shin-rs5fy5a20ner8l.sh">字符串hello从out.sh传送到了in.sh</a></p></blockquote><h3 id="命令行的通配符"><a class="markdownIt-Anchor" href="#命令行的通配符"></a> 命令行的通配符</h3><p>在开始使用命令之前，我们需要介绍一个使命令行如此强大的 shell 特性。因为 shell 频繁地使用 文件名，shell 提供了特殊字符来帮助你快速指定一组文件名。这些特殊字符叫做通配符。 使用通配符（也以文件名代换著称）允许你依据字符类型来选择文件名。下表列出这些通配符 以及它们所选择的对象：</p><p><strong>通配符</strong></p><table><thead><tr><th>通配符</th><th>意义</th></tr></thead><tbody><tr><td>*</td><td>匹配任意多个字符（包括零个或一个）</td></tr><tr><td>？</td><td>匹配任意一个字符（不包括零个）</td></tr><tr><td>[characters]</td><td>匹配任意一个属于字符集中的字符</td></tr><tr><td>[!characters]</td><td>匹配任意一个不是字符集中的字符</td></tr><tr><td>[[:class:]]</td><td>匹配任意一个属于指定字符类中的字符</td></tr></tbody></table><p><strong>普遍使用的字符类</strong></p><table><thead><tr><th>字符类</th><th>意义</th></tr></thead><tbody><tr><td>[:alnum:]</td><td>匹配任意一个字母或数字</td></tr><tr><td>[:alpha:]</td><td>匹配任意一个字母</td></tr><tr><td>[:digit:]</td><td>匹配任意一个数字</td></tr><tr><td>[:lower:]</td><td>匹配任意一个小写字母</td></tr><tr><td>[:upper]</td><td>匹配任意一个大写字母</td></tr></tbody></table><p><strong>案例：</strong></p><table><thead><tr><th>模式</th><th>匹配对象</th></tr></thead><tbody><tr><td>*</td><td>所有文件</td></tr><tr><td>g*</td><td>文件名以“g”开头的文件</td></tr><tr><td>b*.txt</td><td>以&quot;b&quot;开头，中间有零个或任意多个字符，并以&quot;.txt&quot;结尾的文件</td></tr><tr><td>Data???</td><td>以“Data”开头，其后紧接着3个字符的文件</td></tr><tr><td>[abc]*</td><td>文件名以&quot;a&quot;,“b”,或&quot;c&quot;开头的文件</td></tr><tr><td>BACKUP.[0-9][0-9][0-9]</td><td>以&quot;BACKUP.&quot;开头，并紧接着3个数字的文件</td></tr><tr><td>[[:upper:]]*</td><td>以大写字母开头的文件</td></tr><tr><td>[![:digit:]]*</td><td>不以数字开头的文件</td></tr><tr><td><code>*[[:lower:]123]</code></td><td>文件名以小写字母结尾，或以 “1”，“2”，或 “3” 结尾的文件</td></tr></tbody></table><blockquote><p>接受文件名作为参数的任何命令，都可以使用通配符</p></blockquote><h3 id="常用的转义字符"><a class="markdownIt-Anchor" href="#常用的转义字符"></a> 常用的转义字符</h3><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>反斜杠（\）</td><td>使反斜杠后面的一个字符变为单纯的字符。</td></tr><tr><td>单引号（‘’）</td><td>单引号里的任何字符都会原样输出，单引号中的变量是无效的，单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</td></tr><tr><td>双引号（“”）</td><td>双引号中可以有变量，双引号中可以出现转义字符</td></tr><tr><td><code>反引号（``）</code></td><td>把其中的命令执行后返回结果。</td></tr></tbody></table><p>我们先定义一个名为PRICE的变量并赋值为5，然后输出以双引号括起来的字符串与变量信息：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# PRICE=5[root@linuxprobe ~]# echo &quot;Price is $PRICE&quot;Price is 5[root@linuxprobe ~]# echo &#x27;Price is $PRICE&#x27;Price is $PRICE</code></pre><p>要想让第一个“$”乖乖地作为美元符号，那么就需要使用反斜杠（\）来进行转义，将这个命令提取符转义成单纯的文本，去除其特殊功能。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# echo &quot;Price is $$PRICE&quot;Price is 3767PRICE[root@linuxprobe ~]# echo &quot;Price is \$$PRICE&quot;Price is $5</code></pre><p>如果只需要某个命令的输出值时，可以像命令这样，将命令用反引号括起来，达到预期的效果。例如，将反引号与uname -a命令结合，然后使用echo命令来查看本机的Linux版本和内核信息：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# echo `uname -a`Linux linuxprobe.com 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2017 x86_64 x86_64 x86_64 GNU/Linux</code></pre><h3 id="重要的环境变量"><a class="markdownIt-Anchor" href="#重要的环境变量"></a> 重要的环境变量</h3><p>变量是计算机系统用于保存可变值的数据类型。在Linux系统中，变量名称一般都是大写的，这是一种约定俗成的规范。我们可以直接通过变量名称来提取到对应的变量值。Linux系统中的环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录、邮件存放位置等。</p><p>为了通过环境变量帮助Linux系统构建起能够为用户提供服务的工作运行环境，需要数百个变量协同工作才能完成。</p><p>前文中曾经讲到，在Linux系统中一切都是文件，Linux命令也不例外。那么，在用户执行了一条命令之后，Linux系统中到底发生了什么事情呢？简单来说，命令在Linux中的执行分为4个步骤。</p><ul><li><strong>第1步</strong>：判断用户是否以绝对路径或相对路径的方式输入命令（如/bin/ls），如果是的话则直接执行。</li><li><strong>第2步</strong>：Linux系统检查用户输入的命令是否为“别名命令”，即用一个自定义的命令名称来替换原本的命令名称。可以<strong>用alias命令来创建一个属于自己的命令别名</strong>，格式为“<strong>alias 别名=命令</strong>”。若要取消一个命令别名，则是用unalias命令，格式为“<strong>unalias 别名</strong>”。我们之前在使用rm命令删除文件时，Linux系统都会要求我们再确认是否执行删除操作，其实这就是Linux系统为了防止用户误删除文件而特意设置的rm别名命令，接下来我们把它取消掉：</li></ul><pre><code class="highlight plaintext">[root@linuxprobe ~]# lsanaconda-ks.cfg Documents initial-setup-ks.cfg Pictures TemplatesDesktop Downloads Music Public Videos[root@linuxprobe ~]# rm anaconda-ks.cfg rm: remove regular file ‘anaconda-ks.cfg’? y[root@linuxprobe~]# alias rmalias rm=&#x27;rm -i&#x27;[root@linuxprobe ~]# unalias rm[root@linuxprobe ~]# rm initial-setup-ks.cfg [root@linuxprobe ~]#</code></pre><ul><li><strong>第3步</strong>：Bash解释器判断用户输入的是内部命令还是外部命令。内部命令是解释器内部的指令，会被直接执行；而用户在绝大部分时间输入的是外部命令，这些命令交由步骤4继续处理。可以使用“<strong>type命令名称</strong>”来判断用户输入的命令是内部命令还是外部命令。</li><li><strong>第4步</strong>：系统在多个路径中查找用户输入的命令文件，而定义这些路径的变量叫作PATH，可以简单地把它理解成是“解释器的小助手”，作用是告诉Bash解释器待执行的命令可能存放的位置，然后Bash解释器就会乖乖地在这些位置中逐个查找。PATH是由多个路径值组成的变量，每个路径值之间用<strong>冒号</strong>间隔，对这些路径的增加和删除操作将影响到Bash解释器对Linux命令的查找。</li></ul><pre><code class="highlight plaintext">[root@linuxprobe ~]# echo $PATH/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin[root@linuxprobe ~]# PATH=$PATH:/root/bin[root@linuxprobe ~]# echo $PATH/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/root/bin</code></pre><p>我们可以<strong>使用env命令</strong>来查看到Linux系统中<strong>所有的环境变量</strong>，而最重要的10个环境变量，如表所示：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><p>Linux作为一个多用户多任务的操作系统，能够为每个用户提供独立的、合适的工作运行环境，因此，<strong>一个相同的变量会因为用户身份的不同而具有不同的值</strong>。例如，我们使用下述命令来查看HOME变量在不同用户身份下都有哪些值</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# echo $HOME/root[root@linuxprobe ~]# su - linuxprobeLast login: Fri Feb 27 19:49:57 CST 2017 on pts/0[linuxprobe@linuxprobe ~]$ echo $HOME/home/linuxprobe</code></pre><p>其实变量是由固定的变量名与用户或系统设置的变量值两部分组成的，我们完全可以自行创建变量，来满足工作需求。例如设置一个名称为WORKDIR的变量，方便用户更轻松地进入一个层次较深的目录：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# mkdir /home/workdir[root@linuxprobe ~]# WORKDIR=/home/workdir[root@linuxprobe ~]# cd $WORKDIR [root@linuxprobe workdir]# pwd/home/workdir</code></pre><p>但是，这样的变量不具有全局性，作用范围也有限，默认情况下不能被其他用户使用。如果工作需要，<strong>可以使用export命令将其提升为全局变量</strong>，这样其他用户也就可以使用它了：</p><pre><code class="highlight plaintext">[root@linuxprobe workdir]# su linuxprobeLast login: Fri Mar 20 20:52:10 CST 2017 on pts/0[linuxprobe@linuxprobe ~]$ cd $WORKDIR[linuxprobe@linuxprobe ~]$ echo $WORKDIR[linuxprobe@linuxprobe ~]$ exit[root@linuxprobe ~]# export WORKDIR[root@linuxprobe ~]# su linuxprobeLast login: Fri Mar 20 21:52:10 CST 2017 on pts/0[linuxprobe@linuxprobe ~]$ cd $WORKDIR[linuxprobe@linuxprobe workdir]$ pwd/home/workdir</code></pre><h2 id="存储结构磁盘划分"><a class="markdownIt-Anchor" href="#存储结构磁盘划分"></a> 存储结构/磁盘划分</h2><table><thead><tr><th>目录名称</th><th>应放置文件的内容</th></tr></thead><tbody><tr><td>/boot</td><td>开机所需文件—内核、开机菜单以及所需配置文件等</td></tr><tr><td>/dev</td><td>以文件形式存放任何设备与接口</td></tr><tr><td>/etc</td><td>配置文件</td></tr><tr><td>/home</td><td>用户主目录</td></tr><tr><td>/bin</td><td>存放单用户模式下还可以操作的命令</td></tr><tr><td>/lib</td><td>开机时用到的函数库，以及/bin与/sbin下面的命令要调用的函数</td></tr><tr><td>/sbin</td><td>开机过程中需要的命令</td></tr><tr><td>/media</td><td>用于挂载设备文件的目录</td></tr><tr><td>/opt</td><td>放置第三方的软件</td></tr><tr><td>/root</td><td>系统管理员的家目录</td></tr><tr><td>/srv</td><td>一些网络服务的数据文件目录</td></tr><tr><td>/tmp</td><td>任何人均可使用的“共享”临时目录</td></tr><tr><td>/proc</td><td>虚拟文件系统，例如系统内核、进程、外部设备及网络状态等</td></tr><tr><td>/usr/local</td><td>用户自行安装的软件</td></tr><tr><td>/usr/sbin</td><td>Linux系统开机时不会使用到的软件/命令/脚本</td></tr><tr><td>/usr/share</td><td>帮助与说明文件，也可放置共享文件</td></tr><tr><td>/var</td><td>主要存放经常变化的文件，如日志</td></tr><tr><td>/lost+found</td><td>当文件系统发生错误时，将一些丢失的文件片段存放在这里</td></tr></tbody></table><h3 id="物理设备的命名规则"><a class="markdownIt-Anchor" href="#物理设备的命名规则"></a> 物理设备的命名规则</h3><p>在Linux系统中一切都是文件，硬件设备也不例外。既然是文件，就必须有文件名称。系统内核中的udev设备管理器会自动把硬件名称规范起来，目的是让用户通过设备文件的名字可以猜出设备大致的属性以及分区信息等；这对于陌生的设备来说特别方便。另外，udev设备管理器的服务会一直以守护进程的形式运行并侦听内核发出的信号来管理/dev目录下的设备文件。</p><p>Linux系统中常见的硬件设备的文件名称如表所示</p><table><thead><tr><th>硬件设备</th><th>文件名称</th></tr></thead><tbody><tr><td>IDE设备</td><td>/dev/hd[a-d]</td></tr><tr><td>SCSI/SATA/U盘</td><td>/dev/sd[a-p]</td></tr><tr><td>软驱</td><td>/dev/fd[0-1]</td></tr><tr><td>打印机</td><td>/dev/lp[0-15]</td></tr><tr><td>光驱</td><td>/dev/cdrom</td></tr><tr><td>鼠标</td><td>/dev/mouse</td></tr><tr><td>磁带机</td><td>/dev/st0或/dev/ht0</td></tr></tbody></table><p>由于现在的IDE设备已经很少见了，所以一般的硬盘设备都会是以“/dev/sd”开头的。而一台主机上可以有多块硬盘，因此系统采用a～p来代表16块不同的硬盘（默认从a开始分配），而且硬盘的分区编号也很有讲究：</p><ul><li>主分区或扩展分区的编号从1开始，到4结束；</li><li>逻辑分区从编号5开始。</li></ul><p><img src="image/-17.png" alt="-17.png" /></p><p>首先，/dev/目录中保存的应当是硬件设备文件；其次，sd表示是存储设备；然后，a表示系统中同类接口中第一个被识别到的设备，最后，5表示这个设备是一个逻辑分区。一言以蔽之，“/dev/sda5”表示的就是“<strong>这是系统中第一块被识别到的硬件设备中分区编号为5的逻辑分区的设备文件</strong>”</p><h3 id="挂载硬件设备"><a class="markdownIt-Anchor" href="#挂载硬件设备"></a> 挂载硬件设备</h3><h4 id="mount"><a class="markdownIt-Anchor" href="#mount"></a> mount</h4><p>我们在用惯了Windows系统后总觉得一切都是理所当然的，平时把U盘插入到电脑后也从来没有考虑过Windows系统做了哪些事情，才使得我们可以访问这个U盘的。接下来我们会逐一学习在Linux系统中挂载和卸载存储设备的方法，以便大家更好地了解Linux系统添加硬件设备的工作原理和流程。前面讲到，在拿到一块全新的硬盘存储设备后要先分区，然后格式化，最后才能挂载并正常使用。“分区”和“格式化”大家以前经常听到，但“挂载”又是什么呢？刘遄老师在这里给您一个最简单、最贴切的解释—<strong>当用户需要使用硬盘设备或分区中的数据时，需要先将其与一个已存在的目录文件进行关联，而这个关联动作就是“挂载”</strong>。</p><p><strong>mount命令</strong>用于挂载文件系统，格式为</p><pre><code class="highlight plaintext">mount 文件系统 挂载目录</code></pre><p>挂载是在使用硬件设备前所执行的最后一步操作。只需使用mount命令把硬盘设备或分区与一个目录文件进行关联，然后就能在这个目录中看到硬件设备中的数据了。对于比较新的Linux系统来讲，一般不需要使用-t参数来指定文件系统的类型，Linux系统会自动进行判断。而mount 中的-a参数则厉害了，它会在执行后自动检查/etc/fstab文件中有无疏漏被挂载的设备文件，如果有，则进行自动挂载操作。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>挂载所有在/etc/fstab中定义的文件系统</td></tr><tr><td>-t</td><td>指定文件系统的类型</td></tr></tbody></table><p>例如，要把设备/dev/sdb2挂载到/backup目录，只需要在mount命令中填写设备与挂载目录参数就行，系统会自动去判断要挂载文件的类型，因此只需要执行下述命令即可：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# mount /dev/sdb2 /backup</code></pre><hr /><p>虽然按照上面的方法执行mount命令后就能立即使用文件系统了，但系统在<strong>重启后挂载就会失效</strong>，也就是说我们需要每次开机后都手动挂载一下。这肯定不是我们想要的效果，如果想<strong>让硬件设备和目录永久地进行自动关联</strong>，就必须把挂载信息按照指定的填写格式“设备文件 挂载目录 格式类型 权限选项 是否备份 是否自检”写入<strong>到/etc/fstab文件中</strong></p><table><thead><tr><th>字段</th><th>意义</th></tr></thead><tbody><tr><td>设备文件</td><td>一般为设备的路径+设备名称，也可以写唯一识别码（UUID，Universally Unique Identifier）</td></tr><tr><td>挂载目录</td><td>指定要挂载到的目录，需在挂载前创建好</td></tr><tr><td>格式类型</td><td>指定文件系统的格式，比如Ext3、Ext4、XFS、SWAP、iso9660（此为光盘设备）等</td></tr><tr><td>权限选项</td><td>若设置为defaults，则默认权限为：rw, suid, dev, exec, auto, nouser, async</td></tr><tr><td>是否备份</td><td>若为1则开机后使用dump进行磁盘备份，为0则不备份</td></tr><tr><td>是否自检</td><td>若为1则开机后自动进行磁盘自检，为0则不自检</td></tr></tbody></table><p>如果想将文件系统为ext4的硬件设备/dev/sdb2在开机后自动挂载到/backup目录上，并保持默认权限且无需开机自检，就需要在/etc/fstab文件中写入下面的信息，这样在系统重启后也会成功挂载。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# vim /etc/fstab## /etc/fstab# Created by anaconda on Wed May 4 19:26:23 2017## Accessible filesystems, by reference, are maintained under &#x27;/dev/disk&#x27;# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info#/dev/mapper/rhel-root / xfs defaults 1 1UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b /boot xfs defaults 1 2/dev/mapper/rhel-swap swap swap defaults 0 0/dev/cdrom /media/cdrom iso9660 defaults 0 0 /dev/sdb2 /backup ext4 defaults 0 0</code></pre><hr /><h4 id="umount"><a class="markdownIt-Anchor" href="#umount"></a> umount</h4><p><strong>umount命令用于撤销已经挂载的设备文件</strong>，格式为</p><pre><code class="highlight plaintext">umount [挂载点/设备文件]</code></pre><p>我们挂载文件系统的目的是为了使用硬件资源，而卸载文件系统就意味不再使用硬件的设备资源；相对应地，挂载操作就是把硬件设备与目录进行关联的动作，因此卸载操作只需要说明想要取消关联的设备文件或挂载目录的其中一项即可，一般不需要加其他额外的参数。我们来尝试手动卸载掉/dev/sdb2设备文件：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# umount /dev/sdb2</code></pre><h3 id="添加硬盘设备"><a class="markdownIt-Anchor" href="#添加硬盘设备"></a> 添加硬盘设备</h3><ul><li>在虚拟机添加一个硬盘</li></ul><p><img src="image/-18.png" alt="-18.png" /></p><p>在虚拟机中模拟添加了硬盘设备后就应该能看到抽象成的硬盘设备文件了。按照前文讲解的udev服务命名规则，第二个被识别的SCSI设备应该会被保存为/dev/sdb，这个就是硬盘设备文件了。但在开始使用该硬盘之前还需要进行分区操作，例如从中取出一个2GB的分区设备以供后面的操作使用。</p><h4 id="fdisk命令分区"><a class="markdownIt-Anchor" href="#fdisk命令分区"></a> fdisk命令（分区）</h4><p>在Linux系统中，管理硬盘设备最常用的方法就当属fdisk命令了。fdisk命令用于管理磁盘分区，格式为</p><pre><code class="highlight plaintext">fdisk [磁盘名称]</code></pre><p>它提供了集添加、删除、转换分区等功能于一身的“一站式分区服务”。不过与前面讲解的直接写到命令后面的参数不同，这条命令的参数是交互式的，因此在管理硬盘设备时特别方便，可以根据需求动态调整。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>m</td><td>查看全部可用的参数</td></tr><tr><td>n</td><td>添加新的分区</td></tr><tr><td>d</td><td>删除某个分区信息</td></tr><tr><td>l</td><td>列出所有可用的分区类型</td></tr><tr><td>t</td><td>改变某个分区的类型</td></tr><tr><td>p</td><td>查看分区表信息</td></tr><tr><td>w</td><td>保存并退出</td></tr><tr><td>q</td><td>不保存直接退出</td></tr></tbody></table><ul><li>第1步：我们首先使用fdisk命令来尝试管理/dev/sdb硬盘设备<br /><img src="image/-19.png" alt="-19.png" /></li><li>第2步：输入参数n尝试添加新的分区。系统会要求您是选择继续输入参数p来创建主分区，还是输入参数e来创建扩展分区。这里输入参数p来创建一个主分区：<br /><img src="image/-20.png" alt="-20.png" /></li><li>第3步：在确认创建一个主分区后，系统要求您先输入主分区的编号。我们在前文得知，主分区的编号范围是1～4，因此这里输入默认的1就可以了。接下来系统会提示定义起始的扇区位置，这不需要改动，我们敲击回车键保留默认设置即可，系统会自动计算出最靠前的空闲扇区的位置。最后，系统会要求定义分区的结束扇区位置，这其实就是要去定义整个分区的大小是多少。我们不用去计算扇区的个数，只需要输入+2G即可创建出一个容量为2GB的硬盘分区。<br /><img src="image/-21.png" alt="-21.png" /></li><li>第4步：再次使用参数p来查看硬盘设备中的分区信息。果然就能看到一个名称为/dev/sdb1、起始扇区位置为2048、结束扇区位置为4196351的主分区了。这时候千万不要直接关闭窗口，而应该敲击参数w后回车，这样分区信息才是真正的写入成功啦。<br /><img src="image/-22.png" alt="-22.png" /></li><li>第5步：在上述步骤执行完毕之后，Linux系统会自动把这个硬盘主分区抽象成/dev/sdb1设备文件。我们可以使用file命令查看该文件的属性，但是刘遄老师在讲课和工作中发现，有些时候系统并没有自动把分区信息同步给Linux内核，而且这种情况似乎还比较常见（但不能算作是严重的bug）。我们可以输入partprobe命令手动将分区信息同步到内核，而且一般推荐连续两次执行该命令，效果会更好。如果使用这个命令都无法解决问题，那么就重启计算机吧，这个杀手锏百试百灵，一定会有用的。<br /><img src="image/-23.png" alt="-23.png" /></li></ul><h4 id="mkfs格式化"><a class="markdownIt-Anchor" href="#mkfs格式化"></a> mkfs（格式化）</h4><p>如果硬件存储设备没有进行格式化，则Linux系统无法得知怎么在其上写入数据。因此，在对存储设备进行分区后还需要进行格式化操作。在Linux系统中用于格式化操作的命令是mkfs。这条命令很有意思，因为在Shell终端中输入mkfs名后再敲击两下用于补齐命令的Tab键，会有如下所示的效果：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# mkfsmkfs mkfs.cramfs mkfs.ext3 mkfs.fat mkfs.msdos mkfs.xfsmkfs.btrfs mkfs.ext2 mkfs.ext4 mkfs.minix mkfs.vfat</code></pre><p>对！这个mkfs命令很贴心地把常用的文件系统名称用后缀的方式保存成了多个命令文件，用起来也非常简单—mkfs.文件类型名称。例如要格式分区为XFS的文件系统，则命令应为mkfs.xfs /dev/sdb1。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# mkfs.xfs /dev/sdb1meta-data=/dev/sdb1 isize=256 agcount=4, agsize=131072 blks = sectsz=512 attr=2, projid32bit=1 = crc=0data = bsize=4096 blocks=524288, imaxpct=25 = sunit=0 swidth=0 blksnaming =version 2 bsize=4096 ascii-ci=0 ftype=0log =internal log bsize=4096 blocks=2560, version=2 = sectsz=512 sunit=0 blks, lazy-count=1realtime =none extsz=4096 blocks=0, rtextents=0</code></pre><p>终于完成了存储设备的分区和格式化操作，接下来就是要来挂载并使用存储设备了。与之相关的步骤也非常简单：首先是创建一个用于挂载设备的挂载点目录；然后使用mount命令将存储设备与挂载点进行关联；最后使用df -h命令来查看挂载状态和硬盘使用量信息。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# mkdir /newFS[root@linuxprobe ~]# mount /dev/sdb1 /newFS/[root@linuxprobe ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/mapper/rhel-root 18G 3.5G 15G 20% /devtmpfs 905M 0 905M 0% /devtmpfs 914M 140K 914M 1% /dev/shmtmpfs 914M 8.8M 905M 1% /runtmpfs 914M 0 914M 0% /sys/fs/cgroup/dev/sr0 3.5G 3.5G 0 100% /media/cdrom/dev/sda1 497M 119M 379M 24% /boot/dev/sdb1 2.0G 33M 2.0G 2% /newFS</code></pre><h4 id="du查看文件数据占用量"><a class="markdownIt-Anchor" href="#du查看文件数据占用量"></a> du（查看文件数据占用量）</h4><p>既然存储设备已经顺利挂载，接下来就可以尝试通过挂载点目录向存储设备中写入文件了。在写入文件之前，先介绍一个用于查看文件数据占用量的du命令，其格式为</p><pre><code class="highlight plaintext">du [选项] [文件]</code></pre><p>简单来说，该命令就是用来查看一个或多个文件占用了多大的硬盘空间。我们还可以使用</p><pre><code class="highlight plaintext">du -sh /*</code></pre><p>命令来查看在Linux系统根目录下所有一级目录分别占用的空间大小。下面，我们先从某些目录中复制过来一批文件，然后查看这些文件总共占用了多大的容量：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# cp -rf /etc/* /newFS/[root@linuxprobe ~]# ls /newFS/abrt hosts pulseadjtime hosts.allow purplealiases hosts.deny qemu-gaaliases.db hp qemu-kvmalsa idmapd.conf radvd.confalternatives init.d rc0.danacrontab inittab rc1.d………………省略部分输入信息………………[root@linuxprobe ~]# du -sh /newFS/33M /newFS/</code></pre><blockquote><p>细心的读者一定还记得，前面在讲解mount命令时提到，使用mount命令挂载的设备文件会在系统下一次重启的时候失效。如果想让这个设备文件的挂载永久有效，则需要把挂载的信息写入到配置文件/etc/fstab中</p></blockquote><h3 id="添加交换分区"><a class="markdownIt-Anchor" href="#添加交换分区"></a> 添加交换分区</h3><p>SWAP（交换）分区是一种通过在硬盘中预先划分一定的空间，然后将把内存中暂时不常用的数据临时存放到硬盘中，以便腾出物理内存空间让更活跃的程序服务来使用的技术，其设计目的是为了解决真实物理内存不足的问题。但由于交换分区毕竟是通过硬盘设备读写数据的，速度肯定要比物理内存慢，所以只有当真实的物理内存耗尽后才会调用交换分区的资源。</p><p>交换分区的创建过程与前文讲到的挂载并使用存储设备的过程非常相似。在对/dev/sdb存储设备进行分区操作前，有必要先说一下交换分区的划分建议：在生产环境中，交换分区的大小一般为真实物理内存的1.5～2倍，为了让大家更明显地感受交换分区空间的变化，这里取出一个大小为5GB的主分区作为交换分区资源。在分区创建完毕后保存并退出即可：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# fdisk /dev/sdbWelcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Device does not contain a recognized partition tableBuilding a new DOS disklabel with disk identifier 0xb3d27ce1.Command (m for help): nPartition type:p primary (1 primary, 0 extended, 3 free)e extendedSelect (default p): pPartition number (2-4, default 2): First sector (4196352-41943039, default 4196352): 此处敲击回车Using default value 4196352Last sector, +sectors or +size&#123;K,M,G&#125; (4196352-41943039, default 41943039): +5GPartition 2 of type Linux and of size 5 GiB is setCommand (m for help): pDisk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0xb0ced57f Device Boot Start End Blocks Id System/dev/sdb1 2048 4196351 2097152 83 Linux/dev/sdb2 4196352 14682111 5242880 83 LinuxCommand (m for help): wThe partition table has been altered!Calling ioctl() to re-read partition table.WARNING: Re-reading the partition table failed with error 16: Device or resource busy.The kernel still uses the old table. The new table will be used atthe next reboot or after you run partprobe(8) or kpartx(8)Syncing disks.</code></pre><p>使用SWAP分区专用的格式化命令<strong>mkswap</strong>，对新建的主分区进行格式化操作：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# mkswap /dev/sdb2Setting up swapspace version 1, size = 5242876 KiBno label, UUID=2972f9cb-17f0-4113-84c6-c64b97c40c75</code></pre><p><strong>使用swapon命令把准备好的SWAP分区设备正式挂载到系统中</strong>。我们可以使用free -m命令查看交换分区的大小变化（由2047MB增加到7167MB）：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# free -mtotal used free shared buffers cachedMem: 1483 782 701 9 0 254-/+ buffers/cache: 526 957Swap: 2047 0 2047[root@linuxprobe ~]# swapon /dev/sdb2[root@linuxprobe ~]# free -mtotal used free shared buffers cachedMem: 1483 785 697 9 0 254-/+ buffers/cache: 530 953Swap: 7167 0 7167</code></pre><p>为了能够让新的交换分区设备在重启后依然生效，需要按照下面的格式将相关信息写入到配置文件中，并记得保存：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# vim /etc/fstab## /etc/fstab# Created by anaconda on Wed May 4 19:26:23 2017## Accessible filesystems, by reference, are maintained under &#x27;/dev/disk&#x27;# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info#/dev/mapper/rhel-root / xfs defaults 1 1UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b /boot xfs defaults 1 2/dev/mapper/rhel-swap swap swap defaults 0 0/dev/cdrom /media/cdrom iso9660 defaults 0 0 /dev/sdb1 /newFS xfs defaults 0 0 /dev/sdb2 swap swap defaults 0 0</code></pre><h2 id="vivim"><a class="markdownIt-Anchor" href="#vivim"></a> vi/vim</h2><p>Vim之所以能得到广大厂商与用户的认可，原因在于Vim编辑器中设置了三种模式—命令模式、末行模式和编辑模式，每种模式分别又支持多种不同的命令快捷键，这大大提高了工作效率，而且用户在习惯之后也会觉得相当顺手。要想高效率地操作文本，就必须先搞清这三种模式的操作区别以及模式之间的切换方法</p><ul><li><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</li><li><strong>输入模式</strong>：正常的文本录入。</li><li><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</li></ul><p><img src="image/-24.png" alt="-24.png" /></p><p>在每次运行Vim编辑器时，<strong>默认进入命令模式</strong>，此时需要先切换到输入模式后再进行文档编写工作，而每次在<strong>编写完文档后需要先返回命令模式，然后再进入末行模式，执行文档的保存或退出操作</strong>。</p><p><strong>命令模式</strong>中最常用的一些命令</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>dd</td><td>删除（剪切）光标所在整行</td></tr><tr><td>5dd</td><td>删除（剪切）从光标处开始的5行</td></tr><tr><td>yy</td><td>复制光标所在整行</td></tr><tr><td>5yy</td><td>复制从光标处开始的5行</td></tr><tr><td>n</td><td><strong>显示搜索命令定位到的下一个字符串</strong></td></tr><tr><td>N</td><td>显示搜索命令定位到的上一个字符串</td></tr><tr><td>u</td><td>撤销上一步的操作</td></tr><tr><td>p</td><td>将之前删除（dd）或复制（yy）过的数据粘贴到光标后面</td></tr><tr><td>i</td><td><strong>进入输入模式</strong></td></tr></tbody></table><p><strong>末行模式</strong>主要用于保存或退出文件，以及设置Vim编辑器的工作环境，还可以让用户执行外部的Linux命令或跳转到所编写文档的特定行数。要想切换到末行模式，在命令模式中输入一个冒号就可以了</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>:w</td><td>保存</td></tr><tr><td>:q</td><td>退出</td></tr><tr><td>:q!</td><td>强制退出（放弃对文档的修改内容）</td></tr><tr><td>:wq!</td><td>强制保存退出</td></tr><tr><td>:e!</td><td>放弃更改</td></tr><tr><td>:set nu</td><td>显示行号</td></tr><tr><td>:set nonu</td><td>不显示行号</td></tr><tr><td>:命令</td><td>执行该命令</td></tr><tr><td>:整数</td><td>跳转到该行</td></tr><tr><td>😒/one/two</td><td>将当前光标所在行的第一个one替换成two</td></tr><tr><td>😒/one/two/g</td><td>将当前光标所在行的所有one替换成two</td></tr><tr><td>:%s/one/two/g</td><td>将全文中的所有one替换成two</td></tr><tr><td>?字符串</td><td>在文本中从下至上搜索该字符串,按Enter后用n向下搜索</td></tr><tr><td>/字符串</td><td><strong>在文本中从上至下搜索该字符串，按Enter后用n向下搜索</strong></td></tr></tbody></table><h2 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h2><p>通常，现在的操作系统都支持多任务，意味着操作系统（给用户）造成了一种假象，(让用户觉得) 它同时能够做多件事情，事实上，它是快速地轮换执行这些任务的。Linux 内核通过使用进程，来 管理多任务。通过进程，Linux 安排不同的程序等待使用 CPU。</p><p>有时候，计算机变得呆滞，运行缓慢，或者一个应用程序停止响应。在这一章中，我们将看一些 可用的命令行工具，这些工具帮助我们查看程序的执行状态，以及怎样终止行为不当的进程。</p><p><strong>进程是怎样工作的</strong></p><ul><li>当系统启动的时候，内核先把一些它自己的程序初始化为进程，然后运行一个叫做 init 的程序。init， 依次地，再运行一系列的称为 init 脚本的 shell 脚本（位于/etc），它们可以启动所有的系统服务。 其中许多系统服务以守护（daemon）程序的形式实现，守护程序仅在后台运行，没有任何用户接口。 这样，即使我们没有登录系统，至少系统也在忙于执行一些例行事务。</li><li>一个程序可以发动另一个程序，这个事实在进程方案中，表述为一个父进程创建了一个子进程。</li><li>内核维护每个进程的信息，以此来保持事情有序。例如，系统分配给每个进程一个数字，这个数字叫做 进程 ID 或 PID。PID 号按升序分配，init 进程的 PID 总是1。内核也对分配给每个进程的内存进行跟踪。 像文件一样，进程也有所有者和用户 ID，有效用户 ID，等等。</li></ul><h3 id="ps-查看进程"><a class="markdownIt-Anchor" href="#ps-查看进程"></a> ps 查看进程</h3><p>ps命令用于<strong>查看系统中的进程状态</strong>，格式为</p><pre><code class="highlight plaintext">ps [参数]</code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中，有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该 状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><p>当执行ps aux命令后通常会看到如表所示的进程状态，表中只是列举了部分输出值，而且正常的输出值中不包括中文注释。</p><table><thead><tr><th>USER</th><th>PID</th><th>%CPU</th><th>%MEM</th><th>VSZ</th><th>RSS</th><th>TTY</th><th>STAT</th><th>START</th><th>TIME</th><th>COMMAND</th></tr></thead><tbody><tr><td>进程的所有者</td><td>进程ID号</td><td>运算器占用率</td><td>内存占用率</td><td>虚拟内存使用量(单位是KB)</td><td>占用的固定内存量(单位是KB)</td><td>所在终端</td><td>进程状态</td><td>被启动的时间</td><td>实际使用CPU的时间</td><td>命令名称与参数</td></tr><tr><td>root</td><td>1</td><td>0.0</td><td>0.4</td><td>53684</td><td>7628</td><td>?</td><td>Ss</td><td>07:22</td><td>0:02</td><td>/usr/lib/systemd/systemd</td></tr><tr><td>root</td><td>2</td><td>0.0</td><td>0.0</td><td>0</td><td>0</td><td>?</td><td>S</td><td>07:22</td><td>0:00</td><td>[kthreadd]</td></tr><tr><td>root</td><td>3</td><td>0.0</td><td>0.0</td><td>0</td><td>0</td><td>?</td><td>S</td><td>07:22</td><td>0:00</td><td>[ksoftirqd/0]</td></tr><tr><td>root</td><td>5</td><td>0.0</td><td>0.0</td><td>0</td><td>0</td><td>?</td><td>S&lt;</td><td>07:22</td><td>0:00</td><td>[kworker/0:0H]</td></tr><tr><td>root</td><td>7</td><td>0.0</td><td>0.0</td><td>0</td><td>0</td><td>?</td><td>S</td><td>07:22</td><td>0:00</td><td>[migration/0]</td></tr></tbody></table><blockquote><p>如前面所提到的，在Linux系统中的命令参数有长短格式之分，<strong>长格式和长格式之间不能合并</strong>，<strong>长格式和短格式之间也不能合并</strong>，但<strong>短格式和短格式之间是可以合并</strong>的，<strong>合并后仅保留一个-（减号）即可</strong>。另外ps命令可<strong>允许参数不加减号（-）</strong>，因此可直接写成ps aux的样子</p></blockquote><table><thead><tr><th>状态</th><th>意义</th></tr></thead><tbody><tr><td>R</td><td>运行。这意味着，进程正在运行或准备运行。</td></tr><tr><td>S</td><td>正在睡眠。 进程没有运行，而是，正在等待一个事件， 比如说，一个按键或者网络数据包。</td></tr><tr><td>D</td><td>不可中断睡眠。进程正在等待 I/O，比方说，一个磁盘驱动器的 I/O。</td></tr><tr><td>T</td><td>已停止. 已经指示进程停止运行。稍后介绍更多。</td></tr><tr><td>Z</td><td>一个死进程或“僵尸”进程。这是一个已经终止的子进程，但是它的父进程还没有清空它。 （父进程没有把子进程从进程表中删除）</td></tr><tr><td>&lt;</td><td>一个高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。 进程的这种属性叫做 niceness。具有高优先级的进程据说是不好的（less nice）， 因为它占用了比较多的 CPU 时间，这样就给其它进程留下很少时间。</td></tr><tr><td>N</td><td>低优先级进程。 一个低优先级进程（一个“好”进程）只有当其它高优先级进程执行之后，才会得到处理器时间。</td></tr></tbody></table><h3 id="top-显示任务"><a class="markdownIt-Anchor" href="#top-显示任务"></a> top 显示任务</h3><p>top命令用于<strong>动态地监视进程活动与系统负载等信息</strong>，其格式为</p><pre><code class="highlight plaintext">top</code></pre><ul><li>M：可以给进程占用内存大小排序</li><li>h：显示程序的帮助屏幕</li><li>q：退出top程序</li><li>x：高亮排序列</li><li>shift+&lt;或者&gt;：切换排序列</li><li>i：排除僵死和睡眠的进程</li></ul><p>top命令相当强大，能够动态地查看系统运维状态，完全将它看作Linux中的“强化版的Windows任务管理器”。top命令的运行界面如图所示</p><p><img src="image/-25.png" alt="-25.png" /></p><p>top命令执行结果的前5行为系统整体的统计信息，其所代表的含义如下</p><blockquote><p>第1行：系统时间、运行时间、登录终端数、系统负载（三个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低）。</p></blockquote><blockquote><p>第2行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。</p></blockquote><blockquote><p>第3行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。其中数据均为CPU数据并以百分比格式显示，例如“97.1 id”意味着有97.1%的CPU处理器资源处于空闲。</p></blockquote><blockquote><p>第4行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。</p></blockquote><blockquote><p>第5行：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、已被提前加载的内存量。</p></blockquote><table><thead><tr><th>行号</th><th>字段</th><th>意义</th></tr></thead><tbody><tr><td>1</td><td>top</td><td>程序名。</td></tr><tr><td></td><td>14:59:20</td><td>当前时间。</td></tr><tr><td></td><td>up 6:30</td><td>这是正常运行时间。它是计算机从上次启动到现在所运行的时间。 在这个例子里，系统已经运行了六个半小时。</td></tr><tr><td></td><td>2users</td><td>有两个用户登录系统。</td></tr><tr><td></td><td>load average:</td><td>加载平均值是指，等待运行的进程数目，也就是说，处于运行状态的进程个数， 这些进程共享 CPU。展示了三个数值，每个数值对应不同的时间周期。第一个是最后60秒的平均值， 下一个是前5分钟的平均值，最后一个是前15分钟的平均值。若平均值低于1.0，则指示计算机 工作不忙碌。</td></tr><tr><td>2</td><td>Tasks:</td><td>总结了进程数目和各种进程状态。</td></tr><tr><td>3</td><td>Cpu(s):</td><td>这一行描述了 CPU 正在执行的进程的特性。</td></tr><tr><td></td><td>0.7%us</td><td>0.7% of the CPU is being used for user processes. 这意味着进程在内核之外。</td></tr><tr><td></td><td>1.0%sy</td><td>1.0%的 CPU 时间被用于系统（内核）进程。</td></tr><tr><td></td><td>0.0%ni</td><td>0.0%的 CPU 时间被用于&quot;nice&quot;（低优先级）进程。</td></tr><tr><td></td><td>98.3%id</td><td>98.3%的 CPU 时间是空闲的。</td></tr><tr><td></td><td>0.0%wa</td><td>0.0%的 CPU 时间来等待 I/O。</td></tr><tr><td>4</td><td>Mem:</td><td>展示物理内存的使用情况。</td></tr><tr><td>5</td><td>Swap:</td><td>展示交换分区（虚拟内存）的使用情况。</td></tr></tbody></table><h3 id="进程相关命令"><a class="markdownIt-Anchor" href="#进程相关命令"></a> 进程相关命令</h3><h4 id="停止暂停"><a class="markdownIt-Anchor" href="#停止暂停"></a> 停止/暂停</h4><p>linux中我们正在运行的程序可以通过下列命令停止或暂停</p><ul><li>ctrl+c：中断/停止一个程序</li><li>ctrl+z：停止一个进程，而没有终止它。这样会把一个前台进程移到后台等待</li></ul><h4 id="放置到后台执行"><a class="markdownIt-Anchor" href="#放置到后台执行"></a> 放置到后台执行</h4><p>比方说，我们想让 shell 提示符返回，却没有终止 xlogo 程序。为达到这个目的，我们把 这个程序放到后台执行。把终端看作是一个有前台（表层放置可见的事物，像 shell 提示符） 和后台（表层之下放置隐藏的事物）（的设备）。</p><ul><li>启动一个程序，<strong>加上”&amp;”字符</strong>，让它<strong>立即在后台</strong> 运行：</li></ul><pre><code class="highlight plaintext">[me@linuxbox ~]$ xlogo &amp;[1] 28236[me@linuxbox ~]$</code></pre><ul><li>启动一个程序，也可以使用<strong>ctrl+z</strong>让其在后台运行：</li></ul><pre><code class="highlight plaintext">[me@linuxbox ~]$ xlogo[1]+ Stopped                 xlogo[me@linuxbox ~]$</code></pre><p>执行命令之后，这个 xlogo 窗口出现，并且 shell 提示符返回，同时打印一些有趣的数字。 这条信息是 shell 特性的一部分，叫做工作控制。通过这条信息，shell 告诉我们，已经启动了 工作号为1（“［1］”），PID 为28236的程序。如果我们运行 ps 命令，可以看到我们的进程：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ ps  PID TTY         TIME   CMD10603 pts/1   00:00:00   bash28236 pts/1   00:00:00   xlogo28239 pts/1   00:00:00   ps</code></pre><h4 id="jobs-显示活跃任务"><a class="markdownIt-Anchor" href="#jobs-显示活跃任务"></a> jobs 显示活跃任务</h4><p>工作控制，这个 shell 功能可以列出从终端中启动的任务。执行 jobs 命令，我们可以看到这个输出列表：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ jobs[1]+ Running            xlogo &amp;</code></pre><blockquote><p>结果显示我们有一个任务，编号为“1”，它正在运行，并且这个任务的命令是 xlogo ＆</p></blockquote><h4 id="fgbg"><a class="markdownIt-Anchor" href="#fgbg"></a> fg/bg</h4><p><strong>fg 把一个任务放到前台执行</strong></p><p>一个在后台运行的进程对一切来自键盘的输入都免疫，也不能用 Ctrl-c 来中断它。使用 fg 命令，让一个进程返回前台执行：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ jobs[1]+ Running        xlogo &amp;[me@linuxbox ~]$ fg %1xlogo</code></pre><p><strong>bg 把一个任务放到后台执行</strong></p><p>停止 xlogo 程序之后，通过调整 xlogo 的窗口大小，我们可以证实这个程序已经停止了。 它看起来像死掉了一样。使用 fg 命令，可以恢复程序到前台运行，或者用 bg 命令把程序移到后台。</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ bg %1[1]+ xlogo &amp;[me@linuxbox ~]$</code></pre><h4 id="pidof"><a class="markdownIt-Anchor" href="#pidof"></a> pidof</h4><p>pidof命令用于查询某个指定服务进程的PID值，格式为</p><pre><code class="highlight plaintext">pidof [参数] [服务名称]</code></pre><p>每个进程的进程号码值（PID）是唯一的，因此可以通过PID来区分不同的进程。例如，可以使用如下命令来查询本机上sshd服务程序的PID：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# pidof sshd2156</code></pre><h4 id="kill-killall"><a class="markdownIt-Anchor" href="#kill-killall"></a> kill /killall</h4><p><strong>kill命令</strong>用于终止某个指定PID的服务进程，格式为</p><pre><code class="highlight plaintext">kill [参数] [进程PID]</code></pre><p>参数：</p><table><thead><tr><th>编号</th><th>名字</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>HUP</td><td>挂起。这是美好往昔的痕迹，那时候终端机通过电话线和调制解调器连接到 远端的计算机。这个信号被用来告诉程序，控制的终端机已经“挂起”。 通过关闭一个终端会话，可以说明这个信号的作用。发送这个信号到终端机上的前台程序，程序会终止。许多守护进程也使用这个信号，来重新初始化。这意味着，当发送这个信号到一个守护进程后， 这个进程会重新启动，并且重新读取它的配置文件。Apache 网络服务器守护进程就是一个例子。</td></tr><tr><td>2</td><td>INT</td><td>中断。实现和 Ctrl-c 一样的功能，由终端发送。通常，它会终止一个程序。</td></tr><tr><td>3</td><td>QUIT</td><td>退出</td></tr><tr><td>9</td><td>KILL</td><td>杀死。这个信号很特别。鉴于进程可能会选择不同的方式，来处理发送给它的 信号，其中也包含忽略信号，这样呢，从不发送 Kill 信号到目标进程。而是内核立即终止 这个进程。当一个进程以这种方式终止的时候，它没有机会去做些“清理”工作，或者是保存劳动成果。 因为这个原因，把 KILL 信号看作杀手锏，当其它终止信号失败后，再使用它。</td></tr><tr><td>11</td><td>SEGV</td><td>段错误。如果一个程序非法使用内存，就会发送这个信号。也就是说， 程序试图写入内存，而这个内存空间是不允许此程序写入的。</td></tr><tr><td>15</td><td>TERM</td><td>终止。这是 kill 命令发送的默认信号。如果程序仍然“活着”，可以接受信号，那么 这个信号终止。</td></tr><tr><td>18</td><td>CONT</td><td>继续。在停止一段时间后，进程恢复运行。</td></tr><tr><td>19</td><td>STOP</td><td>停止。这个信号导致进程停止运行，而没有终止。像 KILL 信号，它不被 发送到目标进程，因此它不能被忽略。</td></tr><tr><td>20</td><td>TSTP</td><td>终端停止。当按下 Ctrl-z 组合键后，终端发送这个信号。不像 STOP 信号， TSTP 信号由目标进程接收，且可能被忽略。</td></tr><tr><td>28</td><td>WINCH</td><td>改变窗口大小。当改变窗口大小时，系统会发送这个信号。 一些程序，像 top 和 less 程序会响应这个信号，按照新窗口的尺寸，刷新显示的内容。</td></tr></tbody></table><blockquote><p>也可以用 jobspec（例如，“％1”）来代替 PID</p></blockquote><p>接下来，我们使用kill命令把上面用pidof命令查询到的PID所代表的进程终止掉，其命令如下所示。这种操作的效果等同于强制停止sshd服务</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# kill 2156</code></pre><hr /><p><strong>killall命令</strong>用于终止某个指定名称的服务所对应的全部进程，或者通过 killall 命令，给匹配特定程序或用户名的多个进程发送信号，格式为：</p><pre><code class="highlight plaintext">killall [参数] [服务名称]</code></pre><p>通常来讲，复杂软件的服务程序会有多个进程协同为用户提供服务，如果逐个去结束这些进程会比较麻烦，此时可以使用killall命令来批量结束某个服务程序带有的全部进程。下面以httpd服务程序为例，来结束其全部进程</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# pidof httpd13581 13580 13579 13578 13577 13576[root@linuxprobe ~]# killall httpd[root@linuxprobe ~]# pidof httpd[root@linuxprobe ~]#</code></pre><blockquote><p>如果我们在系统终端中执行一个命令后想立即停止它，可以同时<strong>按下Ctrl + C组合键</strong>（生产环境中比较常用的一个快捷键），这样将<strong>立即终止该命令的进程</strong>。或者，如果有些命令在执行时不断地在屏幕上输出信息，影响到后续命令的输入，则可以在执行命令时在末尾<strong>添加上一个&amp;符号</strong>，这样<strong>命令将进入系统后台</strong>来执行</p></blockquote><p>为了说明情况，我们将启动一对 xlogo 程序的实例，然后再终止它们：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ xlogo &amp;[1] 18801[me@linuxbox ~]$ xlogo &amp;[2] 18802[me@linuxbox ~]$ killall xlogo[1]- Terminated                xlogo[2]+ Terminated                xlogo</code></pre><h2 id="shell环境变量"><a class="markdownIt-Anchor" href="#shell环境变量"></a> shell环境变量</h2><p>正如我们之前所讨论到的，shell 在 shell 会话中维护着大量的信息，这些信息称为 (shell) 环境。 存储在 shell 环境中的数据被程序用来确定配置属性。然而大多数程序用配置文件来存储程序设置， 某些程序也会查找存储在 shell 环境中的数值来调整他们的行为。知道了这些，我们就可以用 shell 环境 来自定制 shell 经历。</p><p>shell 在环境中存储了两种基本类型的数据，虽然对于 bash 来说，很大程度上这些类型是不可 辨别的。它们是<strong>环境变量</strong>和 <strong>shell 变量</strong>。Shell 变量是由 bash 存放的少量数据，而剩下的基本上 都是环境变量。除了变量，shell 也存储了一些可编程的数据，命名为别名和 shell 函数。</p><h3 id="查看环境变量"><a class="markdownIt-Anchor" href="#查看环境变量"></a> 查看环境变量</h3><p>我们既可以<strong>用 bash 的内部命令 set</strong>，或者是 <strong>printenv 程序</strong>来查看什么存储在环境当中。set 命令可以 显示 shell 和环境变量两者，而 printenv 只是显示环境变量。</p><p>因为环境变量内容列表相当长，所以最好 把每个命令的输出结果管道到 less 命令：</p><pre><code class="highlight plaintext">$ printenv | less</code></pre><p>执行以上命令之后，我们应该能得到类似以下内容：</p><pre><code class="highlight plaintext">KDE_MULTIHEAD=falseSSH_AGENT_PID=6666HOSTNAME=linuxboxGPG_AGENT_INFO=/tmp/gpg-PdOt7g/S.gpg-agent:6689:1SHELL=/bin/bashTERM=xtermXDG_MENU_PREFIX=kde-HISTSIZE=1000XDG_SESSION_COOKIE=6d7b05c65846c3eaf3101b0046bd2b00-1208521990.996705-1177056199GTK2_RC_FILES=/etc/gtk-2.0/gtkrc:/home/me/.gtkrc-2.0:/home/me/.kde/share/config/gtkrc-2.0GTK_RC_FILES=/etc/gtk/gtkrc:/home/me/.gtkrc:/home/me/.kde/share/config/gtkrcGS_LIB=/home/me/.fontsWINDOWID=29360136QTDIR=/usr/lib/qt-3.3QTINC=/usr/lib/qt-3.3/includeKDE_FULL_SESSION=trueUSER=meLS_COLORS=no=00:fi=00:di=00;34:ln=00;36:pi=40;33:so=00;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=00;32:\*.cmd=00;32:\*.exe:</code></pre><p>我们所看到的是环境变量及其数值的列表。例如，我们看到一个叫做 USER 的变量，这个变量值是 “me”。printenv 命令也能够列出特定变量的数值：</p><pre><code class="highlight plaintext">$ printenv USERme</code></pre><p>当使用没有带选项和参数的 set 命令时，shell 和环境变量二者都会显示，同时也会显示定义的 shell 函数。不同于 printenv 命令，set 命令的输出结果很礼貌地按照字母顺序排列：</p><pre><code class="highlight plaintext">$ set | less</code></pre><p>也可以通过 echo 命令来查看一个变量的内容，像这样：</p><pre><code class="highlight plaintext">$ echo $HOME/home/me</code></pre><p>如果 shell 环境中的一个成员既不可用 set 命令也不可用 printenv 命令显示，则这个变量是别名。 输入不带参数的 alias 命令来查看它们:</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ aliasalias l.=&#x27;ls -d .* --color=tty&#x27;alias ll=&#x27;ls -l --color=tty&#x27;alias ls=&#x27;ls --color=tty&#x27;alias vi=&#x27;vim&#x27;alias which=&#x27;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&#x27;</code></pre><hr /><p><strong>一些常见的环境变量</strong></p><table><thead><tr><th>变量</th><th>内容</th></tr></thead><tbody><tr><td>DISPLAY</td><td>如果你正在运行图形界面环境，那么这个变量就是你显示器的名字。通常，它是 “:0”， 意思是由 X 产生的第一个显示器。</td></tr><tr><td>EDITOR</td><td>文本编辑器的名字。</td></tr><tr><td>SHELL</td><td>shell 程序的名字。</td></tr><tr><td>HOME</td><td>用户家目录。</td></tr><tr><td>LANG</td><td>定义了字符集以及语言编码方式。</td></tr><tr><td>OLD_PWD</td><td>先前的工作目录。</td></tr><tr><td>PAGER</td><td>页输出程序的名字。这经常设置为/usr/bin/less。</td></tr><tr><td>PATH</td><td>由冒号分开的目录列表，当你输入可执行程序名后，会搜索这个目录列表。</td></tr><tr><td>PS1</td><td>Prompt String 1. 这个定义了你的 shell 提示符的内容。随后我们可以看到，这个变量 内容可以全面地定制。</td></tr><tr><td>PWD</td><td>当前工作目录。</td></tr><tr><td>TERM</td><td>终端类型名。类 Unix 的系统支持许多终端协议；这个变量设置你的终端仿真器所用的协议。</td></tr><tr><td>TZ</td><td>指定你所在的时区。大多数类 Unix 的系统按照协调时间时 (UTC) 来维护计算机内部的时钟 ，然后应用一个由这个变量指定的偏差来显示本地时间。</td></tr><tr><td>USER</td><td>你的用户名</td></tr></tbody></table><h3 id="建立环境变量"><a class="markdownIt-Anchor" href="#建立环境变量"></a> 建立环境变量</h3><p>当我们登录系统后，启动 bash 程序，并且会读取一系列称为启动文件的配置脚本， 这些文件定义了默认的可供所有用户共享的 shell 环境。然后是读取更多位于我们自己家目录中 的启动文件，这些启动文件定义了用户个人的 shell 环境。精确的启动顺序依赖于要运行的 shell 会话 类型。有两种 shell 会话类型：一个是登录 shell 会话，另一个是非登录 shell 会话。登录 shell 会话会提示用户输入用户名和密码；例如，我们启动一个虚拟控制台会话。当我们在 GUI 模式下 运行终端会话时，非登录 shell 会话会出现。</p><p>登录 shell 会读取一个或多个启动文件，正如表所示：</p><table><thead><tr><th>文件</th><th>内容</th></tr></thead><tbody><tr><td>/etc/profile</td><td>应用于所有用户的全局配置脚本。</td></tr><tr><td>~/.bash_profile</td><td>用户私人的启动文件。可以用来扩展或重写全局配置脚本中的设置。</td></tr><tr><td>~/.bash_login</td><td>如果文件 ~/.bash_profile 没有找到，bash 会尝试读取这个脚本。</td></tr><tr><td>~/.profile</td><td>如果文件 ~/.bash_profile 或文件 ~/.bash_login 都没有找到，bash 会试图读取这个文件。 这是基于 Debian 发行版的默认设置，比方说 Ubuntu。</td></tr></tbody></table><p>非登录 shell 会话会读取以下启动文件：</p><table><thead><tr><th>文件</th><th>内容</th></tr></thead><tbody><tr><td>/etc/bash.bashrc</td><td>应用于所有用户的全局配置文件。</td></tr><tr><td>~/.bashrc</td><td>用户私有的启动文件。可以用来扩展或重写全局配置脚本中的设置。</td></tr></tbody></table><p>除了读取以上启动文件之外，非登录 shell 会话也会继承它们父进程的环境设置，通常是一个登录 shell。</p><p>在普通用户看来，文件 ~/.bashrc 可能是最重要的启动文件，因为它几乎总是被读取。非登录 shell 默认 会读取它，并且大多数登录 shell 的启动文件会以能读取 ~/.bashrc 文件的方式来书写。</p><hr /><p><strong>启动文件的内容</strong></p><p>如果我们看一下典型的 .bash_profile 文件（来自于 CentOS 4 系统），它看起来像这样：</p><pre><code class="highlight plaintext"># .bash_profile# Get the aliases and functions#下列if的意思是如果.bashrc文件存在，则读取该文件if [ -f ~/.bashrc ]; then. ~/.bashrcfi# User specific environment and startup programsPATH=$PATH:$HOME/binexport PATH</code></pre><pre><code class="highlight plaintext">If the file ~/.bashrc exists, thenread the ~/.bashrc file.</code></pre><p>我们可以看到这一小段代码就是一个登录 shell 得到 .bashrc 文件内容的方式。在我们启动文件中， 下一件有趣的事与 PATH 变量有关系。</p><p>曾经是否感到迷惑 shell 是怎样知道到哪里找到我们在命令行中输入的命令的？</p><p>例如，当我们输入 ls 后， shell 不会查找整个计算机系统，来找到 /bin/ls（ls 命令的绝对路径名），而是，它查找一个目录列表， <strong>这些目录包含在 PATH 变量中</strong>。</p><p>PATH 变量经常（但不总是，依赖于发行版）<strong>在 /etc/profile 启动文件中设置</strong>，通过这些代码：</p><pre><code class="highlight plaintext">PATH=$PATH:$HOME/bin</code></pre><p>修改 PATH 变量，添加目录 $HOME/bin 到目录列表的末尾。这是一个参数展开的实例， 参数展开我们在第八章中提到过。为了说明这是怎样工作的，试试下面的例子：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ foo=&quot;This is some&quot;[me@linuxbox ~]$ echo $fooThis is some[me@linuxbox ~]$ foo=&quot;$foo text.&quot;[me@linuxbox ~]$ echo $fooThis is some text.</code></pre><p>使用<strong>这种技巧，我们可以把文本附加到一个变量值的末尾</strong>。通过添加字符串 $HOME/bin 到 PATH 变量值 的末尾，则目录 $HOME/bin 就添加到了命令搜索目录列表中。这意味着当我们想要在自己的家目录下， 创建一个目录来存储我们自己的私人程序时，shell 已经给我们准备好了。我们所要做的事就是 把创建的目录叫做 bin，赶快行动吧。</p><blockquote><p>注意：很多发行版默认地提供了这个 PATH 设置。一些基于 Debian 的发行版，例如 Ubuntu，在登录 的时候，会检测目录 ~/bin 是否存在，若找到目录则把它动态地加到 PATH 变量中。</p></blockquote><p>最后，有下面一行代码：</p><pre><code class="highlight plaintext">export PATH</code></pre><p>这个 export 命令告诉 shell 让这个 shell 的子进程可以使用 PATH 变量的内容，即让PATH变量从仅为该用户使用变为全局使用。</p><h3 id="export命令"><a class="markdownIt-Anchor" href="#export命令"></a> export命令</h3><p>设置或显示环境变量。</p><pre><code class="highlight plaintext">export [-fnp][变量名称]=[变量设置值]</code></pre><p>参 数：</p><ul><li>-f 代表[变量名称]中为函数名称。</li><li>-n 删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。</li><li>-p 列出所有的shell赋予程序的环境变量。</li></ul><p>一个变量创建时，它不会自动地为在它之后创建的shell进程所知。而命令export可以向后面的shell传递变量的值。当一个shell脚本调用并执行时，它不会自动得到原来脚本（调用者）里定义的变量的访问权，除非这些变量已经被显式地设置为可用。export命令可以用于传递一个或多个变量的值到任何后继脚本。</p><p>登录到系统后，系统将启动一个用户shell。在这个shell中，可以使用shell命令或声明变量，也可以创建并运行shell脚本程序。运行shell脚本程序时，系统将创建一个子shell。此时，系统中将有两个shell，一个是登录时系统启动的shell，另一个是系统为运行脚本程序创建的shell。当一个脚本程序运行完毕，它的脚本shell将终止，可以返回到执行该脚本之前的shell。从这种意义上来说，用户可以有许多shell，每个shell都是由某个shell（称为父shell）派生的。</p><p>在<strong>子shell中定义的变量只在该子shell内有效</strong>。如果在一个shell脚本程序中定义了一个变量，当该脚本程序运行时，这个定义的变量只是该脚本程序内的一个局部变量，其他的shell不能引用它，要使<strong>某个变量的值可以在其他shell中被改变，可以使用export命令对已定义的变量进行输出</strong>。</p><p>export命令将使系统在创建每一个新的shell时定义这个变量的一个拷贝。这个过程称之为变量输出。</p><p>#echo $PKG_PATH 在任何时候建立的变量都只是当前shell的局部变量，所以不能被shell运行的其他命令或shell程序所利用。 export ,是把你设置的环境变量传给当前SHELL的子SHELL，使其在子SHELL中有效。</p><h3 id="修改shell环境"><a class="markdownIt-Anchor" href="#修改shell环境"></a> 修改shell环境</h3><p>按照通常的规则，添加目录到你的 PATH 变量或者是定义额外的环境变量，要把这些更改放置到 .bash_profile 文件中（或者其替代文件中，根据不同的发行版。例如，Ubuntu 使用 .profile 文件）。 对于其它的更改，要放到 .bashrc 文件中。除非你是系统管理员，需要为系统中的所有用户修改 默认设置，那么则限定你只能对自己家目录下的文件进行修改。当然，有可能会更改 /etc 目录中的 文件，比如说 profile 文件，而且在许多情况下，修改这些文件也是明智的，但是现在，我们要 安全起见。</p><p>修改之前我们先备份一份：</p><pre><code class="highlight plaintext">#该文件在用户的家目录[me@linuxbox ~]$ cp .bashrc .bashrc.bak</code></pre><p>然后我们编辑该文件：</p><pre><code class="highlight plaintext">vim .bashrc</code></pre><p>在最后面添加：</p><pre><code class="highlight plaintext">umask 0002export HISTCONTROL=ignoredupsexport HISTSIZE=1000alias l.=&#x27;ls -d .* --color=auto&#x27;alias ll=&#x27;ls -l --color=auto&#x27;</code></pre><blockquote><p>注意：你的发行版可能已经包含其中的一些行，但是复制没有任何伤害。</p></blockquote><table><thead><tr><th>按键</th><th>行动</th></tr></thead><tbody><tr><td>文本行</td><td>含义</td></tr><tr><td>umask 0002</td><td>设置掩码来解决共享目录的问题。</td></tr><tr><td>export HISTCONTROL=ignoredups</td><td>使得 shell 的历史记录功能忽略一个命令，如果相同的命令已被记录。</td></tr><tr><td>export HISTSIZE=1000</td><td>增加命令历史的大小，从默认的 500 行扩大到 1000 行。</td></tr><tr><td>alias l.=‘ls -d .* --color=auto’</td><td>创建一个新命令，叫做’l.'，这个命令会显示所有以点开头的目录项。</td></tr><tr><td>alias ll=‘ls -l --color=auto’</td><td>创建一个叫做’ll’的命令，这个命令会显示长格式目录列表。</td></tr></tbody></table><hr /><p><strong>激活我们的修改</strong></p><p>我们对于文件 .bashrc 的修改不会生效，直到我们关闭终端会话，再重新启动一个新的会话， 因为 .bashrc 文件只是在刚开始启动终端会话时读取。然而，我们可以强迫 bash 重新读取修改过的 .bashrc 文件，使用下面的命令：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ source .bashrc</code></pre><h2 id="软件包管理"><a class="markdownIt-Anchor" href="#软件包管理"></a> 软件包管理</h2><p><strong>打包系统</strong></p><p>不同的 Linux 发行版使用不同的打包系统，一般而言，大多数发行版分别属于两大包管理技术阵营： Debian 的”.deb”，和红帽的”.rpm”。也有一些重要的例外，比方说 Gentoo， Slackware，和 Foresight，但大多数会使用这两个基本系统中的一个。</p><table><thead><tr><th>包管理系统</th><th>发行版 (部分列表)</th></tr></thead><tbody><tr><td>Debian Style (.deb)</td><td>Debian, Ubuntu, Xandros, Linspire</td></tr><tr><td>Red Hat Style (.rpm)</td><td>Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS</td></tr></tbody></table><p><strong>软件包管理系统是怎样工作</strong></p><p>在专有软件产业中找到的软件发布方法通常需要买一张安装媒介，比方说”安装盘”，然后运行 “安装向导”，来在系统中安装新的应用程序。</p><p>Linux 不是这样。Linux 系统中几乎所有的软件都可以在互联网上找到。其中大多数软件由发行商以 包文件的形式提供，剩下的则以源码形式存在，可以手动安装。在后面章节里，我们将会谈谈怎样 通过编译源码来安装软件。</p><p><strong>包文件</strong></p><p>在包管理系统中软件的基本单元是包文件。包文件是一个构成软件包的文件压缩集合。一个软件包 可能由大量程序以及支持这些程序的数据文件组成。除了安装文件之外，软件包文件也包括 关于这个包的元数据，如软件包及其内容的文本说明。另外，许多软件包还包括预安装和安装后脚本， 这些脚本用来在软件安装之前和之后执行配置任务。</p><p>软件包文件是由软件包维护者创建的，他通常是（但不总是）一名软件发行商的雇员。软件维护者 从上游提供商（程序作者）那里得到软件源码，然后编辑源码，创建软件包元数据以及所需要的 安装脚本。通常，软件包维护者要把所做的修改应用到最初的源码当中，来提高此软件与 Linux 发行版其它部分的融合性。</p><p><strong>资源库</strong></p><p>虽然某些软件项目选择执行他们自己的打包和发布策略，但是现在大多数软件包是由发行商和感兴趣 的第三方创建的。系统发行版的用户可以在一个中心资源库中得到这些软件包，这个资源库可能 包含了成千上万个软件包，每一个软件包都是专门为这个系统发行版建立和维护的。</p><p>因软件开发生命周期不同阶段的需要，一个系统发行版可能维护着几个不同的资源库。例如，通常会 有一个”测试”资源库，其中包含刚刚建立的软件包，它们想要勇敢的用户来使用， 在这些软件包正式发布之前，让用户查找错误。系统发行版经常会有一个”开发”资源库， 这个资源库中保存着注定要包含到下一个主要版本中的半成品软件包。</p><p>一个系统发行版可能也会拥有相关第三方的资源库。这些资源库需要支持一些因法律原因， 比如说专利或者是 DRM 反规避问题，而不能被包含到发行版中的软件。可能最著名的案例就是 那个加密的 DVD 支持，在美国这是不合法的。第三方资源库在这些软件专利和反规避法案不 生效的国家中起作用。这些资源库通常完全地独立于它们所支持的资源库，要想使用它们， 你必须了解它们，手动地把它们包含到软件包管理系统的配置文件中。</p><p><strong>依赖性</strong></p><p>程序很少是”孤立的”，而是依赖于其它软件组件来完成它们的工作。常见活动，以 输入/输出为例，就是由共享程序例程来处理的。这些程序例程存储在共享库中，共享库不只 为一个程序提供基本服务。如果一个软件包需要共享资源，比如说共享库，据说就有一个依赖。 现代的软件包管理系统都提供了一些依赖项解析方法，以此来确保当安装软件包时，也安装了 其所有的依赖程序。</p><p><strong>上层和底层软件包工具</strong></p><p>软件包管理系统通常由两种工具类型组成：底层工具用来处理这些任务，比方说安装和删除软件包文件， 和上层工具，完成元数据搜索和依赖解析。在这一章中，我们将看一下由 Debian 风格的系统 （比如说 Ubuntu，还有许多其它系统）提供的工具，还有那些由 Red Hat 产品使用的工具。虽然所有基于 Red Hat 风格的发行版都依赖于相同的底层程序（rpm）, 但是它们却使用不同的上层工具。我们将研究上层程序 yum 供我们讨论，Fedora, Red Hat 企业版，和 CentOs 都是使用 yum。其它基于 Red Hat 风格的发行版提供了带有可比较特性的上层工具。</p><table><thead><tr><th>发行版</th><th>底层工具</th><th>上层工具</th></tr></thead><tbody><tr><td>Debian-Style</td><td>dpkg</td><td>apt-get, aptitude</td></tr><tr><td>Fedora, Red Hat Enterprise Linux, CentOS</td><td>rpm</td><td>yum</td></tr></tbody></table><h3 id="yum命令"><a class="markdownIt-Anchor" href="#yum命令"></a> yum命令</h3><h4 id="yum搜索软件"><a class="markdownIt-Anchor" href="#yum搜索软件"></a> <strong>yum搜索软件�</strong>�</h4><p>使用上层工具来搜索资源库元数据，可以根据软件包的名字和说明来定位它。</p><table><thead><tr><th>风格</th><th>命令</th></tr></thead><tbody><tr><td>Debian</td><td>apt-get update; apt-cache search search_string</td></tr><tr><td>Red Hat</td><td>yum search search_string</td></tr></tbody></table><p>例如：搜索一个 yum 资源库来查找 emacs 文本编辑器，使用以下命令：</p><pre><code class="highlight plaintext">yum search emacs</code></pre><hr /><h4 id="yum安装软件"><a class="markdownIt-Anchor" href="#yum安装软件"></a> <strong>yum安装软件�</strong>�</h4><p>上层工具允许从一个资源库中下载一个软件包，并经过完全依赖解析来安装它。</p><table><thead><tr><th>风格</th><th>命令</th></tr></thead><tbody><tr><td>Debian</td><td>apt-get update; apt-get install package_name</td></tr><tr><td>Red Ha</td><td>yum install package_name</td></tr></tbody></table><p>例如：从一个 apt 资源库来安装 emacs 文本编辑器：</p><pre><code class="highlight plaintext">yum install emacs</code></pre><hr /><h4 id="yum卸载软件"><a class="markdownIt-Anchor" href="#yum卸载软件"></a> <strong>yum卸载软件</strong></h4><p>可以使用上层或者底层工具来卸载软件。下面是可用的上层工具。</p><table><thead><tr><th>风格</th><th>命令</th></tr></thead><tbody><tr><td>Debian</td><td>apt-get remove package_name</td></tr><tr><td>Red Hat</td><td>yum erase package_name</td></tr></tbody></table><p>例如：从 Red Hat 风格的系统中卸载 emacs 软件包：</p><pre><code class="highlight plaintext">yum erase emacs</code></pre><h4 id="yum更新软件包"><a class="markdownIt-Anchor" href="#yum更新软件包"></a> yum更新软件包</h4><p>最常见的软件包管理任务是保持系统中的软件包都是最新的。上层工具仅需一步就能完成 这个至关重要的任务。</p><table><thead><tr><th>风格</th><th>命令</th></tr></thead><tbody><tr><td>Debian</td><td>apt-get update; apt-get upgrade</td></tr><tr><td>Red Hat</td><td>yum update</td></tr></tbody></table><p>示例：</p><pre><code class="highlight plaintext">yum updata java</code></pre><h4 id="配置阿里镜像"><a class="markdownIt-Anchor" href="#配置阿里镜像"></a> 配置阿里镜像</h4><ol><li>备份</li></ol><pre><code class="highlight plaintext">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code></pre><ol><li>下载新的CentOS-Base.repo</li></ol><pre><code class="highlight plaintext">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</code></pre><ol><li>生成缓存</li></ol><pre><code class="highlight plaintext">yum clean allyum makecache</code></pre><h4 id="查找软件并删除"><a class="markdownIt-Anchor" href="#查找软件并删除"></a> 查找软件并删除</h4><pre><code class="highlight plaintext">rpm -qa | grep jdkyum -y remove java-1.5.0-gcj-devel-1.5.0.0-29.1.el6.x86_64</code></pre><h3 id="rpm"><a class="markdownIt-Anchor" href="#rpm"></a> rpm</h3><hr /><h4 id="通过软件包文件来安装软件"><a class="markdownIt-Anchor" href="#通过软件包文件来安装软件"></a> <strong>通过软件包文件来安装软件</strong></h4><p>如果从某处而不是从资源库中下载了一个软件包文件，可以使用底层工具来直接（没有经过依赖解析）安装它。</p><table><thead><tr><th>风格</th><th>命令</th></tr></thead><tbody><tr><td>Debian</td><td>dpkg --install package_file</td></tr><tr><td>Red Hat</td><td>rpm -i package_file</td></tr></tbody></table><p>例如：如果已经从一个并非资源库的网站下载了软件包文件 emacs-22.1-7.fc7-i386.rpm， 则可以通过这种方法来安装它：</p><pre><code class="highlight plaintext">rpm -i emacs-22.1-7.fc7-i386.rpm</code></pre><p><strong>忽略依赖解析方式</strong>：</p><pre><code class="highlight plaintext">rpm -ivh MySQL-server-5.5.31-2.el6.i686.rpm --nodeps --force</code></pre><blockquote><p>注意：因为这项技术使用底层的 rpm 程序来执行安装任务，所以没有运行依赖解析。 如果 rpm 程序发现缺少了一个依赖，则会报错并退出。</p></blockquote><h4 id="经过软件包来升级软件"><a class="markdownIt-Anchor" href="#经过软件包来升级软件"></a> 经过软件包来升级软件</h4><p>如果已经从一个非资源库网站下载了一个软件包的最新版本，可以安装这个版本，用它来 替代先前的版本：</p><table><thead><tr><th>风格</th><th>命令</th></tr></thead><tbody><tr><td>Debian</td><td>dpkg --install package_file</td></tr><tr><td>Red Hat</td><td>rpm -U package_file</td></tr></tbody></table><p>例如：把 Red Hat 系统中所安装的 emacs 的版本更新到软件包文件 emacs-22.1-7.fc7-i386.rpmz 所包含的 emacs 版本。</p><pre><code class="highlight plaintext">rpm -U emacs-22.1-7.fc7-i386.rpm</code></pre><h4 id="列出所安装的软件包"><a class="markdownIt-Anchor" href="#列出所安装的软件包"></a> 列出所安装的软件包</h4><p>下表中的命令可以用来显示安装到系统中的所有软件包列表：</p><table><thead><tr><th>风格</th><th>命令</th></tr></thead><tbody><tr><td>Debian</td><td>dpkg --list</td></tr><tr><td>Red Hat</td><td>rpm -qa</td></tr></tbody></table><pre><code class="highlight plaintext">rpm -qa | grep mariadb</code></pre><h4 id="删除软件"><a class="markdownIt-Anchor" href="#删除软件"></a> 删除软件</h4><pre><code class="highlight plaintext">语句：rpm -e --nodeps 软件名实例：rpm -e --nodeps mariadb-libs-5.5.37-1.el7_0.x86_64批量删除：yum -y remove `rpm -qa | grep mariadb`rpm -e --nodeps `rpm -qa | grep mysql`</code></pre><h2 id="网络系统"><a class="markdownIt-Anchor" href="#网络系统"></a> 网络系统</h2><p>当谈及到网络系统层面，几乎任何东西都能由 Linux 来实现。Linux 被用来创建各式各样的网络系统和装置， 包括防火墙，路由器，名称服务器，网络连接式存储设备等等。</p><h3 id="检查和检测网络"><a class="markdownIt-Anchor" href="#检查和检测网络"></a> 检查和检测网络</h3><h4 id="ping"><a class="markdownIt-Anchor" href="#ping"></a> ping</h4><p>最基本的网络命令是 ping。这个 ping 命令发送一个特殊的网络数据包，叫做 IMCP ECHO_REQUEST，到 一台指定的主机。大多数接收这个包的网络设备将会回复它，来允许网络连接验证。</p><blockquote><p>注意：大多数网络设备（包括 Linux 主机）都可以被配置为忽略这些数据包。通常，这样做是出于网络安全 原因，部分地遮蔽一台主机免受一个潜在攻击者地侵袭。配置防火墙来阻塞 IMCP 流量也很普遍。</p></blockquote><p>一旦启动，ping 命令会持续在特定的时间间隔内（默认是一秒）发送数据包，直到它被中断：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ ping linuxcommand.orgPING linuxcommand.org (66.35.250.210) 56(84) bytes of data.64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=1ttl=43 time=107 ms64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=2ttl=43 time=108 ms64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=3ttl=43 time=106 ms64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=4ttl=43 time=106 ms64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=5ttl=43 time=105 ms...</code></pre><p>按下组合键 Ctrl-c，中断这个命令之后，ping 打印出运行统计信息。一个正常工作的网络会报告 零个数据包丢失。一个成功执行的“ping”命令会意味着网络的各个部件（网卡，电缆，路由，网关） 都处于正常的工作状态。</p><h4 id="netstat"><a class="markdownIt-Anchor" href="#netstat"></a> netstat</h4><p>netstat 程序被用来检查各种各样的网络设置和统计数据。通过此命令的许多选项，我们 可以看看网络设置中的各种特性。使用“-ie”选项，我们能够查看系统中的网络接口：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ netstat -ieeth0    Link encap:Ethernet HWaddr 00:1d:09:9b:99:67        inet addr:192.168.1.2 Bcast:192.168.1.255 Mask:255.255.255.0        inet6 addr: fe80::21d:9ff:fe9b:9967/64 Scope:Link        UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1        RX packets:238488 errors:0 dropped:0 overruns:0 frame:0        TX packets:403217 errors:0 dropped:0 overruns:0 carrier:0        collisions:0 txqueuelen:100 RX bytes:153098921 (146.0 MB) TX        bytes:261035246 (248.9 MB) Memory:fdfc0000-fdfe0000lo      Link encap:Local Loopback        inet addr:127.0.0.1 Mask:255.0.0.0...</code></pre><p>在上述实例中，我们看到我们的测试系统有两个网络接口。第一个，叫做 eth0，是 因特网接口，和第二个，叫做 lo，是内部回环网络接口，它是一个虚拟接口，系统用它来 “自言自语”。</p><hr /><p><strong>查看某端口</strong></p><pre><code class="highlight plaintext">netstat -ntlp   //查看当前所有tcp端口·netstat -ntulp |grep 1935   //查看所有1935端口使用情况·</code></pre><h3 id="网络中传输文件"><a class="markdownIt-Anchor" href="#网络中传输文件"></a> 网络中传输文件</h3><h4 id="ftp"><a class="markdownIt-Anchor" href="#ftp"></a> ftp</h4><p>ftp 命令属于真正的“经典”程序之一，它的名字来源于其所使用的协议，就是文件传输协议。 FTP 被广泛地用来从因特网上下载文件。大多数，并不是所有的，网络浏览器都支持 FTP， 你经常可以看到它们的 URI 以协议 <a href="ftp://%E5%BC%80%E5%A4%B4">ftp://开头</a>。在出现网络浏览器之前，ftp 程序已经存在了。 ftp 程序可用来与 FTP 服务器进行通信，FTP 服务器就是存储文件的计算机，这些文件能够通过 网络下载和上传。</p><p>FTP（它的原始形式）并不是安全的，因为它会以明码形式发送帐号的姓名和密码。这就意味着 这些数据没有加密，任何嗅探网络的人都能看到。由于此种原因，几乎因特网中所有 FTP 服务器 都是匿名的。一个匿名服务器能允许任何人使用注册名“anonymous”和无意义的密码登录系统。</p><p>在下面的例子中，我们将展示一个典型的会话，从匿名 FTP 服务器，其名字是 fileserver， 的/pub/images/Ubuntu-8.04的目录下，使用 ftp 程序下载一个 Ubuntu 系统映像文件。</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ ftp fileserverConnected to fileserver.localdomain.220 (vsFTPd 2.0.1)Name (fileserver:me): anonymous331 Please specify the password.Password:230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp&gt; cd pub/cd\_images/Ubuntu-8.04250 Directory successfully changed.ftp&gt; ls200 PORT command successful. Consider using PASV.150 Here comes the directory listing.-rw-rw-r-- 1 500 500 733079552 Apr 25 03:53 ubuntu-8.04- desktop-i386.iso226 Directory send OK.ftp&gt; lcd DesktopLocal directory now /home/me/Desktopftp&gt; get ubuntu-8.04-desktop-i386.isolocal: ubuntu-8.04-desktop-i386.iso remote: ubuntu-8.04-desktop-i386.iso200 PORT command successful. Consider using PASV.150 Opening BINARY mode data connection for ubuntu-8.04-desktop-i386.iso (733079552 bytes).226 File send OK.733079552 bytes received in 68.56 secs (10441.5 kB/s)ftp&gt; bye</code></pre><table><thead><tr><th>命令</th><th>意思</th></tr></thead><tbody><tr><td>ftp fileserver</td><td>唤醒 ftp 程序，让它连接到 FTP 服务器，fileserver。</td></tr><tr><td>anonymous</td><td>登录名。输入登录名后，将出现一个密码提示。一些服务器将会接受空密码， 其它一些则会要求一个邮件地址形式的密码。如果是这种情况，试着输入 “user@example.com”。</td></tr><tr><td>cd pub/cd_images/Ubuntu-8.04</td><td>跳转到远端系统中，要下载文件所在的目录下， 注意在大多数匿名的 FTP 服务器中，支持公共下载的文件都能在目录 pub 下找到</td></tr><tr><td>ls</td><td>列出远端系统中的目录。</td></tr><tr><td>lcd Desktop</td><td>跳转到本地系统中的 ~/Desktop 目录下。在实例中，ftp 程序在工作目录 ~ 下被唤醒。 这个命令把工作目录改为 ~/Desktop</td></tr><tr><td>get ubuntu-8.04-desktop-i386.iso</td><td>告诉远端系统传送文件到本地。因为本地系统的工作目录 已经更改到了 ~/Desktop，所以文件会被下载到此目录。</td></tr><tr><td>bye</td><td>退出远端服务器，结束 ftp 程序会话。也可以使用命令 quit 和 exit。</td></tr></tbody></table><h4 id="wget-下载"><a class="markdownIt-Anchor" href="#wget-下载"></a> wget 下载</h4><p>wget命令用于<strong>在终端中下载网络文件</strong>，格式</p><pre><code class="highlight plaintext">wget [参数] 下载地址</code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><p><strong>案例：</strong></p><p>尝试使用wget命令从本书的配套站点中下载本书的最新pdf格式电子文档，这个文件的完整路径为<a href="https://www.linuxprobe.com/docs/LinuxProbe.pdf%EF%BC%8C%E6%89%A7%E8%A1%8C%E8%AF%A5%E5%91%BD%E4%BB%A4%E5%90%8E%E7%9A%84%E4%B8%8B%E8%BD%BD%E6%95%88%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">https://www.linuxprobe.com/docs/LinuxProbe.pdf，执行该命令后的下载效果如下：</a></p><pre><code class="highlight plaintext">[root@linuxprobe ~]# wget https://www.linuxprobe.com/docs/LinuxProbe.pdf</code></pre><p>接下来，我们使用wget命令递归下载www.linuxprobe.com网站内的所有页面数据以及文件，下载完后会自动保存到当前路径下一个名为www.linuxprobe.com的目录中。执行该操作的命令为wget -r -p <a href="https://www.linuxprobe.com">https://www.linuxprobe.com</a>，该命令的执行结果如下。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# wget -r -p https://www.linuxprobe.com--2017-08-24 19:31:41-- https://www.linuxprobe.com/Resolving www.linuxprobe.com... 106.185.25.197Connecting to www.linuxprobe.com|106.185.25.197|:80... connected.HTTP request sent, awaiting response... 200 OKLength: unspecified [text/html]Saving to: &#x27;www.linuxprobe.com/index.html&#x27;</code></pre><h4 id="scp远程拷贝"><a class="markdownIt-Anchor" href="#scp远程拷贝"></a> scp远程拷贝</h4><p>Linux scp 命令用于 Linux 之间复制文件和目录。</p><p>语法：</p><pre><code class="highlight plaintext">scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file][-l limit] [-o ssh_option] [-P port] [-S program][[user@]host1:]file1 [...] [[user@]host2:]file2</code></pre><p>简易写法</p><pre><code class="highlight plaintext">:scp [可选参数] file_source file_target</code></pre><p>参数说明：</p><ul><li>-1： 强制scp命令使用协议ssh1</li><li>-2： 强制scp命令使用协议ssh2</li><li>-4： 强制scp命令只使用IPv4寻址</li><li>-6： 强制scp命令只使用IPv6寻址</li><li>-B： 使用批处理模式（传输过程中不询问传输口令或短语）</li><li>-C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</li><li>-p：保留原文件的修改时间，访问时间和访问权限。</li><li>-q： 不显示传输进度条。</li><li>-r： 递归复制整个目录。</li><li>-v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li><li>-c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</li><li>-F ssh_config： 指定一个替代的ssh配置文件，此参数直接传递给ssh。</li><li>-i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</li><li>-l limit： 限定用户所能使用的带宽，以Kbit/s为单位。</li><li>-o ssh_option： 如果习惯于使用ssh_config(5)中的参数传递方式，</li><li>-P port：<strong>注意是大写的P, port是指定数据传输用到的端口号</strong></li><li>-S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</li></ul><hr /><p><strong>本机-&gt;远程</strong></p><p>目前我们处在IP为“192.168.60.133”的Linux系统下，计划将系统下的/home/ixdba/etc.tar.gz文件拷贝到IP为“192.168.60</p><p>168”的远程Linux系统中root用户下的/tmp目录下：</p><pre><code class="highlight plaintext">scp /home/etc.tar root@192.168.60.168:/tmp</code></pre><p>命令输入完毕，会要求输入“192.168.60.168”服务器root的密码，然后开始远程拷贝数据。</p><p><strong>远程-&gt;本机</strong></p><p>如果我们处在“192.168.60.168”服务器上，也可以使用下面的命令传输数据：</p><pre><code class="highlight plaintext">scp root@192.168.60.133:/home/etc.tar /tmp</code></pre><p>命令输入完毕，此时会要求输入“192.168.60.133”服务器root的密码，然后开始远程拷贝数据。</p><h3 id="ssh"><a class="markdownIt-Anchor" href="#ssh"></a> SSH</h3><p>通过网络来远程操控类 Unix 的操作系统已经有很多年了。早些年，在因特网普遍推广之前，有 一些受欢迎的程序被用来登录远程主机。它们是 rlogin 和 telnet 程序。然而这些程序，拥有和 ftp 程序 一样的致命缺点；它们以明码形式来传输所有的交流信息（包括登录命令和密码）。这使它们完全不 适合使用在因特网时代。</p><p>为了解决这个问题，开发了一款新的协议，叫做 SSH（Secure Shell）。 SSH 解决了这两个基本的和远端主机安全交流的问题。首先，它要认证远端主机是否为它 所知道的那台主机（这样就阻止了所谓的“中间人”的攻击），其次，它加密了本地与远程主机之间 所有的通讯信息。</p><p>SSH 由两部分组成。SSH 服务器运行在远端主机上运行，在端口号22上监听将要到来的连接，而 SSH 客户端用在本地系统中，用来和远端服务器通信。</p><p>大多数 Linux 发行版自带一个提供 SSH 功能的软件包，叫做 OpenSSH，来自于 BSD 项目。一些发行版 默认包含客户端和服务器端两个软件包（例如，Red Hat）,而另一些（比方说 Ubuntu）则只是提供客户端服务。为了能让系统接受远端的连接，它必须 安装 OpenSSH-server 软件包，配置，运行它，并且（如果系统正在运行，或者是在防火墙之后） 它必须允许在 TCP 端口号上接收网络连接。</p><p><strong>建立连接</strong></p><p>试用下述命令，然后输入正确的密码，即可连接到目标主机。</p><p>成功地输入密码之后，我们会接收到远端系统的 shell 提示符：</p><pre><code class="highlight plaintext"># ssh root@172.172.30.71root@172.172.30.71&#x27;s password: Last login: Wed Nov  4 09:46:17 2020 from 192.168.211.182[root@linux71 ~]#</code></pre><blockquote><p>远端 shell 会话一直存在，直到用户输入 exit 命令后，则关闭了远程连接。这时候，本地的 shell 会话 恢复，本地 shell 提示符重新出现。</p></blockquote><p>每建立一个新的连接，都会在 ~/.ssh/known_hosts 文件生成如下的一行话：</p><pre><code class="highlight plaintext">192.168.211.182 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBAeprXVlg+94HN0SGnFuFl2GdEShQ9sZTD5sDtAKd1ZX6ERPVsHhjoWhZxToY8JDI9Ng02xlc7/kr4Mvbk/tZI4=</code></pre><p>ssh 验证远端主机的真实性。如果远端主机不能成功地通过验证，则会提示以下信息：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ ssh remote-sys@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middleattack)!...</code></pre><p>有两种可能的情形会提示这些信息。第一，某个攻击者企图制造“中间人”袭击。这很少见， 因为每个人都知道 ssh 会针对这种状况发出警告。最有可能的罪魁祸首是远端系统已经改变了； 例如，它的操作系统或者是 SSH 服务器重新安装了。然而，为了安全起见，第一个可能性不应该 被轻易否定。当这条消息出现时，总要与远端系统的管理员查对一下。当确定了这条消息归结为一个良性的原因之后，那么在客户端更正问题就很安全了。 使用文本编辑器（可能是 vim）从文件~/.ssh/known_hosts 中删除废弃的钥匙， 就解决了问题。在上面的例子里，我们看到这样一句话：</p><pre><code class="highlight plaintext">Offending key in /home/me/.ssh/known_hosts:1</code></pre><p>这意味着文件 known_hosts 里面某一行包含攻击型的钥匙。从文件中删除这一行，则 ssh 程序 就能够从远端系统接受新的身份验证凭据。</p><hr /><p><strong>在远端主机执行命令</strong></p><pre><code class="highlight plaintext">[me@linuxbox ~]$ ssh root@172.172.30.71 &#x27;ls \*&#x27; &gt; dirlist.txtme@twin4&#x27;s password:[me@linuxbox ~]$</code></pre><blockquote><p>注意，上面的例子中使用了单引号。这样做是因为我们不想路径名展开操作在本地执行 ；而希望 它在远端系统中被执行。同样地，如果我们想要把输出结果重定向到远端主机的文件中，我们可以 把重定向操作符和文件名都放到单引号里面</p></blockquote><pre><code class="highlight plaintext">[me@linuxbox ~]$ ssh remote-sys &#x27;ls * &gt; dirlist.txt&#x27;</code></pre><h3 id="防火墙"><a class="markdownIt-Anchor" href="#防火墙"></a> 防火墙</h3><p>在RHEL 7系统中，firewalld防火墙取代了iptables防火墙.</p><p>其实，iptables与firewalld都不是真正的防火墙，它们都只是用来定义防火墙策略的防火墙管理工具而已，或者说，它们只是一种服务。</p><p>iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。换句话说，当前在Linux系统中其实存在多个防火墙管理工具，旨在方便运维人员管理Linux系统中的防火墙策略，我们只需要配置妥当其中的一个就足够了。</p><h4 id="打开防火墙"><a class="markdownIt-Anchor" href="#打开防火墙"></a> 打开防火墙</h4><pre><code class="highlight plaintext">systemctl start firewalld或者systemctl start Iptables</code></pre><h4 id="关闭防火墙"><a class="markdownIt-Anchor" href="#关闭防火墙"></a> 关闭防火墙</h4><pre><code class="highlight plaintext">systemctl stop firewalld或者systemctl stop Iptables</code></pre><h4 id="iptables"><a class="markdownIt-Anchor" href="#iptables"></a> iptables</h4><p>在早期的Linux系统中，默认使用的是iptables防火墙管理服务来配置防火墙。尽管新型的firewalld防火墙管理服务已经被投入使用多年，但是大量的企业在生产环境中依然出于各种原因而继续使用iptables。</p><h5 id="策略与规则链"><a class="markdownIt-Anchor" href="#策略与规则链"></a> 策略与规则链</h5><p>防火墙会从上至下的顺序来读取配置的策略规则，在找到匹配项后就立即结束匹配工作并去执行匹配项中定义的行为（即放行或阻止）。如果在读取完所有的策略规则之后没有匹配项，就去执行默认的策略。</p><p>一般而言，防火墙策略规则的设置有两种：一种是“通”（即放行），一种是“堵”（即阻止）。当防火墙的默认策略为拒绝时（堵），就要设置允许规则（通），否则谁都进不来；如果防火墙的默认策略为允许时，就要设置拒绝规则，否则谁都能进来，防火墙也就失去了防范的作用。</p><p>iptables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链，而规则链则依据数据包处理位置的不同进行分类，具体如下：</p><ul><li>在进行路由选择前处理数据包（PREROUTING）</li><li>处理流入的数据包（INPUT）</li><li>处理流出的数据包（OUTPUT）</li><li>处理转发的数据包（FORWARD）</li><li>在进行路由选择后处理数据包（POSTROUTING）</li></ul><p>一般来说，从内网向外网发送的流量一般都是可控且良性的，因此我们使用最多的就是INPUT规则链，该规则链可以增大黑客人员从外网入侵内网的难度。</p><blockquote><p>比如在您居住的社区内，物业管理公司有两条规定：禁止小商小贩进入社区；各种车辆在进入社区时都要登记。显而易见，这两条规定应该是用于社区的正门的（流量必须经过的地方），而不是每家每户的防盗门上。根据前面提到的防火墙策略的匹配顺序，可能会存在多种情况。比如，来访人员是小商小贩，则直接会被物业公司的保安拒之门外，也就无需再对车辆进行登记。如果来访人员乘坐一辆汽车进入社区正门，则“禁止小商小贩进入社区”的第一条规则就没有被匹配到，因此按照顺序匹配第二条策略，即需要对车辆进行登记。如果是社区居民要进入正门，则这两条规定都不会匹配到，因此会执行默认的放行策略。</p></blockquote><p>但是，仅有策略规则还不能保证社区的安全，保安还应该知道采用什么样的动作来处理这些匹配的流量，比如“允许”、“拒绝”、“登记”、“不理它”。这些动作对应到iptables服务的术语中分别是<strong>ACCEPT</strong>（允许流量通过）、<strong>REJECT</strong>（拒绝流量通过）、<strong>LOG</strong>（记录日志信息）、<strong>DROP</strong>（拒绝流量通过）。“允许流量通过”和“记录日志信息”都比较好理解，这里需要着重讲解的是REJECT和DROP的不同点。就DROP来说，它是直接将流量丢弃而且不响应；REJECT则会在拒绝流量后再回复一条“您的信息已经收到，但是被扔掉了”信息，从而让流量发送方清晰地看到数据被拒绝的响应信息。</p><blockquote><p>我们来举一个例子，让各位读者更直观地理解这两个拒绝动作的不同之处。比如有一天您正在家里看电视，突然听到有人敲门，您透过防盗门的猫眼一看是推销商品的，便会在不需要的情况下开门并拒绝他们（REJECT）。但如果您看到的是债主带了十几个小弟来讨债，此时不仅要拒绝开门，还要默不作声，伪装成自己不在家的样子（DROP）</p></blockquote><p>当把Linux系统中的防火墙策略设置为REJECT拒绝动作后，流量发送方会看到端口不可达的响应：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# ping -c 4 192.168.10.10PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.From 192.168.10.10 icmp_seq=1 Destination Port UnreachableFrom 192.168.10.10 icmp_seq=2 Destination Port UnreachableFrom 192.168.10.10 icmp_seq=3 Destination Port UnreachableFrom 192.168.10.10 icmp_seq=4 Destination Port Unreachable--- 192.168.10.10 ping statistics ---4 packets transmitted, 0 received, +4 errors, 100% packet loss, time 3002ms</code></pre><p>而把Linux系统中的防火墙策略修改成DROP拒绝动作后，流量发送方会看到响应超时的提醒。但是流量发送方无法判断流量是被拒绝，还是接收方主机当前不在线：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# ping -c 4 192.168.10.10PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data. --- 192.168.10.10 ping statistics ---4 packets transmitted, 0 received, 100% packet loss, time 3000ms</code></pre><h5 id="基本命令参数"><a class="markdownIt-Anchor" href="#基本命令参数"></a> 基本命令参数</h5><p>iptables命令可以根据流量的源地址、目的地址、传输协议、服务类型等信息进行匹配，一旦匹配成功，iptables就会根据策略规则所预设的动作来处理这些流量。另外，再次提醒一下，防火墙策略规则的匹配顺序是从上至下的，因此要把较为严格、优先级较高的策略规则放到前面，以免发生错误</p><p>表总结归纳了常用的iptables命令参数。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-P</td><td>设置默认策略</td></tr><tr><td>-F</td><td>清空规则链</td></tr><tr><td>-L</td><td>查看规则链</td></tr><tr><td>-A</td><td>在规则链的末尾加入新规则</td></tr><tr><td>-I num</td><td>在规则链的头部加入新规则</td></tr><tr><td>-D num</td><td>删除某一条规则</td></tr><tr><td>-s</td><td>匹配来源地址IP/MASK，加叹号“!”表示除这个IP外</td></tr><tr><td>-d</td><td>匹配目标地址</td></tr><tr><td>-i</td><td>网卡名称 匹配从这块网卡流入的数据</td></tr><tr><td>-o</td><td>网卡名称 匹配从这块网卡流出的数据</td></tr><tr><td>-p</td><td>匹配协议，如TCP、UDP、ICMP</td></tr><tr><td>—dport num</td><td>匹配目标端口号</td></tr><tr><td>—sport num</td><td>匹配来源端口号</td></tr></tbody></table><p><strong>在iptables命令后添加-L参数查看已有的防火墙规则链：</strong></p><pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination ACCEPT all -- anywhere anywhere ctstate RELATED,ESTABLISHEDACCEPT all -- anywhere anywhere INPUT_direct all -- anywhere anywhere INPUT_ZONES_SOURCE all -- anywhere anywhere INPUT_ZONES all -- anywhere anywhere ACCEPT icmp -- anywhere anywhere REJECT all -- anywhere anywhere reject-with icmp-host-prohibited………………省略部分输出信息………………</code></pre><p>在iptables命令后添加-F参数清空已有的防火墙规则链：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -F[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination ………………省略部分输出信息………………</code></pre><p>把INPUT规则链的默认策略设置为拒绝：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -P INPUT DROP[root@linuxprobe ~]# iptables -LChain INPUT (policy DROP)target prot opt source destination …………省略部分输出信息………………</code></pre><p>如前面所提到的防火墙策略设置无非有两种方式，一种是“通”，一种是“堵”，当把INPUT链设置为默认拒绝后，就要往里面写入允许策略了，否则所有流入的数据包都会被默认拒绝掉，同学们需要留意规则链的默认策略拒绝动作只能是DROP，而不能是REJECT。</p><p><strong>向INPUT链中添加允许ICMP流量进入的策略规则：</strong></p><p>在日常运维工作中，经常会使用ping命令来检查对方主机是否在线，而向防火墙的INPUT规则链中添加一条允许ICMP流量进入的策略规则就默认允许了这种ping命令检测行为。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -I INPUT -p icmp -j ACCEPT[root@linuxprobe ~]# ping -c 4 192.168.10.10PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.64 bytes from 192.168.10.10: icmp_seq=1 ttl=64 time=0.156 ms64 bytes from 192.168.10.10: icmp_seq=2 ttl=64 time=0.117 ms64 bytes from 192.168.10.10: icmp_seq=3 ttl=64 time=0.099 ms64 bytes from 192.168.10.10: icmp_seq=4 ttl=64 time=0.090 ms--- 192.168.10.10 ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 2999msrtt min/avg/max/mdev = 0.090/0.115/0.156/0.027 ms</code></pre><p><strong>删除INPUT规则链中刚刚加入的那条策略（允许ICMP流量），并把默认策略设置为允许：</strong></p><pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -D INPUT 1[root@linuxprobe ~]# iptables -P INPUT ACCEPT[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination………………省略部分输出信息………………</code></pre><p><strong>将INPUT规则链设置为只允许指定网段的主机访问本机的22端口，拒绝来自其他所有主机的流量：</strong></p><pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -I INPUT -s 192.168.10.0/24 -p tcp --dport 22 -j ACCEPT[root@linuxprobe ~]# iptables -A INPUT -p tcp --dport 22 -j REJECT[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:sshREJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable………………省略部分输出信息………………</code></pre><p><strong>向INPUT规则链中添加拒绝所有人访问本机12345端口的策略规则：</strong></p><pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -I INPUT -p tcp --dport 12345 -j REJECT[root@linuxprobe ~]# iptables -I INPUT -p udp --dport 12345 -j REJECT[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination REJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachableREJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachableACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:sshREJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable………………省略部分输出信息………………</code></pre><p><strong>向INPUT规则链中添加拒绝192.168.10.5主机访问本机80端口（Web服务）的策略规则：</strong></p><pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination REJECT tcp -- 192.168.10.5 anywhere tcp dpt:http reject-with icmp-port-unreachableREJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachableREJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachableACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:sshREJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable………………省略部分输出信息………………</code></pre><p><strong>向INPUT规则链中添加拒绝所有主机访问本机1000～1024端口的策略规则：</strong></p><pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -A INPUT -p tcp --dport 1000:1024 -j REJECT[root@linuxprobe ~]# iptables -A INPUT -p udp --dport 1000:1024 -j REJECT[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination REJECT tcp -- 192.168.10.5 anywhere tcp dpt:http reject-with icmp-port-unreachableREJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachableREJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachableACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:sshREJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachableREJECT tcp -- anywhere anywhere tcp dpts:cadlock2:1024 reject-with icmp-port-unreachableREJECT udp -- anywhere anywhere udp dpts:cadlock2:1024 reject-with icmp-port-unreachable</code></pre><h5 id="允许某个ip某个端口访问"><a class="markdownIt-Anchor" href="#允许某个ip某个端口访问"></a> 允许某个ip某个端口访问</h5><pre><code class="highlight plaintext">#拒绝所有iptables -I INPUT -p TCP --dport 80 -j DROP#允许46.166.150.22访问80端口iptables -I INPUT -s 46.166.150.22 -p TCP --dport 80 -j ACCEPT#--line-number参数会显示策略编号，该编号在删除策略时使用iptables -L -n --line-number#2是--line-number查到的，此句会删除第2条策略iptables -D INPUT 2</code></pre><h5 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h5><pre><code class="highlight plaintext">#增加，限制进iptables -A INPUT -p tcp -s 192.168.0.83 --sport 23 -j ACCEPT#增加，限制出iptables -A INPUT -p tcp -d 192.168.0.83 --dport 23 -j ACCEPT#删除iptables -D INPUT -p tcp -s 192.168.0.83 --sport 23 -j ACCEPT</code></pre><h4 id="firewalld"><a class="markdownIt-Anchor" href="#firewalld"></a> Firewalld</h4><p>RHEL 7系统中集成了多款防火墙管理工具，其中firewalld（Dynamic Firewall Manager of Linux systems，Linux系统的动态防火墙管理器）服务是默认的防火墙配置管理工具，它拥有基于CLI（命令行界面）和基于GUI（图形用户界面）的两种管理方式。</p><p>相较于传统的防火墙管理配置工具，firewalld支持动态更新技术并加入了区域（zone）的概念。简单来说，区域就是firewalld预先准备了几套防火墙策略集合（策略模板），用户可以根据生产场景的不同而选择合适的策略集合，从而实现防火墙策略之间的快速切换。例如，我们有一台笔记本电脑，每天都要在办公室、咖啡厅和家里使用。按常理来讲，这三者的安全性按照由高到低的顺序来排列，应该是家庭、公司办公室、咖啡厅。当前，我们希望为这台笔记本电脑指定如下防火墙策略规则：在家中允许访问所有服务；在办公室内仅允许访问文件共享服务；在咖啡厅仅允许上网浏览。在以往，我们需要频繁地手动设置防火墙策略规则，而现在只需要预设好区域集合，然后只需轻点鼠标就可以自动切换了，从而极大地提升了防火墙策略的应用效率。</p><p><strong>firewalld中常用的区域名称及策略规则</strong></p><table><thead><tr><th>区域</th><th>默认规则策略</th></tr></thead><tbody><tr><td>trusted</td><td>允许所有的数据包</td></tr><tr><td>home</td><td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关，则允许流量</td></tr><tr><td>internal</td><td>等同于home区域</td></tr><tr><td>work</td><td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、ipp-client与dhcpv6-client服务相关，则允许流量</td></tr><tr><td>public</td><td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、dhcpv6-client服务相关，则允许流量</td></tr><tr><td>external</td><td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td></tr><tr><td>dmz</td><td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td></tr><tr><td>block</td><td>拒绝流入的流量，除非与流出的流量相关</td></tr><tr><td>drop</td><td>拒绝流入的流量，除非与流出的流量相关</td></tr></tbody></table><h5 id="终端管理工具"><a class="markdownIt-Anchor" href="#终端管理工具"></a> 终端管理工具</h5><p>命令行终端是一种极富效率的工作方式，firewall-cmd是firewalld防火墙配置管理工具的CLI（命令行界面）版本。它的参数一般都是以“长格式”来提供的，大家不要一听到长格式就头大，因为RHEL 7系统支持部分命令的参数补齐，其中就包含这条命令（很酷吧）。也就是说，现在除了能用Tab键自动补齐命令或文件名等内容之外，还可以用Tab键来补齐表8-3中所示的长格式参数了。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>—get-default-zone</td><td>查询默认的区域名称</td></tr><tr><td>—set-default-zone=&lt;区域名称&gt;</td><td>设置默认的区域，使其永久生效</td></tr><tr><td>—get-zones</td><td>显示可用的区域</td></tr><tr><td>—get-services</td><td>显示预先定义的服务</td></tr><tr><td>—get-active-zones</td><td>显示当前正在使用的区域与网卡名称</td></tr><tr><td>—add-source=</td><td>将源自此IP或子网的流量导向指定的区域</td></tr><tr><td>—remove-source=</td><td>不再将源自此IP或子网的流量导向某个指定区域</td></tr><tr><td>—add-interface=&lt;网卡名称&gt;</td><td>将源自该网卡的所有流量都导向某个指定区域</td></tr><tr><td>—change-interface=&lt;网卡名称&gt;</td><td>将某个网卡与区域进行关联</td></tr><tr><td>—list-all</td><td>显示当前区域的网卡配置参数、资源、端口以及服务等信息</td></tr><tr><td>—list-all-zones</td><td>显示所有区域的网卡配置参数、资源、端口以及服务等信息</td></tr><tr><td>—add-service=&lt;服务名&gt;</td><td>设置默认区域允许该服务的流量</td></tr><tr><td>—add-port=&lt;端口号/协议&gt;</td><td>设置默认区域允许该端口的流量</td></tr><tr><td>—remove-service=&lt;服务名&gt;</td><td>设置默认区域不再允许该服务的流量</td></tr><tr><td>—remove-port=&lt;端口号/协议&gt;</td><td>设置默认区域不再允许该端口的流量</td></tr><tr><td>—reload</td><td>让“永久生效”的配置规则立即生效，并覆盖当前的配置规则</td></tr><tr><td>—panic-on</td><td>开启应急状况模式</td></tr><tr><td>—panic-off</td><td>关闭应急状况模式</td></tr></tbody></table><p>与Linux系统中其他的防火墙策略配置工具一样，使用firewalld配置的防火墙策略默认为运行时（Runtime）模式，又称为当前生效模式，而且随着系统的重启会失效。</p><p>如果想让配置策略一直存在，就需要使用永久（Permanent）模式了，方法就是在用firewall-cmd命令正常设置防火墙策略时添加—permanent参数，这样配置的防火墙策略就可以永久生效了。但是，永久生效模式有一个“不近人情”的特点，就是使用它设置的策略只有在系统重启之后才能自动生效。</p><p>如果想让配置的策略立即生效，需要手动执行firewall-cmd —reload命令。</p><p>查看firewalld服务当前所使用的区域：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --get-default-zonepublic</code></pre><p>查询eno16777728网卡在firewalld服务中的区域：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --get-zone-of-interface=eno16777728public</code></pre><p>把firewalld服务中eno16777728网卡的默认区域修改为external，并在系统重启后生效。分别查看当前与永久模式下的区域名称：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --permanent --zone=external --change-interface=eno16777728success[root@linuxprobe ~]# firewall-cmd --get-zone-of-interface=eno16777728public[root@linuxprobe ~]# firewall-cmd --permanent --get-zone-of-interface=eno16777728external</code></pre><p>把firewalld服务的当前默认区域设置为public：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --set-default-zone=publicsuccess[root@linuxprobe ~]# firewall-cmd --get-default-zonepublic</code></pre><p>启动/关闭firewalld防火墙服务的应急状况模式，阻断一切网络连接（当远程控制服务器时请慎用）：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --panic-onsuccess[root@linuxprobe ~]# firewall-cmd --panic-offsuccess</code></pre><p>查询public区域是否允许请求SSH和HTTPS协议的流量：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=sshyes[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=httpsno</code></pre><p>把firewalld服务中请求HTTPS协议的流量设置为永久允许，并立即生效：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --zone=public --add-service=httpssuccess[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-service=httpssuccess[root@linuxprobe ~]# firewall-cmd --reloadsuccess</code></pre><p>把firewalld服务中请求HTTP协议的流量设置为永久拒绝，并立即生效：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --remove-service=http success[root@linuxprobe ~]# firewall-cmd --reload success</code></pre><p>把在firewalld服务中访问8080和8081端口的流量策略设置为允许，但仅限当前生效：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --zone=public --add-port=8080-8081/tcpsuccess[root@linuxprobe ~]# firewall-cmd --zone=public --list-ports 8080-8081/tcp</code></pre><p><strong>把原本访问本机888端口的流量转发到22端口，要且求当前和长期均有效：</strong></p><ul><li>流量转发命令格式为firewall-cmd —permanent —zone=&lt;区域&gt; —add-forward-port=port=&lt;源端口号&gt;:proto=&lt;协议&gt;:toport=&lt;目标端口号&gt;:toaddr=&lt;目标IP地址&gt;</li></ul><pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-forward-port=port=888:proto=tcp:toport=22:toaddr=192.168.10.10success[root@linuxprobe ~]# firewall-cmd --reloadsuccess</code></pre><p>在客户端使用ssh命令尝试访问192.168.10.10主机的888端口：</p><pre><code class="highlight plaintext">[root@client A ~]# ssh -p 888 192.168.10.10The authenticity of host &#x27;[192.168.10.10]:888 ([192.168.10.10]:888)&#x27; can&#x27;t be established.ECDSA key fingerprint is b8:25:88:89:5c:05:b6:dd:ef:76:63:ff:1a:54:02:1a.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &#x27;[192.168.10.10]:888&#x27; (ECDSA) to the list of known hosts.root@192.168.10.10&#x27;s password:此处输入远程root管理员的密码Last login: Sun Jul 19 21:43:48 2017 from 192.168.10.10</code></pre><p>firewalld中的富规则表示更细致、更详细的防火墙策略配置，它可以针对系统服务、端口号、源地址和目标地址等诸多信息进行更有针对性的策略配置。它的优先级在所有的防火墙策略中也是最高的。比如，我们可以在firewalld服务中配置一条富规则，使其拒绝192.168.10.0/24网段的所有用户访问本机的ssh服务（22端口）：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.10.0/24&quot; service name=&quot;ssh&quot; reject&quot;success[root@linuxprobe ~]# firewall-cmd --reloadsuccess</code></pre><h5 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例</h5><pre><code class="highlight plaintext">#增加规则firewall-cmd --permanent --direct --add-rule ipv4/ipv6 filter OUTPUT 0 -p tcp --dport 1:65535 -d 0.0.0.0/0 -j DROPfirewall-cmd --permanent --direct --add-rule ipv4/ipv6 filter INPUT 0 -p tcp --sport 1:65535 -s 0.0.0.0/0 -j DROP#删除规则firewall-cmd --permanent --direct --remove-rule ipv4/ipv6 filter INPUT 0 -p tcp --sport 1:65535 -s 0.0.0.0/0 -j DROP</code></pre><h5 id="图形管理工具"><a class="markdownIt-Anchor" href="#图形管理工具"></a> 图形管理工具</h5><p><strong>firewall-config</strong>是firewalld防火墙配置管理工具的GUI（图形用户界面）版本，几乎可以实现所有以命令行来执行的操作。毫不夸张的说，即使读者没有扎实的Linux命令基础，也完全可以通过它来妥善配置RHEL 7中的防火墙策略。</p><pre><code class="highlight plaintext">$ firewall-config</code></pre><p><img src="image/-26.png" alt="-26.png" /></p><blockquote><p>在使用firewall-config工具配置完防火墙策略之后，无须进行二次确认，因为只要有修改内容，它就自动进行保存</p></blockquote><p>实例（配置8080-8088的http请求允许访问）：</p><ul><li>我们先将当前区域中请求http服务的流量设置为允许，但仅限当前生效<br /><img src="image/-27.png" alt="-27.png" /></li><li>尝试添加一条防火墙策略规则，使其放行访问8080～8088端口（TCP协议）的流量，并将其设置为永久生效，以达到系统重启后防火墙策略依然生效的目的<br /><img src="image/-28.png" alt="-28.png" /></li><li>配置完毕之后，还需要在Options菜单中单击Reload Firewalld命令，让配置的防火墙策略立即生效<br /><img src="image/-29.png" alt="-29.png" /></li></ul><p>实例2（使用SNAT技术处理过的网络）</p><ul><li>前面在讲解firewall-config工具的功能时，曾经提到了SNAT（Source Network Address Translation，源网络地址转换）技术。SNAT是一种为了解决IP地址匮乏而设计的技术，它可以使得多个内网中的用户通过同一个外网IP接入Internet。</li><li>大家可以看一下在网络中不使用SNAT技术（见图1）和使用SNAT技术（见图2）时的情况。<ul><li>在图1所示的局域网中有多台PC，如果网关服务器没有应用SNAT技术，则互联网中的网站服务器在收到PC的请求数据包，并回送响应数据包时，将无法在网络中找到这个私有网络的IP地址，所以PC也就收不到响应数据包了。</li><li>在图2所示的局域网中，由于网关服务器应用了SNAT技术，所以互联网中的网站服务器会将响应数据包发给网关服务器，再由后者转发给局域网中的PC。</li><li><img src="image/-30.png" alt="-30.png" /></li></ul></li><li>使用iptables命令实现SNAT技术是一件很麻烦的事情，但是在firewall-config中却是小菜一碟了。用户只需按照图8-8进行配置，并选中Masquerade zone复选框，就自动开启了SNAT技术。<img src="image/-31.png" alt="-31.png" /></li></ul><p>实例3：</p><ul><li>为了让大家直观查看不同工具在实现相同功能的区别，这里使用firewall-config工具重新演示了前面使用firewall-cmd来配置防火墙策略规则，将本机888端口的流量转发到22端口，且要求当前和长期均有效<img src="image/-32.png" alt="-32.png" /></li><li>让防火墙策略立即生效</li><li><img src="image/-33.png" alt="-33.png" /></li></ul><p>实例4：</p><ul><li>配置富规则，让192.168.10.20主机访问到本机的1234端口号<br /><img src="image/-34.png" alt="-34.png" /></li></ul><h3 id="开放指定端口"><a class="markdownIt-Anchor" href="#开放指定端口"></a> 开放指定端口</h3><pre><code class="highlight plaintext">1、开启防火墙 systemctl start firewalld2、开放指定端口firewall-cmd --zone=public --add-port=1935/tcp --permanent 命令含义：--zone #作用域--add-port=1935/tcp  #添加端口，格式为：端口/通讯协议--permanent  #永久生效，没有此参数重启后失效3、重启防火墙firewall-cmd --reload4、查看端口号netstat -ntlp   //查看当前所有tcp端口·netstat -ntulp |grep 1935   //查看所有1935端口使用情况·</code></pre><h3 id="服务的访问控制列表"><a class="markdownIt-Anchor" href="#服务的访问控制列表"></a> 服务的访问控制列表</h3><p>TCP Wrappers是RHEL 7系统中默认启用的一款流量监控程序，它能够根据来访主机的地址与本机的目标服务程序作出允许或拒绝的操作。换句话说，Linux系统中其实有两个层面的防火墙，第一种是前面讲到的基于TCP/IP协议的流量过滤工具，而TCP Wrappers服务则是能允许或禁止Linux系统提供服务的防火墙，从而在更高层面保护了Linux系统的安全运行。</p><p>TCP Wrappers服务的防火墙策略由两个控制列表文件所控制，用户可以编辑允许控制列表文件来放行对服务的请求流量，也可以编辑拒绝控制列表文件来阻止对服务的请求流量。控制列表文件修改后会立即生效，系统将会先检查<strong>允许控制列表文件（/etc/hosts.allow）</strong>，如果匹配到相应的允许策略则放行流量；如果没有匹配，则去进一步匹配<strong>拒绝控制列表文件（/etc/hosts.deny）</strong>，若找到匹配项则拒绝该流量。如果这两个文件全都没有匹配到，则默认放行流量。</p><table><thead><tr><th>客户端类型</th><th>示例</th><th>满足示例的客户端列表</th></tr></thead><tbody><tr><td>单一主机</td><td>192.168.10.10</td><td>IP地址为192.168.10.10的主机</td></tr><tr><td>指定网段</td><td>192.168.10.</td><td>IP段为192.168.10.0/24的主机</td></tr><tr><td>指定网段</td><td>192.168.10.0/255.255.255.0</td><td>IP段为192.168.10.0/24的主机</td></tr><tr><td>指定DNS后缀</td><td>.linuxprobe.com</td><td>所有DNS后缀为.linuxprobe.com的主机</td></tr><tr><td>指定主机名称</td><td><a href="http://www.linuxprobe.com">www.linuxprobe.com</a></td><td>主机名称为www.linuxprobe.com的主机</td></tr><tr><td>指定所有客户端</td><td>ALL</td><td>所有主机全部包括在内</td></tr></tbody></table><p>在配置TCP Wrappers服务时需要遵循两个原则：</p><ul><li>编写拒绝策略规则时，填写的是服务名称，而非协议名称；</li><li>建议先编写拒绝策略规则，再编写允许策略规则，以便直观地看到相应的效果。</li></ul><p>下面编写拒绝策略规则文件，禁止访问本机sshd服务的所有流量（无须/etc/hosts.deny文件中修改原有的注释信息）</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# vim /etc/hosts.deny## hosts.deny This file contains access rules which are used to# deny connections to network services that either use# the tcp_wrappers library or that have been# started through a tcp_wrappers-enabled xinetd.## The rules in this file can also be set up in# /etc/hosts.allow with a &#x27;deny&#x27; option instead.## See &#x27;man 5 hosts_options&#x27; and &#x27;man 5 hosts_access&#x27;# for information on rule syntax.# See &#x27;man tcpd&#x27; for information on tcp_wrapperssshd:*[root@linuxprobe ~]# ssh 192.168.10.10ssh_exchange_identification: read: Connection reset by peer</code></pre><p>接下来，在允许策略规则文件中添加一条规则，使其放行源自192.168.10.0/24网段，访问本机sshd服务的所有流量。可以看到，服务器立刻就放行了访问sshd服务的流量，效果非常直观：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# vim /etc/hosts.allow## hosts.allow This file contains access rules which are used to# allow or deny connections to network services that# either use the tcp_wrappers library or that have been# started through a tcp_wrappers-enabled xinetd.## See &#x27;man 5 hosts_options&#x27; and &#x27;man 5 hosts_access&#x27;# for information on rule syntax.# See &#x27;man tcpd&#x27; for information on tcp_wrapperssshd:192.168.10.[root@linuxprobe ~]# ssh 192.168.10.10The authenticity of host &#x27;192.168.10.10 (192.168.10.10)&#x27; can&#x27;t be established.ECDSA key fingerprint is 70:3b:5d:37:96:7b:2e:a5:28:0d:7e:dc:47:6a:fe:5c.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &#x27;192.168.10.10&#x27; (ECDSA) to the list of known hosts.root@192.168.10.10&#x27;s password: Last login: Wed May 4 07:56:29 2017[root@linuxprobe ~]#</code></pre><h2 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h2><h3 id="dirnamebasename截取路径"><a class="markdownIt-Anchor" href="#dirnamebasename截取路径"></a> dirname/basename(截取路径)</h3><p><strong>dirname</strong> 命令去除文件名中的非目录部分，删除最后一个“\”后面的路径，显示父目录。</p><p>语法：</p><pre><code class="highlight plaintext">dirname [选项] 参数</code></pre><p>实例：</p><pre><code class="highlight plaintext">[root@adm182 t3]# dirname /opt/data/files/outputfiles/libo/t3/SDM_TEST_NEW_SENSITIVE.txt/opt/data/files/outputfiles/libo/t3</code></pre><hr /><p><strong>basename</strong> 命令用于打印目录或者文件的基本名称，显示最后的目录名或文件名。</p><p>语法：</p><pre><code class="highlight plaintext">basename [选项] 参数</code></pre><p>实例：</p><pre><code class="highlight plaintext">[root@adm182 t3]# basename /opt/data/files/outputfiles/libo/t3/SDM_TEST_NEW_SENSITIVE.txtSDM_TEST_NEW_SENSITIVE.txt</code></pre><h3 id="w3m"><a class="markdownIt-Anchor" href="#w3m"></a> w3m</h3><p>安装：</p><pre><code class="highlight plaintext">yum -y install epel-releaseyum -y install w3m</code></pre><p>使用：</p><pre><code class="highlight plaintext">w3m www.baidu.com</code></pre><p><img src="image/-35.png" alt="-35.png" /></p><p>页面操作：</p><table><thead><tr><th>操作</th><th>快捷键</th></tr></thead><tbody><tr><td><strong>向下翻页</strong></td><td>Space,C-v</td></tr><tr><td>向上翻页</td><td>b,ESC v</td></tr><tr><td>焦点向右</td><td>l,C-f</td></tr><tr><td>焦点向左</td><td>h,C-b</td></tr><tr><td>焦点向下</td><td>j,C-n</td></tr><tr><td>焦点向上</td><td>k,C-p</td></tr><tr><td>向下滚动一行</td><td>J</td></tr><tr><td>向上滚动一行</td><td>K</td></tr><tr><td>到行首</td><td>^,C-a</td></tr><tr><td>到行尾</td><td>$,C-e</td></tr><tr><td>到下一个单词</td><td>w</td></tr><tr><td>到上一个单词</td><td>W</td></tr><tr><td>右移一屏</td><td>&gt;</td></tr><tr><td>左移一屏</td><td>&lt;</td></tr><tr><td>屏幕右移一列</td><td>.</td></tr><tr><td>屏幕左移一列</td><td>,</td></tr><tr><td>到首行</td><td>g,M-&lt;</td></tr><tr><td>到末行</td><td>G,M-&gt;</td></tr><tr><td>到指定行</td><td>ESC g</td></tr><tr><td>当前行居中</td><td>Z</td></tr><tr><td>当前列居中</td><td>z</td></tr><tr><td>转到下个超链接</td><td>TAB</td></tr><tr><td>到上个超链接</td><td>C-u,ESC TAB</td></tr><tr><td>到第一个超链接</td><td>[</td></tr><tr><td>到最后一个超链接</td><td>]</td></tr><tr><td>询问退出/直接退出</td><td>q/Q</td></tr></tbody></table><p>超链接操作：</p><table><thead><tr><th>操作</th><th>快捷键</th></tr></thead><tbody><tr><td>打开超链接</td><td>Enter</td></tr><tr><td>链接另存为</td><td>a, ESC Enter</td></tr><tr><td>查看链接</td><td>url u</td></tr><tr><td>查看图片</td><td>url i</td></tr><tr><td>查看图片</td><td>I</td></tr><tr><td>图片另存为</td><td>ESC I</td></tr><tr><td>标记字符串为锚点</td><td>:</td></tr><tr><td>查看当前页面的 URL</td><td>c</td></tr><tr><td>显示当前页面属性</td><td>=</td></tr><tr><td>查看当前行号</td><td>C-g</td></tr><tr><td>查看历史记录</td><td>C-h</td></tr><tr><td>提交表单</td><td>F</td></tr><tr><td>用外部浏览器打开当前页面</td><td>M</td></tr><tr><td>用外部浏览器打开链接</td><td>ESC M</td></tr><tr><td>标记 ID 串为锚点</td><td>ESC</td></tr></tbody></table><p>文件流操作</p><table><thead><tr><th>操作</th><th>快捷键</th></tr></thead><tbody><tr><td>打开 URL</td><td>U</td></tr><tr><td>打开文件</td><td>V</td></tr><tr><td>执行外部命令并导入</td><td>@</td></tr><tr><td>执行外部命令并浏览</td><td>#</td></tr></tbody></table><p>缓存操作</p><table><thead><tr><th>操作</th><th>快捷键</th></tr></thead><tbody><tr><td>返回</td><td>B</td></tr><tr><td>查看源代码</td><td>v</td></tr><tr><td>选择缓存</td><td>s</td></tr><tr><td>编辑缓存代码</td><td>E</td></tr><tr><td>重画屏幕</td><td>C-l</td></tr><tr><td>刷新</td><td>R</td></tr><tr><td>页面另存为</td><td>S</td></tr><tr><td>源码另存为</td><td>ESC s</td></tr><tr><td>编辑图片</td><td>ESC e</td></tr></tbody></table><p>标签操作</p><table><thead><tr><th>操作</th><th>快捷键</th></tr></thead><tbody><tr><td>在新标签页打开链接</td><td>Ctrl-t</td></tr><tr><td>关闭当前标签</td><td>Ctrl-q</td></tr><tr><td>跳到下一个标签</td><td>}</td></tr><tr><td>跳到前一个标签</td><td>{</td></tr></tbody></table><h3 id="split"><a class="markdownIt-Anchor" href="#split"></a> split</h3><p>Linux split命令用于将一个文件分割成数个。该指令将大文件分割成较小的文件，在默认情况下将按照每1000行切割成一个小文件。</p><p>语法：</p><pre><code class="highlight plaintext">split [--help][--version][-&lt;行数&gt;][-b &lt;字节&gt;][-C &lt;字节&gt;][-l &lt;行数&gt;][要切割的文件][输出文件名]</code></pre><p>参数：</p><ul><li>-&lt;行数&gt; : 指定每多少行切成一个小文件</li><li>-b&lt;字节&gt; : 指定每多少字节切成一个小文件</li><li>–help : 在线帮助</li><li>–version : 显示版本信息</li><li>-C&lt;字节&gt; : 与参数&quot;-b&quot;相似，但是在切 割时将尽量维持每行的完整性</li><li>[输出文件名] : 设置切割后文件的前置文件名， split会自动在前置文件名后再加上编号</li></ul><p>示例：</p><pre><code class="highlight plaintext">模式一：指定分割后文件行数对与txt文本文件，可以通过指定分割后文件的行数来进行文件分割。split -l 300 large_file.txt new_file_prefix模式二：指定分割后文件大小split -b 10m server.log waynelog</code></pre><p><strong>合并方式</strong></p><pre><code class="highlight plaintext">cat small_files* &gt; large_file</code></pre><h3 id="cpulimit"><a class="markdownIt-Anchor" href="#cpulimit"></a> cpulimit</h3><p>Cpulimit 是一个<strong>限制进程的CPU使用率</strong>的工具</p><h4 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h4><p><strong>网络安�</strong>�</p><p>CPULimit 并不是系统自带的工具，使用前要先安装。在 <strong>Debian 或 Ubuntu</strong> 系列的 Linux 中，可以使用 apt 来安装：</p><pre><code class="highlight plaintext">apt-get install cpulimit</code></pre><p>若在 <strong>CentOS、RHEL</strong> 或者是 Fedora Linux 中，可在启用 EPEL 套件库后，再以 yum 安装：</p><pre><code class="highlight plaintext">yum -y install cpulimit</code></pre><p><strong>编译安�</strong>�</p><pre><code class="highlight plaintext">wget -O cpulimit.zip https://github.com/opsengine/cpulimit/archive/master.zipunzip cpulimit.zipcd cpulimit-mastermakesudo cp src/cpulimit /usr/bin</code></pre><h4 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h4><pre><code class="highlight plaintext">#限制进程名cpulimit -e httpd -l 40 #限制httpd（进程名）的cpu使用率为40%#限制路径cpulimit -e /usr/local/bin/httpd -l 40#限制pidcpulimit -p 2960 -l 55 #限制pid为2960的进程的CPU占用为55%#直接使用cpulimit启动进程#md5sum /dev/urandom为测试程序，模拟cpu跑满的场景cpulimit --limit 50 -- md5sum /dev/urandomcpulimit --limit 50 -- /opt/adm/sdm/jdk/bin/java -jar /opt/adm/sdm/sdm_server-5.0.0.jar</code></pre><p><strong>后台运行</strong></p><p>cpulimit 在执行时也会占用一个终端机，若想让 cpulimit 在后台运行，可加上 --background 参数：</p><pre><code class="highlight plaintext">cpulimit --pid 21203 --limit 50 --background</code></pre><p><strong>过高关闭</strong></p><p>cpulimit 配合 --limit 参数可以限制进程的 CPU 用量上限值，如果进程超过这个上限值，预设会调节 CPU 用量，而如果想要在 CPU 用量过高时直接中止进程，可以加上 –-kill 参数：</p><pre><code class="highlight plaintext">cpulimit --pid 21203 --limit 50 --kill</code></pre><p><strong>自动离开</strong></p><p>在默认的状况下，cpulimit 在执行时若没有发现指定的进程（或是指定的进程已经中止了），它还是会持续等待并监控系统的进程，只要有发现符合条件的进程，就会继续进行 CPU 用量的控制。若想让 cpulimit 在找不到目标进程时自动离开，可以加上 --lazy 参数：</p><pre><code class="highlight plaintext">cpulimit --exe md5sum --limit 50 --lazy</code></pre><p><strong>使用例子</strong></p><p>在撰写 bash 脚本时，我们可以先执行一个进程，紧接着从 bash 的 $! 变量读取出前一个执行进程的 PID，这样就可以不需要手动查出进程的 PID 了：</p><pre><code class="highlight plaintext"># 运行进程md5sum /dev/urandom &amp;# 限制上一个进程的 CPU 用量cpulimit --pid $! --limit 50</code></pre>]]>
    </content>
    <id>http://example.com/2022/12/12/Linux/</id>
    <link href="http://example.com/2022/12/12/Linux/"/>
    <published>2022-12-12T05:00:00.000Z</published>
    <summary>本文详细介绍了Linux的核心概念、常用命令，权限，系统命令，归档备份，网络系统，vim，程序管理，环境变量，管道符，重定向，磁盘。</summary>
    <title>Linux</title>
    <updated>2026-02-26T08:53:45.746Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    <content>
      <![CDATA[<h1 id="jvm"><a class="markdownIt-Anchor" href="#jvm"></a> $JVM</h1><h1 id="jvm-2"><a class="markdownIt-Anchor" href="#jvm-2"></a> JVM</h1><ul><li><a href="">JVM</a><ul><li><a href="">JVM概述</a><ul><li><a href="">JVM常识</a></li><li><a href="">JVM分类</a></li><li><a href="">HotSpot</a></li><li><a href="">JVM架构理解</a></li><li><a href="">JIT即时编译器</a></li><li><a href="">JIT编译器优化</a></li></ul></li><li><a href="">CLASS文件</a><ul><li><a href="">class文件概述</a></li><li><a href="">class常量池理解</a></li><li><a href="">class文件中的应用和特殊字符串</a></li></ul></li><li><a href="">类加载子系统</a><ul><li><a href="">JVM程序执行流程</a></li><li><a href="">类加载过程</a></li><li><a href="">类加载的时机</a></li><li><a href="">类加载器</a></li><li><a href="">自定义类加载器</a></li><li><a href="">双亲委派模型</a></li><li><a href="">破坏双亲委派模型</a></li></ul></li><li><a href="">运行时数据区</a><ul><li><a href="">程序计数器</a></li><li><a href="">Java虚拟机栈</a><ul><li><a href="">栈帧</a></li><li><a href="">局部变量表</a></li><li><a href="">操作数栈</a></li><li><a href="">动态连接</a></li><li><a href="">方法返回</a></li><li><a href="">附加信息/栈异常</a></li></ul></li><li><a href="">本地方法栈</a><ul><li><a href="">介绍</a></li><li><a href="">使用流程</a></li></ul></li><li><a href="">Java内存模型</a></li><li><a href="">JVM调优</a><ul><li><a href="">取消伸缩区</a></li><li><a href="">GC处理流程</a></li><li><a href="">查看垃圾回收</a></li><li><a href="">内存回收算法</a></li></ul></li><li><a href="">Java堆</a><ul><li><a href="">堆分类</a></li><li><a href="">对象创建</a></li><li><a href="">内存分配</a></li><li><a href="">对象的访问</a></li><li><a href="">数组内存分析</a></li></ul></li><li><a href="">方法区</a><ul><li><a href="">永久代、方法区、元空间的关系</a></li><li><a href="">PermGen(永久代)</a></li><li><a href="">Metaspace(元空间)</a></li></ul></li><li><a href="">运行时常量池/字符串常量�</a>�</li></ul></li><li><a href="">JVM如何运行字节码</a></li><li><a href="">JVM堆溢出分析</a><ul><li><a href="">jconsole内存监控工具</a></li><li><a href="">jmap内存分析工具</a></li></ul></li><li><a href="">JVM远程debug</a></li></ul></li></ul><h2 id="jvm概述"><a class="markdownIt-Anchor" href="#jvm概述"></a> JVM概述</h2><h3 id="jvm常识"><a class="markdownIt-Anchor" href="#jvm常识"></a> JVM常识</h3><p><strong>程序的执行方式有哪些？</strong></p><ul><li>主要有三种：<strong>静态编译执行</strong>、<strong>动态编译执行</strong>和<strong>动态解释执行</strong></li></ul><blockquote><p>注意：此处所说的编译指的是编译成可让操作系统直接执行的机器码</p></blockquote><hr /><p><strong>字节码和机器码的区别？</strong></p><p>机器码是电脑CPU直接读取运行的机器指令，运行速度最快，但是非常晦涩难懂，也比较难编写，一般从业人员接触不到。</p><p>字节码是一种中间状态（中间码）的二进制代码（文件）。需要直译器转译后才能成为机器码</p><hr /><p><strong>JDK,JRE与JVM的关系是？</strong></p><hr /><p><strong>OracleJDK和openJDK的关系是？</strong></p><p>查看JDK的版本</p><pre><code class="highlight plaintext">java -version</code></pre><ul><li>如果是SUN/OracleJDK，显示信息为</li></ul><blockquote><p><code>Java HotSpot(TM) 64-Bit Server VM</code>表明，此JDK的JVM是Oracle的64位的HotSpot虚拟机；运行在Server模式下(虚拟机有Server和Client两种运行模式).</p></blockquote><blockquote><p><code>Java(TM) SE Runtime Environment (build 1.8.0_162-b12)</code> 是Java运行时环境(即JRE)的版本信息.</p></blockquote><ul><li>如果是OpenJDK，显示信息为：</li></ul><pre><code class="highlight plaintext">[root@localhost ~]# java -versionopenjdk version &quot;1.8.0_144&quot;OpenJDK Runtime Environment (build 1.8.0_144-b01)OpenJDK 64-Bit Server VM (build 25.144-b01, mixed mode)</code></pre><hr /><p><strong>什么是OpenJDK</strong></p><p>Sun发布的OpenJDK是一款只能运行在i386和AMD-64机器上的软件</p><ul><li><strong>OpenJDK 的来历</strong></li></ul><p>Java由SUN公司(Sun Microsystems, 发起于美国斯坦福大学, SUN是Stanford University Network的缩写)发明, 2006年SUN公司将Java开源, 此时的JDK即为OpenJDK.</p><p>也就是说, OpenJDK是Java SE的开源实现, 它由SUN和Java社区提供支持, 2009年Oracle收购了Sun公司,自此Java的维护方之一的SUN也变成了Oracle</p><p>大多数JDK都是在OpenJDK的基础上编写实现的, 比如IBM J9, Azul Zulu, Azul Zing和Oracle JDK. 几乎所有的所有JDK都派生自OpenJDK, 它们之间不同的是许可证:</p><blockquote><p>OpenJDK根据许可证GPL v2发布;</p></blockquote><blockquote><p>Oracle JDK根据Oracle二进制代码许可协议获得许可.</p></blockquote><ul><li><strong>OracleJDK的来历</strong></li></ul><p>Oracle JDK之前被称为SUN JDK, 这是在2009年Oracle收购SUN公司之前, 收购后被命名为Oracle JDK.</p><p>实际上, Oracle JDK是基于OpenJDK源代码构建的, 因此Oracle JDK和OpenJDK之间没有重大的技术差异.</p><p>Oracle的项目发布经理Joe Darcy在OSCON 2011 上对两者关系的介绍也证实了OpenJDK 7和Oracle JDK 7在程序上是非常接近的, 两者共用了大量相同的代码(如下图), 注意: 图中提示了两者共同代码的占比要远高于图形上看到的比例, 所以我们编译的OpenJDK基本上可以认为性能、功能和执行逻辑上都和官方的Oracle JDK是一致的.</p><ul><li><strong>Oracle JDK与OpenJDK的区别</strong></li></ul><blockquote><p>OpenJDK使用的是开源免费的FreeType, 可以按照GPL v2许可证使用.GPL V2允许在商业上使用;</p></blockquote><blockquote><p>Oracle JDK则采用JRL(Java Research License, Java研究授权协议) 放出.JRL只允许个人研究使用,要获得Oracle JDK的商业许可证, 需要联系Oracle的销售人员进行购买</p></blockquote><hr /><p><strong>JRockit是Oracle的JVM, 从Java SE 7开始, HotSpot和JRockit合并为一个JVM</strong>.</p><ul><li><strong>JVM和Hotspot的关系是什么？</strong></li></ul><p>JVM是《JVM虚拟机规范》中提出来的规范</p><p>Hotspot是使用JVM规范的商用产品，除此之外还有Oracle JRockit、IBM的J9也是JVM产品</p><ul><li><p><strong>JVM和Java的关系是什么？</strong></p></li><li><p><strong>JVM的client运行模式和server运行模式的区别是什么？</strong></p></li></ul><p>JVM有两种运行模式<strong>Server</strong>与<strong>Client</strong>。</p><p>两种模式的区别在于，Client模式启动速度较快，Server模式启动较慢；但是启动进入稳定期长期运行之后Server模式的程序运行速度比Client要快很多。这是因为Server模式启动的JVM采用的是重量级的虚拟机，对程序采用了更多的优化；而Client模式启动的JVM采用的是轻量级的虚拟机。所以Server启动慢，但稳定后速度比Client远远要快。</p><h3 id="jvm分类"><a class="markdownIt-Anchor" href="#jvm分类"></a> JVM分类</h3><ul><li>Java是直接通过指针进行的程序访问，所以他没有采用句柄的形式操作，这样使得程序的性能更高。</li><li>传统意义来讲，JVM一共分为三类（虚拟机是一个公共标准）<ul><li>SUN：从JDK1.2开始使用了HotSpot虚拟机标准（06年开源，利用C++实现，一些JNI部分使用的是系统提供的C程序实现的，JIT即使编译器）</li><li>BEA：使用了JRockit虚拟机标准，例如：WebLogic</li><li>IBM：开发了JVM’s(J9)虚拟机</li></ul></li><li>Oracle后来通过收购得到了：SUN与BEA，那么Oracle有了两个虚拟机标准</li></ul><h3 id="hotspot"><a class="markdownIt-Anchor" href="#hotspot"></a> HotSpot</h3><pre><code class="highlight plaintext">java -version</code></pre><p>获取信息：</p><pre><code class="highlight plaintext">java version &quot;1.8.0_201&quot;Java(TM) SE Runtime Environment (build 1.8.0_201-b09)Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)</code></pre><p><strong>虚拟机提供有三种处理模式：</strong></p><ul><li>混合模式：Java -version</li><li>[禁用JIT]纯解释模式：java Xint -version</li><li>纯编译模式：java -Xcomp -version</li></ul><p><strong>运行模式：</strong></p><ul><li>[client]客户端运行：启动速度快，但是中间程序的执行慢，占用内存小</li><li>[server]服务器端运行：启动速度慢，占用内存多，执行效率高</li></ul><p>修改路径：</p><pre><code class="highlight plaintext">D:\java1.8\jdk1.8.0_201\lib\jvm.cfg</code></pre><h3 id="jvm架构理解"><a class="markdownIt-Anchor" href="#jvm架构理解"></a> JVM架构理解</h3><p><strong>解析器与JIT即时编译器</strong></p><p>在部分商用虚拟机中（如HotSpot），Java程序最初是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为<strong>即时编译器</strong>（Just In Time Compiler，下文统称JIT编译器）</p><p>由于Java虚拟机规范并没有具体的约束规则去限制即使编译器应该如何实现，所以这部分功能完全是与虚拟机具体实现相关的内容，如无特殊说明，我们提到的编译器、即时编译器都是指Hotspot虚拟机内的即时编译器，虚拟机也是特指HotSpot虚拟机</p><p>我们的JIT是属于动态编译方式的，<strong>动态编译</strong>（dynamic compilation）指的是“在运行时进行编译”；与之相对的是事前编译（ahead-of-time compilation，简称AOT），也叫<strong>静态编译</strong>（staticcompilation）。</p><p>JIT编译（just-in-time compilation）狭义来说是当某段代码即将第一次被执行时进行编译，因而叫“即时编译”。<strong>JIT编译是动态编译的一种特例</strong>。JIT编译一词后来被泛化，时常与动态编译等价；但要注意广义与狭义的JIT编译所指的区别</p><hr /><p><strong>Java编译成字节码、动态编译和解释为机器码的过程分析：</strong></p><p><strong>编译器和解释器的协调工作流程：</strong></p><h3 id="jit即时编译器"><a class="markdownIt-Anchor" href="#jit即时编译器"></a> JIT即时编译器</h3><p><strong>为什么HotSpot虚拟机要使用解释器与编译器并存的架构？</strong></p><p>尽管并不是所有的Java虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚拟机（如HotSpot），都同时包含解释器和编译器。</p><hr /><p><strong>解释器与编译器两者各有优势：</strong></p><p>当程序需要<strong>迅速启动和执行</strong>的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取<strong>更高的执行效率</strong>。</p><p>当程序运行环境中<strong>内存资源限制较大</strong>（如部分嵌入式系统中），可以<strong>使用解释器执行节约内存</strong>，反之可以使用<strong>编译执行来提升效率</strong>。</p><hr /><p><strong>编译的时间开销</strong></p><p>解释器的执行，抽象的看是这样的：</p><ul><li>输入的代码 -&gt; [ 解释器 解释执行 ] -&gt; 执行结果</li></ul><p>而要JIT编译然后再执行的话，抽象的看则是：</p><ul><li>输入的代码 -&gt; [ 编译器 编译 ] -&gt; 编译后的代码 -&gt; [ 执行 ] -&gt; 执行结果</li></ul><blockquote><p>说JIT比解释快，其实说的是“执行编译后的代码”比“解释器解释执行”要快，并不是说“编译”这个动作比“解释”这个动作快。JIT编译再怎么快，至少也比解释执行一次略慢一些，而要得到最后的执行结果还得再经过一个“执行编译后的代码”的过程。所以，<strong>对“只执行一次”的代码而言，解释执行其实总是比JIT编译执行要快</strong></p></blockquote><hr /><p><strong>怎么算是“只执行一次的代码”呢？</strong></p><p>粗略说，下面两个条件同时满足时就是严格的“只执行一次”</p><p>1、只被调用一次，例如类的构造器（class initializer，()）</p><p>2、没有循环</p><p>对只执行一次的代码做JIT编译再执行，可以说是得不偿失。</p><p>对只执行少量次数的代码，JIT编译带来的执行速度的提升也未必能抵消掉最初编译带来的开销</p><blockquote><p><strong>只有对频繁执行的代码，JIT编译才能保证有正面的收益</strong></p></blockquote><hr /><p><strong>编译的空间开销</strong></p><p>对一般的Java方法而言，编译后代码的大小相对于class字节码的大小，膨胀比达到10x是很正常的。同上面说的时间开销一样，这里的空间开销也是，只有对执行频繁的代码才值得编译，如果把所有代码都编译则会显著增加代码所占空间，导致“代码爆炸”</p><blockquote><p><strong>这也就解释了为什么有些JVM会选择不总是做JIT编译，而是选择用解释器+JIT编译器的混合执行引擎</strong></p></blockquote><hr /><p><strong>为何HotSpot虚拟机要实现两个不同的即时编译器？</strong></p><p>HotSpot虚拟机中内置了两个即时编译器：<strong>Client Complier和Server Complier</strong>，简称为C1、C2编译器，分别用在客户端和服务端。</p><p>目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。<strong>程序使用哪个编译器，取决于虚拟机运行的模式</strong>。HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用</p><pre><code class="highlight plaintext">“-client”或“-server”</code></pre><p>参数去强制指定虚拟机运行在Client模式或Server模式。</p><p>用Client Complier获取更高的<strong>编译速度</strong>，用Server Complier 来获取更好的<strong>编译质量</strong>。为什么提供多个即时编译器与为什么提供多个垃圾收集器类似，都是为了适应不同的应用场景。</p><hr /><p><strong>哪些程序代码会被编译？</strong></p><p>程序中的代码只有是热点代码时，才会编译为本地代码，那么什么是热点代码呢？</p><p>运行过程中会被即时编译器编译的“热点代码”有两类：</p><ol><li>被多次调用的方法。</li><li>被多次执行的循环体。</li></ol><p>两种情况，编译器都是以<strong>整个方法</strong>作为编译对象。 这种编译方法因为编译发生在方法执行过程之中，因此形象的称之为栈上替换（On Stack Replacement，OSR），即方法栈帧还在栈上，方法就被替换了</p><hr /><p><strong>如何判断热点代码呢？</strong></p><p>要知道方法或一段代码是不是热点代码，是不是需要触发即时编译，需要进行Hot Spot Detection（热点探测）</p><p>目前主要的热点探测方式有以下两种：</p><p><strong>基于采样的热点探测</strong></p><ul><li><strong>采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这个方法就是“热点方法”</strong>。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可），缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li></ul><p><strong>基于计数器的热点探测</strong></p><ul><li><strong>采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”</strong>。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨。</li></ul><hr /><p><strong>HotSpot虚拟机中使用的是哪种热点检测方式呢？</strong></p><p>在HotSpot虚拟机中使用的是第二种,基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：<strong>方法调用计数器和回边计数器</strong>。在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译</p><p><strong>方法调用计数器</strong></p><p>顾名思义，这个计数器用于统计方法被调用的次数</p><p><strong>回边计数器</strong></p><p>它的作用就是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”。</p><hr /><p><strong>如何编译为本地代码？</strong></p><p>Server Compiler和Client Compiler两个编译器的编译过程是不一样的。</p><p>对Client Compiler来说，它是一个简单快速的编译器，主要关注点在于<strong>局部优化</strong>，而放弃许多耗时较长的全局优化手段。</p><p>而Server Compiler则是专门面向服务器端的，并为服务端的性能配置特别调整过的编译器，是一个<strong>充分优化</strong>过的高级编译器。</p><h3 id="jit编译器优化"><a class="markdownIt-Anchor" href="#jit编译器优化"></a> JIT编译器优化</h3><p>HotSpot 虚拟机使用了很多种优化技术，这里只简单介绍其中的几种，完整的优化技术介绍可以参考官网内容</p><p><strong>公共子表达式的消除</strong></p><p>公共子表达式消除是一个普遍应用于各种编译器的经典优化技术，他的含义是：如果一个表达式E已经计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成为了公共子表达式。对于这种表达式，没有必要花时间再对他进行计算，只需要直接用前面计算过的表达式结果代替E就可以了。如果这种优化仅限于程序的基本块内，便称为局部公共子表达式消除（Local Common Subexpression Elimination），如果这种优化范围涵盖了多个基本块，那就称为全局公共子表达式消除（Global Common Subexpression Elimination）。举个简单的例子来说明他的优化过程，假设存在如下代码：</p><pre><code class="highlight plaintext">int d = (c*b)*12+a+(a+b*c)</code></pre><p>如果这段代码交给Javac编译器则不会进行任何优化，那生成的代码如下所示，是完全遵照Java源码的写法直译而成的</p><pre><code class="highlight plaintext">iload_2 // bimul // 计算b*c bipush 12 // 推入12 imul // 计算(c*b)*12 iload_1 // aiadd // 计算(c*b)*12+a iload_1 // aiload_2 // biload_3 // cimul // 计算b*ciadd // 计算a+b*ciadd // 计算(c*b)*12+a+(a+b*c) istore 4</code></pre><p>当这段代码进入到虚拟机即时编译器后，他将进行如下优化：编译器检测到”cb“与”bc“是一样的表达式，而且在计算期间b与c的值是不变的。因此，这条表达式就可能被视</p><pre><code class="highlight plaintext">int d = E*12+a+(a+E);</code></pre><p>这时，编译器还可能（取决于哪种虚拟机的编译器以及具体的上下文而定）进行另外一种优化：代数化简（Algebraic Simpliﬁcation），把表达式变为：</p><pre><code class="highlight plaintext">int d = E*13+a*2;</code></pre><p>表达式进行变换之后，再计算起来就可以节省一些时间了</p><hr /><p><strong>方法内联</strong></p><p>在使用JIT进行即时编译时，将方法调用直接使用方法体中的代码进行替换，这就是方法内联，减少了方法调用过程中<strong>压栈与入栈</strong>的开销。同时为之后的一些优化手段提供条件。</p><p>如果JVM监测到一些小方法被频繁的执行，它会把方法的调用替换成方法体本身。比如说下面这个：</p><pre><code class="highlight plaintext">private int add4(int x1, int x2, int x3, int x4) &#123;    return add2(x1, x2) + add2(x3, x4);&#125;private int add2(int x1, int x2) &#123;    return x1 + x2;&#125;</code></pre><p>可以肯定的是运行一段时间后JVM会把add2方法去掉，并把你的代码翻译成：</p><pre><code class="highlight plaintext">private int add4(int x1, int x2, int x3, int x4) &#123;    return x1 + x2 + x3 + x4;&#125;</code></pre><hr /><p><strong>逃逸分析</strong></p><p>逃逸分析(Escape Analysis)是目前Java虚拟机中比较前沿的优化技术。这是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p><p><strong>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸</strong></p><p>逃逸分析包括：</p><ul><li>全局变量赋值逃逸</li><li>方法返回值逃逸</li><li>实例引用发生逃逸</li><li>线程逃逸:赋值给类变量或可以在其他线程中访问的实例变量</li></ul><pre><code class="highlight plaintext">public class EscapeAnalysis &#123;    public static Object object;    public void globalVariableEscape()&#123;//全局变量赋值逃逸       object =new Object();    &#125;    public Object methodEscape()&#123; //方法返回值逃逸       return new Object();    &#125;    public void instancePassEscape()&#123; //实例引用发生逃逸       this.speak(this);    &#125;    public void speak(EscapeAnalysis escapeAnalysis)&#123;       System.out.println(&quot;Escape Hello&quot;);    &#125;&#125;</code></pre><p>使用方法逃逸的案例进行分析：</p><pre><code class="highlight plaintext">public static StringBuffer craeteStringBuffer(String s1, String s2) &#123;    StringBuffer sb = new StringBuffer();    sb.append(s1);    sb.append(s2);    return sb;&#125;</code></pre><blockquote><p>StringBuffer sb是一个方法内部变量，上述代码中直接将sb返回，这样这个StringBuffer有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为<strong>线程逃逸</strong>。</p></blockquote><p>上述代码如果想要StringBuffer sb不逃出方法，可以这样写：</p><pre><code class="highlight plaintext">public static String createStringBuffer(String s1, String s2) &#123;    StringBuffer sb = new StringBuffer();    sb.append(s1);    sb.append(s2);    return sb.toString();&#125;</code></pre><blockquote><p>不直接返回 StringBuffer，那么StringBuffer将不会逃逸出方法</p></blockquote><p>使用逃逸分析，编译器可以对代码做如下优化：</p><blockquote><p>一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p></blockquote><blockquote><p>二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p></blockquote><blockquote><p>三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中</p></blockquote><p><strong>在Java代码运行时，通过JVM参数可指定是否开启逃逸分析</strong></p><pre><code class="highlight plaintext">-XX:+DoEscapeAnalysis ： 表示开启逃逸分析-XX:-DoEscapeAnalysis ： 表示关闭逃逸分析</code></pre><blockquote><p>从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis</p></blockquote><hr /><p><strong>对象的栈上内存分配</strong></p><p>我们知道，在<strong>一般情况下，对象和数组元素的内存分配是在堆内存上进行的</strong>。但是随着JIT编译器的日渐成熟，很多优化使这种分配策略并不绝对。JIT编译器就可以在编译期间根据逃逸分析的结果，来决定是否可以将对象的内存分配从堆转化为栈</p><pre><code class="highlight plaintext">public class EscapeAnalysisTest &#123;    public static void main(String[] args) &#123;        long a1 = System.currentTimeMillis();        for (int i = 0; i &lt; 1000000; i++) &#123;            alloc();        &#125;        // 查看执行时间        long a2 = System.currentTimeMillis();        System.out.println(&quot;cost &quot; + (a2 - a1) + &quot; ms&quot;);        // 为了方便查看堆内存中对象个数，线程sleep        try &#123;           Thread.sleep(100000);        &#125; catch (InterruptedException e1) &#123;            e1.printStackTrace();        &#125;    &#125;    private static void alloc() &#123;     User user = new User();    &#125;    static class User &#123;    &#125;&#125;</code></pre><blockquote><p>其实代码内容很简单，就是使用for循环，在代码中创建100万个User对象</p></blockquote><blockquote><p>我们在alloc方法中定义了User对象，但是并没有在方法外部引用他。也就是说，这个对象并不会逃逸到alloc外部。经过JIT的逃逸分析之后，就可以对其内存分配进行优化</p></blockquote><p>我们指定以下JVM参数并运行：</p><pre><code class="highlight plaintext">-Xmx4G -Xms4G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError</code></pre><p>在程序打印出 <code>cost XX ms</code> 后，代码运行结束之前，我们使用<code>[jmap][1]</code> 命令，来查看下当前堆内存中有多少个User对象：</p><pre><code class="highlight plaintext">~ jps2809 StackAllocTest2810 Jps~ jmap -histo 2809num #instances #bytes class name.----------------------------------------------1: 524 87282184 [I2: 1000000 16000000 StackAllocTest$User3: 6806 2093136 [B4: 8006 1320872 [C5: 4188 100512 java.lang.String6: 581 66304 java.lang.Class</code></pre><p>从上面的jmap执行结果中我们可以看到，堆中共创建了100万个StackAllocTest$User 实例。</p><p>在关闭逃避分析的情况下（<code>-XX:-DoEscapeAnalysis</code>），虽然在alloc方法中创建的User对象并没有逃逸到方法外部，但是还是被分配在堆内存中。也就说，如果没有JIT编译器优化，没有逃逸分析技术，正常情况下就应该是这样的。即所有对象都分配到堆内存中。</p><p>接下来，我们开启逃逸分析，再来执行下以上代码</p><pre><code class="highlight plaintext">-Xmx4G -Xms4G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError</code></pre><p>在程序打印出 cost XX ms 后，代码运行结束之前，我们使用jmap 命令，来查看下当前堆内存中有多少个User对象：</p><p>从以上打印结果中可以发现，开启了逃逸分析之后（-XX:+DoEscapeAnalysis），在堆内存中只有12万多个StackAllocTest$User 对象。也就是说在经过JIT优化之后，堆内存中分配的对象数量，从100万降到了12万。</p><p>除了以上通过jmap验证对象个数的方法以外，读者还可以尝试将堆内存调小，然后执行以上代码，根据GC的次数来分析，也能发现，开启了逃逸分析之后，在运行期间，GC次数会明显减少。正是因为很多堆上分配被优化成了栈上分配，所以GC次数有了明显的减少</p><p><strong>总结</strong></p><p>所以，如果以后再有人问你：是不是所有的对象和数组都会在堆内存分配空间？</p><p>那么你可以告诉他：不一定，随着JIT编译器的发展，在编译期间，如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。但是这也并不是绝对的。就像我们前面看到的一样，在开启逃逸分析之后，也并不是所有User对象都没有在堆上分配</p><hr /><p><strong>标量替换</strong></p><p>标量（Scalar）是指一个无法再分解成更小的数据的数据 。</p><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替</p><pre><code class="highlight plaintext">//有一个类Apublic class A&#123;    public int a=1;    public int b=2&#125;//方法getAB使用类A里面的a,bprivate void getAB()&#123;    A x = new A();    x.a;    x.b;&#125;//JVM在编译的时候会直接编译成private void getAB()&#123;    a = 1;    b = 2;&#125;//这就是标量替换</code></pre><hr /><p><strong>同步锁消除</strong></p><p>同样基于逃逸分析，当加锁的变量不会发生逃逸，是线程私有的完全没有必要加锁。 在jit编译时期就可以将同步锁去掉，以减少加锁与解锁造成的资源开销</p><pre><code class="highlight plaintext">public class TestLockEliminate &#123;    public static String getString(String s1, String s2) &#123;        StringBuffer sb = new StringBuffer();        sb.append(s1);        sb.append(s2);        return sb.toString();    &#125;    public static void main(String[] args) &#123;        long tsStart = System.currentTimeMillis();        for (int i = 0; i &lt; 1000000; i++) &#123;         getString(&quot;TestLockEliminate &quot;, &quot;Suffix&quot;);        &#125;        System.out.println(&quot;一共耗费：&quot; + (System.currentTimeMillis() - tsStart) + &quot; ms&quot;);    &#125;&#125;</code></pre><p>getString()方法中的StringBuffer数以函数内部的局部变量，进作用于方法内部，不可能逃逸出该方法，因此他就不可能被多个线程同时访问，也就没有资源的竞争，但是StringBuffer的append操作却需要执行同步操作:</p><pre><code class="highlight plaintext">@Overridepublic synchronized StringBuffer append(String str) &#123;    toStringCache = null;    super.append(str);    return this;&#125;</code></pre><p>逃逸分析和锁消除分别可以使用参数<code>-XX:+DoEscapeAnalysis</code>和<code>-XX:+EliminateLocks</code>(锁消除必须在-server模式下)开启。使用如下参数运行上面的程序：</p><pre><code class="highlight plaintext">-XX:+DoEscapeAnalysis -XX:-EliminateLocks</code></pre><p>得到如下结果：</p><p>使用如下命令</p><pre><code class="highlight plaintext">-XX:+DoEscapeAnalysis -XX:+EliminateLocks</code></pre><p>得到如下结果：</p><h2 id="class文件"><a class="markdownIt-Anchor" href="#class文件"></a> CLASS文件</h2><h3 id="class文件概述"><a class="markdownIt-Anchor" href="#class文件概述"></a> class文件概述</h3><p>我们可任意打开一个Class文件（使用Hex Editor等工具打开），内容如下（内容是16进制）：</p><p><strong>魔数</strong></p><p>所有的由Java编译器编译而成的class文件的前4个字节都是“0xCAFEBABE”。</p><p>它的作用在于：当JVM在尝试加载某个文件到内存中来的时候，会首先判断此class文件有没有JVM认为可以接受的“签名”，即JVM会首先读取文件的前4个字节，判断该4个字节是否是“0xCAFEBABE”，如果是，则JVM会认为可以将此文件当作class文件来加载并使用。</p><p><strong>版本号</strong></p><p>随着Java本身的发展，Java语言特性和JVM虚拟机也会有相应的更新和增强。目前我们能够用到的JDK版本如：1.5，1.6，1.7，还有现如今的1.8及更高的版本。发布新版本的目的在于：在原有的版本上增加新特性和相应的JVM虚拟机的优化。而随着主版本发布的次版本，则是修改相应主版本上出现的bug。我们平时只需要关注主版本就可以了。</p><p>主版本号和次版本号在class文件中各占两个字节，副版本号占用第5、6两个字节，而主版本号则占用第7，8两个字节。JDK1.0的主版本号为45，以后的每个新主版本都会在原先版本的基础上加1。若现在使用的是JDK1.7编译出来的class文件，则相应的主版本号应该是51,对应的7，8个字节的十六进制的值应该是 0x33。</p><p>一个 JVM实例只能支持特定范围内的主版本号 （Mi 至Mj） 和 0 至特定范围内 （0 至 m） 的副版本号。假设一个 Class 文件的格式版本号为 V， 仅当Mi.0 ≤ v ≤ Mj.m成立时，这个 Class 文件才可以被此 Java 虚拟机支持。不同版本的 Java 虚拟机实现支持的版本号也不同，高版本号的 Java 虚拟机实现可以支持低版本号的 Class 文件，反之则不成立。</p><p>JVM在加载class文件的时候，会读取出主版本号，然后比较这个class文件的主版本号和JVM本身的版本号，如果JVM本身的版本号 &lt; class文件的版本号，JVM会认为加载不了这个class文件，会抛出我们经常见到的&quot; java.lang.UnsupportedClassVersionError: Bad version number in .class file &quot; Error 错误；反之，JVM会认为可以加载此class文件，继续加载此class文件</p><blockquote><ol><li>有时候我们在运行程序时会抛出这个Error 错误：“java.lang.UnsupportedClassVersionError: Bad version number in .class ﬁle”。上面已经揭示了出现这个问题的原因，就是在于当前尝试加载class文件的JVM虚拟机的版本 低于class文件的版本。解决方法：1.重新使用当前jvm编译源代码，然后再运行代码；2.将当前JVM虚拟机更新到class文件的版本。</li><li>怎样查看class文件的版本号？可以借助于文本编辑工具，直接查看该文件的7，8个字节的值，确定class文件是什么版本的。</li></ol></blockquote><p>当然快捷的方式使用JDK自带的javap工具，如当前有Math.class 文件，进入此文件所在的目录，然后执行 ”javap -v Math“,结果会类似如下所示：</p><p><strong>常量池计数器</strong></p><p>常量池是class文件中非常重要的结构，它描述着整个class文件的字面量信息。常量池是由一组constant_pool结构体数组组成的，而数组的大小则由常量池计数器指定。常量池计数器</p><p>constant_pool_count 的值 =constant_pool表中的成员数+ 1。constant_pool表的索引值只有在大于 0 且小于constant_pool_count时才会被认为是有效的。</p><blockquote><p>注意事项</p></blockquote><p>常量池计数器默认从1开始而不是从0开始：</p><ul><li>当constant_pool_count = 1时，常量池中的cp_info个数为0；当constant_pool_count为n时，常量池中的cp_info个数为n-1。</li></ul><p>原因：</p><ul><li>在指定class文件规范的时候，将索引#0项常量空出来是有特殊考虑的，这样当：某些数据在特定的情况下想表达“不引用任何一个常量池项”的意思时，就可以将其引用的常量的索引值设置为#0来表示</li></ul><p><strong>常量池数据区</strong></p><p><strong>访问标志</strong></p><p>访问标志，access_flags 是一种掩码标志，用于表示某个类或者接口的访问权限及基础属性。</p><p><strong>类索引</strong></p><p>类索引，this_class的值必须是对constant_pool表中项目的一个有效索引值。constant_pool表在这个索引处的项必须为CONSTANT_Class_info 类型常量，表示这个 Class 文件所定义的类或接口</p><p><strong>父类索引</strong></p><p>父类索引，对于类来说，super_class 的值必须为 0 或者是对constant_pool 表中项目的一个有效索引值。</p><p>如果它的值不为 0，那 constant_pool 表在这个索引处的项必须为CONSTANT_Class_info 类型常量，表示这个 Class 文件所定义的类的直接父类。当前类的直接父类，以及它所有间接父类的access_flag 中都不能带有ACC_FINAL 标记。对于接口来说，它的Class文件的super_class项的值必须是对constant_pool表中项目的一个有效索引值。constant_pool表在这个索引处的项必须为代表 java.lang.Object 的 CONSTANT_Class_info 类型常量 。</p><p>如果 Class 文件的 super_class的值为 0，那这个Class文件只可能是定义的是java.lang.Object类，只有它是唯一没有父类的类。</p><p><strong>接口计数器</strong></p><p>接口计数器，interfaces_count的值表示当前类或接口的【直接父接口数量】。</p><p><strong>接口信息数据区</strong></p><p>接口表，interfaces[]数组中的每个成员的值必须是一个对constant_pool表中项目的一个有效索引值， 它的长度为 interfaces_count。每个成员interfaces[i] 必须为</p><p>CONSTANT_Class_info类型常量，其中 【0 ≤ i &lt;interfaces_count】。在interfaces[]数组中，成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即interfaces[0]对应的是源代码中最左边的接口。</p><p><strong>字段计数器</strong></p><p>字段计数器，fields_count的值表示当前 Class 文件 fields[]数组的成员个数。 fields[]数组中每一项都是一个field_info结构的数据项，它用于表示该类或接口声明的类字段或者实例字段。</p><p><strong>字段信息数据区</strong></p><p>字段表，fields[]数组中的每个成员都必须是一个fields_info结构的数据项，用于表示当前类或接口中某个字段的完整描述。 fields[]数组描述当前类或接口声明的所有字段，但不包括从父类或父接口继承的部分。</p><p><strong>方法计数器</strong></p><p>方法计数器， methods_count的值表示当前Class 文件 methods[]数组的成员个数。Methods[]数组中每一项都是一个 method_info 结构的数据项。</p><p><strong>方法信息数据区</strong></p><p>方法表，methods[] 数组中的每个成员都必须是一个 method_info 结构的数据项，用于表示当前类或接口中某个方法的完整描述。</p><p>如果某个method_info 结构的access_flags 项既没有设置 ACC_NATIVE 标志也没有设置</p><p>ACC_ABSTRACT 标志，那么它所对应的方法体就应当可以被 Java 虚拟机直接从当前类加载，而不需要引用其它类。</p><p>method_info结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法 。</p><p>【methods[]数组只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法】。</p><p><strong>属性计数器</strong></p><p>属性计数器，attributes_count的值表示当前 Class 文件attributes表的成员个数。 attributes表中每一项都是一个attribute_info 结构的数据项。</p><p><strong>属性信息数据区</strong></p><p>属性表，attributes 表的每个项的值必须是attribute_info结构。</p><p>在Java 7 规范里，Class文件结构中的attributes表的项包括下列定义的属性： InnerClasses 、 EnclosingMethod 、 Synthetic 、Signature、SourceFile，SourceDebugExtension 、Deprecated、RuntimeVisibleAnnotations 、RuntimeInvisibleAnnotations以及BootstrapMethods属性。</p><p>对于支持 Class 文件格式版本号为 49.0 或更高的 Java 虚拟机实现，必须正确识别并读取attributes表中的Signature、RuntimeVisibleAnnotations和RuntimeInvisibleAnnotations属性。对于支持Class文件格式版本号为 51.0 或更高的 Java 虚拟机实现，必须正确识别并读取 attributes表中的BootstrapMethods属性。Java 7 规范 要求任一 Java 虚拟机实现可以自动忽略 Class 文件的 attributes表中的若干 （甚至全部） 它不可识别的属性项。任何本规范未定义的属性不能影响Class文件的语义，只能提供附加的描述信息 。</p><h3 id="class常量池理解"><a class="markdownIt-Anchor" href="#class常量池理解"></a> class常量池理解</h3><p><strong>1.常量池在class文件的什么位置？</strong></p><p><strong>2.常量池的里面是怎么组织的？</strong></p><p>cp_info：常量池项</p><p>constant_pool_count：常量池计算器</p><p><strong>3.常量池项 (cp_info) 的结构是什么？</strong></p><p>JVM虚拟机规定了不同的tag值和不同类型的字面量对应关系如下：</p><p>所以根据cp_info中的tag 不同的值，可以将cp_info 更细化为以下结构体：</p><p>现在让我们看一下细化了的常量池的结构会是类似下图所示的样子：</p><p><strong>4. int和ﬂoat数据类型的常量在常量池中是怎样表示和存储的？</strong></p><p>Java语言规范规定了 int类型和Float 类型的数据类型占用 4 个字节的空间。那么存在于class字节码文件中的该类型的常量是如何存储的呢？</p><p>举例：建下面的类 IntAndFloatTest.java，在这个类中，我们声明了五个变量，但是取值就两种int类型的10 和Float类型的11f。</p><pre><code class="highlight plaintext">package com.kkb.jvm;   public class IntAndFloatTest &#123;     private final int a = 10;       private final int b = 10;       private float c = 11f;      private float d = 11f;       private float e = 11f;  &#125;</code></pre><p>然后用编译器编译成IntAndFloatTest.class字节码文件，我们通过javap -v IntAndFloatTest 指令来看一下其常量池中的信息，可以看到虽然我们在代码中写了两次10 和三次11f，但是常量池中，就只有一个常量10 和一个常量11f,如下图所示:</p><p>从结果上可以看到常量池第#8 个常量池项(cp_info) 就是CONSTANT_Integer_info,值为10；第#23个常量池项(cp_info) 就是CONSTANT_Float_info,值为11f。</p><p>代码中所有用到 int 类型 10 的地方，会使用指向常量池的指针值#8 定位到第#8 个常量池项</p><p>(cp_info)，即值为 10的结构体CONSTANT_Integer_info，而用到ﬂoat类型的11f时，也会指向常量池的指针值#23来定位到第#23个常量池项(cp_info) 即值为11f的结构体CONSTANT_Float_info。如下图所示：</p><p><strong>5. long和 double数据类型的常量在常量池中是怎样表示和存储的？</strong></p><p>Java语言规范规定了 long 类型和 double类型的数据类型占用8 个字节的空间。那么存在于class 字节码文件中的该类型的常量是如何存储的呢？</p><p>举例：建下面的类 LongAndDoubleTest.java，在这个类中，我们声明了六个变量，但是取值就两种Long 类型的-6076574518398440533L 和Double 类型的10.1234567890D。</p><pre><code class="highlight plaintext">public class LongAndDoubleTest &#123;    private long a = -6076574518398440533L;      private long b = -6076574518398440533L;      private long c = -6076574518398440533L;      private double d = 10.1234567890D;      private double e = 10.1234567890D;     private double f = 10.1234567890D; &#125;</code></pre><p>然后用编译器编译成 LongAndDoubleTest.class 字节码文件，我们通过javap -v LongAndDoubleTest指令来看一下其常量池中的信息，可以看到虽然我们在代码中写了三次-6076574518398440533L 和三次10.1234567890D，但是常量池中，就只有一个常</p><p>量-6076574518398440533L 和一个常量10.1234567890D,如下图所示:</p><p>从结果上可以看到常量池第 #18 个常量池项(cp_info) 就是CONSTANT_Long_info,值</p><p>为-6076574518398440533L ；第 #26个常量池项(cp_info) 就是CONSTANT_Double_info,值为10.1234567890D。</p><p>代码中所有用到 long 类型-6076574518398440533L 的地方，会使用指向常量池的指针值#18 定位到第 #18 个常量池项(cp_info)，即值为-6076574518398440533L 的结构体CONSTANT_Long_info，而用到double类型的10.1234567890D时，也会指向常量池的指针值#26来定位到第 #26 个常量池项</p><p>(cp_info) 即值为10.1234567890D的结构体CONSTANT_Double_info。如下图所示：</p><p><strong>6. String类型的字符串常量在常量池中是怎样表示和存储的？</strong></p><p>对于字符串而言，JVM会将字符串类型的字面量以UTF-8 编码格式存储到在class字节码文件中。这么说可能有点摸不着北，我们先从直观的Java源码中中出现的用双引号&quot;&quot; 括起来的字符串来看，在编译器编译的时候，都会将这些字符串转换成CONSTANT_String_info结构体，然后放置于常量池中。其结构如下所示：</p><p>如上图所示的结构体，CONSTANT_String_info结构体中的string_index的值指向了CONSTANT_Utf8_info结构体，而字符串的utf-8编码数据就在这个结构体之中。如下图所示：</p><p>请看一例，定义一个简单的StringTest.java类，然后在这个类里加一个&quot;JVM原理&quot; 字符串，然后，我们来看看它在class文件中是怎样组织的。</p><pre><code class="highlight plaintext">public class StringTest &#123;    private String s1 = &quot;JVM原理&quot;;     private String s2 = &quot;JVM原理&quot;;     private String s3 = &quot;JVM原理&quot;;     private String s4 = &quot;JVM原理&quot;;&#125;</code></pre><p>将Java源码编译成StringTest.class文件后，在此文件的目录下执行 javap -v StringTest 命令，会看到如下的常量池信息的轮廓：</p><p>(PS :使用javap -v 指令能看到易于我们阅读的信息，查看真正的字节码文件可以使用HEXWin、 NOTEPAD++、UtraEdit 等工具。)</p><p>在面的图中，我们可以看到CONSTANT_String_info结构体位于常量池的第#15个索引位置。而存</p><p>放&quot;Java虚拟机原理&quot; 字符串的 UTF-8编码格式的字节数组被放到CONSTANT_Utf8_info结构体中，该结构体位于常量池的第#16个索引位置。上面的图只是看了个轮廓，让我们再深入地看一下它们的组织吧。请看下图：</p><p>由上图可见：“JVM原理”的UTF-8编码的数组是：4A564D E5 8E 9FE7 90 86，并且存入了CONSTANT_Utf8_info结构体中</p><p><strong>7. 类文件中定义的类名和类中使用到的类在常量池中是怎样被组织和存储的？</strong></p><p>JVM会将某个Java 类中所有使用到了的类的完全限定名 以二进制形式的完全限定名 封装成CONSTANT_Class_info结构体中，然后将其放置到常量池里。CONSTANT_Class_info 的tag值为 7 。其结构如下：</p><blockquote><p>Tips：类的完全限定名和二进制形式的完全限定名</p></blockquote><blockquote><p>在某个Java源码中，我们会使用很多个类，比如我们定义了一个 ClassTest的类，并把它放到com.kkb.jvm 包下，则 ClassTest类的完全限定名为com.kkb.jvm.ClassTest，将JVM编译器将类编译成class文件后，此完全限定名在class文件中，是以二进制形式的完全限定名存储的，即它会把完全限定符的&quot;.“换成”/&quot; ，即在class文件中存储的 ClassTest类的完全限定名称</p><p>是&quot;com/kkb/jvm/ClassTest&quot;。因为这种形式的完全限定名是放在了class二进制形式的字节码文件中，所以就称之为 二进制形式的完全限定名。</p></blockquote><p>举例，我们定义一个很简单的ClassTest类，来看一下常量池是怎么对类的完全限定名进行存储的。</p><pre><code class="highlight plaintext"> import  java.util.Date;    public class ClassTest &#123;    private Date date =new Date();&#125;</code></pre><p>将Java源码编译成ClassTest.class文件后，在此文件的目录下执行 javap -v ClassTest 命令，会看到如下的常量池信息的轮廓：</p><p>如上图所示，在ClassTest.class文件的常量池中，共有 3 个CONSTANT_Class_info结构体，分别表示ClassTest 中用到的Class信息。 我们就看其中一个表示com/jvm.ClassTest的</p><p>CONSTANT_Class_info 结构体。它在常量池中的位置是#1，它的name_index值为#2，它指向了常量池的第2 个常量池项，如下所示:</p><p>注意：</p><blockquote><p>对于某个类而言，其class文件中至少要有两个CONSTANT_Class_info常量池项，用来表示自己的类信息和其父类信息。(除了java.lang.Object类除外，其他的任何类都会默认继承自</p><p>java.lang.Object）如果类声明实现了某些接口，那么接口的信息也会生成对应的</p><p>CONSTANT_Class_info常量池项。</p></blockquote><p>除此之外，如果在类中使用到了其他的类，只有真正使用到了相应的类，JDK编译器才会将类的信息组成CONSTANT_Class_info常量池项放置到常量池中。如下图：</p><pre><code class="highlight plaintext">import java.util.Date; public  class Other&#123;     private Date date;      public Other()  &#123;         Date da;    &#125;&#125;</code></pre><p>上述的Other的类，在JDK将其编译成class文件时，常量池中并没有java.util.Date对应的CONSTANT_Class_info常量池项，为什么呢?</p><p>在Other类中虽然定义了Date类型的两个变量date、da，但是JDK编译的时候，认为你只是声明</p><p>了“Ljava/util/Date”类型的变量，并没有实际使用到Ljava/util/Date类。将类信息放置到常量池中的目的，是为了在后续的代码中有可能会反复用到它。很显然，JDK在编译Other类的时候，会解析到Date类有没有用到，发现该类在代码中就没有用到过，所以就认为没有必要将它的信息放置到常量池中了。</p><hr /><p>将上述的Other类改写一下，仅使用new Date()，如下图所示：</p><pre><code class="highlight plaintext">import java.util.Date; public  class Other&#123;     private Date date;      public Other()  &#123;         new Date();;    &#125;&#125;</code></pre><p>这时候使用javap -v Other ，可以查看到常量池中有表示java/util/Date的常量池项：</p><hr /><p><strong>总结</strong></p><p>对于某个类或接口而言，其自身、父类和继承或实现的接口的信息会被直接组装成</p><p>CONSTANT_Class_info常量池项放置到常量池中；</p><p>类中或接口中使用到了其他的类，只有在类中实际使用到了该类时，该类的信息才会在常量池中有对应的CONSTANT_Class_info常量池项；</p><p>类中或接口中仅仅定义某种类型的变量，JDK只会将变量的类型描述信息以UTF-8字符串组成CONSTANT_Utf8_info常量池项放置到常量池中，上面在类中的private Date date;JDK编译器只会将表示date的数据类型的“Ljava/util/Date”字符串放置到常量池中。</p><hr /><p><strong>8.哪些字面量会进入常量池中？</strong></p><ol><li>final类型的8种基本类型的值会进入常量池。</li><li>非final类型（包括static的）的8种基本类型的值，只有double、float、long的值会进入常量池。</li><li>常量池中包含的字符串类型字面量（双引号引起来的字符串值）。</li></ol><p>测试代码：</p><pre><code class="highlight plaintext">public class Test&#123;     private int int_num = 110;     private char char_num = &#x27;a&#x27;;     private short short_num = 120;     private float float_num = 130.0f;      private double double_num = 140.0;       private byte byte_num = 111;    private long long_num = 3333L;     private long long_delay_num;    private boolean boolean_flage = true;        public void init()&#123;        this.long_delay_num = 5555L;    &#125;&#125;</code></pre><p>使用javap命令打印的结果如下：</p><h3 id="class文件中的应用和特殊字符串"><a class="markdownIt-Anchor" href="#class文件中的应用和特殊字符串"></a> class文件中的应用和特殊字符串</h3><p><strong>符号引用</strong></p><p>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。</p><p>例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、</p><p>CONSTANT_Methodref_info等类型的常量出现</p><p>符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中</p><p>在[Java]中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p><hr /><p><strong>直接引用</strong></p><ol><li>直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）</li><li>相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）</li><li>一个能间接定位到目标的句柄</li></ol><p>直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。</p><hr /><p><strong>符号引用替换为直接引用的时机</strong></p><p>符号引用替换为直接引用的操作发生在类加载过程(加载 -&gt; 连接(验证、准备、解析) -&gt; 初始化)中的解析阶段，会将符号引用转换(替换)为对应的直接引用，放入运行时常量池中</p><blockquote><p>注：直接引用可以是指向目标内存的指针，也可以是偏移量，也可以是一个能定位到目标内存的句柄。</p></blockquote><p>特殊字符串包括三种： 类的全限定名， 字段和方法的描述符， 特殊方法的方法名。 下面我们就分别介绍这三种特殊字符串。</p><hr /><p><strong>类的全限定名</strong></p><p>Object类，在源文件中的全限定名是 java.lang.Object。而class文件中的全限定名是将点号替换成“/” 。</p><p>Object类在class文件中的全限定名是 java/lang/Object 。 源文件中一个类的名字， 在class文件中是用全限定名表述的。</p><hr /><p><strong>描述符</strong></p><ul><li><strong>各类型的描述符</strong></li></ul><p>对于字段的数据类型，其描述符主要有以下几种</p><ul><li><p>基本数据类型（byte、char、double、ﬂoat、int、long、short、boolean）：除 long 和 boolean，其他基本数据类型的描述符用对应单词的大写首字母表示。long 用 J 表示，boolean 用 Z 表示。</p></li><li><p>void：描述符是 V。</p></li><li><p>对象类型：描述符用字符 L加上对象的全限定名表示，如 String 类型的描述符为 Ljava/lang/String。</p></li><li><p>数组类型：每增加一个维度则在对应的字段描述符前增加一个<code>[ ，如一维数组 int[] 的描述符为 [I，二维数组 String[][] 的描述符为 [[Ljava/lang/String 。</code></p></li><li><p><strong>字段描述符</strong></p></li></ul><p>字段的描述符就是字段的类型所对应的字符或字符串。</p><pre><code class="highlight plaintext">int i 中， 字段i的描述符就是 IObject o中， 字段o的描述符就是 Ljava/lang/Object;double[][] d中， 字段d的描述符就是 [[D</code></pre><ul><li><strong>方法描述符</strong></li></ul><p>方法的描述符比较复杂， 包括所有参数的类型列表和方法返回值。 它的格式是这样的：</p><pre><code class="highlight plaintext">(参数1类型 参数2类型 参数3类型 ...)返回值类型</code></pre><blockquote><p>不管是参数的类型还是返回值类型， 都是使用对应字符和对应字符串来表示的， 并且参数列表使用小括号括起来， 并且各个参数类型之间没有空格， 参数列表和返回值类型之间也没有空格。</p></blockquote><p>方法描述符举例说明如下：</p><p>特殊方法的方法名</p><p>首先要明确一下， 这里的特殊方法是指的类的构造方法和类型初始化方法。</p><p>构造方法就不用多说了， 至于类型的初始化方法， 对应到源码中就是静态初始化块。 也就是说， 静态初始化块， 在class文件中是以一个方法表述的， 这个方法同样有方法描述符和方法名，具体如下:</p><ul><li>类的构造方法的方法名使用字符串 表示</li><li>静态初始化方法的方法名使用字符串 表示。</li><li>除了这两种特殊的方法外， 其他普通方法的方法名， 和源文件中的方法名相同</li></ul><hr /><p><strong>总结</strong></p><ol><li>方法和字段的描述符中， 不包括字段名和方法名， 字段描述符中只包括字段类型， 方法描述符中只包括参数列表和返回值类型。</li><li>无论method()是静态方法还是实例方法，它的方法描述符都是相同的。尽管实例方法除了传递自身定义的参数，还需要额外传递参数this，但是这一点不是由方法描述符来表达的。参数this的传递，是由Java虚拟机实现在调用实例方法所使用的指令中实现的隐式传递。</li></ol><h2 id="类加载子系统"><a class="markdownIt-Anchor" href="#类加载子系统"></a> 类加载子系统</h2><h3 id="jvm程序执行流程"><a class="markdownIt-Anchor" href="#jvm程序执行流程"></a> JVM程序执行流程</h3><p><strong>Bootstrap：系统类加载器</strong></p><p>如示例：String是系统类加载的，我们无法看到其类加载器</p><pre><code class="highlight plaintext">package com.lee.configserver;public class testMain &#123;    public static void main(String[] args) &#123;        //String是一个系统类，系统类里面的类加载器是不同的        String str = &quot;hello&quot;; //静态常量池定义        System.out.println(str.getClass().getClassLoader());    &#125;&#125;</code></pre><p>输出：</p><p><strong>App类加载器</strong></p><pre><code class="highlight plaintext">package com.lee.configserver;class People&#123;&#125;public class testMain &#123;    public static void main(String[] args) &#123;        People people = new People();   //实例化了一个自定义类对象        System.out.println(people.getClass().getClassLoader());    &#125;&#125;</code></pre><p>输出：</p><p><strong>平台类加载器</strong></p><pre><code class="highlight plaintext">package com.lee.configserver;class People&#123;&#125;public class testMain &#123;    public static void main(String[] args) &#123;        People people = new People();   //实例化了一个自定义类对象        System.out.println(people.getClass().getClassLoader());        System.out.println(people.getClass().getClassLoader().getParent());        System.out.println(people.getClass().getClassLoader().getParent().getParent());    &#125;&#125;</code></pre><h3 id="类加载过程"><a class="markdownIt-Anchor" href="#类加载过程"></a> 类加载过程</h3><p><strong>加载</strong></p><p>“加载”是“类加载”(Class Loading)过程的第一步。这个加载过程主要就是靠<strong>类加载器</strong>实现的，包括用户自定义类加载器。</p><p><strong>加载的过程</strong></p><p>在加载的过程中,JVM主要做3件事情</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流(class文件)在程序运行过程中,当要访问一个类时,若发现这个类尚未被加载,并满足类初始化的条件时，就根据要被初始化的这个类的全限定名找到该类的二进制字节流,开始加载过程</li><li>将这个字节流的<strong>静态存储结构</strong>转化为<strong>方法区的运行时数据结构</strong></li><li><strong>在内存中创建一个该类的java.lang.Class对象</strong>,作为方法区该类的各种数据的访问入口</li></ul><blockquote><p>程序在运行中所有对该类的访问都通过这个类对象,也就是这个Class对象是提供给外界访问该类的接口。</p></blockquote><hr /><p><strong>加载源</strong></p><p>JVM规范对于加载过程给予了较大的宽松度.一般二进制字节流都从已经编译好的本地class文件中读取,此外还可以从以下地方读取。</p><ul><li><strong>zip�</strong>�<br />Jar、War、Ear等</li><li><strong>其它文件生成</strong><br />由JSP文件中生成对应的Class类.</li><li><strong>数据库中</strong><br />将二进制字节流存储至数据库中,然后在加载时从数据库中读取.有些中间件会这么做,用来实现代码在集群间分发</li><li><strong>网络</strong><br />从网络中获取二进制字节流.典型就是Applet.</li><li><strong>运行时计算生成</strong><br />动态代理技术,用ProxyGenerator.generateProxyClass为特定接口生成形式为<code>&quot;*$Proxy&quot;</code>的代理类的二进制字节流.</li></ul><p><strong>类和数组加载的区别</strong></p><p>数组也有类型,称为“数组类型”.如:</p><pre><code class="highlight plaintext">String[] str = new String[10];</code></pre><blockquote><p>这个数组的数组类型是[Ljava.lang.String ,而String只是这个数组的元素类型</p></blockquote><p>数组类和非数组类的类加载是不同的，具体情况如下：</p><ul><li><strong>非数组类</strong>：是由类加载器来完成。</li><li><strong>数组类</strong>：数组类本身不通过类加载器创建，它是由java虚拟机直接创建，但数组类与类加载器有很密切的关系，因为数组类的元素类型最终要靠类加载器创建</li></ul><hr /><p><strong>加载过程的注意点</strong></p><ul><li><strong>JVM规范并未给出类在方法区中存放的数据结构</strong></li></ul><p>类完成加载后,二进制字节流就以特定的数据结构存储在方法区中,但存储的数据结构是由虚拟机自己定义的,虚拟机规范并没有指定。</p><ul><li><strong>JVM规范并没有指定Class对象存放的位置</strong></li></ul><p>在二进制字节流以特定格式存储在方法区后,JVM会创建一个java.lang.Class类的对象,作为本类的外部访问接口。</p><p>既然是对象就应该存放在Java堆中,不过JVM规范并没有给出限制,不同的虚拟机根据自己的需求存放这个对象。</p><p>HotSpot将Class对象存放在方法区。</p><ul><li><strong>加载阶段和链接阶段是交叉的</strong></li></ul><p>类加载的过程中每个步骤的开始顺序都有严格限制,但每个步骤的结束顺序没有限制。也就是说,类加载过程中,必须按照如下顺序开始:</p><blockquote><p>加载 -&gt; 链接 -&gt; 初始化</p></blockquote><p>但结束顺序无所谓,因此由于每个步骤处理时间的长短不一就会导致有些步骤会出现交叉</p><hr /><p><strong>验证</strong></p><p>验证阶段比较耗时,它非常重要但不一定必要(因为对程序运行期没有影响)<strong>,如果所运行的代码已经被反复使用和验证过,那么可以使用参数关闭,以缩短类加载时间</strong></p><pre><code class="highlight plaintext">-Xverify:none</code></pre><ul><li><strong>验证的目的</strong></li></ul><p>保证二进制字节流中的信息符合虚拟机规范,并没有安全问题</p><ul><li><strong>验证的必要性</strong></li></ul><p>虽然Java语言是一门安全的语言,它能确保程序猿无法访问数组边界以外的内存、避免让一个对象转换成任意类型、避免跳转到不存在的代码行.也就是说,Java语言的安全性是通过编译器来保证的.</p><p>但是我们知道,编译器和虚拟机是两个独立的东西,虚拟机只认二进制字节流,它不会管所获得的二进制字节流是哪来的，当然，如果是编译器给它的，那么就相对安全，但如果是从其它途径获得的，那么无法确保该二进制字节流是安全的。</p><p>通过上文可知，虚拟机规范中没有限制二进制字节流的来源，在字节码层面上,上述Java代码无法做到的都是可以实现的,至少语义上是可以表达出来的,为了防止字节流中有安全问题，需要验证！</p><ul><li><p><strong>验证的过程</strong></p></li><li><p><strong>文件格式验证</strong></p></li></ul><p>验证字节流是否符合Class文件格式的规范,并且能被当前的虚拟机处理.</p><p>本验证阶段是基于二进制字节流进行的,<strong>只有通过本阶段验证,才被允许存到方法区</strong></p><p>后面的三个验证阶段都是基于方法区的存储结构进行,不会再直接操作字节流</p><p>印证【加载和验证】是交叉进行的：</p><ol><li>加载开始前，二进制字节流还没进方法区，而加载完成后，二进制字节流已经存入方法区</li><li>而在文件格式验证前，二进制字节流尚未进入方法区，文件格式验证通过之后才进入方法区，也就是说，加载开始后，立即启动了文件格式验证，本阶段验证通过后，二进制字节流被转换成特定数据结构存储至方法区中，继而开始下阶段的验证和创建Class对象等操作</li></ol><ul><li><strong>元数据验证</strong></li></ul><p>对字节码描述信息进行语义分析,确保符合Java语法规范</p><ul><li><strong>字节码验证</strong></li></ul><p>本阶段是验证过程的最复杂的一个阶段。</p><p>本阶段对方法体进行语义分析,保证方法在运行时不会出现危害虚拟机的事件。</p><p>字节码验证将对类的方法进行校验分析，保证被校验的方法在运行时不会做出危害虚拟机的事，一个类方法体的字节码没有通过字节码验证，那一定有问题，但若一个方法通过了验证，也不能说明它一定安全</p><ul><li><strong>符号引用验证</strong></li></ul><p>发生在JVM将符号引用转化为直接引用的时候,这个转化动作发生在解析阶段,对类自身以外的信息进行匹配校验,确保解析能正常执行</p><hr /><p><strong>准备</strong></p><p>仅仅为类变量（即static修饰的字段变量）分配内存并且设置该类变量的初始值即零值，这里不包含用final修饰的static，因为final在编译的时候就会分配了（编译器的优化），同时这里也不会为实例变量分配初始化。类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</p><p>准备阶段主要完成两件事情：</p><ul><li>为已在方法区中的类的静态成员变量分配内存</li><li>为静态成员变量设置初始值，初始值为0、false、null等</li></ul><p>比如：</p><pre><code class="highlight plaintext">public static int x = 1000;</code></pre><blockquote><p>实际上变量x在准备阶段过后的初始值为0而不是1000</p></blockquote><blockquote><p>将x赋值为1000的putstatic指令是程序被编译后，存放于类构造器<client>方法之中</p></blockquote><p>但是如果声明为</p><pre><code class="highlight plaintext">public static final int x = 1000;</code></pre><blockquote><p>在编译阶段会为x生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将x赋值为1000</p></blockquote><hr /><p><strong>解析</strong></p><p>解析是虚拟机将常量池的符号引用替换为直接引用的过程</p><p>解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info 、CONSTANT_Fieldref_info 、CONSTANT_Methodref_info 、CONSTANT_InterfaceMethodref_info 四种常量类型</p><ol><li><strong>类或接口的解析</strong>：</li></ol><p>判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。</p><ol><li><strong>字段解析</strong>：</li></ol><p>对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束(优先从接口来，然后是继承的父类.理论上是按照上述顺序进行搜索解析，但在实际应用中，虚拟机的编译器实现可能要比上述规范要求的更严格一些。如果有一个同名字段同时出现在该类的接口和父类中，或同时在自己或父类的接口中出现，编译器可能会拒绝编译）.</p><ol><li><strong>类方法解析</strong>：</li></ol><p>对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。</p><ol><li><strong>接口方法解析</strong>：</li></ol><p>与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行了。</p><hr /><p><strong>初始化</strong></p><p>初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码(初始化成为代码设定的默认值)。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源</p><p>其实初始化过程就是调用类初始化方法的过程，完成<strong>对static修饰的类变量的手动赋值</strong>还有<strong>主动调用静态代码块</strong>。</p><p><strong>初始化过程的注意点</strong></p><ul><li>方法是编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的,编译器收集的顺序是由语句在源文件中出现的顺序所决定的.</li><li>静态代码块只能访问到出现在静态代码块之前的变量,定义在它之后的变量,在前面的静态语句块可以赋值,但是不能访问.</li></ul><pre><code class="highlight plaintext">public class Test &#123;    static &#123;        i=0;        System.out.println(i);//编译失败:&quot;非法向前引用&quot;    &#125;    static int i = 1;&#125;</code></pre><ul><li>实例构造器需要显式调用父类构造函数,而类的不需要调用父类的类构造函数,虚拟机会确保子类的方法执行前已经执行完毕父类的方法.因此在JVM中第一个被执行的方法的类肯定是java.lang.Object.</li><li>如果一个类/接口中没有静态代码块,也没有静态成员变量的赋值操作,那么编译器就不会为此类生成方法.</li><li>接口也需要通过方法为接口中定义的静态成员变量显示初始化。接口中不能使用静态代码块,但仍然有变量初始化的赋值操作,因此接口与类一样都会生成方法.不同的是,执行接口的方法不需要先执行父接口的方法.只有当父接口中的静态成员变量被使用到时才会执行父接口的方法.</li><li>虚拟机会保证在多线程环境中一个类的方法别正确地加锁,同步.当多条线程同时去初始化一个类时，只会有一个线程去执行该类的方法,其它线程都被阻塞等待,直到活动线程执行方法完毕.其他线程虽会被阻塞,只要有一个方法执行完,其它线程唤醒后不会再进入方法.<strong>同一个类加载器下,一个类型只会初始化一次</strong>.</li></ul><p><strong>使用静态内部类的单例实现：</strong></p><pre><code class="highlight plaintext">public class Student &#123;private Student() &#123;&#125;/** 此处使用一个内部类来维护单例 JVM在类加载的时候，是互斥的，所以可以由此保证线程安全问题*/private static class SingletonFactory &#123;private static Student student = new Student();&#125;/* 获取实例 */public static Student getSingletonInstance() &#123;return SingletonFactory.student;&#125;&#125;</code></pre><h3 id="类加载的时机"><a class="markdownIt-Anchor" href="#类加载的时机"></a> 类加载的时机</h3><p>什么时候开始加载，虚拟机规范并没有强制性的约束，对于其它大部分阶段究竟何时开始虚拟机规范也都没有进行规范，这些都是交由虚拟机的具体实现来把握。所以不同的虚拟机它们开始的时机可能是不同的。但是对于初始化却严格的规定了有且只有四种情况必须先对类进行“初始化”(加载，验证，准备自然需要在初始化之前完成)：</p><ol><li>遇到new 、getstatic 、putstatic 和invokestatic 这四条指令时，如果对应的类没有初始化，则要对对应的类先进行初始化。</li></ol><ul><li>这四个指令对应到我们java代码中的场景分别是：<ul><li>new关键字实例化对象的时候；</li><li>读取或设置一个类的静态字段（读取被final修饰，已在编译器把结果放入常量池的静态字段除外） ；</li><li>调用类的静态方法时。</li></ul></li></ul><ol><li>使用java.lang.reflect 包方法时对类进行反射调用的时候。</li><li>初始化一个类的时候发现其父类还没初始化，要先初始化其父类。</li><li>当虚拟机开始启动时，用户需要指定一个主类，虚拟机会先执行这个主类的初始化</li></ol><h3 id="类加载器"><a class="markdownIt-Anchor" href="#类加载器"></a> 类加载器</h3><p><strong>启动类加载器</strong>(Bootstrap ClassLoader)：</p><ul><li>负责加载 JAVA_HOME\lib 目录中的，</li><li>或通过-Xbootclasspath参数指定路径中的，</li><li>且被虚拟机认可（按文件名识别，如rt.jar）的类。</li><li>由C++实现，不是ClassLoader子类</li></ul><p><strong>扩展类加载器</strong>(Extension ClassLoader)：</p><ul><li>负责加载 JAVA_HOME\lib\ext 目录中的，</li><li>或通过java.ext.dirs系统变量指定路径中的类库。</li></ul><p><strong>应用程序类加载器</strong>(Application ClassLoader)：</p><ul><li>负责加载用户路径（classpath）上的类</li></ul><p><strong>JVM的类加载是通过ClassLoader及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：</strong></p><p>加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</p><h3 id="自定义类加载器"><a class="markdownIt-Anchor" href="#自定义类加载器"></a> 自定义类加载器</h3><p><strong>自定义类加载器步骤</strong></p><ul><li>继承ClassLoader</li><li>重写findClass（）方法</li><li>调用defineClass（）方法</li></ul><p><strong>实践</strong></p><p>下面写一个自定义类加载器：指定类加载路径在D盘下的lib文件夹下。</p><p>（1）在本地磁盘新建一个Test.java 类，代码如下：</p><pre><code class="highlight plaintext">package jvm.classloader;public class Test &#123;    public void say()&#123;        System.out.println(&quot;Hello MyClassLoader&quot;);    &#125;&#125;</code></pre><p>（2）使用javac -d . Test.java 命令，将生成的Test.class 文件放到D:/lib/jvm/classloader文件夹下</p><p>（3）在Eclipse中自定义类加载器，代码如下：</p><pre><code class="highlight plaintext">package com.lee.configserver;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;public class MyClassLoader extends ClassLoader &#123;    private String classpath;    public MyClassLoader(String classpath) &#123;        this.classpath = classpath;    &#125;    @Override    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;        try &#123;            byte[] classDate = getData(name);            if (classDate == null) &#123;            &#125; else &#123;//defineClass方法将字节码转化为类                return defineClass(name, classDate, 0, classDate.length);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return super.findClass(name);    &#125;    //返回类的字节码    private byte[] getData(String className) throws IOException &#123;        InputStream in = null;        ByteArrayOutputStream out = null;        String path = classpath + File.separatorChar +                className.replace(&#x27;.&#x27;, File.separatorChar) + &quot;.class&quot;;        try &#123;            in = new FileInputStream(path);            out = new ByteArrayOutputStream();            byte[] buffer = new byte[2048];            int len = 0;            while ((len = in.read(buffer)) != -1) &#123;                out.write(buffer, 0, len);            &#125;            return out.toByteArray();        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; finally &#123;            in.close();            out.close();        &#125;        return null;    &#125;&#125;</code></pre><p>测试运行：</p><pre><code class="highlight plaintext">package com.lee.configserver;import java.lang.reflect.Method;public class TestMyClassLoader &#123;    public static void main(String[] args) throws Exception &#123;        //自定义类加载器的加载路径        MyClassLoader myClassLoader = new MyClassLoader(&quot;D:\\lib&quot;);        //包名+类名        Class c = myClassLoader.loadClass(&quot;jvm.classloader.Test&quot;);        if (c != null) &#123;            Object obj = c.newInstance();            Method method = c.getMethod(&quot;say&quot;, null);            method.invoke(obj, null);            System.out.println(c.getClassLoader().toString());        &#125;    &#125;&#125;</code></pre><p><strong>自定义类加载器的作用：</strong></p><p>JVM自带的三个加载器只能加载指定路径下的类字节码。</p><p>如果某个情况下，我们需要加载应用程序之外的类文件呢？比如本地D盘下的，或者去加载网络上的某个类文件，这种情况就可以使用自定义加载器了</p><h3 id="双亲委派模型"><a class="markdownIt-Anchor" href="#双亲委派模型"></a> 双亲委派模型</h3><p>JVM通过双亲委派模型进行类的加载，当然我们也可以通过继承java.lang.ClassLoader实现自定义的类加载器。</p><ul><li>当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，</li><li>只有当父类加载器无法完成加载任务时，才会尝试执行加载任务。</li></ul><p>采用双亲委派的一个好处是：</p><ul><li>比如加载位于rt.jar包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个Object对象。</li></ul><p><strong>为什么要使用双亲委托这种模型呢？</strong></p><p>因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。</p><p>考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，<strong>因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法</strong></p><hr /><p><strong>但是JVM在搜索类的时候，又是如何判定两个class是相同的呢？</strong></p><p>JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。</p><p>只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class</p><p><strong>既然JVM已经提供了默认的类加载器，为什么还要定义自已的类加载器呢？</strong></p><p>因为Java中提供的默认ClassLoader，只加载指定目录下的jar和class，如果我们想加载其它位置的类或jar时。</p><p>比如：我要加载网络上的一个class文件，通过动态加载到内存之后，要调用这个类中的方法实现我的业务逻辑。在这样的情况下，默认的ClassLoader就不能满足我们的需求了，所以需要定义自己的ClassLoader</p><h3 id="破坏双亲委派模型"><a class="markdownIt-Anchor" href="#破坏双亲委派模型"></a> 破坏双亲委派模型</h3><p>因为在某些情况下父类加载器需要委托子类加载器去加载class文件（双亲委派模式的话，是子类委托父类加载器去加载class文件）。因为受到加载范围的限制，父类加载器无法加载到需要的文件。</p><p>以Driver接口为例，由于Driver接口定义在jdk当中的，而其实现由各个数据库的服务商来提供，比如mysql的就写了MySQL Connector ，那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接口的实现类，然后进行管理，但是DriverManager由启动类加载器加载，只能记载JAVA_HOME的lib下文件，而其实现是由服务商提供的，由系统类加载器加载，这个时候就需要启动类加载器来委托子类来加载Driver实现，从而破坏了双亲委派，这里仅仅是举了破坏双亲委派的其中一个情况。</p><pre><code class="highlight plaintext">package com.lee.configserver;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import org.junit.Test;public class TestJdbc &#123;    @Test    public void testJdbc() &#123;        Connection connection = null;        PreparedStatement preparedStatement = null;        ResultSet rs = null;        try &#123;            // 加载数据库驱动            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);            // 通过驱动管理类获取数据库链接connection = DriverManager            connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/ssm?characterEncoding=utf-8&quot;, &quot; root&quot;, &quot;root&quot;);            // 定义sql语句 ?表示占位符            String sql = &quot;select * from user where id = ?&quot;;            // 获取预处理 statement            preparedStatement = connection.prepareStatement(sql);            // 设置参数，第一个参数为 sql 语句中参数的序号（从 1 开始），第二个参数为            preparedStatement.setInt(1, 1);            // 向数据库发出 sql 执行查询，查询出结果集            rs = preparedStatement.executeQuery();            // 遍历查询结果集        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;// 释放资源            if (rs != null) &#123;                try &#123;                    rs.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (preparedStatement != null) &#123;                try &#123;                    preparedStatement.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (connection != null) &#123;                try &#123;                    connection.close();                &#125; catch (SQLException e) &#123;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="运行时数据区"><a class="markdownIt-Anchor" href="#运行时数据区"></a> 运行时数据区</h2><ul><li>方法区：最重要的内存区域，多线程共享，保存了类的信息（名称，成员，接口，父类），反射机制时重要的组成部分，动态进行类操作的实现；</li><li><strong>堆内存</strong>（Heap）:保存对象的真实信息，该内存牵扯到释放问题（GC）</li><li><strong>栈内存</strong>（Stack）:线程的私有空间，在每一次进行方法调用的时候都会存在有栈帧，采用先进后出的设计原则<ul><li>本地变量表：局部参数或者形参，允许保存有32位的插槽（Salt）,如果超过了32位的长度就需要开辟两个连续性的插槽（long，double）</li><li>操作数栈：执行所有得方法计算操作</li><li>常量长引用：String类型，Integer类示例</li><li>返回地址：方法执行完毕后的恢复执行的点</li></ul></li><li>程序计数器：执行指令的一个顺序编码，该区域的所占比例几乎可以忽略</li><li>本地方法栈：与栈内存的功能类似，区别在于是为本地方法服务的</li></ul><h3 id="程序计数器"><a class="markdownIt-Anchor" href="#程序计数器"></a> 程序计数器</h3><p><strong>程序计数器</strong>（Program Counter Register），也叫<strong>PC寄存器</strong>，是一块较小的内存空间，它可以看作是当前线程所执行的字节码指令的行号指示器。字节码解释器的工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支，循环，跳转，异常处理，线程回复等都需要依赖这个计数器来完成。</p><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（针对多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，<strong>每条线程都需要有一个独立的程序计数器</strong>，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>如果一个线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；</p><p>如果正在执行的是一个Native方法，这个计数器的值则为空。</p><p>此内存区域是唯一一个在Java的虚拟机规范中没有规定任何OutOfMemoryError异常情况的区域</p><h3 id="java虚拟机栈"><a class="markdownIt-Anchor" href="#java虚拟机栈"></a> Java虚拟机栈</h3><p>虚拟机栈也是线程私有，而且生命周期与线程相同，每个Java方法在执行的时候都会创建一个栈帧（Stack Frame）</p><h4 id="栈帧"><a class="markdownIt-Anchor" href="#栈帧"></a> 栈帧</h4><p><strong>栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用至执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程</strong>。</p><p>栈帧溢出：</p><pre><code class="highlight plaintext">package com.lee.configserver;public class testMain &#123;    public static void main(String[] args) &#123;        fun();    &#125;    public static void fun() &#123;        fun();//死循环    &#125;&#125;</code></pre><p>输出：</p><p>一个线程中方法的调用链可能会很长，很多方法都同时处于执行状态。对于JVM执行引擎来说，在在活动线程中，只有位于JVM虚拟机栈<strong>栈顶</strong>的元素才是有效的，即称为当前栈帧，与这个栈帧相关连的方法称为<strong>当前方法</strong>，定义这个方法的类叫做当前类。</p><p>执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。如果当前方法调用了其他方法，或者当前方法执行结束，那这个方法的栈帧就不再是当前栈帧了。</p><p>调用新的方法时，新的栈帧也会随之创建。并且随着程序控制权转移到新方法，新的栈帧成为了当前栈帧。方法返回之际，原栈帧会返回方法的执行结果给之前的栈帧(返回给方法调用者)，随后虚拟机将会丢弃此栈帧。</p><p>关于「栈帧」，我们在看看《Java虚拟机规范》中的描述：</p><blockquote><p>栈帧是用来存储数据和部分过程结果的数据结构，同时也用来处理动态连接、方法返回值和异常分派。</p></blockquote><blockquote><p>栈帧随着方法调用而创建，随着方法结束而销毁——无论方法正常完成还是异常完成都算作方法结束。</p></blockquote><blockquote><p>栈帧的存储空间由创建它的线程分配在Java虚拟机栈之中，每一个栈帧都有自己的本地变量表(局部变量表)、操作数栈和指向当前方法所属的类的运行时常量池的引用</p></blockquote><p>接下来，详细讲解一下栈帧中的局部变量表、操作数栈、动态连接、方法返回地址等各个部分的数据结构和作用。</p><h4 id="局部变量表"><a class="markdownIt-Anchor" href="#局部变量表"></a> 局部变量表</h4><p><strong>局部变量表</strong>(Local Variable Table)是一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。局部变量表的容量以变量槽(Variable Slot)为最小单位，Java虚拟机规范并没有定义一个槽所应该占用内存空间的大小，但是规定了一个槽应该可以存放一个32位以内的数据类型</p><blockquote><p>在Java程序编译为Class文件时,就在方法的Code属性中的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。(最大Slot数量)</p></blockquote><p>一个局部变量可以保存一个类型为boolean、byte、char、short、int、float、reference和returnAddress类型的数据。reference类型表示对一个对象实例的引用。returnAddress类型是为jsr、jsr_w和ret指令服务的，目前已经很少使用了</p><p>虚拟机通过索引定位的方法查找相应的局部变量，索引的范围是从0~局部变量表最大容量。如果Slot是32位的，则遇到一个64位数据类型的变量(如long或double型)，则会连续使用两个连续的Slot来存储</p><h4 id="操作数栈"><a class="markdownIt-Anchor" href="#操作数栈"></a> 操作数栈</h4><p><strong>操作数栈</strong>(Operand Stack)也常称为操作栈，它是一个后入先出栈(LIFO)。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到方法的Code属性的max_stacks数据项中。</p><p>操作数栈的每一个元素可以是任意Java数据类型，32位的数据类型占一个栈容量，64位的数据类型占2个栈容量,且在方法执行的任意时刻，操作数栈的深度都不会超过max_stacks中设置的最大值。</p><p>当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。</p><h4 id="动态连接"><a class="markdownIt-Anchor" href="#动态连接"></a> 动态连接</h4><p>在一个class文件中，一个方法要调用其他方法，需要将这些方法的<strong>符号引用</strong>转化为其在内存地址中的<strong>直接引用</strong>，而符号引用存在于方法区中的运行时常量池。</p><p>Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的<strong>动态连接</strong>(Dynamic Linking)。</p><p>这些符号引用一部分会在类加载阶段或者第一次使用时就直接转化为直接引用，这类转化称为静态解析。另一部分将在每次运行期间转化为直接引用，这类转化称为动态连接。</p><h4 id="方法返回"><a class="markdownIt-Anchor" href="#方法返回"></a> 方法返回</h4><p><strong>当一个方法开始执行时，可能有两种方式退出该方法</strong>：</p><ul><li>正常完成出口</li><li>异常完成出口</li></ul><p><strong>正常完成出口</strong>是指方法正常完成并退出，没有抛出任何异常(包括Java虚拟机异常以及执行时通过throw语句显示抛出的异常)。如果当前方法正常完成，则根据当前方法返回的字节码指令，这时有可能会有返回值传递给方法调用者(调用它的方法)，或者无返回值。具体是否有返回值以及返回值的数据类型将根据该方法返回的字节码指令确定</p><p><strong>异常完成出口</strong>是指方法执行过程中遇到异常，并且这个异常在方法体内部没有得到处理，导致方法退出。</p><blockquote><p>无论是Java虚拟机抛出的异常还是代码中使用athrow指令产生的异常，只要在本方法的异常表中没有搜索到相应的异常处理器，就会导致方法退出</p></blockquote><p>无论方法采用何种方式退出，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在当前栈帧中保存一些信息，用来帮他恢复它的上层方法执行状态</p><blockquote><p>方法退出过程实际上就等同于把当前栈帧出栈，因此退出可以执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压如调用者的操作数栈中，调整PC计数器的值以指向方法调用指令后的下一条指令</p></blockquote><p>一般来说，方法正常退出时，调用者的PC计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过异常处理器表确定的，栈帧中一般不会保存此部分信息</p><h4 id="附加信息栈异常"><a class="markdownIt-Anchor" href="#附加信息栈异常"></a> 附加信息/栈异常</h4><p><strong>附加信息</strong></p><p>虚拟机规范允许具体的虚拟机实现增加一些规范中没有描述的信息到栈帧之中，例如和调试相关的信息，这部分信息完全取决于不同的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其</p><p>他附加信息一起归为一类，称为栈帧信息</p><p><strong>栈异常</strong></p><p>Java虚拟机规范中，对该区域规定了这两种异常情况：</p><ol><li>如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出StackOverflowError异常；</li><li>虚拟机栈可以动态拓展，当扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常</li></ol><h3 id="本地方法栈"><a class="markdownIt-Anchor" href="#本地方法栈"></a> 本地方法栈</h3><p>本地方法栈和虚拟机栈相似，区别就是虚拟机栈为虚拟机执行<strong>Java服务（字节码服务）</strong>，而本地方法栈为虚拟机使用到的<strong>Native方法（比如C++方法）服务</strong></p><h4 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h4><p>简单地讲，一个Native Method就是一个java调用非java代码的接口</p><pre><code class="highlight plaintext">&quot;A native method is a Java method whose implementation is provided by nonjava code.&quot;</code></pre><p>一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C</p><p>在定义一个native method时，并不提供实现体（有些像定义一个java interface），因为其实现体是由非java语言在外面实现的。，下面给了一个示例：</p><pre><code class="highlight plaintext">public class IHaveNatives&#123;    native public void Native1( int x ) ;    native static public long Native2() ;    native synchronized private float Native3( Object o ) ;    native void Native4( int[] ary ) throws Exception ;&#125;</code></pre><p>这些方法的声明描述了一些非java代码在这些java代码里看起来像什么样子</p><p><strong>标识符native可以与所有其它的java标识符连用，但是abstract除外</strong>。这是合理的，因为native暗示这些方法是有实现体的，只不过这些实现体是非java的，但是abstract却显然的指明这些方法无实现体。</p><p><strong>native与其它java标识符连用时，其意义同非Native Method并无差别</strong>，比如native static表明这个方法可以在不产生类的实例时直接调用，这非常方便，比如当你想用一个native method去调用一个C的类库时。上面的第三个方法用到了native synchronized，JVM在进入这个方法的实现体之前会执行同步锁机制（就像java的多线程。）</p><p><strong>一个native method方法可以返回任何java类型</strong>，<strong>包括非基本类型，而且同样可以进行异常控制</strong>。这些方法的实现体可以制一个异常并且将其抛出，这一点与java的方法非常相似。</p><p><strong>当一个native method接收到一些非基本类型时如Object或一个整型数组时，这个方法可以访问这些非基本型的内部，但是这将使这个native方法依赖于你所访问的java类的实现</strong>。有一点要牢牢记住：我们可以在一个native method的本地实现中访问所有的java特性，但是这要依赖于你所访问的java特性的实现，而且这样做远远不如在java语言中使用那些特性方便和容易</p><p><strong>native method的存在并不会对其他类调用这些本地方法产生任何影响，实际上调用这些方法的其他类甚至不知道它所调用的是一个本地方法。JVM将控制调用本地方法的所有细节</strong>。需要注意当我们将一个本地方法声明为final的情况。用java实现的方法体在被编译时可能会因为内联而产生效率上的提升。但是一个native final方法是否也能获得这样的好处却是值得怀疑的，但是这只是一个代码优化方面的问题，对功能实现没有影响</p><p><strong>如果一个含有本地方法的类被继承，子类会继承这个本地方法并且可以用java语言重写这个方法（这个似乎看起来有些奇怪），同样的如果一个本地方法被fianl标识，它被继承后不能被重写</strong>。</p><p><strong>本地方法非常有用，因为它有效地扩充了jvm</strong>。事实上，我们所写的java代码已经用到了本地方法，在sun的java的并发（多线程）的机制实现中，许多与操作系统的接触点都用到了本地方法，这使得java程序能够超越java运行时的界限。有了本地方法，java程序可以做任何应用层次的任务</p><hr /><p><strong>为什么要用本地方法？</strong></p><p>java使用起来非常方便，然而有些层次的任务用java实现起来不容易，或者我们对程序的效率很在意时，问题就来了</p><p><strong>有时java应用需要与java外面的环境交互。这是本地方法存在的主要原因，你可以想想java需要与一些底层系统如操作系统或某些硬件交换信息时的情况</strong>。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐的细节</p><p>JVM支持着java语言本身和运行时库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎 样，它毕竟不是一个完整的系统，它经常依赖于一些底层（underneath在下面的）系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的，还有，如果我们要使用一些java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法</p><hr /><p><strong>JVM怎样使本地方法跑起来</strong></p><p>我们知道，当一个类第一次被使用到时，这个类的字节码会被加载到内存，并且只会回载一次。在这个被加载的字节码的入口维持着一个该类所有方法描述符的list，这些方法描述符包含这样一些信息：方法代码存于何处，它有哪些参数，方法的描述符（public之类）等等。</p><p>如果一个方法描述符内有native，这个描述符块将有一个指向该方法的实现的指针。这些实现在一些DLL文件内，但是它们会被操作系统加载到java程序的地址空间。当一个带有本地方法的类被加载时，其相关的DLL并未被加载，因此指向方法实现的指针并不会被设置。当本地方法被调用之前，这些DLL才会被加载，这是通过调用java.system.loadLibrary()实现的。</p><p>最后需要提示的是，使用本地方法是有开销的，它丧失了java的很多好处。如果别无选择，我们可以选择使用本地方法。</p><h4 id="使用流程"><a class="markdownIt-Anchor" href="#使用流程"></a> 使用流程</h4><p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。本地方法可以通过本地方法接口来访问虚拟机的运行时数据区，但不止如此，它还可以做任何它想做的事情。</p><p>本地方法本质上时依赖于实现的，虚拟机实现的设计者们可以自由地决定使用怎样的机制来让Java程序调用本地方法。</p><p>任何本地方法接口都会使用某种本地方法栈。当线程调用Java方法时，虚拟机会创建一个新的栈帧并压入Java栈。<strong>然而当它调用的是本地方法时，虚拟机会保持Java栈不变，不再在线程的Java栈中压入新的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法</strong>。</p><p>如果某个虚拟机实现的本地方法接口是使用C连接模型的话，那么它的本地方法栈就是C栈。当C程序调用一个C函数时，其栈操作都是确定的。传递给该函数的参数以某个确定的顺序压入栈，它的返回值也以确定的方式传回调用者。同样，这就是虚拟机实现中本地方法栈的行为。</p><p>很可能本地方法接口需要回调Java虚拟机中的Java方法，在这种情况下，该线程会保存本地方法栈的状态并进入到另一个Java栈</p><hr /><p><strong>下图描绘了这样一个情景，就是当一个线程调用一个本地方法时，本地方法又回调虚拟机中的另一个Java方法</strong></p><p>这幅图展示了JAVA虚拟机内部线程运行的全景图。一个线程可能在整个生命周期中都执行Java方法，操作它的Java栈；或者它可能毫无障碍地在Java栈和本地方法栈之间跳转</p><p>该线程首先调用了两个Java方法，而第二个Java方法又调用了一个本地方法，这样导致虚拟机使用了一个本地方法栈。假设这是一个C语言栈，其间有两个C函数，第一个C函数被第二个Java方法当做本地方法调用，而这个C函数又调用了第二个C函数。之后第二个C函数又通过本地方法接口回调了一个Java方法（第三个Java方法），最终这个Java方法又调用了一个Java方法（它成为图中的当前方法</p><h3 id="java内存模型"><a class="markdownIt-Anchor" href="#java内存模型"></a> Java内存模型</h3><p>合理的内存模型可以使GC的性能更加强大，不必太大的浪费服务器的性能，从而减少阻塞所带来的程序的性能影响</p><ul><li>例：你现在收拾屋子，基本上我们会有两类收拾方法<ul><li>方式一：简单的进行物品的码放以及打扫卫生，时间短</li><li>方式二：房屋装修与改造，时间长</li></ul></li></ul><p>Java中数据报错的内存位置：堆内存（调优，原理）：</p><ul><li>最需要强调的就是JDK1.8之后所带来的内存结构改变以及GC策略提升</li></ul><p><strong>jdk1.8之前</strong></p><p><strong>jdk1.8之后</strong></p><ul><li>当内存不足的时候需要堆伸缩区进行控制，当内存充足的时候就要考虑将伸缩区的内存释放掉，来回的计算伸缩必会造成额外的计算机性能的影响，导致程序的整体性能下降</li></ul><p><strong>用RunTime类获取当前运行环境的最大内存和最小内存</strong></p><p>RunTime类常用方法：</p><ul><li>getRuntime()：该方法用于返回当前应用程序的运行环境对象</li><li>exec(String command)：该方法用于根据指定的路径执行对应的可执行文件。</li><li>freeMemory()：该方法用于返回Java虚拟机中的空闲内存量，以字节为单位。</li><li>maxMemory()：该方法用于返回Java虚拟机试图使用的最大内存量</li><li>totalMemory()：该方法用于返回Java虚拟机中的内存总量。</li></ul><pre><code class="highlight plaintext">package com.lee.configserver;public class testMain &#123;    public static void main(String[] args) &#123;        //RunTime类主要代表了应用程序的运行环境。一个RunTime就代表一个运行环境        System.out.println(&quot;MAX_MEMORY:&quot;+byteToM(Runtime.getRuntime().maxMemory())+&quot;M&quot;);        System.out.println(&quot;TOTAL_MEMORY:&quot;+byteToM(Runtime.getRuntime().totalMemory())+&quot;M&quot;);    &#125;    public static double round(double num,int scale)&#123;        //Math.pow求次方        //Math.round取整        return Math.round(Math.pow(10, scale) * num) / Math.pow(10, scale);    &#125;    public static double byteToM(long num)&#123;        return round(num/1024/1024,2);    &#125;&#125;</code></pre><blockquote><p>我先自的内存为8G，所以会发现默认的内容：</p><p>MaxMemory：整体电脑内存的1/4</p><p>TotalMemory：整体电脑内存的1/64</p></blockquote><blockquote><p>伸缩区的空间：MaxMemory - TotalMemory = 可变的伸缩区空间极大</p></blockquote><h3 id="jvm调优"><a class="markdownIt-Anchor" href="#jvm调优"></a> JVM调优</h3><p>JVM可以调优的点重要的就是这三点:</p><ul><li>取消伸缩区</li><li>GC执行分析（算法）</li><li>垃圾回收策略</li></ul><h4 id="取消伸缩区"><a class="markdownIt-Anchor" href="#取消伸缩区"></a> 取消伸缩区</h4><p><strong>当伸缩区空间较小的时候那么JVM的性能必然会得到提升</strong></p><p>所以我们程序执行的设置有相应的执行参数：</p><ul><li><code>-Xmx</code>：分配最大的初始化内存</li><li><code>-Xms</code>：最大的分配内存</li></ul><p>执行jar程序的时候就可以加执行参数：</p><pre><code class="highlight plaintext">java -Xmx大小单位 -Xms大小单位 类文件示例：java -Xmx1000M -Xms3G</code></pre><p>示例：</p><p>现在idea中设置jvm启动参数：</p><p>然后执行程序：</p><pre><code class="highlight plaintext">package com.lee.configserver;public class testMain &#123;    public static void main(String[] args) &#123;        //RunTime类主要代表了应用程序的运行环境。一个RunTime就代表一个运行环境        System.out.println(&quot;MAX_MEMORY:&quot;+byteToM(Runtime.getRuntime().maxMemory())+&quot;M&quot;);        System.out.println(&quot;TOTAL_MEMORY:&quot;+byteToM(Runtime.getRuntime().totalMemory())+&quot;M&quot;);    &#125;    public static double round(double num,int scale)&#123;        //Math.pow求次方        //Math.round取整        return Math.round(Math.pow(10, scale) * num) / Math.pow(10, scale);    &#125;    public static double byteToM(long num)&#123;        return round(num/1024/1024,2);    &#125;&#125;</code></pre><p>结果：</p><ul><li>我们发现，加了启动参数后，jvm的运行时空间内存发生了改变</li></ul><h4 id="gc处理流程"><a class="markdownIt-Anchor" href="#gc处理流程"></a> GC处理流程</h4><ol><li>对象实例化需要依据关键字new完成，所有的新对象都会在伊甸园开辟，如果伊甸园的内存空间不足会发生MinorGc<ul><li>Member mem = new Member(); 很小，直接保存在伊甸园；</li></ul></li><li>伊甸园不是无限大的，所以肯定有些对象执行了N次的MinorGC后还会存在，那么这些对象将进入到存货区（存货区有两个，一个负责保存存活对象，一个负责晋升，永远都有一个空内存）</li><li>如果经历过若干次的MinorGC回收处理之后发现空间依然不够使用的，那么则进行老年代的GC回收，执行了一个MajorGC(Full GC，性能很差)，如果可以回收空间，则继续进行MinorGC</li><li>如果MajorGC失败，则继续内存已经占满，则抛出OOM异常</li><li>如果新创建的对象的空间占用过大将直接保存到老年代之中</li></ol><p>让内存溢出：</p><pre><code class="highlight plaintext">package com.lee.configserver;public class testMain &#123;    public static void main(String[] args) &#123;        String str = &quot;hello&quot;;        for(int x = 0;x&lt;Integer.MAX_VALUE;x++)&#123;            //str.intern()返回一个字符串，内容与此字符串相同，但一定取自具有唯一字符串的池            str += str.intern();        &#125;    &#125;&#125;</code></pre><h4 id="查看垃圾回收"><a class="markdownIt-Anchor" href="#查看垃圾回收"></a> 查看垃圾回收</h4><pre><code class="highlight plaintext">-Xmx20M -Xms20M -XX:+PrintGCDetails     //JDK1.9之后使用-XX:+PrintGCDetails查看垃圾回收详情-Xmx2M -Xms2M -Xlog:gc*    //JDK1.9之后使用-Xlog:gc* 查看垃圾回收详情</code></pre><blockquote><p>JDK1.8的时候默认会根据系统的不同而选择不同的GC回收策略</p><p>JDK1.9之后，使用的默认GC操作就是G1</p></blockquote><p><strong>JDK1.8</strong></p><pre><code class="highlight plaintext">package com.lee.configserver;public class testMain &#123;    public static void main(String[] args) &#123;        String str = &quot;hello&quot;;        for(int x = 0;x&lt;Integer.MAX_VALUE;x++)&#123;            //str.intern()返回一个字符串，内容与此字符串相同，但一定取自具有唯一字符串的池            str += str.intern();        &#125;    &#125;&#125;</code></pre><p>给上述代码加上启动参数：</p><pre><code class="highlight plaintext">-Xmx20M -Xms20M -XX:+PrintGCDetails</code></pre><p>输出：</p><p><strong>JDK1.9之后</strong></p><pre><code class="highlight plaintext">package com.lee.configserver;public class testMain &#123;    public static void main(String[] args) &#123;        String str = &quot;hello&quot;;        for(int x = 0;x&lt;Integer.MAX_VALUE;x++)&#123;            //str.intern()返回一个字符串，内容与此字符串相同，但一定取自具有唯一字符串的池            str += str.intern();        &#125;    &#125;&#125;</code></pre><p>给上述代码加上启动参数：</p><pre><code class="highlight plaintext">-Xmx2M -Xms2M -Xlog:gc*</code></pre><p>运行：</p><h4 id="内存回收算法"><a class="markdownIt-Anchor" href="#内存回收算法"></a> 内存回收算法</h4><p>年轻代回收算法：</p><ul><li>“复制”清理算法：将保留的对象复制到存货区之中，存货区的内容或保存到老年代之中</li><li>伊甸园区总是会有大量的新对象产生，所以HotSpot虚拟机使用了BTP（单核CPU的试带所有的对象依次保存，相当于队列），TLAB（多核CPU，吧队列拆分为不同的块，依据CPU的核心个数拆分）两种技术形式的处理</li></ul><p>老年代回收算法：</p><ul><li>“标记-清除”算法：先进性对象的第一次标记，在这段时间之内会暂停程序的执行（如果标记的时间过程或者对象的内容过多），这个暂停的时间就会长<ul><li>串行GC</li><li>并行回收GC</li><li>并行GC</li></ul></li><li>“标记-压缩”算法：基于“标记-清除”算法，将零散的内存空间进重新整理在进行分配<ul><li>串行GC</li><li>并行回收GC</li><li>CMS(挂起)<ul><li>STW(Stop-The-World)设计问题，暂时挂起所有的程序的执行线程，进行无用的对象标记</li></ul></li></ul></li></ul><blockquote><p>没有任何一项合适的GC回收操作能完美的解决完美回收，从JDK1.8开始提供了G1收集器，在JDK11之后提供了ZGC</p></blockquote><p><strong>G1算法</strong></p><ul><li>支持大内存（4G-64G），支持有多CPU，减少STW停顿时间，可以保证并发状态下的程序执行</li><li>G1算法实际就是把Java内存给分了一堆块，每一个块都包含完整的老年代，年轻代，都是相对独立的内存空间，所以只是单个块的垃圾回收，那么内存不会特别大，对象也不会特别多，只会影响一小部分用户，其他用户不会受到影响</li></ul><p>jdk1.8之前可以手动的更改为G1算法回收</p><pre><code class="highlight plaintext">-XX:+UseG1GC</code></pre><blockquote><p>jdk11之后默认就是G1回收器，对于其他的回收算法实际上可以忽略掉</p></blockquote><h3 id="java堆"><a class="markdownIt-Anchor" href="#java堆"></a> Java堆</h3><p>Java堆被所有线程共享，在Java虚拟机启动时创建。是虚拟机管理最大的一块内存。</p><p><strong>唯一目的是存放对象实例，Java虚拟机规范的描是：所有的对象实例以及数组都要在堆上分配</strong></p><p>随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”</p><ul><li>内存空间在物理上可以不连续，逻辑上连续即可。</li><li>Java堆是垃圾回收的主要区域，主要采用分代回收算法。</li><li>堆进一步划分主要是为了更好的回收内存或更快的分配内存</li></ul><h4 id="堆分类"><a class="markdownIt-Anchor" href="#堆分类"></a> 堆分类</h4><p><strong>1.8之前</strong></p><ul><li>新生代（Eden空间[伊甸园]，From Survivor空间，To Survivor空间）</li><li>老年代</li><li>永久代</li></ul><p><strong>1.8之后(含1.8)</strong></p><ul><li>新生代（Eden空间[伊甸园]，From Survivor空间，To Survivor空间）、</li><li>老年代</li><li>Meta Space</li></ul><p>在 JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）</p><hr /><p><strong>堆内存划分：</strong></p><ul><li>堆大小 = 新生代 + 老年代。堆的大小可通过参数–Xms（堆的初始容量）、-Xmx（堆的最大容量） 来指定。</li></ul><pre><code class="highlight plaintext">java -Xmx大小单位 -Xms大小单位 类文件示例：java -Xmx1000M -Xms3G</code></pre><ul><li>其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。默认的，Edem : from : to = 8 : 1 : 1 。(可以通过参数 –XX:SurvivorRatio 来设定 。</li></ul><blockquote><p>即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。</p></blockquote><pre><code class="highlight plaintext">–XX:SurvivorRatio大小单位</code></pre><ul><li>JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。</li><li>新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间</li></ul><h4 id="对象创建"><a class="markdownIt-Anchor" href="#对象创建"></a> 对象创建</h4><pre><code class="highlight plaintext">Student stu = new Student();</code></pre><h4 id="内存分配"><a class="markdownIt-Anchor" href="#内存分配"></a> 内存分配</h4><p><strong>内存分配原则</strong></p><table><thead><tr><th>序号</th><th>介绍</th></tr></thead><tbody><tr><td>1</td><td>优先在Eden分配,如果Eden空间不足虚拟机则会进行一次MinorGC</td></tr><tr><td>2</td><td>大对象直接接入老年代,大对象一般指的是很长的字符串或数组</td></tr><tr><td>3</td><td>长期存活的对象进入老年代，每个对象都有一个age，当age到达设定的年龄的时候就会进入老年代，默认是15岁</td></tr></tbody></table><p><strong>内存分配</strong></p><p>内存分配的方法有两种:指针碰撞(Bump the Pointer)和空闲列表(Free List)</p><table><thead><tr><th>分配方法</th><th>说明</th><th>收集器</th></tr></thead><tbody><tr><td>指针碰撞</td><td>内存地址是连续的</td><td>Serial和ParNew收集器</td></tr><tr><td>空闲列表</td><td>内存地址不连续</td><td>CMS收集器和Mark-Sweep收集器</td></tr></tbody></table><hr /><p><strong>内存分配安全问题</strong></p><p>在分配内存的同时，存在线程安全的问题，即虚拟机给A线程分配内存过程中，指针未修改，B线程可能同时使用了同样一块内存。</p><p>在JVM中有两种解决办法：</p><ol><li>**CAS，比较和交换（**Compare And Swap）： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</li><li><strong>TLAB，本地线程分配缓冲</strong>(Thread Local Allocation Buffer即TLAB)： 为每一个线程预先分配一块内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配。</li></ol><h4 id="对象的访问"><a class="markdownIt-Anchor" href="#对象的访问"></a> 对象的访问</h4><table><thead><tr><th>方式</th><th>优点</th></tr></thead><tbody><tr><td>句柄</td><td>稳定，对象被移动只要修改句柄中的地址</td></tr><tr><td>直接指针</td><td>访问速度快，节省了一次指针定位的开销</td></tr></tbody></table><h4 id="数组内存分析"><a class="markdownIt-Anchor" href="#数组内存分析"></a> 数组内存分析</h4><p><strong>一维数组</strong></p><pre><code class="highlight plaintext">int[] arr1 = new int[3];</code></pre><p>先把 arr1 压进栈，然后在堆空间中开辟一个空间，并把值初始化为0（arr1为引用变量，但是内部数据是int类型，默认值为 0）,最后把 开辟的堆空间地址 赋值给arr1</p><pre><code class="highlight plaintext">int[] arr2 = arr1;</code></pre><p>把 arr1 中的 地址 赋值给 arr2，此时 arr2 和 arr1 指向同一块空间</p><pre><code class="highlight plaintext">arr2[0] = 20;</code></pre><p>此时，arr1[0] 值为 20</p><hr /><p><strong>二维数组</strong></p><pre><code class="highlight plaintext">int[][] array = new int[3][];</code></pre><p>这条语句会先把 array 压栈，然后在堆中开辟一个空间，初始值为 null（array为引用变量，第一维同样是引用类型），最后把开辟的堆空间地址赋值给 array</p><pre><code class="highlight plaintext">array[0][] = new int[1]</code></pre><p>这条语句会在堆空间中开辟一个 只有一个 int 类型大小的空间，并初始化为 0 ，然后把自己的地址赋值给array<code>[0][]</code></p><pre><code class="highlight plaintext">array[1][] = new int[2];array[2][] = new int[3];</code></pre><h3 id="方法区"><a class="markdownIt-Anchor" href="#方法区"></a> 方法区</h3><h4 id="永久代-方法区-元空间的关系"><a class="markdownIt-Anchor" href="#永久代-方法区-元空间的关系"></a> 永久代、方法区、元空间的关系</h4><p><strong>jdk1.8之前</strong></p><p><strong>jdk1.8之后</strong></p><ul><li>当内存不足的时候需要堆伸缩区进行控制，当内存充足的时候就要考虑将伸缩区的内存释放掉，来回的计算伸缩必会造成额外的计算机性能的影响，导致程序的整体性能下降</li></ul><p>涉及到JVM内存结构时，往往会提到永久代，那么它和方法区又是什么关系呢？</p><p><strong>《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它</strong>。</p><p>那么，在不同的 JVM 上方法区的实现肯定是不同的了。 同时大多数用的JVM都是Sun公司的HotSpot。在HotSpot上把GC分代收集扩展至方法区，或者说<strong>使用永久代来实现方法区</strong>。</p><p>因此，我们得到了结论，永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现。而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。</p><ul><li>在1.7之前在(JDK1.2 ~ JDK7)的实现中，HotSpot 使用永久代实现方法区，HotSpot 使用 GC分代来实现方法区内存回收，可以使用如下参数来调节方法区的大小:</li></ul><pre><code class="highlight plaintext">-XX:PermSize：方法区初始大小-XX:MaxPermSize：方法区最大大小超过这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: PermGen</code></pre><ul><li>对于Java8， HotSpots取消了永久代，那么是不是也就没有方法区了呢？当然不是，方法区是一个规范，规范没变，它就一直在。那么取代永久代的就是元空间</li></ul><p><strong>元空间和永久代有什么不同的？</strong></p><p>存储位置不同，永久代物理是是堆的一部分，和新生代，老年代地址是连续的，而元空间属于本地内存；</p><p>存储内容不同，元空间存储类的元信息，[静态变量]和[常量池]等并入堆中。相当于永久代的数据被分到了堆和元空间中</p><hr /><p>通过上面分析，大家应该大致了解了 JVM 的内存划分，也清楚了 JDK 8 中永久代向元空间的转换。不过大家应该都有一个疑问，就是为什么要做这个转换？带着这个疑问，最后给大家总结以下几点原因：</p><ol><li>字符串存在永久代中，容易出现性能问题和内存溢出。</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢</li></ol><p>出，太大则容易导致老年代溢出。</p><ol><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li><li>Oracle 可能会将HotSpot 与 JRockit 合二为一。</li></ol><h4 id="permgen永久代"><a class="markdownIt-Anchor" href="#permgen永久代"></a> PermGen(永久代)</h4><p>绝大部分 Java 程序员应该都见过 &quot;java.lang.OutOfMemoryError: PermGen space &quot;这个异常。这里的 “PermGen space”其实指的就是方法区。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出</p><p>我们现在通过动态生成类来模拟永久代的内存溢出(本例中使用的 JDK 版本是 1.7，指定的 PermGen区的大小为 8M)：</p><pre><code class="highlight plaintext">package com.kkb.test.memory;public class Test &#123;&#125;</code></pre><pre><code class="highlight plaintext">package com.kkb.test.memory;import java.io.File;import java.net.URL;import java.net.URLClassLoader;import java.util.ArrayList;import java.util.List;public class PermGenOomMock&#123;    public static void main(String[] args) &#123;        URL url = null;        List&lt;ClassLoader&gt; classLoaderList = new ArrayList&lt;ClassLoader&gt;();        try &#123;             url = new File(&quot;/tmp&quot;).toURI().toURL();             URL[] urls = &#123;url&#125;;        while (true)&#123;            ClassLoader loader = new URLClassLoader(urls);            classLoaderList.add(loader);            loader.loadClass(&quot;com.kkb.test.memory.Test&quot;);        &#125;        &#125; catch (Exception e) &#123;           e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>通过每次生成不同URLClassLoader对象来加载Test类，从而生成不同的类对象，这样就能看到我们熟</p><p>悉的 &quot;java.lang.OutOfMemoryError: PermGen space &quot; 异常了。这里之所以采用 JDK 1.7，是因为在JDK 1.8 中， HotSpot 已经没有 “PermGen space”这个区间了，取而代之是一个叫做 Metaspace（元空间） 的东西。下面我们就来看看 Metaspace 与 PermGen space 的区别</p><h4 id="metaspace元空间"><a class="markdownIt-Anchor" href="#metaspace元空间"></a> Metaspace(元空间)</h4><p>方法区也是所有线程共享。主要用于存储类的信息、常量池、方法数据、方法代码等。</p><p><strong>方法区是JVM 的规范，永久代（PermGen space）是HotSpot对这种规范的实现</strong></p><p>其实，移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了JavaHeap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。我们可以通过一段程序来比较 JDK 1.6 与 JDK 1.7及 JDK 1.8 的区别，以字符串常量为例：</p><pre><code class="highlight plaintext">package com.kkb.test.memory;import java.util.ArrayList;import java.util.List;public class StringOomMock &#123;static String base = &quot;string&quot;;public static void main(String[] args) &#123;List&lt;String&gt; list = new ArrayList&lt;String&gt;();for (int i=0;i&lt; Integer.MAX_VALUE;i++)&#123;String str = base + base;base = str;list.add(str.intern());&#125;&#125;&#125;</code></pre><p>这段程序以2的指数级不断的生成新的字符串，这样可以比较快速的消耗内存。我们通过 JDK 1.6、JDK1.7 和 JDK 1.8 分别运行：</p><p>从上述结果可以看出，JDK 1.6下，会出现“PermGen Space”的内存溢出，而在 JDK 1.7和 JDK 1.8 中，会出现堆内存溢出，并且 JDK 1.8中 PermSize 和 MaxPermGen 已经无效。因此，可以大致验证 JDK1.7 和 1.8 将字符串常量由永久代转移到堆中，并且 JDK 1.8 中已经不存在永久代的结论。</p><hr /><p><strong>现在我们看看元空间到底是一个什么东西？</strong></p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：<strong>元空间并不在虚拟机中，而是使用本地内存</strong>。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</p><pre><code class="highlight plaintext">-XX:MetaspaceSize：初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。-XX:MaxMetaspaceSize：最大空间，默认是没有限制的。除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：-XX:MinMetaspaceFreeRatio：在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集-XX:MaxMetaspaceFreeRatio：在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</code></pre><p>现在我们在 JDK 8下重新运行一下代码段 4，不过这次不再指定 PermSize 和 MaxPermSize。而是指定MetaSpaceSize 和 MaxMetaSpaceSize的大小。输出结果如下：</p><blockquote><p>从输出结果，我们可以看出，这次不再出现永久代溢出，而是出现了元空间的溢出。</p></blockquote><h3 id="运行时常量池字符串常量池"><a class="markdownIt-Anchor" href="#运行时常量池字符串常量池"></a> 运行时常量池/字符串常量池</h3><p>运行时常量池存储在哪？</p><ul><li><strong>&lt;=JDK1.6</strong>，运行时常量池是方法区的一部分。</li><li><strong>&gt;=JDK1.7</strong>，运行时常量池在Java 堆（Heap）中</li></ul><p>class常量池存放编译期生成的字面量和符号引用，这部分将在类加载后放到运行时常量池中。<strong>运行时常量池也是每个类都有一个</strong></p><hr /><p><strong>运行时常量池中存储的内容是什么？</strong></p><p><strong>class常量池与运行时常量池区别</strong></p><p>运行时常量池具有动态性，java运行期间也可能将新的常量放入池中</p><p>它的字面量可以动态的添加(String#intern()),符号引用可以被解析为直接引用</p><p><strong>字符串常量池存储在哪？</strong></p><p>在JDK6.0及之前版本，字符串常量池是放在Perm Gen区(也就是方法区)中；</p><p>在JDK7.0版本，被移到了堆中。大概是由于方法区的内存空间太小了。</p><p><strong>String Pool是什么？</strong></p><p>在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个Hash表，默认值大小长度是1009；这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。字符串常量由一个一个字符组成，放在了StringTable上。</p><p>在JDK6.0中，StringTable的长度是固定的，长度就是1009，因此如果放入String Pool中的String非常多，就会造成hash冲突，导致链表过长，当调用String.intern()时会需要到链表上一个一个找，从而导致性能大幅度下降；</p><p>在JDK7.0中，StringTable的长度可以通过参数指定：</p><pre><code class="highlight plaintext">-XX:StringTableSize=66666</code></pre><p><strong>字符串常量池中存储的是值还是引用？</strong></p><p>在JDK6.0及之前版本中，String Pool里放的都是字符串常量</p><p>在JDK7.0中，由于String.intern()发生改变，因此也可存放放于堆内的字符串对象的引用</p><blockquote><p>需要说明的是：字符串常量池中的字符串只存在一份！</p></blockquote><pre><code class="highlight plaintext">String s1 = &quot;hello,world!&quot;;String s2 = &quot;hello,world!&quot;;s1 == s2 // true</code></pre><hr /><p><strong>String和String Pool的关系</strong></p><p>1、<strong>不可变的String</strong></p><p>String的底层实际上是使用private final char[] value来实现字符串的存储的，就是说String对象一旦创建之后，就不能再修改这个对象存储的字符串内容。正因为如此，也说String类是不可改变的</p><p>2、<strong>什么是String Pool</strong></p><p>在JVM中存放着一个字符串池，其中保存着很多String对象，这些对象可以被共享使用。当以字符串直接创建String对象时，会首先在字符串池中查找是否存在该常量。如果不存在，则在String</p><p>Pool中创建一个，然后将其地址返回。如果在String Pool中查询到已经存在该常量，则不创建对象，直接返回这个对象地址。</p><p>3、<strong>String的创建</strong></p><p>有了以上两个概念，就可以说说String的创建了。String主要有两种创建方式，如下：</p><pre><code class="highlight plaintext">String str1 = new String(“abc”);String str2 = “abc”;</code></pre><p>虽然两个语句都是返回一个String对象的引用，但是JVM对这两种创建的方式是不一样的。对于第一种，JVM会在内部维护的String Pool中存放一个”abc”的对象，并且在heap中创建一个String对象，然后将该heap中的对象的引用返回给用户。第二种，JVM首先会在String Pool中查找是否存在”abc”对象，如果已经有则不创建，没有的话则在String Pool中创建一个对象</p><hr /><p>有了以上概念，列一个经常考的面试题：</p><pre><code class="highlight plaintext">String s1 = new String(“abc”);String s2 = new String(“abc”);</code></pre><p>上面创建了几个String对象？（3个）</p><hr /><p><strong>String的Intern方法详解</strong></p><p><strong>引言</strong></p><p>String 类型的常量池比较特殊。它的主要使用方法有两种：</p><ul><li>直接使用双引号声明出来的String 对象会直接存储在常量池中。</li><li>如果不是用双引号声明的String 对象，可以使用String 提供的intern 方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中</li></ul><p><strong>intern 的实现原理</strong></p><p>String#intern 方法中看到，这个方法是一个 native 的方法，但注释写的非常明了。“如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回”。</p><p>它的大体实现结构就是:JAVA 使用 jni 调用c++实现的StringTable 的intern 方法, StringTable的intern 方法跟Java中的HashMap 的实现是差不多的, 只是不能自动扩容。默认大小是1009。</p><p>要注意的是，String的String Pool是一个固定大小的Hashtable ，默认值大小长度是1009，如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern 时性能会大幅下降</p><ul><li>在jdk6中StringTable 是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。</li><li>在jdk7中， StringTable 的长度可以通过一个参数指定：</li></ul><pre><code class="highlight plaintext">-XX:StringTableSize=99991</code></pre><hr /><p><strong>jdk6 和 jdk7 下 intern 的区别</strong></p><p>相信很多 JAVA 程序员都做做类似 String s = new String(“abc”) 这个语句创建了几个对象的题目。 这种题目主要就是为了考察程序员对字符串对象的常量池掌握与否。</p><p>上述的语句中是创建了2个对象，第一个对象是”abc”字符串存储在常量池中，第二个对象在JAVA Heap中的 String 对象</p><pre><code class="highlight plaintext">public static void main(String[] args) &#123;    String s = new String(&quot;1&quot;);    s.intern();    String s2 = &quot;1&quot;;    System.out.println(s == s2);    String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);    s3.intern();    String s4 = &quot;11&quot;;    System.out.println(s3 == s4);&#125;</code></pre><p>输出：</p><ul><li>jdk6 下 <code>false false</code></li><li>jdk7 下 <code>false true</code></li></ul><p>具体为什么稍后再解释，然后将s3.intern(); 语句下调一行，放到String s4 = “11”; 后面。将s.intern(); 放到String s2 = “1”; 后面。是什么结果呢</p><pre><code class="highlight plaintext">public static void main(String[] args) &#123;    String s = new String(&quot;1&quot;);    String s2 = &quot;1&quot;;    s.intern();    System.out.println(s == s2);    String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);    String s4 = &quot;11&quot;;    s3.intern();    System.out.println(s3 == s4);&#125;</code></pre><p>打印结果为：</p><ul><li>jdk6 下<code>false false</code></li><li>jdk7 下<code>false false</code></li></ul><p><strong>1.jdk6中的解释</strong></p><blockquote><p>注：图中绿色线条代表 string 对象的内容指向。 黑色线条代表地址指向。</p></blockquote><p>如上图所示。首先说一下 jdk6中的情况，在 jdk6中上述的所有打印都是 false 的，因为 jdk6中的常量池是放在 Perm 区中的，Perm区和正常的 JAVA Heap 区域是完全分开的。上面说过如果是使用引号声明的字符串都是会直接在字符串常量池中生成，而 new 出来的 String 对象是放在 JAVA Heap 区域。所以拿一个 JAVA Heap 区域的对象地址和字符串常量池的对象地址进行比较肯定是不相同的，即使调用String.intern 方法也是没有任何关系的</p><p><strong>2.jdk7中的解释</strong></p><p>在 Jdk6 以及以前的版本中，字符串的常量池是放在堆的Perm区的，Perm区是一个类静态的区域，主要存储一些加载类的信息，常量池，方法片段等内容，默认大小只有4m，一旦常量池中大量使用intern 是会直接产生java.lang.OutOfMemoryError:PermGen space 错误的。在 jdk7 的版本中，字符串常量池已经从Perm区移到正常的Java Heap区域了。为什么要移动，Perm 区域太小是一个主要原因，当然据消息称jdk8已经直接取消了Perm区域，而新建立了一个元区域。应该是jdk开发者认为Perm区域已经不适合现在 JAVA 的发展了。正式因为字符串常量池移动到JAVA Heap区域后，再来解释为什么会有上述的打印结果。</p><ul><li><p>在第一段代码中，先看 s3和s4字符串。String s3 = new String(“1”) + new String(“1”); ，这句代码中现在生成了2最终个对象，是字符串常量池中的“1” 和 JAVA Heap中的s3引用指向的对象。中间还有2个匿名的new String(“1”) 我们不去讨论它们。此时s3引用对象内容是”11″，但此时常量池中是没有 “11”对象的。</p></li><li><p>接下来s3.intern(); 这一句代码，是将 s3中的&quot;11&quot;字符串放入String 常量池中，因为此时常量池中不存在&quot;11&quot;字符串，因此常规做法是跟 jdk6 图中表示的那样，在常量池中生成一个&quot;11&quot;的对象，关键点是 jdk7 中常量池不在Perm区域了，这块做了调整。常量池中不需要再存储一份对象了，可以直接存储堆中的引用。这份引用指向s3引用的对象。 也就是说引用地址是相同的。</p></li><li><p>最后String s4 = “11”; 这句代码中”11″是显示声明的，因此会直接去常量池中创建，创建的时候发现已经有这个对象了，此时也就是指向s3引用对象的一个引用。所以s4引用就指向和s3一样了。因此最后的比较 s3 == s4 是 true。</p></li><li><p>再看s和 s2 对象。String s = new String(“1”); 第一句代码，生成了2个对象。常量池中的“1”和 JAVA Heap 中的字符串对象。s.intern(); 这一句是 s 对象去常量池中寻找后发现 “1” 已经在常量池里了。</p></li><li><p>接下来String s2 = “1”; 这句代码是生成一个 s2的引用指向常量池中的“1”对象。 结果就是 s 和s2 的引用地址明显不同。图中画的很清晰。</p></li><li><p>来看第二段代码，从上边第二幅图中观察。第一段代码和第二段代码的改变就是 s3.intern();的顺序是放在String s4 = “11”; 后了。这样，首先执行String s4 = “11”; 声明 s4 的时候常量池中是不存在“11”对象的，执行完毕后，“11“对象是 s4 声明产生的新对象。然后再执行s3.intern(); 时，常量池中“11”对象已经存在了，因此 s3 和 s4 的引用是不同的。</p></li><li><p>第二段代码中的 s 和 s2 代码中， s.intern(); ，这一句往后放也不会有什么影响了，因为对象池中在执行第一句代码String s = new String(“1”); 的时候已经生成“1”对象了。下边的s2声明都是直接从常量池中取地址引用的。 s 和 s2 的引用地址是不会相等的</p></li></ul><p><strong>小结</strong></p><p>从上述的例子代码可以看出 jdk7 版本对 intern 操作和常量池都做了一定的修改。主要包括2点：</p><ul><li>将String常量池从Perm区移动到了Java Heap区</li><li>String#intern 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象</li></ul><h2 id="jvm如何运行字节码"><a class="markdownIt-Anchor" href="#jvm如何运行字节码"></a> JVM如何运行字节码</h2><h2 id="jvm堆溢出分析"><a class="markdownIt-Anchor" href="#jvm堆溢出分析"></a> JVM堆溢出分析</h2><h3 id="jconsole内存监控工具"><a class="markdownIt-Anchor" href="#jconsole内存监控工具"></a> jconsole内存监控工具</h3><p>该工具可以实时监控正在运行的java程序的一些内存使用情况</p><p>工具在java home安装目录的bin目录下，直接双击运行</p><h3 id="jmap内存分析工具"><a class="markdownIt-Anchor" href="#jmap内存分析工具"></a> jmap内存分析工具</h3><p>jdk自带的jvm内存分析的工具可以查看当前堆内对象的使用情况</p><h2 id="jvm远程debug"><a class="markdownIt-Anchor" href="#jvm远程debug"></a> JVM远程debug</h2><p><strong>java启动jar包时加入参数</strong></p><ul><li>指定运行的被调试应用和调试者之间的通信协议，(ie: transport=dt_socket)</li><li>远程被调试应用开通的端口，(ie: address=1043)， 可定义其他端口，比如9999</li><li>server=y 表示这个 JVM 即将被调试</li><li>suspend=n 用来告知 JVM 立即执行，不要等待未来将要附着上/连上（attached）的调试者。如果设成 y, 则应用将暂停不运行，直到有调试者连接上</li></ul><pre><code class="highlight plaintext">-agentlib:jdwp=transport=dt_socket,address=1043,server=y,suspend=n</code></pre><p><s>或者(旧版方式)：</s></p><pre><code class="highlight plaintext">-Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=1043,suspend=n</code></pre><p><strong>Remote JVM debug</strong></p><p>idea配置remote jvm debug即可：</p><p><strong>远程JVM调试怎么工作的</strong></p><p>一切源于被称作 Agents 的东西。运行着各种编译过的 .class 文件的JVM， 有一种特性，可以允许外部的库（Java或C++写的libraries）在运行时注入到 JVM 中。这些外部的库就称作 Agents, 他们有能力修改运行中 .class 文件的内容。</p><p>这些 Agents 拥有的这些 JVM 的功能权限， 是在 JVM 内运行的 Java Code 所无法获取的， 他们能用来做一些有趣的事情，比如修改运行中的源码， 性能分析等。 像 JRebel 工具就是用了这些功能达到魔术般的效果。</p><p>传递一个 Agent Lib 给 JVM, 通过添加 agentlib:libname[=options] 格式的启动参数即可办到。像上面的远程调试我们用的就是 **-agentlib:jdwp=… **来引入 jdwp 这个 Agent 的。</p><p>jdwp 是一个 JVM 特定的 JDWP（Java Debug Wire Protocol） 可选实现，用来定义调试者与运行JVM之间的通讯，它的是通过 JVM 本地库的 <a href="http://jdwp.so">jdwp.so</a> 或者 jdwp.dll 支持实现的。</p><p><strong>它到底是怎么工作的呢？</strong></p><p>简单来说， jdwp agent 会建立运行应用的 JVM 和调试者（本地或者远程）之间的桥梁。既然他是一个Agent Library, 它就有能力拦截运行的代码。</p><p>在 JVM 架构里， debugging 功能在 JVM 本身的内部是找不到的，它是一种抽象到外部工具的方式（也称作调试者 debugger）。这些调试工具或者运行在 JVM 的本地 或者在远程。这是一种解耦，模块化的架构。</p>]]>
    </content>
    <id>http://example.com/2022/11/01/JVM/</id>
    <link href="http://example.com/2022/11/01/JVM/"/>
    <published>2022-11-01T05:00:00.000Z</published>
    <summary>本文详细介绍了Jvm的核心概念，CLASS文件，类加载子系统，运行时数据区，Java虚拟机栈，本地方法栈，Java内存模型，JVM调优，JVM堆溢出分析，JVM远程debug。</summary>
    <title>Jvm</title>
    <updated>2026-02-26T08:50:16.672Z</updated>
  </entry>
</feed>
