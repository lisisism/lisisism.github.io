<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <author>
    <name>Lism</name>
  </author>
  <generator uri="https://hexo.io/">Hexo</generator>
  <id>http://example.com/</id>
  <link href="http://example.com/" rel="alternate"/>
  <link href="http://example.com/atom.xml" rel="self"/>
  <rights>All rights reserved 2026, Lism</rights>
  <title>/Lism Blog</title>
  <updated>2026-02-27T01:39:31.319Z</updated>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    <category term="ZFS" scheme="http://example.com/tags/ZFS/"/>
    <content>
      <![CDATA[<h1 id="zfs"><a class="markdownIt-Anchor" href="#zfs"></a> zfs</h1><p>ZFS（Zettabyte File System）是一种高级的文件系统和卷管理器，最初由Sun Microsystems开发。它具有许多先进的功能，旨在提供高性能、数据完整性、可扩展性和先进的存储管理功能。ZFS最初是为Solaris操作系统设计的，但现在也可在其他操作系统上使用，包括各种Linux发行版和FreeBSD。</p><p>以下是ZFS的一些关键特点和功能：</p><ol><li><strong>数据完整性</strong>： ZFS以数据完整性为中心，可以检测和修复存储介质上的数据损坏。它使用称为校验和的技术来验证数据的完整性，并可以自动修复损坏的数据，以确保数据的一致性和可靠性。</li><li><strong>快照</strong>： ZFS支持快照，允许您在不影响当前数据的情况下捕获文件系统的快照。这对于备份、版本控制和数据还原非常有用。</li><li><strong>克隆</strong>： 您可以使用ZFS克隆功能创建文件系统的副本，这些副本与原始文件系统共享相同的数据块。这对于测试和开发环境非常有用。</li><li><strong>自动扩展</strong>： ZFS可以动态增加存储池的大小，而无需离线或重新分区。这使得存储管理更加灵活。</li><li><strong>数据压缩</strong>： ZFS支持数据压缩，可以减少存储空间的使用，并提高读取和写入性能。</li><li><strong>快速快照和克隆</strong>： ZFS的快照和克隆操作非常快速，因为它们不涉及实际数据复制。</li><li><strong>RAID-Z</strong>： 类似于RAID，ZFS提供了一种称为RAID-Z的数据保护机制，可以在硬件RAID的情况下提供更高的可靠性和性能。</li><li><strong>灵活的存储池</strong>： ZFS允许您创建存储池，将多个磁盘组合在一起，以提供容错性和性能。总之，ZFS是一个强大的文件系统和存储管理系统，具有出色的数据完整性、快照、克隆和自动扩展等功能。它在大规模数据存储、虚拟化环境和高性能计算等领域广泛使用。许多操作系统和存储设备都支持ZFS，因此它在各种平台上都有广泛的应用。</li></ol><h2 id="zfs使用"><a class="markdownIt-Anchor" href="#zfs使用"></a> zfs使用</h2><blockquote><p>注意：在使用ZFS时，请小心谨慎，特别是在生产环境中。不正确的操作可能导致数据丢失。请根据您的需求和环境，调整这些命令。</p></blockquote><ol><li>创建ZFS存储池：</li></ol><p>首先，让我们创建一个名为&quot;myzpool&quot;的ZFS存储池，并使用两个硬盘作为存储设备。</p><pre><code class="highlight shell">sudo zpool create myzpool /dev/sdb /dev/sdc</code></pre><ol start="2"><li>创建ZFS文件系统：</li></ol><p>在存储池上创建一个ZFS文件系统，命名为&quot;myfilesystem&quot;。</p><pre><code class="highlight sh"><span class="built_in">sudo</span> zfs create myzpool/myfilesystem</code></pre><ol start="3"><li>设置数据压缩：</li></ol><p>启用数据压缩以节省存储空间。</p><pre><code class="highlight sh"><span class="built_in">sudo</span> zfs <span class="built_in">set</span> compression=on myzpool/myfilesystem</code></pre><ol start="4"><li>创建快照：</li></ol><p>创建一个名为&quot;snapshot1&quot;的ZFS快照。</p><pre><code class="highlight sh"><span class="built_in">sudo</span> zfs snapshot myzpool/myfilesystem@snapshot1<span class="comment">#回滚到快照</span><span class="built_in">sudo</span> zfs rollback myzpool/myfilesystem@snapshot1</code></pre><ol start="5"><li>查看快照列表：</li></ol><p>查看所有快照的列表。</p><pre><code class="highlight plaintext">sudo zfs list -t snapshot</code></pre><ol start="6"><li>创建克隆：</li></ol><p>创建一个名为&quot;clone1&quot;的克隆，基于&quot;snapshot1&quot;。</p><pre><code class="highlight plaintext">sudo zfs clone myzpool/myfilesystem@snapshot1 myzpool/clone1</code></pre><ol start="7"><li>扩展存储池：</li></ol><p>添加一个新的硬盘来扩展存储池。</p><pre><code class="highlight plaintext">sudo zpool add myzpool /dev/sdd</code></pre><ol start="8"><li>显示存储池信息：</li></ol><p>查看存储池的信息，包括使用量、可用空间等。</p><pre><code class="highlight plaintext">sudo zpool status myzpool</code></pre><ol start="9"><li>卸载存储池：</li></ol><p>在不再需要存储池时，可以卸载它。</p><pre><code class="highlight plaintext">sudo zpool destroy myzpool</code></pre><h2 id="共享挂载"><a class="markdownIt-Anchor" href="#共享挂载"></a> 共享挂载</h2><p>要将ZFS文件系统目录挂载到另一台机器上，通常使用<strong>NFS</strong>（Network File System）来实现网络共享。您可以将ZFS文件系统目录导出为NFS共享，并在远程机器上挂载该共享。以下是一些简单的步骤来实现这一目标：</p><h3 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h3><ol><li>安装和配置NFS服务器：</li></ol><p>如果尚未安装NFS服务器，您需要在ZFS服务器上安装并配置它。具体安装方法取决于您使用的操作系统。例如，在Ubuntu上，您可以使用以下命令安装NFS服务器：</p><pre><code class="highlight plaintext">sudo apt-get install nfs-kernel-server</code></pre><ol start="2"><li>创建ZFS文件系统：</li></ol><p>如果还没有创建ZFS文件系统，可以使用以下命令创建它：</p><pre><code class="highlight plaintext">sudo zfs create myzpool/myfilesystem</code></pre><ol start="3"><li>配置NFS共享：</li></ol><p>编辑NFS服务器的配置文件以指定共享。<strong>打开/etc/exports</strong>文件并添加要共享的目录，例如：</p><ul><li><code>/myzpool/myfilesystem</code> 是您要共享的ZFS文件系统目录的路径。</li><li><code>*</code> 允许所有主机访问共享。</li><li><code>rw</code> 允许读写访问。</li><li><code>sync</code> 使用同步写入模式。</li><li><code>no_root_squash</code> 允许远程root用户访问。</li><li><code>no_subtree_check</code> 禁用子目录检查。</li><li><code>all_squash</code>：将所有远程客户端的用户映射为匿名用户。这意味着无论哪个客户端连接，都将以匿名用户的身份进行访问，而不会考虑其实际用户身份。</li><li><code>insecure</code>：允许不安全的访问，通常用于允许非特权端口的客户端连接。这可以在某些情况下提高兼容性，但可能会降低安全性。</li><li><code>anonuid=0</code>：将匿名用户的UID设置为0，即root用户。这意味着远程客户端以root用户的身份访问共享。</li><li><code>anongid=0</code>：将匿名用户的GID设置为0，即root用户的组。</li></ul><pre><code class="highlight plaintext">/myzpool/myfilesystem *(rw,sync,no_root_squash,no_subtree_check)</code></pre><ol start="4"><li>重新加载NFS配置： 在编辑完/etc/exports文件后，重新加载NFS服务器配置以使更改生效：</li></ol><pre><code class="highlight plaintext">sudo exportfs -ra</code></pre><ol start="5"><li>启动NFS服务： 启动NFS服务器服务：</li></ol><pre><code class="highlight plaintext">sudo systemctl start nfs-kernel-server # 对于基于systemd的系统</code></pre><h3 id="远端机器"><a class="markdownIt-Anchor" href="#远端机器"></a> 远端机器</h3><ol><li>安装NFS客户端：</li></ol><p>如果尚未安装NFS客户端，您需要在远程机器上安装它。具体安装方法取决于您使用的操作系统。例如，在Ubuntu上，您可以使用以下命令安装NFS客户端：bash</p><pre><code class="highlight plaintext">sudo apt-get install nfs-common</code></pre><ol start="2"><li>创建本地挂载点：</li></ol><p>在远程机器上创建一个本地挂载点，用于将ZFS共享挂载到远程机器上。例如：</p><pre><code class="highlight plaintext">sudo mkdir /mnt/zfs_share # 替换成您喜欢的本地挂载点路径</code></pre><ol start="3"><li>挂载ZFS共享：</li></ol><p>使用mount命令将ZFS共享挂载到本地挂载点。例如：</p><pre><code class="highlight plaintext">sudo mount -t nfs &lt;ZFS服务器IP或主机名&gt;:/myzpool/myfilesystem /mnt/zfs_share</code></pre><blockquote><p>请替换&lt;ZFS服务器IP或主机名&gt;、/myzpool/myfilesystem和/mnt/zfs_share为实际的值。</p></blockquote>]]>
    </content>
    <id>http://example.com/2023/09/03/ZFS/</id>
    <link href="http://example.com/2023/09/03/ZFS/"/>
    <published>2023-09-03T04:00:00.000Z</published>
    <summary>ZFS（Zettabyte File System）是一种高级的文件系统和卷管理器，最初由Sun Microsystems开发。它具有许多先进的功能，旨在提供高性能、数据完整性、可扩展性和先进的存储管理功能。ZFS最初是为Solaris操作系统设计的，但现在也可在其他操作系统上使用，包括各种Linux发行版和FreeBSD。</summary>
    <title>ZFS</title>
    <updated>2026-02-27T01:39:31.319Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Spring Cloud" scheme="http://example.com/tags/Spring-Cloud/"/>
    <content>
      <![CDATA[<h1 id="微服务框架-spring-cloud"><a class="markdownIt-Anchor" href="#微服务框架-spring-cloud"></a> 微服务框架 Spring Cloud</h1><p>[toc]</p><hr /><h2 id="spring-cloud入门"><a class="markdownIt-Anchor" href="#spring-cloud入门"></a> Spring Cloud入门</h2><h3 id="微服务与微服务架构"><a class="markdownIt-Anchor" href="#微服务与微服务架构"></a> 微服务与微服务架构</h3><p>做服务架构是一种新型的系统架构。其设计思路是。<strong>将单体架构系统拆分为多个可以相互调用、配合的独立运行的小程序</strong>。这每个小程序对整体系统所提供的功能就称为一个微服务。</p><p>由于每个微服务都是独立运行的，所以每个教服务都独自占用一个进程。<strong>微服务间采用轻量级的HTTP RESTful协议通信，每个微服务程序不受编程语言的限制，整个系统关心的是微服务程序所提供的具体服务，并不关心其具体的实现</strong>。每个微服务可以有自己独立的数据库。即可以操作自己的独立数据库，也可以操作整体系统的数据库。</p><h3 id="spring-cloud简介"><a class="markdownIt-Anchor" href="#spring-cloud简介"></a> Spring Cloud简介</h3><h4 id="百度百科"><a class="markdownIt-Anchor" href="#百度百科"></a> 百度百科</h4><p><strong>Spring Cloud是一系列框架的有序集合</strong>。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者提供了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><p>简单来说，Spring Cloud就是将现有的分布式开发技术整合到了Spring Boot中。形象地讲，Spring Boot就是火锅，而现有的分布式开发技术就是要吃的“涮菜、测肉&quot;，而学习SpringCloud就是在“吃火锅”</p><p>截止到目前，Spring Cloud已经集成了至少24种技术框架。在Spring Cloud官网首页可以一目了然这24种技术。<br /><a href="https://spring.io/projects/spring-cloud">Spring Cloud 官 网</a></p><h4 id="官网介绍"><a class="markdownIt-Anchor" href="#官网介绍"></a> 官网介绍</h4><p><a href="http://spring.io">打开spring官网：http://spring.io</a></p><p>翻译：构建分布式系统不需要复杂和容易出错，Spring Cloud为最常见的分布式系统模式提供了一种简单且易于接受的编程模型，帮助开发人员构建有弹性的、可靠的、协调的应用程序，Spring Cloud构建于Spring Boot之上，使得开发者很容易入手并快速应用于生产中。</p><p>该简介下方即为官方提供的Spring Cloud项目的体系结构图，从中可以看到，其为N多种技术的综合体</p><blockquote><p>IoT ：Internet of Things 物联网</p></blockquote><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p>Spring Cloud是什么？</p><p><strong>Spring Cloud是微服务系统架构的一站式解决方案</strong></p><p>Spring Cloud和Spring Boot是什么关系呢？</p><p><strong>Spring Boot为Spring Cloud提供了代码实现环境</strong>，使用Spring Boot将其他组件有机融合到了Spring Cloud的体系架构中了，所以说，springCloud是基于Spring Boot的，微服务系统架构的一站式解决方案</p><h4 id="spring-cloud-在线资源"><a class="markdownIt-Anchor" href="#spring-cloud-在线资源"></a> Spring Cloud 在线资源</h4><p><a href="https://spring.io/projects/spring-cloud">Spring Cloud 官网：https://spring.io/projects/spring-cloud</a></p><p><a href="https://springcloud.cc/">Spring Cloud中文网：https://springcloud.cc/</a></p><p><a href="http://springcloud.cn/">Spring Cloud中国社区：http:/springcloud.cn/</a></p><h3 id="spring-clouddubbo"><a class="markdownIt-Anchor" href="#spring-clouddubbo"></a> Spring Cloud/Dubbo</h3><p><strong>Spring Cloud与Dubbo均为微服务框架</strong>，开发团队在进行技术选型时，总会将它们进行对比，考虑应该选择哪一个。其实这两个概架没有可比性</p><p>与Spring Cloud相比，Dubbo 的架构完整度不够，其本身仅仅提供了服务注册中心与服务治理两个模块，而Sping Cloud到目前为止已经提供了服务注册中心服务治理等24个模块，并且现在还在增加中。，</p><p>Dubbo本身仅仅提供了服务注册中心与服务治理两个模块，并不是说其它功能其就不能够实现，Dubbo的设计是开放型的，其可通过整合第三方的相关功能框架。但也正因为如此，搭建出的Dubbo架构可能就存在兼容性问题。而Spring Cloud不存在这个问题，其出品的每一个模块都是经过严格测试的，几乎不存在兼容性问题。所以，若将Spring Cloud比作品牌电脑的话，Dubbo就是一台自己动手组装的电脑。</p><p>与Spring Cloud相比，Dubbo的社区活跃度太低。对于团队来说，社区活跃度高低将会影响整个项目的维护成本。当社区活跃度很高时，在一般性的工程中遇到的问题，在社区中基本都可找到相应的解决方案</p><p><strong>Dubbo服务间的通讯采用的是RPC</strong>,而<strong>Spring Cloud则采用的是HTTP的REST</strong>. RPC对于业务接口具有强依赖性，必须要保证通讯双方具有相同的业务接口。而这个保证就必须要通过严格的业务接口版本管理来实现。这种强依赖在大型的微服务项目中将会成为一个很大的问题。相比RPC, REST更为轻量化。服务提供者和调用者间的依赖仅仅是一纸契约，一段文本，不存在代码级别的强依赖。</p><p>对于国内开发团队来说，可能选择Dubbo的一个很重要原因就是官方文档。Dubbo 提供了高质量的中文版官方文档，而Spring Cloud的文档都是英文版的。Spring Cloud文档在体量上比Dubbo多很多，文档内容更多的是偏向模块整合，对于每个模块更深入的方法，两要用户查看其更为详细文档。对于中小型开发团队来说，对于英文文档的阅读成本，是必须要考虑的。</p><h3 id="服务提供者消费者项目"><a class="markdownIt-Anchor" href="#服务提供者消费者项目"></a> 服务提供者/消费者项目</h3><p>该项目为后续学习Spring Cloud的基础项目，也是前提准备</p><h4 id="服务提供者项目"><a class="markdownIt-Anchor" href="#服务提供者项目"></a> 服务提供者项目</h4><p><strong>项目创建</strong></p><p>创建一个基础的Spring Boot项目：</p><p>项目名：</p><p>导入项目基础jar包：</p><p>项目目录如下：</p><hr /><p><strong>pom依赖</strong></p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>provider<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!--修改MySQL驱动版本--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p><strong>主配置文件application.properties</strong></p><pre><code class="highlight properties"><span class="comment">#指定端口号</span><span class="attr">server.port</span>=<span class="string">8081</span><span class="comment">#更改访问上下文路径/访问路径 localhost:8088/leeBoot/...</span><span class="comment">#server.servlet.context-path=/leeBoot</span><span class="comment"></span><span class="comment">#开启启动时自动建表</span><span class="attr">spring.jpa.generate-ddl</span>=<span class="string">true</span><span class="comment">#是否在控制台显示sql语句</span><span class="attr">spring.jpa.show-sql</span>=<span class="string">true</span><span class="comment">#设置应用启动时不重新建表</span><span class="attr">spring.jpa.hibernate.ddl-auto</span>=<span class="string">none</span><span class="comment"></span><span class="comment">#配置数据源</span><span class="attr">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/leetest?characterEncoding=UTF-8</span><span class="attr">spring.datasource.username</span>=<span class="string">root</span><span class="attr">spring.datasource.password</span>=<span class="string">123456</span><span class="comment"></span><span class="comment"></span><span class="comment"></span><span class="comment">#配置日志输出格式</span><span class="attr">logging.pattern.console</span>=<span class="string">%level %msg%n</span><span class="comment">#设置spring boot启动时的日志级别</span><span class="attr">logging.level.root</span>=<span class="string">info</span><span class="comment">#hibernate运行日志级别   org.gibernate表示类名</span><span class="attr">logging.level.org.hibernate</span>=<span class="string">info</span><span class="comment">#在show-sql为true时显示sql中的动态参数值</span><span class="attr">logging.level.org.hibernate.type.descriptor.sql.BasicBinder</span>=<span class="string">trace</span><span class="comment">#在show-sql为true时显示查询结果</span><span class="attr">logging.level.org.hibernate.type.descriptor.sql.BasicExtractor</span>=<span class="string">trace</span><span class="comment">#控制自己代码运行时显示的日志级别</span><span class="attr">logging.level.com.lee</span>=<span class="string">debug</span></code></pre><hr /><p><strong>编写bean</strong></p><ul><li>因为我们使用Spring Data JPA，所以我们不需要建表，框架会帮我们建好数据库表</li><li>@<code>Entity</code>：数据库名与实体类名一一映射</li><li>@<code>JsonIgnoreProperties</code>：<ul><li>忽略掉hebernate的延迟加载，防止要json序列化值时其值为空</li><li>用来在json序列化时将java bean中的一些属性忽略掉</li></ul></li><li>@<code>Id</code>：用在成员变量，表示该字段时主键</li><li>@<code>GeneratedValue</code>：用在成员变量，可设置字段自增</li><li>@<code>Column</code>：用在成员变量，表明对应的数据库字段名</li></ul><blockquote><p>controller处理器方法的返回值是作为json数据响应给浏览器的，这个数据转换工作是由SpringMVC的HttpMessageConverter接口完成的，确切的说，是由该接口的一个实现类Jackson完成的</p></blockquote><blockquote><p>但默认情况下，Hibernate对所有对象的查询采用了延迟加载策略，由Hibernate延迟初始化器hibernateLazyInitializer完成，其首先会将javasist，动态代理对象先传递给了Jackson，在访问详情时在做查询，但Jackson在拿到代理对象后马上就要将其转换为json而不等待，所以我们要使用@JsonIgnoreProperties注解忽略掉hebernate的延迟加载</p></blockquote><pre><code class="highlight java"><span class="keyword">package</span> com.lee.provider.bean;<span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonIgnoreProperties;<span class="keyword">import</span> lombok.Data;<span class="keyword">import</span> javax.persistence.*;<span class="comment">/**</span><span class="comment"> * 这里先不使用mybatis,使用Spring Data JPA</span><span class="comment"> * jpa可以自动根据该类在数据库中生成表</span><span class="comment"> */</span><span class="meta">@Data</span>   <span class="comment">//lombok用来生成getter和setter方法的</span><span class="comment">//用来将该实体类与数据库表进行一对一映射,不写name表示和数据库表depart一对一映射</span><span class="meta">@Entity(name = &quot;t_depart&quot;)</span><span class="comment">//忽略掉hebernate的延迟加载</span><span class="comment">//还可以用来在json序列化时将java bean中的一些属性忽略掉</span><span class="meta">@JsonIgnoreProperties(&#123;&quot;hibernateLazyInitializer&quot;,&quot;handler&quot;,&quot;fieldHandler&quot;&#125;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Depart</span> &#123;    <span class="comment">//表示主键</span>    <span class="meta">@Id</span>    <span class="comment">//设置字段自增</span>    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>    <span class="keyword">private</span> Integer id;    <span class="comment">//表明对应的数据库字段名</span>    <span class="meta">@Column(name = &quot;name&quot;)</span>    <span class="keyword">private</span> String name;    <span class="meta">@Column(name = &quot;dbase&quot;)</span>    <span class="keyword">private</span> String dbase;&#125;</code></pre><hr /><p><strong>编写dao层</strong></p><p>对于spring Data来说，dao层默认名字为Repository</p><ul><li>JpaRepository继承自PagingAndSortingRepository接口，JpaRepository基于JPA的Repository接口，极大减少了JPA作为数据访问的代码，JpaRepository是实现Spring Data JPA技术访问数据库的关键接口</li><li>当我们需要定义自己的Repository的时候，我们可以继承JpaRepository，从而获得Spring为我们预先定义的多种基本数据操作方法</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.provider.repository;<span class="keyword">import</span> com.lee.provider.bean.Depart;<span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;<span class="comment">/**</span><span class="comment"> * 这个类相当于mybatis时的dao</span><span class="comment"> *</span><span class="comment"> * 第一个泛型:当前Repository的操作对象类型</span><span class="comment"> * 第二个泛型:当前Repository的操作对象的id类型</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DepartRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Depart, Integer&gt; &#123;&#125;</code></pre><hr /><p><strong>编写service层</strong></p><p>service层接口</p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.provider.service;<span class="keyword">import</span> com.lee.provider.bean.Depart;<span class="keyword">import</span> java.util.List;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DepartService</span> &#123;    <span class="type">boolean</span> <span class="title function_">saveDepart</span><span class="params">(Depart depart)</span>;    <span class="type">boolean</span> <span class="title function_">removeDepartById</span><span class="params">(<span class="type">int</span> id)</span>;    <span class="type">boolean</span> <span class="title function_">modifyDepart</span><span class="params">(Depart depart)</span>;    Depart <span class="title function_">getDepartById</span><span class="params">(<span class="type">int</span> id)</span>;    List&lt;Depart&gt; <span class="title function_">listAllDeparts</span><span class="params">()</span>;&#125;</code></pre><p>service层实现：</p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.provider.service;<span class="keyword">import</span> com.lee.provider.bean.Depart;<span class="keyword">import</span> com.lee.provider.repository.DepartRepository;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.stereotype.Service;<span class="keyword">import</span> java.util.List;<span class="meta">@Service</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">DepartService</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> DepartRepository repository;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveDepart</span><span class="params">(Depart depart)</span> &#123;        <span class="comment">//如果这个depart的id在数据库中存在，就执行update</span>        <span class="comment">//如果这个depart的id字数据库中不存在，就执行insert</span>        <span class="comment">//返回值就是你插入的对象</span>        <span class="type">Depart</span> <span class="variable">result</span> <span class="operator">=</span> repository.save(depart);        <span class="keyword">if</span> (result!=<span class="literal">null</span>) &#123;            <span class="keyword">return</span> <span class="literal">true</span>;        &#125;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeDepartById</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="comment">//判断数据库是否有id</span>        <span class="keyword">if</span> (repository.existsById(id)) &#123;            <span class="comment">//如果数据库有id，就会给删除掉，如果没有该id,执行就会抛异常</span>            repository.deleteById(id);            <span class="keyword">return</span> <span class="literal">true</span>;        &#125;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">modifyDepart</span><span class="params">(Depart depart)</span> &#123;        <span class="comment">//如果这个depart的id在数据库中存在，就执行update</span>        <span class="comment">//如果这个depart的id字数据库中不存在，就执行insert</span>        <span class="comment">//返回值就是你插入的对象</span>        <span class="type">Depart</span> <span class="variable">result</span> <span class="operator">=</span> repository.save(depart);        <span class="keyword">if</span> (result!=<span class="literal">null</span>) &#123;            <span class="keyword">return</span> <span class="literal">true</span>;        &#125;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> Depart <span class="title function_">getDepartById</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="comment">//判断数据库是否有id</span>        <span class="keyword">if</span> (repository.existsById(id)) &#123;            <span class="comment">//如果id不存在，会抛出异常</span>            <span class="keyword">return</span> repository.getOne(id);        &#125;        <span class="comment">//尽量避免给返回null</span>        <span class="type">Depart</span> <span class="variable">depart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Depart</span>();        depart.setName(<span class="string">&quot;no this depart&quot;</span>);        <span class="keyword">return</span> depart;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> List&lt;Depart&gt; <span class="title function_">listAllDeparts</span><span class="params">()</span> &#123;        <span class="keyword">return</span> repository.findAll();    &#125;&#125;</code></pre><hr /><p><strong>编写Controller</strong></p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.provider.Controller;<span class="keyword">import</span> com.lee.provider.bean.Depart;<span class="keyword">import</span> com.lee.provider.service.DepartService;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.web.bind.annotation.*;<span class="keyword">import</span> java.util.List;<span class="meta">@RequestMapping(&quot;/provider/depart&quot;)</span><span class="meta">@RestController</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartController</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> DepartService service;    <span class="meta">@PostMapping(&quot;/save&quot;)</span>    <span class="comment">//@RequestBody表示传过来的数据时json数据</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveHandle</span><span class="params">(<span class="meta">@RequestBody</span> Depart depart)</span> &#123;        <span class="keyword">return</span> service.saveDepart(depart);    &#125;    <span class="meta">@DeleteMapping(&quot;/del/&#123;id&#125;&quot;)</span>    <span class="comment">//@PathVariable 表示获取url中的&#123;id&#125;的值</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteHandle</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;        <span class="keyword">return</span> service.removeDepartById(id);    &#125;    <span class="meta">@PutMapping(&quot;/update&quot;)</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateHandle</span><span class="params">(<span class="meta">@RequestBody</span> Depart depart)</span>&#123;        <span class="keyword">return</span> service.modifyDepart(depart);    &#125;    <span class="meta">@GetMapping(&quot;/get/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> Depart <span class="title function_">GetHandle</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span>&#123;        <span class="keyword">return</span> service.getDepartById(id);    &#125;    <span class="meta">@GetMapping(&quot;/list&quot;)</span>    <span class="keyword">public</span> List&lt;Depart&gt; <span class="title function_">listHandle</span><span class="params">()</span> &#123;        <span class="keyword">return</span> service.listAllDeparts();    &#125;&#125;</code></pre><h4 id="消费者项目"><a class="markdownIt-Anchor" href="#消费者项目"></a> 消费者项目</h4><p><strong>项目创建</strong></p><p>创建一个基础的Spring Boot项目：</p><p>项目名：</p><p>添加相关jar包：</p><p>项目目录如下：</p><hr /><p><strong>pom依赖</strong></p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p><strong>spring boot主配置文件</strong></p><pre><code class="highlight properties"><span class="comment">#指定端口号</span><span class="attr">server.port</span>=<span class="string">8080</span></code></pre><hr /><p><strong>编写bean</strong></p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer.bean;<span class="keyword">import</span> lombok.Data;<span class="meta">@Data</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Depart</span> &#123;    <span class="keyword">private</span> Integer id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> String dbase;&#125;</code></pre><hr /><p><strong>编写Configuration文件</strong></p><ul><li>传统情况下在java代码里访问restful服务，一般使用Apache的HttpClient。不过此种方法使用起来太过繁琐。spring提供了一种简单便捷的模板类来进行操作，这就是<strong>RestTemplate</strong></li><li>调用远程服务时就必须使用HTTP客户端,主要有四种：JDK原生的URLConnection、Apache的Http Client、Netty的异步HTTP Client, Spring的RestTemplate。</li><li>restTemplate是spring提供的可以提供访问rest服务的客户端工具类，提供多种快捷的访问远程的方法，大大提高了客户端的编程效率。解放了原先HttpClient的复杂提交，java中调用RESTful服务很典型的是使用HttpClient，对于常用的REST操作，这些方法属于低等级的操作。使用HttpClient我们需要自己封装Post请求，再根据响应的状态码判断从响应中获取header和body，有时候还需要自己做json转换</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer.codeconfig;<span class="keyword">import</span> org.springframework.context.annotation.Bean;<span class="keyword">import</span> org.springframework.context.annotation.Configuration;<span class="keyword">import</span> org.springframework.web.client.RestTemplate;<span class="meta">@Configuration</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartCodeConfig</span> &#123;    <span class="meta">@Bean</span>    <span class="comment">//bean的名称就相当于方法名</span>    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();    &#125;&#125;</code></pre><hr /><p><strong>编写Controller</strong></p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer.Controller;<span class="keyword">import</span> com.lee.consumer.bean.Depart;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.web.bind.annotation.*;<span class="keyword">import</span> org.springframework.web.client.RestTemplate;<span class="keyword">import</span> java.util.List;<span class="meta">@RestController</span><span class="meta">@RequestMapping(&quot;/consumer/depart&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartController</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> RestTemplate restTemplate;    <span class="meta">@PostMapping(&quot;/save&quot;)</span>    <span class="comment">//@RequestBody表示传过来的数据时json数据</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveHandle</span><span class="params">(Depart depart)</span> &#123;        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081/provider/depart/save&quot;</span>;        <span class="comment">//url/传入参数/调用方法返回值</span>        <span class="keyword">return</span> restTemplate.postForObject(url, depart, Boolean.class);    &#125;    <span class="meta">@DeleteMapping(&quot;/del/&#123;id&#125;&quot;)</span>    <span class="comment">//@PathVariable 表示获取url中的&#123;id&#125;的值</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteHandle</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081/provider/depart/del/&quot;</span>+id;        restTemplate.delete(url);    &#125;    <span class="meta">@PutMapping(&quot;/update&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateHandle</span><span class="params">(Depart depart)</span> &#123;        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081/provider/depart/update&quot;</span>;        restTemplate.put(url,depart);    &#125;    <span class="meta">@GetMapping(&quot;/get/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> Depart <span class="title function_">GetHandle</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span> &#123;        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081/provider/depart/get/&quot;</span>+id;        <span class="keyword">return</span> restTemplate.getForObject(url,Depart.class);    &#125;    <span class="meta">@GetMapping(&quot;/list&quot;)</span>    <span class="keyword">public</span> List&lt;Depart&gt; <span class="title function_">listHandle</span><span class="params">()</span> &#123;        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081/provider/depart/list&quot;</span>;        <span class="keyword">return</span> restTemplate.getForObject(url, List.class);    &#125;&#125;</code></pre><h2 id="相关注解详解"><a class="markdownIt-Anchor" href="#相关注解详解"></a> 相关注解详解</h2><h3 id="json序列化相关注解"><a class="markdownIt-Anchor" href="#json序列化相关注解"></a> JSON序列化相关注解</h3><p><strong>问题由来：</strong><br />springboot项目中定义了很多类，我们在rest返回中直接返回或者在返回对象中使用这些类，spring已经使用jackson自动帮我们完成这些的to json。但是有时候自动转的json内容太多，或者格式不符合我们的期望，因此需要调整类的to json过程，或者说希望自定义类的json过程。</p><p><strong>问题解决</strong></p><p>使用@JsonIgnoreProperties、@JsonIgnore、@JsonForma。</p><ul><li><p>@<strong>JsonIgnore</strong>注解用来忽略某些字段，可以用在变量或者Getter方法上，用在Setter方法时，和变量效果一样。这个注解一般用在我们要忽略的字段上。</p></li><li><p>@<strong>JsonIgnoreProperties</strong>(ignoreUnknown = true)，将这个注解写在类上之后，就会忽略类中不存在的字段。这个注解还可以指定要忽略的字段，例如@JsonIgnoreProperties({ “password”, “secretKey” })</p></li><li><p>@<strong>JsonFormat</strong>可以帮我们完成格式转换。例如对于Date类型字段，如果不适用JsonFormat默认在rest返回的是long，如果我们使用@JsonFormat(timezone = “GMT+8”, pattern = “yyyy-MM-dd HH:mm:ss”)，就返回&quot;2018-11-16 22:58:15&quot;</p></li></ul><p><a href="https://fasterxml.github.io/jackson-annotations/javadoc/2.6/com/fasterxml/jackson/annotation/JsonIgnoreProperties.html">具体可以参考官方文档</a></p><blockquote><p>@JsonIgnoreProperties与@JsonIgnore的主要区别在于， @JsonIgnoreProperties是类级别的， 而@JsonIgnore是变量和方法级别的。</p></blockquote><p><strong>代码示例</strong><br />代码简要说明， User类的fullName 和comment字段会被@JsonIgnoreProperties注解忽略。address字段会被@JsonIgnore注解忽略。regDate会按照@JsonFormat(timezone = “GMT+8”, pattern = “yyyy-MM-dd HH:mm:ss”)进行格式转</p><pre><code class="highlight java"><span class="meta">@Data</span><span class="meta">@JsonIgnoreProperties(value = &#123;&quot;fullName&quot;, &quot;comment&quot;&#125;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;    <span class="keyword">private</span> String id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> String fullName;    <span class="keyword">private</span> String comment;    <span class="keyword">private</span> String mail;    <span class="meta">@JsonIgnore</span>    <span class="keyword">private</span> String address;    <span class="meta">@JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span>    <span class="keyword">private</span> Date regDate;    <span class="keyword">private</span> Date reg2Date;&#125;</code></pre><p>Controller代码</p><pre><code class="highlight java"><span class="meta">@ApiOperation(value = &quot;按用户id删除&quot;, notes=&quot;private&quot;)</span><span class="meta">@ApiImplicitParams(&#123;</span><span class="meta">        @ApiImplicitParam(name = &quot;userId&quot;, defaultValue = &quot;2&quot;, value = &quot;userID&quot;, required = true, dataType = &quot;string&quot;, paramType = &quot;path&quot;),</span><span class="meta">&#125;)</span><span class="meta">@DeleteMapping(value = &quot;/users/&#123;userId&#125;&quot;, produces = &quot;application/json;charset=UTF-8&quot;)</span><span class="keyword">public</span> User <span class="title function_">delUser</span><span class="params">(<span class="meta">@PathVariable</span> String userId)</span> &#123;    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)userSvc.deleteById(userId);    log.info(<span class="string">&quot;rest del user=&#123;&#125; by id=&#123;&#125;&quot;</span>, user, userId);    <span class="keyword">return</span> user;&#125;</code></pre><p>可以看到返回的对象是User，然后comment、fullName、address属性被忽略了，regDate的格式进行转换</p><h3 id="generatedvalue"><a class="markdownIt-Anchor" href="#generatedvalue"></a> @GeneratedValue</h3><p>@GeneratedValue注解存在的意义主要就是<strong>为一个实体生成一个唯一标识的主键</strong>、@GeneratedValue提供了主键的生成策略</p><p>@GeneratedValue注解有两个属性,分别是strategy和generator,</p><ul><li>generator属性：<ul><li>generator属性的值是一个字符串,默认为&quot;&quot;,其声明了主键生成器的名称(对应于同名的主键生成器@SequenceGenerator和@TableGenerator)</li></ul></li></ul><hr /><ul><li><strong>strategy属性</strong>：提供四种值:<ul><li>AUTO：主键由程序控制, 是默认选项 ,不设置就是这个</li><li>IDENTITY ：主键由数据库生成, 采用数据库自增长, Oracle不支持这种方式</li><li>SEQUENCE： 通过数据库的序列产生主键, MYSQL  不支持</li><li>Table ：提供特定的数据库产生主键, 该方式更有利于数据库的移植</li></ul></li></ul><blockquote><p>默认SpringBoot的@GeneratedValue 是不需要加参数的,但是如果数据库控制主键自增(auto_increment), 不加参数就会报错</p></blockquote><h3 id="spring-data-jpa之jparepository"><a class="markdownIt-Anchor" href="#spring-data-jpa之jparepository"></a> Spring Data JPA之JpaRepository</h3><p><strong>使用Spring Data JPA CrudRepository 和JpaRepository 的好处</strong>：</p><ul><li>继承这些接口，可以使Spring找到自定义的数据库操作接口，并生成代理类，后续可以注入到Spring容器中；</li><li>可以不写相关的sql操作，由代理类生成</li></ul><p><strong>JpaRepository接口的官方定义如下</strong>：</p><pre><code class="highlight plaintext">public interface JpaRepository&lt;T, ID&gt; extends PagingAndSortingRepository&lt;T, ID&gt;, QueryByExampleExecutor&lt;T&gt;</code></pre><p>可以看出JpaRepository继承了接口PagingAndSortingRepository和QueryByExampleExecutor。而，PagingAndSortingRepository又继承CrudRepository。</p><p>也就是说， CrudRepository 提供基本的增删改查；PagingAndSortingRepository 提供分页和排序方法；JpaRepository 提供JPA需要的方法</p><p><strong>当我们需要定义自己的Repository的时候，我们可以继承JpaRepository</strong>，从而获得Spring为我们预先定义的多种基本数据操作方法。</p><pre><code class="highlight plaintext">public interface UserRepository extends JpaRepository&lt;User, Integer&gt; &#123;&#125;</code></pre><p><strong>各函数说明</strong></p><pre><code class="highlight java"> <span class="comment">/**</span><span class="comment">    * 保存一个实体。</span><span class="comment">    */</span>   &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; S <span class="title function_">save</span><span class="params">(S entity)</span>;   <span class="comment">/**</span><span class="comment">    * 保存提供的所有实体。</span><span class="comment">    */</span>   &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; Iterable&lt;S&gt; <span class="title function_">saveAll</span><span class="params">(Iterable&lt;S&gt; entities)</span>;   <span class="comment">/**</span><span class="comment">    * 根据id查询对应的实体。</span><span class="comment">    */</span>   Optional&lt;T&gt; <span class="title function_">findById</span><span class="params">(ID id)</span>;   <span class="comment">/**</span><span class="comment">    * 根据id查询对应的实体是否存在。</span><span class="comment">    */</span>   <span class="type">boolean</span> <span class="title function_">existsById</span><span class="params">(ID id)</span>;   <span class="comment">/**</span><span class="comment">    * 查询所有的实体。</span><span class="comment">    */</span>   Iterable&lt;T&gt; <span class="title function_">findAll</span><span class="params">()</span>;   <span class="comment">/**</span><span class="comment">    * 根据给定的id集合查询所有对应的实体，返回实体集合。</span><span class="comment">    */</span>   Iterable&lt;T&gt; <span class="title function_">findAllById</span><span class="params">(Iterable&lt;ID&gt; ids)</span>;   <span class="comment">/**</span><span class="comment">    * 统计现存实体的个数。</span><span class="comment">    */</span>   <span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;   <span class="comment">/**</span><span class="comment">    * 根据id删除对应的实体。</span><span class="comment">    */</span>   <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(ID id)</span>;   <span class="comment">/**</span><span class="comment">    * 删除给定的实体。</span><span class="comment">    */</span>   <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(T entity)</span>;   <span class="comment">/**</span><span class="comment">    * 删除给定的实体集合。</span><span class="comment">    */</span>   <span class="keyword">void</span> <span class="title function_">deleteAll</span><span class="params">(Iterable&lt;? extends T&gt; entities)</span>;   <span class="comment">/**</span><span class="comment">    * 删除所有的实体。</span><span class="comment">    */</span>   <span class="keyword">void</span> <span class="title function_">deleteAll</span><span class="params">()</span>;  <span class="comment">/**</span><span class="comment">    * 返回所有的实体，根据Sort参数提供的规则排序。</span><span class="comment">    */</span>   Iterable&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Sort sort)</span>;   <span class="comment">/**</span><span class="comment">    * 返回一页实体，根据Pageable参数提供的规则进行过滤。</span><span class="comment">    */</span>   Page&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Pageable pageable)</span>;<span class="comment">/**</span><span class="comment">    * 将所有未决的更改刷新到数据库。</span><span class="comment">    */</span>   <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>;   <span class="comment">/**</span><span class="comment">    * 保存一个实体并立即将更改刷新到数据库。</span><span class="comment">    */</span>   &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; S <span class="title function_">saveAndFlush</span><span class="params">(S entity)</span>;   <span class="comment">/**</span><span class="comment">    * 在一个批次中删除给定的实体集合，这意味着将产生一条单独的Query。</span><span class="comment">    */</span>   <span class="keyword">void</span> <span class="title function_">deleteInBatch</span><span class="params">(Iterable&lt;T&gt; entities)</span>;   <span class="comment">/**</span><span class="comment">    * 在一个批次中删除所有的实体。</span><span class="comment">    */</span>   <span class="keyword">void</span> <span class="title function_">deleteAllInBatch</span><span class="params">()</span>;   <span class="comment">/**</span><span class="comment">    * 根据给定的id标识符，返回对应实体的引用。</span><span class="comment">    */</span>   T <span class="title function_">getOne</span><span class="params">(ID id)</span>;</code></pre><h3 id="hystrixcommand"><a class="markdownIt-Anchor" href="#hystrixcommand"></a> @HystrixCommand</h3><pre><code class="highlight java"><span class="keyword">package</span> com.example.demo.service;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.stereotype.Service;<span class="keyword">import</span> org.springframework.web.client.RestTemplate;<span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;<span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;<span class="meta">@Service</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerService</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> RestTemplate restTemplate;    <span class="meta">@HystrixCommand(commandKey = &quot;testCommand&quot;, groupKey = &quot;testGroup&quot;, threadPoolKey = &quot;testThreadKey&quot;,</span><span class="meta">            fallbackMethod = &quot;hiConsumerFallBack&quot;, ignoreExceptions = &#123;NullPointerException.class&#125;,</span><span class="meta">            threadPoolProperties = &#123;</span><span class="meta">                    @HystrixProperty(name = &quot;coreSize&quot;, value = &quot;30&quot;),</span><span class="meta">                    @HystrixProperty(name = &quot;maxQueueSize&quot;, value = &quot;101&quot;),</span><span class="meta">                    @HystrixProperty(name = &quot;keepAliveTimeMinutes&quot;, value = &quot;2&quot;),</span><span class="meta">                    @HystrixProperty(name = &quot;queueSizeRejectionThreshold&quot;, value = &quot;15&quot;),</span><span class="meta">                    @HystrixProperty(name = &quot;metrics.rollingStats.numBuckets&quot;, value = &quot;12&quot;),</span><span class="meta">                    @HystrixProperty(name = &quot;metrics.rollingStats.timeInMilliseconds&quot;, value = &quot;1440&quot;)</span><span class="meta">            &#125;</span><span class="meta">            )</span>    <span class="keyword">public</span> String <span class="title function_">hiConsumer</span><span class="params">(String id)</span> &#123;                <span class="comment">//SERVICE_HI是服务端的spring.application.name，并且大写，hi为服务端提供的接口</span>        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">&quot;http://SERVICE_HI/hi&quot;</span>, String.class).getBody();    &#125;        <span class="keyword">public</span> String <span class="title function_">hiConsumerFallBack</span><span class="params">(String id, Throwable e)</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;This is a error&quot;</span>;    &#125;&#125;</code></pre><p>让我们来逐个介绍下@HystrixCommand注解的各个参数：</p><p>1：<strong>commandKey</strong>：配置全局唯一标识服务的名称，比如，库存系统有一个获取库存服务，那么就可以为这个服务起一个名字来唯一识别该服务，如果不配置，则默认是@HystrixCommand注解修饰的函数的函数名。</p><p>2：<strong>groupKey</strong>：一个比较重要的注解，配置全局唯一标识服务分组的名称，比如，库存系统就是一个服务分组。通过设置分组，Hystrix会根据组来组织和统计命令的告、仪表盘等信息。Hystrix命令默认的线程划分也是根据命令组来实现。默认情况下，Hystrix会让相同组名的命令使用同一个线程池，所以我们需要在创建Hystrix命令时为其指定命令组来实现默认的线程池划分。此外，Hystrix还提供了通过设置threadPoolKey来对线程池进行设置。建议最好设置该参数，使用threadPoolKey来控制线程池组。</p><p>3：<strong>threadPoolKey</strong>：对线程池进行设定，细粒度的配置，相当于对单个服务的线程池信息进行设置，也可多个服务设置同一个threadPoolKey构成线程组。</p><p>4：<strong>fallbackMethod</strong>：@HystrixCommand注解修饰的函数的回调函数，@HystrixCommand修饰的函数必须和这个回调函数定义在同一个类中，因为定义在了同一个类中，所以fackback method可以是public/private均可。</p><p>5：<strong>commandProperties</strong>：配置该命令的一些参数，如executionIsolationStrategy配置执行隔离策略，默认是使用线程隔离，此处我们配置为THREAD，即线程池隔离。参见：com.netflix.hystrix.HystrixCommandProperties中各个参数的定义。</p><p>6：<strong>threadPoolProperties</strong>：线程池相关参数设置，具体可以设置哪些参数请见：com.netflix.hystrix.HystrixThreadPoolProperties</p><p>7：<strong>ignoreExceptions</strong>：调用服务时，除了HystrixBadRequestException之外，其他@HystrixCommand修饰的函数抛出的异常均会被Hystrix认为命令执行失败而触发服务降级的处理逻辑（调用fallbackMethod指定的回调函数），所以当需要在命令执行中抛出不触发降级的异常时来使用它，通过这个参数指定，哪些异常抛出时不触发降级（不去调用fallbackMethod），而是将异常向上抛出。</p><p>8：<strong>observableExecutionMode</strong>：定义hystrix observable command的模式；</p><p>9：<strong>raiseHystrixExceptions</strong>：任何不可忽略的异常都包含在HystrixRuntimeException中；</p><p>10：<strong>defaultFallback</strong>：默认的回调函数，该函数的函数体不能有入参，返回值类型与@HystrixCommand修饰的函数体的返回值一致。如果指定了fallbackMethod，则fallbackMethod优先级更高</p><h3 id="cacheresult注解"><a class="markdownIt-Anchor" href="#cacheresult注解"></a> @CacheResult注解</h3><table><thead><tr><th>注解</th><th>描述</th><th>属性</th></tr></thead><tbody><tr><td>@CacheResult</td><td>该注解用来标记请求命令返回的结果应该被缓存，它必须与@HystrixCommand注解结合使用</td><td>cacheKeyMethod</td></tr><tr><td>@CacheRemove</td><td>该注解用来让请求命令的缓存失效，失效的缓存根据定义Key决定</td><td>commandKey,cacheKeyMethod</td></tr><tr><td>@CacheKey</td><td>该注解用来在请求命令的参数上标记，使其作为缓存的Key值，如果没有标注则会使用所有参数。如果同事还是使用了@CacheResult和@CacheRemove注解的cacheKeyMethod方法指定缓存Key的生成，那么该注解将不会起作用</td><td>value</td></tr></tbody></table><p>该注解标记结果需要被缓存，并且<strong>这个注解需要结合@HystrixCommand注解一起使用</strong>。该注解有一个参数cacheKeyMethod，用来指定获取cacheKey的方法名。Hystrix会根据获取到的cacheKey值来区分是否是重复请求，如果他们的cacheKey相同，那么该依赖服务只会在第一个请求到达时被真实的调用一次，另外一个请求则是直接从请求缓存中根据这个cacheKey来获取到的结果。所以开启请求缓存可以让我们实现的Hystrix命令具备下面几项好处：</p><ul><li>减少重复的请求数，降低依赖服务的并发度；</li><li>在同一个用户请求的上下文，想同依赖服务的返回数据始终保持一致。</li><li>请求缓存在run()和contruct()执行之前生效，所以可以有效减少不必要的线程开销；</li></ul><p>使用@CacheResult开启缓存代码示例：</p><pre><code class="highlight java"><span class="keyword">package</span> com.example.demo; <span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.stereotype.Service;<span class="keyword">import</span> org.springframework.web.client.RestTemplate; <span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.cache.annotation.CacheResult;<span class="keyword">import</span> com.example.demo.entity.User;<span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand; <span class="meta">@Service</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheResultDemo</span> &#123;     <span class="meta">@Autowired</span>    <span class="keyword">private</span> RestTemplate restTemplate;     <span class="meta">@CacheResult(cacheKeyMethod = &quot;getUserId&quot;)</span>    <span class="meta">@HystrixCommand(fallbackMethod = &quot;hiConsumerFallBack&quot;)</span>    <span class="keyword">public</span> User <span class="title function_">hiConsumer</span><span class="params">(String id)</span> &#123;                <span class="comment">//SERVICE_HI是服务端的spring.application.name，并且大写，hi为服务端提供的接口</span>        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">&quot;http://SERVICE_HI/hi&quot;</span>, User.class).getBody();    &#125;        <span class="keyword">public</span> String <span class="title function_">hiConsumerFallBack</span><span class="params">(String id, Throwable e)</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;This is a error&quot;</span>;    &#125;        <span class="keyword">public</span> String <span class="title function_">getUserId</span><span class="params">(String id)</span> &#123;        <span class="keyword">return</span> id;    &#125; &#125;</code></pre><p>使用CacheKey开启缓存代码示例：</p><pre><code class="highlight java"><span class="keyword">package</span> com.example.demo;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.stereotype.Service;<span class="keyword">import</span> org.springframework.web.client.RestTemplate;importcom.netflix.hystrix.contrib.javanica.cache.annotation.CacheKey;<span class="keyword">import</span> com.example.demo.entity.User;importcom.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;<span class="meta">@Service</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheKeyDemo</span> &#123;      <span class="meta">@Autowired</span>      <span class="keyword">private</span> RestTemplate restTemplate;      <span class="meta">@HystrixCommand(fallbackMethod = &quot;hiConsumerFallBack&quot;)</span>      <span class="keyword">public</span> User <span class="title function_">hiConsumer</span><span class="params">(<span class="meta">@CacheKey(&quot;id&quot;)</span> String id)</span> &#123;                        <span class="comment">//SERVICE_HI是服务端的spring.application.name，并且大写，hi为服务端提供的接口</span>            <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">&quot;http://SERVICE_HI/hi&quot;</span>, User.class).getBody();      &#125;            <span class="keyword">public</span> String <span class="title function_">hiConsumerFallBack</span><span class="params">(String id, Throwable e)</span> &#123;            <span class="keyword">return</span> <span class="string">&quot;This is a error&quot;</span>;      &#125;&#125;</code></pre><p>其中@CacheKey除了可以指定方法参数为缓存key之外，还可以指定对象中的属性作为缓存Key，如下：</p><pre><code class="highlight java"><span class="keyword">package</span> com.example.demo; <span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.stereotype.Service;<span class="keyword">import</span> org.springframework.web.client.RestTemplate; <span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.cache.annotation.CacheKey;<span class="keyword">import</span> com.example.demo.entity.User;<span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand; <span class="meta">@Service</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheKeyDemo2</span> &#123;     <span class="meta">@Autowired</span>    <span class="keyword">private</span> RestTemplate restTemplate;     <span class="meta">@HystrixCommand(fallbackMethod = &quot;hiConsumerFallBack&quot;)</span>    <span class="keyword">public</span> User <span class="title function_">hiConsumer</span><span class="params">(<span class="meta">@CacheKey(&quot;id&quot;)</span> User user)</span> &#123;                <span class="comment">//SERVICE_HI是服务端的spring.application.name，并且大写，hi为服务端提供的接口</span>        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">&quot;http://SERVICE_HI/hi&quot;</span>, User.class, user.getId()).getBody();    &#125;        <span class="keyword">public</span> String <span class="title function_">hiConsumerFallBack</span><span class="params">(String id, Throwable e)</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;This is a error&quot;</span>;    &#125; &#125;</code></pre><p>清理失效缓存功能：</p><p>使用请求缓存时，如果只是读操作，那么不需要考虑缓存中的内容是否正确的问题，但是如果请求命令中还有更新数据的写操作，那么缓存中的数据就需要我们在进行写操作时进行及时处理，以防止读操作的请求命令获取到了失效的数据。</p><p>通过@CacheRemove注解来实现失效缓存清理功能：</p><pre><code class="highlight java"><span class="keyword">package</span> com.example.demo;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.stereotype.Service;<span class="keyword">import</span> org.springframework.web.client.RestTemplate;importcom.netflix.hystrix.contrib.javanica.cache.annotation.CacheKey;importcom.netflix.hystrix.contrib.javanica.cache.annotation.CacheRemove;<span class="keyword">import</span> com.example.demo.entity.User;importcom.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;<span class="meta">@Service</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheRemoveDemo</span> &#123;      <span class="meta">@Autowired</span>      <span class="keyword">private</span> RestTemplate restTemplate;      <span class="meta">@CacheRemove(commandKey = &quot;getUserId&quot;)</span>      <span class="meta">@HystrixCommand(fallbackMethod = &quot;hiConsumerFallBack&quot;)</span>      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="meta">@CacheKey(&quot;id&quot;)</span> User user)</span> &#123;                        <span class="comment">//SERVICE_HI是服务端的spring.application.name，并且大写，hi为服务端提供的接口</span>            restTemplate.postForObject(<span class="string">&quot;http://SERVICE_HI/hi&quot;</span>, user, User.class);            <span class="keyword">return</span>;      &#125;            <span class="keyword">public</span> String <span class="title function_">hiConsumerFallBack</span><span class="params">(String id, Throwable e)</span> &#123;            <span class="keyword">return</span> <span class="string">&quot;This is a error&quot;</span>;      &#125;            <span class="keyword">public</span> String <span class="title function_">getUserId</span><span class="params">(String id)</span> &#123;            <span class="keyword">return</span> id;      &#125;&#125;</code></pre><h2 id="微服务中心eureka"><a class="markdownIt-Anchor" href="#微服务中心eureka"></a> 微服务中心Eureka</h2><p><a href="https://github.com/Netflix/eureka">官方网址：https://github.com/Netflix/eureka</a></p><h3 id="eureka引入"><a class="markdownIt-Anchor" href="#eureka引入"></a> Eureka引入</h3><p>前面的例子存在一个问题:消费者直接连接的提供者。这样做的问题是，若提供者出现宕机，或消费者存在高并发情况，那么消费者就会出现问题。所以，我们就需要一个服务注册中心，就像之前的zokeeper一样。提供者对于消费者来说是透明的，不固定的。。</p><p>所有提供者将自己提供服务的名称及自己主机详情(IP、端口、版本等)写入到另一台主机中，这台主机称为服务注册中心。所有消费者需要哪种服务只需向注册中心提交服务名称，注册中心就会根据该服务的所有提供者当前的运行情况(繁忙度、健康状态等)，将一个合适的提供者信息发送给消费者，由消费者访问提供者提供的服务。</p><p>可以充当Spring Cloud服务注册中心的服务器很多，如Zookeeper、Eureka、Consul<br />Template and Nginx.但目前在实际生产环境中使用最多，Spring Cloud支持最好的就是Eurekae</p><h4 id="eureka概述"><a class="markdownIt-Anchor" href="#eureka概述"></a> Eureka概述</h4><p>Eureka，古希腊词语，意思是“我找到了!我发现了!”</p><p>Eureka是Netfix(美国一家视频网络平台公司)开发的服务发现框架，本身是一个基于REST的服务，主要用于定位运行在AwS (Amazon Web Serices, |亚马逊网络服务，一种类似于阿里云的云计算服务)域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。Springcloud将它集成在其子项目spring doud-.etfix中，实现SpringCloud 的<strong>服务发现功能</strong>。</p><p>Eureka包含两个组件:<strong>Eureka Server</strong>和<strong>Eureka Client</strong></p><p><strong>Eureka Server</strong>提供<strong>服务注册功能</strong>，提供者节点启动后，会在Eureka Server中进行注册,这样Eureka Server的服务注册表中将会存储所有可用服务节点的信息。然后各提供者将会向Eureka Server发送<strong>心跳</strong>，以告知Eureka Server自己的健康状况，默认<strong>周期为30秒</strong>。如果在多个心跳周期内(默认3个周期90秒没有接收到某个提供者节点的心跳，Eureka Server会认为其已无法提供服务，会将该提供者节点从服务注册表中移除。Eureka Server之间通过复制的方式完成数据的同步。工</p><p><strong>Eureka Client</strong>是一个java客户端，用于<strong>简化消费者与Eureka Server的交证</strong>。同时，EurekaClient还内置有<strong>负载7种均衡器</strong>，为消费者从Fureka Server的服务注册表中选择合适的提供者.</p><p>Eureka提供了<strong>客户端缓存机制</strong>（因为他把注册表信息都下载到了自己本地），即使所有的Eureka Server都挂掉，客户端依然可以利用缓存中的信息为消费者提供服务发现功能。不过，此时不再接受服务注册，因为EurekaServer已经全部挂掉了。这就是<strong>AP原则（可用性）</strong>（zookeeper遵循的CP原则（一致性））的体现。</p><p>综上，Eureka通过心跳检查、客户端缓存等机制，确保了系统的高可用性、灵活性和可伸缩性。</p><h4 id="eureka体系结构"><a class="markdownIt-Anchor" href="#eureka体系结构"></a> Eureka体系结构</h4><h3 id="创建eureka服务中心"><a class="markdownIt-Anchor" href="#创建eureka服务中心"></a> 创建Eureka服务中心</h3><p>只需三步即可创建一个Eureka服务中心</p><ul><li>导入EurekaServer依赖</li><li>在主配置文件中配置EurekaServer</li><li>在启动类中添加注解@<strong>EnableEurekaServer</strong> 开启EurekaServer</li></ul><h4 id="创建工程"><a class="markdownIt-Anchor" href="#创建工程"></a> 创建工程</h4><p>创建一个spring boot工程：</p><p>工程名：</p><p>导入Eureka依赖：</p><h4 id="pom依赖主配置文件"><a class="markdownIt-Anchor" href="#pom依赖主配置文件"></a> pom依赖/主配置文件</h4><p>pom依赖：</p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>eurekaserver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>eurekaserver<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR3<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p><strong>如果使用的是jdk 8以上的高版本，还需导入下列依赖</strong></p><blockquote><p>注意，这里要导入的依赖并非是Spring Cloud工程要直接依赖的，而是由于Eureka Server所依赖的。但在JDK9之前，这些依赖是包含在JDK中的，从JDK9开始，JAXB API被划归到了Java EE API,从JDK中踢除了出去。由于本例运行的主机使用的是JDK为10,所以需要导入这些JAXB API依赖。若你使用的是JDK6、7、8，那么这些依赖无需导入。</p></blockquote><blockquote><p>JAXB (Java Architecture for XML Binding, XML绑定的Java技术)是一个业界的标准，是一项可以根据XML Schema产生Java类的技术。该过程中，JAXB也提供了将XML实例文档反向生成Java对象树的方法，并能将Java对象树的内容重新写到XML实例文档。从另一方面来讲，JAXB提供了快速而简便的方法将XML模式绑定到Java表示，从而使得Java开发者在Java应用程序中能方便地结合XML数据和处理函数。</p></blockquote><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.activation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><hr /><p><strong>主配置文件：</strong></p><pre><code class="highlight properties"><span class="attr">server.port</span>=<span class="string">8000</span><span class="comment"></span><span class="comment">#指定Eureka主机</span><span class="attr">eureka.instance.hostname</span>=<span class="string">localhost</span><span class="comment"></span><span class="comment"># 指定当前主机是否需要向注册中心注册（不用，因为当前主机是Server，不是client）</span><span class="attr">eureka.client.register-with-eureka</span>=<span class="string">false</span><span class="comment"></span><span class="comment">#指定当前主机是否需要获取注册信息（不用，因为当前主机是Server,不是client）</span><span class="attr">eureka.client.fetch-registry</span>=<span class="string">false</span><span class="comment"></span><span class="comment">#暴露服务中心地址</span><span class="comment">#使用占位符方式</span><span class="attr">eureka.client.service-url.defaultZone</span>=<span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka</span><span class="comment">#普通方式</span><span class="comment">#eureka.client.service-url.defaultZone=http://localhost:8000/eureka</span></code></pre><h4 id="定义spring-boot启动类"><a class="markdownIt-Anchor" href="#定义spring-boot启动类"></a> 定义spring boot启动类</h4><p>添加@EnableEurekaServer注解，开启EurekaServer</p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.eurekaserver;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;<span class="meta">@SpringBootApplication</span><span class="meta">@EnableEurekaServer</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaserverApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(EurekaserverApplication.class, args);    &#125;&#125;</code></pre><h4 id="启动测试"><a class="markdownIt-Anchor" href="#启动测试"></a> 启动测试</h4><p>访问：</p><pre><code class="highlight plaintext">http://localhost:8000/</code></pre><h3 id="修改提供者工程"><a class="markdownIt-Anchor" href="#修改提供者工程"></a> 修改提供者工程</h3><p>只需完成三步即可创建一个Eureka服务提供者</p><ul><li>添加Eureka客户端依赖</li><li>在配置文件中指定要注册的Eureka注册中心</li><li>在启动类上添加@<strong>EnableEurekaClient</strong>注解</li></ul><h4 id="pom依赖主配置文件-2"><a class="markdownIt-Anchor" href="#pom依赖主配置文件-2"></a> pom依赖/主配置文件</h4><p>pom依赖：</p><ul><li>添加Eureka客户端依赖和spring cloud dependencyManagement</li></ul><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>provider<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="comment">&lt;!--Eureka客户端依赖--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!--修改MySQL驱动版本--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!--data数据源阿里巴巴连接池--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p><strong>主配置文件：</strong></p><ul><li><strong>instance-id</strong>：为客户端微服务在Eureka状态显示栏中显示的名称，若不指定，则默认显示的是该服务提供者 <code>主机名：应用名称：端口号</code></li><li><strong><a href="http://spring.application.name">spring.application.name</a></strong>：指定微服务的名称。若不指定，在Eureka中应用名称位置默认显示Unknown，此名称即为提供者对外暴露的微服务名称，<strong>将来服务消费者就是依据此名称来消费服务的</strong></li></ul><pre><code class="highlight properties"><span class="comment">#指定端口号</span><span class="attr">server.port</span>=<span class="string">8081</span><span class="comment">#更改访问上下文路径/访问路径 localhost:8088/leeBoot/...</span><span class="comment">#server.servlet.context-path=/springcloudprovider</span><span class="comment"></span><span class="comment">#开启启动时自动建表</span><span class="attr">spring.jpa.generate-ddl</span>=<span class="string">true</span><span class="comment">#是否在控制台显示sql语句</span><span class="attr">spring.jpa.show-sql</span>=<span class="string">true</span><span class="comment">#设置应用启动时不重新建表</span><span class="attr">spring.jpa.hibernate.ddl-auto</span>=<span class="string">none</span><span class="comment"></span><span class="comment">#配置数据源</span><span class="attr">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/leetest?characterEncoding=UTF-8</span><span class="attr">spring.datasource.username</span>=<span class="string">root</span><span class="attr">spring.datasource.password</span>=<span class="string">123456</span><span class="comment"></span><span class="comment">#配置日志输出格式</span><span class="attr">logging.pattern.console</span>=<span class="string">%level %msg%n</span><span class="comment">#设置spring boot启动时的日志级别</span><span class="attr">logging.level.root</span>=<span class="string">info</span><span class="comment">#hibernate运行日志级别   org.gibernate表示类名</span><span class="attr">logging.level.org.hibernate</span>=<span class="string">info</span><span class="comment">#在show-sql为true时显示sql中的动态参数值</span><span class="attr">logging.level.org.hibernate.type.descriptor.sql.BasicBinder</span>=<span class="string">trace</span><span class="comment">#在show-sql为true时显示查询结果</span><span class="attr">logging.level.org.hibernate.type.descriptor.sql.BasicExtractor</span>=<span class="string">trace</span><span class="comment">#控制自己代码运行时显示的日志级别</span><span class="attr">logging.level.com.lee</span>=<span class="string">debug</span><span class="comment"></span><span class="comment">#指定Eureka服务中心（就是eurekaserver项目中的eureka.client.service-url.defaultZone）</span><span class="attr">eureka.client.service-url.defaultZone</span>:<span class="string">http://localhost:8000/eureka</span><span class="comment">#指定当前客户端在注册中心的名称</span><span class="attr">eureka.instance.instance-id</span>=<span class="string">lee-msc-provider-depart-8081</span><span class="comment"></span><span class="comment">#指定微服务的名称(应用名称)</span><span class="attr">spring.application.name</span>=<span class="string">leemsc-provider-depart</span></code></pre><h4 id="修改启动类"><a class="markdownIt-Anchor" href="#修改启动类"></a> 修改启动类</h4><p>添加@EnableEurekaClient注解：</p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.provider;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;<span class="meta">@SpringBootApplication</span><span class="meta">@EnableEurekaClient</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(ProviderApplication.class, args);    &#125;&#125;</code></pre><h4 id="启动测试-2"><a class="markdownIt-Anchor" href="#启动测试-2"></a> 启动测试</h4><h3 id="actuator完善微服务info"><a class="markdownIt-Anchor" href="#actuator完善微服务info"></a> actuator完善微服务info</h3><p>在微服务状态的超链接上点击，可以看到404错误页面，通过地址栏可以看到：<u><a href="http://localhost:8081/actuator/info">http://localhost:8081/actuator/info</a></u>，因为是由于在配置文件中没有设置actuator的info监控终端所致</p><h4 id="提供者添加依赖"><a class="markdownIt-Anchor" href="#提供者添加依赖"></a> 提供者添加依赖</h4><p>添加actuator依赖</p><pre><code class="highlight xml"><span class="comment">&lt;!--添加actuator依赖--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h4 id="提供者配置文件"><a class="markdownIt-Anchor" href="#提供者配置文件"></a> 提供者配置文件</h4><p>在eureka客户端工程中，为服务提供者工程在配置文件的最后添加如下内容：</p><ul><li>info：是不能变化的，表示这里定义的是info页面内容</li><li>二级内容分为key与value，key与value可以任意指定，其显示到页面是以JSON数据的形式出现</li><li>二级内容key若只有一级，则其为JSON的key，value为JSON的value</li><li>二级内容key若为两级，则第一集为JSON的key，而该JSON的值为JSON数组</li></ul><pre><code class="highlight properties"><span class="comment">#指定端口号</span><span class="attr">server.port</span>=<span class="string">8081</span><span class="comment">#更改访问上下文路径/访问路径 localhost:8088/leeBoot/...</span><span class="comment">#server.servlet.context-path=/springcloudprovider</span><span class="comment"></span><span class="comment">#开启启动时自动建表</span><span class="attr">spring.jpa.generate-ddl</span>=<span class="string">true</span><span class="comment">#是否在控制台显示sql语句</span><span class="attr">spring.jpa.show-sql</span>=<span class="string">true</span><span class="comment">#设置应用启动时不重新建表</span><span class="attr">spring.jpa.hibernate.ddl-auto</span>=<span class="string">none</span><span class="comment"></span><span class="comment">#配置数据源</span><span class="attr">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/leetest?characterEncoding=UTF-8</span><span class="attr">spring.datasource.username</span>=<span class="string">root</span><span class="attr">spring.datasource.password</span>=<span class="string">123456</span><span class="comment"></span><span class="comment">#配置日志输出格式</span><span class="attr">logging.pattern.console</span>=<span class="string">%level %msg%n</span><span class="comment">#设置spring boot启动时的日志级别</span><span class="attr">logging.level.root</span>=<span class="string">info</span><span class="comment">#hibernate运行日志级别   org.gibernate表示类名</span><span class="attr">logging.level.org.hibernate</span>=<span class="string">info</span><span class="comment">#在show-sql为true时显示sql中的动态参数值</span><span class="attr">logging.level.org.hibernate.type.descriptor.sql.BasicBinder</span>=<span class="string">trace</span><span class="comment">#在show-sql为true时显示查询结果</span><span class="attr">logging.level.org.hibernate.type.descriptor.sql.BasicExtractor</span>=<span class="string">trace</span><span class="comment">#控制自己代码运行时显示的日志级别</span><span class="attr">logging.level.com.lee</span>=<span class="string">debug</span><span class="comment"></span><span class="comment">#指定Eureka服务中心（就是eurekaserver项目中的eureka.client.service-url.defaultZone）</span><span class="attr">eureka.client.service-url.defaultZone</span>:<span class="string">http://localhost:8000/eureka</span><span class="comment">#指定当前客户端在注册中心的名称</span><span class="comment">#eureka.instance.instance-id=lee-msc-provider-depart-8081</span><span class="comment"></span><span class="comment">#指定微服务的名称(应用名称)</span><span class="attr">spring.application.name</span>=<span class="string">leemsc-provider-depart</span><span class="comment"></span><span class="comment">#info后面的内容可以随便写</span><span class="attr">info.company.name</span>=<span class="string">leeboer.xyz</span><span class="attr">info.company.address</span>=<span class="string">xian</span><span class="attr">info.company.tel</span>=<span class="string">123456798</span><span class="attr">info.app.name</span>=<span class="string">leemsc-provider-depart</span><span class="attr">info.app.people</span>=<span class="string">leeboer</span></code></pre><h4 id="运行测试"><a class="markdownIt-Anchor" href="#运行测试"></a> 运行测试</h4><h3 id="self-preservation机制"><a class="markdownIt-Anchor" href="#self-preservation机制"></a> Self Preservation机制</h3><p>Self Preservation机制即自我保护机制，在Eureka服务页面中看到如下红色字体内容，表示当前EurekaServer启动了自我保护机制，进入了自我保护模式</p><p>[翻译]紧急情况!当微服务主机联系不上时，Eureka 不能够正确判断它们是否处于up状态。当更新(指收到的微服务主机的心跳)小于阈值时，为了安全，微服务主机将不再失效。</p><p>默认情况下，EurekaServer在90秒内没有检测到服务列表中的某微服务，则会自动将该微服务从服务列表中删除。但很多情况下并不是该微服务节点（主机)出了问题，而是由于网络故障或网速等原因使该微服务无法被EurekaServer发现，即无法检测到该微服务主机的心跳。若在短暂时间内网络恢复正常，但由于EurekaServer 的服务列表中已经没有该微服务，所以该微服务已经无法提供服务了。</p><p>在短时间内若EurekaServer丢失较多微服务( EurekaServer收到的心跳数量小于阙值)，那么其会自动进入自我保护模式:服务列表只可读取、写入，不可执行删除操作。当EurekaServer收到的心跳数量恢复到阈值以上时，其会自动退出Self Preservation模式(翻译自官网)</p><p><strong>Self Preservation机制默认是开启的，可以通过修改EurekaServer中配置文件来关闭</strong>。但建议不关闭</p><pre><code class="highlight properties"><span class="attr">server.port</span>=<span class="string">8000</span><span class="comment"></span><span class="comment">#指定Eureka主机</span><span class="attr">eureka.instance.hostname</span>=<span class="string">localhost</span><span class="comment"></span><span class="comment">#关闭自我保护机制</span><span class="attr">eureka.server.enable-self-preservation</span>=<span class="string">false</span><span class="comment"></span><span class="comment"># 指定当前主机是否需要向注册中心注册（不用，因为当前主机是Server，不是client）</span><span class="attr">eureka.client.register-with-eureka</span>=<span class="string">false</span><span class="comment"></span><span class="comment">#指定当前主机是否需要获取注册信息（不用，因为当前主机是Server,不是client）</span><span class="attr">eureka.client.fetch-registry</span>=<span class="string">false</span><span class="comment"></span><span class="comment">#暴露服务中心地址</span><span class="comment">#使用占位符方式</span><span class="attr">eureka.client.service-url.defaultZone</span>=<span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka</span><span class="comment">#普通方式</span><span class="comment">#eureka.client.service-url.defaultZone=http://localhost:8000/eureka</span></code></pre><h3 id="修改消费者工程"><a class="markdownIt-Anchor" href="#修改消费者工程"></a> 修改消费者工程</h3><p>消费者将使用提供者暴露的服务名称（<a href="http://spring.application.name">spring.application.name</a>）来消费服务</p><p>完成以下四个步骤即可创建一个Eureka服务消费者</p><ul><li>添加Eureka客户端依赖</li><li>在配置文件中指定要注册的Eureka注册中心</li><li>在CodeConfig类中为RestTemplate添加@LoadBalanced注解</li><li>在启动类上添加@EnableEurekaClient</li></ul><h4 id="添加依赖修改主配置文件"><a class="markdownIt-Anchor" href="#添加依赖修改主配置文件"></a> 添加依赖/修改主配置文件</h4><p>pom依赖：</p><ul><li>添加Eureka客户端依赖和spring cloud dependencyManagement</li></ul><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="comment">&lt;!--Eureka客户端依赖--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!--添加actuator依赖--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p>主配置文件：</p><pre><code class="highlight properties"><span class="comment">#指定端口号</span><span class="attr">server.port</span>=<span class="string">8080</span><span class="comment"></span><span class="comment">#指定微服务对外暴露的名称</span><span class="attr">spring.application.name</span>=<span class="string">leemsc-consumer-depart</span><span class="comment"></span><span class="comment">#指定Eureka服务注册中心</span><span class="attr">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:8000/eureka</span></code></pre><h4 id="修改configuration类启动类"><a class="markdownIt-Anchor" href="#修改configuration类启动类"></a> 修改Configuration类/启动类</h4><p>修改Configuration类:</p><ul><li>@LoadBalanced：开启消费端的负载均衡功能，默认是轮询策略</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer.codeconfig;<span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;<span class="keyword">import</span> org.springframework.context.annotation.Bean;<span class="keyword">import</span> org.springframework.context.annotation.Configuration;<span class="keyword">import</span> org.springframework.web.client.RestTemplate;<span class="meta">@Configuration</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartCodeConfig</span> &#123;    <span class="comment">//开启消费端的负载均衡功能，默认是轮询策略</span>    <span class="meta">@LoadBalanced</span>    <span class="meta">@Bean</span>    <span class="comment">//bean的名称就相当于方法名</span>    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();    &#125;&#125;</code></pre><p>修改启动类：</p><ul><li>添加@EnableEurekaClient注解</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;<span class="meta">@SpringBootApplication</span><span class="meta">@EnableEurekaClient</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(ConsumerApplication.class, args);    &#125;&#125;</code></pre><h4 id="运行测试-2"><a class="markdownIt-Anchor" href="#运行测试-2"></a> 运行测试</h4><h3 id="服务发现discovery"><a class="markdownIt-Anchor" href="#服务发现discovery"></a> 服务发现discovery</h3><p>服务发现，即通过“服务发现客户端”，<strong>读取EurekaServer中的服务列表</strong>，获取指定名称的微服务详情</p><h4 id="修改处理器"><a class="markdownIt-Anchor" href="#修改处理器"></a> 修改处理器</h4><p>在<strong>任何</strong>微服务的<strong>提供者或者消费者</strong>处理器中，只要获取到“服务发现Client”，即可读取到EurekaServer的微服务列表</p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.provider.Controller;<span class="keyword">import</span> com.lee.provider.bean.Depart;<span class="keyword">import</span> com.lee.provider.service.DepartService;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.cloud.client.ServiceInstance;<span class="keyword">import</span> org.springframework.cloud.client.discovery.DiscoveryClient;<span class="keyword">import</span> org.springframework.web.bind.annotation.*;<span class="keyword">import</span> java.util.List;<span class="meta">@RequestMapping(&quot;/provider/depart&quot;)</span><span class="meta">@RestController</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartController</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> DepartService service;    <span class="comment">//获取服务发现客户端</span>    <span class="meta">@Autowired</span>    <span class="keyword">private</span> DiscoveryClient client;    <span class="meta">@PostMapping(&quot;/save&quot;)</span>    <span class="comment">//@RequestBody表示传过来的数据时json数据</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveHandle</span><span class="params">(<span class="meta">@RequestBody</span> Depart depart)</span> &#123;        <span class="keyword">return</span> service.saveDepart(depart);    &#125;    <span class="meta">@DeleteMapping(&quot;/del/&#123;id&#125;&quot;)</span>    <span class="comment">//@PathVariable 表示获取url中的&#123;id&#125;的值</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteHandle</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;        <span class="keyword">return</span> service.removeDepartById(id);    &#125;    <span class="meta">@PutMapping(&quot;/update&quot;)</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateHandle</span><span class="params">(<span class="meta">@RequestBody</span> Depart depart)</span>&#123;        <span class="keyword">return</span> service.modifyDepart(depart);    &#125;    <span class="meta">@GetMapping(&quot;/get/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> Depart <span class="title function_">GetHandle</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span>&#123;        <span class="keyword">return</span> service.getDepartById(id);    &#125;    <span class="meta">@GetMapping(&quot;/list&quot;)</span>    <span class="keyword">public</span> List&lt;Depart&gt; <span class="title function_">listHandle</span><span class="params">()</span> &#123;        <span class="keyword">return</span> service.listAllDeparts();    &#125;    <span class="meta">@GetMapping(&quot;/discovery&quot;)</span>    <span class="keyword">public</span> Object <span class="title function_">discoverHandler</span><span class="params">()</span>&#123;        <span class="comment">//获取服务注册列表中所有微服务名称</span>        List&lt;String&gt; springApplicationNames = client.getServices();        <span class="keyword">for</span> (String name : springApplicationNames) &#123;            <span class="comment">//获取提供指定微服务名称服务的所有提供者主机（因为服务提供者的主机不仅仅是一台）</span>            List&lt;ServiceInstance&gt; instances = client.getInstances(name);            <span class="keyword">for</span> (ServiceInstance instance : instances) &#123;                System.out.println(instance.getHost()+<span class="string">&quot; : &quot;</span>+instance.getPort());            &#125;        &#125;        <span class="keyword">return</span> springApplicationNames;    &#125;&#125;</code></pre><h4 id="启动类添加注解"><a class="markdownIt-Anchor" href="#启动类添加注解"></a> 启动类添加注解</h4><p>添加@EnableDiscoveryClient，开启服务发现客户端</p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.provider;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;<span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;<span class="meta">@SpringBootApplication</span><span class="meta">@EnableEurekaClient</span><span class="meta">@EnableDiscoveryClient</span>  <span class="comment">//开启服务发现客户端</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(ProviderApplication.class, args);    &#125;&#125;</code></pre><h4 id="运行测试-3"><a class="markdownIt-Anchor" href="#运行测试-3"></a> 运行测试</h4><p>浏览器输出：</p><p>控制台输出:</p><h3 id="eurekaserver集群"><a class="markdownIt-Anchor" href="#eurekaserver集群"></a> EurekaServer集群</h3><p>单个EurekaServer不仅吞吐量有限，还存在单点问题，所以我们会使用EurekaServer集群，这里要搭建的EurekaServer集群中包含三个EurekaServer节点，其端口号分别为8100，8200，8300</p><h4 id="修改eurekaserver"><a class="markdownIt-Anchor" href="#修改eurekaserver"></a> 修改EurekaServer</h4><p>要想搭建EurekaServer，需在三台服务器启动EurekaServer，EurekaServer的改动如下：</p><ul><li>只需在<code>eureka.client.service-url.defaultZone</code>中指定所有的服务中心的地址即可，每个服务中心之间用逗号隔开</li></ul><pre><code class="highlight properties"><span class="attr">server.port</span>=<span class="string">8000</span><span class="comment"></span><span class="comment">#指定Eureka主机</span><span class="attr">eureka.instance.hostname</span>=<span class="string">192.168.1.1</span><span class="comment"></span><span class="comment">#关闭自我保护机制</span><span class="comment">#eureka.server.enable-self-preservation=false</span><span class="comment"></span><span class="comment"># 指定当前主机是否需要向注册中心注册（不用，因为当前主机是Server，不是client）</span><span class="attr">eureka.client.register-with-eureka</span>=<span class="string">false</span><span class="comment"></span><span class="comment">#指定当前主机是否需要获取注册信息（不用，因为当前主机是Server,不是client）</span><span class="attr">eureka.client.fetch-registry</span>=<span class="string">false</span><span class="comment"></span><span class="comment">#暴露服务中心地址</span><span class="attr">eureka.client.service-url.defaultZone</span>=<span class="string">http://192.168.1.1:8000/eureka,http://192.168.1.2:8000/eureka,http://192.168.1.3:8000/eureka</span></code></pre><h4 id="服务提供者服务消费者"><a class="markdownIt-Anchor" href="#服务提供者服务消费者"></a> 服务提供者/服务消费者</h4><p>服务提供者/服务消费者要想访问集群，也只需修改<code>eureka.client.service-url.defaultZone</code>即可</p><pre><code class="highlight properties"><span class="comment">#指定Eureka服务注册中心</span><span class="attr">eureka.client.service-url.defaultZone</span>=<span class="string">http://192.168.1.1:8000/eureka,http://192.168.1.2:8000/eureka,http://192.168.1.3:8000/eureka</span></code></pre><h3 id="eureka与zookeeper对比"><a class="markdownIt-Anchor" href="#eureka与zookeeper对比"></a> Eureka与Zookeeper对比</h3><h4 id="eureka与ap原则"><a class="markdownIt-Anchor" href="#eureka与ap原则"></a> eureka与AP原则</h4><p>Eureka在CAP原则中遵循的是AP原则，即保证了可用性，牺牲了一致性。</p><p>Eureka Server集群中各个节点都是平等的，不像zk集群中还存在Leader与Follower.每个Eureka Server节点都具有向客户端响应读写操作的功能。只要不是出现集群中所有节点都宕机的情况，Eureka的服务注册与发现功能就不会停止。即使所有Eureka Server都宕机了，Eureka Client通过其缓存机制仍可对外提供服务发现功能，虽然此时已经不能再进行服务注册了。这保证了可用性。</p><p>当某一个Eureka集群节点中数据更新了，其会向其它节点发出广播，让其同步数据。但同步数据之前及之间，尚未更新数据的节点并不会停止服务，其依然可以进行服务的注册与发现。只不过其服务列表中的数据不能保证是最新的。从这点可知，Eureka通过牺牲一致性，保证了可用性。</p><p>Eureka为了保证可用性，启用了Self Preservation自我保护机制。自我保护机制一旦启动，Eureka将不再从服务列表中删除长时间没有收到心跳的服务:此时的Eureka虽然仍可以接受新的服务注册与发现，但不会被同步到其它节点。当网络稳定时，当前Eureka实例新的数据信息就会被同步到其它节点中。</p><h4 id="zookeer与cp原则"><a class="markdownIt-Anchor" href="#zookeer与cp原则"></a> Zookeer与CP原则</h4><p>zk遵循的是CP原则，即保证了一致性，但牺牲了可用性。体现在哪里呢?</p><p>当Leader宕机后，zk集群会马上进行新的Leader的选举。但选举选举时长在30-120秒间，整个选举期间zk集群是不接受客户端的读写操作的，即zk集群是处于瘫痪状态的。所以，其不满足可用性。</p><p>为什么Leader的选举需要这么长的时间呢?为了保证zk集群各个节点中数据的一致性，zk集群做了两类数据同步:初始化同步与更新同步。当新的Leader被选举出后，各个Follower需要将新Leader的数据同步到自己的缓存中，这是初始化同步，当Leader的数据被客户端修改后，其会向Follower发出广播，然后各个Follower会主动同步Leader的更新数据，这是更新同步。无论是初始化同步还是更新同步，zk集群为了保证数据的一致性，若发现超过半数的Follower同步超时，则其会再次进行同步，而这个过程中zk集群是处于不对外提供服务状态。</p><h2 id="声明式rest客户端openfeign"><a class="markdownIt-Anchor" href="#声明式rest客户端openfeign"></a> 声明式REST客户端OpenFeign</h2><h3 id="openfeign概述"><a class="markdownIt-Anchor" href="#openfeign概述"></a> OpenFeign概述</h3><p>本项目通过自动配置和绑定到Spring环境和其他Spring编程模型习惯用法，为Spring引导应用程序提供OpenFeign集成</p><p><strong>功能</strong></p><p>声明式REST客户端：Feign创建一个使用JAX-RS或Spring MVC注解修饰的接口的动态实现</p><h4 id="openfeign与feign"><a class="markdownIt-Anchor" href="#openfeign与feign"></a> OpenFeign与Feign</h4><p>Spring Boot 1.x及Spring Cloud之前的版本环境下使用的是Feign，而该项目现已更新了OpenFeign，所以后续使用的依赖也发生了变化</p><pre><code class="highlight xml"><span class="comment">&lt;!--openfeign依赖--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!--feign依赖--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h4 id="ribbon简介"><a class="markdownIt-Anchor" href="#ribbon简介"></a> Ribbon简介</h4><p>Ribbon是Netflix公司开源的一个负载均衡的项目，是一个客户端负载均衡器，运行在消费者端，当然，一定是Eureka客户端</p><p><strong>Ribbon与OpenFeign</strong></p><p>OpenFeign中使用Ribbon进行负载均衡，所以OpenFeign直接内置了Ribbon，即在导入OpenFeign依赖后，无需再专门导入Ribbon依赖了</p><h3 id="修改消费者工程-2"><a class="markdownIt-Anchor" href="#修改消费者工程-2"></a> 修改消费者工程</h3><p>这里无需修改提供者工程，只需修改消费者工程即可</p><p>需完成四部即可使用feign接口消费微服务：</p><ul><li>添加openfeign依赖</li><li>定义Service接口，并用@FeignClient指定其所绑定的微服务名（即服务提供者的applicationName）</li><li>修改处理器，通过Service接口消费微服务</li><li>在启动类上添加@EnableFeignClients注解</li></ul><blockquote><p>不要忘记在主配置文件修改<strong>统一</strong>的服务提供者和服务消费者的服务注册中心</p></blockquote><p><strong>pom依赖</strong></p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="comment">&lt;!--Eureka客户端依赖--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!--添加actuator依赖--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!--添加OpenFeign依赖--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p><strong>定义Service接口</strong></p><ul><li>@FeignClient：指定当前service所绑定的提供者微服务的名称</li><li>所有的@XXXMapping相关注解与服务提供者的Controller一一对应，就相当于我们消费者的接口实现是服务提供者的Controller</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer.service;<span class="keyword">import</span> com.lee.consumer.bean.Depart;<span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;<span class="keyword">import</span> org.springframework.web.bind.annotation.*;<span class="keyword">import</span> java.util.List;<span class="comment">//指定当前service所绑定的提供者微服务的名称</span><span class="meta">@FeignClient(&quot;leemsc-provider-depart&quot;)</span><span class="meta">@RequestMapping(&quot;/provider/depart&quot;)</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DepartService</span> &#123;    <span class="meta">@PostMapping(&quot;/save&quot;)</span>    <span class="type">boolean</span> <span class="title function_">saveDepart</span><span class="params">(Depart depart)</span>;    <span class="meta">@DeleteMapping(&quot;/del/&#123;id&#125;&quot;)</span>    <span class="type">boolean</span> <span class="title function_">removeDepartById</span><span class="params">(<span class="meta">@PathVariable</span>  <span class="type">int</span> id)</span>;    <span class="meta">@PutMapping(&quot;/update&quot;)</span>    <span class="type">boolean</span> <span class="title function_">modifyDepart</span><span class="params">(Depart depart)</span>;    <span class="meta">@GetMapping(&quot;/get/&#123;id&#125;&quot;)</span>    Depart <span class="title function_">getDepartById</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span>;    <span class="meta">@GetMapping(&quot;/list&quot;)</span>    List&lt;Depart&gt; <span class="title function_">listAllDeparts</span><span class="params">()</span>;&#125;</code></pre><p><strong>修改处理器类</strong></p><ul><li>使用feign风格的service，不再使用RestTemplate</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer.Controller;<span class="keyword">import</span> com.lee.consumer.bean.Depart;<span class="keyword">import</span> com.lee.consumer.service.DepartService;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.web.bind.annotation.*;<span class="keyword">import</span> org.springframework.web.client.RestTemplate;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * 使用openFeign后，不用再使用RestTemplate，编程风格和以前一样了</span><span class="comment"> */</span><span class="meta">@RestController</span><span class="meta">@RequestMapping(&quot;/consumer/depart&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartController</span> &#123;    <span class="meta">@Autowired</span>    <span class="comment">//这里不再注入RestTemplate，注入service接口</span>    <span class="keyword">private</span> DepartService service;    <span class="meta">@PostMapping(&quot;/save&quot;)</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveHandle</span><span class="params">(Depart depart)</span> &#123;        <span class="keyword">return</span> service.saveDepart(depart);    &#125;    <span class="meta">@DeleteMapping(&quot;/del/&#123;id&#125;&quot;)</span>    <span class="comment">//@PathVariable 表示获取url中的&#123;id&#125;的值</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteHandle</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;        <span class="keyword">return</span> service.removeDepartById(id);    &#125;    <span class="meta">@PutMapping(&quot;/update&quot;)</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateHandle</span><span class="params">(Depart depart)</span> &#123;        <span class="keyword">return</span> service.modifyDepart(depart);    &#125;    <span class="meta">@GetMapping(&quot;/get/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> Depart <span class="title function_">GetHandle</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span> &#123;        <span class="keyword">return</span> service.getDepartById(id);    &#125;    <span class="meta">@GetMapping(&quot;/list&quot;)</span>    <span class="keyword">public</span> List&lt;Depart&gt; <span class="title function_">listHandle</span><span class="params">()</span> &#123;        <span class="keyword">return</span> service.listAllDeparts();    &#125;&#125;</code></pre><p><strong>修改启动类</strong></p><ul><li>@EnableFeignClients：开启feign客户端，指定service接口所在包</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;<span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;<span class="comment">//开启feign客户端，指定service接口所在包</span><span class="meta">@EnableFeignClients(basePackages = &quot;com.lee.consumer.service&quot;)</span><span class="meta">@SpringBootApplication</span><span class="meta">@EnableEurekaClient</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(ConsumerApplication.class, args);    &#125;&#125;</code></pre><p><strong>运行测试</strong></p><h3 id="ribbon负载均衡展示"><a class="markdownIt-Anchor" href="#ribbon负载均衡展示"></a> Ribbon负载均衡展示</h3><p>前面的消费者例子是通过feign接口来消费微服务的，但没体现出负载均衡的功能，所以，下面将进行Feign负载均衡的功能展示</p><h4 id="系统结构"><a class="markdownIt-Anchor" href="#系统结构"></a> 系统结构</h4><p>负载均衡能力的展示需要搭建出多个服务提供者。下面将构建这样一一个系统:一一个微服务由三个提供者提供，而消费者使用Ribbon对这三个提供者进行负载均衡访问。Ribbon 首先会选择同一区域内访问量较少的EurekaServer,然后再从该EurekaServer中获取到服务列表，然后再根据用户指定的负载均衡策略选择-一个服务提供者。</p><h4 id="项目搭建"><a class="markdownIt-Anchor" href="#项目搭建"></a> 项目搭建</h4><p>首先我们需要创建三个服务名相同，使用数据库不同的服务提供者，我们只需要把之前的服务提供者复制三分，然后分别修改以下内容</p><ul><li><strong>创建数据库</strong>：让每一个服务提供者都访问自己的数据库（即分别创建三个database）</li><li><strong>修改配置文件</strong>：<ul><li>当前工程的端口号，8080，8081，8082</li><li>自己要连接的数据库database名</li></ul></li></ul><blockquote><p>注意：服务名称不可以修改，因为消费者是通过该名称来进行负载均衡服务消费的</p></blockquote><p><strong>测试</strong></p><p>分别启动三个服务提供者，启动一个eurekaserver，再启动服务消费者，查看Eureka服务中心：</p><p>我们调用服务消费者（Eureka client端）的Controller时，可以发现，默认负载均衡算法时分别调用三个服务提供者，因为<strong>默认负载均衡算法为轮询算法</strong></p><h3 id="ribbon负载均衡算法irule"><a class="markdownIt-Anchor" href="#ribbon负载均衡算法irule"></a> Ribbon负载均衡算法IRule</h3><p>Ribbon提供了多种负载均衡策略算法，例如轮询算法、随机算法、响应时间加权算法等。默认采用的是轮询算法。当然，我们也可以指定Ribbon所要采用的负载均衡算法。</p><h4 id="ribbon接口"><a class="markdownIt-Anchor" href="#ribbon接口"></a> Ribbon接口</h4><p>IRule接口的实现类就是Ribbon默认的几种负载均衡算法；</p><p><strong>choose0方法</strong></p><p><strong>Ribbon的负载均衡算法需要实现lRule接口</strong>，而该接口中的核心方法即choose()方法，即对提供者的选择方式就是在该方法中体现的。</p><p>查看该方法的注释，其意思是“根据key的值从alservers或upServers集合中选择一个可用的Server”。allServers是所有提供者集合，而upServers则是所有可用的提供者集合。choose()方法的参数key是集合选择的标准。</p><pre><code class="highlight java"><span class="keyword">package</span> com.netflix.loadbalancer;<span class="comment">/**</span><span class="comment"> * Interface that defines a &quot;Rule&quot; for a LoadBalancer. A Rule can be thought of</span><span class="comment"> * as a Strategy for loadbalacing. Well known loadbalancing strategies include</span><span class="comment"> * Round Robin, Response Time based etc.</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@author</span> stonse</span><span class="comment"> * </span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRule</span>&#123;    <span class="comment">/*</span><span class="comment">     * choose one alive server from lb.allServers or</span><span class="comment">     * lb.upServers according to key</span><span class="comment">     * </span><span class="comment">     * @return choosen Server object. NULL is returned if none</span><span class="comment">     *  server is available </span><span class="comment">     */</span>    <span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(Object key)</span>;        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span>;        <span class="keyword">public</span> ILoadBalancer <span class="title function_">getLoadBalancer</span><span class="params">()</span>;    &#125;</code></pre><blockquote><p>不过，从ribbon2.0开始，该key就被固定为“default”了，即该参数已经失去了实际的意义了，打开iRibbonLoadBalanceClient类的getServer()方法，可以看到其调用了loadBalancer的choose()方法，实参为&quot;default&quot;</p></blockquote><h4 id="ribbon自带算法"><a class="markdownIt-Anchor" href="#ribbon自带算法"></a> Ribbon自带算法</h4><p>Ribbon的内置可用负载均衡算法有七种</p><p><strong>RoundRobinRule</strong></p><p>轮询算法，Ribbon默认采用的策略</p><p><strong>BestAvailableRule</strong></p><p>选择并发量最小的provider，即连接的消费者数量最少的provider，其会遍历服务列表中的每一个provide，选择当前连接数量minimalConcurrentConnections最小的provider</p><p><strong>AvailabilityFilteringRule</strong></p><p>过滤掉由于连续连接或读故障而处于断路器跳闸状态的provide，或已经超过连接极限的provide，对剩余provide采用轮询策略</p><p><strong>ZoneAvoidanceRule</strong></p><p>复合判断provider所在区域的性能及provider的可用性选择服务器</p><p><strong>RandomRule</strong></p><p>随机策略，从所有可用的provide中随机选择一个</p><p><strong>RetryRule</strong></p><p>先按照RoundRobinRule策略获取provider，若获取失败，则再指定的时限内重试，默认的时限为500毫秒</p><p><strong>WeightedResponseTimeRule</strong></p><p>&quot;权重响应时间&quot;策略，根据每个provide的平均响应时间计算其权重，响应时间越快权重越大，被选中的几率就越高，再刚启动时采用轮询策略，后面就会根据权重进行选择了</p><h4 id="更换默认策略"><a class="markdownIt-Anchor" href="#更换默认策略"></a> 更换默认策略</h4><p>Ribbon默认采用的是RoundRobinRule，即轮询策略，但通过修改消费者的启动类或者codeConfig类可以实现更换负载均衡策略的目的：只需添加如下代码即可：</p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer;<span class="keyword">import</span> com.netflix.loadbalancer.IRule;<span class="keyword">import</span> com.netflix.loadbalancer.RandomRule;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;<span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;<span class="keyword">import</span> org.springframework.context.annotation.Bean;<span class="comment">//开启feign客户端，指定service接口所在包</span><span class="meta">@EnableFeignClients(basePackages = &quot;com.lee.consumer.service&quot;)</span><span class="meta">@SpringBootApplication</span><span class="meta">@EnableEurekaClient</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(ConsumerApplication.class, args);    &#125;    <span class="comment">//指定Ribbon使用&quot;随机算法策略&quot;</span>    <span class="meta">@Bean</span>    <span class="keyword">public</span> IRule <span class="title function_">LoadBalanceRule</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();    &#125;&#125;</code></pre><h4 id="自定义负载均衡策略"><a class="markdownIt-Anchor" href="#自定义负载均衡策略"></a> 自定义负载均衡策略</h4><p>该负载均衡策略的思路是：从所有可用的provider中排除掉指定端口号的provider，剩余的provide随机选择</p><pre><code class="highlight java"><span class="keyword">package</span> rule;<span class="keyword">import</span> com.netflix.loadbalancer.ILoadBalancer;<span class="keyword">import</span> com.netflix.loadbalancer.IRule;<span class="keyword">import</span> com.netflix.loadbalancer.Server;<span class="keyword">import</span> java.util.Iterator;<span class="keyword">import</span> java.util.List;<span class="keyword">import</span> java.util.Random;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRule</span> <span class="keyword">implements</span> <span class="title class_">IRule</span> &#123;    ILoadBalancer lb;    <span class="comment">//要排除的提供者端口号集合</span>    <span class="keyword">private</span> List&lt;Integer&gt; excludePorts;    <span class="keyword">public</span> <span class="title function_">CustomRule</span><span class="params">()</span> &#123;    &#125;    <span class="comment">//从构造函数中传入要排除的端口号集合</span>    <span class="keyword">public</span> <span class="title function_">CustomRule</span><span class="params">(List&lt;Integer&gt; excludePorts)</span> &#123;        <span class="built_in">this</span>.excludePorts = excludePorts;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(Object key)</span> &#123;        <span class="comment">//获取所有可用的提供者</span>        List&lt;Server&gt; servers = lb.getReachableServers();        <span class="comment">//获取所有排除了指定端口号的提供者</span>        List&lt;Server&gt; availableServices = <span class="built_in">this</span>.getAvailableServices(servers);        <span class="comment">//从剩余的提供者中随机获取可用的提供者</span>        <span class="keyword">return</span> <span class="built_in">this</span>.getAvailableRandomServices(availableServices);    &#125;    <span class="comment">//获取所有排除了指定端口号的提供者</span>    <span class="keyword">private</span> List&lt;Server&gt; <span class="title function_">getAvailableServices</span><span class="params">(List&lt;Server&gt; servers)</span> &#123;        <span class="keyword">if</span> (excludePorts == <span class="literal">null</span> || excludePorts.size() == <span class="number">0</span>) &#123;            <span class="keyword">return</span> servers;        &#125;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; servers.size(); i++) &#123;            <span class="keyword">for</span> (Integer port : excludePorts) &#123;                <span class="keyword">if</span> (port.equals(servers.get(i).getPort())) &#123;                    servers.remove(i);                    <span class="keyword">break</span>;                &#125;            &#125;        &#125;        <span class="keyword">return</span> servers;    &#125;    <span class="comment">//从剩余的提供者中随机获取可用的提供者</span>    <span class="keyword">private</span> Server <span class="title function_">getAvailableRandomServices</span><span class="params">(List&lt;Server&gt; servers)</span> &#123;        <span class="comment">//获取一个[0，servers.size() )的随机整数</span>        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(servers.size());        <span class="keyword">return</span> servers.get(index);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span> &#123;        <span class="built_in">this</span>.lb = lb;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> ILoadBalancer <span class="title function_">getLoadBalancer</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="built_in">this</span>.lb;    &#125;&#125;</code></pre><p>然后再启动类或者@Configuration声明的类给spring注入我们自定义的负载均衡规则</p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer;<span class="keyword">import</span> com.netflix.loadbalancer.IRule;<span class="keyword">import</span> com.netflix.loadbalancer.RandomRule;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;<span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;<span class="keyword">import</span> org.springframework.context.annotation.Bean;<span class="keyword">import</span> rule.CustomRule;<span class="keyword">import</span> java.util.ArrayList;<span class="keyword">import</span> java.util.List;<span class="comment">//开启feign客户端，指定service接口所在包</span><span class="meta">@EnableFeignClients(basePackages = &quot;com.lee.consumer.service&quot;)</span><span class="meta">@SpringBootApplication</span><span class="meta">@EnableEurekaClient</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(ConsumerApplication.class, args);    &#125;<span class="comment">//    //指定Ribbon使用&quot;随机算法策略&quot;</span><span class="comment">//    @Bean</span><span class="comment">//    public IRule LoadBalanceRule()&#123;</span><span class="comment">//        return new RandomRule();</span><span class="comment">//    &#125;</span>    <span class="comment">//指定Ribbon使用&quot;自定义的负载均衡算法策略&quot;</span>    <span class="meta">@Bean</span>    <span class="keyword">public</span> IRule <span class="title function_">LoadBalanceRule</span><span class="params">()</span>&#123;        List&lt;Integer&gt; ports = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();        ports.add(<span class="number">8081</span>);        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomRule</span>(ports);    &#125;&#125;</code></pre><h2 id="hystrix熔断机制与服务降级"><a class="markdownIt-Anchor" href="#hystrix熔断机制与服务降级"></a> Hystrix熔断机制与服务降级</h2><h3 id="服务熔断简介"><a class="markdownIt-Anchor" href="#服务熔断简介"></a> 服务熔断简介</h3><p>若要了解服务熔断，需要先了解雪崩效应和服务雪崩</p><p><strong>雪崩效应</strong></p><p>分布式系统中很容易出现雪崩效应</p><p>在IO型服务中，假设服务A依赖服务B和服务C，而B服务和C服务有可能继续依赖其他的服务，继续下去会使得调用链路过长，技术上称1-&gt;N扇出</p><p>如果在A的链路上某个或几个被调用的子服务不可用或延迟较高，则会导致调用A服务的请求被堵住。</p><p>堵住的A请求会消耗占用系统的线程、10等资源，当对A服务的请求越来越多，占用的计算机资源越来越多的时候，会导致系统瓶颈出现，造成其他的请求同样不可用，最终导致业务系统崩溃，这种现象称为雪崩效应。</p><p>例如一个汽车生产线，生产不同的汽车，需要使用不同的零件。如果某个零件因为种种原因无法及时供给，而没有该零件，则后续的好多已经到货的零件也无法安装。一个零件的缺失造成整台车无法装配，陷入等待零件的状态，直到零件到位，才能继续组装。</p><p>此时如果有很多个车型都需要这个零件，那么整个工厂都将陷入等待的状态，而前述已经生成好的汽车部件，及暂不能安装的其它零件,将由于等待而占用大量资金、厂地等资源。一个零件最终导致所有的生产陷入瘫痪，这就是雪崩效应。</p><p><strong>服务雪崩</strong></p><p>雪崩效应发生在分布式（Service-Oriented Architecture，面向服务的架构）系统中，则称为服务雪崩</p><p>上图是用户请求多个服务（A,H,I,P）均能正常访问并返回的情况</p><p>上图为请求服务I出现问题时，一个用户请求被阻塞的情况</p><p>上图为大量用户请求服务I出现异常全部陷入阻塞的情况，即发生服务血崩的情况</p><p>举个例子，一个依赖30个微服务的系统，每个服务99 99%可用。则整个系统的可用性为99.99%的30次方，约为99.7%。为什么是30次方呢?若系统依赖于2个微服务，个微服务的可用率为99.99%，那么，两个微服务的组合的可用率为99.99%* 99.99%，同理，30个微服务，每个微服务的可用率为99.99%，则这30个微服务组合后的可用性为99.99%的30次方。</p><p>也就是说，整个系统会存在0.3%的失败率。若存在一亿次请求，那么将会有30万次失败。随着随着服务依赖数量的增多，服务不稳定的概率会成指数性升高。</p><p><strong>熔断机制</strong></p><p>熔断机制是服务雪崩的一种有效解决方案。当服务消费者所请求的提供者暂不能提供服务时，消费者会被阻塞，且长时间占用请求链路。为I防止这种情况的发生，当在设定阈值时限到达时仍未获得提供者的服务，则系统将通过断路器直接将此请求链路断开。这种像熔断“保险丝”一样的解决方案称为熔断机制。</p><h3 id="hystrix简介"><a class="markdownIt-Anchor" href="#hystrix简介"></a> Hystrix简介</h3><p><a href="https://github.com/netflix/hystrix">官网：https://github.com/netflix/hystrix</a></p><p>在分布式环境中，其所依赖的一些服务出现失败是不可避免的。Hystrix是一一个通过添加容延逻辑与容错逻辑来控制这些分布式服务间相互影响的库。Hystrix通过隔离服务间的访问点、停止服务间的级联失败，及提供回退选项，来提升系统的整体弹性。</p><p><strong>综合说明</strong></p><p>在一个分布式系统里,许多服务不可避免的会出现调用失败的情况，比如超时、异常等。如何能够保证在一个服务出问题的情况下，不会导致整个系统瘫痪，这个就是Hystrix需要做的事情。Hystrix提供了熔断、隔离、Fallback、cache、 监控等功能，能够在-一个或多个服务同时出现问题时保证系统依然可用。</p><p>Hystrix是种开关装置， 类似于熔断保险丝。当Hystrix 监控到某个服务发生故障后，其不会让该服务的消费者阻塞，或向消费者抛出异常，而是向消费者返回一个符合预期的、可处理的备选响应（FallBack）,这样就避免了服务雪崩的发生</p><h3 id="服务降级简介"><a class="markdownIt-Anchor" href="#服务降级简介"></a> 服务降级简介</h3><p>在访问分布式系统中，经常会发生以下两种情况:</p><ul><li>当整个微服务架构整体的负载超出了预设的上限阈值，或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，我们可以将一些不重要或不紧急的服务进行延迟使用或暂停使用。这就是服务熔断，类似于主动拉电闸的服务熔断。此时，若有消费者消费这些延迟/暂停使用的服务则会出现阻塞，等待提供者的响应</li><li>当消费者访问某微服务时，由于网络或其它原因，提供者向消费者响应过慢，出现服务超时或根本就没有响应时，这也是一种服务熔断，类似于保险丝自动熔断的服务熔断。此时消费者会被迫阻塞，等待提供者的响应。</li></ul><p>在发生服务熔断时，不仅用户体验很差，其还占用了大量的系统资源。为了解决这个问题，在编写消费者端代码时就设置了预案:在消费者端给出一种默认的、临时的处理方案，能够给出消费者一个可以接受的结果。即，对于用户(指的是人，并非指消费者端)来说，其所消费的服务并非由应当提供服务的提供者端给出，而是由服务消费者临时给出，服务质量降级了。这就是“服务降级”，提供者端的&quot;服务熔断&quot;与消费者端的&quot;本地服务&quot;共同构成了&quot;服务降级&quot;</p><p><strong>简单来说服务降级指的是</strong>：当服务的提供者无法正常提供服务时，为了增加用户体验，保证整个系统能够正常运行，由服务消费者端调用本地操作，暂时给出用户响应结果的情况.</p><h3 id="hystrix服务降级方法级别"><a class="markdownIt-Anchor" href="#hystrix服务降级方法级别"></a> Hystrix服务降级（方法级别）</h3><p><strong>服务降级是针对消费者端的，和提供者没有任何关系</strong></p><p>无论消费者是通过RestTemplate消费微服务的，还是通过Feign接口消费微服务的，使用Hystrix的方法都一样，Hystrix与Feign之间并没有依赖关系</p><ul><li>添加hystrix依赖</li><li>修改处理器，在<strong>处理器方法</strong>上添加@HystrixCommand注解，并添加相应的Hystrix处理方法</li><li>在启动类上添加@EnableCircuitBreaker注解</li></ul><p><strong>pom依赖</strong></p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="comment">&lt;!--Eureka客户端依赖--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!--添加actuator依赖--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!--添加OpenFeign依赖--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!--hystrix依赖--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p><strong>处理器方法：</strong></p><ul><li>断路打开后，可用避免连锁故障，fallback方法可以直接返回一个固定值</li><li>方法上加上@HystrixCommand注解。该注解对该方法创建了熔断器的功能，并指定了fallbackMethod熔断方法</li><li>这就说明当服务提供者工程不可用的时候，消费者调用服务提供者的API接口时，会执行快速失败，直接返回一组字符串，而不是等待响应超时，这很好的控制了容器的线程阻塞</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer.Controller;<span class="keyword">import</span> com.lee.consumer.bean.Depart;<span class="keyword">import</span> com.lee.consumer.service.DepartService;<span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.web.bind.annotation.*;<span class="keyword">import</span> org.springframework.web.client.RestTemplate;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * 使用openFeign后，不用再使用RestTemplate，编程风格和以前一样了</span><span class="comment"> */</span><span class="meta">@RestController</span><span class="meta">@RequestMapping(&quot;/consumer/depart&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartController</span> &#123;    <span class="meta">@Autowired</span>    <span class="comment">//这里不再注入RestTemplate，注入service接口</span>    <span class="keyword">private</span> DepartService service;    <span class="meta">@PostMapping(&quot;/save&quot;)</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveHandle</span><span class="params">(Depart depart)</span> &#123;        <span class="keyword">return</span> service.saveDepart(depart);    &#125;    <span class="meta">@DeleteMapping(&quot;/del/&#123;id&#125;&quot;)</span>    <span class="comment">//@PathVariable 表示获取url中的&#123;id&#125;的值</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteHandle</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;        <span class="keyword">return</span> service.removeDepartById(id);    &#125;    <span class="meta">@PutMapping(&quot;/update&quot;)</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateHandle</span><span class="params">(Depart depart)</span> &#123;        <span class="keyword">return</span> service.modifyDepart(depart);    &#125;    <span class="comment">//方法级别的服务降级</span>    <span class="meta">@HystrixCommand(fallbackMethod = &quot;getHystrixHandle&quot;)</span>    <span class="meta">@GetMapping(&quot;/get/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> Depart <span class="title function_">GetHandle</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">Depart</span> <span class="variable">depart</span> <span class="operator">=</span>  service.getDepartById(id);        <span class="comment">//如果是服务端产生的异常则由类级别进行服务降级</span>        <span class="comment">//在这个方法中抛出的异常由方法级别进行服务降级</span>        <span class="comment">//模拟服务端调用延时，测试服务降级</span>        Thread.sleep(<span class="number">5100</span>);        <span class="keyword">return</span> depart;    &#125;    <span class="meta">@GetMapping(&quot;/list&quot;)</span>    <span class="keyword">public</span> List&lt;Depart&gt; <span class="title function_">listHandle</span><span class="params">()</span> &#123;        <span class="keyword">return</span> service.listAllDeparts();    &#125;    <span class="comment">//当@HystrixCommand标注的方法不能正常访问时调用此方法</span>    <span class="keyword">public</span> Depart <span class="title function_">getHystrixHandle</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span>&#123;        <span class="type">Depart</span> <span class="variable">depart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Depart</span>();        depart.setId(id);        depart.setName(<span class="string">&quot;no this depart&quot;</span>);        depart.setDbase(<span class="string">&quot;no this db&quot;</span>);        System.out.println(<span class="string">&quot;方法降级++++&quot;</span>);        <span class="keyword">return</span> depart;    &#125;&#125;</code></pre><p><strong>修改启动类：</strong></p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer;<span class="keyword">import</span> com.netflix.loadbalancer.IRule;<span class="keyword">import</span> com.netflix.loadbalancer.RandomRule;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;<span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;<span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;<span class="keyword">import</span> org.springframework.context.annotation.Bean;<span class="keyword">import</span> rule.CustomRule;<span class="keyword">import</span> java.util.ArrayList;<span class="keyword">import</span> java.util.List;<span class="comment">//开启服务降级</span><span class="meta">@EnableCircuitBreaker</span><span class="comment">//开启feign客户端，指定service接口所在包</span><span class="meta">@EnableFeignClients(basePackages = &quot;com.lee.consumer.service&quot;)</span><span class="meta">@SpringBootApplication</span><span class="meta">@EnableEurekaClient</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(ConsumerApplication.class, args);    &#125;&#125;</code></pre><h3 id="hystrix-feign服务降级类级别"><a class="markdownIt-Anchor" href="#hystrix-feign服务降级类级别"></a> Hystrix-Feign服务降级（类级别）</h3><p>前面所讲的HystrixCommon的fallbackMethod就是一种服务降级的方式，而这里我们要讲的是使用Feign对Hystrix的支持功能所实现的两一种服务降级的方式。</p><ul><li>在Feign接口所在包下定义降级处理类</li><li>在Feign接口中指定要使用的降级处理类</li><li>在配置文件中开启Feign对Hystrix的支持</li></ul><p><strong>Controller</strong></p><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer.Controller;<span class="keyword">import</span> com.lee.consumer.bean.Depart;<span class="keyword">import</span> com.lee.consumer.service.DepartService;<span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.web.bind.annotation.*;<span class="keyword">import</span> org.springframework.web.client.RestTemplate;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * 使用openFeign后，不用再使用RestTemplate，编程风格和以前一样了</span><span class="comment"> */</span><span class="meta">@RestController</span><span class="meta">@RequestMapping(&quot;/consumer/depart&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartController</span> &#123;    <span class="meta">@Autowired</span>    <span class="comment">//这里不再注入RestTemplate，注入service接口</span>    <span class="keyword">private</span> DepartService service;    <span class="meta">@PostMapping(&quot;/save&quot;)</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveHandle</span><span class="params">(Depart depart)</span> &#123;        <span class="keyword">return</span> service.saveDepart(depart);    &#125;    <span class="meta">@DeleteMapping(&quot;/del/&#123;id&#125;&quot;)</span>    <span class="comment">//@PathVariable 表示获取url中的&#123;id&#125;的值</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteHandle</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;        <span class="keyword">return</span> service.removeDepartById(id);    &#125;    <span class="meta">@PutMapping(&quot;/update&quot;)</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateHandle</span><span class="params">(Depart depart)</span> &#123;        <span class="keyword">return</span> service.modifyDepart(depart);    &#125;    <span class="comment">//方法级别的服务降级</span>    <span class="meta">@HystrixCommand(fallbackMethod = &quot;getHystrixHandle&quot;)</span>    <span class="meta">@GetMapping(&quot;/get/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> Depart <span class="title function_">GetHandle</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">Depart</span> <span class="variable">depart</span> <span class="operator">=</span>  service.getDepartById(id);        <span class="comment">//如果是服务端产生的异常则由类级别进行服务降级</span>        <span class="comment">//在这个方法中抛出的异常由方法级别进行服务降级</span>        <span class="comment">//模拟服务端调用延时，测试服务降级</span>        Thread.sleep(<span class="number">5100</span>);        <span class="keyword">return</span> depart;    &#125;    <span class="meta">@GetMapping(&quot;/list&quot;)</span>    <span class="keyword">public</span> List&lt;Depart&gt; <span class="title function_">listHandle</span><span class="params">()</span> &#123;        <span class="keyword">return</span> service.listAllDeparts();    &#125;    <span class="comment">//当@HystrixCommand标注的方法不能正常访问时调用此方法</span>    <span class="keyword">public</span> Depart <span class="title function_">getHystrixHandle</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span>&#123;        <span class="type">Depart</span> <span class="variable">depart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Depart</span>();        depart.setId(id);        depart.setName(<span class="string">&quot;no this depart&quot;</span>);        depart.setDbase(<span class="string">&quot;no this db&quot;</span>);        System.out.println(<span class="string">&quot;方法降级++++&quot;</span>);        <span class="keyword">return</span> depart;    &#125;&#125;</code></pre><p><strong>定义降级处理类</strong></p><ul><li>降级处理类需要实现FallbackFactory接口，该接口的泛型为Feign接口，该类可以定义在任意包下，不过，一般会与Feign接口定义在同一包下，本例在DepartService接口所在包中定义降级处理类DepartFallbackFactory</li><li>该类需要使用@Component注解，表示要将其交给Spring容器来管理</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer.service;<span class="keyword">import</span> com.lee.consumer.bean.Depart;<span class="keyword">import</span> feign.hystrix.FallbackFactory;<span class="keyword">import</span> org.springframework.stereotype.Component;<span class="keyword">import</span> java.util.List;<span class="comment">//服务降级处理类</span><span class="comment">//FallbackFactory&lt;&gt;的泛型是Feign的Service接口</span><span class="meta">@Component</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartFallbackFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;DepartService&gt; &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> DepartService <span class="title function_">create</span><span class="params">(Throwable throwable)</span> &#123;        <span class="comment">//返回一个DeparteService()接口的对象</span>        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DepartService</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveDepart</span><span class="params">(Depart depart)</span> &#123;                System.out.println(<span class="string">&quot;服务降级++++++saveDepart+++++++++&quot;</span>);                <span class="keyword">return</span> <span class="literal">false</span>;            &#125;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeDepartById</span><span class="params">(<span class="type">int</span> id)</span> &#123;                System.out.println(<span class="string">&quot;服务降级++++++removeDepartById+++++++++&quot;</span>);                <span class="keyword">return</span> <span class="literal">false</span>;            &#125;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">modifyDepart</span><span class="params">(Depart depart)</span> &#123;                System.out.println(<span class="string">&quot;服务降级++++++modifyDepart+++++++++&quot;</span>);                <span class="keyword">return</span> <span class="literal">false</span>;            &#125;            <span class="meta">@Override</span>            <span class="keyword">public</span> Depart <span class="title function_">getDepartById</span><span class="params">(<span class="type">int</span> id)</span> &#123;                System.out.println(<span class="string">&quot;服务降级++++++getDepartById+++++++++&quot;</span>);                <span class="type">Depart</span> <span class="variable">depart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Depart</span>();                depart.setId(id);                depart.setName(<span class="string">&quot;no this depart&quot;</span>);                depart.setDbase(<span class="string">&quot;no this db&quot;</span>);                <span class="keyword">return</span> depart;            &#125;            <span class="meta">@Override</span>            <span class="keyword">public</span> List&lt;Depart&gt; <span class="title function_">listAllDeparts</span><span class="params">()</span> &#123;                System.out.println(<span class="string">&quot;服务降级++++++listAllDeparts+++++++++&quot;</span>);                <span class="keyword">return</span> <span class="literal">null</span>;            &#125;        &#125;;    &#125;&#125;</code></pre><p><strong>在Feign接口指定服务降级类</strong></p><ul><li>@FeignClient的fallbackFactory属性指定服务降级类</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.consumer.service;<span class="keyword">import</span> com.lee.consumer.bean.Depart;<span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;<span class="keyword">import</span> org.springframework.stereotype.Service;<span class="keyword">import</span> org.springframework.web.bind.annotation.*;<span class="keyword">import</span> java.util.List;<span class="comment">//指定当前service所绑定的提供者微服务的名称,指定服务降级处理类</span><span class="meta">@FeignClient(value=&quot;leemsc-provider-depart&quot;,fallbackFactory=DepartFallbackFactory.class)</span><span class="meta">@RequestMapping(&quot;/provider/depart&quot;)</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DepartService</span> &#123;    <span class="meta">@PostMapping(&quot;/save&quot;)</span>    <span class="type">boolean</span> <span class="title function_">saveDepart</span><span class="params">(Depart depart)</span>;    <span class="meta">@DeleteMapping(&quot;/del/&#123;id&#125;&quot;)</span>    <span class="type">boolean</span> <span class="title function_">removeDepartById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>  <span class="type">int</span> id)</span>;    <span class="meta">@PutMapping(&quot;/update&quot;)</span>    <span class="type">boolean</span> <span class="title function_">modifyDepart</span><span class="params">(Depart depart)</span>;    <span class="meta">@GetMapping(&quot;/get/&#123;id&#125;&quot;)</span>    Depart <span class="title function_">getDepartById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span>;    <span class="meta">@GetMapping(&quot;/list&quot;)</span>    List&lt;Depart&gt; <span class="title function_">listAllDeparts</span><span class="params">()</span>;&#125;</code></pre><p><strong>修改主配置文件</strong></p><pre><code class="highlight properties"><span class="comment">#指定端口号</span><span class="attr">server.port</span>=<span class="string">8080</span><span class="comment"></span><span class="comment">#指定微服务对外暴露的名称</span><span class="attr">spring.application.name</span>=<span class="string">leemsc-consumer-depart</span><span class="comment"></span><span class="comment">#指定Eureka服务注册中心</span><span class="attr">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:8000/eureka</span><span class="comment"></span><span class="comment">#开启Feign对Hystrix的支持</span><span class="attr">feign.hystrix.enabled</span>=<span class="string">true</span><span class="comment">#设置服务熔断时限，默认为5000毫秒（即等待响应的时间）</span><span class="attr">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</span>=<span class="string">5000</span></code></pre><p><strong>运行：</strong></p><p>由于改代码中同时出现了两种降级方式</p><ul><li>所以运行时如果只是服务端出现了问题，那么返回的是fallbackFactory的响应结果，fallbackMethod则未执行</li><li>如果运行时服务端调用没问题，消费者处理器执行过程中有异常，则fallbackFactory不执行，fallbackMethod执行</li><li>如果运行时服务端出现了问题，消费者处理器执行过程中也有异常，则两个都执行</li></ul><h3 id="两种降级同时使用"><a class="markdownIt-Anchor" href="#两种降级同时使用"></a> 两种降级同时使用</h3><p>一般情况下这两种方式同时使用，fallbackMethod方式用于解决处理器执行过程中的异常问题，而服务降级类方式用于解决未获取到服务问题</p><h2 id="网关服务zuul"><a class="markdownIt-Anchor" href="#网关服务zuul"></a> 网关服务zuul</h2><p>zuul时从设备和web站点到Netflix流应用后端的所有请求的前门，作为边界服务应用，zuul实现类动态路由，监视，弹性和安全性而构建的，它还具有根据情况将请求路由到多个Amazon Auto Scaling Groups的能力</p><h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3><p>Zuul主要提供了对请求的路由与过滤功能。路由功能主要指，将外部请求转发到具体的微服务实例上，是外部访问微服务的统一入口。 过滤功能主要指，对请求的处理过程进行干预，对请求进行校验、服务聚合等处理。</p><p>Zuul与Eureka进行整合,将Zuul自身注册为Eureka服务治理下的应用，从Eureka Server中获取到其它微服务信息，使外部对于微服务的访问都是通过Zuul进行转发的。</p><p>那么，具体怎么使用呢?服务提供者是消费者通过EurekaServer进行访问的，即相当于EurekaSenver是服务提供者的统一入口。那么服务消费者很多，用户怎样访问这些消费者工程呢?当然可以像之前那样直接访问这些工程。但这种方式没有统一的消费者工程调用入口，不便于访问与管理，而Zuul就是这样的一个对于消费者的统一入口。这点，从Spring官网<a href="http://spring.xn--io-uv2c6e61b4sr2mpsekzi208b75a679g0xhu73j">http://spring.io最下面的图中可以体现出来</a>。</p><h3 id="基本用法"><a class="markdownIt-Anchor" href="#基本用法"></a> 基本用法</h3><p><strong>创建一个springboot工程</strong><br />创建一个Spring boot工程</p><p>项目名称：</p><p>添加依赖：</p><p><strong>pom依赖</strong></p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zuulserver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>zuulserver<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR3<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p><strong>主配置文件</strong></p><pre><code class="highlight properties"><span class="attr">server.port</span>=<span class="string">9000</span><span class="comment">#设置服务注册中心</span><span class="attr">eureka.client.service-url.defaultZone</span>:<span class="string">http://localhost:8000/eureka</span><span class="comment"></span><span class="comment">#设置spring应用名</span><span class="attr">spring.application.name</span>=<span class="string">leemsc-zuul-depart</span></code></pre><p><strong>启动类</strong></p><ul><li>启动类使用@EnableZuulProxy开启zuul代理模式</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.zuulserver;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cloud.netflix.zuul.EnableZuulProxy;<span class="comment">//开启zuul代理模式</span><span class="meta">@EnableZuulProxy</span><span class="meta">@SpringBootApplication</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZuulserverApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(ZuulserverApplication.class, args);    &#125;&#125;</code></pre><p><strong>访问测试</strong></p><ul><li>通过zuul来访问consumer</li></ul><pre><code class="highlight plaintext">http://localhost:9000/leemsc-consumer-depart/consumer/depart/get/2</code></pre><h3 id="路由访问映射规则"><a class="markdownIt-Anchor" href="#路由访问映射规则"></a> 路由访问映射规则</h3><p><strong>修改主配置文件</strong></p><ul><li>leedepart可以随意命名，但service-id与path是关键字，不能更改</li><li>leedepart.service-id指定要被替换掉的微服务名称</li><li>leedepart.path指定用于替换指定微服务名称的路径</li></ul><pre><code class="highlight properties"><span class="attr">server.port</span>=<span class="string">9000</span><span class="comment">#设置服务注册中心</span><span class="attr">eureka.client.service-url.defaultZone</span>:<span class="string">http://localhost:8000/eureka</span><span class="comment"></span><span class="comment">#设置spring应用名</span><span class="attr">spring.application.name</span>=<span class="string">leemsc-zuul-depart</span><span class="comment"></span><span class="comment">#设置zuul路由规则</span><span class="comment">#设置要被替换的微服务名称</span><span class="attr">zuul.routes.leedepart.service-id</span>=<span class="string">leemsc-consumer-depart</span><span class="comment">#指定替换使用的路径</span><span class="attr">zuul.routes.leedepart.path</span>=<span class="string">/condep/**</span></code></pre><p><strong>测试</strong></p><ul><li>访问路径修改成了替换的名字，可以隐藏真正的consumer名</li></ul><h3 id="忽略服务名称"><a class="markdownIt-Anchor" href="#忽略服务名称"></a> 忽略服务名称</h3><p>以上配置虽然可以使用映射路径访问微服务，但通过原来的服务名称仍然可以访问到微服务，即以上的配置并没有隐藏和保护原来的微服务名称，可以在配置文件中设置忽略微服务属性，禁掉原来所有的微服务名称使用，有两种设置方式，忽略指定微服务，与忽略所有微服务</p><p><strong>忽略指定微服务名称</strong></p><ul><li>在配置文件中指定要忽略的微服务</li></ul><pre><code class="highlight properties"><span class="attr">server.port</span>=<span class="string">9000</span><span class="comment">#设置服务注册中心</span><span class="attr">eureka.client.service-url.defaultZone</span>:<span class="string">http://localhost:8000/eureka</span><span class="comment"></span><span class="comment">#设置spring应用名</span><span class="attr">spring.application.name</span>=<span class="string">leemsc-zuul-depart</span><span class="comment"></span><span class="comment">#设置zuul路由规则</span><span class="comment">#设置要被替换的微服务名称</span><span class="attr">zuul.routes.leedepart.service-id</span>=<span class="string">leemsc-consumer-depart</span><span class="comment">#指定替换使用的路径</span><span class="attr">zuul.routes.leedepart.path</span>=<span class="string">/condep/**</span><span class="comment"></span><span class="comment">#指定要忽略的微服务(即通过此名称无法访问，只可以使用替换的路径)</span><span class="attr">zuul.ignored-services</span>=<span class="string">leemsc-consumer-depart</span></code></pre><blockquote><p>此时再通过微服务名称已经无法访问到微服务了，但通过映射路径是可以访问到的</p></blockquote><p><strong>忽略所有微服务名称</strong></p><ul><li>指定所有的微服务名称都无法访问，只能通过替换的名称</li></ul><pre><code class="highlight properties"><span class="comment">#指定所有的微服务名称都无法访问，只能通过替换的名称</span><span class="attr">zuul.ignored-services</span>=<span class="string">*</span></code></pre><p><strong>测试访问</strong><br />通过别名可以访问：</p><p>通过微服务全称无法访问：</p><h3 id="为映射路径配置统一前缀"><a class="markdownIt-Anchor" href="#为映射路径配置统一前缀"></a> 为映射路径配置统一前缀</h3><p>一般情况下我们会在映射路径前添加一个前缀用于表示模块信息或公司名称等，而前缀对于各个微服务来说一般都是需要的，我们可以为映射路径统一配置前缀</p><p><strong>修改主配置文件</strong></p><pre><code class="highlight properties"><span class="attr">server.port</span>=<span class="string">9000</span><span class="comment">#设置服务注册中心</span><span class="attr">eureka.client.service-url.defaultZone</span>:<span class="string">http://localhost:8000/eureka</span><span class="comment"></span><span class="comment">#设置spring应用名</span><span class="attr">spring.application.name</span>=<span class="string">leemsc-zuul-depart</span><span class="comment"></span><span class="comment">#设置zuul路由规则</span><span class="comment">#设置要被替换的微服务名称</span><span class="attr">zuul.routes.leedepart.service-id</span>=<span class="string">leemsc-consumer-depart</span><span class="comment">#指定替换使用的路径</span><span class="attr">zuul.routes.leedepart.path</span>=<span class="string">/condep/**</span><span class="comment"></span><span class="comment">#指定要忽略的微服务(即通过此名称无法访问，只可以使用替换的路径)</span><span class="comment">#zuul.ignored-services=leemsc-consumer-depart</span><span class="comment"></span><span class="comment">#指定所有的微服务名称都无法访问，只能通过替换的名称</span><span class="attr">zuul.ignored-services</span>=<span class="string">*</span><span class="comment"></span><span class="comment">#指定访问的统一前缀</span><span class="attr">zuul.prefix</span>=<span class="string">/depart</span></code></pre><p><strong>测试访问</strong></p><h2 id="spring-cloud-config分布式配置中心"><a class="markdownIt-Anchor" href="#spring-cloud-config分布式配置中心"></a> Spring Cloud Config分布式配置中心</h2><p>SpringCloudConfig的原理是,我们首先需要将各个微服务公共的配置信息推送到GitHub远程版本库。然后我们再定义一个Spring Cloud Config Server,其会连接上这个GitHub远程库。这样我们就可以定义Config版的Eureka Server、 提供者与消费者了。这些都将作为SpringCloudConfig Client出现，它们都会通过连接Spring Cloud Config server连接上GitHub上的远程库，以读取到指定配置文件中的内容。</p><h3 id="github远程库设置"><a class="markdownIt-Anchor" href="#github远程库设置"></a> github远程库设置</h3><h4 id="前提准备"><a class="markdownIt-Anchor" href="#前提准备"></a> 前提准备</h4><p><strong>非对称加密原理</strong></p><p><strong>设置github免密登录</strong><br />使用gitBash输入命令生成私/公钥</p><pre><code class="highlight plaintext">ssh-keygen</code></pre><p>然后再<code>C:\Users\leeboer\.ssh</code>文件夹找到公钥，打开，复制里面的内容放到github上</p><p><strong>建立远程库</strong></p><p><strong>clone远程库到本地</strong></p><pre><code class="highlight plaintext">git clone https://github.com/leeboer/SpringConfigTest.git</code></pre><h4 id="创建本地配置文件并推送到远程库"><a class="markdownIt-Anchor" href="#创建本地配置文件并推送到远程库"></a> 创建本地配置文件并推送到远程库</h4><blockquote><p><strong>spring cloud config工程必须使用yml文件，使用其他配置文件在git无法读取</strong></p></blockquote><p><strong>创建本地配置文件</strong></p><p>我们需要定义并推送三个配置文件，这三个配置文件分别是为了后续EurekaServer，provider，与consumer使用的</p><p>多环境测试文件：application.yml</p><ul><li>yml多配置之间要使用 “—” 分割</li></ul><pre><code class="highlight yml"><span class="attr">spring:</span>  <span class="attr">profiles:</span>    <span class="attr">active:</span> <span class="string">dev</span><span class="meta">---</span><span class="comment">#dev配置</span><span class="attr">spring:</span>  <span class="attr">application:</span>    <span class="attr">name:</span> <span class="string">leemsc-config-dev</span>  <span class="attr">profiles:</span>    <span class="attr">active:</span> <span class="string">dev</span><span class="meta">---</span><span class="comment">#test配置</span><span class="attr">spring:</span>  <span class="attr">application:</span>    <span class="attr">name:</span> <span class="string">leemsc-config-test</span>  <span class="attr">profiles:</span>    <span class="attr">active:</span> <span class="string">test</span></code></pre><p>application-consumer-config.properties</p><pre><code class="highlight properties"><span class="comment">#配置dev环境</span><span class="attr">server</span>:<span class="string"></span>  <span class="attr">port</span>: <span class="string">7070</span><span class="attr">spring</span>:<span class="string"></span>  <span class="attr">application</span>:<span class="string"></span>    <span class="attr">name</span>: <span class="string">leemsc-consumer-depart</span>  <span class="attr">profiles</span>: <span class="string">dev</span><span class="attr">eureka</span>:<span class="string"></span>  <span class="attr">client</span>:<span class="string"></span>    <span class="attr">service-url</span>:<span class="string"></span>      <span class="attr">defaultZone</span>: <span class="string">http://localhost:8100/eureka</span><span class="attr">feign</span>:<span class="string"></span>  <span class="attr">hystrix</span>:<span class="string"></span>    <span class="attr">enabled</span>: <span class="string">true</span><span class="attr">hystrix</span>:<span class="string"></span>  <span class="attr">command</span>:<span class="string"></span>    <span class="attr">default</span>:<span class="string"></span>      <span class="attr">execution</span>:<span class="string"></span>        <span class="attr">isolation</span>:<span class="string"></span>          <span class="attr">thread</span>:<span class="string"></span>            <span class="attr">timeoutInMilliseconds</span>: <span class="string">5000</span><span class="attr">---</span><span class="comment">#配置test环境</span><span class="attr">server</span>:<span class="string"></span>  <span class="attr">port</span>: <span class="string">9090</span><span class="attr">spring</span>:<span class="string"></span>  <span class="attr">application</span>:<span class="string"></span>    <span class="attr">name</span>: <span class="string">leemsc-consumer-depart</span>  <span class="attr">profiles</span>: <span class="string">test</span><span class="attr">eureka</span>:<span class="string"></span>  <span class="attr">client</span>:<span class="string"></span>    <span class="attr">service-url</span>:<span class="string"></span>      <span class="attr">defaultZone</span>: <span class="string">http://localhost:8200/eureka</span><span class="attr">feign</span>:<span class="string"></span>  <span class="attr">hystrix</span>:<span class="string"></span>    <span class="attr">enabled</span>: <span class="string">true</span><span class="attr">hystrix</span>:<span class="string"></span>  <span class="attr">command</span>:<span class="string"></span>    <span class="attr">default</span>:<span class="string"></span>      <span class="attr">execution</span>:<span class="string"></span>        <span class="attr">isolation</span>:<span class="string"></span>          <span class="attr">thread</span>:<span class="string"></span>            <span class="attr">timeoutInMilliseconds</span>: <span class="string">5000</span></code></pre><p>application-provider-config.properties</p><pre><code class="highlight properties"><span class="comment">#dev环境</span><span class="attr">server</span>:<span class="string"></span>  <span class="attr">port</span>: <span class="string">8082</span><span class="attr">spring</span>:<span class="string"></span>  <span class="attr">profiles</span>: <span class="string">dev</span>  <span class="attr">application</span>:<span class="string"></span>    <span class="attr">name</span>: <span class="string">leemsc-provider-depart</span>  <span class="attr">datasource</span>:<span class="string"></span>    <span class="attr">driver-class-name</span>: <span class="string">com.mysql.jdbc.Driver</span>    <span class="attr">password</span>: <span class="string">123456</span>    <span class="attr">type</span>: <span class="string">com.alibaba.druid.pool.DruidDataSource</span>    <span class="attr">url</span>: <span class="string">jdbc:mysql://127.0.0.1:3306/leetest01?characterEncoding=UTF-8</span>    <span class="attr">username</span>: <span class="string">root</span>  <span class="attr">jpa</span>:<span class="string"></span>    <span class="attr">generate-ddl</span>: <span class="string">true</span>    <span class="attr">hibernate</span>:<span class="string"></span>      <span class="attr">ddl-auto</span>: <span class="string">none</span>    <span class="attr">show-sql</span>: <span class="string">true</span><span class="attr">eureka</span>:<span class="string"></span>  <span class="attr">client</span>:<span class="string"></span>    <span class="attr">service-url</span>:<span class="string"></span>      <span class="attr">defaultZone</span>: <span class="string">http://localhost:8100/eureka</span><span class="attr">logging</span>:<span class="string"></span>  <span class="attr">level</span>:<span class="string"></span>    <span class="attr">com</span>:<span class="string"></span>      <span class="attr">lee</span>: <span class="string">debug</span>    <span class="attr">org</span>:<span class="string"></span>      <span class="attr">hibernate</span>: <span class="string">info</span>      <span class="attr">hibernate.type.descriptor.sql.BasicBinder</span>: <span class="string">trace</span>    <span class="attr">root</span>: <span class="string">info</span>  <span class="attr">pattern</span>:<span class="string"></span>    <span class="attr">console</span>: <span class="string">&#x27;%level %msg%n&#x27;</span><span class="attr">info</span>:<span class="string"></span>  <span class="attr">app</span>:<span class="string"></span>    <span class="attr">name</span>: <span class="string">leemsc-provider-depart</span>    <span class="attr">people</span>: <span class="string">leeboer</span>  <span class="attr">company</span>:<span class="string"></span>    <span class="attr">address</span>: <span class="string">xian</span>    <span class="attr">name</span>: <span class="string">leeboer.xyz</span>    <span class="attr">tel</span>: <span class="string">123456798</span><span class="attr">---</span><span class="comment">#test环境</span><span class="attr">server</span>:<span class="string"></span>  <span class="attr">port</span>: <span class="string">8083</span><span class="attr">spring</span>:<span class="string"></span>  <span class="attr">profiles</span>: <span class="string">test</span>  <span class="attr">application</span>:<span class="string"></span>    <span class="attr">name</span>: <span class="string">leemsc-provider-depart</span>  <span class="attr">datasource</span>:<span class="string"></span>    <span class="attr">driver-class-name</span>: <span class="string">com.mysql.jdbc.Driver</span>    <span class="attr">password</span>: <span class="string">123456</span>    <span class="attr">type</span>: <span class="string">com.alibaba.druid.pool.DruidDataSource</span>    <span class="attr">url</span>: <span class="string">jdbc:mysql://127.0.0.1:3306/leetest?characterEncoding=UTF-8</span>    <span class="attr">username</span>: <span class="string">root</span>  <span class="attr">jpa</span>:<span class="string"></span>    <span class="attr">generate-ddl</span>: <span class="string">true</span>    <span class="attr">hibernate</span>:<span class="string"></span>      <span class="attr">ddl-auto</span>: <span class="string">none</span>    <span class="attr">show-sql</span>: <span class="string">true</span><span class="attr">eureka</span>:<span class="string"></span>  <span class="attr">client</span>:<span class="string"></span>    <span class="attr">service-url</span>:<span class="string"></span>      <span class="attr">defaultZone</span>: <span class="string">http://localhost:8200/eureka</span><span class="attr">logging</span>:<span class="string"></span>  <span class="attr">level</span>:<span class="string"></span>    <span class="attr">com</span>:<span class="string"></span>      <span class="attr">lee</span>: <span class="string">debug</span>    <span class="attr">org</span>:<span class="string"></span>      <span class="attr">hibernate</span>: <span class="string">info</span>      <span class="attr">hibernate.type.descriptor.sql.BasicBinder</span>: <span class="string">trace</span>    <span class="attr">root</span>: <span class="string">info</span>  <span class="attr">pattern</span>:<span class="string"></span>    <span class="attr">console</span>: <span class="string">&#x27;%level %msg%n&#x27;</span><span class="attr">info</span>:<span class="string"></span>  <span class="attr">app</span>:<span class="string"></span>    <span class="attr">name</span>: <span class="string">leemsc-provider-depart</span>    <span class="attr">people</span>: <span class="string">leeboer</span>  <span class="attr">company</span>:<span class="string"></span>    <span class="attr">address</span>: <span class="string">xian</span>    <span class="attr">name</span>: <span class="string">leeboer.xyz</span>    <span class="attr">tel</span>: <span class="string">123456798</span></code></pre><p>application-eureka-config.properties</p><pre><code class="highlight yml"><span class="comment">#dev环境</span><span class="attr">spring:</span>  <span class="attr">application:</span>    <span class="attr">name:</span> <span class="string">leemsc-eurekaServer-config</span>  <span class="attr">profiles:</span> <span class="string">dev</span><span class="attr">server:</span>  <span class="attr">port:</span> <span class="number">8100</span><span class="attr">eureka:</span>  <span class="attr">instance:</span>    <span class="attr">hostname:</span> <span class="string">localhost</span> <span class="comment">#指定Eureka主机</span>  <span class="attr">client:</span>    <span class="attr">fetch-registry:</span> <span class="literal">false</span> <span class="comment">#指定当前主机是否需要获取注册信息</span>    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#指定当前主机是否需要向注册中心注册</span>    <span class="attr">service-url:</span>      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8100/eureka</span> <span class="comment">#暴露服务中心地址</span><span class="meta">---</span><span class="comment">#test测试环境</span><span class="attr">spring:</span>  <span class="attr">application:</span>    <span class="attr">name:</span> <span class="string">leemsc-eurekaServer-config</span>  <span class="attr">profiles:</span> <span class="string">test</span><span class="attr">server:</span>  <span class="attr">port:</span> <span class="number">8200</span><span class="attr">eureka:</span>  <span class="attr">instance:</span>    <span class="attr">hostname:</span> <span class="string">localhost</span>  <span class="attr">client:</span>    <span class="attr">fetch-registry:</span> <span class="literal">false</span>    <span class="attr">register-with-eureka:</span> <span class="literal">false</span>    <span class="attr">service-url:</span>      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8200/eureka</span></code></pre><p><strong>把本地配置文件推送到远程库</strong></p><pre><code class="highlight plaintext">$ git add *$ git commit -m &quot;first one&quot;$ git push</code></pre><h3 id="创建spring-cloud-config工程"><a class="markdownIt-Anchor" href="#创建spring-cloud-config工程"></a> 创建Spring Cloud Config工程</h3><p>该工程将存放当前项目中所有EurekaServer的配置文件，服务提供者，服务消费者等工程的配置文件公共服务</p><h4 id="环境搭建"><a class="markdownIt-Anchor" href="#环境搭建"></a> 环境搭建</h4><p><strong>创建spring boot工程</strong></p><p>定义一个基础的spring boot工程：</p><p>项目名：</p><p>添加config server依赖：</p><p><strong>pom依赖</strong></p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>configserver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>configserver<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR3<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p><strong>定义配置文件</strong></p><ul><li>指定当前工程所关联的git远程库地址</li></ul><pre><code class="highlight properties"><span class="attr">server.port</span>=<span class="string">9999</span><span class="comment"></span><span class="comment">#指定当前工程所关联的git远程库地址</span><span class="attr">spring.cloud.config.server.git.uri</span>=<span class="string">git@github.com:leeboer/SpringConfigTest.git</span></code></pre><p><strong>定义启动类</strong></p><ul><li>加上@EnableConfigServer注解</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.configserver;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cloud.config.server.EnableConfigServer;<span class="comment">//开启ConfigServer服务</span><span class="meta">@EnableConfigServer</span><span class="meta">@SpringBootApplication</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigserverApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(ConfigserverApplication.class, args);    &#125;&#125;</code></pre><h4 id="运行访问"><a class="markdownIt-Anchor" href="#运行访问"></a> 运行访问</h4><p>此时，Config Server服务器就已经定义完毕了，为了证明通过该服务器可以成功访问到Github的远程库的文件，现以之前上传到远程库中的多环境选择配置文件为例，查看多环境的切换</p><p><strong>1 完成多环境切换</strong></p><p>注意，下面的操作是通过读取远程库中的application.properties文件，并完成多环境的切换，并非简单的读取远程库文件</p><ul><li>A-切换到dev环境</li></ul><p>地址栏中输入的是可以完成多环境选择的application-dev.properties，并非是上传到远程库的application.properties，并会切换至配置文件中存在的dev环境，页面显示的dev环境信息及工共配置信息，并未显示test环境信息</p><ul><li>B-切换到test环境</li></ul><p>切换至配置文件的test环境，页面显示的是test的环境信息和工共配置信息，但并未显示dev的环境信息</p><ul><li>C-切换到不同存在的环境</li></ul><p>切换到不存在的环境，则页面显示公共配置信息，其他多环境信息不显示。</p><p><strong>2 切换到指定分支的指定环境</strong></p><p>切换到master分支的dev环境，默认即为master分支，即前面的切换都是切换到了默认master分支的多环境</p><p><strong>3 读取master分支上有关dev的配置信息</strong></p><h3 id="定义config版的eureka-server服务器"><a class="markdownIt-Anchor" href="#定义config版的eureka-server服务器"></a> 定义config版的Eureka Server服务器</h3><p>只需要三步：</p><ul><li>添加spring-cloud-starter-config依赖</li><li>删除旧的application.properties</li><li>添加bootstrap.yml文件</li></ul><p><strong>pom依赖</strong></p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>eurekaserver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>eurekaserver<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR3<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="comment">&lt;!--添加spring cloud config客户端依赖--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p><strong>定义bootstrap.yml</strong></p><p>下面的配置必须定义在bootstrap.yml文件中，若定义在application中，则Eureka无法启动（因为我们的配置文件是远程加载的，所以删掉原来的application）</p><p>bootstrapyml文件是在应用程序启动时加载的，而其中的配置一般也都是应用程序启动时所必须的数据。application.xml中配置 数据则是应用程序启动后在执行过程中要读取的数据。例如，本例的Eureka若要启动，则必须要在启动过程中读取到指定的GitHub中配置文件的数据，否则无法启动。所以，这些信息需要配置在bootstrap.yml中，若配置在applicationyml中，应用在启动时是读取不到的。</p><pre><code class="highlight yml"><span class="attr">spring:</span>  <span class="attr">cloud:</span>    <span class="attr">config:</span>      <span class="comment">#指定configServer的地址</span>      <span class="attr">uri:</span> <span class="string">http://localhost:9999</span>      <span class="comment">#指定要访问远程库的分支</span>      <span class="attr">label:</span> <span class="string">master</span>      <span class="comment">#指定要从远程库读取的配置文件名（无需加yml扩展名，因为只能使用yml文件）</span>      <span class="attr">name:</span> <span class="string">application-eureka-config</span>      <span class="comment">#选择环境</span>      <span class="attr">profile:</span> <span class="string">dev</span></code></pre><blockquote><p>由于当前主机要运行的真正自己需要的配置文件信息需要从远程库中读取，所以这里的application.yml文件就不再需要了，将其<strong>删除</strong></p></blockquote><p><strong>启动</strong></p><p>若配置文件修改了，则需要将修改的配置文件提交到远程库，然后还需要重启config server工程</p><p><strong>运行</strong></p><p>如果不指定读取的环境，则<u>默认读取的是dev</u></p><p>运行成功</p><blockquote><p>默认是dev，那么如何切换到test呢？其并不能像普通的spring boot工程那样，在运行jar文件时通过添加参数进行切换，因为环境配置信息均是从远程仓库拉取的，本地是没有要切换的环境信息的，而要获取这些信息，只能通过修改配置文件中的环境选择属性，然后将修改推送到远程库，重启Config Server，这样才能切换环境</p></blockquote><h3 id="定义config版的provider服务器"><a class="markdownIt-Anchor" href="#定义config版的provider服务器"></a> 定义config版的provider服务器</h3><p>只需要三步：</p><ul><li>添加spring-cloud-starter-config依赖</li></ul><pre><code class="highlight xml"><span class="comment">&lt;!--添加spring cloud config客户端依赖--&gt;</span>       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><ul><li>删除旧的application.properties</li><li>添加bootstrap.yml文件</li></ul><pre><code class="highlight yml"><span class="attr">spring:</span>  <span class="attr">cloud:</span>    <span class="attr">config:</span>      <span class="comment">#指定configServer的地址</span>      <span class="attr">uri:</span> <span class="string">http://localhost:9999</span>      <span class="comment">#指定要访问远程库的分支</span>      <span class="attr">label:</span> <span class="string">master</span>      <span class="comment">#指定要从远程库读取的配置文件名（无需加yml扩展名，因为只能使用yml文件）</span>      <span class="attr">name:</span> <span class="string">application-provider-config</span>      <span class="comment">#选择环境</span>      <span class="attr">profile:</span> <span class="string">dev</span></code></pre><h3 id="定义config版的consumer服务器"><a class="markdownIt-Anchor" href="#定义config版的consumer服务器"></a> 定义config版的consumer服务器</h3><p>只需要三步：</p><ul><li>添加spring-cloud-starter-config依赖</li></ul><pre><code class="highlight xml"><span class="comment">&lt;!--添加spring cloud config客户端依赖--&gt;</span>       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><ul><li>删除旧的application.properties</li><li>添加bootstrap.yml文件</li></ul><pre><code class="highlight yml"><span class="attr">spring:</span>  <span class="attr">cloud:</span>    <span class="attr">config:</span>      <span class="comment">#指定configServer的地址</span>      <span class="attr">uri:</span> <span class="string">http://localhost:9999</span>      <span class="comment">#指定要访问远程库的分支</span>      <span class="attr">label:</span> <span class="string">master</span>      <span class="comment">#指定要从远程库读取的配置文件名（无需加yml扩展名，因为只能使用yml文件）</span>      <span class="attr">name:</span> <span class="string">application-consumer-config</span>      <span class="comment">#选择环境</span>      <span class="attr">profile:</span> <span class="string">dev</span></code></pre>]]>
    </content>
    <id>http://example.com/2023/08/03/Spring-Cloud/</id>
    <link href="http://example.com/2023/08/03/Spring-Cloud/"/>
    <published>2023-08-03T11:00:00.000Z</published>
    <summary>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者提供了一套简单易懂、易部署和易维护的分布式系统开发工具包。</summary>
    <title>Spring Cloud</title>
    <updated>2026-02-27T01:26:26.632Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    <category term="String-Boot" scheme="http://example.com/tags/String-Boot/"/>
    <content>
      <![CDATA[<h1 id="spring-boot"><a class="markdownIt-Anchor" href="#spring-boot"></a> Spring Boot</h1><p>[toc]</p><h2 id="spring-boot基础"><a class="markdownIt-Anchor" href="#spring-boot基础"></a> Spring Boot基础</h2><p>SSM需要做大量的配置工作，其实很多配置行为本身只是手段，并不是目的。 基于这个考虑，把该简化的简化，该省略的省略，开发人员只用关心提供业务功能就行了，这就是 SpringBoot</p><p>Spring Boot是一个基于Spring的套件，它帮我们预组装了Spring的一系列组件，以便以尽可能少的代码和配置来开发基于Spring的Java应用程序。</p><p>以汽车为例，如果我们想组装一辆汽车，我们需要发动机、传动、轮胎、底盘、外壳、座椅、内饰等各种部件，然后把它们装配起来。Spring就相当于提供了一系列这样的部件，但是要装好汽车上路，还需要我们自己动手。而Spring Boot则相当于已经帮我们预装好了一辆可以上路的汽车，如果有特殊的要求，例如把发动机从普通款换成涡轮增压款，可以通过修改配置或编写少量代码完成。</p><p>因此，Spring Boot和Spring的关系就是整车和零部件的关系，它们不是取代关系，试图跳过Spring直接学习Spring Boot是不可能的。</p><p><strong>Spring Boot的目标就是提供一个开箱即用的应用程序架构，我们基于Spring Boot的预置结构继续开发，省时省力</strong>。</p><p>换言之，SpringBoot可以简单地看成<strong>简化</strong>了的、按照<strong>约定开发</strong>的SSM(H)</p><p>快速开发框架Spring Boot</p><h3 id="创建工程运行"><a class="markdownIt-Anchor" href="#创建工程运行"></a> 创建工程/运行</h3><h4 id="创建项目"><a class="markdownIt-Anchor" href="#创建项目"></a> 创建项目</h4><h5 id="官网创建"><a class="markdownIt-Anchor" href="#官网创建"></a> 官网创建</h5><p>可以使用网站去创建一个工程，解压后放到idea的工程目录，然后添加model</p><p><a href="start.spring.io">start.spring.io</a></p><p><strong>idea添加model</strong></p><blockquote><p>idea中删除Model需要删除两次，第一次是逻辑删除，第二次才是真正的物理文件的删除</p></blockquote><h5 id="idea创建-jar"><a class="markdownIt-Anchor" href="#idea创建-jar"></a> idea创建-jar</h5><p>Create New Project -&gt; Spring Initializr</p><p>填写对应的名称参数</p><p>创建一个基础的Web项目</p><p>指定项目路径 -&gt; Finish</p><p>创建好之后，会自带一个<code>SpringbootApplication</code>类，其被<code>@SpringBootApplication</code>所标记，表示这个是一个springboot应用</p><h5 id="idea创建-war"><a class="markdownIt-Anchor" href="#idea创建-war"></a> idea创建-war</h5><p>前面创建的Spring Boot工程最终被打为了Jar包，是以可执行文件的形式出现的，其使用了Spring Boot内嵌的Tomcat作为Web服务器来运行web应用的。新版Dubbo的监控中心工程就是典型的应用。但在实际生产环境下，对于Web工程，很多时候我们需要的是war包，然后部署到企业级Web服务器中。所以，下面我们来看一下如何使用Spring Boot将工程打为war包。</p><p><strong>创建一个基于war的spring boot工程</strong></p><p><strong>war工程解析</strong></p><p>war工程比jar工程多了一个<code>ServletInitializer</code>类</p><ul><li>在该工程中我们发现其自动增加了一个类ServletInitializer，该类重写了父类的configure()方法。该方法用于完成web环境的配置，即web环境的初始化工作。</li></ul><p>打开SpringBootServletInitializer类，查看其configure()方法的注释可知，该方法已经完成了所有应用程序配置的默认设置，用户只需要写代码即可。</p><blockquote><p>翻译如下：配置应用程序。通常情况下(Normally)，所有你需要做的仅仅是添加源码，因为其它配置已经具有了合理(sensible)</p></blockquote><p>由于这是一个war包工程，将来需要部署到服务器，即在打包时无需ServletAPI。然而在编译时是需要的，所以在工程的pom文件中专门添加了<scope>provided</scope>范围的<strong>ServletAPI依赖</strong>。</p><p><strong>打包</strong><br />运行Maven的package命令，将其打为war</p><p><strong>部署</strong><br />找到该war包，将其部署到Tomcat的webapps目录中，启动Tomcat。</p><p><strong>访问</strong><br />在浏览器中可以访问到该工程。注意，由于工程是部署到了Tomcat的webapps中，不是部署到webapps/ROOT中，所以在访问时需要指定工程名。</p><h4 id="helloworld"><a class="markdownIt-Anchor" href="#helloworld"></a> helloWorld</h4><p>新写的类必须在@SpringBootApplication标记类的包或子包下面，否则扫描不到</p><p><a href="http://xn--com-k82eq06crpj.leeboer.springboot.web">新建包com.leeboer.springboot.web</a>，然后在其下新建类<strong>HelloController</strong></p><p>这个类就是Spring MVC里的一个普通的<strong>控制器</strong></p><ul><li><code>@RestController</code>使spring4里的新注解，是 <code>@ResponseBody</code>和<code>@Controller</code>的缩写</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.web;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="comment">//这个注解使spring4中的新注解，使@Controller和@ResponseBody的缩写</span><span class="meta">@RestController</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Hello Spring Boot!&quot;</span>;    &#125;&#125;</code></pre><h4 id="测试运行"><a class="markdownIt-Anchor" href="#测试运行"></a> 测试运行</h4><p>运行SpringbootApplication.java</p><p>然后访问地址</p><pre><code class="highlight plaintext">http://127.0.0.1:8080/hello</code></pre><blockquote><p>为什么不用启动tomcat了呢？<br />这是因为com.leeboer.springboot.SpringbootApplication类的主方法就把tomcat嵌进去了，不需要手动启动tomcat了</p></blockquote><blockquote><p>使用spring boot构建一个web项目就是如此简单</p></blockquote><h3 id="部署"><a class="markdownIt-Anchor" href="#部署"></a> 部署</h3><p>spring boot和之前的web应用程序不一样，其本质是一个Java应用程序</p><p>通常来说，spring boot部署会采用两种方式，全部打包为jar，或者打包为一个war</p><h4 id="idea中打包"><a class="markdownIt-Anchor" href="#idea中打包"></a> idea中打包</h4><p>双击该按钮即可打包</p><p>打包存储的路径位置：（BUILD SUCCESS表示构建成功）</p><p>然后就可以直接在cmd命令中启动该工程：</p><pre><code class="highlight plaintext">java -jar D:\LeeGit\springbootdemo\target\springbootdemo-0.0.1-SNAPSHOT.jar</code></pre><p>启动成功：</p><h4 id="jar-方式"><a class="markdownIt-Anchor" href="#jar-方式"></a> jar 方式</h4><p><strong>打包</strong></p><pre><code class="highlight plaintext">cd D:\leeGit\springbootdemomvn install</code></pre><blockquote><p>这会导致在cd D:\leeGit\springbootdemo\target目录下生成一个jar文件</p></blockquote><blockquote><p>或者也可以使用idea进行打包，详情自行百度</p></blockquote><p><strong>运行</strong><br />输入命令：</p><pre><code class="highlight plaintext">java -jar target/springboot-0.0.1-SNAPSHOT.jar</code></pre><blockquote><p>就启动这个jar了</p></blockquote><blockquote><p>通过这个方式，把jar上传到服务器并运行，就可以达到部署效果了</p></blockquote><p><strong>保持linux运行</strong></p><pre><code class="highlight plaintext">nohup java -jar xxxx.jar &amp;</code></pre><h4 id="war-方式"><a class="markdownIt-Anchor" href="#war-方式"></a> war 方式</h4><p><strong>Application</strong><br />Application修改如下代码，新加：</p><p><code>@ServletComponentScan</code>注解，并且继承<code>SpringBootServletInitializer</code></p><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer;<span class="keyword">import</span> javafx.application.Application;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;<span class="keyword">import</span> org.springframework.boot.web.servlet.ServletComponentScan;<span class="keyword">import</span> org.springframework.boot.web.support.SpringBootServletInitializer;<span class="meta">@SpringBootApplication</span><span class="meta">@ServletComponentScan</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootdemoApplication</span> <span class="keyword">extends</span> <span class="title class_">SpringBootServletInitializer</span> &#123;<span class="meta">@Override</span><span class="keyword">protected</span> SpringApplicationBuilder <span class="title function_">configure</span><span class="params">(SpringApplicationBuilder application)</span> &#123;<span class="keyword">return</span> application.sources(SpringbootdemoApplication.class);&#125;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;SpringApplication.run(SpringbootdemoApplication.class, args);&#125;&#125;</code></pre><p><strong>pom.xml</strong><br />新增打包成war的声明：</p><pre><code class="highlight plaintext">&lt;packaging&gt;war&lt;/packaging&gt;</code></pre><p>spring-boot-starter-tomcat修改为 provided方式，以避免和独立 tomcat 容器的冲突.</p><blockquote><p>表示provided 只在编译和测试的时候使用，打包的时候就没它了</p></blockquote><pre><code class="highlight xml"><span class="comment">&lt;!--这个表示springboot的内置tomcat只在测试的时候用，打包部署的时候就没有它--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><p><strong>pom.xml</strong></p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span><span class="tag">&lt;<span class="name">parent</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.21.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span><span class="tag">&lt;/<span class="name">parent</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leeboer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springbootdemo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;<span class="name">name</span>&gt;</span>springbootdemo<span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span><span class="tag">&lt;<span class="name">properties</span>&gt;</span><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!--这个表示springboot的内置tomcat只在测试的时候用，打包部署的时候就没有它--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span><span class="tag">&lt;<span class="name">build</span>&gt;</span><span class="tag">&lt;<span class="name">plugins</span>&gt;</span><span class="tag">&lt;<span class="name">plugin</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span><span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p><strong>创建war包</strong></p><pre><code class="highlight plaintext">cd D:\leeGit\springbootdemomvn clean package</code></pre><blockquote><p>这样就在target目录下生成了一个<code>springboot-0.0.1-SNAPSHOT.war</code>文件</p></blockquote><p><strong>部署</strong></p><p>如果用 <code>springboot-0.0.1-SNAPSHOT.war</code> 这个文件名部署，那么访问的时候就要在路径上加上springboot-0.0.1-SNAPSHOT。 所以把这个文件重命名为 ROOT.war</p><blockquote><p>ROOT.war　并不是指访问的时候要使用 /ROOT/hello ,而是直接使用/hello 进行访问，ROOT表示根路径</p></blockquote><p>也可以命名为lee.war，访问就要改为localhost:8080/lee/hello</p><p>然后把它放进<strong>tomcat 的webapps</strong>目录下</p><p><strong>运行</strong><br />运行tomcat下bin目录的startup.bat，然后就可以启动了，访问：</p><pre><code class="highlight plaintext">http://127.0.0.1:8080/hello</code></pre><h3 id="工程结构详解"><a class="markdownIt-Anchor" href="#工程结构详解"></a> 工程结构详解</h3><h4 id="spring-boot-pomxml详解"><a class="markdownIt-Anchor" href="#spring-boot-pomxml详解"></a> spring boot pom.xml详解</h4><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springbootdemo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>springbootdemo<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><ul><li><p>这里的pom.xml文件中没有版本号是因为在<strong>父工程中进行了选择性继承</strong></p></li><li><p>我们打开父工程：</p></li><li><p>如果要更改spring的版本号，可以直接这样修改</p></li></ul><p><strong>springboot进行了二次打包</strong></p><ul><li><p>spring boot使用该插件，对maven package打的包进行了二次打包:</p></li><li><p>二次打包后才变成可执行文件，第一次打包的文件中并没有.MF文件</p></li><li><p>jar是在original的基础上进行的二次打包</p></li></ul><h4 id="manifestmf文件"><a class="markdownIt-Anchor" href="#manifestmf文件"></a> MANIFEST.MF文件</h4><p><strong>把启动jar文件用编辑器打开：可以找到MANIFEST.MF文件</strong></p><p>在Java编译的jar文件中，一定会有一个一个META-INF目录， 这个目录下会有一些文件，其中必有一个MANIFEST.MF</p><pre><code class="highlight bash">Manifest-Version: 1.0Implementation-Title: springbootdemoImplementation-Version: 0.0.1-SNAPSHOTStart-Class: com.lee.springbootdemo.SpringbootdemoApplication   <span class="comment">#我们的springboot启动类，入口类调用了该启动类</span>Spring-Boot-Classes: BOOT-INF/classes/Spring-Boot-Lib: BOOT-INF/lib/Build-Jdk-Spec: 1.8Spring-Boot-Version: 2.1.9.RELEASECreated-By: Maven Archiver 3.4.0Main-Class: org.springframework.boot.loader.JarLauncher      <span class="comment">#定义jar文件的入口类，该类必须是一个可执行的类，一旦定义了该属性即可通过 java -jar x.jar来运行该jar文件</span></code></pre><h3 id="热部署"><a class="markdownIt-Anchor" href="#热部署"></a> 热部署</h3><p>目前的spring boot，当发生了任何修改之后，必须关闭后再启动Application类才能够生效，显得略微麻烦，spring boot提供了热部署的方式，当发现任何类发生了改变，马上通过jvm类加载的方式，加载最新的类到虚拟机当中，这样就不需要重新启动也可以看到修改后的效果</p><h4 id="eclipse"><a class="markdownIt-Anchor" href="#eclipse"></a> eclipse</h4><p>依赖</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span> <span class="comment">&lt;!-- 这个需要为 true 热部署才有效 --&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><p>插件</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></code></pre><p><strong>重启测试</strong><br />重新启动application，然后随便修改一下任意代码，就会看到控制台自动重启</p><h4 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> idea</h4><p>ldea中的SpringBoot工程若要使用热部署，需要完成两个步骤。</p><ul><li><strong>导入devtools依赖</strong>，</li><li><strong>编辑当前工程的配置信息</strong>。</li></ul><p>这两个步骤是在每一个使用热部署的Spring Boot工程中均要设置的。</p><blockquote><p>需要注意，Spring Boot工程在ldea中的热部署与Eclipse中的热部署，工程修改后的重新启动时机是不同的。Eclipse中只要修改过的文件被保存了，则工程会马上重新部署。而ldea则不同，其对文件修改后的保存是自动的，所以其重新部署的时机是ldea整个IDE窗口被钝化时，即Windows 窗口切换到其它窗口时，工程会重新部署。</p></blockquote><p><strong>导入devtools依赖</strong></p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springbootdemo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>springbootdemo<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span>        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span><span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p><strong>编辑当前工程的配置信息</strong></p><blockquote><p>默认配置下，针对/static、/public和/templates目录中的文件修改，不会自动重启，因为禁用缓存后，这些文件的修改可以实时更新。</p></blockquote><h3 id="spring-boot主配置文件"><a class="markdownIt-Anchor" href="#spring-boot主配置文件"></a> Spring boot主配置文件</h3><p>Spring Boot的主配置文件也可使用application.yml文件。yml,也可写为yaml.</p><p>在开发之初YAML的本意是Yet Another Markup Language (仍是一种标记语言)。后来为了强调这种语言是以数据为中心，而不是以标记为中心，所以将YAML解释为Yami Ain’tMarkup Language (Yaml不是一种标记语言)。 它是一种直观的能够被电脑识别的数据序列化格式，是一个可读性高并且容易被人阅读，容易和脚本语言交互，用来表达多级资源序列的编程语言。</p><p><strong>yml与properties</strong>文件的主要区别是对于多级属性，即key的显示方式不同。yml文件在输入时，只需按照点(.)的方式输出key即可，输入完毕后回车即出现了如下形式。该形式要求冒号后与值之间要有一个空格。</p><pre><code class="highlight properties"><span class="comment">#配置端口号</span><span class="attr">server.port</span>=<span class="string">8080</span><span class="comment">#配置项目访问名称，上下文路径</span><span class="attr">server.servlet.context-path</span>=<span class="string">/leeboer</span></code></pre><hr /><h4 id="端口和上下文路径"><a class="markdownIt-Anchor" href="#端口和上下文路径"></a> 端口和上下文路径</h4><p>可以通过修改application.properties，修改访问的端口号和上下文路径</p><pre><code class="highlight properties"><span class="attr">spring.mvc.view.prefix</span>=<span class="string">/WEB-INF/jsp/</span><span class="attr">spring.mvc.view.suffix</span>=<span class="string">.jsp</span><span class="comment">#更改端口号</span><span class="attr">server.port</span>=<span class="string">8888</span><span class="comment">#更改上下文路径</span><span class="comment">#新版本spring boot使用server.servlet.context-path</span><span class="attr">server.context-path</span>=<span class="string">/test</span></code></pre><h4 id="yml配置文件"><a class="markdownIt-Anchor" href="#yml配置文件"></a> yml配置文件</h4><p>yml也是配置文件的一种写法格式，于properties的区别如下图所示</p><p><strong>注意事项</strong></p><ol><li>不同“等级” 用冒号隔开</li><li>次等级的前面是空格，不能使用制表符(tab)</li><li>冒号之后如果有值，那么冒号和值之间至少有一个空格，不能紧贴着</li></ol><pre><code class="highlight yml"><span class="attr">spring:</span>    <span class="attr">mvc:</span>        <span class="attr">view:</span>            <span class="attr">prefix:</span> <span class="string">/WEB-INF/jsp/</span>            <span class="attr">suffix:</span> <span class="string">.jsp</span><span class="attr">server:</span>    <span class="attr">port:</span> <span class="number">8888</span>    <span class="attr">context-path:</span> <span class="string">/test</span></code></pre><blockquote><p>要么用application.properties 要么用 application.yml，不要都用，spring只会选择其一</p></blockquote><h3 id="actuato"><a class="markdownIt-Anchor" href="#actuato"></a> Actuato</h3><p>Actuator是Spring Boot提供的对应用系统的自省和监控的集成功能，可以对应用系统进行配置查看、相关功能统计等。在SpringCloud中主要是完成微服务的监控，完成监控治理。可以查看微服务间的数据处理和调用，当它们之间出现了异常，就可以快速定位到出现问题的地方。。</p><p>其功能与Dubbo的监控中心类似，不同的是，Dubbo的监控中心是需要专门部署的，而Spring Boot的Actuator 是存在于每一个工程中的。</p><h4 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h4><p><strong>添加依赖</strong></p><pre><code class="highlight xml"><span class="comment">&lt;!--actuator监控依赖--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><p><strong>配置application.properties</strong></p><pre><code class="highlight properties"><span class="comment">#配置端口号</span><span class="attr">server.port</span>=<span class="string">8080</span><span class="comment">#配置项目访问名称，上下文路径</span><span class="attr">server.servlet.context-path</span>=<span class="string">/leeboer</span><span class="comment"></span><span class="comment">#actuator监控端口号和上下文路径</span><span class="attr">management.server.port</span>=<span class="string">9999</span><span class="attr">management.server.servlet.context-path</span>=<span class="string">/xxx</span></code></pre><p><strong>访问该路径</strong></p><pre><code class="highlight plaintext">http://localhost:9999/xxx/actuator/health</code></pre><p><strong>自定义info信息</strong></p><pre><code class="highlight properties"><span class="comment">#配置端口号</span><span class="attr">server.port</span>=<span class="string">8080</span><span class="comment">#配置项目访问名称，上下文路径</span><span class="attr">server.servlet.context-path</span>=<span class="string">/leeboer</span><span class="comment"></span><span class="comment">#actuator监控端口号和上下文路径</span><span class="attr">management.server.port</span>=<span class="string">9999</span><span class="attr">management.server.servlet.context-path</span>=<span class="string">/xxx</span><span class="comment">#指定监控终端的基本访问路径,默认为/actuator</span><span class="attr">management.endpoints.web.base-path</span>=<span class="string">/actuator</span><span class="comment"></span><span class="comment">#自定义info信息</span><span class="attr">info.company.name</span>=<span class="string">lee</span><span class="attr">info.company.url</span>=<span class="string">www.leeboer.xyz</span><span class="attr">info.company.addr</span>=<span class="string">china beijing</span><span class="comment"></span><span class="comment">#从properties中读取信息</span><span class="attr">info.project.groupid</span>=<span class="string">@project.groupId@</span><span class="attr">info.project.artifactid</span>=<span class="string">@project.artifactId@</span><span class="attr">info.project.version</span>=<span class="string">@project.version@</span><span class="attr">info.project.name</span>=<span class="string">@project.name@</span></code></pre><p><strong>开放所有的监控终端</strong></p><pre><code class="highlight properties"><span class="comment">#actuator监控端口号和上下文路径</span><span class="attr">management.server.port</span>=<span class="string">9999</span><span class="attr">management.server.servlet.context-path</span>=<span class="string">/xxx</span><span class="comment">#指定监控终端的基本访问路径,默认为/actuator</span><span class="attr">management.endpoints.web.base-path</span>=<span class="string">/actuator</span><span class="comment">#开放所有的监控终端</span><span class="attr">management.endpoints.web.exposure.include</span>=<span class="string">*</span><span class="comment"></span><span class="comment">#关闭部分监控终端</span><span class="attr">management.endpoints.web.exposure.wxclude</span>=<span class="string">evn,beans</span></code></pre><h4 id="监控终端访问测试"><a class="markdownIt-Anchor" href="#监控终端访问测试"></a> 监控终端访问测试</h4><p><strong>mappings终端</strong><br />下面是使用mappings终端，可以看到当前工程中所有的URI与处理器的映射关系，及详细的处理器方法及其映射规则。很实用。</p><p><strong>beans终端</strong></p><p><strong>env终端</strong><br />可以看到当前应用程序运行主机的所有软硬件环境信息。</p><h4 id="常用监控终端"><a class="markdownIt-Anchor" href="#常用监控终端"></a> 常用监控终端</h4><table><thead><tr><th>id</th><th>desc</th><th>Sensitive</th></tr></thead><tbody><tr><td>auditevents</td><td>显示当前应用程序的审计事件信息</td><td>Yes</td></tr><tr><td>beans</td><td>显示应用Spring Beans的完整列表</td><td>Yes</td></tr><tr><td>caches</td><td>显示可用缓存信息</td><td>Yes</td></tr><tr><td>conditions</td><td>显示自动装配类的状态及及应用信息</td><td>Yes</td></tr><tr><td>configprops</td><td>显示所有 @ConfigurationProperties 列表</td><td>Yes</td></tr><tr><td>env</td><td>显示 ConfigurableEnvironment 中的属性</td><td>Yes</td></tr><tr><td>flyway</td><td>显示 Flyway 数据库迁移信息</td><td>Yes</td></tr><tr><td>health</td><td>显示应用的健康信息（未认证只显示status，认证显示全部信息详情）</td><td>No</td></tr><tr><td>info</td><td>显示任意的应用信息（在资源文件写info.xxx即可）</td><td>No</td></tr><tr><td>liquibase</td><td>展示Liquibase 数据库迁移</td><td>Yes</td></tr><tr><td>metrics</td><td>展示当前应用的 metrics 信息</td><td>Yes</td></tr><tr><td>mappings</td><td>显示所有 @RequestMapping 路径集列表</td><td>Yes</td></tr><tr><td>scheduledtasks</td><td>显示应用程序中的计划任务</td><td>Yes</td></tr><tr><td>sessions</td><td>允许从Spring会话支持的会话存储中检索和删除用户会话。</td><td>Yes</td></tr><tr><td>shutdown</td><td>允许应用以优雅的方式关闭（默认情况下不启用）</td><td>Yes</td></tr><tr><td>threaddump</td><td>执行一个线程dump</td><td>Yes</td></tr><tr><td>httptrace</td><td>显示HTTP跟踪信息（默认显示最后100个HTTP请求 - 响应交换）</td><td>Yes</td></tr></tbody></table><h3 id="导入spring-boot项目"><a class="markdownIt-Anchor" href="#导入spring-boot项目"></a> 导入spring boot项目</h3><p><strong>idea导入springboot项目</strong></p><p>IDEA 导入Springboot 项目办法：</p><ol><li>菜单-&gt;File-&gt;New-&gt;Project From Existing Sources</li><li>如图粘贴右上角springboot.rar 解压出来之后的目录,并选中 pom.xml</li><li>点击OK，然后后面就一路 Next 就行了</li></ol><h3 id="打包"><a class="markdownIt-Anchor" href="#打包"></a> 打包</h3><p>我们在Maven的使用插件一节中介绍了如何使用maven-shade-plugin打包一个可执行的jar包。在Spring Boot应用中，打包更加简单，因为Spring Boot自带一个更简单的spring-boot-maven-plugin插件用来打包，我们只需要在pom.xml中加入以下配置：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span>    ...    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p>无需任何配置，Spring Boot的这款插件会自动定位应用程序的入口Class，我们执行以下Maven命令即可打包：</p><pre><code class="highlight plaintext">$ mvn clean package</code></pre><p>以springboot-exec-jar项目为例，打包后我们在target目录下可以看到两个jar文件：</p><pre><code class="highlight plaintext">$ lsclassesgenerated-sourcesmaven-archivermaven-statusspringboot-exec-jar-1.0-SNAPSHOT.jarspringboot-exec-jar-1.0-SNAPSHOT.jar.original</code></pre><p>其中，springboot-exec-jar-1.0-SNAPSHOT.jar.original是Maven标准打包插件打的jar包，它只包含我们自己的Class，不包含依赖，而springboot-exec-jar-1.0-SNAPSHOT.jar是Spring Boot打包插件创建的包含依赖的jar，可以直接运行：</p><pre><code class="highlight plaintext">$ java -jar springboot-exec-jar-1.0-SNAPSHOT.jar</code></pre><p>这样，部署一个Spring Boot应用就非常简单，无需预装任何服务器，只需要上传jar包即可。</p><p>在打包的时候，因为打包后的Spring Boot应用不会被修改，因此，默认情况下，spring-boot-devtools这个依赖不会被打包进去。但是要注意，使用早期的Spring Boot版本时，需要配置一下才能排除spring-boot-devtools这个依赖：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>        <span class="tag">&lt;<span class="name">excludeDevtools</span>&gt;</span>true<span class="tag">&lt;/<span class="name">excludeDevtools</span>&gt;</span>    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></code></pre><p>如果不喜欢默认的项目名+版本号作为文件名，可以加一个配置指定文件名：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span>    ...    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>awesome-app<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span>        ...    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p>这样打包后的文件名就是awesome-app.jar</p><h3 id="瘦身spring-boot"><a class="markdownIt-Anchor" href="#瘦身spring-boot"></a> 瘦身Spring Boot</h3><p>在上一节中，我们使用Spring Boot提供的spring-boot-maven-plugin打包Spring Boot应用，可以直接获得一个完整的可运行的jar包，把它上传到服务器上再运行就极其方便。</p><p>但是这种方式也不是没有缺点。最大的缺点就是包太大了，动不动几十MB，在网速不给力的情况下，上传服务器非常耗时。并且，其中我们引用到的Tomcat、Spring和其他第三方组件，只要版本号不变，这些jar就相当于每次都重复打进去，再重复上传了一遍。</p><p>真正经常改动的代码其实是我们自己编写的代码。如果只打包我们自己编写的代码，通常jar包也就几百KB。但是，运行的时候，classpath中没有依赖的jar包，肯定会报错。</p><p>所以问题来了：如何只打包我们自己编写的代码，同时又自动把依赖包下载到某处，并自动引入到classpath中。解决方案就是使用<strong>spring-boot-thin-launcher</strong>。</p><h4 id="使用spring-boot-thin-launcher"><a class="markdownIt-Anchor" href="#使用spring-boot-thin-launcher"></a> 使用spring-boot-thin-launcher</h4><p>我们先演示如何使用spring-boot-thin-launcher，再详细讨论它的工作原理。首先复制一份上一节的Maven项目，并重命名为springboot-thin-jar：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span>    ...    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-thin-jar<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    ...</code></pre><p>然后，修改<build>-<plugins>-<plugin>，给原来的spring-boot-maven-plugin增加一个<dependency>如下：</p><pre><code class="highlight java">&lt;project ...&gt;    ...    &lt;build&gt;        &lt;finalName&gt;awesome-app&lt;/finalName&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;dependencies&gt;                    &lt;dependency&gt;                        &lt;groupId&gt;org.springframework.boot.experimental&lt;/groupId&gt;                        &lt;artifactId&gt;spring-boot-thin-layout&lt;/artifactId&gt;                        &lt;version&gt;<span class="number">1.0</span><span class="number">.27</span>.RELEASE&lt;/version&gt;                    &lt;/dependency&gt;                &lt;/dependencies&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>不需要任何其他改动了，我们直接按正常的流程打包，执行mvn clean package，观察target目录最终生成的可执行awesome-app.jar，只有79KB左右。</p><p>直接运行java -jar awesome-app.jar，效果和上一节完全一样。显然，79KB的jar肯定无法放下Tomcat和Spring这样的大块头。那么，运行时这个awesome-app.jar又是怎么找到它自己依赖的jar包呢？</p><p>实际上spring-boot-thin-launcher这个插件改变了spring-boot-maven-plugin的默认行为。它输出的jar包只包含我们自己代码编译后的class，一个很小的ThinJarWrapper，以及解析pom.xml后得到的所有依赖jar的列表。</p><p>运行的时候，入口实际上是ThinJarWrapper，它会先在指定目录搜索看看依赖的jar包是否都存在，如果不存在，先从Maven中央仓库下载到本地，然后，再执行我们自己编写的main()入口方法。这种方式有点类似很多在线安装程序：用户下载后得到的是一个很小的exe安装程序，执行安装程序时，会首先在线下载所需的若干巨大的文件，再进行真正的安装。</p><p>这个spring-boot-thin-launcher在启动时搜索的默认目录是用户主目录的.m2，我们也可以指定下载目录，例如，将下载目录指定为当前目录：</p><pre><code class="highlight plaintext">$ java -Dthin.root=. -jar awesome-app.jar</code></pre><p>上述命令通过环境变量thin.root传入当前目录，执行后发现当前目录下自动生成了一个repository目录，这和Maven的默认下载目录~/.m2/repository的结构是完全一样的，只是它仅包含awesome-app.jar所需的运行期依赖项。</p><blockquote><p>注意：只有首次运行时会自动下载依赖项，再次运行时由于无需下载，所以启动速度会大大加快。如果删除了repository目录，再次运行时就会再次触发下载。</p></blockquote><p>把79KB大小的awesome-app.jar直接扔到服务器执行，上传过程就非常快。但是，第一次在服务器上运行awesome-app.jar时，仍需要从Maven中央仓库下载大量的jar包，所以，spring-boot-thin-launcher还提供了一个dryrun选项，专门用来下载依赖项而不执行实际代码：</p><pre><code class="highlight plaintext">java -Dthin.dryrun=true -Dthin.root=. -jar awesome-app.jar</code></pre><p>执行上述代码会在当前目录创建repository目录，并下载所有依赖项，但并不会运行我们编写的main()方法。此过程称之为“预热”（warm up）。</p><p>如果服务器由于安全限制不允许从外网下载文件，那么可以在本地预热，然后把awesome-app.jar和repository目录上传到服务器。只要依赖项没有变化，后续改动只需要上传awesome-app.jar即可。</p><h2 id="spring-boot重要用法"><a class="markdownIt-Anchor" href="#spring-boot重要用法"></a> Spring boot重要用法</h2><h3 id="自定义异常页面"><a class="markdownIt-Anchor" href="#自定义异常页面"></a> 自定义异常页面</h3><h4 id="简单的替换异常页面"><a class="markdownIt-Anchor" href="#简单的替换异常页面"></a> 简单的替换异常页面</h4><p>我们可以使用简单的方式自定义异常页面，并将默认状态页面进行替换</p><p>在<code>resources</code>目录下新建<code>public.error</code>包</p><ul><li>编写404.html/500.html即可</li></ul><blockquote><p>在error目录中定义异常页面。这些异常页面的名称必须为相应的状态码，扩展名为html。</p></blockquote><h4 id="自定义编写抛错逻辑"><a class="markdownIt-Anchor" href="#自定义编写抛错逻辑"></a> 自定义编写抛错逻辑</h4><h5 id="增加抛错"><a class="markdownIt-Anchor" href="#增加抛错"></a> 增加抛错</h5><p>修改HelloController，使得访问你/hello一定会产生异常</p><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.web;<span class="keyword">import</span> org.springframework.stereotype.Controller;<span class="keyword">import</span> org.springframework.ui.Model;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;<span class="keyword">import</span> java.text.DateFormat;<span class="keyword">import</span> java.util.Date;<span class="comment">//这个注解使spring4中的新注解，使@Controller和@ResponseBody的缩写</span><span class="comment">//@RestController</span><span class="comment">//修改RestController为controller</span><span class="comment">//这时返回的“hello”就不是字符串，而是根据application.properties中的视图重定向，在WEB-IND/jsp中去寻找hello.jsp文件</span><span class="meta">@Controller</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(Model m)</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//ModelAndView类中包含了Model和View，在这里只使用Model,返回字符串，让框架去寻址</span>        m.addAttribute(<span class="string">&quot;now&quot;</span>, DateFormat.getDateTimeInstance().format(<span class="keyword">new</span> <span class="title class_">Date</span>()));        <span class="comment">//故意抛错，验证错误处理        </span>        <span class="keyword">if</span>(<span class="literal">true</span>)&#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;some exception&quot;</span>);        &#125;        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;    &#125;&#125;</code></pre><h5 id="globalexceptionhandler"><a class="markdownIt-Anchor" href="#globalexceptionhandler"></a> GlobalExceptionHandler</h5><p>新怎加一个类<code>GlobalExceptionHandler</code>，用于捕捉Exception异常以及其子类</p><p>捕捉到异常后，把异常信息，发出异常的地址放进ModelAndView里，然后跳转到errorPage.jsp</p><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.exception;<span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;<span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;<span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;<span class="keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="meta">@ControllerAdvice</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;    <span class="meta">@ExceptionHandler(value = Exception.class)</span>    <span class="keyword">public</span> ModelAndView <span class="title function_">defaultErrorHandler</span><span class="params">(HttpServletRequest req, Exception e)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();        mav.addObject(<span class="string">&quot;exception&quot;</span>, e);        mav.addObject(<span class="string">&quot;url&quot;</span>, req.getRequestURL());        mav.setViewName(<span class="string">&quot;errorPage&quot;</span>);        <span class="keyword">return</span> mav;    &#125;&#125;</code></pre><p><strong>@ControllerAdvice</strong>是Spring 3.2新增的注解，作用<strong>控制器增强</strong>，主要是用来Controller的一些公共的需求的低侵入性增强提供辅助，作用于<code>@RequestMapping</code>标注的方法上</p><ol><li><strong>@ExceptionHandler</strong>   自定义的错误处理器</li><li><strong>@ModelAttribute</strong>      全局的对所有的controller的Model添加属性</li><li><strong>@InitBinder</strong>  对表单数据绑定</li></ol><p>所以结合上面我们可以知道,使用@ExceptionHandler，可以处理异常, 但是仅限于当前Controller中处理异常, @ControllerAdvice可以配置basePackage下的所有controller. 所以结合两者使用,就可以处理全局的异常了</p><p>自定义异常类</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomGenericException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;    <span class="keyword">private</span> String errCode;    <span class="keyword">private</span> String errMsg;    <span class="keyword">public</span> String <span class="title function_">getErrCode</span><span class="params">()</span> &#123;        <span class="keyword">return</span> errCode;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setErrCode</span><span class="params">(String errCode)</span> &#123;        <span class="built_in">this</span>.errCode = errCode;    &#125;    <span class="keyword">public</span> String <span class="title function_">getErrMsg</span><span class="params">()</span> &#123;        <span class="keyword">return</span> errMsg;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setErrMsg</span><span class="params">(String errMsg)</span> &#123;        <span class="built_in">this</span>.errMsg = errMsg;    &#125;    <span class="keyword">public</span> <span class="title function_">CustomGenericException</span><span class="params">(String errCode, String errMsg)</span> &#123;        <span class="built_in">this</span>.errCode = errCode;        <span class="built_in">this</span>.errMsg = errMsg;    &#125;&#125;</code></pre><p>使用示例</p><pre><code class="highlight java"><span class="meta">@ControllerAdvice</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionsHandler</span> &#123;    <span class="meta">@ExceptionHandler(CustomGenericException.class)</span><span class="comment">//可以直接写@ExceptionHandler,不指明异常类，会自动映射</span>    <span class="keyword">public</span> ModelAndView <span class="title function_">customGenericExceptionHnadler</span><span class="params">(CustomGenericException exception)</span>&#123; <span class="comment">//还可以声明接收其他任意参数</span>        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;generic_error&quot;</span>);        modelAndView.addObject(<span class="string">&quot;errCode&quot;</span>,exception.getErrCode());        modelAndView.addObject(<span class="string">&quot;errMsg&quot;</span>,exception.getErrMsg());        <span class="keyword">return</span> modelAndView;    &#125;    <span class="comment">//可以通过ResponseStatus配置返回的状态码</span>    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span>    <span class="meta">@ExceptionHandler(Exception.class)</span><span class="comment">//可以直接写@EceptionHandler，IOExeption继承于Exception</span>    <span class="keyword">public</span> ModelAndView <span class="title function_">allExceptionHandler</span><span class="params">(Exception exception)</span>&#123;        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;generic_error&quot;</span>);        modelAndView.addObject(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;this is Exception.class&quot;</span>);        <span class="keyword">return</span> modelAndView;    &#125;&#125;</code></pre><blockquote><p>此时<code>ExceptionsHandler</code>类就会捕获Controller中的所有异常</p></blockquote><h5 id="errorpagejsp"><a class="markdownIt-Anchor" href="#errorpagejsp"></a> errorPage.jsp</h5><pre><code class="highlight xml">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:500px;border:1px solid lightgray;margin:200px auto;padding:80px&quot;</span>&gt;</span> 系统 出现了异常，异常原因是：    $&#123;exception&#125;    <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span>    出现异常的地址是：    $&#123;url&#125;    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><h5 id="重启测试"><a class="markdownIt-Anchor" href="#重启测试"></a> 重启测试</h5><pre><code class="highlight plaintext">http://127.0.0.1:8080/hello</code></pre><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><p><strong>添加依赖</strong></p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><p><strong>定义测试类</strong></p><ul><li><code>@RunWith(SpringRunner.class)</code></li><li><code>@SpringBootTest(classes=SpringbootdemoApplication.class)</code></li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.springbootdemo;<span class="keyword">import</span> org.junit.Test;<span class="keyword">import</span> org.junit.runner.RunWith;<span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<span class="meta">@RunWith(SpringRunner.class)</span><span class="meta">@SpringBootTest(classes=SpringbootdemoApplication.class)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootdemoApplicationTests</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> ISomeService service;        <span class="meta">@Test</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;        service.doSome();    &#125;&#125;</code></pre><h3 id="多环境选择"><a class="markdownIt-Anchor" href="#多环境选择"></a> 多环境选择</h3><p>在开发应用时，通常同一套程序会被运行在多个不同的环境，例如，开发、测试、生产环境等。每个环境的数据库地址、服务器端口号等配置都会不同。若在不同环境下运行时将配置文件修改为不同内容，那么，这种做法不仅非常繁琐，而且很容易发生错误。</p><p>在开发应用时，有时不同的环境，其需要运行的接口的实现类也是不同的。例如，若要开发一个具有短信发送功能的应用，开发环境中要执行的send()方法仅需调用短信模拟器即可，而生产环境中要执行的send()则需要调用短信运营商所提供的短信发送接口。这种情况下，就需要开发两个相关接口的实现类去实现send()方法。</p><p>对于不同的环境，需要使用不同的配置文件，执行不同的类。而<strong>这个选择只需在SpringBoot的主配置文件中指定即可</strong>。</p><p>下面以不同的环境“使用配置有不同的端口号的配置文件，及调用不同接口实现类”为例来演示多环境选择问题的解决</p><p>有时候在本地测试使用8080端口，可是上线使用的又是80端口，此时就可以通过多配置文件实现多配置支持的灵活切换</p><h4 id="多配置文件"><a class="markdownIt-Anchor" href="#多配置文件"></a> 多配置文件</h4><p><strong>3个配置文件：</strong></p><p>核心配置文件：<code>application.properties</code><br />开发环境用的配置文件：<code>application-dev.properties</code><br />生产环境用的配置文件：<code>application-pro.properties</code></p><p><strong>通过spring.profiles.active 灵活地来切换使用环境</strong></p><ul><li>该命令指定即为运行和编译要使用的配置文件</li><li>填写的值为其他application-之后，后缀名之前的简写名</li></ul><hr /><ul><li>application.properties</li></ul><pre><code class="highlight properties"><span class="attr">spring.profiles.active</span>=<span class="string">pro</span><span class="attr">spring.mvc.view.prefix</span>=<span class="string">/WEB-INF/jsp/</span><span class="attr">spring.mvc.view.suffix</span>=<span class="string">.jsp</span></code></pre><ul><li>application-dev.properties</li></ul><pre><code class="highlight properties"><span class="comment">#开发环境</span><span class="attr">server.port</span>=<span class="string">8088</span><span class="attr">server.context-path</span>=<span class="string">/test</span></code></pre><ul><li>application-pro.properties</li></ul><pre><code class="highlight properties"><span class="comment">#生产环境</span><span class="attr">server.port</span>=<span class="string">80</span><span class="attr">server.context-path</span>=<span class="string">/</span></code></pre><p>@<strong>Profile</strong>注释</p><ul><li>该注释可以标记在类上或方法上</li><li>即标记在哪个配置文件环境下生效</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MsgService</span>&#123;    String <span class="title function_">send</span><span class="params">()</span>;&#125;</code></pre><pre><code class="highlight java"><span class="meta">@Service</span><span class="meta">@Profile(&quot;dev&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DevMsgServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MsgService</span>&#123;    String <span class="title function_">send</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="string">&quot;dev&quot;</span>;    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="meta">@Service</span><span class="meta">@Profile(&quot;pro&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProMsgServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MsgService</span>&#123;    String <span class="title function_">send</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="string">&quot;pro&quot;</span>;    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="meta">@RestController</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgController</span>&#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> MsgService service;        <span class="meta">@GitMapping(&quot;/send&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">sendHandler</span><span class="params">()</span>&#123;        <span class="keyword">return</span> service.send();    &#125;&#125;</code></pre><h4 id="部署-2"><a class="markdownIt-Anchor" href="#部署-2"></a> 部署</h4><p>不仅可以通过修改application.properties文件进行切换，还可以在部署环境下，指定不同的参数来确保生产环境总是使用的希望的那套配置</p><p>构建</p><pre><code class="highlight plaintext">cd C:\Users\X7TI\Downloads\springbootmvn install</code></pre><p>运行</p><pre><code class="highlight plaintext">java -jar target/springboot-0.0.1-SNAPSHOT.jar --spring.profiles.active=pro</code></pre><pre><code class="highlight plaintext">java -jar target/springboot-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev</code></pre><blockquote><p>这样就可以保证在开发环境总是用的8080端口，而到了生产环境总是用的80端口，免去了每次上线还要修改端口号的麻烦</p></blockquote><h3 id="禁用自动配置"><a class="markdownIt-Anchor" href="#禁用自动配置"></a> 禁用自动配置</h3><p>Spring Boot大量使用自动配置和默认配置，极大地减少了代码，通常只需要加上几个注解，并按照默认规则设定一下必要的配置即可。例如，配置JDBC，默认情况下，只需要配置一个spring.datasource：</p><pre><code class="highlight plaintext">spring:  datasource:    url: jdbc:hsqldb:file:testdb    username: sa    password:    dirver-class-name: org.hsqldb.jdbc.JDBCDriver</code></pre><p>Spring Boot就会自动创建出DataSource、JdbcTemplate、DataSourceTransactionManager，非常方便。</p><p>但是，有时候，我们又必须要禁用某些自动配置。例如，系统有主从两个数据库，而Spring Boot的自动配置只能配一个，怎么办？</p><p>这个时候，针对DataSource相关的自动配置，就必须关掉。我们需要用exclude指定需要关掉的自动配置：</p><pre><code class="highlight java"><span class="meta">@SpringBootApplication</span><span class="comment">// 启动自动配置，但排除指定的自动配置:</span><span class="meta">@EnableAutoConfiguration(exclude = DataSourceAutoConfiguration.class)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;    ...&#125;</code></pre><p>现在，Spring Boot不再给我们自动创建DataSource、JdbcTemplate和DataSourceTransactionManager了，要实现主从数据库支持，怎么办？</p><p>让我们一步一步开始编写支持主从数据库的功能。首先，我们需要把主从数据库配置写到application.yml中，仍然按照Spring Boot默认的格式写，但datasource改为datasource-master和datasource-slave：</p><pre><code class="highlight yml"><span class="attr">spring:</span>  <span class="attr">datasource-master:</span>    <span class="attr">url:</span> <span class="string">jdbc:hsqldb:file:testdb</span>    <span class="attr">username:</span> <span class="string">sa</span>    <span class="attr">password:</span>    <span class="attr">dirver-class-name:</span> <span class="string">org.hsqldb.jdbc.JDBCDriver</span>  <span class="attr">datasource-slave:</span>    <span class="attr">url:</span> <span class="string">jdbc:hsqldb:file:testdb</span>    <span class="attr">username:</span> <span class="string">sa</span>    <span class="attr">password:</span>    <span class="attr">dirver-class-name:</span> <span class="string">org.hsqldb.jdbc.JDBCDriver</span></code></pre><p>注意到两个数据库实际上是同一个库。如果使用MySQL，可以创建一个只读用户，作为datasource-slave的用户来模拟一个从库。</p><p>下一步，我们分别创建两个HikariCP的DataSource：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MasterDataSourceConfiguration</span> &#123;    <span class="meta">@Bean(&quot;masterDataSourceProperties&quot;)</span>    <span class="meta">@ConfigurationProperties(&quot;spring.datasource-master&quot;)</span>    DataSourceProperties <span class="title function_">dataSourceProperties</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProperties</span>();    &#125;    <span class="meta">@Bean(&quot;masterDataSource&quot;)</span>    DataSource <span class="title function_">dataSource</span><span class="params">(<span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;masterDataSourceProperties&quot;)</span> DataSourceProperties props)</span> &#123;        <span class="keyword">return</span> props.initializeDataSourceBuilder().build();    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlaveDataSourceConfiguration</span> &#123;    <span class="meta">@Bean(&quot;slaveDataSourceProperties&quot;)</span>    <span class="meta">@ConfigurationProperties(&quot;spring.datasource-slave&quot;)</span>    DataSourceProperties <span class="title function_">dataSourceProperties</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProperties</span>();    &#125;    <span class="meta">@Bean(&quot;slaveDataSource&quot;)</span>    DataSource <span class="title function_">dataSource</span><span class="params">(<span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;slaveDataSourceProperties&quot;)</span> DataSourceProperties props)</span> &#123;        <span class="keyword">return</span> props.initializeDataSourceBuilder().build();    &#125;&#125;</code></pre><p>注意到上述class并未添加@Configuration和@Component，要使之生效，可以使用@Import导入：</p><pre><code class="highlight java"><span class="meta">@SpringBootApplication</span><span class="meta">@EnableAutoConfiguration(exclude = DataSourceAutoConfiguration.class)</span><span class="meta">@Import(&#123; MasterDataSourceConfiguration.class, SlaveDataSourceConfiguration.class&#125;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;    ...&#125;</code></pre><p>此外，上述两个DataSource的Bean名称分别为masterDataSource和slaveDataSource，我们还需要一个最终的@Primary标注的DataSource，它采用Spring提供的AbstractRoutingDataSource，代码实现如下：</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">RoutingDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">protected</span> Object <span class="title function_">determineCurrentLookupKey</span><span class="params">()</span> &#123;        <span class="comment">// 从ThreadLocal中取出key:</span>        <span class="keyword">return</span> RoutingDataSourceContext.getDataSourceRoutingKey();    &#125;&#125;</code></pre><p>RoutingDataSource本身并不是真正的DataSource，它通过Map关联一组DataSource，下面的代码创建了包含两个DataSource的RoutingDataSource，关联的key分别为masterDataSource和slaveDataSource：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoutingDataSourceConfiguration</span> &#123;    <span class="meta">@Primary</span>    <span class="meta">@Bean</span>    DataSource <span class="title function_">dataSource</span><span class="params">(</span><span class="params">            <span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;masterDataSource&quot;)</span> DataSource masterDataSource,</span><span class="params">            <span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;slaveDataSource&quot;)</span> DataSource slaveDataSource)</span> &#123;        <span class="type">var</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoutingDataSource</span>();        <span class="comment">// 关联两个DataSource:</span>        ds.setTargetDataSources(Map.of(                <span class="string">&quot;masterDataSource&quot;</span>, masterDataSource,                <span class="string">&quot;slaveDataSource&quot;</span>, slaveDataSource));        <span class="comment">// 默认使用masterDataSource:</span>        ds.setDefaultTargetDataSource(masterDataSource);        <span class="keyword">return</span> ds;    &#125;    <span class="meta">@Bean</span>    JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);    &#125;    <span class="meta">@Bean</span>    DataSourceTransactionManager <span class="title function_">dataSourceTransactionManager</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);    &#125;&#125;</code></pre><p>仍然需要自己创建JdbcTemplate和PlatformTransactionManager，注入的是标记为@Primary的RoutingDataSource。这样，我们通过如下的代码就可以切换RoutingDataSource底层使用的真正的DataSource：</p><pre><code class="highlight java">RoutingDataSourceContext.setDataSourceRoutingKey(<span class="string">&quot;slaveDataSource&quot;</span>);jdbcTemplate.query(...);</code></pre><p>只不过写代码切换DataSource即麻烦又容易出错，更好的方式是通过注解配合AOP实现自动切换，这样，客户端代码实现如下：</p><pre><code class="highlight java"><span class="meta">@Controllerpublic</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;        <span class="meta">@RoutingWithSlave</span> <span class="comment">// &lt;-- 指示在此方法中使用slave数据库</span>        <span class="meta">@GetMapping(&quot;/profile&quot;)</span>        <span class="keyword">public</span> ModelAndView <span class="title function_">profile</span><span class="params">(HttpSession session)</span> &#123;        ...    &#125;&#125;</code></pre><p>实现上述功能需要编写一个@RoutingWithSlave注解，一个AOP织入和一个ThreadLocal来保存key。由于代码比较简单，这里我们不再详述。</p><p>如果我们想要确认是否真的切换了DataSource，可以覆写determineTargetDataSource()方法并打印出DataSource的名称：</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">RoutingDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> &#123;    ...    <span class="meta">@Override</span>    <span class="keyword">protected</span> DataSource <span class="title function_">determineTargetDataSource</span><span class="params">()</span> &#123;        <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="built_in">super</span>.determineTargetDataSource();        logger.info(<span class="string">&quot;determin target datasource: &#123;&#125;&quot;</span>, ds);        <span class="keyword">return</span> ds;    &#125;&#125;</code></pre><p>访问不同的URL，可以在日志中看到两个DataSource，分别是HikariPool-1和hikariPool-2：</p><pre><code class="highlight plaintext">2020-06-14 17:55:21.676  INFO 91561 --- [nio-8080-exec-7] c.i.learnjava.config.RoutingDataSource   : determin target datasource: HikariDataSource (HikariPool-1)2020-06-14 17:57:08.992  INFO 91561 --- [io-8080-exec-10] c.i.learnjava.config.RoutingDataSource   : determin target datasource: HikariDataSource (HikariPool-2)</code></pre><p>我们用一个图来表示创建的DataSource以及相关Bean的关系：</p><p>注意到DataSourceTransactionManager和JdbcTemplate引用的都是RoutingDataSource，所以，这种设计的一个限制就是：在一个请求中，一旦切换了内部数据源，在同一个事务中，不能再切到另一个，否则，DataSourceTransactionManager和JdbcTemplate操作的就不是同一个数据库连接。</p><h3 id="使用profiles"><a class="markdownIt-Anchor" href="#使用profiles"></a> 使用Profiles</h3><p>Profile本身是Spring提供的功能，我们在使用条件装配中已经讲到了，Profile表示一个环境的概念，如开发、测试和生产这3个环境：</p><ul><li>native</li><li>test</li><li>production</li></ul><p>或者按git分支定义master、dev这些环境：</p><ul><li>master</li><li>dev在启动一个Spring应用程序的时候，可以传入一个或多个环境，例如：</li></ul><pre><code class="highlight plaintext">-Dspring.profiles.active=test,master</code></pre><p>大多数情况下，使用一个环境就足够了。</p><p>Spring Boot对Profiles的支持在于，可以在application.yml中为每个环境进行配置。下面是一个示例配置：</p><pre><code class="highlight yml"><span class="attr">spring:</span>  <span class="attr">application:</span>    <span class="attr">name:</span> <span class="string">$&#123;APP_NAME:unnamed&#125;</span>  <span class="attr">datasource:</span>    <span class="attr">url:</span> <span class="string">jdbc:hsqldb:file:testdb</span>    <span class="attr">username:</span> <span class="string">sa</span>    <span class="attr">password:</span>    <span class="attr">dirver-class-name:</span> <span class="string">org.hsqldb.jdbc.JDBCDriver</span>    <span class="attr">hikari:</span>      <span class="attr">auto-commit:</span> <span class="literal">false</span>      <span class="attr">connection-timeout:</span> <span class="number">3000</span>      <span class="attr">validation-timeout:</span> <span class="number">3000</span>      <span class="attr">max-lifetime:</span> <span class="number">60000</span>      <span class="attr">maximum-pool-size:</span> <span class="number">20</span>      <span class="attr">minimum-idle:</span> <span class="number">1</span><span class="attr">pebble:</span>  <span class="attr">suffix:</span>  <span class="attr">cache:</span> <span class="literal">false</span><span class="attr">server:</span>  <span class="attr">port:</span> <span class="string">$&#123;APP_PORT:8080&#125;</span><span class="meta">---</span><span class="meta"></span><span class="attr">spring:</span>  <span class="attr">config:</span>    <span class="attr">activate:</span>      <span class="attr">on-profile:</span> <span class="string">test</span><span class="attr">server:</span>  <span class="attr">port:</span> <span class="number">8000</span><span class="meta">---</span><span class="meta"></span><span class="attr">spring:</span>  <span class="attr">config:</span>    <span class="attr">activate:</span>      <span class="attr">on-profile:</span> <span class="string">production</span><span class="attr">server:</span>  <span class="attr">port:</span> <span class="number">80</span><span class="attr">pebble:</span>  <span class="attr">cache:</span> <span class="literal">true</span></code></pre><p>注意到分隔符—，最前面的配置是默认配置，不需要指定Profile，后面的每段配置都必须以spring.config.activate.on-profile.profiles: xxx开头，表示一个Profile。上述配置默认使用8080端口，但是在test环境下，使用8000端口，在production环境下，使用80端口，并且启用Pebble的缓存。</p><p>如果我们不指定任何Profile，直接启动应用程序，那么Profile实际上就是default，可以从Spring Boot启动日志看出：</p><pre><code class="highlight plaintext">...2022-11-25T11:10:34.006+08:00  INFO 13537 --- [           main] com.itranswarp.learnjava.Application     : No active profile set, falling back to 1 default profile: &quot;default&quot;</code></pre><p>上述日志显示未设置Profile，使用默认的Profile为default。</p><p>要以test环境启动，可输入如下命令：</p><pre><code class="highlight plaintext">$ java -Dspring.profiles.active=test -jar springboot-profiles-1.0-SNAPSHOT.jar...2022-11-25T11:09:02.946+08:00  INFO 13510 --- [           main] com.itranswarp.learnjava.Application     : The following 1 profile is active: &quot;test&quot;...2022-11-25T11:09:05.124+08:00  INFO 13510 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8000 (http) with context path &#x27;&#x27;...</code></pre><p>从日志看到活动的Profile是test，Tomcat的监听端口是8000。</p><p>通过Profile可以实现一套代码在不同环境启用不同的配置和功能。假设我们需要一个存储服务，在本地开发时，直接使用文件存储即可，但是，在测试和生产环境，需要存储到云端如S3上，如何通过Profile实现该功能？</p><p>首先，我们要定义存储接口StorageService：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StorageService</span> &#123;    <span class="comment">// 根据URI打开InputStream:</span>    InputStream <span class="title function_">openInputStream</span><span class="params">(String uri)</span> <span class="keyword">throws</span> IOException;    <span class="comment">// 根据扩展名+InputStream保存并返回URI:</span>    String <span class="title function_">store</span><span class="params">(String extName, InputStream input)</span> <span class="keyword">throws</span> IOException;&#125;</code></pre><p>本地存储可通过LocalStorageService实现：</p><pre><code class="highlight java"><span class="meta">@Component</span><span class="meta">@Profile(&quot;default&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalStorageService</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;    <span class="meta">@Value(&quot;$&#123;storage.local:/var/static&#125;&quot;)</span>    String localStorageRootDir;    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());    <span class="keyword">private</span> File localStorageRoot;    <span class="meta">@PostConstruct</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;        logger.info(<span class="string">&quot;Intializing local storage with root dir: &#123;&#125;&quot;</span>, <span class="built_in">this</span>.localStorageRootDir);        <span class="built_in">this</span>.localStorageRoot = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="built_in">this</span>.localStorageRootDir);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> InputStream <span class="title function_">openInputStream</span><span class="params">(String uri)</span> <span class="keyword">throws</span> IOException &#123;        <span class="type">File</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="built_in">this</span>.localStorageRoot, uri);        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(targetFile));    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">store</span><span class="params">(String extName, InputStream input)</span> <span class="keyword">throws</span> IOException &#123;        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + <span class="string">&quot;.&quot;</span> + extName;        <span class="type">File</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="built_in">this</span>.localStorageRoot, fileName);        <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(targetFile))) &#123;            input.transferTo(output);        &#125;        <span class="keyword">return</span> fileName;    &#125;&#125;</code></pre><p>而云端存储可通过CloudStorageService实现：</p><pre><code class="highlight java"><span class="meta">@Component</span><span class="meta">@Profile(&quot;!default&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloudStorageService</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;    <span class="meta">@Value(&quot;$&#123;storage.cloud.bucket:&#125;&quot;)</span>    String bucket;    <span class="meta">@Value(&quot;$&#123;storage.cloud.access-key:&#125;&quot;)</span>    String accessKey;    <span class="meta">@Value(&quot;$&#123;storage.cloud.access-secret:&#125;&quot;)</span>    String accessSecret;    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());    <span class="meta">@PostConstruct</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;        <span class="comment">// <span class="doctag">TODO:</span></span>        logger.info(<span class="string">&quot;Initializing cloud storage...&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> InputStream <span class="title function_">openInputStream</span><span class="params">(String uri)</span> <span class="keyword">throws</span> IOException &#123;        <span class="comment">// <span class="doctag">TODO:</span></span>        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;File not found: &quot;</span> + uri);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">store</span><span class="params">(String extName, InputStream input)</span> <span class="keyword">throws</span> IOException &#123;        <span class="comment">// <span class="doctag">TODO:</span></span>        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Unable to access cloud storage.&quot;</span>);    &#125;&#125;</code></pre><p>注意到LocalStorageService使用了条件装配@Profile(“default”)，即默认启用LocalStorageService，而CloudStorageService使用了条件装配@Profile(“!default”)，即非default环境时，自动启用CloudStorageService。这样，一套代码，就实现了不同环境启用不同的配置。</p><h3 id="使用conditional"><a class="markdownIt-Anchor" href="#使用conditional"></a> 使用Conditional</h3><p>使用Profile能根据不同的Profile进行条件装配，但是Profile控制比较糙，如果想要精细控制，例如，配置本地存储，AWS存储和阿里云存储，将来很可能会增加Azure存储等，用Profile就很难实现。</p><p>Spring本身提供了条件装配@Conditional，但是要自己编写比较复杂的Condition来做判断，比较麻烦。Spring Boot则为我们准备好了几个非常有用的条件：</p><ul><li>@ConditionalOnProperty：如果有指定的配置，条件生效；</li><li>@ConditionalOnBean：如果有指定的Bean，条件生效；</li><li>@ConditionalOnMissingBean：如果没有指定的Bean，条件生效；</li><li>@ConditionalOnMissingClass：如果没有指定的Class，条件生效；</li><li>@ConditionalOnWebApplication：在Web环境中条件生效；</li><li>@ConditionalOnExpression：根据表达式判断条件是否生效。</li></ul><p>我们以最常用的@ConditionalOnProperty为例，把上一节的StorageService改写如下。首先，定义配置storage.type=xxx，用来判断条件，默认为local：</p><pre><code class="highlight plaintext">storage:  type: $&#123;STORAGE_TYPE:local&#125;</code></pre><p>设定为local时，启用LocalStorageService：</p><pre><code class="highlight java"><span class="meta">@Component</span><span class="meta">@ConditionalOnProperty(value = &quot;storage.type&quot;, havingValue = &quot;local&quot;, matchIfMissing = true)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalStorageService</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;    ...&#125;</code></pre><p>设定为aws时，启用AwsStorageService：</p><pre><code class="highlight java"><span class="meta">@Component</span><span class="meta">@ConditionalOnProperty(value = &quot;storage.type&quot;, havingValue = &quot;aws&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AwsStorageService</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;    ...&#125;</code></pre><p>设定为aliyun时，启用AliyunStorageService：</p><pre><code class="highlight java"><span class="meta">@Component</span><span class="meta">@ConditionalOnProperty(value = &quot;storage.type&quot;, havingValue = &quot;aliyun&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliyunStorageService</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;    ...&#125;</code></pre><p>注意到LocalStorageService的注解，当指定配置为local，或者配置不存在，均启用LocalStorageService。</p><h3 id="lombok"><a class="markdownIt-Anchor" href="#lombok"></a> Lombok</h3><p>lombok是一个自动生成getter/setter/toString等方法的一个idea插件</p><p><strong>lombok插件安装</strong></p><p><strong>添加依赖</strong></p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><p><strong>使用</strong></p><ul><li>添加<code>@Data</code>注解即可</li></ul><pre><code class="highlight java"><span class="meta">@Data</span><span class="meta">@NoArgsConstructor</span>     <span class="comment">//没有参数的构造方法</span><span class="meta">@AllArgsConstructor</span>     <span class="comment">//全部参数的构造方法</span><span class="keyword">public</span> <span class="keyword">void</span> Student&#123;    <span class="keyword">private</span> <span class="type">int</span> id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> <span class="type">int</span> age;        <span class="comment">//剩下的代码lombok会自动生成</span>&#125;</code></pre><h3 id="读取自定义配置"><a class="markdownIt-Anchor" href="#读取自定义配置"></a> 读取自定义配置</h3><p>自定义配置，可以是定义在主配置文件application.properties中的自定义属性，也可以是自定义配置文件中的属性。</p><ul><li>通过@Value(“${ }”)读取指定的自定义属性</li><li>若要读取自定义配置文件，则需要在该读取类上添加@PropertySource注解</li><li>自定义配置文件不能是yml文件，只能是properties</li></ul><h4 id="读取配置文件中的属性"><a class="markdownIt-Anchor" href="#读取配置文件中的属性"></a> 读取配置文件中的属性</h4><p>修改主配置文件：<code>application.properties</code></p><pre><code class="highlight plaintext">student.name=张三</code></pre><p>在类中读取：</p><pre><code class="highlight java"><span class="meta">@Controller</span><span class="meta">@RequestMapping(&quot;/test&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeHandler</span>&#123;    <span class="meta">@Value(&quot;$&#123;student.name&#125;&quot;)</span>    <span class="keyword">private</span> String name;    <span class="meta">@GetMapping(&quot;some&quot;)</span>    <span class="meta">@ResponseBody</span>    <span class="keyword">public</span> String <span class="title function_">someHandler</span><span class="params">()</span>&#123;        <span class="keyword">return</span> name;    &#125;&#125;</code></pre><h4 id="读取指定配置文件中的属性"><a class="markdownIt-Anchor" href="#读取指定配置文件中的属性"></a> 读取指定配置文件中的属性</h4><p>一般情况下，主配置文件中存放系统中定义好的属性设置，而自定义属性一般会写入自定义的配置文件中。也就是说，Java代码除了可以读取主配置文件中的属性外，还可以读取指定配置文件中的属性，可以通过@PropertySource注解加载指定的配置文件。</p><blockquote><p>spring boot官网给出说明，@PropertySource注解不能加载yml文件。所以其建议自定快速开发框架 自定义配置文件就使用属性文件。</p></blockquote><p><strong>自定义配置文件</strong></p><p>定义配置文件<code>myapp.properties</code>，存放在src/main/resource目录中</p><pre><code class="highlight plaintext">student.name=张三</code></pre><p><strong>类中取值</strong></p><p>使用<code>@PropertySource</code>注解，若属性的值存在中文，则需要添加encoding属性</p><pre><code class="highlight java"><span class="meta">@Controller</span><span class="meta">@RequestMapping(&quot;/test&quot;)</span><span class="meta">@PropertySource(value=&quot;classpath:myapp.properties&quot;,encoding=&quot;utf-8&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeHandler</span>&#123;    <span class="meta">@Value(&quot;$&#123;student.name&#125;&quot;)</span>    <span class="keyword">private</span> String name;    <span class="meta">@GetMapping(&quot;some&quot;)</span>    <span class="meta">@ResponseBody</span>    <span class="keyword">public</span> String <span class="title function_">someHandler</span><span class="params">()</span>&#123;        <span class="keyword">return</span> name;    &#125;&#125;</code></pre><h4 id="读取对象属性"><a class="markdownIt-Anchor" href="#读取对象属性"></a> 读取对象属性</h4><p><code>myapp.properties</code></p><pre><code class="highlight plaintext">student.name=zhangsanstudent.age=24student.score=93.5</code></pre><p><strong>类中读取值</strong></p><ul><li><code>@ProertySource</code>用于指定要读取的配置文件</li><li><code>@ConfigurationProperties</code>用于指定要读取配置文件中的对象属性</li><li><code>@Component</code>表示当前从配置文件读取来的对象，由Spring容器创建</li></ul><blockquote><p>这里的类名可以随便起，不用和配置文件相同，但是成员变量名必须相同</p></blockquote><pre><code class="highlight java"><span class="meta">@Component</span><span class="meta">@PropertySource(value=&quot;classpath:myapp.properties&quot;,encoding=&quot;utf-8&quot;)</span><span class="meta">@ConfigurationProperties(&quot;student&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;        <span class="keyword">private</span> String name;    <span class="keyword">private</span> <span class="type">int</span> age;    <span class="keyword">private</span> <span class="type">double</span> score;    <span class="comment">//getter and setter</span>&#125;</code></pre><h4 id="读取list-string"><a class="markdownIt-Anchor" href="#读取list-string"></a> 读取List-String</h4><p><code>myapp.properties</code></p><pre><code class="highlight properties"><span class="attr">country.cities[0]</span>=<span class="string">beijing</span><span class="attr">country.cities[1]</span>=<span class="string">shanghai</span><span class="attr">country.cities[2]</span>=<span class="string">xian</span></code></pre><p><strong>在类中取值</strong></p><pre><code class="highlight java"><span class="meta">@Component</span> <span class="meta">@PropertySource(value=&quot;classpath:myapp.properties&quot;,encoding=&quot;utf-8&quot;)</span> <span class="meta">@ConfigurationProperties(&quot;country&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Country</span>&#123;    <span class="keyword">private</span> List&lt;String&gt; cities;        <span class="comment">//getter and setter</span>&#125;</code></pre><h4 id="读取list-object"><a class="markdownIt-Anchor" href="#读取list-object"></a> 读取List-Object</h4><p><code>myapp.properties</code></p><pre><code class="highlight properties"><span class="attr">group.students[0].name</span>=<span class="string">zhangdan</span><span class="attr">group.students[0].age</span>=<span class="string">23</span><span class="attr">group.students[0].score</span>=<span class="string">93</span><span class="attr">group.students[1].name</span>=<span class="string">lisi</span><span class="attr">group.students[1].age</span>=<span class="string">25</span><span class="attr">group.students[1].score</span>=<span class="string">80</span><span class="attr">group.students[2].name</span>=<span class="string">wangwu</span><span class="attr">group.students[2].age</span>=<span class="string">26</span><span class="attr">group.students[2].score</span>=<span class="string">99</span></code></pre><p><strong>在类中取值</strong></p><blockquote><p>Student类无需任何注解</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> <span class="type">int</span> age;    <span class="keyword">private</span> <span class="type">double</span> score;        <span class="comment">//getter and setter</span>&#125;</code></pre><pre><code class="highlight java"><span class="meta">@Component</span> <span class="meta">@PropertySource(value=&quot;classpath:myapp.properties&quot;,encoding=&quot;utf-8&quot;)</span> <span class="meta">@ConfigurationProperties(&quot;group&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Country</span>&#123;    <span class="keyword">private</span> List&lt;Student&gt; student;        <span class="comment">//getter and setter</span>&#125;</code></pre><h3 id="jsp"><a class="markdownIt-Anchor" href="#jsp"></a> JSP</h3><p>在Spring Boot下直接使用JSP文件，其是无法解析的，需要做专门的配置。</p><p>spring boot的默认视图支持使Thymeleaf</p><ul><li>在pom文件中注册JSP解析器依赖</li><li>在pom文件中注册资源目录</li><li>在主配置文件中注册视图前辍与后辍（不是必须的）</li></ul><h4 id="1-直接添加jsp文件"><a class="markdownIt-Anchor" href="#1-直接添加jsp文件"></a> 1 直接添加JSP文件</h4><p><strong>创建webapp目录</strong></p><p>在src/main下创建webapp目录，用于存放jsp文件。这就是一个普通的目录，无需执行Mark Directory As。</p><p><strong>创建index.jsp</strong></p><p>在spring boot工程中若要创建jsp文件，一般是需要在src/main下创建webapp目录，然后在该目录下创建jsp文件。但通过Alt + Insert发现没有创建jsp文件的选项。此时，需要打开Project Structrue窗口，将webapp目录指定为web资源目录，然后才可以创建jsp文件</p><p>指定后便可看到下面的窗口情况。</p><p>此时，便可在webapp中找到jsp的创建选项了。</p><p>创建index页面</p><p>此时启动工程后在浏览器直接访问，发现其并没有显示index页面。因为当前工程不能识别jsp文件</p><h4 id="2-使用物理视图"><a class="markdownIt-Anchor" href="#2-使用物理视图"></a> 2 使用物理视图</h4><p><strong>添加jasper依赖</strong></p><p>在pom中添加一个Tomcat内嵌的jsp引擎jasper依赖。jsp引擎是用于解析jsp文件的，即将jsp文件解析为Servlet是由jsp引擎完成的。embed，嵌入。</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><p><strong>注册webapp目录</strong></p><p>在pom文件中将webapp目录注册为资源目录。</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">build</span>&gt;</span>    <span class="comment">&lt;!--spring提供的打包插件--&gt;</span>    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="comment">&lt;!--注册webapp目录为资源目录--&gt;</span>    <span class="tag">&lt;<span class="name">resources</span>&gt;</span>        <span class="tag">&lt;<span class="name">resource</span>&gt;</span>            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/webapp<span class="tag">&lt;/<span class="name">directory</span>&gt;</span>            <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>META-INF/resource<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span>            <span class="tag">&lt;<span class="name">includes</span>&gt;</span>                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span>            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span>        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span>    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span><span class="tag">&lt;/<span class="name">build</span>&gt;</span></code></pre><p>不过，我们一般会注册两个目录：还会注册dao包下的mybatis映射文件为资源目录</p><pre><code class="highlight xml"><span class="comment">&lt;!--注册dao包下mybatis映射文件为资源目录--&gt;</span><span class="tag">&lt;<span class="name">resource</span>&gt;</span>    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span>    <span class="tag">&lt;<span class="name">includes</span>&gt;</span>        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span>    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></code></pre><p><strong>创建welcome.jsp</strong></p><p>在webapp目录下再创建一个子目录jsp，在其中创建welcome.jsp文件。</p><p><strong>编写controller类</strong></p><p><strong>访问</strong></p><h4 id="3-使用逻辑视图"><a class="markdownIt-Anchor" href="#3-使用逻辑视图"></a> 3 使用逻辑视图</h4><p>修改主配置文件<code>application.properties</code></p><pre><code class="highlight properties"><span class="attr">spring.mvc.view.prefix</span>=<span class="string">/</span><span class="attr">spring.mvc.view.suffix</span>=<span class="string">.jsp</span></code></pre><p>修改Controller</p><blockquote><p><strong>关于静态资源请求</strong></p></blockquote><p>查看控制台的启动日志，DispatcherServlet的<url-pattern>为/。我们之前在学习SpringMVC时强调过，若DispatcherServlet的<url-pattern>为/，则中央调度器会拦截静态资源，即所有静态资源是无法访问的，若要访问，则需要再行配置。但，通过前面的运行可知，Spring Boot对于静态资源的访问是没有问题的。即，Spring Boot已经处理好了静态资源访问问题。</p><h3 id="mybatis"><a class="markdownIt-Anchor" href="#mybatis"></a> MyBatis</h3><p>在Spring Boot中使用MyBatis无需定义MyBatis的主配置文件，需要完成以下三个步骤：</p><ul><li>在pom文件中导入三个依赖：MyBatis与Spring Boot整合依赖、MySQL驱动依赖，及Druid依赖</li><li>在Spring Boot主配置文件中注册三个信息：映射文件、实体类别名，及数据源</li><li>在Dao接口上添加@Mapper注解</li></ul><p><strong>pom.xml依赖</strong></p><blockquote><p>注意，<code>spring boot与mybaits整合依赖</code>这个依赖是由mybatis开发，并非由Spring开发，所以这里需要指明版本号。因为父工程中没有定义该版本号。</p></blockquote><blockquote><p>注意，<code>mysql驱动依赖</code>该依赖要指定版本号，若不指定其也会从父工程中继承，但版本过高，代码运行</p></blockquote><pre><code class="highlight xml"><span class="comment">&lt;!--spring boot与mybaits整合依赖--&gt;</span> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> <span class="comment">&lt;!--mysql驱动依赖--&gt;</span> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>     <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> <span class="comment">&lt;!--阿里连接池--&gt;</span> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><p><strong>注册dao包下mybatis映射文件为资源目录</strong></p><pre><code class="highlight xml"><span class="comment">&lt;!--注册dao包下mybatis映射文件为资源目录--&gt;</span><span class="tag">&lt;<span class="name">build</span>&gt;</span>    <span class="tag">&lt;<span class="name">resource</span>&gt;</span>        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span>        <span class="tag">&lt;<span class="name">includes</span>&gt;</span>            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span>        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span>    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span><span class="tag">&lt;/<span class="name">build</span>&gt;</span></code></pre><p><strong>定义Service接口及实现类</strong></p><p>service接口</p><p>service实现类</p><p><strong>定义实体类和数据库表</strong></p><p>定义实体类</p><p>在DB的test数据库中定义student</p><p><strong>定义Dao接口和映射文件</strong></p><p>Dao接口上要添加@Mapper注解。</p><p>映射文件</p><p><strong>定义Controller</strong></p><p><strong>修改主配置文件</strong></p><ul><li>注册映射文件</li><li>注册实体类别名</li><li>注册数据源</li></ul><p><code>application.properties</code></p><pre><code class="highlight properties"><span class="comment"># 配置jsp的寻找路径 </span><span class="attr">spring.mvc.view.prefix</span>=<span class="string">/ </span><span class="attr">spring.mvc.view.suffix</span>=<span class="string">.jsp </span><span class="comment"></span><span class="comment">#注册映射文件</span><span class="attr">mybatis.mapper-locations</span>=<span class="string">classpath:com/abc/primary/dao/*.xml</span><span class="comment">#注册实体类别名</span><span class="attr">mybatis.type-aliases-package</span>=<span class="string">com.abc.primary.beans</span><span class="comment"></span><span class="comment"></span><span class="comment">#datasource数据源 </span><span class="attr">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver </span><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/lee_test?characterEncoding=UTF-8 </span><span class="attr">spring.datasource.username</span>=<span class="string">root </span><span class="attr">spring.datasource.password</span>=<span class="string">admin </span><span class="comment"></span><span class="comment"></span><span class="comment">#新增数据库链接必须的参数 </span><span class="attr">spring.jpa.properties.hibernate.hbm2ddl.auto</span>=<span class="string">update</span></code></pre><h3 id="对事务的支持"><a class="markdownIt-Anchor" href="#对事务的支持"></a> 对事务的支持</h3><p>Spring Boot对于事务的支持，只需完成两个步骤：</p><ul><li>在<strong>启动类</strong>上添加<code>@EnableTransactionManagement</code>注解，开启事务</li><li>在Service<strong>实现类</strong>的方法上添加<code>@Transactional</code>注解</li></ul><p><strong>修改启动类</strong></p><pre><code class="highlight java"><span class="meta">@SpringBootApplication</span><span class="meta">@EnableTransactionManagement</span>   <span class="comment">//开启事务</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootdemoApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(SpringbootdemoApplication.class, args);    &#125;&#125;</code></pre><p><strong>修改Service启动类</strong></p><pre><code class="highlight java"><span class="meta">@Service</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ISomeService</span> &#123;        <span class="meta">@Autowired</span>    <span class="keyword">private</span> IStudentDao dao;        <span class="meta">@Transactional</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span>&#123;        <span class="comment">//该插入会发生回滚，无法插入到db</span>        dao.insertStudent(student);        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span> / <span class="number">0</span>;      <span class="comment">//抛出异常语句</span>        dao.insertStudent(student);    &#125;&#125;</code></pre><p><strong>正常测试</strong></p><p>以上代码运行后，页面与代码均会显示报错，查看DB表，没有任何记录插入。</p><p><strong>对比测试</strong></p><p>将Service实现类中的@Transactional注解注释掉，再运行，页面与代码仍均会显示报错，但查看DB表，会发现插入了一条记录，即异常前的插入语句没有回滚。</p><h3 id="对日志的控制"><a class="markdownIt-Anchor" href="#对日志的控制"></a> 对日志的控制</h3><p>Spring Boot中使用的日志技术为logback。其与Log4J都出自同一人，性能要优于Log4J，是Log4J的替代者。</p><p>在Spring Boot中若要使用logback，则需要具有spring-boot-starter-logging依赖，而该依赖被spring-boot-starter-web所依赖，即不用直接导入spring-boot-starter-logging依赖。</p><p><strong>方式一：添加配置属性</strong></p><pre><code class="highlight properties"><span class="comment">#日志显示格式</span><span class="attr">logging.pattern.console</span>:<span class="string">%level %msg%n</span><span class="comment">#减少项目启动时的日志输出</span><span class="attr">logging.level.root</span>:<span class="string">warn</span><span class="comment">#显示Dao层执行的sql语句</span><span class="attr">logging.level.com.bjpowernode.primary.dao</span>:<span class="string">debug</span></code></pre><blockquote><p>注意，在日志显示格式的属性值前面的xxx:是随意内容。在yml文件中的属性值若以%开头会报错，所以添加一些随意字符。在properties文件中不存在该问题。</p></blockquote><p><strong>方式二：添加配置文件</strong></p><p>该文件名为logback.xml，且必须要放在src/main/resources类路径下。</p><pre><code class="highlight xml"><span class="meta">&lt;?xml version= <span class="string">&quot;1.0&quot;</span> encoding= <span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;myConsoLe&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoLeAppender&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span>            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%-5level - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span>        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span>    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span>    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;WARN&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;myConsole&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">root</span>&gt;</span>    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.bjpowernode.primary.dao&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></code></pre><p><strong>使用</strong></p><h3 id="redis"><a class="markdownIt-Anchor" href="#redis"></a> Redis</h3><p>使用Redis缓存的数据划分为两类：</p><ul><li>DB中相关表更新后，Redis缓存中的存放的相关数据要清除，否则客户端获取到的就不是最新数据，这是一类数据；</li><li>还有一类数据是，对数据的准确性要求不是很高的数据，其可以与DB中数据不一致，但差别不能太大，所以该类数据一般会设置过期时效。</li></ul><p>Spring Boot对于以上两类数据，均可使用API方式与注解方式进行缓存。但Spring Boot使用注解方式在对指定缓存空间设置缓存时效时非常麻烦，所以对于两类数据的缓存可以分别使用两种方式实现。</p><h4 id="注解详解"><a class="markdownIt-Anchor" href="#注解详解"></a> 注解详解</h4><h5 id="cacheable"><a class="markdownIt-Anchor" href="#cacheable"></a> @Cacheable</h5><p>@Cacheable可以标记在一个<strong>方法</strong>上，也可以标记在一个<strong>类</strong>上。当标记在一个方法上时表示该方法是<strong>支持缓存</strong>的，当标记在一个类上时则表示该类所有的方法都是支持缓存的。对于一个支持缓存的方法，<strong>Spring会在其被调用后将其返回值缓存起来，以保证下次利用同样的参数来执行该方法时可以直接从缓存中获取结果，而不需要再次执行该方法</strong>。Spring在缓存方法的返回值时是以键值对进行缓存的，值就是方法的返回结果，至于键的话，Spring又支持两种策略，默认策略和自定义策略，这个稍后会进行说明。需要注意的是当一个支持缓存的方法在对象内部被调用时是不会触发缓存功能的。@Cacheable可以指定三个属性，value、key和condition。</p><table><thead><tr><th>参数</th><th>解释</th><th>例子</th></tr></thead><tbody><tr><td>value</td><td>缓存的名称，在 spring 配置文件中定义，必须指定至少一个</td><td>例如: @Cacheable(value=”mycache”) @Cacheable(value={”cache1”,”cache2”}</td></tr><tr><td>key</td><td>缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合</td><td>@Cacheable(value=”testcache”,key=”#userName”)</td></tr><tr><td>condition</td><td>缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存</td><td><code>@Cacheable(value=”testcache”,condition=”#userName.length()&gt;2”)</code></td></tr></tbody></table><p><strong>value属性指定Cache名称</strong></p><p>value属性是必须指定的，其表示当前方法的返回值是会被缓存在哪个Cache上的，对应Cache的名称。其可以是一个Cache也可以是多个Cache，当需要指定多个Cache时其是一个数组。</p><pre><code class="highlight java"><span class="meta">@Cacheable(&quot;cache1&quot;)</span><span class="comment">//Cache是发生在cache1上的</span>   <span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(Integer id)</span> &#123;      returnnull;   &#125;  <span class="meta">@Cacheable(&#123;&quot;cache1&quot;, &quot;cache2&quot;&#125;)</span><span class="comment">//Cache是发生在cache1和cache2上的</span>   <span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(Integer id)</span> &#123;      returnnull;   &#125;</code></pre><p><strong>key使用示例</strong></p><p>key属性是用来指定Spring缓存方法的返回结果时对应的key的。该属性支持SpringEL表达式。当我们没有指定该属性时，Spring将使用默认策略生成key。我们这里先来看看自定义策略，至于默认策略会在后文单独介绍。<br />自定义策略是指我们可以通过Spring的EL表达式来指定我们的key。这里的EL表达式可以使用方法参数及它们对应的属性。使用方法参数时我们可以直接使用“#参数名”或者“#p参数index”。下面是几个使用参数作为key的示例。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">* key 是指传入时的参数</span><span class="comment">*</span><span class="comment">*/</span>   <span class="meta">@Cacheable(value=&quot;users&quot;, key=&quot;#id&quot;)</span>   <span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(Integer id)</span> &#123;      returnnull;   &#125;<span class="comment">// 表示第一个参数</span>  <span class="meta">@Cacheable(value=&quot;users&quot;, key=&quot;#p0&quot;)</span>   <span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(Integer id)</span> &#123;      returnnull;   &#125;<span class="comment">// 表示User中的id值</span>   <span class="meta">@Cacheable(value=&quot;users&quot;, key=&quot;#user.id&quot;)</span>   <span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(User user)</span> &#123;      returnnull;   &#125; <span class="comment">// 表示第一个参数里的id属性值</span>   <span class="meta">@Cacheable(value=&quot;users&quot;, key=&quot;#p0.id&quot;)</span>   <span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(User user)</span> &#123;      returnnull;   &#125;</code></pre><blockquote><p>除了上述使用方法参数作为key之外，Spring还为我们提供了一个root对象可以用来生成key。通过该root对象我们可以获取到以下信息。</p></blockquote><table><thead><tr><th>属性名称</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>methodName</td><td>当前方法名</td><td>#root.methodName</td></tr><tr><td>method</td><td>当前方法</td><td>#<a href="http://root.method.name">root.method.name</a></td></tr><tr><td>target</td><td>当前被调用的对象</td><td>#root.target</td></tr><tr><td>targetClass</td><td>当前被调用的对象的class</td><td>#root.targetClass</td></tr><tr><td>args</td><td>当前方法参数组成的数组</td><td>#root.args[0]</td></tr><tr><td>caches</td><td>当前被调用的方法使用的Cache</td><td>#root.caches[0].name</td></tr></tbody></table><blockquote><p>当我们要使用root对象的属性作为key时我们也可以将“#root”省略，因为Spring默认使用的就是root对象的属性</p></blockquote><p><strong>自定义key值的默认值</strong></p><pre><code class="highlight java"><span class="meta">@Configuration</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCacheConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;    <span class="comment">//自动生成key的结构，类名_方法名_参数值</span>    <span class="keyword">public</span> KeyGenerator <span class="title function_">keyGenerator</span><span class="params">()</span> &#123;        <span class="comment">//函数式接口的写法</span>        <span class="keyword">return</span> (target,method, params) -&gt;&#123;            <span class="comment">//获取注解所标方法所在的类名</span>            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> target.getClass().getName();            <span class="comment">//获取注解所标方法的方法名</span>            <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();            <span class="keyword">return</span> className+<span class="string">&quot;_&quot;</span>+methodName+<span class="string">&quot;_&quot;</span>+params[<span class="number">0</span>].toString();        &#125;;    &#125;&#125;</code></pre><p><strong>condition属性指定发生的条件</strong></p><p>有的时候我们可能并不希望缓存一个方法所有的返回结果。通过condition属性可以实现这一功能。condition属性默认为空，表示将缓存所有的调用情形。其值是通过SpringEL表达式来指定的，当为true时表示进行缓存处理；当为false时表示不进行缓存处理，即每次调用该方法时该方法都会执行一次。如下示例表示只有当user的id为偶数时才会进行缓存</p><pre><code class="highlight java"><span class="comment">// 根据条件判断是否缓存</span> <span class="meta">@Cacheable(value=&#123;&quot;users&quot;&#125;, key=&quot;#user.id&quot;, condition=&quot;#user.id%2==0&quot;)</span><span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(User user)</span> &#123;   System.out.println(<span class="string">&quot;find user by user &quot;</span> + user);   <span class="keyword">return</span> user;&#125;</code></pre><h5 id="cacheput"><a class="markdownIt-Anchor" href="#cacheput"></a> @CachePut</h5><p>在支持Spring Cache的环境下，对于使用@Cacheable标注的方法，Spring在每次执行前都会检查Cache中是否存在相同key的缓存元素，如果存在就不再执行该方法，而是直接从缓存中获取结果进行返回，否则才会执行并将返回结果存入指定的缓存中。@CachePut也可以声明一个方法支持缓存功能。<strong>与@Cacheable不同的是使用@CachePut标注的方法在执行前不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中</strong></p><pre><code class="highlight java"><span class="comment">//@CachePut也可以标注在类上和方法上。使用@CachePut时我们可以指定的属性跟@Cacheable是一样的。</span>   <span class="meta">@CachePut(&quot;users&quot;)</span><span class="comment">//每次都会执行方法，并将结果存入指定的缓存中</span>   <span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(Integer id)</span> &#123;      returnnull;   &#125;</code></pre><h5 id="cacheevict"><a class="markdownIt-Anchor" href="#cacheevict"></a> @CacheEvict</h5><p>@CacheEvict是用来标注在需要清除缓存元素的方法或类上的。当标记在一个类上时表示其中所有的方法的<strong>执行都会触发缓存的清除操作</strong>。@CacheEvict可以指定的属性有value、key、condition、allEntries和beforeInvocation。其中value、key和condition的语义与@Cacheable对应的属性类似。即<strong>value表示清除操作是发生在哪些Cache上的</strong>（对应Cache的名称）；<strong>key表示需要清除的是哪个key</strong>，如未指定则会使用默认策略生成的key；condition表示清除操作发生的条件。下面我们来介绍一下新出现的两个属性allEntries和beforeInvocation。</p><p><strong>allEntries属性</strong></p><p>allEntries是boolean类型，表示是否需要清除缓存中的所有元素。默认为false，表示不需要。当指定了allEntries为true时，Spring Cache将忽略指定的key。有的时候我们需要Cache一下清除所有的元素，这比一个一个清除元素更有效率。</p><pre><code class="highlight java"><span class="meta">@CacheEvict(value=&quot;users&quot;, allEntries=true)</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;    System.out.println(<span class="string">&quot;delete user by id: &quot;</span> + id);&#125;</code></pre><p><strong>beforeInvocation属性</strong></p><p>清除操作默认是在对应方法成功执行之后触发的，即方法如果因为抛出异常而未能成功返回时也不会触发清除操作。使用beforeInvocation可以改变触发清除操作的时间，当我们指定该属性值为true时，Spring会在调用该方法之前清除缓存中的指定元素。</p><pre><code class="highlight java"><span class="meta">@CacheEvict(value=&quot;users&quot;, beforeInvocation=true)</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;   System.out.println(<span class="string">&quot;delete user by id: &quot;</span> + id);&#125;</code></pre><h5 id="caching"><a class="markdownIt-Anchor" href="#caching"></a> @Caching</h5><p>@Caching注解可以让我们在一个方法或者类上同时指定多个Spring Cache相关的注解。其拥有三个属性：cacheable、put和evict，分别用于指定@Cacheable、@CachePut和@CacheEvict。</p><pre><code class="highlight java"><span class="meta">@Caching(cacheable = @Cacheable(&quot;users&quot;), evict = &#123; @CacheEvict(&quot;cache2&quot;),</span><span class="meta">@CacheEvict(value = &quot;cache3&quot;, allEntries = true) &#125;)</span><span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(Integer id)</span> &#123;  returnnull;&#125;</code></pre><h4 id="总步骤"><a class="markdownIt-Anchor" href="#总步骤"></a> 总步骤</h4><p>（1） <strong>都需要的步骤</strong></p><ul><li>在pom文件中添加spring boot与redis整合依赖</li><li>在主配置文件中注册redis连接信息、MyBatis中实体类的别名</li><li>由于要将查询的实体类对象缓存到Redis，Redis要求实体类必须序列化。所以需要实体类实现序列化接口</li></ul><p>（2） <strong>使用注解方式还需要的步骤</strong></p><ul><li>在工程入口类上添加<code>@EnableCaching</code>注解</li><li>在查询方法上添加<code>@Cacheable</code>注解，在增删改方法上添加<code>@CacheEvict</code>注解</li><li>在主配置文件中注册缓存空间名称</li></ul><p>（3） <strong>使用API方式还需要的步骤</strong></p><ul><li>Service中被自动注入的RedisTemplate需要的泛型，key与value要求类型相同，要么都是String，要么都是Object。建议使用Object，其通用性更好</li><li>在Service的查询方法中通过RedisTemplate对象获取到Redis的操作对象，然后再对Redis进行读写操作</li></ul><h4 id="依赖配置"><a class="markdownIt-Anchor" href="#依赖配置"></a> 依赖/配置</h4><p><strong>pom依赖</strong></p><p>在pom中添加spring boot与Redis整合依赖</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><p><strong>修改主配置文件</strong></p><pre><code class="highlight properties"><span class="comment">#连接单机Redis</span><span class="attr">spring.redis.host</span>=<span class="string">osRedis</span><span class="attr">spring.redis.port</span>=<span class="string">6379</span><span class="attr">spring.redis.password</span>=<span class="string">111</span><span class="comment">#连接redis高可用集群</span><span class="comment">#spring.redis.sentinel.master=mymaster</span><span class="comment">#spring.redis.sentinel.nodes=sentinel1:26379,sentinel2:26379,sentinel3:26379</span><span class="comment"></span><span class="comment">#开启缓存，指定cache类型</span><span class="attr">spring.cache.type</span>=<span class="string">redis</span><span class="comment">#缓存区域名</span><span class="attr">spring.cache.cache-names</span>=<span class="string">realTimeCache</span></code></pre><h4 id="类编写"><a class="markdownIt-Anchor" href="#类编写"></a> 类编写</h4><p>当前工程完成让用户在页面中输入要查询学生的id，其首先会查看Redis缓存中是否存在，若存在，则直接从Redis中读取；若不存在，则先从DB中查询出来，然后再存放到Redis缓存中。但用户也可以通过页面注册学生，一旦有新的学生注册，则需要将缓存中的学生信息清空。根据id查询出的学生信息要求必须是实时性的，其适合使用注解方式的Redis缓存。</p><p>同时，通过页面还可以查看到总学生数，但对其要求是差不多就行，无需是实时性的。对于Spring Boot工程，其适合使用API方式的Redis缓存，该方式方便设置缓存的到期时限。</p><p><strong>工程入口类添加@EnableCaching注解</strong></p><pre><code class="highlight java"><span class="meta">@SpringBootApplication</span><span class="meta">@EnableCaching</span>          <span class="comment">//开启缓存</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootwarApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(SpringbootwarApplication.class, args);    &#125;&#125;</code></pre><p><strong>修改实体类Student</strong></p><p>由于要将查询的实体类对象缓存到Redis，Redis要求实体类必须<strong>序列化</strong>。所以需要实体类实现序列化接口</p><p><strong>修改index页面</strong></p><p><strong>修改Controller</strong><br />在其中添加两个处理器方法。</p><p><strong>修改Service接口</strong></p><p><strong>修改Service实现类</strong>注解方式</p><ul><li>在<strong>查询方法上</strong>添加@<strong>Cacheable</strong>注解，在<strong>增删改方法</strong>上添加@<strong>CacheEvict</strong>注解</li><li>value值为 在主配置文件中注册缓存空间名称</li></ul><blockquote><p>@Cacheable会先用&quot;student_id&quot;从缓存中查询，如果有值，则直接返回，不会调用方法内部的语句</p></blockquote><blockquote><p>@CacheEvict会清掉realTimeCache缓存空间中的所有值（allEntries=true表示所有）</p></blockquote><blockquote><p>所以建议尽量让缓存空间小，一个表对应一个缓存空间</p></blockquote><p><strong>修改Service实现类</strong>代码方式</p><p><em>count数据并不需要实时的更新，只需要确保它相对准确就可以</em></p><blockquote><p>只要我们为一个缓存设置了缓存时间，就要考虑热点缓存问题（即时间到期后会有大量的并发访问该条记录）</p></blockquote><blockquote><p>我们可以用双重检测机制防止解决热点缓存</p></blockquote><p>redisTemplate对象我们直接注入就可以：</p><p>双重检测锁：</p><blockquote><p>这里使用<strong>synchronized的前提是该类是单例</strong>，因为我们的类都交给了spring管理，所以是单例的</p></blockquote><p><strong>修改Dao接口</strong></p><p><strong>修改映射文件</strong></p><h4 id="启动redis"><a class="markdownIt-Anchor" href="#启动redis"></a> 启动Redis</h4><p><strong>启动redis</strong></p><p><strong>启动Redis集群</strong><br />该示例需要启动三台Redis主机，三台Redis哨兵主机。</p><p>逐台启动三台Redis主机，即启动Redis</p><p><strong>登录Redis</strong><br />逐台登录三台Redis</p><p><strong>查看Redis角色</strong></p><p>逐台查看Redis的角色。</p><p><strong>启动sentinel集群</strong><br />逐台启动三台Sentinel主机，即启动Sentinel集群。</p><h3 id="拦截器"><a class="markdownIt-Anchor" href="#拦截器"></a> 拦截器</h3><p>在非Spring Boot工程中若要使用SpringMVC的拦截器，在定义好拦截器后，需要在Spring配置文件中对其进行注册。但Spring Boot工程中没有了Spring配置文件，那么如何使用拦截器呢？</p><p>Spring Boot对于原来在配置文件配置的内容，现在全部体现在一个类中，该类需要继承自WebMvcConfigurationSupport类，并使用@Configuration进行注解，表示该类为一个JavaConfig/CodeConfig类，其充当配置文件的角色。</p><p><strong>定义拦截器</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,Object handler)</span> <span class="keyword">throws</span> Exception&#123;        System.out.println(<span class="string">&quot;执行拦截器&quot;</span> + request.getRequestURI());        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;&#125;</code></pre><p><strong>定义处理器</strong></p><p><strong>定义配置文件类</strong></p><ul><li><code>*表示只有一级目录，**表示后面所有的目录</code></li></ul><pre><code class="highlight java"><span class="comment">//表示该文件相当于配置文件</span><span class="meta">@Configuration</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span>&#123;        SomeInterceptor si= <span class="keyword">new</span> <span class="title class_">SomeInterceptor</span>();        <span class="comment">//拦截first开头的路径，不拦截second开头的路径</span>        registry.addInterceptor(si).addPathPatterns(<span class="string">&quot;/first/**&quot;</span>).excludePathPatterns(<span class="string">&quot;/second/**&quot;</span>);    &#125;&#125;</code></pre><h3 id="servlet"><a class="markdownIt-Anchor" href="#servlet"></a> Servlet</h3><p>在Spring Boot中使用Servlet，根据Servlet注册方式的不同，有两种使用方式。若使用的Servlet3.0+版本，则两种方式均可使用；若使用的是Servlet2.5版本，则只能使用配置</p><h4 id="注解方式"><a class="markdownIt-Anchor" href="#注解方式"></a> 注解方式</h4><p>若使用的是Servlet3.0+版本，可以直接使用Servlet的注解对Servlet进行注册。其总步骤有两步：</p><ul><li>在定义好的Servlet上使用<code>@WebServlet</code>注解</li><li>在入口类上添加<code>@ServletComponentScan</code>注解</li></ul><p><strong>创建Servlet</strong><br />这里在创建Servlet时需要注意，不能直接使用Eclipse中的向导直接创建Servlet，无法创建。需要通过创建一个class，让其继承自HttpServlet方式创建。然后在Servlet上添加@WebServlet注解。</p><p><strong>修改入口类</strong></p><p>在入口类中添加Servlet扫描注解。</p><h4 id="配置类方式"><a class="markdownIt-Anchor" href="#配置类方式"></a> 配置类方式</h4><p>若使用的是Servlet2.5版本，没有Servlet注解，此时只能使用配置类方式。其总步骤有两步，无需在入口类上添加@ServletComponentScan注解。</p><ul><li>定义Servlet</li><li>定义配置类</li></ul><p><strong>定义Servlet</strong></p><p><strong>定义配置类</strong></p><h3 id="filter过滤器"><a class="markdownIt-Anchor" href="#filter过滤器"></a> Filter过滤器</h3><p>在Spring Boot中使用Filter与前面的使用Servlet相似，根据Filter注册方式的不同，有两种使用方式。若使用的是Servlet3.0+版本，则两种方式均可使用；若使用的是Servlet2.5版本，则只能使用配置类方式。</p><h4 id="注解方式-2"><a class="markdownIt-Anchor" href="#注解方式-2"></a> 注解方式</h4><p>若使用的是Servlet3.0+版本，可以直接使用Filter的注解对Filter进行注册。其总步骤有两步：</p><ul><li>在定义好的Filter上使用<code>@WebFilter</code>注解</li><li>在入口类上添加<code>@ServletComponentScan</code>注解</li></ul><p><strong>创建Filter</strong><br />这里在创建Filter时需要注意，不能直接使用Eclipse中的向导直接创建Filter，无法创建。需要通过创建一个class，让其实现Filter接口方式创建。然后在Filter上添加@WebFilter注解。</p><p><strong>修改入口类</strong><br />在@ServletComponentScan注解中注册Filter所在的包，当然，Spring Boot支持通配符的使用。</p><h4 id="配置类方式-2"><a class="markdownIt-Anchor" href="#配置类方式-2"></a> 配置类方式</h4><p>若使用的是Servlet2.5版本，没有Filter注解，此时只能使用配置类方式。其总步骤有两步，与@ServletComponentScan注解无关。</p><ul><li>定义Filter</li><li>定义配置类</li></ul><p><strong>定义Filter</strong></p><p><strong>修改配置类</strong><br />在配置类中添加如下方法</p><h2 id="持久层支持"><a class="markdownIt-Anchor" href="#持久层支持"></a> 持久层支持</h2><h3 id="jpa"><a class="markdownIt-Anchor" href="#jpa"></a> JPA</h3><p>JPA（Java persistence API）是Sun官方提出的Java持久化规范，用来方便大家操作数据库。</p><p>真正干活的可能是hibernate，tomlink等等实现了JPA规范的不同的厂商</p><h4 id="数据库准备"><a class="markdownIt-Anchor" href="#数据库准备"></a> 数据库准备</h4><p>创建表</p><pre><code class="highlight sql">use lee_test;<span class="keyword">CREATE TABLE</span> category (  id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT,  name <span class="type">varchar</span>(<span class="number">30</span>),  <span class="keyword">PRIMARY KEY</span> (id)) <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>UTF8;</code></pre><p>准备数据</p><pre><code class="highlight sql"><span class="keyword">insert into</span> category <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;category 1&#x27;</span>);<span class="keyword">insert into</span> category <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;category 2&#x27;</span>);<span class="keyword">insert into</span> category <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;category 3&#x27;</span>);<span class="keyword">insert into</span> category <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;category 4&#x27;</span>);</code></pre><h4 id="applicationproperties"><a class="markdownIt-Anchor" href="#applicationproperties"></a> application.properties</h4><pre><code class="highlight properties"><span class="comment"># 配置jsp的寻找路径</span><span class="attr">spring.mvc.view.prefix</span>=<span class="string">/WEB-INF/jsp/</span><span class="attr">spring.mvc.view.suffix</span>=<span class="string">.jsp</span><span class="comment">#更改tomcat默认端口号</span><span class="attr">server.port</span>=<span class="string">8088</span><span class="comment">#更改访问上下文路径/访问路径 localhost:8088/leeBoot/...</span><span class="attr">server.context-path</span>=<span class="string">/leeBoot</span><span class="comment"></span><span class="comment">#datasource数据源</span><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/lee_test?characterEncoding=UTF-8</span><span class="attr">spring.datasource.username</span>=<span class="string">root</span><span class="attr">spring.datasource.password</span>=<span class="string">admin</span><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span><span class="comment">#新增数据库链接必须的参数</span><span class="attr">spring.jpa.properties.hibernate.hbm2ddl.auto</span>=<span class="string">update</span></code></pre><h4 id="pomxml"><a class="markdownIt-Anchor" href="#pomxml"></a> pom.xml</h4><p>增加对MySQL和 jpa的支持</p><pre><code class="highlight xml"><span class="comment">&lt;!-- mysql--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!-- jpa--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h4 id="实体类"><a class="markdownIt-Anchor" href="#实体类"></a> 实体类</h4><ul><li><code>@Entity</code> 注解表示这是个实体类</li><li><code>@Table(name = &quot;category&quot;)</code> 表示这个类对应的表名是 category_ ，注意有下划线哦</li><li><code>@Id</code> 表明主键</li><li><code>@GeneratedValue(strategy = GenerationType.IDENTITY)</code> 表明自增长方式</li><li><code>@Column(name = &quot;id&quot;)</code> 表明对应的数据库字段名</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.pojo;<span class="keyword">import</span> javax.persistence.*;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/7/5.</span><span class="comment"> */</span><span class="comment">//表示这是个实体类</span><span class="meta">@Entity</span><span class="comment">//表示这个实体类对应的表为category</span><span class="meta">@Table(name=&quot;category&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Category</span> &#123;    <span class="comment">//表明主键</span>    <span class="meta">@Id</span>    <span class="comment">//表示自增长方式</span>    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>    <span class="comment">//表示对应的数据库字段名</span>    <span class="meta">@Column(name=&quot;id&quot;)</span>    <span class="keyword">private</span> <span class="type">int</span> id;    <span class="meta">@Column(name=&quot;name&quot;)</span>    <span class="keyword">private</span> String name;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;&#125;</code></pre><h4 id="dao"><a class="markdownIt-Anchor" href="#dao"></a> DAO</h4><p>创建dao接口CategoryDAO，继承了JpaRespository，并且提供泛型&lt;Category,Integer&gt;表示这个是针对Category类的DAO，Integer表示主键是Integer类型</p><p>JpaRespository这个父接口，就提供了CRUD，分页等等一系列的查询了，直接拿来用</p><p><strong>JpaRespository</strong>是一个接口，<code>org.springframework.data.jpa.repository.support</code>包有一个实现类<strong>SimpleJpaRepository</strong>，会纳入spring bean管理，所以所有继承了该接口的Dao类，实际传入的对象都是该实现类对象</p><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.dao;<span class="keyword">import</span> com.leeboer.springboot.pojo.Category;<span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/7/5.</span><span class="comment"> */</span><span class="comment">//泛型&lt;Category,Integer&gt; 表示这个是针对Category类的DAO,Integer表示主键是Integer类型</span><span class="comment">//JpaRepository 这个父接口，就提供了CRUD, 分页等等一系列的查询了，直接拿来用，都不需要二次开发的了</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CategoryDAO</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Category,Integer&gt; &#123;&#125;</code></pre><h4 id="controller"><a class="markdownIt-Anchor" href="#controller"></a> Controller</h4><p>创建CategoryController 类</p><pre><code>1. 接受listCategory映射2. 然后获取所有的分类数据3. 接着放入Model中4. 跳转到listCategory.jsp中</code></pre><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.web;<span class="keyword">import</span> com.leeboer.springboot.dao.CategoryDAO;<span class="keyword">import</span> com.leeboer.springboot.pojo.Category;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.stereotype.Controller;<span class="keyword">import</span> org.springframework.ui.Model;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/7/5.</span><span class="comment"> */</span><span class="meta">@Controller</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryController</span> &#123;    <span class="meta">@Autowired</span>    CategoryDAO categoryDAO;    <span class="meta">@RequestMapping(&quot;/listCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">listCategory</span><span class="params">(Model model)</span>&#123;        List&lt;Category&gt; list = categoryDAO.findAll();        <span class="keyword">for</span>(Category c:list)&#123;            System.out.println(c.getName());        &#125;        model.addAttribute(<span class="string">&quot;cs&quot;</span>,list);        <span class="keyword">return</span> <span class="string">&quot;listCategory&quot;</span>;    &#125;&#125;</code></pre><h4 id="jsp-2"><a class="markdownIt-Anchor" href="#jsp-2"></a> JSP</h4><pre><code class="highlight html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;   <span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">&#x27;center&#x27;</span> <span class="attr">border</span>=<span class="string">&#x27;1&#x27;</span> <span class="attr">cellspacing</span>=<span class="string">&#x27;0&#x27;</span>&gt;</span>    <span class="tag">&lt;<span class="name">tr</span>&gt;</span>        <span class="tag">&lt;<span class="name">td</span>&gt;</span>id<span class="tag">&lt;/<span class="name">td</span>&gt;</span>        <span class="tag">&lt;<span class="name">td</span>&gt;</span>name<span class="tag">&lt;/<span class="name">td</span>&gt;</span>    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>    <span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">items</span>=<span class="string">&quot;$&#123;cs&#125;&quot;</span> <span class="attr">var</span>=<span class="string">&quot;c&quot;</span> <span class="attr">varStatus</span>=<span class="string">&quot;st&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">tr</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;c.id&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;c.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span>                        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>    <span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></code></pre><h4 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h4><pre><code class="highlight plaintext">http://127.0.0.1:8088/leeBoot/listCategory</code></pre><h3 id="mybatis-注解方式"><a class="markdownIt-Anchor" href="#mybatis-注解方式"></a> MyBatis-注解方式</h3><h4 id="applicationproperties-2"><a class="markdownIt-Anchor" href="#applicationproperties-2"></a> application.properties</h4><pre><code class="highlight properties"><span class="comment"># 配置jsp的寻找路径</span><span class="attr">spring.mvc.view.prefix</span>=<span class="string">/WEB-INF/jsp/</span><span class="attr">spring.mvc.view.suffix</span>=<span class="string">.jsp</span><span class="comment">#更改tomcat默认端口号</span><span class="attr">server.port</span>=<span class="string">8088</span><span class="comment">#更改访问上下文路径/访问路径 localhost:8088/leeBoot/...</span><span class="attr">server.context-path</span>=<span class="string">/leeBoot</span><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/lee_test?characterEncoding=UTF-8</span><span class="attr">spring.datasource.username</span>=<span class="string">root</span><span class="attr">spring.datasource.password</span>=<span class="string">admin</span><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span><span class="comment">#新增数据库链接必须的参数（jpa方式要加，mybatis方式不用加）</span><span class="comment">#spring.jpa.properties.hibernate.hbm2ddl.auto=update</span></code></pre><h4 id="pomxml-2"><a class="markdownIt-Anchor" href="#pomxml-2"></a> pom.xml</h4><p>增加对MySQL和mybatis的支持</p><pre><code class="highlight xml"><span class="comment">&lt;!-- mysql--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!-- mybatis --&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h4 id="mapper"><a class="markdownIt-Anchor" href="#mapper"></a> Mapper</h4><p>其他与JPA方式相同，只需把dao改为Mapper即可</p><p>使用注解@Mapper表示这是一个Mybatis Mapper接口<br />使用@Select注解表示调用findAll方法会执行对应的sql语句</p><blockquote><p><strong>在工程主类application.java 上面添加注解<code>@MapperScan(&quot;com.leeboer.springboot.mapper&quot;)</code>，这样就可以省去在每个接口Mapper中添加<code>@Mapper</code>注解</strong></p></blockquote><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.dao;<span class="comment">/**</span><span class="comment"> * mybatis方式</span><span class="comment"> */</span><span class="keyword">import</span> com.leeboer.springboot.pojo.Category;<span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;<span class="keyword">import</span> org.apache.ibatis.annotations.Select;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/7/5.</span><span class="comment"> */</span><span class="meta">@Mapper</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CategoryMapper</span> &#123;    <span class="meta">@Select(&quot;select * from category&quot;)</span>    List&lt;Category&gt; <span class="title function_">findAll</span><span class="params">()</span>;&#125;</code></pre><h4 id="测试-2"><a class="markdownIt-Anchor" href="#测试-2"></a> 测试</h4><p>测试会发现，两种方式的执行效果相同</p><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.web;<span class="keyword">import</span> com.leeboer.springboot.dao.CategoryDAO;<span class="keyword">import</span> com.leeboer.springboot.dao.CategoryMapper;<span class="keyword">import</span> com.leeboer.springboot.pojo.Category;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.stereotype.Controller;<span class="keyword">import</span> org.springframework.ui.Model;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/7/5.</span><span class="comment"> */</span><span class="meta">@Controller</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryController</span> &#123;    <span class="comment">//jpa方式</span>    <span class="meta">@Autowired</span>    CategoryDAO categoryDAO;    <span class="comment">//Mapper方式</span>    <span class="meta">@Autowired</span>    CategoryMapper categoryMapper;    <span class="meta">@RequestMapping(&quot;/listCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">listCategory</span><span class="params">(Model model)</span>&#123;        List&lt;Category&gt; list = categoryDAO.findAll();        List&lt;Category&gt; list2 = categoryMapper.findAll();        <span class="keyword">for</span>(Category c:list2)&#123;            System.out.println(c.getName());        &#125;        model.addAttribute(<span class="string">&quot;cs&quot;</span>,list2);        <span class="keyword">return</span> <span class="string">&quot;listCategory&quot;</span>;    &#125;&#125;</code></pre><h3 id="mybatis-xml方式"><a class="markdownIt-Anchor" href="#mybatis-xml方式"></a> MyBatis-xml方式</h3><p>基于上一个例子的基础上</p><h4 id="categorymapper"><a class="markdownIt-Anchor" href="#categorymapper"></a> CategoryMapper</h4><pre><code class="highlight java"><span class="keyword">import</span> java.util.List; <span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;<span class="keyword">import</span> org.apache.ibatis.annotations.Select; <span class="keyword">import</span> com.how2java.springboot.pojo.Category; <span class="meta">@Mapper</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CategoryMapper</span> &#123;     List&lt;Category&gt; <span class="title function_">findAll</span><span class="params">()</span>; &#125;</code></pre><h4 id="categoryxml"><a class="markdownIt-Anchor" href="#categoryxml"></a> Category.xml</h4><p>在Mapper类旁边，新增加Category.xml文件</p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span><span class="meta">    <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="meta">    <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>      <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.leeboer.springboot.mapper.CategoryMapper&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Category&quot;</span>&gt;</span>            select * from category        <span class="tag">&lt;/<span class="name">select</span>&gt;</span>       <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></code></pre><h4 id="applicationproperties-3"><a class="markdownIt-Anchor" href="#applicationproperties-3"></a> application.properties</h4><pre><code class="highlight properties"><span class="comment"># 配置jsp的寻找路径</span><span class="attr">spring.mvc.view.prefix</span>=<span class="string">/WEB-INF/jsp/</span><span class="attr">spring.mvc.view.suffix</span>=<span class="string">.jsp</span><span class="comment">#更改tomcat默认端口号</span><span class="attr">server.port</span>=<span class="string">8088</span><span class="comment">#更改访问上下文路径/访问路径 localhost:8088/leeBoot/...</span><span class="attr">server.context-path</span>=<span class="string">/leeBoot</span><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/lee_test?characterEncoding=UTF-8</span><span class="attr">spring.datasource.username</span>=<span class="string">root</span><span class="attr">spring.datasource.password</span>=<span class="string">admin</span><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span><span class="comment">#新增数据库链接必须的参数（jpa方式要加，mybatis方式不用加）</span><span class="comment">#spring.jpa.properties.hibernate.hbm2ddl.auto=update</span><span class="comment"></span><span class="comment">#mybaits基于注解要额外加两条配置</span><span class="attr">mybatis.mapper-locations</span>=<span class="string">classpath:com/leeboer/springboot/mapper/*.xml</span><span class="attr">mybatis.type-aliases-package</span>=<span class="string">com.leeboer.springboot.pojo</span></code></pre><h4 id="测试-3"><a class="markdownIt-Anchor" href="#测试-3"></a> 测试</h4><p>调用方法与抢两个类似，不在概述</p><h2 id="crud分页"><a class="markdownIt-Anchor" href="#crud分页"></a> CRUD/分页</h2><h3 id="jpa-2"><a class="markdownIt-Anchor" href="#jpa-2"></a> JPA</h3><p>该种方式实现分页无需修改其他代码，只需在<code>controller</code>层增加相应响应即可，因为<code>CategoryDao</code>实现了<code>JpaRepository</code>接口，该接口的实现类<code>SimpleJpaRepository</code>基本实现了要用的所有方法</p><h4 id="controller-2"><a class="markdownIt-Anchor" href="#controller-2"></a> Controller</h4><p>Sort：表示一个排序对象，设置倒排序</p><pre><code class="highlight java"><span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sort</span>(Sort.Direction.DESC, <span class="string">&quot;id&quot;</span>);</code></pre><p>Pageable：分页对象</p><pre><code class="highlight java"><span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageRequest</span>(start, size, sort);</code></pre><p>CategoryDAO通过分页对象获取结果page</p><pre><code class="highlight java">Page&lt;Category&gt; page =categoryDAO.findAll(pageable);</code></pre><blockquote><p>在这个page对象里，不仅包含了分页信息，还包含了数据信息，即有哪些分类数据。 这个可以通过getContent()获取出来</p></blockquote><p>CategoryController.java</p><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.web;<span class="keyword">import</span> com.leeboer.springboot.Mapper.CategoryMapper;<span class="keyword">import</span> com.leeboer.springboot.dao.CategoryDAO;<span class="keyword">import</span> com.leeboer.springboot.pojo.Category;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.data.domain.Page;<span class="keyword">import</span> org.springframework.data.domain.PageRequest;<span class="keyword">import</span> org.springframework.data.domain.Pageable;<span class="keyword">import</span> org.springframework.data.domain.Sort;<span class="keyword">import</span> org.springframework.stereotype.Controller;<span class="keyword">import</span> org.springframework.ui.Model;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/7/5.</span><span class="comment"> */</span><span class="meta">@Controller</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryController</span> &#123;    <span class="comment">//jpa方式</span>    <span class="meta">@Autowired</span>    CategoryDAO categoryDAO;    <span class="comment">//Mapper方式</span>    <span class="meta">@Autowired</span>    CategoryMapper categoryMapper;    <span class="meta">@RequestMapping(&quot;/listCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">listCategory</span><span class="params">(Model model,<span class="meta">@RequestParam(value = &quot;start&quot;, defaultValue = &quot;0&quot;)</span> <span class="type">int</span> start,<span class="meta">@RequestParam(value = &quot;size&quot;, defaultValue = &quot;5&quot;)</span> <span class="type">int</span> size)</span>&#123;        <span class="comment">//分页</span>        <span class="comment">//如果首页开始坐标小于0则返回0</span>        start = start&lt;<span class="number">0</span>?<span class="number">0</span>:start;        <span class="comment">//设置倒序排序</span>        <span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sort</span>(Sort.Direction.DESC, <span class="string">&quot;id&quot;</span>);        <span class="comment">//根据start,size,sort创建分页对象</span>        <span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageRequest</span>(start, size, sort);        <span class="comment">//dao根据分页对象获取结果page</span>        <span class="comment">//在这个page对象里，不仅包含了分页信息，还包含了数据信息，即有哪些分类数据。 这个可以通过getContent()获取出来</span>        Page&lt;Category&gt; page =categoryDAO.findAll(pageable);        model.addAttribute(<span class="string">&quot;page&quot;</span>, page);        <span class="keyword">return</span> <span class="string">&quot;listCategory&quot;</span>;    &#125;    <span class="comment">//增</span>    <span class="meta">@RequestMapping(&quot;/addCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">addCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryDAO.save(c);<span class="comment">//JPA 新增和修改用的都是save. 它根据实体类的id是否为0来判断是进行增加还是修改</span>        <span class="keyword">return</span> <span class="string">&quot;redirect:listCategory&quot;</span>;    &#125;    <span class="comment">//删</span>    <span class="meta">@RequestMapping(&quot;/deleteCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">deleteCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryDAO.delete(c);        <span class="keyword">return</span> <span class="string">&quot;redirect:listCategory&quot;</span>;    &#125;    <span class="comment">//改</span>    <span class="meta">@RequestMapping(&quot;/updateCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">updateCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryDAO.save(c);<span class="comment">//JPA 新增和修改用的都是save. 它根据实体类的id是否为0来判断是进行增加还是修改</span>        <span class="keyword">return</span> <span class="string">&quot;redirect:listCategory&quot;</span>;    &#125;    <span class="comment">//查</span>    <span class="meta">@RequestMapping(&quot;/editCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">editCategory</span><span class="params">(<span class="type">int</span> id,Model m)</span> <span class="keyword">throws</span> Exception &#123;        Category c= categoryDAO.getOne(id);        m.addAttribute(<span class="string">&quot;c&quot;</span>, c);        <span class="keyword">return</span> <span class="string">&quot;editCategory&quot;</span>;    &#125;&#125;</code></pre><h4 id="jsp-3"><a class="markdownIt-Anchor" href="#jsp-3"></a> jsp</h4><p>通过page.getContent遍历当前页面的Category对象</p><p>在分页的时候通过page.number获取当前页面，page.totalPages获取总页面数</p><blockquote><p>page.getContent会返回一个泛型是Category的集合</p></blockquote><p>listCategory.jsp</p><pre><code class="highlight html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;         pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:500px;margin:20px auto;text-align: center&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">&#x27;center&#x27;</span> <span class="attr">border</span>=<span class="string">&#x27;1&#x27;</span> <span class="attr">cellspacing</span>=<span class="string">&#x27;0&#x27;</span>&gt;</span>        <span class="tag">&lt;<span class="name">tr</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>id<span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>name<span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">td</span>&gt;</span>        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>        <span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">items</span>=<span class="string">&quot;$&#123;page.content&#125;&quot;</span> <span class="attr">var</span>=<span class="string">&quot;c&quot;</span> <span class="attr">varStatus</span>=<span class="string">&quot;st&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">tr</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;c.id&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;c.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;editCategory?id=$&#123;c.id&#125;&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;deleteCategory?id=$&#123;c.id&#125;&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>        <span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span>    <span class="tag">&lt;/<span class="name">table</span>&gt;</span>    <span class="tag">&lt;<span class="name">br</span>&gt;</span>    <span class="tag">&lt;<span class="name">div</span>&gt;</span>        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=0&quot;</span>&gt;</span>[首  页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=$&#123;page.number-1&#125;&quot;</span>&gt;</span>[上一页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=$&#123;page.number+1&#125;&quot;</span>&gt;</span>[下一页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=$&#123;page.totalPages-1&#125;&quot;</span>&gt;</span>[末  页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>    <span class="tag">&lt;<span class="name">br</span>&gt;</span>    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;addCategory&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span>        name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span>        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span>    <span class="tag">&lt;/<span class="name">form</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><p>editCategory.jsp</p><pre><code class="highlight html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isELIgnored=&quot;false&quot;%&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin:0px auto; width:500px&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;updateCategory&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span> name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;c.name&#125;&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;c.id&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;/<span class="name">form</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><h3 id="mybatis-2"><a class="markdownIt-Anchor" href="#mybatis-2"></a> MyBatis</h3><h4 id="pomxml-3"><a class="markdownIt-Anchor" href="#pomxml-3"></a> pom.xml</h4><p>增加对PageHelper的支持</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h4 id="pagehelperconfig"><a class="markdownIt-Anchor" href="#pagehelperconfig"></a> PageHelperConfig</h4><p>添加一个类PageHelperConfig ，其中进行PageHelper相关配置</p><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.config;<span class="keyword">import</span> java.util.Properties;<span class="keyword">import</span> org.springframework.context.annotation.Bean;<span class="keyword">import</span> org.springframework.context.annotation.Configuration;<span class="keyword">import</span> com.github.pagehelper.PageHelper;<span class="meta">@Configuration</span><span class="comment">//表示该类是spring容器配置类，相当于基于xml启动的spring的application.xml配置文件</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageHelperConfig</span> &#123;    <span class="meta">@Bean</span>    <span class="comment">//表示application.xml中的一个&lt;bean&gt;&lt;/bean&gt;元素，改bean元素的id为pageHelper</span>    <span class="keyword">public</span> PageHelper <span class="title function_">pageHelper</span><span class="params">()</span> &#123;        <span class="type">PageHelper</span> <span class="variable">pageHelper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageHelper</span>();        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();        <span class="comment">//offsetAsPageNum:设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用</span>        p.setProperty(<span class="string">&quot;offsetAsPageNum&quot;</span>, <span class="string">&quot;true&quot;</span>);        <span class="comment">//rowBoundsWithCount:设置为true时，使用RowBounds分页会进行count查询</span>        p.setProperty(<span class="string">&quot;rowBoundsWithCount&quot;</span>, <span class="string">&quot;true&quot;</span>);        <span class="comment">//reasonable：启用合理化时，如果pageNum&lt;1会查询第一页，如果pageNum&gt;pages会查询最后一页</span>        p.setProperty(<span class="string">&quot;reasonable&quot;</span>, <span class="string">&quot;true&quot;</span>);        pageHelper.setProperties(p);        <span class="keyword">return</span> pageHelper;    &#125;&#125;</code></pre><h4 id="mapper-2"><a class="markdownIt-Anchor" href="#mapper-2"></a> Mapper</h4><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.Mapper;<span class="comment">/**</span><span class="comment"> * mybatis 注解方式（xml方式删掉Mapper注解和select注解新增xml文件即可）</span><span class="comment"> */</span><span class="keyword">import</span> com.leeboer.springboot.pojo.Category;<span class="keyword">import</span> org.apache.ibatis.annotations.*;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/7/5.</span><span class="comment"> */</span><span class="meta">@Mapper</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CategoryMapper</span> &#123;    <span class="meta">@Select(&quot;select * from category &quot;)</span>    List&lt;Category&gt; <span class="title function_">findAll</span><span class="params">()</span>;    <span class="meta">@Insert(&quot; insert into category ( name ) values (#&#123;name&#125;) &quot;)</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">save</span><span class="params">(Category category)</span>;    <span class="meta">@Delete(&quot; delete from category where id= #&#123;id&#125; &quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>;    <span class="meta">@Select(&quot;select * from category where id= #&#123;id&#125; &quot;)</span>    <span class="keyword">public</span> Category <span class="title function_">get</span><span class="params">(<span class="type">int</span> id)</span>;    <span class="meta">@Update(&quot;update category set name=#&#123;name&#125; where id=#&#123;id&#125; &quot;)</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Category category)</span>;&#125;</code></pre><h4 id="controller-3"><a class="markdownIt-Anchor" href="#controller-3"></a> Controller</h4><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.springboot.web;<span class="keyword">import</span> com.github.pagehelper.PageHelper;<span class="keyword">import</span> com.github.pagehelper.PageInfo;<span class="keyword">import</span> com.leeboer.springboot.Mapper.CategoryMapper;<span class="keyword">import</span> com.leeboer.springboot.dao.CategoryDAO;<span class="keyword">import</span> com.leeboer.springboot.pojo.Category;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.data.domain.Page;<span class="keyword">import</span> org.springframework.data.domain.PageRequest;<span class="keyword">import</span> org.springframework.data.domain.Pageable;<span class="keyword">import</span> org.springframework.data.domain.Sort;<span class="keyword">import</span> org.springframework.stereotype.Controller;<span class="keyword">import</span> org.springframework.ui.Model;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/7/5.</span><span class="comment"> */</span><span class="meta">@Controller</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryController</span> &#123;    <span class="comment">//jpa方式</span>    <span class="meta">@Autowired</span>    CategoryDAO categoryDAO;    <span class="comment">//Mapper方式</span>    <span class="meta">@Autowired</span>    CategoryMapper categoryMapper;    <span class="comment">//mybatis-PageHelper增删该查和注解的使用</span>    <span class="meta">@RequestMapping(&quot;/addCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">listCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryMapper.save(c);        <span class="keyword">return</span> <span class="string">&quot;redirect:listCategory&quot;</span>;    &#125;    <span class="meta">@RequestMapping(&quot;/deleteCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">deleteCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryMapper.delete(c.getId());        <span class="keyword">return</span> <span class="string">&quot;redirect:listCategory&quot;</span>;    &#125;    <span class="meta">@RequestMapping(&quot;/updateCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">updateCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryMapper.update(c);        <span class="keyword">return</span> <span class="string">&quot;redirect:listCategory&quot;</span>;    &#125;    <span class="meta">@RequestMapping(&quot;/editCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">listCategory</span><span class="params">(<span class="type">int</span> id,Model m)</span> <span class="keyword">throws</span> Exception &#123;        Category c= categoryMapper.get(id);        m.addAttribute(<span class="string">&quot;c&quot;</span>, c);        <span class="keyword">return</span> <span class="string">&quot;listCategory&quot;</span>;    &#125;    <span class="meta">@RequestMapping(&quot;/listCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">listCategory</span><span class="params">(Model m,<span class="meta">@RequestParam(value = &quot;start&quot;, defaultValue = &quot;0&quot;)</span> <span class="type">int</span> start,<span class="meta">@RequestParam(value = &quot;size&quot;, defaultValue = &quot;5&quot;)</span> <span class="type">int</span> size)</span> <span class="keyword">throws</span> Exception &#123;        PageHelper.startPage(start,size,<span class="string">&quot;id desc&quot;</span>);        List&lt;Category&gt; cs=categoryMapper.findAll();        PageInfo&lt;Category&gt; page = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(cs);        m.addAttribute(<span class="string">&quot;page&quot;</span>, page);        <span class="keyword">return</span> <span class="string">&quot;listCategoryPageHelper&quot;</span>;    &#125;&#125;</code></pre><h4 id="jsp-4"><a class="markdownIt-Anchor" href="#jsp-4"></a> jsp</h4><p>通过page.getList遍历当前页面的Category对象。<br />在分页的时候通过page.pageNum获取当前页面，page.pages获取总页面数。</p><blockquote><p>注：page.getList会返回一个泛型是Category的集合</p></blockquote><p>listCategory.jsp</p><pre><code class="highlight html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;  &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;    <span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:500px;margin:20px auto;text-align: center&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">&#x27;center&#x27;</span> <span class="attr">border</span>=<span class="string">&#x27;1&#x27;</span> <span class="attr">cellspacing</span>=<span class="string">&#x27;0&#x27;</span>&gt;</span>        <span class="tag">&lt;<span class="name">tr</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>id<span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>name<span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">td</span>&gt;</span>        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>        <span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">items</span>=<span class="string">&quot;$&#123;page.list&#125;&quot;</span> <span class="attr">var</span>=<span class="string">&quot;c&quot;</span> <span class="attr">varStatus</span>=<span class="string">&quot;st&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">tr</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;c.id&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;c.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;editCategory?id=$&#123;c.id&#125;&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;deleteCategory?id=$&#123;c.id&#125;&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>        <span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span>              <span class="tag">&lt;/<span class="name">table</span>&gt;</span>    <span class="tag">&lt;<span class="name">br</span>&gt;</span>    <span class="tag">&lt;<span class="name">div</span>&gt;</span>                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=1&quot;</span>&gt;</span>[首  页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=$&#123;page.pageNum-1&#125;&quot;</span>&gt;</span>[上一页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=$&#123;page.pageNum+1&#125;&quot;</span>&gt;</span>[下一页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=$&#123;page.pages&#125;&quot;</span>&gt;</span>[末  页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>    <span class="tag">&lt;<span class="name">br</span>&gt;</span>    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;addCategory&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span>          name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span>    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span>          <span class="tag">&lt;/<span class="name">form</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><h4 id="测试运行-2"><a class="markdownIt-Anchor" href="#测试运行-2"></a> 测试运行</h4><h3 id="sqlite"><a class="markdownIt-Anchor" href="#sqlite"></a> SQLite</h3><p>SQLite 是一种数据库，它是跑在 JVM里面的，所以不需要像 mysql 那样得独立安装配置，而是直接拿来就用</p><h4 id="pomxml-4"><a class="markdownIt-Anchor" href="#pomxml-4"></a> pom.xml</h4><p>增加sqlite依赖</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xerial<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sqlite-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h4 id="配置sqlite方言"><a class="markdownIt-Anchor" href="#配置sqlite方言"></a> 配置SQLite方言</h4><p>因为是使用 JPA 来链接 SQlite, 而 JPA 默认用的是 Hibernate，所以要为 Hibernate 配置专门的方言</p><p>方便 Hibernate和 Sqlite打交道。 方言的英文是 Dialect， 所以就有了SQLiteDialect 这个类了</p><h5 id="sqlitedialect"><a class="markdownIt-Anchor" href="#sqlitedialect"></a> SQLiteDialect</h5><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.sqlite;<span class="keyword">import</span> java.sql.SQLException;<span class="keyword">import</span> java.sql.Types;<span class="keyword">import</span> org.hibernate.JDBCException;<span class="keyword">import</span> org.hibernate.ScrollMode;<span class="keyword">import</span> org.hibernate.dialect.Dialect;<span class="keyword">import</span> org.hibernate.dialect.function.AbstractAnsiTrimEmulationFunction;<span class="keyword">import</span> org.hibernate.dialect.function.NoArgSQLFunction;<span class="keyword">import</span> org.hibernate.dialect.function.SQLFunction;<span class="keyword">import</span> org.hibernate.dialect.function.SQLFunctionTemplate;<span class="keyword">import</span> org.hibernate.dialect.function.StandardSQLFunction;<span class="keyword">import</span> org.hibernate.dialect.function.VarArgsSQLFunction;<span class="keyword">import</span> org.hibernate.dialect.identity.IdentityColumnSupport;<span class="keyword">import</span> org.hibernate.dialect.pagination.AbstractLimitHandler;<span class="keyword">import</span> org.hibernate.dialect.pagination.LimitHandler;<span class="keyword">import</span> org.hibernate.dialect.pagination.LimitHelper;<span class="keyword">import</span> org.hibernate.dialect.unique.DefaultUniqueDelegate;<span class="keyword">import</span> org.hibernate.dialect.unique.UniqueDelegate;<span class="keyword">import</span> org.hibernate.engine.spi.RowSelection;<span class="keyword">import</span> org.hibernate.exception.DataException;<span class="keyword">import</span> org.hibernate.exception.JDBCConnectionException;<span class="keyword">import</span> org.hibernate.exception.LockAcquisitionException;<span class="keyword">import</span> org.hibernate.exception.spi.SQLExceptionConversionDelegate;<span class="keyword">import</span> org.hibernate.exception.spi.TemplatedViolatedConstraintNameExtracter;<span class="keyword">import</span> org.hibernate.exception.spi.ViolatedConstraintNameExtracter;<span class="keyword">import</span> org.hibernate.internal.util.JdbcExceptionHelper;<span class="keyword">import</span> org.hibernate.mapping.Column;<span class="keyword">import</span> org.hibernate.type.StandardBasicTypes;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SQLiteDialect</span> <span class="keyword">extends</span> <span class="title class_">Dialect</span> &#123;    <span class="keyword">private</span> <span class="keyword">final</span> UniqueDelegate uniqueDelegate;    <span class="keyword">public</span> <span class="title function_">SQLiteDialect</span><span class="params">()</span> &#123;        registerColumnType(Types.BIT, <span class="string">&quot;boolean&quot;</span>);        registerColumnType(Types.DECIMAL, <span class="string">&quot;decimal&quot;</span>);        registerColumnType(Types.CHAR, <span class="string">&quot;char&quot;</span>);        registerColumnType(Types.LONGVARCHAR, <span class="string">&quot;longvarchar&quot;</span>);        registerColumnType(Types.TIMESTAMP, <span class="string">&quot;datetime&quot;</span>);        registerColumnType(Types.BINARY, <span class="string">&quot;blob&quot;</span>);        registerColumnType(Types.VARBINARY, <span class="string">&quot;blob&quot;</span>);        registerColumnType(Types.LONGVARBINARY, <span class="string">&quot;blob&quot;</span>);        registerFunction(<span class="string">&quot;concat&quot;</span>, <span class="keyword">new</span> <span class="title class_">VarArgsSQLFunction</span>(StandardBasicTypes.STRING, <span class="string">&quot;&quot;</span>, <span class="string">&quot;||&quot;</span>, <span class="string">&quot;&quot;</span>));        registerFunction(<span class="string">&quot;mod&quot;</span>, <span class="keyword">new</span> <span class="title class_">SQLFunctionTemplate</span>(StandardBasicTypes.INTEGER, <span class="string">&quot;?1 % ?2&quot;</span>));        registerFunction(<span class="string">&quot;quote&quot;</span>, <span class="keyword">new</span> <span class="title class_">StandardSQLFunction</span>(<span class="string">&quot;quote&quot;</span>, StandardBasicTypes.STRING));        registerFunction(<span class="string">&quot;random&quot;</span>, <span class="keyword">new</span> <span class="title class_">NoArgSQLFunction</span>(<span class="string">&quot;random&quot;</span>, StandardBasicTypes.INTEGER));        registerFunction(<span class="string">&quot;round&quot;</span>, <span class="keyword">new</span> <span class="title class_">StandardSQLFunction</span>(<span class="string">&quot;round&quot;</span>));        registerFunction(<span class="string">&quot;substr&quot;</span>, <span class="keyword">new</span> <span class="title class_">StandardSQLFunction</span>(<span class="string">&quot;substr&quot;</span>, StandardBasicTypes.STRING));        registerFunction(<span class="string">&quot;trim&quot;</span>, <span class="keyword">new</span> <span class="title class_">AbstractAnsiTrimEmulationFunction</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">protected</span> SQLFunction <span class="title function_">resolveBothSpaceTrimFunction</span><span class="params">()</span> &#123;                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQLFunctionTemplate</span>(StandardBasicTypes.STRING, <span class="string">&quot;trim(?1)&quot;</span>);            &#125;            <span class="meta">@Override</span>            <span class="keyword">protected</span> SQLFunction <span class="title function_">resolveBothSpaceTrimFromFunction</span><span class="params">()</span> &#123;                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQLFunctionTemplate</span>(StandardBasicTypes.STRING, <span class="string">&quot;trim(?2)&quot;</span>);            &#125;            <span class="meta">@Override</span>            <span class="keyword">protected</span> SQLFunction <span class="title function_">resolveLeadingSpaceTrimFunction</span><span class="params">()</span> &#123;                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQLFunctionTemplate</span>(StandardBasicTypes.STRING, <span class="string">&quot;ltrim(?1)&quot;</span>);            &#125;            <span class="meta">@Override</span>            <span class="keyword">protected</span> SQLFunction <span class="title function_">resolveTrailingSpaceTrimFunction</span><span class="params">()</span> &#123;                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQLFunctionTemplate</span>(StandardBasicTypes.STRING, <span class="string">&quot;rtrim(?1)&quot;</span>);            &#125;            <span class="meta">@Override</span>            <span class="keyword">protected</span> SQLFunction <span class="title function_">resolveBothTrimFunction</span><span class="params">()</span> &#123;                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQLFunctionTemplate</span>(StandardBasicTypes.STRING, <span class="string">&quot;trim(?1, ?2)&quot;</span>);            &#125;            <span class="meta">@Override</span>            <span class="keyword">protected</span> SQLFunction <span class="title function_">resolveLeadingTrimFunction</span><span class="params">()</span> &#123;                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQLFunctionTemplate</span>(StandardBasicTypes.STRING, <span class="string">&quot;ltrim(?1, ?2)&quot;</span>);            &#125;            <span class="meta">@Override</span>            <span class="keyword">protected</span> SQLFunction <span class="title function_">resolveTrailingTrimFunction</span><span class="params">()</span> &#123;                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQLFunctionTemplate</span>(StandardBasicTypes.STRING, <span class="string">&quot;rtrim(?1, ?2)&quot;</span>);            &#125;        &#125;);        uniqueDelegate = <span class="keyword">new</span> <span class="title class_">SQLiteUniqueDelegate</span>(<span class="built_in">this</span>);    &#125;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SQLiteDialectIdentityColumnSupport</span> <span class="variable">IDENTITY_COLUMN_SUPPORT</span> <span class="operator">=</span> <span class="keyword">new</span>            <span class="title class_">SQLiteDialectIdentityColumnSupport</span>(<span class="keyword">new</span> <span class="title class_">SQLiteDialect</span>());    <span class="meta">@Override</span>    <span class="keyword">public</span> IdentityColumnSupport <span class="title function_">getIdentityColumnSupport</span><span class="params">()</span> &#123;        <span class="keyword">return</span> IDENTITY_COLUMN_SUPPORT;    &#125;    <span class="comment">// limit/offset support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AbstractLimitHandler</span> <span class="variable">LIMIT_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbstractLimitHandler</span>() &#123;        <span class="meta">@Override</span>        <span class="keyword">public</span> String <span class="title function_">processSql</span><span class="params">(String sql, RowSelection selection)</span> &#123;            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">hasOffset</span> <span class="operator">=</span> LimitHelper.hasFirstRow(selection);            <span class="keyword">return</span> sql + (hasOffset ? <span class="string">&quot; limit ? offset ?&quot;</span> : <span class="string">&quot; limit ?&quot;</span>);        &#125;        <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsLimit</span><span class="params">()</span> &#123;            <span class="keyword">return</span> <span class="literal">true</span>;        &#125;        <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">bindLimitParametersInReverseOrder</span><span class="params">()</span> &#123;            <span class="keyword">return</span> <span class="literal">true</span>;        &#125;    &#125;;    <span class="meta">@Override</span>    <span class="keyword">public</span> LimitHandler <span class="title function_">getLimitHandler</span><span class="params">()</span> &#123;        <span class="keyword">return</span> LIMIT_HANDLER;    &#125;    <span class="comment">// lock acquisition support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsLockTimeouts</span><span class="params">()</span> &#123;        <span class="comment">// may be http://sqlite.org/c3ref/db_mutex.html ?</span>        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getForUpdateString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsOuterJoinForUpdate</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="comment">// current timestamp support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsCurrentTimestampSelection</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCurrentTimestampSelectStringCallable</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getCurrentTimestampSelectString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;select current_timestamp&quot;</span>;    &#125;    <span class="comment">// SQLException support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_BUSY</span> <span class="operator">=</span> <span class="number">5</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_LOCKED</span> <span class="operator">=</span> <span class="number">6</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_IOERR</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_CORRUPT</span> <span class="operator">=</span> <span class="number">11</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_NOTFOUND</span> <span class="operator">=</span> <span class="number">12</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_FULL</span> <span class="operator">=</span> <span class="number">13</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_CANTOPEN</span> <span class="operator">=</span> <span class="number">14</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_PROTOCOL</span> <span class="operator">=</span> <span class="number">15</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_TOOBIG</span> <span class="operator">=</span> <span class="number">18</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_CONSTRAINT</span> <span class="operator">=</span> <span class="number">19</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_MISMATCH</span> <span class="operator">=</span> <span class="number">20</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQLITE_NOTADB</span> <span class="operator">=</span> <span class="number">26</span>;    <span class="meta">@Override</span>    <span class="keyword">public</span> SQLExceptionConversionDelegate <span class="title function_">buildSQLExceptionConversionDelegate</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQLExceptionConversionDelegate</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> JDBCException <span class="title function_">convert</span><span class="params">(SQLException sqlException, String message, String sql)</span> &#123;                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">errorCode</span> <span class="operator">=</span> JdbcExceptionHelper.extractErrorCode(sqlException) &amp; <span class="number">0xFF</span>;                <span class="keyword">if</span> (errorCode == SQLITE_TOOBIG || errorCode == SQLITE_MISMATCH) &#123;                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataException</span>(message, sqlException, sql);                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errorCode == SQLITE_BUSY || errorCode == SQLITE_LOCKED) &#123;                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LockAcquisitionException</span>(message, sqlException, sql);                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((errorCode &gt;= SQLITE_IOERR &amp;&amp; errorCode &lt;= SQLITE_PROTOCOL) || errorCode == SQLITE_NOTADB) &#123;                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JDBCConnectionException</span>(message, sqlException, sql);                &#125;                <span class="comment">// returning null allows other delegates to operate</span>                <span class="keyword">return</span> <span class="literal">null</span>;            &#125;        &#125;;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> ViolatedConstraintNameExtracter <span class="title function_">getViolatedConstraintNameExtracter</span><span class="params">()</span> &#123;        <span class="keyword">return</span> EXTRACTER;    &#125;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ViolatedConstraintNameExtracter</span> <span class="variable">EXTRACTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatedViolatedConstraintNameExtracter</span>() &#123;        <span class="meta">@Override</span>        <span class="keyword">protected</span> String <span class="title function_">doExtractConstraintName</span><span class="params">(SQLException sqle)</span> <span class="keyword">throws</span> NumberFormatException &#123;            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">errorCode</span> <span class="operator">=</span> JdbcExceptionHelper.extractErrorCode(sqle) &amp; <span class="number">0xFF</span>;            <span class="keyword">if</span> (errorCode == SQLITE_CONSTRAINT) &#123;                <span class="keyword">return</span> extractUsingTemplate(<span class="string">&quot;constraint &quot;</span>, <span class="string">&quot; failed&quot;</span>, sqle.getMessage());            &#125;            <span class="keyword">return</span> <span class="literal">null</span>;        &#125;    &#125;;    <span class="comment">// union subclass support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsUnionAll</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="comment">// DDL support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canCreateSchema</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasAlterTable</span><span class="params">()</span> &#123;        <span class="comment">// As specified in NHibernate dialect</span>        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dropConstraints</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">qualifyIndexName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getAddColumnString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;add column&quot;</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getDropForeignKeyString</span><span class="params">()</span> &#123;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;No drop foreign key syntax supported by SQLiteDialect&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getAddForeignKeyConstraintString</span><span class="params">(String constraintName,</span><span class="params">                                                   String[] foreignKey, String referencedTable, String[] primaryKey,</span><span class="params">                                                   <span class="type">boolean</span> referencesPrimaryKey)</span> &#123;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;No add foreign key syntax supported by SQLiteDialect&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getAddPrimaryKeyConstraintString</span><span class="params">(String constraintName)</span> &#123;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;No add primary key syntax supported by SQLiteDialect&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsCommentOn</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsIfExistsBeforeTableName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doesReadCommittedCauseWritersToBlockReaders</span><span class="params">()</span> &#123;        <span class="comment">// TODO Validate (WAL mode...)</span>        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doesRepeatableReadCauseReadersToBlockWriters</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsTupleDistinctCounts</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getInExpressionCountLimit</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="number">1000</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> UniqueDelegate <span class="title function_">getUniqueDelegate</span><span class="params">()</span> &#123;        <span class="keyword">return</span> uniqueDelegate;    &#125;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SQLiteUniqueDelegate</span> <span class="keyword">extends</span> <span class="title class_">DefaultUniqueDelegate</span> &#123;        <span class="keyword">public</span> <span class="title function_">SQLiteUniqueDelegate</span><span class="params">(Dialect dialect)</span> &#123;            <span class="built_in">super</span>(dialect);        &#125;        <span class="meta">@Override</span>        <span class="keyword">public</span> String <span class="title function_">getColumnDefinitionUniquenessFragment</span><span class="params">(Column column)</span> &#123;            <span class="keyword">return</span> <span class="string">&quot; unique&quot;</span>;        &#125;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getSelectGUIDString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;select hex(randomblob(16))&quot;</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> ScrollMode <span class="title function_">defaultScrollMode</span><span class="params">()</span> &#123;        <span class="keyword">return</span> ScrollMode.FORWARD_ONLY;    &#125;&#125;</code></pre><h5 id="sqlitedialectidentitycolumnsupport"><a class="markdownIt-Anchor" href="#sqlitedialectidentitycolumnsupport"></a> SQLiteDialectIdentityColumnSupport</h5><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.sqlite;<span class="keyword">import</span> org.hibernate.dialect.Dialect;<span class="keyword">import</span> org.hibernate.dialect.identity.IdentityColumnSupportImpl;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SQLiteDialectIdentityColumnSupport</span> <span class="keyword">extends</span> <span class="title class_">IdentityColumnSupportImpl</span> &#123;    <span class="keyword">public</span> <span class="title function_">SQLiteDialectIdentityColumnSupport</span><span class="params">(Dialect dialect)</span> &#123;        <span class="built_in">super</span>(dialect);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsIdentityColumns</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasDataTypeInIdentityColumn</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getIdentitySelectString</span><span class="params">(String table, String column, <span class="type">int</span> type)</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;select last_insert_rowid()&quot;</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getIdentityColumnString</span><span class="params">(<span class="type">int</span> type)</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;integer&quot;</span>;    &#125;&#125;</code></pre><h5 id="sqlitemetadatabuilderinitializer"><a class="markdownIt-Anchor" href="#sqlitemetadatabuilderinitializer"></a> SQLiteMetadataBuilderInitializer</h5><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.sqlite;<span class="keyword">import</span> org.hibernate.boot.MetadataBuilder;<span class="keyword">import</span> org.hibernate.boot.registry.StandardServiceRegistry;<span class="keyword">import</span> org.hibernate.boot.spi.MetadataBuilderInitializer;<span class="keyword">import</span> org.hibernate.engine.jdbc.dialect.internal.DialectResolverSet;<span class="keyword">import</span> org.hibernate.engine.jdbc.dialect.spi.DialectResolver;<span class="keyword">import</span> org.jboss.logging.Logger;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SQLiteMetadataBuilderInitializer</span> <span class="keyword">implements</span> <span class="title class_">MetadataBuilderInitializer</span> &#123;    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(SQLiteMetadataBuilderInitializer.class);    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contribute</span><span class="params">(MetadataBuilder metadataBuilder, StandardServiceRegistry serviceRegistry)</span> &#123;        <span class="type">DialectResolver</span> <span class="variable">dialectResolver</span> <span class="operator">=</span> serviceRegistry.getService(DialectResolver.class);        <span class="keyword">if</span> (!(dialectResolver <span class="keyword">instanceof</span> DialectResolverSet)) &#123;            logger.warnf(<span class="string">&quot;DialectResolver &#x27;%s&#x27; is not an instance of DialectResolverSet, not registering SQLiteDialect&quot;</span>,                    dialectResolver);            <span class="keyword">return</span>;        &#125;        ((DialectResolverSet) dialectResolver).addResolver(resolver);    &#125;    <span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">SQLiteDialect</span> <span class="variable">dialect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SQLiteDialect</span>();    <span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">DialectResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> (DialectResolver) info -&gt; &#123;        <span class="keyword">if</span> (info.getDatabaseName().equals(<span class="string">&quot;SQLite&quot;</span>)) &#123;            <span class="keyword">return</span> dialect;        &#125;        <span class="keyword">return</span> <span class="literal">null</span>;    &#125;;&#125;</code></pre><h4 id="applicationproperties-4"><a class="markdownIt-Anchor" href="#applicationproperties-4"></a> application.properties</h4><p>对 mysql 的配置，修改到了对 sqlite 的配置</p><pre><code class="highlight properties"><span class="comment"># 配置jsp的寻找路径</span><span class="attr">spring.mvc.view.prefix</span>=<span class="string">/WEB-INF/jsp/</span><span class="attr">spring.mvc.view.suffix</span>=<span class="string">.jsp</span><span class="comment">#更改tomcat默认端口号</span><span class="attr">server.port</span>=<span class="string">8088</span><span class="comment">#更改访问上下文路径/访问路径 localhost:8088/leeBoot/...</span><span class="attr">server.context-path</span>=<span class="string">/leeBoot</span><span class="comment">#配置mysql数据源</span><span class="comment">#spring.datasource.url=jdbc:mysql://127.0.0.1:3306/lee_test?characterEncoding=UTF-8</span><span class="comment">#spring.datasource.username=root</span><span class="comment">#spring.datasource.password=admin</span><span class="comment">#spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><span class="comment">#新增数据库链接必须的参数（jpa方式要加，mybatis方式不用加）</span><span class="comment">#spring.jpa.properties.hibernate.hbm2ddl.auto=update</span><span class="comment"></span><span class="comment">#mybaits基于xml要额外加两条配置</span><span class="comment">#mybatis.mapper-locations=classpath:com/leeboer/springboot/mapper/*.xml</span><span class="comment">#mybatis.type-aliases-package=com.leeboer.springboot.pojo</span><span class="comment"></span><span class="comment">#SQLite数据库配置</span><span class="attr">spring.jpa.database-platform</span>=<span class="string">com.leeboer.sqlite.SQLiteDialect</span><span class="comment">#表结构由hibernate根据实体类来帮你创建</span><span class="attr">spring.jpa.generate-ddl</span>=<span class="string">true</span><span class="comment">#自动根据Entity配置创建表</span><span class="attr">spring.jpa.hibernate.ddl-auto</span>=<span class="string">update</span><span class="comment">#数据库文件位置,该文件没有的话会自动创建</span><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:sqlite:leeboer.db</span><span class="comment">#驱动名称</span><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">org.sqlite.JDBC</span></code></pre><h4 id="sqlite创建表添加数据"><a class="markdownIt-Anchor" href="#sqlite创建表添加数据"></a> sqlite创建表/添加数据</h4><pre><code class="highlight java"><span class="keyword">package</span> com.leeboer.sqlite;<span class="keyword">import</span> java.sql.Connection;<span class="keyword">import</span> java.sql.DriverManager;<span class="keyword">import</span> java.sql.ResultSet;<span class="keyword">import</span> java.sql.Statement;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/7/5.</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateTableCategory</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">try</span> &#123;            <span class="comment">// 加载驱动,连接sqlite的jdbc</span>            Class.forName(<span class="string">&quot;org.sqlite.JDBC&quot;</span>);            <span class="comment">// 连接数据库how2j.db,不用手动创建。。。</span>            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:sqlite:leeboer.db&quot;</span>);            <span class="comment">// 创建连接对象，是Java的一个操作数据库的重要接口</span>            <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();            <span class="comment">// 判断是否有表tables的存在。有则删除</span>            statement.executeUpdate(<span class="string">&quot;drop table if exists Category&quot;</span>);            <span class="comment">// 创建表</span>            statement.executeUpdate(<span class="string">&quot;create table Category(id int,name varchar(20))&quot;</span>);            <span class="comment">//插入数据</span>            statement.executeUpdate(<span class="string">&quot;insert into Category values(1,&#x27;Gareen&#x27;)&quot;</span>);            statement.executeUpdate(<span class="string">&quot;insert into Category values(2,&#x27;yellow&#x27;)&quot;</span>);            statement.executeUpdate(<span class="string">&quot;insert into Category values(3,&#x27;red&#x27;)&quot;</span>);            statement.executeUpdate(<span class="string">&quot;insert into Category values(4,&#x27;black&#x27;)&quot;</span>);            <span class="comment">// 搜索数据库，将搜索的放入数据集ResultSet中</span>            <span class="type">ResultSet</span> <span class="variable">rSet</span> <span class="operator">=</span> statement.executeQuery(<span class="string">&quot;select * from Category&quot;</span>);            <span class="keyword">while</span> (rSet.next()) &#123; <span class="comment">// 遍历这个数据集</span>                System.out.println(<span class="string">&quot;id：&quot;</span> + rSet.getInt(<span class="number">1</span>));                System.out.println(<span class="string">&quot;姓名：&quot;</span> + rSet.getString(<span class="number">2</span>));            &#125;            rSet.close();<span class="comment">// 关闭数据集</span>            connection.close();<span class="comment">// 关闭数据库连接</span>        &#125; <span class="keyword">catch</span> (Exception e) &#123;            <span class="comment">// TODO Auto-generated catch block</span>            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h4 id="测试运行-3"><a class="markdownIt-Anchor" href="#测试运行-3"></a> 测试运行</h4><p>配置好之后，即可基于之前的例子访问localhost:8088/leeBoot/listCategory可得到相同的结果</p><h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2><h3 id="单元测试-2"><a class="markdownIt-Anchor" href="#单元测试-2"></a> 单元测试</h3><p><u>该案例基于前面的jpa案例</u></p><p>有时候，springboot里要做单元测试，而不是直接跑起来，比如jpa章节的查询数据，想跑个测试，看看数据库里的数据，接下来讲该怎么做</p><h4 id="pomxml-5"><a class="markdownIt-Anchor" href="#pomxml-5"></a> pom.xml</h4><ol><li>修改junit版本为4.12</li><li>增加spring-boot-starter-test</li></ol><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!-- springboot test --&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h4 id="测试类"><a class="markdownIt-Anchor" href="#测试类"></a> 测试类</h4><ol><li>需要加上2个注解<ul><li>@RunWith(SpringRunner.class)</li><li>@SpringBooTest(classes=Application.class)</li></ul></li><li>自动装配CategoryDAO dao，以便使用</li><li>test方法加上@test注解，然后就可以使用dao来工作了</li><li>运行的时候选择JUnit Test方式</li></ol><pre><code class="highlight java"><span class="keyword">package</span> com.how2java.springboot.test; <span class="keyword">import</span> java.util.List; <span class="keyword">import</span> org.junit.Test;<span class="keyword">import</span> org.junit.runner.RunWith;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<span class="keyword">import</span> com.how2java.springboot.Application;<span class="keyword">import</span> com.how2java.springboot.dao.CategoryDAO;<span class="keyword">import</span> com.how2java.springboot.pojo.Category; <span class="meta">@RunWith(SpringRunner.class)</span><span class="meta">@SpringBootTest(classes = Application.class)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJPA</span> &#123;     <span class="meta">@Autowired</span> CategoryDAO dao;         <span class="meta">@Test</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;        List&lt;Category&gt; cs=  dao.findAll();        <span class="keyword">for</span> (Category c : cs) &#123;            System.out.println(<span class="string">&quot;c.getName():&quot;</span>+ c.getName());        &#125;             &#125;&#125;</code></pre><h3 id="jpa条件查询"><a class="markdownIt-Anchor" href="#jpa条件查询"></a> JPA条件查询</h3><h4 id="jpa条件查询方式"><a class="markdownIt-Anchor" href="#jpa条件查询方式"></a> JPA条件查询方式</h4><p>JPA 条件查询方式很有意思，是不需要写 SQL 语句的，只需要在 dao 接口里按照规范的命名定义对应的方法名，及可达到查询相应字段的效果了。<br />在如下代码里做了如下事情：</p><ol><li>首先通过 @Before 把 Category表里所有数据都删除了，并新增了10条。</li><li>然后 test1() 查询所有数据，看看新增的10条数据。</li><li>接着，test2() 通过自定义的接口方法 findByName，根据name 查询分类表</li><li>接着，test3() 通过自定义的接口方法 findByNameLikeAndIdGreaterThanOrderByNameAsc，根据名称模糊查询，id 大于某值, 并且名称正排序查询。</li></ol><p><strong>Category.java</strong></p><pre><code class="highlight java"><span class="keyword">import</span> javax.persistence.Column;<span class="keyword">import</span> javax.persistence.Entity;<span class="keyword">import</span> javax.persistence.GeneratedValue;<span class="keyword">import</span> javax.persistence.GenerationType;<span class="keyword">import</span> javax.persistence.Id;<span class="keyword">import</span> javax.persistence.Table; <span class="meta">@Entity</span><span class="meta">@Table(name = &quot;category_&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Category</span> &#123;     <span class="meta">@Id</span>    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>    <span class="meta">@Column(name = &quot;id&quot;)</span>    <span class="keyword">private</span> <span class="type">int</span> id;         <span class="meta">@Column(name = &quot;name&quot;)</span>    <span class="keyword">private</span> String name;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Category [id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;    &#125;     &#125;</code></pre><p><strong>CategoryDAO.java</strong></p><pre><code class="highlight java"><span class="keyword">import</span> java.util.List; <span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository; <span class="keyword">import</span> com.how2java.springboot.pojo.Category; <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CategoryDAO</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Category,Integer&gt;&#123;     <span class="keyword">public</span> List&lt;Category&gt; <span class="title function_">findByName</span><span class="params">(String name)</span>;         <span class="keyword">public</span> List&lt;Category&gt; <span class="title function_">findByNameLikeAndIdGreaterThanOrderByNameAsc</span><span class="params">(String name, <span class="type">int</span> id)</span>;&#125;</code></pre><p><strong>TestJPA.java</strong></p><pre><code class="highlight java"><span class="keyword">import</span> java.util.List; <span class="keyword">import</span> org.junit.Before;<span class="keyword">import</span> org.junit.Test;<span class="keyword">import</span> org.junit.runner.RunWith;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner; <span class="keyword">import</span> com.how2java.springboot.Application;<span class="keyword">import</span> com.how2java.springboot.dao.CategoryDAO;<span class="keyword">import</span> com.how2java.springboot.pojo.Category; <span class="meta">@RunWith(SpringRunner.class)</span><span class="meta">@SpringBootTest(classes = Application.class)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJPA</span> &#123;     <span class="meta">@Autowired</span> CategoryDAO dao;         <span class="meta">@Before</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;        List&lt;Category&gt; cs=  dao.findAll();        <span class="keyword">for</span> (Category c : cs) &#123;            dao.delete(c);        &#125;                 <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;            <span class="type">Category</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Category</span>();            c.setName(<span class="string">&quot;category &quot;</span> + i);            dao.save(c);        &#125;             &#125;         <span class="meta">@Test</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;        List&lt;Category&gt; cs=  dao.findAll();        System.out.println(<span class="string">&quot;所有的分类信息：&quot;</span>);        <span class="keyword">for</span> (Category c : cs) &#123;            System.out.println(c.getName());        &#125;        System.out.println();    &#125;         <span class="meta">@Test</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;查询名称是 \&quot;category 1 \&quot;的分类:&quot;</span>);        List&lt;Category&gt; cs=  dao.findByName(<span class="string">&quot;category 1&quot;</span>);        <span class="keyword">for</span> (Category c : cs) &#123;            System.out.println(<span class="string">&quot;c.getName():&quot;</span>+ c.getName());        &#125;        System.out.println();    &#125;    <span class="meta">@Test</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;根据名称模糊查询，id 大于5, 并且名称正排序查询&quot;</span>);        List&lt;Category&gt; cs=  dao.findByNameLikeAndIdGreaterThanOrderByNameAsc(<span class="string">&quot;%3%&quot;</span>,<span class="number">5</span>);        <span class="keyword">for</span> (Category c : cs) &#123;            System.out.println(c);        &#125;        System.out.println();             &#125;&#125;</code></pre><h4 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h4><p>虽然JPA没有自己动手写sql语句，但是通过反射获取自定义的接口方法里提供的信息，就知道用户希望根据什么条件查询了，然后 JPA 底层再偷偷摸摸地拼装对应的 sql 语句，丢给数据库，就达到了条件查询的效果啦</p><h4 id="条件查询规范"><a class="markdownIt-Anchor" href="#条件查询规范"></a> 条件查询规范</h4><p>JPA条件查询方式只是个别举例，下表把jpa做的各种查询规范都列出来了，如果要做其他相关查询，按照表格中的规范设计接口方法即可。</p><h3 id="上传文件"><a class="markdownIt-Anchor" href="#上传文件"></a> 上传文件</h3><p>先讲解一个上传图片的案例</p><h4 id="jsp-5"><a class="markdownIt-Anchor" href="#jsp-5"></a> jsp</h4><p>在jsp目录下新建uploadPage.jsp需要注意几点：</p><ol><li><code>method=&quot;post&quot;</code>是必须的</li><li><code>enctype=&quot;multipart/form-data&quot;</code>是必须的，表示提交二进制文件</li><li><code>name=&quot;file&quot;</code>是必须的，和后续服务端对应</li><li><code>accept=&quot;image/*&quot;</code>表示只选择图片</li></ol><pre><code class="highlight html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt; <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span>  选择图片:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">accept</span>=<span class="string">&quot;image/*&quot;</span> /&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span>  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></code></pre><h4 id="controller-4"><a class="markdownIt-Anchor" href="#controller-4"></a> Controller</h4><ol><li>接收上传的 文件</li></ol><pre><code class="highlight java"><span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file</code></pre><ol start="2"><li>根据时间戳创建新的文件名，防止覆盖</li></ol><pre><code class="highlight java"><span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> System.currentTimeMillis()+file.getOriginalFilename();</code></pre><ol start="3"><li>通过req.getServletContext().getRealPath(“”)获取当前项目真实路劲，然后拼接前面的文件名</li></ol><pre><code class="highlight java">String destFileName=req.getServletContext().getRealPath(<span class="string">&quot;&quot;</span>)+<span class="string">&quot;uploaded&quot;</span>+File.separator+fileName;</code></pre><ol start="4"><li>第一次运行的时候，这个文件所在的目录往往是不存在的，这里需要创建一下目录</li></ol><pre><code class="highlight java"><span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destFileName);destFile.getParentFile().mkdirs();</code></pre><ol start="5"><li>把浏览器上传的文件复制到希望的位置</li></ol><pre><code class="highlight java">file.transferTo(destFile);</code></pre><ol start="6"><li>把文件名放在model里，方便后续使用</li></ol><pre><code class="highlight java">m.addAttribute(<span class="string">&quot;fileName&quot;</span>,fileName);</code></pre><pre><code class="highlight java"><span class="keyword">package</span> com.how2java.springboot.web;<span class="keyword">import</span> java.io.File;<span class="keyword">import</span> java.io.FileNotFoundException;<span class="keyword">import</span> java.io.IOException; <span class="keyword">import</span> javax.servlet.http.HttpServletRequest; <span class="keyword">import</span> org.springframework.stereotype.Controller;<span class="keyword">import</span> org.springframework.ui.Model;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;  <span class="meta">@Controller</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;      <span class="meta">@RequestMapping(&quot;/uploadPage&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">uploadPage</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;uploadPage&quot;</span>;    &#125;         <span class="meta">@RequestMapping(value = &quot;/upload&quot;, method = RequestMethod.POST)</span>    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(HttpServletRequest req, <span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file,Model m)</span> &#123;            <span class="keyword">try</span> &#123;                <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> System.currentTimeMillis()+file.getOriginalFilename();                String destFileName=req.getServletContext().getRealPath(<span class="string">&quot;&quot;</span>)+<span class="string">&quot;uploaded&quot;</span>+File.separator+fileName;                                 <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destFileName);                destFile.getParentFile().mkdirs();                file.transferTo(destFile);                                 m.addAttribute(<span class="string">&quot;fileName&quot;</span>,fileName);            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;                e.printStackTrace();                <span class="keyword">return</span> <span class="string">&quot;上传失败,&quot;</span> + e.getMessage();            &#125; <span class="keyword">catch</span> (IOException e) &#123;                e.printStackTrace();                <span class="keyword">return</span> <span class="string">&quot;上传失败,&quot;</span> + e.getMessage();            &#125;                         <span class="keyword">return</span> <span class="string">&quot;showImg&quot;</span>;    &#125;   &#125;</code></pre><h4 id="设置上传文件的大小"><a class="markdownIt-Anchor" href="#设置上传文件的大小"></a> 设置上传文件的大小</h4><p>默认是1m，修改application.properties</p><pre><code class="highlight properties"><span class="attr">spring.mvc.view.prefix</span>=<span class="string">/WEB-INF/jsp/</span><span class="attr">spring.mvc.view.suffix</span>=<span class="string">.jsp</span><span class="attr">spring.http.multipart.maxFileSize</span>=<span class="string">100Mb</span><span class="attr">spring.http.multipart.maxRequestSize</span>=<span class="string">100Mb</span></code></pre><h3 id="restful"><a class="markdownIt-Anchor" href="#restful"></a> Restful</h3><h4 id="restful风格是什么"><a class="markdownIt-Anchor" href="#restful风格是什么"></a> Restful风格是什么</h4><p>大家在做Web开发的过程中，method常用的值是get和post. 可事实上，method值还可以是put和delete等等其他值。<br />既然method值如此丰富，那么就可以考虑使用同一个url，但是约定不同的method来实施不同的业务，这就是Restful的基本考虑。<br />CRUD是最常见的操作，在使用Restful 风格之前，通常的增加做法是这样的：</p><pre><code class="highlight plaintext">/addCategory?name=xxx</code></pre><p>可是使用了Restful风格之后，增加就变成了：</p><pre><code class="highlight plaintext">/categories</code></pre><p>CRUD如下表所示，URL就都使用一样的 “/categories”，区别只是在于method不同，服务器根据method的不同来判断浏览器期望做的业务行为</p><h4 id="listcategoryjsp"><a class="markdownIt-Anchor" href="#listcategoryjsp"></a> listCategory.jsp</h4><p>对之前的listCategory.jsp做出如下修改</p><ol><li><p>增加<br />1.1. action修改为&quot;categories&quot;</p></li><li><p>删除<br />2.1. url修改为categories/id<br />2.2 点击超链接后，会使用form提交，并且提交_method的值为delete，以达到和增加类似的效果</p></li></ol><pre><code class="highlight JavaScript">$(<span class="keyword">function</span>(<span class="params"></span>)&#123;    $(<span class="string">&quot;.delete&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;    <span class="keyword">var</span> href=$(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;href&quot;</span>);    $(<span class="string">&quot;#formdelete&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;action&quot;</span>,href).<span class="title function_">submit</span>();    <span class="keyword">return</span> <span class="literal">false</span>;    &#125;)&#125;)</code></pre><ol start="3"><li>获取<br />3.1. url修改为了/categories/id</li><li>在最开始增加了jQuery.main.js的引入</li></ol><pre><code class="highlight plaintext">&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;</code></pre><pre><code class="highlight html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;   <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>     <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">       <span class="comment">/*将post method 改变为delete*/</span></span><span class="language-javascript">      $(<span class="keyword">function</span>(<span class="params"></span>)&#123;                    </span><span class="language-javascript">           $(<span class="string">&quot;.delete&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><span class="language-javascript">               <span class="keyword">var</span> href=$(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;href&quot;</span>);</span><span class="language-javascript">               $(<span class="string">&quot;#formdelete&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;action&quot;</span>,href).<span class="title function_">submit</span>();</span><span class="language-javascript">               <span class="keyword">return</span> <span class="literal">false</span>;</span><span class="language-javascript">           &#125;)</span><span class="language-javascript">       &#125;)</span><span class="language-javascript">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>      <span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:500px;margin:20px auto;text-align: center&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">&#x27;center&#x27;</span> <span class="attr">border</span>=<span class="string">&#x27;1&#x27;</span> <span class="attr">cellspacing</span>=<span class="string">&#x27;0&#x27;</span>&gt;</span>        <span class="tag">&lt;<span class="name">tr</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>id<span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>name<span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;<span class="name">td</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">td</span>&gt;</span>        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>        <span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">items</span>=<span class="string">&quot;$&#123;page.content&#125;&quot;</span> <span class="attr">var</span>=<span class="string">&quot;c&quot;</span> <span class="attr">varStatus</span>=<span class="string">&quot;st&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">tr</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;c.id&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;c.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;categories/$&#123;c.id&#125;&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">href</span>=<span class="string">&quot;categories/$&#123;c.id&#125;&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>        <span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span>             <span class="tag">&lt;/<span class="name">table</span>&gt;</span>    <span class="tag">&lt;<span class="name">br</span>&gt;</span>    <span class="tag">&lt;<span class="name">div</span>&gt;</span>                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=0&quot;</span>&gt;</span>[首  页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=$&#123;page.number-1&#125;&quot;</span>&gt;</span>[上一页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=$&#123;page.number+1&#125;&quot;</span>&gt;</span>[下一页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?start=$&#123;page.totalPages-1&#125;&quot;</span>&gt;</span>[末  页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span>    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>    <span class="tag">&lt;<span class="name">br</span>&gt;</span>    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;categories&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span>    name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span>    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span>         <span class="tag">&lt;/<span class="name">form</span>&gt;</span>         <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;formdelete&quot;</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> &gt;</span>       <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;DELETE&quot;</span>&gt;</span>   <span class="tag">&lt;/<span class="name">form</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><h4 id="editcategoryjsp"><a class="markdownIt-Anchor" href="#editcategoryjsp"></a> editCategory.jsp</h4><p>action修改为了categories/id</p><blockquote><p>注意：form 下增加 filed, 虽然这个form的method是post, 但是springmvc看到这个_method的值是put后，会把其修改为put.</p></blockquote><pre><code class="highlight plaintext">&lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt;</code></pre><pre><code class="highlight html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isELIgnored=&quot;false&quot;%&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin:0px auto; width:500px&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;../categories/$&#123;c.id&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PUT&quot;</span>&gt;</span>name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;c.name&#125;&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;/<span class="name">form</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><h4 id="categorycontroller"><a class="markdownIt-Anchor" href="#categorycontroller"></a> CategoryController</h4><p>CRUD的RequestMapping都修改为了/categories,以前用的注解叫做@RequestMapper,现在分别叫做 GetMapper, PutMapper, PostMapper 和 DeleteMapper 用于表示接受对应的Method</p><pre><code class="highlight java"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.data.domain.Page;<span class="keyword">import</span> org.springframework.data.domain.PageRequest;<span class="keyword">import</span> org.springframework.data.domain.Pageable;<span class="keyword">import</span> org.springframework.data.domain.Sort;<span class="keyword">import</span> org.springframework.stereotype.Controller;<span class="keyword">import</span> org.springframework.ui.Model;<span class="keyword">import</span> org.springframework.web.bind.annotation.DeleteMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.PutMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam; <span class="keyword">import</span> com.how2java.springboot.dao.CategoryDAO;<span class="keyword">import</span> com.how2java.springboot.pojo.Category;  <span class="meta">@Controller</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryController</span> &#123;    <span class="meta">@Autowired</span> CategoryDAO categoryDAO;         <span class="meta">@GetMapping(&quot;/categories&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">listCategory</span><span class="params">(Model m,<span class="meta">@RequestParam(value = &quot;start&quot;, defaultValue = &quot;0&quot;)</span> <span class="type">int</span> start,<span class="meta">@RequestParam(value = &quot;size&quot;, defaultValue = &quot;5&quot;)</span> <span class="type">int</span> size)</span> <span class="keyword">throws</span> Exception &#123;        start = start&lt;<span class="number">0</span>?<span class="number">0</span>:start;        <span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sort</span>(Sort.Direction.DESC, <span class="string">&quot;id&quot;</span>);        <span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageRequest</span>(start, size, sort);        Page&lt;Category&gt; page =categoryDAO.findAll(pageable);        m.addAttribute(<span class="string">&quot;page&quot;</span>, page);        <span class="keyword">return</span> <span class="string">&quot;listCategory&quot;</span>;    &#125;     <span class="meta">@PostMapping(&quot;/categories&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">addCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryDAO.save(c);        <span class="keyword">return</span> <span class="string">&quot;redirect:/categories&quot;</span>;    &#125;    <span class="meta">@DeleteMapping(&quot;/categories/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">deleteCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryDAO.delete(c);        <span class="keyword">return</span> <span class="string">&quot;redirect:/categories&quot;</span>;    &#125;    <span class="meta">@PutMapping(&quot;/categories/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">updateCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryDAO.save(c);        <span class="keyword">return</span> <span class="string">&quot;redirect:/categories&quot;</span>;    &#125;    <span class="meta">@GetMapping(&quot;/categories/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">getCategory</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id,Model m)</span> <span class="keyword">throws</span> Exception &#123;        Category c= categoryDAO.getOne(id);        m.addAttribute(<span class="string">&quot;c&quot;</span>, c);        <span class="keyword">return</span> <span class="string">&quot;editCategory&quot;</span>;    &#125;&#125;</code></pre><h3 id="json"><a class="markdownIt-Anchor" href="#json"></a> JSON</h3><p>分别使用json的方式，提交，获取单个和获取多个</p><pre><code class="highlight plaintext">http://localhost:8080/submit.html</code></pre><pre><code class="highlight plaintext">http://localhost:8080/getOne.html</code></pre><pre><code class="highlight plaintext">http://localhost:8080/getMany.html</code></pre><h4 id="entity实体类"><a class="markdownIt-Anchor" href="#entity实体类"></a> Entity实体类</h4><p>增加一个注解：@JsonIgnoreProperties({<br />“handler”,“hibernateLazyInitializer”})，否则会出错</p><pre><code class="highlight java"> <span class="keyword">import</span> javax.persistence.Column;<span class="keyword">import</span> javax.persistence.Entity;<span class="keyword">import</span> javax.persistence.GeneratedValue;<span class="keyword">import</span> javax.persistence.GenerationType;<span class="keyword">import</span> javax.persistence.Id;<span class="keyword">import</span> javax.persistence.Table; <span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonIgnoreProperties; <span class="meta">@Entity</span><span class="meta">@Table(name = &quot;category_&quot;)</span><span class="meta">@JsonIgnoreProperties(&#123; &quot;handler&quot;,&quot;hibernateLazyInitializer&quot; &#125;)</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Category</span> &#123;     <span class="meta">@Id</span>    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>    <span class="meta">@Column(name = &quot;id&quot;)</span>    <span class="keyword">private</span> <span class="type">int</span> id;         <span class="meta">@Column(name = &quot;name&quot;)</span>    <span class="keyword">private</span> String name;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Category [id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;    &#125;     &#125;</code></pre><h4 id="controller-5"><a class="markdownIt-Anchor" href="#controller-5"></a> Controller</h4><p>控制器里提供三个方法，分别用来处理json提交，json获取单个对象，json获取多个对象</p><p><strong>@RestController</strong> 表示@ResponseBody<br />和@Controller两个注解的结合，前者的作用是标注框架，该controller中返回的http数据包不是http页面，是json或者是xml等其他数据格式（即修改http数据包包头中的相关字段）</p><p><strong>@ResquestBody</strong> 如果要接受json或xml数据，给Controller的方法参数注释该注解，根据HTTP Request Header的content-Type的内容,通过适当的HttpMessageConverter转换为JAVA类</p><pre><code class="highlight java"><span class="keyword">import</span> java.util.List; <span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.data.domain.Page;<span class="keyword">import</span> org.springframework.data.domain.PageRequest;<span class="keyword">import</span> org.springframework.data.domain.Pageable;<span class="keyword">import</span> org.springframework.data.domain.Sort;<span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<span class="keyword">import</span> org.springframework.web.bind.annotation.PutMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<span class="keyword">import</span> org.springframework.web.bind.annotation.RestController; <span class="keyword">import</span> com.how2java.springboot.dao.CategoryDAO;<span class="keyword">import</span> com.how2java.springboot.pojo.Category;  <span class="meta">@RestController</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryController</span> &#123;    <span class="meta">@Autowired</span> CategoryDAO categoryDAO;         <span class="meta">@GetMapping(&quot;/category&quot;)</span>    <span class="keyword">public</span> List&lt;Category&gt; <span class="title function_">listCategory</span><span class="params">(<span class="meta">@RequestParam(value = &quot;start&quot;, defaultValue = &quot;0&quot;)</span> <span class="type">int</span> start,<span class="meta">@RequestParam(value = &quot;size&quot;, defaultValue = &quot;5&quot;)</span> <span class="type">int</span> size)</span> <span class="keyword">throws</span> Exception &#123;        start = start&lt;<span class="number">0</span>?<span class="number">0</span>:start;        <span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sort</span>(Sort.Direction.DESC, <span class="string">&quot;id&quot;</span>);        <span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageRequest</span>(start, size, sort);        Page&lt;Category&gt; page =categoryDAO.findAll(pageable);        <span class="keyword">return</span> page.getContent();    &#125;         <span class="meta">@GetMapping(&quot;/category/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> Category <span class="title function_">getCategory</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span> <span class="keyword">throws</span> Exception &#123;        Category c= categoryDAO.getOne(id);        System.out.println(c);        <span class="keyword">return</span> c;    &#125;    <span class="meta">@PutMapping(&quot;/category&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCategory</span><span class="params">(<span class="meta">@RequestBody</span> Category category)</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;springboot接受到浏览器以JSON格式提交的数据：&quot;</span>+category);    &#125;&#125;</code></pre><h4 id="ajax"><a class="markdownIt-Anchor" href="#ajax"></a> Ajax</h4><h5 id="submithtml"><a class="markdownIt-Anchor" href="#submithtml"></a> submit.html</h5><p>访问地址</p><pre><code class="highlight plaintext">http://localhost:8080/submit.html</code></pre><p>提交成功后，在springboot控制台查看使用json方式提交的数据</p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>用AJAX以JSON方式提交数据<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>    <span class="tag">&lt;<span class="name">form</span> &gt;</span>       id：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span>       名称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;category xxx&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span>        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sender&quot;</span>&gt;</span>     <span class="tag">&lt;/<span class="name">form</span>&gt;</span>    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;messageDiv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>             <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    $(<span class="string">&#x27;#sender&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><span class="language-javascript">        <span class="keyword">var</span> id=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;id&#x27;</span>).<span class="property">value</span>;</span><span class="language-javascript">        <span class="keyword">var</span> name=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;name&#x27;</span>).<span class="property">value</span>;</span><span class="language-javascript">        <span class="keyword">var</span> category=&#123;<span class="string">&quot;name&quot;</span>:name,<span class="string">&quot;id&quot;</span>:id&#125;;</span><span class="language-javascript">        <span class="keyword">var</span> jsonData = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(category);</span><span class="language-javascript">        <span class="keyword">var</span> page=<span class="string">&quot;category&quot;</span>;</span><span class="language-javascript">          </span><span class="language-javascript">        $.<span class="title function_">ajax</span>(&#123;</span><span class="language-javascript">               <span class="attr">type</span>:<span class="string">&quot;put&quot;</span>,</span><span class="language-javascript">               <span class="attr">url</span>: page,</span><span class="language-javascript">               <span class="attr">data</span>:jsonData,</span><span class="language-javascript">               <span class="attr">dataType</span>:<span class="string">&quot;json&quot;</span>,</span><span class="language-javascript">               contentType : <span class="string">&quot;application/json;charset=UTF-8&quot;</span>,</span><span class="language-javascript">               <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">result</span>)&#123;</span><span class="language-javascript">               &#125;</span><span class="language-javascript">            &#125;);</span><span class="language-javascript">           <span class="title function_">alert</span>(<span class="string">&quot;提交成功，请在springboot控制台查看服务端接收到的数据&quot;</span>);</span><span class="language-javascript">  </span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span>     <span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><h5 id="getonehtml"><a class="markdownIt-Anchor" href="#getonehtml"></a> getOne.html</h5><p>访问地址：</p><pre><code class="highlight plaintext">http://localhost:8080/getOne.html</code></pre><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>用AJAX以JSON方式获取数据<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;通过AJAX获取一个Hero对象---&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sender&quot;</span>&gt;</span>          <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;messageDiv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>             <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    $(<span class="string">&#x27;#sender&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><span class="language-javascript">        <span class="keyword">var</span> url=<span class="string">&quot;category/10&quot;</span>;</span><span class="language-javascript">        $.<span class="title function_">get</span>(</span><span class="language-javascript">                url,</span><span class="language-javascript">                <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><span class="language-javascript">                     <span class="keyword">var</span> json=data;</span><span class="language-javascript">                     <span class="keyword">var</span> name =json.<span class="property">name</span>;</span><span class="language-javascript">                     <span class="keyword">var</span> id = json.<span class="property">id</span>;</span><span class="language-javascript">                     $(<span class="string">&quot;#messageDiv&quot;</span>).<span class="title function_">html</span>(<span class="string">&quot;分类id：&quot;</span>+ id + <span class="string">&quot;&lt;br&gt;分类名称:&quot;</span> +name );</span><span class="language-javascript">                        </span><span class="language-javascript">         &#125;); </span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span>     <span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><h5 id="getmanyhtml"><a class="markdownIt-Anchor" href="#getmanyhtml"></a> getMany.html</h5><p>访问测试地址：</p><pre><code class="highlight plaintext">http://localhost:8080/getMany.html</code></pre><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>用AJAX以JSON方式获取数据<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;通过AJAX获取多个分类对象&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sender&quot;</span>&gt;</span>          <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;messageDiv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>             <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    $(<span class="string">&#x27;#sender&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><span class="language-javascript">        <span class="keyword">var</span> url=<span class="string">&quot;category?start=0&amp;size=100&quot;</span>;</span><span class="language-javascript">        $.<span class="title function_">get</span>(</span><span class="language-javascript">                url,</span><span class="language-javascript">                <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><span class="language-javascript">                    <span class="keyword">var</span> categorys = data;</span><span class="language-javascript">                     <span class="keyword">for</span>(i <span class="keyword">in</span> categorys)&#123;</span><span class="language-javascript">                         <span class="keyword">var</span> old = $(<span class="string">&quot;#messageDiv&quot;</span>).<span class="title function_">html</span>();</span><span class="language-javascript">                         <span class="keyword">var</span> category = categorys[i];</span><span class="language-javascript">                         $(<span class="string">&quot;#messageDiv&quot;</span>).<span class="title function_">html</span>(old + <span class="string">&quot;&lt;br&gt;&quot;</span>+category.<span class="property">id</span>+<span class="string">&quot;   -----   &quot;</span>+category.<span class="property">name</span>);</span><span class="language-javascript">                     &#125;</span><span class="language-javascript">         &#125;); </span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span>     <span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><h3 id="redis-2"><a class="markdownIt-Anchor" href="#redis-2"></a> Redis</h3><p>下面的案例基于上述JPA分页教程</p><h4 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h4><p>Redis是一套key-value高性能数据库</p><h4 id="运行redis服务器"><a class="markdownIt-Anchor" href="#运行redis服务器"></a> 运行Redis服务器</h4><h4 id="pomxml-6"><a class="markdownIt-Anchor" href="#pomxml-6"></a> pom.xml</h4><p>增加对Redis支持的包</p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.how2java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  <span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  <span class="tag">&lt;<span class="name">description</span>&gt;</span>springboot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>       <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>              <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>              <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!-- servlet依赖. --&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>              <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>              <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!-- tomcat的支持.--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span> <span class="comment">&lt;!-- 这个需要为 true 热部署才有效 --&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>                 <span class="comment">&lt;!-- mysql--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>         <span class="comment">&lt;!-- jpa--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!-- redis --&gt;</span>               <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>               <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>               <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>          <span class="tag">&lt;<span class="name">version</span>&gt;</span> 4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>           <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>     <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>     <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span> <span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><h4 id="applicationproperties-5"><a class="markdownIt-Anchor" href="#applicationproperties-5"></a> application.properties</h4><p>增加redis相关配置<br />同时让hibernate的sql语句显示出来，这样才知道到底是通过Redis取到2的数据，还是依然从数据库中取得数据</p><pre><code class="highlight properties"><span class="attr">spring.mvc.view.prefix</span>=<span class="string">/WEB-INF/jsp/</span><span class="attr">spring.mvc.view.suffix</span>=<span class="string">.jsp</span><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8</span><span class="attr">spring.datasource.username</span>=<span class="string">root</span><span class="attr">spring.datasource.password</span>=<span class="string">admin</span><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span><span class="attr">spring.jpa.properties.hibernate.hbm2ddl.auto</span>=<span class="string">update</span><span class="comment"> </span><span class="comment">###########################redis#########################</span><span class="comment">#Redis数据库索引（默认为0）</span><span class="attr">spring.redis.database</span>=<span class="string">0</span><span class="comment">#Redis服务器地址</span><span class="attr">spring.redis.host</span>=<span class="string">127.0.0.1</span><span class="comment">#Redis服务器连接端口</span><span class="attr">spring.redis.port</span>=<span class="string">6379</span><span class="comment">#Redis服务器连接密码（默认为空）</span><span class="attr">spring.redis.password</span>=<span class="string"></span><span class="comment">#连接池最大连接数（使用负值表示没有限制）</span><span class="attr">spring.redis.pool.max-active</span>=<span class="string">10</span><span class="comment">#连接池最大阻塞等待时间（使用负值表示没有限制）</span><span class="attr">spring.redis.pool.max-wait</span>=<span class="string">-1</span><span class="comment">#连接池中的最大空闲连接</span><span class="attr">spring.redis.pool.max-idle</span>=<span class="string">8</span><span class="comment">#连接池中的最小空闲连接</span><span class="attr">spring.redis.pool.min-idle</span>=<span class="string">0</span><span class="comment">#连接超时时间（毫秒）</span><span class="attr">spring.redis.timeout</span>=<span class="string">0</span> <span class="attr">spring.jpa.show-sql</span>=<span class="string">true</span></code></pre><h4 id="application"><a class="markdownIt-Anchor" href="#application"></a> Application</h4><p>增加注解，以开启缓存</p><pre><code class="highlight plaintext">@EnableCaching</code></pre><pre><code class="highlight java"><span class="keyword">package</span> com.how2java.springboot;  <span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;  <span class="meta">@SpringBootApplication</span><span class="meta">@EnableCaching</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(Application.class, args);    &#125;  &#125;</code></pre><h4 id="redisconfigjava"><a class="markdownIt-Anchor" href="#redisconfigjava"></a> RedisConfig.java</h4><p>Redis缓存配置类<br />这个配置，一个作用：让保存到Redis里的key和value都转换为刻度的json格式，否则会是二进制格式，通过RedisClient工具也无法识别</p><pre><code class="highlight java"><span class="keyword">package</span> com.how2java.springboot.config;<span class="keyword">import</span> org.springframework.cache.CacheManager;<span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;<span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;<span class="keyword">import</span> org.springframework.context.annotation.Bean;<span class="keyword">import</span> org.springframework.context.annotation.Configuration;<span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;<span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;<span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;<span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer; <span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;<span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;<span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper; <span class="comment">//该注解的意思是表示该类是一个spring配置类，相当于给spriApplication.xml中加一句话</span><span class="meta">@Configuration</span><span class="meta">@EnableCaching</span><span class="comment">//Redis 缓存配置类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;     <span class="meta">@Bean</span>    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisTemplate&lt;?,?&gt; redisTemplate)</span> &#123;        <span class="type">RedisSerializer</span> <span class="variable">stringSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.PUBLIC_ONLY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        redisTemplate.setKeySerializer(stringSerializer);        redisTemplate.setHashKeySerializer(stringSerializer);                   redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);                 redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);        <span class="type">CacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisCacheManager</span>(redisTemplate);        <span class="keyword">return</span> cacheManager;      &#125;&#125;</code></pre><h4 id="page4navigator"><a class="markdownIt-Anchor" href="#page4navigator"></a> Page4Navigator</h4><p>创建一个工具类 Page4Navigator 用以替换 原本分页查询要返回的 org.springframework.data.domain.Page 类。 原因是 Page 类对json 还原不支持，在放如 Redis 之后，再拿出来，就会报错失败。</p><p>使用 Page4Navigator 对其包裹，就解决了这个问题了。</p><pre><code class="highlight java"><span class="keyword">package</span> com.how2java.springboot.util; <span class="keyword">import</span> java.util.List; <span class="keyword">import</span> org.springframework.data.domain.Page; <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Page4Navigator</span>&lt;T&gt; &#123;    Page&lt;T&gt; page4jpa;    <span class="type">int</span> navigatePages;         <span class="type">int</span> totalPages;     <span class="type">int</span> number;         <span class="type">long</span> totalElements;         <span class="type">int</span> size;     <span class="type">int</span> numberOfElements;     List&lt;T&gt; content;     <span class="type">boolean</span> isHasContent;     <span class="type">boolean</span> first;     <span class="type">boolean</span> last;         <span class="type">boolean</span> isHasNext;     <span class="type">boolean</span> isHasPrevious;         <span class="type">int</span>[] navigatepageNums;         <span class="keyword">public</span> <span class="title function_">Page4Navigator</span><span class="params">()</span> &#123;        <span class="comment">//这个空的分页是为了 Redis 从 json格式转换为 Page4Navigator 对象而专门提供的</span>    &#125;         <span class="keyword">public</span> <span class="title function_">Page4Navigator</span><span class="params">(Page&lt;T&gt; page4jpa,<span class="type">int</span> navigatePages)</span> &#123;        <span class="built_in">this</span>.page4jpa = page4jpa;        <span class="built_in">this</span>.navigatePages = navigatePages;                 totalPages = page4jpa.getTotalPages();                 number  = page4jpa.getNumber() ;                 totalElements = page4jpa.getTotalElements();                 size = page4jpa.getSize();                 numberOfElements = page4jpa.getNumberOfElements();                 content = page4jpa.getContent();                 isHasContent = page4jpa.hasContent();                         first = page4jpa.isFirst();                 last = page4jpa.isLast();                 isHasNext = page4jpa.hasNext();                 isHasPrevious  = page4jpa.hasPrevious();                        calcNavigatepageNums();             &#125;     <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">calcNavigatepageNums</span><span class="params">()</span> &#123;        <span class="type">int</span> navigatepageNums[];        <span class="type">int</span> <span class="variable">totalPages</span> <span class="operator">=</span> getTotalPages();        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> getNumber();        <span class="comment">//当总页数小于或等于导航页码数时</span>        <span class="keyword">if</span> (totalPages &lt;= navigatePages) &#123;            navigatepageNums = <span class="keyword">new</span> <span class="title class_">int</span>[totalPages];            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalPages; i++) &#123;                navigatepageNums[i] = i + <span class="number">1</span>;            &#125;        &#125; <span class="keyword">else</span> &#123; <span class="comment">//当总页数大于导航页码数时</span>            navigatepageNums = <span class="keyword">new</span> <span class="title class_">int</span>[navigatePages];            <span class="type">int</span> <span class="variable">startNum</span> <span class="operator">=</span> num - navigatePages / <span class="number">2</span>;            <span class="type">int</span> <span class="variable">endNum</span> <span class="operator">=</span> num + navigatePages / <span class="number">2</span>;             <span class="keyword">if</span> (startNum &lt; <span class="number">1</span>) &#123;                startNum = <span class="number">1</span>;                <span class="comment">//(最前navigatePages页</span>                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; navigatePages; i++) &#123;                    navigatepageNums[i] = startNum++;                &#125;            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (endNum &gt; totalPages) &#123;                endNum = totalPages;                <span class="comment">//最后navigatePages页</span>                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> navigatePages - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;                    navigatepageNums[i] = endNum--;                &#125;            &#125; <span class="keyword">else</span> &#123;                <span class="comment">//所有中间页</span>                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; navigatePages; i++) &#123;                    navigatepageNums[i] = startNum++;                &#125;            &#125;        &#125;          <span class="built_in">this</span>.navigatepageNums = navigatepageNums;    &#125;     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNavigatePages</span><span class="params">()</span> &#123;        <span class="keyword">return</span> navigatePages;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNavigatePages</span><span class="params">(<span class="type">int</span> navigatePages)</span> &#123;        <span class="built_in">this</span>.navigatePages = navigatePages;    &#125;     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTotalPages</span><span class="params">()</span> &#123;        <span class="keyword">return</span> totalPages;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTotalPages</span><span class="params">(<span class="type">int</span> totalPages)</span> &#123;        <span class="built_in">this</span>.totalPages = totalPages;    &#125;     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span> &#123;        <span class="keyword">return</span> number;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">(<span class="type">int</span> number)</span> &#123;        <span class="built_in">this</span>.number = number;    &#125;     <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTotalElements</span><span class="params">()</span> &#123;        <span class="keyword">return</span> totalElements;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTotalElements</span><span class="params">(<span class="type">long</span> totalElements)</span> &#123;        <span class="built_in">this</span>.totalElements = totalElements;    &#125;     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;        <span class="keyword">return</span> size;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSize</span><span class="params">(<span class="type">int</span> size)</span> &#123;        <span class="built_in">this</span>.size = size;    &#125;     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumberOfElements</span><span class="params">()</span> &#123;        <span class="keyword">return</span> numberOfElements;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNumberOfElements</span><span class="params">(<span class="type">int</span> numberOfElements)</span> &#123;        <span class="built_in">this</span>.numberOfElements = numberOfElements;    &#125;     <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">getContent</span><span class="params">()</span> &#123;        <span class="keyword">return</span> content;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(List&lt;T&gt; content)</span> &#123;        <span class="built_in">this</span>.content = content;    &#125;     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHasContent</span><span class="params">()</span> &#123;        <span class="keyword">return</span> isHasContent;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHasContent</span><span class="params">(<span class="type">boolean</span> isHasContent)</span> &#123;        <span class="built_in">this</span>.isHasContent = isHasContent;    &#125;     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFirst</span><span class="params">()</span> &#123;        <span class="keyword">return</span> first;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(<span class="type">boolean</span> first)</span> &#123;        <span class="built_in">this</span>.first = first;    &#125;     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLast</span><span class="params">()</span> &#123;        <span class="keyword">return</span> last;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLast</span><span class="params">(<span class="type">boolean</span> last)</span> &#123;        <span class="built_in">this</span>.last = last;    &#125;     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHasNext</span><span class="params">()</span> &#123;        <span class="keyword">return</span> isHasNext;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHasNext</span><span class="params">(<span class="type">boolean</span> isHasNext)</span> &#123;        <span class="built_in">this</span>.isHasNext = isHasNext;    &#125;     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHasPrevious</span><span class="params">()</span> &#123;        <span class="keyword">return</span> isHasPrevious;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHasPrevious</span><span class="params">(<span class="type">boolean</span> isHasPrevious)</span> &#123;        <span class="built_in">this</span>.isHasPrevious = isHasPrevious;    &#125;     <span class="keyword">public</span> <span class="type">int</span>[] getNavigatepageNums() &#123;        <span class="keyword">return</span> navigatepageNums;    &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNavigatepageNums</span><span class="params">(<span class="type">int</span>[] navigatepageNums)</span> &#123;        <span class="built_in">this</span>.navigatepageNums = navigatepageNums;    &#125; &#125;</code></pre><h4 id="categoryserviceimpl"><a class="markdownIt-Anchor" href="#categoryserviceimpl"></a> CategoryServiceImpl</h4><p>实现类CategoryService做了以下工作：</p><ol><li>实现CategoryService接口，提供crud</li><li>在相应方法实现的时候，都是通过调用dao实现的</li><li>CacheConfig，表示分类数据在redis中都放在category这个分组里</li></ol><pre><code class="highlight plaintext">@CacheConfig(cacheNames=&quot;category&quot;)</code></pre><ol start="4"><li>list方法讲解<br /><strong>#p0是指在加有@Cacheable注解的方法中的第一个参数，比如上述list(Pageable pageable)中第一个参数就是pageable。#p0.offset相当于pageable.offset的意思</strong></li></ol><pre><code class="highlight plaintext">@Cacheable(key=&quot;&#x27;category &#x27;+#p0.offset + &#x27;-&#x27; + #p0.pageSize &quot;)</code></pre><p>假如是第一页，即offset=0，pageSize=5，那么会创建一个 key: “category 0-5”<br />首先根据这个key 到 redis中查询数据。 第一次是不会有数据的，那么就会从数据库中取到这5条数据，然后以这个 key: “category 0-5” 保存到 redis 数据库中。<br />下一次再次访问的时候，根据这个key，就可以从 redis 里取到数据了</p><ol start="5"><li>get方法注解</li></ol><pre><code class="highlight plaintext">@Cacheable(key=&quot;&#x27;category &#x27;+ #p0&quot;)</code></pre><p>假如是获取id=71的数据，那么就会以 key= “category 71” 到reids中去获取，如果没有就会从数据库中拿到，然后再以 key= “category 71” 这个值存放到 redis 当中。</p><p>下一次再次访问的时候，根据这个key，就可以从 redis 里取到数据了</p><ol start="6"><li>add方法讲解</li></ol><pre><code class="highlight plaintext">@CacheEvict(allEntries=true)// @CachePut(key=&quot;&#x27;category &#x27;+ #p0&quot;)</code></pre><p>可以看到，本来有个 CachePut，但是被注释掉了。 按理说，本来是应该用这个的。 这样会到在，在增加数据之后，就会在Redis 中以 key= “category 71” 缓存一条数据。 但是为什么被注释掉不用呢？</p><p>因为加入这样做了，那么 list 对应的数据，在缓存在对应的数据，并没有发生变化呀？ 因为 list 对应的数据是这样的 key: “category 0-5”。 如果用这种方式，就会导致数据不同步，即，虽然增加了，并且也增加到缓存中了，但是因为 key 不一样，通过查询拿到的数据，是不会包含新的这一条的。</p><p>所以，才会使用CacheEvict 这个注解，这个注解就表示清除掉缓存。 allEntries= true 是表示清除掉 category 分组 下所有的keys. 注意看截图，里面有一个 category~keys ，里面就表明了都有哪些 keys,都会被清除掉。</p><p>假如这个时候，还有一个分组 cacheNames=“product”, 那么它下面对应的缓存，都是不会被影响到的。 这样就保证了，只清楚当前分组下的缓存，而不是清除 redis 所有的数据了<br />7. delete方法讲解</p><pre><code class="highlight plaintext">@CacheEvict(allEntries=true)// @CacheEvict(key=&quot;&#x27;category &#x27;+ #p0&quot;)</code></pre><p>这个道理和 add 是一样的，仅仅删除 key= “category 71” ，没有什么意义， key: “category 0-5” 里面的数据没有影响呀。 所以还是通过 CacheEvict删除掉所有的缓存就好了</p><pre><code class="highlight java"><span class="keyword">package</span> com.how2java.springboot.service.impl; <span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.cache.annotation.CacheConfig;<span class="keyword">import</span> org.springframework.cache.annotation.CacheEvict;<span class="keyword">import</span> org.springframework.cache.annotation.CachePut;<span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;<span class="keyword">import</span> org.springframework.data.domain.Page;<span class="keyword">import</span> org.springframework.data.domain.Pageable;<span class="keyword">import</span> org.springframework.stereotype.Service; <span class="keyword">import</span> com.how2java.springboot.dao.CategoryDAO;<span class="keyword">import</span> com.how2java.springboot.pojo.Category;<span class="keyword">import</span> com.how2java.springboot.service.CategoryService;<span class="keyword">import</span> com.how2java.springboot.util.Page4Navigator; <span class="meta">@Service</span><span class="meta">@CacheConfig(cacheNames=&quot;category&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CategoryService</span>&#123;     <span class="meta">@Autowired</span> CategoryDAO categoryDAO;         <span class="meta">@Override</span>    <span class="meta">@Cacheable(key=&quot;&#x27;category &#x27;+#p0.offset + &#x27;-&#x27; + #p0.pageSize &quot;)</span>    <span class="keyword">public</span> Page4Navigator&lt;Category&gt; <span class="title function_">list</span><span class="params">(Pageable pageable)</span> &#123;        Page&lt;Category&gt; pageFromJPA=  categoryDAO.findAll(pageable);        Page4Navigator&lt;Category&gt; page = <span class="keyword">new</span> <span class="title class_">Page4Navigator</span>&lt;&gt;(pageFromJPA,<span class="number">5</span>);        <span class="keyword">return</span> page;    &#125;     <span class="meta">@Override</span>    <span class="meta">@Cacheable(key=&quot;&#x27;category &#x27;+ #p0&quot;)</span>    <span class="keyword">public</span> Category <span class="title function_">get</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="type">Category</span> <span class="variable">c</span> <span class="operator">=</span>categoryDAO.findOne(id);        <span class="keyword">return</span> c;    &#125;           <span class="meta">@Override</span>    <span class="meta">@CacheEvict(allEntries=true)</span><span class="comment">//  @CachePut(key=&quot;&#x27;category &#x27;+ #p0&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Category category)</span> &#123;        <span class="comment">// TODO Auto-generated method stub</span>        categoryDAO.save(category);    &#125;         <span class="meta">@Override</span>    <span class="meta">@CacheEvict(allEntries=true)</span><span class="comment">//  @CacheEvict(key=&quot;&#x27;category &#x27;+ #p0&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="comment">// TODO Auto-generated method stub</span>        categoryDAO.delete(id);    &#125; &#125;</code></pre><h4 id="categorycontroller-2"><a class="markdownIt-Anchor" href="#categorycontroller-2"></a> CategoryController</h4><p>由原来的从dao获取，变为了从Service获取</p><pre><code class="highlight java"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.data.domain.PageRequest;<span class="keyword">import</span> org.springframework.data.domain.Pageable;<span class="keyword">import</span> org.springframework.data.domain.Sort;<span class="keyword">import</span> org.springframework.stereotype.Controller;<span class="keyword">import</span> org.springframework.ui.Model;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam; <span class="keyword">import</span> com.how2java.springboot.pojo.Category;<span class="keyword">import</span> com.how2java.springboot.service.CategoryService;<span class="keyword">import</span> com.how2java.springboot.util.Page4Navigator;  <span class="meta">@Controller</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryController</span> &#123;    <span class="meta">@Autowired</span> CategoryService categoryService;         <span class="meta">@RequestMapping(&quot;/listCategory&quot;)</span>         <span class="keyword">public</span> String <span class="title function_">listCategory</span><span class="params">(Model m,<span class="meta">@RequestParam(value = &quot;start&quot;, defaultValue = &quot;0&quot;)</span> <span class="type">int</span> start,<span class="meta">@RequestParam(value = &quot;size&quot;, defaultValue = &quot;5&quot;)</span> <span class="type">int</span> size)</span> <span class="keyword">throws</span> Exception &#123;        start = start&lt;<span class="number">0</span>?<span class="number">0</span>:start;        <span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sort</span>(Sort.Direction.DESC, <span class="string">&quot;id&quot;</span>);        <span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageRequest</span>(start, size, sort);        Page4Navigator&lt;Category&gt; page =categoryService.list(pageable);        m.addAttribute(<span class="string">&quot;page&quot;</span>, page);        <span class="keyword">return</span> <span class="string">&quot;listCategory&quot;</span>;    &#125;     <span class="meta">@RequestMapping(&quot;/addCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">addCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryService.save(c);        <span class="keyword">return</span> <span class="string">&quot;redirect:listCategory&quot;</span>;    &#125;    <span class="meta">@RequestMapping(&quot;/deleteCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">deleteCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryService.delete(c.getId());        <span class="keyword">return</span> <span class="string">&quot;redirect:listCategory&quot;</span>;    &#125;    <span class="meta">@RequestMapping(&quot;/updateCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">updateCategory</span><span class="params">(Category c)</span> <span class="keyword">throws</span> Exception &#123;        categoryService.save(c);        <span class="keyword">return</span> <span class="string">&quot;redirect:listCategory&quot;</span>;    &#125;    <span class="meta">@RequestMapping(&quot;/editCategory&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">ediitCategory</span><span class="params">(<span class="type">int</span> id,Model m)</span> <span class="keyword">throws</span> Exception &#123;        Category c= categoryService.get(id);        m.addAttribute(<span class="string">&quot;c&quot;</span>, c);        <span class="keyword">return</span> <span class="string">&quot;editCategory&quot;</span>;    &#125;&#125;</code></pre>]]>
    </content>
    <id>http://example.com/2023/07/02/Spring-Boot/</id>
    <link href="http://example.com/2023/07/02/Spring-Boot/"/>
    <published>2023-07-02T04:00:00.000Z</published>
    <summary>Spring Boot是一个基于Spring的套件，它帮我们预组装了Spring的一系列组件，以便以尽可能少的代码和配置来开发基于Spring的Java应用程序。</summary>
    <title>Spring Boot</title>
    <updated>2026-02-27T01:23:04.125Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    <content>
      <![CDATA[<h1 id="spring-aop"><a class="markdownIt-Anchor" href="#spring-aop"></a> $Spring AOP</h1><h1 id="spring-aop-2"><a class="markdownIt-Anchor" href="#spring-aop-2"></a> Spring AOP</h1><ul><li><a href="">Spring AOP</a><ul><li><a href="">AOP</a><ul><li><a href="">意图</a></li><li><a href="">实现原理</a></li><li><a href="">作用/优势</a></li><li><a href="">Spring 框架的AOP</a><ul><li><a href="">AOP术语</a></li></ul></li></ul></li><li><a href="">AOP实现类型</a><ul><li><a href="">类型</a><ul><li><a href="">Spring自身实现</a></li><li><a href="">AspectJ实现</a></li></ul></li><li><a href="">AOP实现之AspectJ</a></li><li><a href="">AOP实现之Spring AOP</a><ul><li><a href="">代理模式实现步骤</a></li><li><a href="">动态代理技术</a><ul><li><a href="">JDK动态代理</a></li><li><a href="">CGLib动态代理</a></li></ul></li><li><a href="">Spring AOP：简化代理模式实现步骤</a></li></ul></li></ul></li><li><a href="">Spring AOP 使用</a><ul><li><a href="">编程式AOP ProxyFactory</a><ul><li><a href="">创建代理工厂，设置被代理对象，添加通知</a></li></ul></li><li><a href="">声明式AOP ProxyFactoryBean</a><ul><li><a href="">Advice</a><ul><li><a href="">定义接口</a></li><li><a href="">实现接口</a></li><li><a href="">定义Advice</a></li><li><a href="">使用IOC配置的方式实现代理</a></li><li><a href="">小结</a></li></ul></li><li><a href="">Advisor 顾问</a><ul><li><a href="">声明接口</a></li><li><a href="">接口实现</a></li><li><a href="">切面Advice</a></li><li><a href="">ClassFilter 类拦截器</a></li><li><a href="">MethodMatcher 方法拦截器</a></li><li><a href="">PointCut</a></li><li><a href="">PointCutAdvisor</a></li><li><a href="">spring配置文件</a></li></ul></li></ul></li></ul></li><li><a href="">AspectJ AOP（一般使用该方式）</a><ul><li><a href="">AspectJ的XML实现AOP</a><ul><li><a href="">实现步骤</a><ul><li><a href="">编写目标类</a></li><li><a href="">maven依赖</a></li><li><a href="">编写一个advice（通知）</a></li><li><a href="">配置通知</a></li><li><a href="">配置AOP切面</a></li></ul></li><li><a href="">切入点表达式</a></li><li><a href="">通知类型</a></li><li><a href="">XML实现Spring AOP 案例</a></li></ul></li><li><a href="">AspectJ的注解实现AOP</a><ul><li><a href="">实现步骤</a><ul><li><a href="">编写目标类</a></li><li><a href="">开启AOP自动代理</a></li><li><a href="">编写Aspect（切面）类</a></li><li><a href="">配置切面类</a></li></ul></li><li><a href="">其他注解使用方式</a></li><li><a href="">环绕通知注解配置（特殊）</a></li><li><a href="">定义通用切入点</a></li><li><a href="">零注解配置</a></li><li><a href="">原理</a></li><li><a href="">案例:注解配置AOP</a></li><li><a href="">AspectJ切点函数</a><ul><li><a href="">表达式类型</a></li><li><a href="">使用示例，案例</a></li><li><a href="">表达式组合</a></li></ul></li><li><a href="">自定义注解装配AOP</a></li></ul></li></ul></li></ul></li></ul><h2 id="aop"><a class="markdownIt-Anchor" href="#aop"></a> AOP</h2><p>在软件业，AOP意为面向切面编程，通过<strong>预编译方式</strong>或<strong>运行期动态代理</strong>实现程序功能的统一维护的一种技术，AOP是OOP的延续，是软件开发中的一个热点，也是spring框架中的一个重要内容，是函数式编程的一种衍生泛型，利用AOP可以对业务逻辑的各个部分进行隔离，从而是的业务逻辑各部分之间耦合度降低，提高程序的可重用性，同时提高了开发的效率</p><h3 id="意图"><a class="markdownIt-Anchor" href="#意图"></a> 意图</h3><ul><li>将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码</li></ul><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>AOP可以说是对OOP的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码，属于静态代理</p><p>在Java平台上，对于AOP的织入，有3种方式：</p><ul><li>编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ就扩展了Java编译器，使用关键字aspect来实现织入；</li><li>类加载器：在目标类被装载到JVM时，通过一个特殊的类加载器，对目标类的字节码重新“增强”；</li><li>运行期：目标对象和切面都是普通Java类，通过JVM的动态代理功能或者第三方库实现运行期动态织入。</li></ul><p>最简单的方式是第三种，Spring的AOP实现就是基于JVM的动态代理。由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过CGLIB或者Javassist这些第三方库实现。</p><h3 id="作用优势"><a class="markdownIt-Anchor" href="#作用优势"></a> 作用/优势</h3><p><strong>作用：</strong></p><p>AOP采取横向抽取机制，取代了传统纵向继承体系的重复性代码（性能监视，事务管理，安全检查，缓存）</p><p>在程序运行期间，不修改源码对已有方法进行增强</p><p>将业务逻辑和系统处理的代码（关闭连接，事务管理，操作日志记录）解耦</p><p><strong>优势：</strong></p><ul><li>减少重复代码</li><li>提高开发效率</li><li>维护方便</li></ul><h3 id="spring-框架的aop"><a class="markdownIt-Anchor" href="#spring-框架的aop"></a> Spring 框架的AOP</h3><ul><li>Spring 框架的一个关键组件是<strong>面向方面的编程</strong>(AOP)框架。面向方面的编程需要把程序逻辑分解成不同的部分称为所谓的关注点。跨一个应用程序的多个点的功能被称为<strong>横切关注点</strong>，这些横切关注点在概念上独立于应用程序的业务逻辑。有各种各样的常见的很好的方面的例子，如日志记录、审计、声明式事务、安全性和缓存等。</li><li>在 OOP 中，关键单元模块度是类，而在 AOP 中单元模块度是方面。依赖注入帮助你对应用程序对象相互解耦和 AOP 可以帮助你从它们所影响的对象中对横切关注点解耦。</li><li><strong>横切关注点：</strong> 跨越应用程序的多个模块的方法或功能。（软件系统，可以看做由一组关注点即业务或功能或方法组成，其中，直接的业务关注点是直切关注点，而为直切关注点服务的，就是横切关注点），即与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点</li></ul><h4 id="aop术语"><a class="markdownIt-Anchor" href="#aop术语"></a> AOP术语</h4><table><thead><tr><th>顶</th><th>描述</th></tr></thead><tbody><tr><td>切面(Aspect)</td><td>是切入点和通知的结合</td></tr><tr><td>目标(Target)</td><td>被通知的对象，即业务类的对象</td></tr><tr><td>代理(Proxy)</td><td>一个类被AOP织入增强后，就产生一个结果代理类</td></tr><tr><td>切入点(PointCut)</td><td>切面通知执行的“地点”的定义；目标对象中真正被切面织入的方法，切入点一定是连接点，但连接点不一定是切入点，被标记为final的方法是不能作用连接点与切入点的</td></tr><tr><td>连接点(JointPoint)</td><td>与切入点匹配的执行点，即目标对象中可以被切面（次要业务）织入的方法，所有要监控的方法都称为连接点，就是<strong>接口中的方法</strong></td></tr><tr><td>通知(Advice)</td><td>通知是切面（次要业务）的一种，可以完成简单的织入功能。通知可以定义切面织入的时间点，切入点定义了切面织入的位置；<strong>针对一个接口中的所有方法，不够灵活</strong></td></tr><tr><td>顾问(Advisor)</td><td>顾问是切面（次要业务）的一种，能够将通知以更为复杂的的方式织入到目标对象中，是将通知包装为更复杂的切面的装配器</td></tr></tbody></table><h2 id="aop实现类型"><a class="markdownIt-Anchor" href="#aop实现类型"></a> AOP实现类型</h2><h3 id="类型"><a class="markdownIt-Anchor" href="#类型"></a> 类型</h3><h4 id="spring自身实现"><a class="markdownIt-Anchor" href="#spring自身实现"></a> Spring自身实现</h4><ol><li><strong>ProxyFactory</strong>：编程式使用AOP</li><li><strong>ProxyFactoryBean</strong>：声明式使用AOP，专门生成代理对象的工厂<ul><li><strong>Advice通知</strong> 使用更简单</li><li><strong>Advisor顾问</strong> 操纵更灵活</li></ul></li></ol><blockquote><p>底层又分为<strong>JDK动态代理实现</strong> 和 <strong>CGLib动态代理实现</strong></p></blockquote><h4 id="aspectj实现"><a class="markdownIt-Anchor" href="#aspectj实现"></a> AspectJ实现</h4><ol><li><strong>AspectJProxyFactory</strong>：集成spring与Aspect实现AOP</li></ol><ul><li><strong>这三个类都继承自</strong><ul><li>ProxyConfig：提供配置属性</li><li>AdvisedSupport：封装了通知与通知器</li><li>ProxyCreatorSupport：代理对象创建的辅助类</li></ul></li></ul><h3 id="aop实现之aspectj"><a class="markdownIt-Anchor" href="#aop实现之aspectj"></a> AOP实现之AspectJ</h3><p>AspectJ是一个java实现的AOP框架，它能够对java代码进行AOP编译（一般在编译期进行），让java代码具有AspectJ的AOP功能（当然需要特殊的编译器）</p><p>可以这样说AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言，更幸运的是，AspectJ与java程序完全兼容，几乎是无缝关联，因此对于有java编程基础的工程师，上手和使用都非常容易。</p><p>了解AspectJ应用到java代码的过程（这个过程称为织入），对于织入这个概念，可以简单理解为aspect(切面)应用到目标函数(类)的过程。</p><p>对于这个过程，<strong>一般分为动态织入和静态织入，动态织入的方式是在运行时动态将要增强的代码织入到目标类中</strong>，这样往往是通过动态代理技术完成的，如Java JDK的动态代理(Proxy，底层通过反射实现)或者CGLIB的动态代理(底层通过继承实现)，Spring AOP采用的就是基于运行时增强的代理技术</p><p><strong>ApectJ采用的就是静态织入的方式</strong>。ApectJ主要采用的是编译期织入，在这个期间使用AspectJ的acj编译器(类似javac)把aspect类编译成class字节码后，在java目标类编译时织入，即先编译aspect类再编译目标类。</p><p><strong>spring整合了ApectJ框架，但是底层没有使用acj编译器，而是使用动态代理技术</strong></p><h3 id="aop实现之spring-aop"><a class="markdownIt-Anchor" href="#aop实现之spring-aop"></a> AOP实现之Spring AOP</h3><p><strong>本质目的就是对代理模式的简化，为了方便开发人员简化代理模式的实现，统一管理</strong></p><p>spring AOP是通过<strong>动态代理技术实现</strong>的</p><ul><li>动态代理技术（反射）：<strong>基于JDK的动态代理</strong>和使用<strong>CGLib的动态代理</strong></li><li>动态代理方式选择：根据是否实现接口来选择哪种代理方式</li></ul><h4 id="代理模式实现步骤"><a class="markdownIt-Anchor" href="#代理模式实现步骤"></a> 代理模式实现步骤</h4><ol><li>声明接口：注册需要被监听行为的名称</li><li>接口实现类：扮演被监控的类，负责被监听方法实现细节</li><li>InvocationHanler接口实现类：<ul><li>次要业务/增强业务</li><li>将次要业务与被监听方法绑定执行</li></ul></li><li>代理监控对象：<ul><li>被监控类内存地址，被监控类实现的接口，InvocationHanler实现类的实例对象</li></ul></li></ol><h4 id="动态代理技术"><a class="markdownIt-Anchor" href="#动态代理技术"></a> 动态代理技术</h4><ol><li>基于JDK（实现接口）</li><li>使用CGLib（都可以使用）</li></ol><p>Spring两种动态代理技术都有使用，通过是否实现接口来判断用哪个动态代理技术</p><h5 id="jdk动态代理"><a class="markdownIt-Anchor" href="#jdk动态代理"></a> JDK动态代理</h5><p><strong>目标对象必须实现接口</strong></p><p>使用Proxy类来生成代理对象的代码如下：</p><pre><code class="highlight plaintext">    /**     * 使用JDK的方式生成代理对象     * @author Administrator     */    public class MyProxyUtils &#123;        public static UserService getProxy(final UserService service) &#123;//Porxy是JDK中的API类//第一个参数：目标队形的类加载器//第二个参数：目标对象的接口//第三个参数：代理对象的执行处理器            // 使用Proxy类生成代理对象            UserService proxy =                  (UserService) Proxy.newProxyInstance(                    service.getClass().getClassLoader(),                    service.getClass().getInterfaces(),                     new InvocationHandler() &#123;                        // 代理对象方法一执行，invoke方法就会执行一次                        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                            if(&quot;save&quot;.equals(method.getName()))&#123;                                System.out.println(&quot;记录日志...&quot;);                                // 开启事务                            &#125;                            // 提交事务                            // 让service类的save或者update方法正常的执行下去                            return method.invoke(service, args);                        &#125;                    &#125;);            // 返回代理对象            return proxy;        &#125;    &#125;</code></pre><h5 id="cglib动态代理"><a class="markdownIt-Anchor" href="#cglib动态代理"></a> CGLib动态代理</h5><p><strong>目标对象不需要实现接口</strong></p><p>底层是通过继承目标对象产生代理子对象（代理子对象中继承了目标对象的方法并可以对该方法进行增强）</p><pre><code class="highlight plaintext">public static UserService getProxy()&#123;        // 创建CGLIB核心的类        Enhancer enhancer = new Enhancer();        // 设置父类        enhancer.setSuperclass(UserServiceImpl.class);        // 设置回调函数        enhancer.setCallback(new MethodInterceptor() &#123;            @Override            public Object intercept(Object obj, Method method, Object[] args,                    MethodProxy methodProxy) throws Throwable &#123;                if(&quot;save&quot;.equals(method.getName()))&#123;                    // 记录日志                    System.out.println(&quot;记录日志了...&quot;);                &#125;                return methodProxy.invokeSuper(obj, args);            &#125;        &#125;);        // 生成增强之后的代理对象        UserService proxy = (UserService) enhancer.create();        return proxy;    &#125;</code></pre><h4 id="spring-aop简化代理模式实现步骤"><a class="markdownIt-Anchor" href="#spring-aop简化代理模式实现步骤"></a> Spring AOP：简化代理模式实现步骤</h4><ol><li>声明接口：注册需要被监听行为名称</li><li>接口实现类：扮演被监控的类，负责被监听方法的实现细节</li><li>次要业务/增强业务</li></ol><p><strong>所以说spring AOP吧代理模式的5个步骤省略为3个步骤，只需实现相关的接口和类，再加以配置，就可以实现代理模式</strong></p><p>Spring AOP中的新增名词也基本都是为了上述代理模式的实现而服务的，它的<strong>本质就是为了简化代理模式的实现</strong></p><h2 id="spring-aop-使用"><a class="markdownIt-Anchor" href="#spring-aop-使用"></a> Spring AOP 使用</h2><p>Spring AOP是指Spring自身对AOP的实现，与AspectJ无关系</p><h3 id="编程式aop-proxyfactory"><a class="markdownIt-Anchor" href="#编程式aop-proxyfactory"></a> 编程式AOP ProxyFactory</h3><h4 id="创建代理工厂设置被代理对象添加通知"><a class="markdownIt-Anchor" href="#创建代理工厂设置被代理对象添加通知"></a> 创建代理工厂，设置被代理对象，添加通知</h4><pre><code class="highlight plaintext">package com.zhangguo.Spring041.aop05;import org.springframework.aop.framework.ProxyFactory;public class Test &#123;    @org.junit.Test    public void test01()    &#123;        //实例化Spring代理工厂        ProxyFactory factory=new ProxyFactory();        //设置被代理的对象        factory.setTarget(new Math());        //添加通知，横切逻辑        factory.addAdvice(new BeforeAdvice());        factory.addAdvice(new AfterAdvice());        factory.addAdvice(new SurroundAdvice());        //从代理工厂中获得代理对象        IMath math=(IMath) factory.getProxy();        int n1=100,n2=5;        math.add(n1, n2);        math.sub(n1, n2);        math.mut(n1, n2);        math.div(n1, n2);    &#125;    @org.junit.Test    public void test02()    &#123;        //message.message();    &#125;&#125;</code></pre><ul><li>运行结果</li></ul><h3 id="声明式aop-proxyfactorybean"><a class="markdownIt-Anchor" href="#声明式aop-proxyfactorybean"></a> 声明式AOP ProxyFactoryBean</h3><h4 id="advice"><a class="markdownIt-Anchor" href="#advice"></a> Advice</h4><p><strong>通知Advice的类型</strong></p><ul><li>springAOP中，通过Advice定义横切逻辑，Spring中支持5中类型的Advice</li></ul><table><thead><tr><th>通知</th><th>连接点</th><th>实现接口</th></tr></thead><tbody><tr><td>前置通知</td><td>方法前</td><td>org.springframework.aop.MethodBeforeAdvice</td></tr><tr><td>后置通知</td><td>方法后</td><td>org.springframework.aop.AfterReturningAdvice</td></tr><tr><td>环绕通知</td><td>方法前后</td><td>org.aopalliance.intercept.MethodInterceptor</td></tr><tr><td>抛出异常后通知</td><td>方法抛出异常</td><td>org.springframework.aop.ThrowsAdvice</td></tr><tr><td>引介通知</td><td>类中增加新的方法属性</td><td>org.springframework.aop.IntroductionInterceptor</td></tr></tbody></table><p><strong>前置通知</strong></p><pre><code class="highlight plaintext">package com.zhangguo.Spring041.aop05;import java.lang.reflect.Method;import org.springframework.aop.MethodBeforeAdvice;/** * 前置通知 ，就相当于InvocationHandler类 */public class BeforeAdvice implements MethodBeforeAdvice &#123;    /**     * method 方法信息     * args 参数     * target 被代理的目标对象     * 该切面一定是在执行主要业务之前执行，所以方法中不需要对Method做什么操作     */    public void before(Method method, Object[] args, Object target) throws Throwable &#123;        System.out.println(&quot;-----------------前置通知-----------------&quot;);    &#125;&#125;</code></pre><p><strong>后置通知</strong></p><pre><code class="highlight plaintext">package com.zhangguo.Spring041.aop05;import java.lang.reflect.Method;import org.springframework.aop.AfterReturningAdvice;/** * 后置通知 * */public class AfterAdvice implements AfterReturningAdvice &#123;    /*     * returnValue 返回值     * method 被调用的方法     * args 方法参数     * target 被代理对象     */    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123;        System.out.println(&quot;-----------------后置通知-----------------&quot;);    &#125;&#125;</code></pre><p><strong>环绕通知</strong></p><pre><code class="highlight plaintext">package com.zhangguo.Spring041.aop05;import org.aopalliance.intercept.MethodInterceptor;import org.aopalliance.intercept.MethodInvocation;/** * 环绕通知 * 方法拦截器 * */public class SurroundAdvice implements MethodInterceptor &#123;    public Object invoke(MethodInvocation i) throws Throwable &#123;        //前置横切逻辑        System.out.println(&quot;方法&quot; + i.getMethod() + &quot; 被调用在对象&quot; + i.getThis() + &quot;上，参数 &quot; + i.getArguments());        //方法调用        Object ret = i.proceed();        //后置横切逻辑        System.out.println(&quot;返回值：&quot;+ ret);        return ret;    &#125;&#125;</code></pre><h5 id="定义接口"><a class="markdownIt-Anchor" href="#定义接口"></a> 定义接口</h5><pre><code class="highlight plaintext">/** * 接口 * 抽象主题 */public interface IMath &#123;    //加    int add(int n1, int n2);//JoinCut 连接点    //减    int sub(int n1, int n2);//JoinCut 连接点    //乘    int mut(int n1, int n2);//JoinCut 连接点    //除    int div(int n1, int n2);//JoinCut 连接点&#125;</code></pre><h5 id="实现接口"><a class="markdownIt-Anchor" href="#实现接口"></a> 实现接口</h5><pre><code class="highlight plaintext">/** * 被代理的目标对象 *真实主题 */public class Math implements IMath &#123;    //加    public int add(int n1,int n2)&#123;//切入点 PointCut  主要业务方法        int result=n1+n2;        System.out.println(n1+&quot;+&quot;+n2+&quot;=&quot;+result);        return result;    &#125;    //减    public int sub(int n1,int n2)&#123;//切入点 PointCut  主要业务方法        int result=n1-n2;        System.out.println(n1+&quot;-&quot;+n2+&quot;=&quot;+result);        return result;    &#125;    //乘    public int mut(int n1,int n2)&#123;//切入点 PointCut  主要业务方法        int result=n1*n2;        System.out.println(n1+&quot;X&quot;+n2+&quot;=&quot;+result);        return result;    &#125;    //除    public int div(int n1,int n2)&#123;//切入点 PointCut  主要业务方法        int result=n1/n2;        System.out.println(n1+&quot;/&quot;+n2+&quot;=&quot;+result);        return result;    &#125;&#125;</code></pre><h5 id="定义advice"><a class="markdownIt-Anchor" href="#定义advice"></a> 定义Advice</h5><p>使用基础代理模式InvocationHandler</p><pre><code class="highlight plaintext">/* *   public class Agent implements InvocationHandler&#123; *    *      private BaseService obj;//当前具体被监控对象 *      public Agent(BasseSercie param)&#123; *          this.obj = param; *      &#125; *      public Object invoke(Object proxy,Method method,Object[] args)&#123; *             //织入顺序 *      &#125; *      //次要业务 *      public wash()&#123; *      &#125; *   &#125; *  * */</code></pre><p><strong>后置通知</strong></p><pre><code class="highlight plaintext">import java.lang.reflect.Method;import org.springframework.aop.AfterReturningAdvice;/** * 后置通知 * */public class AfterAdvice implements AfterReturningAdvice &#123;    /*     * returnValue 返回值     * method 被调用的方法     * args 方法参数     * target 被代理对象     * 切面，次要业务     */    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123;        System.out.println(&quot;共用时：time&quot;);    &#125;&#125;</code></pre><h5 id="使用ioc配置的方式实现代理"><a class="markdownIt-Anchor" href="#使用ioc配置的方式实现代理"></a> 使用IOC配置的方式实现代理</h5><ul><li>引入spring IOC的核心jar包</li><li>创建IOC的配置文件beans.xml</li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- 被代理的目标对象 ，注册被监控实现类--&gt;    &lt;bean id=&quot;target&quot; class=&quot;com.zhangguo.Spring041.aop06.Math&quot;&gt;&lt;/bean&gt;    &lt;!--通知、横切逻辑，注册通知实现类--&gt;    &lt;bean id=&quot;advice&quot; class=&quot;com.zhangguo.Spring041.aop06.AfterAdvice&quot;&gt;&lt;/bean&gt;    &lt;!--代理对象,注册代理监控对象生产工厂 --&gt;    &lt;!--interceptorNames 通知数组 --&gt;    &lt;!--p:target-ref 被代理的对象--&gt;    &lt;!--p:proxyTargetClass 被代理对象是否为一个没有实现接口的类，如果是则使用cglib,否则使用jdk动态代理  --&gt;    &lt;bean id=&quot;proxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;        p:interceptorNames=&quot;advice&quot;        p:target-ref=&quot;target&quot;        p:proxyTargetClass=&quot;true&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;    &lt;!--    p:interceptorNames=&quot;advice&quot;等价于&lt;property name=&quot;interceptorNames&quot; value=&quot;advice&quot;&gt;&lt;/property&gt;    p:target-ref=&quot;target&quot;等价于&lt;property name=&quot;target&quot; ref=&quot;target&quot;&gt;&lt;/bean&gt;    --&gt;</code></pre><ul><li>获取代理类并执行</li></ul><pre><code class="highlight plaintext">package com.zhangguo.Spring041.aop06;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123;    @org.junit.Test    public void test01()    &#123;        //容器        ApplicationContext ctx=new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        //从代理工厂中获得代理对象        IMath math=(IMath)ctx.getBean(&quot;proxy&quot;);        int n1=100,n2=5;        math.add(n1, n2);        math.sub(n1, n2);        math.mut(n1, n2);        math.div(n1, n2);    &#125;&#125;</code></pre><ul><li>输出</li></ul><h5 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h5><ul><li><strong>这里有个值得注意的问题</strong>：从容器中获得proxy对象时应该是org.springframework.aop.framework.ProxyFactoryBean类型的对象(如下代码所示)，但这里直接就转换成IMath类型了，这是因为：ProxyFactoryBean本质上是一个用来生产Proxy的FactoryBean。如果容器中的某个对象持有某个FactoryBean的引用它取得的不是FactoryBean本身而是 FactoryBean的getObject()方法所返回的对象。所以如果容器中某个对象依赖于ProxyFactoryBean那么它将会使用到 ProxyFactoryBean的getObject()方法所返回的代理对象这就是ProxyFactryBean得以在容器中使用的原因</li></ul><blockquote><p><strong>通知Advice的弊端是，它只可以对接口中的所有方法进行织入切面</strong></p><p>会强行的与接口中的所有方法进行绑定</p></blockquote><h4 id="advisor-顾问"><a class="markdownIt-Anchor" href="#advisor-顾问"></a> Advisor 顾问</h4><p>此种方式比advice更加灵活，只需多实现几个接口，其他配置方法相同，就可以实现更加灵活的实现</p><h5 id="声明接口"><a class="markdownIt-Anchor" href="#声明接口"></a> 声明接口</h5><pre><code class="highlight plaintext">public interface BaseService &#123;       public void eat();//JoinCut 连接点       public void wc();//JoinCut 连接点&#125;</code></pre><h5 id="接口实现"><a class="markdownIt-Anchor" href="#接口实现"></a> 接口实现</h5><pre><code class="highlight plaintext">import com.kaikeba.service.BaseService;public class Person implements BaseService &#123;public void eat() &#123;//切入点 PointCut  主要业务方法           System.out.println(&quot;吃泡面&quot;);&#125;public void wc() &#123;//切入点 PointCut   主要业务方法 System.out.println(&quot;上厕所&quot;);&#125;&#125;</code></pre><h5 id="切面advice"><a class="markdownIt-Anchor" href="#切面advice"></a> 切面Advice</h5><p>次要方法</p><pre><code class="highlight plaintext">import java.lang.reflect.Method;import org.springframework.aop.Advisor;import org.springframework.aop.MethodBeforeAdvice;import org.springframework.aop.framework.ProxyFactoryBean;/* *  *   public class Agent implements InvocationHandler&#123; *    *      private BaseService obj;//当前具体被监控对象 *       *      public Agent(BasseSercie param)&#123; *          this.obj = param; *      &#125; *    *      public Object invoke(Object proxy,Method method,Object[] args)&#123; *             //织入顺序 *      &#125; *       *      //次要业务 *      public wash()&#123; *       *      &#125; *   &#125; *  * */public class MyBeforeAdvice implements MethodBeforeAdvice &#123;//切面：次要业务public void before(Method arg0, Object[] arg1, Object arg2) throws Throwable &#123;System.out.println(&quot;-----洗手-----&quot;);        &#125;&#125;</code></pre><h5 id="classfilter-类拦截器"><a class="markdownIt-Anchor" href="#classfilter-类拦截器"></a> ClassFilter 类拦截器</h5><p>判断当前被拦截对象是不是当前顾问需要管理对象</p><pre><code class="highlight plaintext">import org.springframework.aop.ClassFilter;import com.kaikeba.serviceImpl.Person;public class MyClassFilter implements ClassFilter &#123; /*  *  1.一个接口下会有多个实现类  *  2.判断当前实现类是不是我们织入方式关心的目标类  *  BaseService接口我们现在只想管理Person.  *  参数：就是当前被拦截类：可能Person，可能Gog  * */public boolean matches(Class&lt;?&gt; clazz) &#123;    if(clazz == Person.class)&#123;    return true;//告诉顾问，当前类是需要我们提供织入服务    &#125;    //Gogreturn false;&#125;&#125;</code></pre><h5 id="methodmatcher-方法拦截器"><a class="markdownIt-Anchor" href="#methodmatcher-方法拦截器"></a> MethodMatcher 方法拦截器</h5><p>当前被拦截的方法是不是我们所需要主要业务方法</p><pre><code class="highlight plaintext">import java.lang.reflect.Method;import org.springframework.aop.MethodMatcher;public class MyMethodMatcher implements MethodMatcher &#123;/* *  被监控接口比如（BaseService），没有重载方法 *  每一个方法名称都是以唯一 *  此时可以采用 static检测方式，只根据方法名称判断 * 参数：method: 接口中某一个方法 *     targetClass: 接口中一个实现类 *      *  业务：只想为Person类中eat方法提供织入    */public boolean matches(Method method, Class&lt;?&gt; targetClass) &#123;String methodName = method.getName();if(&quot;eat&quot;.equals(methodName))&#123;return true;&#125;return false;&#125;public boolean isRuntime() &#123;// TODO Auto-generated method stubreturn false;&#125;public boolean matches(Method method, Class&lt;?&gt; targetClass, Object... args) &#123;// TODO Auto-generated method stubreturn false;&#125;&#125;</code></pre><h5 id="pointcut"><a class="markdownIt-Anchor" href="#pointcut"></a> PointCut</h5><p>目标对象和目标方法</p><pre><code class="highlight plaintext">import org.springframework.aop.ClassFilter;import org.springframework.aop.MethodMatcher;import org.springframework.aop.Pointcut;public class MyPointCut implements Pointcut &#123;/* * InvocationHandler接口 *    invoke()&#123; *        if(obj.getClass ！= person.class)&#123; *              return *        &#125; *         *        if(!methodObj.getName.equals(&quot;eat&quot;))&#123; *               return  *        &#125; *        //织入方式:次要业务方法和 Peson.eat()执行顺序 *        //前置通知 *          wash（）； *          Person.eat() *    &#125; *  * *///使用依赖注入private ClassFilter classFilter;private MethodMatcher metodMatcher;public void setClassFilter(ClassFilter classFilter) &#123;this.classFilter = classFilter;&#125;public void setMetodMatcher(MethodMatcher metodMatcher) &#123;this.metodMatcher = metodMatcher;&#125;public ClassFilter getClassFilter() &#123;// TODO Auto-generated method stubreturn this.classFilter;&#125;public MethodMatcher getMethodMatcher() &#123;// TODO Auto-generated method stubreturn this.metodMatcher;&#125;&#125;</code></pre><h5 id="pointcutadvisor"><a class="markdownIt-Anchor" href="#pointcutadvisor"></a> PointCutAdvisor</h5><p>可以灵活的指定当前接口下的哪一个实现类中哪一个方法与次要业务进行绑定</p><pre><code class="highlight plaintext">import org.aopalliance.aop.Advice;import org.springframework.aop.Pointcut;import org.springframework.aop.PointcutAdvisor;public class MyPointCutAdvisor implements PointcutAdvisor &#123;//采用依赖注入 set    private Advice advice;//次要业务以及次要业务与主要业务执行顺序    private Pointcut pointcut;//当前拦截对象和对象调用主要业务方法 person对象.eat()            public void setAdvice(Advice advice) &#123;this.advice = advice;&#125;public void setPointcut(Pointcut pointcut) &#123;this.pointcut = pointcut;&#125;public Advice getAdvice() &#123;// TODO Auto-generated method stubreturn this.advice;&#125;public boolean isPerInstance() &#123;// TODO Auto-generated method stubreturn false;&#125;public Pointcut getPointcut() &#123;// TODO Auto-generated method stubreturn this.pointcut;&#125;&#125;</code></pre><h5 id="spring配置文件"><a class="markdownIt-Anchor" href="#spring配置文件"></a> spring配置文件</h5><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;    xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context         http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;          &lt;!-- 注册被监控实现类 --&gt;       &lt;bean id=&quot;person&quot; class=&quot;com.kaikeba.serviceImpl.Person&quot;&gt;&lt;/bean&gt;       &lt;bean id=&quot;dog&quot; class=&quot;com.kaikeba.serviceImpl.Gog&quot;&gt;&lt;/bean&gt;              &lt;!-- 注册通知实现类 --&gt;       &lt;bean id=&quot;before&quot; class=&quot;com.kaikeba.advice.MyBeforeAdvice&quot;&gt;&lt;/bean&gt;              &lt;!-- 注册类型过滤器 --&gt;       &lt;bean id=&quot;classFilter&quot; class=&quot;com.kaikeba.util.MyClassFilter&quot;&gt;&lt;/bean&gt;       &lt;!-- 注册方法匹配器 --&gt;       &lt;bean id=&quot;methodMatcher&quot; class=&quot;com.kaikeba.util.MyMethodMatcher&quot;&gt;&lt;/bean&gt;              &lt;!-- 注册切入点 --&gt;       &lt;bean id=&quot;pointCut&quot; class=&quot;com.kaikeba.util.MyPointCut&quot; &gt;          &lt;property name=&quot;classFilter&quot; ref=&quot;classFilter&quot;&gt;&lt;/property&gt;          &lt;property name=&quot;metodMatcher&quot; ref=&quot;methodMatcher&quot;&gt;&lt;/property&gt;       &lt;/bean&gt;              &lt;!-- 注册顾问 --&gt;       &lt;bean id=&quot;myAdvisor&quot; class=&quot;com.kaikeba.util.MyPointCutAdvisor&quot;&gt;           &lt;property name=&quot;advice&quot; ref=&quot;before&quot;&gt;&lt;/property&gt;           &lt;property name=&quot;pointcut&quot; ref=&quot;pointCut&quot;&gt;&lt;/property&gt;       &lt;/bean&gt;              &lt;!-- 注册代理对象工厂 --&gt;       &lt;!--                              此时生成代理对象，只会负责person.eat方法监控                             与Advice不同，不会对BaseService所有的方法进行监控                        --&gt;       &lt;bean id=&quot;personProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;              &lt;property name=&quot;target&quot; ref=&quot;person&quot;&gt;&lt;/property&gt;              &lt;property name=&quot;interceptorNames&quot; value=&quot;myAdvisor&quot;&gt;&lt;/property&gt;       &lt;/bean&gt;&lt;/beans&gt;</code></pre><h2 id="aspectj-aop一般使用该方式"><a class="markdownIt-Anchor" href="#aspectj-aop一般使用该方式"></a> AspectJ AOP（一般使用该方式）</h2><p><strong>AspectJ 是AOP单独的一个实现框架，和spring并无关系</strong></p><p><strong>下述步骤是AspectJ+Spring的结合使用（spring自身实现的aop是<code>ProxyFactoryBean</code>）</strong></p><p>AspectJ是一个java实现的AOP框架，它能够对java代码进行AOP编译（一般在编译期进行），让java代码具有AspectJ的AOP功能（当然需要特殊的编译器）</p><p>可以这样说AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言，更幸运的是，AspectJ与java程序完全兼容，几乎是无缝关联，因此对于有java编程基础的工程师，上手和使用都非常容易。</p><p>了解AspectJ应用到java代码的过程（这个过程称为织入），对于织入这个概念，可以简单理解为aspect(切面)应用到目标函数(类)的过程。</p><p>对于这个过程，<strong>一般分为动态织入和静态织入，动态织入的方式是在运行时动态将要增强的代码织入到目标类中</strong>，这样往往是通过动态代理技术完成的，如Java JDK的动态代理(Proxy，底层通过反射实现)或者CGLIB的动态代理(底层通过继承实现)，Spring AOP采用的就是基于运行时增强的代理技术</p><p><strong>ApectJ采用的就是静态织入的方式</strong>。ApectJ主要采用的是编译期织入，在这个期间使用AspectJ的acj编译器(类似javac)把aspect类编译成class字节码后，在java目标类编译时织入，即先编译aspect类再编译目标类。</p><p><strong>spring整合了ApectJ框架，但是底层没有使用acj编译器，而是使用动态代理技术</strong></p><h3 id="aspectj的xml实现aop"><a class="markdownIt-Anchor" href="#aspectj的xml实现aop"></a> AspectJ的XML实现AOP</h3><h4 id="实现步骤"><a class="markdownIt-Anchor" href="#实现步骤"></a> 实现步骤</h4><h5 id="编写目标类"><a class="markdownIt-Anchor" href="#编写目标类"></a> 编写目标类</h5><p>编写接口和实现类（目标对象）</p><ul><li>UserService接口</li><li>UserServiceImpl实现类</li></ul><blockquote><p>配置目标类，将目标类交给spring IoC容器管理</p></blockquote><h5 id="maven依赖"><a class="markdownIt-Anchor" href="#maven依赖"></a> maven依赖</h5><pre><code class="highlight plaintext">&lt;!-- 基于AspectJ的aop依赖 --&gt;&lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;      &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--&lt;dependency&gt;      &lt;groupId&gt;aopalliance&lt;/groupId&gt;      &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;      &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt;--&gt;</code></pre><h5 id="编写一个advice通知"><a class="markdownIt-Anchor" href="#编写一个advice通知"></a> 编写一个advice（通知）</h5><ul><li>定义一个bean<ul><li>该通知不再需要实现任何接口或继承抽象类，一个普通的bean即可，方法<strong>可以</strong>（也可不带）带一个JoinPoint连接点参数，用于获得连接点信息，如方法名，参数，代理对象等</li></ul></li></ul><pre><code class="highlight plaintext">package com.zhangguo.Spring041.aop08;import org.aspectj.lang.JoinPoint;/** * 通知 */public class Advices &#123;    //前置通知    public void before(JoinPoint jp)    &#123;        System.out.println(&quot;--------------------bofore--------------------&quot;);        System.out.println(&quot;方法名：&quot;+jp.getSignature()+&quot;，参数：&quot;+jp.getArgs().length+&quot;，代理对象：&quot;+jp.getTarget());    &#125;    //后置通知    public void after(JoinPoint jp)&#123;        System.out.println(&quot;--------------------after--------------------&quot;);    &#125;&#125;</code></pre><ul><li>通知类型有很多种，有些参数不一样，特别是环绕通知<ul><li><strong>下列方法名可以随意编写</strong></li></ul></li></ul><pre><code class="highlight plaintext">//前置通知public void beforeMethod(JoinPoint joinPoint)//后置通知public void afterMethod(JoinPoint joinPoint)//返回值通知public void afterReturning(JoinPoint joinPoint, Object result)//抛出异常通知//在方法出现异常时会执行的代码可以访问到异常对象，可以指定在出现特定异常时在执行通知代码public void afterThrowing(JoinPoint joinPoint, Exception ex)//环绕通知//环绕通知需要携带ProceedingJoinPoint类型的参数//环绕通知类似于动态代理的全过程：ProceedingJoinPoint类型的参数可以决定是否执行目标方法。//而且环绕通知必须有返回值，返回值即为目标方法的返回值public Object aroundMethod(ProceedingJoinPoint pjd)&#123;    System.out.println(&quot;环绕通知前&quot;);    //调用目标对象的方法    Object proceed = pjd.proceed();     System.out.println(&quot;环绕通知前&quot;);    return proceed;&#125;</code></pre><h5 id="配置通知"><a class="markdownIt-Anchor" href="#配置通知"></a> 配置通知</h5><ul><li>xml配置通知，就是一个普通的bean</li></ul><pre><code class="highlight plaintext">&lt;bean id=&quot;advices&quot; class=&quot;com.zhangguo.Spring041.aop08.Advices&quot;&gt;&lt;/bean&gt;...&lt;/bean&gt;</code></pre><h5 id="配置aop切面"><a class="markdownIt-Anchor" href="#配置aop切面"></a> 配置AOP切面</h5><ul><li>就是指明你的切面中的方法要在哪些类方法执行的前后执行<ul><li>下面的案例指明了是将切面切入service类中的所有方法，即该类中的所有方法只要一执行就调用切面中定义的通知方法，至于要执行哪些通知方法，需要后续步骤继续配置</li></ul></li></ul><pre><code class="highlight plaintext">&lt;aop:config&gt;   &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;aBean&quot;&gt;      &lt;aop:pointcut id=&quot;businessService&quot;         expression=&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;/&gt;      &lt;!-- 前置通知 --&gt;      &lt;aop:before pointcut-ref=&quot;businessService&quot;          method=&quot;doRequiredTask&quot;/&gt;      &lt;!-- 最终通知 --&gt;      &lt;aop:after pointcut-ref=&quot;businessService&quot;          method=&quot;doRequiredTask&quot;/&gt;      &lt;!-- 后置通知 --&gt;      &lt;aop:after-returning pointcut-ref=&quot;businessService&quot;         returning=&quot;retVal&quot;         method=&quot;doRequiredTask&quot;/&gt;      &lt;!-- 异常抛出通知--&gt;      &lt;aop:after-throwing pointcut-ref=&quot;businessService&quot;         throwing=&quot;ex&quot;         method=&quot;doRequiredTask&quot;/&gt;      &lt;!-- 环绕通知 --&gt;      &lt;aop:around pointcut-ref=&quot;businessService&quot;          method=&quot;doRequiredTask&quot;/&gt;   ...   &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;bean id=&quot;aBean&quot; class=&quot;...&quot;&gt;...&lt;/bean&gt;</code></pre><h4 id="切入点表达式"><a class="markdownIt-Anchor" href="#切入点表达式"></a> 切入点表达式</h4><p>切入点表达式的格式：</p><p><em>单个点用来分割包名，类名，方法名</em></p><p><strong>execution([修饰符] 返回值类型 包名.类名.方法名(参数))</strong></p><ul><li>execution：必须要</li><li>修饰符：可省略</li><li>返回值类型：必须要，但是可以使用*通配符</li><li><strong>包名 ：</strong><ul><li>多级包之间使用.分割</li><li>包名可以使用 * 代替，多级包名可以使用多个 * 代替</li><li>如果想省略中间的包名可以使用 …</li></ul></li><li><strong>类名：</strong><ul><li>可以使用 * 代替</li><li>也可以写成 * DaoImpl</li></ul></li><li><strong>方法名：</strong><ul><li>也可以使用 * 好代替</li><li>也可以写成add *</li></ul></li><li><strong>参数：</strong><ul><li>参数使用 * 代替</li><li>如果有多个参数，可以使用 …代替</li></ul></li></ul><h4 id="通知类型"><a class="markdownIt-Anchor" href="#通知类型"></a> 通知类型</h4><p>通知类型（五种）：<strong>前置通知、后置通知、最终通知、环绕通知、异常抛出通知</strong></p><p><strong>前置通知：</strong></p><ul><li>执行时机：目标对象方法之前执行通知</li><li>配置文件：&lt;aop:before method=“before” pointcut-ref=“myPointcut”/&gt;</li><li>应用场景：方法开始时可以进行校验</li></ul><p><strong>后置通知：</strong></p><ul><li>执行时机：目标对象方法之后执行通知，有异常则不执行了</li><li>配置文件：&lt;aop:after-returning method=“afterReturning”<br />pointcut-ref=“myPointcut”/&gt;</li><li>应用场景：可以修改方法的返回值</li></ul><p><strong>最终通知：</strong></p><ul><li>执行时机：目标对象方法之后执行通知，有没有异常都会执行</li><li>配置文件：&lt;aop:after method=“after” pointcut-ref=“myPointcut”/&gt;</li><li>应用场景：例如像释放资源</li></ul><p><strong>异常抛出通知：</strong></p><ul><li>执行时机：在抛出异常后通知</li><li>配置文件：&lt;aop:after-throwing method=&quot; afterThrowing &quot; pointcut-<br />ref=“myPointcut”/&gt;</li><li>应用场景：包装异常</li></ul><p><strong>环绕通知：（使用环绕通知可以替代其他四个通知）</strong></p><ul><li>执行时机：目标对象方法之前和之后都会执行，抛出异常后不会执行</li><li>配置文件：&lt;aop:around method=“around” pointcut-ref=“myPointcut”/&gt;</li><li>应用场景：事务、统计代码执行时机</li></ul><h4 id="xml实现spring-aop-案例"><a class="markdownIt-Anchor" href="#xml实现spring-aop-案例"></a> XML实现Spring AOP 案例</h4><p><strong>要被代理的Math类</strong></p><pre><code class="highlight plaintext">package com.zhangguo.Spring052.aop01;/** * 被代理的目标类 */public class Math&#123;    //加    public int add(int n1,int n2)&#123;        int result=n1+n2;        System.out.println(n1+&quot;+&quot;+n2+&quot;=&quot;+result);        return result;    &#125;        //减    public int sub(int n1,int n2)&#123;        int result=n1-n2;        System.out.println(n1+&quot;-&quot;+n2+&quot;=&quot;+result);        return result;    &#125;        //乘    public int mut(int n1,int n2)&#123;        int result=n1*n2;        System.out.println(n1+&quot;X&quot;+n2+&quot;=&quot;+result);        return result;    &#125;        //除    public int div(int n1,int n2)&#123;        int result=n1/n2;        System.out.println(n1+&quot;/&quot;+n2+&quot;=&quot;+result);        return result;    &#125;&#125;</code></pre><p><strong>编辑通知类Advice</strong></p><pre><code class="highlight plaintext">package com.zhangguo.Spring052.aop01;import org.aspectj.lang.JoinPoint;/** * 通知类，横切逻辑 * */public class Advices &#123;        public void before(JoinPoint jp)&#123;        System.out.println(&quot;----------前置通知----------&quot;);        System.out.println(jp.getSignature().getName());    &#125;        public void after(JoinPoint jp)&#123;        System.out.println(&quot;----------最终通知----------&quot;);    &#125;&#125;</code></pre><p><strong>配置AOP XML文件</strong></p><ul><li>加粗部分的内容是在原IOC内容中新增的，主要是为AOP服务，如果引入失败则没有智能提示。xmlns:是xml namespace的简写。xmlns:xsi：其xsd文件是xml需要遵守的规范，通过URL可以看到，是w3的统一规范，后面通过xsi:schemaLocation来定位所有的解析文件，这里只能成偶数对出现。</li><li><code>&lt;bean &gt;&lt;/bean&gt;</code>表示通知bean，也就是横切逻辑bean</li><li><code>&lt;aop:config proxy-target-&gt;</code>用于AOP配置，proxy-target-class属性表示被代理的类是否为一个没有实现接口的类，Spring会依据实现了接口则使用JDK内置的动态代理，如果未实现接口则使用cblib；在Bean配置文件中，所有的Spring AOP配置都必须定义在<a href="">aop:config</a>元素内部。</li><li><code>&lt;aop:aspect&gt;</code>元素来为具体的切面实现引用后端Bean实例。因此，切面Bean必须有一个标识符，供<a href="">aop:aspect</a>元素引用。aop:aspect表示切面配置， ref表示通知对象的引用；</li><li><code>aop:pointcut</code>是配置切入点，就是横切逻辑将注入的精确位置，那些包，类，方法需要拦截注入横切逻辑</li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop-4.3.xsd&quot;&gt;         &lt;!--被代理的目标对象 --&gt;    &lt;bean id=&quot;math&quot; class=&quot;com.zhangguo.Spring041.aop08.Math&quot;&gt;&lt;/bean&gt;    &lt;!-- 通知 --&gt;    &lt;bean id=&quot;advice&quot; class=&quot;com.zhangguo.Spring041.aop08.Advices&quot;&gt;&lt;/bean&gt;    &lt;!-- AOP配置 --&gt;    &lt;!-- proxy-target-class属性表示被代理的类是否为一个没有实现接口的类，Spring会依据实现了接口则使用JDK内置的动态代理，如果未实现接口则使用cblib --&gt;    &lt;aop:config proxy-target-class=&quot;true&quot;&gt;        &lt;!-- 切面配置 --&gt;        &lt;!--ref表示通知对象的引用 --&gt;        &lt;aop:aspect ref=&quot;advice&quot;&gt;            &lt;!-- 配置切入点(横切逻辑将注入的精确位置) --&gt;            &lt;aop:pointcut expression=&quot;execution(* com.zhangguo.Spring041.aop08.Math.*(..))&quot; id=&quot;pointcut1&quot;/&gt;            &lt;!--声明通知，method指定通知类型，pointcut指定切点，就是该通知应该注入那些方法中 --&gt;            &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;            &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;&lt;/beans&gt;</code></pre><ul><li>aop:before用于声明通知，method指定通知类型，pointcut指定切点，就是该通知应该注入那些方法中。在aop Schema中，每种通知类型都对应一个特定地XML元素。通知元素需要pointcut-ref属性来引用切入点，或者用pointcut属性直接嵌入切入点表达式。method属性指定切面类中通知方法的名称。有如下几种：</li></ul><pre><code class="highlight plaintext">&lt;!-- 前置通知 --&gt;&lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;&lt;!-- 后置通知 --&gt;&lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;&lt;!--环绕通知 --&gt;&lt;aop:around method=&quot;around&quot; pointcut=&quot;execution(* com.zhangguo.Spring041.aop08.Math.s*(..))&quot;/&gt;&lt;!--异常通知 --&gt;&lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut=&quot;execution(* com.zhangguo.Spring041.aop08.Math.d*(..))&quot;  throwing=&quot;exp&quot;/&gt;&lt;!-- 返回值通知 --&gt;&lt;aop:after-returning method=&quot;afterReturning&quot; pointcut=&quot;execution(* com.zhangguo.Spring041.aop08.Math.m*(..))&quot; returning=&quot;result&quot;/&gt;</code></pre><p><strong>测试运行</strong></p><pre><code class="highlight plaintext">package com.zhangguo.Spring052.aop01;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123;    public static void main(String[] args) &#123;        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;aop01.xml&quot;);        Math math = ctx.getBean(&quot;math&quot;, Math.class);        int n1 = 100, n2 = 5;        math.add(n1, n2);        math.sub(n1, n2);        math.mut(n1, n2);        math.div(n1, n2);    &#125;&#125;</code></pre><p><strong>结果</strong></p><hr /><h3 id="aspectj的注解实现aop"><a class="markdownIt-Anchor" href="#aspectj的注解实现aop"></a> AspectJ的注解实现AOP</h3><h4 id="实现步骤-2"><a class="markdownIt-Anchor" href="#实现步骤-2"></a> 实现步骤</h4><h5 id="编写目标类-2"><a class="markdownIt-Anchor" href="#编写目标类-2"></a> 编写目标类</h5><p>编写接口和实现类（目标对象）</p><ul><li>UserService接口</li><li>UserServiceImpl实现类</li></ul><blockquote><p>配置目标类，将目标类交给spring IoC容器管理</p></blockquote><h5 id="开启aop自动代理"><a class="markdownIt-Anchor" href="#开启aop自动代理"></a> 开启AOP自动代理</h5><ul><li>在spring的xml文件中加入</li></ul><pre><code class="highlight plaintext">&lt;aop:aspectj-autoproxy/&gt;</code></pre><h5 id="编写aspect切面类"><a class="markdownIt-Anchor" href="#编写aspect切面类"></a> 编写Aspect（切面）类</h5><p>Advice通知+PointCut切入点=Aspect切面</p><ul><li>在使用基于Aspectj注解的Spring aop时，我们可以通过把@Pointcut注解定义Pointcut，指定其表达式，然后再需要使用Pointcut表达时的时候直接指定Pointcut</li></ul><pre><code class="highlight plaintext">//切面类，表示通知加切入点//需要将切面类将给spring IoC容器管理@Component//@Aspect:标记改类是一个切面类@Aspectpublic class MyAspect &#123;// 这里的这个方法名没有什么实际意义，相当于一个id，pointcut种的内容是这个id所匹配的要切入的那些柱子，要切入执行的内容就是下面的@before方法，@before注解的参数就是这个pointcut注解方法的名字    @Pointcut(&quot;execution(* add(..))&quot;)    private void beforeAdd() &#123;&#125;        //@Before表示这是一个前置通知    //value：切入点表达式    @Before(&quot;execution(* *..*.*ServiceImpl.*(..))&quot;)    public void before() &#123;        System.out.println(&quot;-----------前置通知-----------&quot;);    &#125;    &#125;</code></pre><h5 id="配置切面类"><a class="markdownIt-Anchor" href="#配置切面类"></a> 配置切面类</h5><p>即让其纳入spring管理</p><pre><code class="highlight plaintext">&lt;context:component-scan base-package=&quot;com.kkb.spring&quot;/&gt;</code></pre><h4 id="其他注解使用方式"><a class="markdownIt-Anchor" href="#其他注解使用方式"></a> 其他注解使用方式</h4><pre><code class="highlight plaintext">import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;/** * 通知类，横切逻辑 */@Component@Aspectpublic class Advices &#123;    //切点    @Pointcut(&quot;execution(* com.zhangguo.Spring052.aop04.Math.a*(..))&quot;)    public void pointcut()&#123;    &#125;        //前置通知    @Before(&quot;pointcut()&quot;)    public void before(JoinPoint jp)&#123;        System.out.println(jp.getSignature().getName());        System.out.println(&quot;----------前置通知----------&quot;);    &#125;        //最终通知    @After(&quot;pointcut()&quot;)    public void after(JoinPoint jp)&#123;        System.out.println(&quot;----------最终通知----------&quot;);    &#125;        //环绕通知    @Around(&quot;execution(* com.zhangguo.Spring052.aop04.Math.s*(..))&quot;)    public Object around(ProceedingJoinPoint pjp) throws Throwable&#123;        System.out.println(pjp.getSignature().getName());        System.out.println(&quot;----------环绕前置----------&quot;);        Object result=pjp.proceed();        System.out.println(&quot;----------环绕后置----------&quot;);        return result;    &#125;        //返回结果通知    @AfterReturning(pointcut=&quot;execution(* com.zhangguo.Spring052.aop04.Math.m*(..))&quot;,returning=&quot;result&quot;)    public void afterReturning(JoinPoint jp,Object result)&#123;        System.out.println(jp.getSignature().getName());        System.out.println(&quot;结果是：&quot;+result);        System.out.println(&quot;----------返回结果----------&quot;);    &#125;        //异常后通知    @AfterThrowing(pointcut=&quot;execution(* com.zhangguo.Spring052.aop04.Math.d*(..))&quot;,throwing=&quot;exp&quot;)    public void afterThrowing(JoinPoint jp,Exception exp)&#123;        System.out.println(jp.getSignature().getName());        System.out.println(&quot;异常消息：&quot;+exp.getMessage());        System.out.println(&quot;----------异常通知----------&quot;);    &#125;&#125;</code></pre><h4 id="环绕通知注解配置特殊"><a class="markdownIt-Anchor" href="#环绕通知注解配置特殊"></a> 环绕通知注解配置（特殊）</h4><p><strong>@Around</strong></p><ul><li>作用：把当前方法看作环绕通知</li><li>属性<ul><li>value：用于指定切入点表达式，还可以指定切入点表达式的引用</li></ul></li></ul><h4 id="定义通用切入点"><a class="markdownIt-Anchor" href="#定义通用切入点"></a> 定义通用切入点</h4><p>使用@PointCut注解在切面类中定义一个通用的切入点，其他通知可以引用该切入点</p><h4 id="零注解配置"><a class="markdownIt-Anchor" href="#零注解配置"></a> 零注解配置</h4><pre><code class="highlight plaintext">//声明改类是一个配置类@Configuration//将com.kkb包纳入注解扫描@ComponentScan(basePackages=&quot;com.kkb&quot;)//这个就相当于xml文件中的&lt;aop:aspectj-autoproxy/&gt;  AOP自动代理@EnableAspectJAutoProxypublic class SpringConfiguration &#123;//在配置中声明一个bean，相当于&lt;bean id=getUser /&gt;     @Bean     public User getUser()&#123; return new User(); &#125;&#125;</code></pre><h4 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h4><p>其实AOP的原理非常简单。我们以LoggingAspect.doAccessCheck()为例，要把它注入到UserService的每个public方法中，最简单的方法是编写一个子类，并持有原始实例的引用：</p><pre><code class="highlight plaintext">@Aspect@Componentpublic class LoggingAspect &#123;    // 在执行UserService的每个方法前执行:    @Before(&quot;execution(public * com.itranswarp.learnjava.service.UserService.*(..))&quot;)    public void doAccessCheck() &#123;        System.err.println(&quot;[Before] do access check...&quot;);    &#125;    // 在执行MailService的每个方法前后执行:    @Around(&quot;execution(public * com.itranswarp.learnjava.service.MailService.*(..))&quot;)    public Object doLogging(ProceedingJoinPoint pjp) throws Throwable &#123;        System.err.println(&quot;[Around] start &quot; + pjp.getSignature());        Object retVal = pjp.proceed();        System.err.println(&quot;[Around] done &quot; + pjp.getSignature());        return retVal;    &#125;&#125;//子类public UserServiceAopProxy extends UserService &#123;    private UserService target;    private LoggingAspect aspect;    public UserServiceAopProxy(UserService target, LoggingAspect aspect) &#123;        this.target = target;        this.aspect = aspect;    &#125;    public User login(String email, String password) &#123;        // 先执行Aspect的代码:        aspect.doAccessCheck();        // 再执行UserService的逻辑:        return target.login(email, password);    &#125;    public User register(String email, String password, String name) &#123;        aspect.doAccessCheck();        return target.register(email, password, name);    &#125;    ...&#125;</code></pre><p>这些都是Spring容器启动时为我们自动创建的注入了Aspect的子类，它取代了原始的UserService（原始的UserService实例作为内部变量隐藏在UserServiceAopProxy中）。如果我们打印从Spring容器获取的UserService实例类型，它类似UserService$$EnhancerBySpringCGLIB$$1f44e01c，实际上是Spring使用CGLIB动态创建的子类，但对于调用方来说，感觉不到任何区别。</p><blockquote><p>Spring对接口类型使用JDK动态代理，对普通类使用CGLIB创建子类。如果一个Bean的class是final，Spring将无法为其创建子类。</p></blockquote><p>可见，虽然Spring容器内部实现AOP的逻辑比较复杂（需要使用AspectJ解析注解，并通过CGLIB实现代理类），但我们使用AOP非常简单，一共需要三步：</p><ul><li>定义执行方法，并在方法上通过AspectJ的注解告诉Spring应该在何处调用此方法；</li><li>标记@Component和@Aspect；</li><li>在@Configuration类上标注@EnableAspectJAutoProxy。</li></ul><h4 id="案例注解配置aop"><a class="markdownIt-Anchor" href="#案例注解配置aop"></a> 案例:注解配置AOP</h4><ul><li>在上一个示例中修改被代理的类Math,为了实现IOC扫描在Math类上注解了@Service并命名bean为math。相当于上一个示例中在xml配置文件中增加了一个bean，<!-- 被代理对象 --><bean ></bean>，Math类的代码如下：</li></ul><pre><code class="highlight plaintext">package com.zhangguo.Spring052.aop02;import org.springframework.stereotype.Service;/** * 被代理的目标类 */@Service(&quot;math&quot;)public class Math&#123;    //加    public int add(int n1,int n2)&#123;        int result=n1+n2;        System.out.println(n1+&quot;+&quot;+n2+&quot;=&quot;+result);        return result;    &#125;        //减    public int sub(int n1,int n2)&#123;        int result=n1-n2;        System.out.println(n1+&quot;-&quot;+n2+&quot;=&quot;+result);        return result;    &#125;        //乘    public int mut(int n1,int n2)&#123;        int result=n1*n2;        System.out.println(n1+&quot;X&quot;+n2+&quot;=&quot;+result);        return result;    &#125;        //除    public int div(int n1,int n2)&#123;        int result=n1/n2;        System.out.println(n1+&quot;/&quot;+n2+&quot;=&quot;+result);        return result;    &#125;&#125;</code></pre><ul><li>修改通知类Advices，代码中有3个注解，@Component表示该类的实例会被Spring IOC容器管理；@Aspect表示声明一个切面；@Before表示before为前置通知，通过参数execution声明一个切点，Advices.java代码如下所示：</li></ul><blockquote><p>这个Java类就相当于<code>使用XML配置Spring MVC时候的&lt;aop:config&gt;</code> 的配置</p></blockquote><pre><code class="highlight plaintext">package com.zhangguo.Spring052.aop02;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;/** * 通知类，横切逻辑 * */@Component@Aspectpublic class Advices &#123;    @Before(&quot;execution(* com.zhangguo.Spring052.aop02.Math.*(..))&quot;)    public void before(JoinPoint jp)&#123;        System.out.println(&quot;----------前置通知----------&quot;);        System.out.println(jp.getSignature().getName());    &#125;        @After(&quot;execution(* com.zhangguo.Spring052.aop02.Math.*(..))&quot;)    public void after(JoinPoint jp)&#123;        System.out.println(&quot;----------最终通知----------&quot;);    &#125;&#125;</code></pre><ul><li>上面Java类等同于下面的xml</li></ul><pre><code class="highlight plaintext">&lt;!-- 通知 --&gt;    &lt;bean id=&quot;advices&quot; class=&quot;com.zhangguo.Spring052.aop01.Advices&quot;&gt;&lt;/bean&gt;        &lt;!-- aop配置 --&gt;    &lt;aop:config proxy-target-class=&quot;true&quot;&gt;        &lt;!--切面 --&gt;        &lt;aop:aspect ref=&quot;advices&quot;&gt;            &lt;!-- 切点 --&gt;            &lt;aop:pointcut expression=&quot;execution(* com.zhangguo.Spring052.aop01.Math.*(..))&quot; id=&quot;pointcut1&quot;/&gt;            &lt;!--连接通知方法与切点 --&gt;            &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;            &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;</code></pre><ul><li>Spring配置文件<ul><li>新增配置文件aop02.xml，在配置IOC的基础上增加了aop:aspectj-autoproxy节点，Spring框架会自动为与AspectJ切面配置的Bean创建代理，proxy-target-属性表示被代理的目标对象是一个类，而非实现了接口的类，主要是为了选择不同的代理方式</li></ul></li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context-4.3.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop-4.3.xsd&quot;&gt;        &lt;context:component-scan base-package=&quot;com.zhangguo.Spring052.aop02&quot;/&gt;        &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt;</code></pre><h4 id="aspectj切点函数"><a class="markdownIt-Anchor" href="#aspectj切点函数"></a> AspectJ切点函数</h4><h5 id="表达式类型"><a class="markdownIt-Anchor" href="#表达式类型"></a> 表达式类型</h5><ul><li>@AspectJ使用AspectJ专门的切点表达式描述切面，Spring所支持的AspectJ表达式可分为四类:<ul><li>方法切点函数：通过描述目标类方法信息定义连接点。</li><li>方法参数切点函数：通过描述目标类方法入参信息定义连接点。</li><li>目标类切点函数：通过描述目标类类型信息定义连接点。</li><li>代理类切点函数：通过描述代理类信息定义连接点。</li></ul></li><li>标准的Aspectj Aop的pointcut的表达式类型很丰富，但是spring AOP只支持9种，另外加Spring Aop自己扩充的一种，一共是10种类型的表达式，分别如下<ul><li>execution：满足匹配模式字符串的所有目标类方法的连接点</li><li>within：指定某些类型的全部方法执行，也可用来指定一个包。</li><li>this：Spring Aop是基于代理的，生成的bean也是一个代理对象，this就是这个代理对象，当这个对象可以转换为指定的类型时，对应的切入点就是它了，Spring Aop将生效。</li><li>target：当被代理的对象可以转换为指定的类型时，对应的切入点就是它了，Spring Aop将生效。</li><li>args：当执行的方法的参数是指定类型时生效。</li><li>@target：当代理的目标对象上拥有指定的注解时生效。</li><li>@args：当执行的方法参数类型上拥有指定的注解时生效。</li><li>@within：与@target类似，看官方文档和网上的说法都是@within只需要目标对象的类或者父类上有指定的注解，则@within会生效，而@target则是必须是目标对象的类上有指定的注解。而根据笔者的测试这两者都是只要目标类或父类上有指定的注解即可。</li><li>@annotation：当执行的方法上拥有指定的注解时生效。</li><li>bean：当调用的方法是指定的bean的方法时生效。</li></ul></li></ul><h5 id="使用示例案例"><a class="markdownIt-Anchor" href="#使用示例案例"></a> 使用示例，案例</h5><ul><li>新增一个类StrUtil</li></ul><pre><code class="highlight plaintext">package com.zhangguo.Spring052.aop03;import org.springframework.stereotype.Component;@Component(&quot;strUtil&quot;)public class StrUtil &#123;    public void show()&#123;        System.out.println(&quot;Hello StrUtil!&quot;);    &#125;&#125;</code></pre><ul><li>测试代码</li></ul><pre><code class="highlight plaintext">package com.zhangguo.Spring052.aop03;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123;    public static void main(String[] args) &#123;        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;aop03.xml&quot;);        IMath math = ctx.getBean(&quot;math&quot;, Math.class);        int n1 = 100, n2 = 5;        math.add(n1, n2);        math.sub(n1, n2);        math.mut(n1, n2);        math.div(n1, n2);                StrUtil strUtil=ctx.getBean(&quot;strUtil&quot;,StrUtil.class);        strUtil.show();    &#125;&#125;</code></pre><ul><li><strong>execution</strong><ul><li>execution是使用的最多的一种Pointcut表达式，表示某个方法的执行</li></ul></li></ul><pre><code class="highlight plaintext">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)</code></pre><ol><li>modifiers-pattern表示方法的访问类型，public等；</li><li>ret-type-pattern表示方法的返回值类型，如String表示返回类型是String，“*”表示所有的返回类型；</li><li>declaring-type-pattern表示方法的声明类，如“com.elim…*”表示com.elim包及其子包下面的所有类型；</li><li>name-pattern表示方法的名称，如“add*”表示所有以add开头的方法名；</li><li>param-pattern表示方法参数的类型，name-pattern(param-pattern)其实是一起的表示的方法集对应的参数类型，如“add()”表示不带参数的add方法，“add(<em>)”表示带一个任意类型的参数的add方法，“add(</em>,String)”则表示带两个参数，且第二个参数是String类型的add方法；</li><li>throws-pattern表示异常类型；其中以问号结束的部分都是可以省略的。<ol><li>“execution(* add())”匹配所有的不带参数的add()方法。</li><li>“execution(public * com…<em>.add</em>(…))”匹配所有com包及其子包下所有类的以add开头的所有public方法。</li><li>“execution(* *(…) throws Exception)”匹配所有抛出Exception的方法。</li></ol></li></ol><pre><code class="highlight plaintext">@Component@Aspectpublic class Advices &#123;    @Before(&quot;execution(* com.zhangguo.Spring052.aop03.Math.*(..))&quot;)    public void before(JoinPoint jp)&#123;        System.out.println(&quot;----------前置通知----------&quot;);        System.out.println(jp.getSignature().getName());    &#125;        //execution切点函数    //com.zhangguo.Spring052.aop03包下所有类的所有方法被切入    @After(&quot;execution(* com.zhangguo.Spring052.aop03.*.*(..))&quot;)    public void after(JoinPoint jp)&#123;        System.out.println(&quot;----------最终通知----------&quot;);    &#125;&#125;</code></pre><ul><li><strong>within</strong><ul><li>within是用来指定类型，指定类型种的所有方法将被拦截<ol><li>“within(com.spring.aop.service.UserServiceImpl)”匹配UserServiceImpl类对应对象的所有方法外部调用，而且这个对象只能是UserServiceImpl类型，不能是其子类型</li><li>“within(com.elim…*)”匹配com.elim包及其子包下面所有的类的所有方法的外部调用。</li></ol></li></ul></li></ul><pre><code class="highlight plaintext">//within切点函数    //com.zhangguo.Spring052.aop03包下所有类的所有方法被切入    @After(&quot;within(com.zhangguo.Spring052.aop03.*)&quot;)    public void after(JoinPoint jp)&#123;        System.out.println(&quot;----------最终通知----------&quot;);    &#125;</code></pre><p>%!(EXTRA markdown.ResourceType=, string=, string=)</p><ul><li><strong>this</strong><ul><li>Spring Aop是基于代理的，this就表示代理对象。this类型的Pointcut表达式的语法是this(type)，当生成的代理对象可以转换为type指定的类型时则表示匹配。基于JDK接口的代理和基于CGLIB的代理生成的代理对象是不一样的<ol><li>“this(com.spring.aop.service.IUserService)”匹配生成的代理对象是IUserService类型的所有方法的外部调用</li></ol></li></ul></li></ul><pre><code class="highlight plaintext">//this切点函数    //实现了IMath接口的代理对象的任意连接点    @After(&quot;this(com.zhangguo.Spring052.aop03.IMath)&quot;)    public void after(JoinPoint jp)&#123;        System.out.println(&quot;----------最终通知----------&quot;);    &#125;</code></pre><p>%!(EXTRA markdown.ResourceType=, string=, string=)</p><ul><li><strong>target</strong><ul><li>Spring aop是基于代理的，target则表示被代理的布标对象，当被代理的目标对象可以被转换为指定的类型时则表示匹配<ol><li>“target(com.spring.aop.service.IUserService)”则匹配所有被代理的目标对象能够转换为IUserService类型的所有方法的外部调用</li></ol></li></ul></li><li><strong>args</strong><ul><li>arge用来匹配方法参数<ol><li>“args()”匹配任何不带参数的方法。</li><li>“args(java.lang.String)”匹配任何只带一个参数，而且这个参数的类型是String的方法。</li><li>“args(…)”带任意参数的方法。</li><li>“args(java.lang.String,…)”匹配带任意个参数，但是第一个参数的类型是String的方法</li><li>“args(…,java.lang.String)”匹配带任意个参数，但是最后一个参数的类型是String的方法</li></ol></li></ul></li></ul><pre><code class="highlight plaintext">//args切点函数    //要求方法有两个int类型的参考才会被织入横切逻辑    @After(&quot;args(int,int)&quot;)    public void after(JoinPoint jp)&#123;        System.out.println(&quot;----------最终通知----------&quot;);    &#125;</code></pre><p>%!(EXTRA markdown.ResourceType=, string=, string=)</p><ul><li><strong>@target</strong><ul><li>@target匹配当被代理的目标对象对应的类型及其父类型上拥有指定的注解时<ol><li>“@target(com.spring.support.MyAnnotation)”匹配被代理的目标对象对应的类型上拥有MyAnnotation注解时</li></ol></li></ul></li><li><strong>@args</strong><ul><li>@args匹配被调用的方法上含有参数，且对应的参数类型上拥有指定的注解的情况<ol><li>“@args(com.spring.support.MyAnnotation)”匹配方法参数类型上拥有MyAnnotation注解的方法调用。如我们有一个方法add(MyParam param)接收一个MyParam类型的参数，而MyParam这个类是拥有注解MyAnnotation的，则它可以被Pointcut表达式“@args(com.elim.spring.support.MyAnnotation)”匹配上</li></ol></li></ul></li><li><strong>@within</strong><ul><li>@within用于匹配被代理的目标对象对应的类型或其父类型拥有指定的注解的情况，但只有在调用拥有指定注解的类上的方法时才匹配<ol><li>“@within(com.spring.support.MyAnnotation)”匹配被调用的方法声明的类上拥有MyAnnotation注解的情况。比如有一个ClassA上使用了注解MyAnnotation标注，并且定义了一个方法a()，那么在调用ClassA.a()方法时将匹配该Pointcut；如果有一个ClassB上没有MyAnnotation注解，但是它继承自ClassA，同时它上面定义了一个方法b()，那么在调用ClassB().b()方法时不会匹配该Pointcut，但是在调用ClassB().a()时将匹配该方法调用，因为a()是定义在父类型ClassA上的，且ClassA上使用了MyAnnotation注解。但是如果子类ClassB覆写了父类ClassA的a()方法，则调用ClassB.a()方法时也不匹配该Pointcut</li></ol></li></ul></li><li><strong>@annotation</strong><ul><li>@annotation用于匹配方法上拥有指定注解的情况<ol><li>“@annotation(com.spring.support.MyAnnotation)”匹配所有的方法上拥有MyAnnotation注解的方法外部调用</li></ol></li></ul></li><li><code>先定义一个可以定义在方法上的注解</code></li></ul><pre><code class="highlight plaintext">package com.zhangguo.Spring052.aop03;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface MyAnno &#123;&#125;</code></pre><pre><code class="highlight plaintext">//@annotation切点函数    //要求方法必须被注解com.zhangguo.Spring052.aop03.MyAnno才会被织入横切逻辑    @After(&quot;@annotation(com.zhangguo.Spring052.aop03.MyAnno)&quot;)    public void after(JoinPoint jp)&#123;        System.out.println(&quot;----------最终通知----------&quot;);    &#125;</code></pre><pre><code class="highlight plaintext">package com.zhangguo.Spring052.aop03;import org.springframework.stereotype.Component;@Component(&quot;strUtil&quot;)public class StrUtil &#123;    @MyAnno    public void show()&#123;        System.out.println(&quot;Hello StrUtil!&quot;);    &#125;&#125;</code></pre><p>%!(EXTRA markdown.ResourceType=, string=, string=)</p><ul><li><strong>bean</strong><ul><li>bean用于匹配当调用的是指定的Spring的某个bean的方法时<ol><li>“bean(abc)”匹配Spring Bean容器中id或name为abc的bean的方法调用</li><li>“bean(user*)”匹配所有id或name为以user开头的bean的方法调用</li></ol></li></ul></li></ul><h5 id="表达式组合"><a class="markdownIt-Anchor" href="#表达式组合"></a> 表达式组合</h5><ul><li>表达式组合就是表达式的逻辑运算，与，或，非。可以通过他们把表达式组合在一起<ol><li>bean(userService) &amp;&amp; args()”匹配id或name为userService的bean的所有无参方法。</li><li>“bean(userService) || @annotation(MyAnnotation)”匹配id或name为userService的bean的方法调用，或者是方法上使用了MyAnnotation注解的方法调用。</li><li>“bean(userService) &amp;&amp; !args()”匹配id或name为userService的bean的所有有参方法调用。</li></ol></li></ul><h4 id="自定义注解装配aop"><a class="markdownIt-Anchor" href="#自定义注解装配aop"></a> 自定义注解装配AOP</h4><p>使用AspectJ的注解，并配合一个复杂的<code>execution(* xxx.Xyz.*(..))</code> 语法来定义应该如何装配AOP。</p><p>在实际项目中，这种写法其实很少使用。假设你写了一个SecurityAspect：</p><pre><code class="highlight plaintext">@Aspect@Componentpublic class SecurityAspect &#123;    @Before(&quot;execution(public * com.itranswarp.learnjava.service.*.*(..))&quot;)    public void check() &#123;        if (SecurityContext.getCurrentUser() == null) &#123;            throw new RuntimeException(&quot;check failed&quot;);        &#125;    &#125;&#125;</code></pre><p>基本能实现无差别全覆盖，即某个包下面的所有Bean的所有方法都会被这个check()方法拦截。</p><p>还有的童鞋喜欢用方法名前缀进行拦截：</p><pre><code class="highlight plaintext">@Around(&quot;execution(public * update*(..))&quot;)public Object doLogging(ProceedingJoinPoint pjp) throws Throwable &#123;    // 对update开头的方法切换数据源:    String old = setCurrentDataSource(&quot;master&quot;);    Object retVal = pjp.proceed();    restoreCurrentDataSource(old);    return retVal;&#125;</code></pre><p>这种非精准打击误伤面更大，因为从方法前缀区分是否是数据库操作是非常不可取的。</p><p>我们在使用AOP时，要注意到虽然Spring容器可以把指定的方法通过AOP规则装配到指定的Bean的指定方法前后，但是，如果自动装配时，因为不恰当的范围，容易导致意想不到的结果，即很多不需要AOP代理的Bean也被自动代理了，并且，后续新增的Bean，如果不清楚现有的AOP装配规则，容易被强迫装配。</p><p>使用AOP时，被装配的Bean最好自己能清清楚楚地知道自己被安排了。例如，Spring提供的@Transactional就是一个非常好的例子。如果我们自己写的Bean希望在一个数据库事务中被调用，就标注上@Transactional。</p><p>通过@Transactional，某个方法是否启用了事务就一清二楚了。因此，装配AOP的时候，使用注解是最好的方式。</p><p>我们以一个实际例子演示如何使用注解实现AOP装配。为了监控应用程序的性能，我们定义一个性能监控的注解：</p><pre><code class="highlight plaintext">@Target(METHOD)@Retention(RUNTIME)public @interface MetricTime &#123;    String value();&#125;</code></pre><p>在需要被监控的关键方法上标注该注解：</p><pre><code class="highlight plaintext">@Componentpublic class UserService &#123;    // 监控register()方法性能:    @MetricTime(&quot;register&quot;)    public User register(String email, String password, String name) &#123;        ...    &#125;    ...&#125;</code></pre><p>然后，我们定义MetricAspect：</p><pre><code class="highlight plaintext">@Aspect@Componentpublic class MetricAspect &#123;    @Around(&quot;@annotation(metricTime)&quot;)    public Object metric(ProceedingJoinPoint joinPoint, MetricTime metricTime) throws Throwable &#123;        String name = metricTime.value();        long start = System.currentTimeMillis();        try &#123;            return joinPoint.proceed();        &#125; finally &#123;            long t = System.currentTimeMillis() - start;            // 写入日志或发送至JMX:            System.err.println(&quot;[Metrics] &quot; + name + &quot;: &quot; + t + &quot;ms&quot;);        &#125;    &#125;&#125;</code></pre><p>注意metric()方法标注了@Around(“@annotation(metricTime)”)，它的意思是，符合条件的目标方法是带有@MetricTime注解的方法，因为metric()方法参数类型是MetricTime（注意参数名是metricTime不是MetricTime），我们通过它获取性能监控的名称。</p><p>有了@MetricTime注解，再配合MetricAspect，任何Bean，只要方法标注了@MetricTime注解，就可以自动实现性能监控。</p><p>%23%20Spring%20AOP%0A%5Btoc%5D%0A%23%23%20AOP%0A%E5%9C%A8%E8%BD%AF%E4%BB%B6%E4%B8%9A%EF%BC%8CAOP%E6%84%8F%E4%B8%BA%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%EF%BC%8C%E9%80%9A%E8%BF%87**%E9%A2%84%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F**%E6%88%96**%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86**%E5%AE%9E%E7%8E%B0%E7%A8%8B%E5%BA%8F%E5%8A%9F%E8%83%BD%E7%9A%84%E7%BB%9F%E4%B8%80%E7%BB%B4%E6%8A%A4%E7%9A%84%E4%B8%80%E7%A7%8D%E6%8A%80%E6%9C%AF%EF%BC%8CAOP%E6%98%AFOOP%E7%9A%84%E5%BB%B6%E7%BB%AD%EF%BC%8C%E6%98%AF%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E7%83%AD%E7%82%B9%EF%BC%8C%E4%B9%9F%E6%98%AFspring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E9%87%8D%E8%A6%81%E5%86%85%E5%AE%B9%EF%BC%8C%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E7%A7%8D%E8%A1%8D%E7%94%9F%E6%B3%9B%E5%9E%8B%EF%BC%8C%E5%88%A9%E7%94%A8AOP%E5%8F%AF%E4%BB%A5%E5%AF%B9%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E7%9A%84%E5%90%84%E4%B8%AA%E9%83%A8%E5%88%86%E8%BF%9B%E8%A1%8C%E9%9A%94%E7%A6%BB%EF%BC%8C%E4%BB%8E%E8%80%8C%E6%98%AF%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%90%84%E9%83%A8%E5%88%86%E4%B9%8B%E9%97%B4%E8%80%A6%E5%90%88%E5%BA%A6%E9%99%8D%E4%BD%8E%EF%BC%8C%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8F%AF%E9%87%8D%E7%94%A8%E6%80%A7%EF%BC%8C%E5%90%8C%E6%97%B6%E6%8F%90%E9%AB%98%E4%BA%86%E5%BC%80%E5%8F%91%E7%9A%84%E6%95%88%E7%8E%87%0A!%5Bed68a81a67162e6bc2b9f3a81dd5019a.png%5D(en-resource%3A%2F%2Fdatabase%2F4280%3A1)%0A%0A!%5B1a646a6b790eb5d0d974729479c4e4da.png%5D(en-resource%3A%2F%2Fdatabase%2F4279%3A1)%0A%0A%0A%23%23%23%20%E6%84%8F%E5%9B%BE%0A*%20%E5%B0%86%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%EF%BC%8C%E6%80%A7%E8%83%BD%E7%BB%9F%E8%AE%A1%EF%BC%8C%E5%AE%89%E5%85%A8%E6%8E%A7%E5%88%B6%EF%BC%8C%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%EF%BC%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%AD%89%E4%BB%A3%E7%A0%81%E4%BB%8E%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%88%92%E5%88%86%E5%87%BA%E6%9D%A5%EF%BC%8C%E9%80%9A%E8%BF%87%E5%AF%B9%E8%BF%99%E4%BA%9B%E8%A1%8C%E4%B8%BA%E7%9A%84%E5%88%86%E7%A6%BB%EF%BC%8C%E6%88%91%E4%BB%AC%E5%B8%8C%E6%9C%9B%E5%8F%AF%E4%BB%A5%E5%B0%86%E5%AE%83%E4%BB%AC%E7%8B%AC%E7%AB%8B%E5%88%B0%E9%9D%9E%E6%8C%87%E5%AF%BC%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%AD%EF%BC%8C%E8%BF%9B%E8%80%8C%E6%94%B9%E5%8F%98%E8%BF%99%E4%BA%9B%E8%A1%8C%E4%B8%BA%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%8D%E5%BD%B1%E5%93%8D%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E7%9A%84%E4%BB%A3%E7%A0%81%0A%0A%23%23%23%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%0AAOP%E5%8F%AF%E4%BB%A5%E8%AF%B4%E6%98%AF%E5%AF%B9OOP%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8C%E5%AE%8C%E5%96%84%E3%80%82OOP%E5%BC%95%E5%85%A5%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%E6%80%A7%E7%AD%89%E6%A6%82%E5%BF%B5%E6%9D%A5%E5%BB%BA%E7%AB%8B%E4%B8%80%E7%A7%8D%E5%AF%B9%E8%B1%A1%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%EF%BC%8C%E7%94%A8%E4%BB%A5%E6%A8%A1%E6%8B%9F%E5%85%AC%E5%85%B1%E8%A1%8C%E4%B8%BA%E7%9A%84%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E3%80%82%E5%AE%9E%E7%8E%B0AOP%E7%9A%84%E6%8A%80%E6%9C%AF%EF%BC%8C%E4%B8%BB%E8%A6%81%E5%88%86%E4%B8%BA%E4%B8%A4%E5%A4%A7%E7%B1%BB%EF%BC%9A%E4%B8%80%E6%98%AF%E9%87%87%E7%94%A8%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%EF%BC%8C%E5%88%A9%E7%94%A8%E6%88%AA%E5%8F%96%E6%B6%88%E6%81%AF%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%AF%B9%E8%AF%A5%E6%B6%88%E6%81%AF%E8%BF%9B%E8%A1%8C%E8%A3%85%E9%A5%B0%EF%BC%8C%E4%BB%A5%E5%8F%96%E4%BB%A3%E5%8E%9F%E6%9C%89%E5%AF%B9%E8%B1%A1%E8%A1%8C%E4%B8%BA%E7%9A%84%E6%89%A7%E8%A1%8C%EF%BC%9B%E4%BA%8C%E6%98%AF%E9%87%87%E7%94%A8%E9%9D%99%E6%80%81%E7%BB%87%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%BC%95%E5%85%A5%E7%89%B9%E5%AE%9A%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%9B%E5%BB%BA%E2%80%9C%E6%96%B9%E9%9D%A2%E2%80%9D%EF%BC%8C%E4%BB%8E%E8%80%8C%E4%BD%BF%E5%BE%97%E7%BC%96%E8%AF%91%E5%99%A8%E5%8F%AF%E4%BB%A5%E5%9C%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E9%97%B4%E7%BB%87%E5%85%A5%E6%9C%89%E5%85%B3%E2%80%9C%E6%96%B9%E9%9D%A2%E2%80%9D%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%B1%9E%E4%BA%8E%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%0A%0A%0A%E5%9C%A8Java%E5%B9%B3%E5%8F%B0%E4%B8%8A%EF%BC%8C%E5%AF%B9%E4%BA%8EAOP%E7%9A%84%E7%BB%87%E5%85%A5%EF%BC%8C%E6%9C%893%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%0A*%20%E7%BC%96%E8%AF%91%E6%9C%9F%EF%BC%9A%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%EF%BC%8C%E7%94%B1%E7%BC%96%E8%AF%91%E5%99%A8%E6%8A%8A%E5%88%87%E9%9D%A2%E8%B0%83%E7%94%A8%E7%BC%96%E8%AF%91%E8%BF%9B%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%8C%E8%BF%99%E7%A7%8D%E6%96%B9%E5%BC%8F%E9%9C%80%E8%A6%81%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E5%B9%B6%E6%89%A9%E5%B1%95%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%8CAspectJ%E5%B0%B1%E6%89%A9%E5%B1%95%E4%BA%86Java%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97aspect%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%BB%87%E5%85%A5%EF%BC%9B%0A*%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9A%E5%9C%A8%E7%9B%AE%E6%A0%87%E7%B1%BB%E8%A2%AB%E8%A3%85%E8%BD%BD%E5%88%B0JVM%E6%97%B6%EF%BC%8C%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%AF%B9%E7%9B%AE%E6%A0%87%E7%B1%BB%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E9%87%8D%E6%96%B0%E2%80%9C%E5%A2%9E%E5%BC%BA%E2%80%9D%EF%BC%9B%0A*%20%E8%BF%90%E8%A1%8C%E6%9C%9F%EF%BC%9A%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%88%87%E9%9D%A2%E9%83%BD%E6%98%AF%E6%99%AE%E9%80%9AJava%E7%B1%BB%EF%BC%8C%E9%80%9A%E8%BF%87JVM%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%9F%E8%83%BD%E6%88%96%E8%80%85%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%AE%9E%E7%8E%B0%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%8A%A8%E6%80%81%E7%BB%87%E5%85%A5%E3%80%82%0A%0A%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E5%BC%8F%E6%98%AF%E7%AC%AC%E4%B8%89%E7%A7%8D%EF%BC%8CSpring%E7%9A%84AOP%E5%AE%9E%E7%8E%B0%E5%B0%B1%E6%98%AF%E5%9F%BA%E4%BA%8EJVM%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E3%80%82%E7%94%B1%E4%BA%8EJVM%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%A6%81%E6%B1%82%E5%BF%85%E9%A1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E7%B1%BB%E6%B2%A1%E6%9C%89%E4%B8%9A%E5%8A%A1%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%B0%B1%E9%9C%80%E8%A6%81%E9%80%9A%E8%BF%87CGLIB%E6%88%96%E8%80%85Javassist%E8%BF%99%E4%BA%9B%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%AE%9E%E7%8E%B0%E3%80%82%0A%23%23%23%20%E4%BD%9C%E7%94%A8%2F%E4%BC%98%E5%8A%BF%0A**%E4%BD%9C%E7%94%A8%EF%BC%9A**%0A%0AAOP%E9%87%87%E5%8F%96%E6%A8%AA%E5%90%91%E6%8A%BD%E5%8F%96%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%8F%96%E4%BB%A3%E4%BA%86%E4%BC%A0%E7%BB%9F%E7%BA%B5%E5%90%91%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E7%9A%84%E9%87%8D%E5%A4%8D%E6%80%A7%E4%BB%A3%E7%A0%81%EF%BC%88%E6%80%A7%E8%83%BD%E7%9B%91%E8%A7%86%EF%BC%8C%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%EF%BC%8C%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5%EF%BC%8C%E7%BC%93%E5%AD%98%EF%BC%89%0A%0A%E5%9C%A8%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9C%9F%E9%97%B4%EF%BC%8C%E4%B8%8D%E4%BF%AE%E6%94%B9%E6%BA%90%E7%A0%81%E5%AF%B9%E5%B7%B2%E6%9C%89%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%A2%9E%E5%BC%BA%0A%0A%E5%B0%86%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%A4%84%E7%90%86%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%88%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%EF%BC%8C%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%EF%BC%89%E8%A7%A3%E8%80%A6%0A%0A**%E4%BC%98%E5%8A%BF%EF%BC%9A**%0A*%20%E5%87%8F%E5%B0%91%E9%87%8D%E5%A4%8D%E4%BB%A3%E7%A0%81%0A*%20%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%0A*%20%E7%BB%B4%E6%8A%A4%E6%96%B9%E4%BE%BF%0A%0A%23%23%23%20Spring%20%E6%A1%86%E6%9E%B6%E7%9A%84AOP%0A%0A*%20Spring%20%E6%A1%86%E6%9E%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6%E6%98%AF**%E9%9D%A2%E5%90%91%E6%96%B9%E9%9D%A2%E7%9A%84%E7%BC%96%E7%A8%8B**(AOP)%E6%A1%86%E6%9E%B6%E3%80%82%E9%9D%A2%E5%90%91%E6%96%B9%E9%9D%A2%E7%9A%84%E7%BC%96%E7%A8%8B%E9%9C%80%E8%A6%81%E6%8A%8A%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E5%88%86%E8%A7%A3%E6%88%90%E4%B8%8D%E5%90%8C%E7%9A%84%E9%83%A8%E5%88%86%E7%A7%B0%E4%B8%BA%E6%89%80%E8%B0%93%E7%9A%84%E5%85%B3%E6%B3%A8%E7%82%B9%E3%80%82%E8%B7%A8%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%A4%9A%E4%B8%AA%E7%82%B9%E7%9A%84%E5%8A%9F%E8%83%BD%E8%A2%AB%E7%A7%B0%E4%B8%BA**%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9**%EF%BC%8C%E8%BF%99%E4%BA%9B%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9%E5%9C%A8%E6%A6%82%E5%BF%B5%E4%B8%8A%E7%8B%AC%E7%AB%8B%E4%BA%8E%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E3%80%82%E6%9C%89%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BE%88%E5%A5%BD%E7%9A%84%E6%96%B9%E9%9D%A2%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%8C%E5%A6%82%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E3%80%81%E5%AE%A1%E8%AE%A1%E3%80%81%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E7%BC%93%E5%AD%98%E7%AD%89%E3%80%82%0A*%20%E5%9C%A8%20OOP%20%E4%B8%AD%EF%BC%8C%E5%85%B3%E9%94%AE%E5%8D%95%E5%85%83%E6%A8%A1%E5%9D%97%E5%BA%A6%E6%98%AF%E7%B1%BB%EF%BC%8C%E8%80%8C%E5%9C%A8%20AOP%20%E4%B8%AD%E5%8D%95%E5%85%83%E6%A8%A1%E5%9D%97%E5%BA%A6%E6%98%AF%E6%96%B9%E9%9D%A2%E3%80%82%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%B8%AE%E5%8A%A9%E4%BD%A0%E5%AF%B9%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AF%B9%E8%B1%A1%E7%9B%B8%E4%BA%92%E8%A7%A3%E8%80%A6%E5%92%8C%20AOP%20%E5%8F%AF%E4%BB%A5%E5%B8%AE%E5%8A%A9%E4%BD%A0%E4%BB%8E%E5%AE%83%E4%BB%AC%E6%89%80%E5%BD%B1%E5%93%8D%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%AF%B9%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9%E8%A7%A3%E8%80%A6%E3%80%82%0A*%20**%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9%EF%BC%9A**%20%E8%B7%A8%E8%B6%8A%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%A4%9A%E4%B8%AA%E6%A8%A1%E5%9D%97%E7%9A%84%E6%96%B9%E6%B3%95%E6%88%96%E5%8A%9F%E8%83%BD%E3%80%82%EF%BC%88%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%81%9A%E7%94%B1%E4%B8%80%E7%BB%84%E5%85%B3%E6%B3%A8%E7%82%B9%E5%8D%B3%E4%B8%9A%E5%8A%A1%E6%88%96%E5%8A%9F%E8%83%BD%E6%88%96%E6%96%B9%E6%B3%95%E7%BB%84%E6%88%90%EF%BC%8C%E5%85%B6%E4%B8%AD%EF%BC%8C%E7%9B%B4%E6%8E%A5%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%85%B3%E6%B3%A8%E7%82%B9%E6%98%AF%E7%9B%B4%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9%EF%BC%8C%E8%80%8C%E4%B8%BA%E7%9B%B4%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9%E6%9C%8D%E5%8A%A1%E7%9A%84%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9%EF%BC%89%EF%BC%8C%E5%8D%B3%E4%B8%8E%E6%88%91%E4%BB%AC%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%97%A0%E5%85%B3%E7%9A%84%EF%BC%8C%E4%BD%86%E6%98%AF%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E5%85%B3%E6%B3%A8%E7%9A%84%E9%83%A8%E5%88%86%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9%0A%23%23%23%23%20AOP%E6%9C%AF%E8%AF%AD%0A%0A%7C%20%E9%A1%B6%20%7C%20%E6%8F%8F%E8%BF%B0%20%7C%0A%7C%20—%20%7C%20—%20%7C%0A%7C%20%E5%88%87%E9%9D%A2(Aspect)%20%7C%20%E6%98%AF%E5%88%87%E5%85%A5%E7%82%B9%E5%92%8C%E9%80%9A%E7%9F%A5%E7%9A%84%E7%BB%93%E5%90%88%20%7C%0A%7C%20%E7%9B%AE%E6%A0%87(Target)%20%7C%20%E8%A2%AB%E9%80%9A%E7%9F%A5%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%8D%B3%E4%B8%9A%E5%8A%A1%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%20%7C%0A%7C%20%E4%BB%A3%E7%90%86(Proxy)%20%7C%20%E4%B8%80%E4%B8%AA%E7%B1%BB%E8%A2%ABAOP%E7%BB%87%E5%85%A5%E5%A2%9E%E5%BC%BA%E5%90%8E%EF%BC%8C%E5%B0%B1%E4%BA%A7%E7%94%9F%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%9C%E4%BB%A3%E7%90%86%E7%B1%BB%20%7C%0A%7C%20%E5%88%87%E5%85%A5%E7%82%B9(PointCut)%20%7C%20%E5%88%87%E9%9D%A2%E9%80%9A%E7%9F%A5%E6%89%A7%E8%A1%8C%E7%9A%84%E2%80%9C%E5%9C%B0%E7%82%B9%E2%80%9D%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9B%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9C%9F%E6%AD%A3%E8%A2%AB%E5%88%87%E9%9D%A2%E7%BB%87%E5%85%A5%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E5%88%87%E5%85%A5%E7%82%B9%E4%B8%80%E5%AE%9A%E6%98%AF%E8%BF%9E%E6%8E%A5%E7%82%B9%EF%BC%8C%E4%BD%86%E8%BF%9E%E6%8E%A5%E7%82%B9%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%98%AF%E5%88%87%E5%85%A5%E7%82%B9%EF%BC%8C%E8%A2%AB%E6%A0%87%E8%AE%B0%E4%B8%BAfinal%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E4%B8%8D%E8%83%BD%E4%BD%9C%E7%94%A8%E8%BF%9E%E6%8E%A5%E7%82%B9%E4%B8%8E%E5%88%87%E5%85%A5%E7%82%B9%E7%9A%84%20%7C%0A%7C%20%E8%BF%9E%E6%8E%A5%E7%82%B9(JointPoint)%20%7C%20%E4%B8%8E%E5%88%87%E5%85%A5%E7%82%B9%E5%8C%B9%E9%85%8D%E7%9A%84%E6%89%A7%E8%A1%8C%E7%82%B9%EF%BC%8C%E5%8D%B3%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%88%87%E9%9D%A2%EF%BC%88%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%EF%BC%89%E7%BB%87%E5%85%A5%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E6%89%80%E6%9C%89%E8%A6%81%E7%9B%91%E6%8E%A7%E7%9A%84%E6%96%B9%E6%B3%95%E9%83%BD%E7%A7%B0%E4%B8%BA%E8%BF%9E%E6%8E%A5%E7%82%B9%EF%BC%8C%E5%B0%B1%E6%98%AF**%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95**%20%7C%0A%7C%20%E9%80%9A%E7%9F%A5(Advice)%20%7C%20%E9%80%9A%E7%9F%A5%E6%98%AF%E5%88%87%E9%9D%A2%EF%BC%88%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%EF%BC%89%E7%9A%84%E4%B8%80%E7%A7%8D%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%AE%8C%E6%88%90%E7%AE%80%E5%8D%95%E7%9A%84%E7%BB%87%E5%85%A5%E5%8A%9F%E8%83%BD%E3%80%82%E9%80%9A%E7%9F%A5%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E5%88%87%E9%9D%A2%E7%BB%87%E5%85%A5%E7%9A%84%E6%97%B6%E9%97%B4%E7%82%B9%EF%BC%8C%E5%88%87%E5%85%A5%E7%82%B9%E5%AE%9A%E4%B9%89%E4%BA%86%E5%88%87%E9%9D%A2%E7%BB%87%E5%85%A5%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%9B**%E9%92%88%E5%AF%B9%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%8D%E5%A4%9F%E7%81%B5%E6%B4%BB**%20%7C%0A%7C%20%E9%A1%BE%E9%97%AE(Advisor)%20%7C%20%E9%A1%BE%E9%97%AE%E6%98%AF%E5%88%87%E9%9D%A2%EF%BC%88%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%EF%BC%89%E7%9A%84%E4%B8%80%E7%A7%8D%EF%BC%8C%E8%83%BD%E5%A4%9F%E5%B0%86%E9%80%9A%E7%9F%A5%E4%BB%A5%E6%9B%B4%E4%B8%BA%E5%A4%8D%E6%9D%82%E7%9A%84%E7%9A%84%E6%96%B9%E5%BC%8F%E7%BB%87%E5%85%A5%E5%88%B0%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E4%B8%AD%EF%BC%8C%E6%98%AF%E5%B0%86%E9%80%9A%E7%9F%A5%E5%8C%85%E8%A3%85%E4%B8%BA%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E5%88%87%E9%9D%A2%E7%9A%84%E8%A3%85%E9%85%8D%E5%99%A8%20%7C%0A%0A!%5Bf1de713ace79cf9d6fa0f0a2a940d506.png%5D(en-resource%3A%2F%2Fdatabase%2F1015%3A1)%0A%0A!%5B6cbc28f4ef49c048a16e392bab58bfa0.png%5D(en-resource%3A%2F%2Fdatabase%2F1008%3A1)%0A%0A%23%23%20AOP%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%9E%8B%0A%0A%23%23%23%20%E7%B1%BB%E5%9E%8B%0A%23%23%23%23%20Spring%E8%87%AA%E8%BA%AB%E5%AE%9E%E7%8E%B0%0A1.%20<strong>ProxyFactory</strong>%EF%BC%9A%3Cu%3E%E7%BC%96%E7%A8%8B%E5%BC%8F%3C%2Fu%3E%E4%BD%BF%E7%94%A8AOP%0A2.%20<strong>ProxyFactoryBean</strong>%EF%BC%9A%3Cu%3E%E5%A3%B0%E6%98%8E%E5%BC%8F%3C%2Fu%3E%E4%BD%BF%E7%94%A8AOP%EF%BC%8C%E4%B8%93%E9%97%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B7%A5%E5%8E%82%0A%20%20%20%20*%20<strong>Advice%E9%80%9A%E7%9F%A5</strong>%20%E4%BD%BF%E7%94%A8%E6%9B%B4%E7%AE%80%E5%8D%95%0A%20%20%20%20*%20<strong>Advisor%E9%A1%BE%E9%97%AE</strong>%20%E6%93%8D%E7%BA%B5%E6%9B%B4%E7%81%B5%E6%B4%BB%0A%0A%3E%20%E5%BA%95%E5%B1%82%E5%8F%88%E5%88%86%E4%B8%BA<strong>JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0</strong>%20%E5%92%8C%20<strong>CGLib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0</strong>%0A%0A%23%23%23%23%20AspectJ%E5%AE%9E%E7%8E%B0%0A1.%20<strong>AspectJProxyFactory</strong>%EF%BC%9A%E9%9B%86%E6%88%90spring%E4%B8%8EAspect%E5%AE%9E%E7%8E%B0AOP%0A%0A%0A!%5B8b2720317ad74dc6d20fe320a0508d84.png%5D(en-resource%3A%2F%2Fdatabase%2F1010%3A1)%0A%0A*%20**%E8%BF%99%E4%B8%89%E4%B8%AA%E7%B1%BB%E9%83%BD%E7%BB%A7%E6%89%BF%E8%87%AA**%0A%20%20%20%20*%20ProxyConfig%EF%BC%9A%E6%8F%90%E4%BE%9B%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%0A%20%20%20%20*%20AdvisedSupport%EF%BC%9A%E5%B0%81%E8%A3%85%E4%BA%86%E9%80%9A%E7%9F%A5%E4%B8%8E%E9%80%9A%E7%9F%A5%E5%99%A8%0A%20%20%20%20*%20ProxyCreatorSupport%EF%BC%9A%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E8%BE%85%E5%8A%A9%E7%B1%BB%0A%0A%0A%23%23%23%20AOP%E5%AE%9E%E7%8E%B0%E4%B9%8BAspectJ%0A%0AAspectJ%E6%98%AF%E4%B8%80%E4%B8%AAjava%E5%AE%9E%E7%8E%B0%E7%9A%84AOP%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%AE%83%E8%83%BD%E5%A4%9F%E5%AF%B9java%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8CAOP%E7%BC%96%E8%AF%91%EF%BC%88%E4%B8%80%E8%88%AC%E5%9C%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E8%BF%9B%E8%A1%8C%EF%BC%89%EF%BC%8C%E8%AE%A9java%E4%BB%A3%E7%A0%81%E5%85%B7%E6%9C%89AspectJ%E7%9A%84AOP%E5%8A%9F%E8%83%BD%EF%BC%88%E5%BD%93%E7%84%B6%E9%9C%80%E8%A6%81%E7%89%B9%E6%AE%8A%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%89%0A%0A%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E8%AF%B4AspectJ%E6%98%AF%E7%9B%AE%E5%89%8D%E5%AE%9E%E7%8E%B0AOP%E6%A1%86%E6%9E%B6%E4%B8%AD%E6%9C%80%E6%88%90%E7%86%9F%EF%BC%8C%E5%8A%9F%E8%83%BD%E6%9C%80%E4%B8%B0%E5%AF%8C%E7%9A%84%E8%AF%AD%E8%A8%80%EF%BC%8C%E6%9B%B4%E5%B9%B8%E8%BF%90%E7%9A%84%E6%98%AF%EF%BC%8CAspectJ%E4%B8%8Ejava%E7%A8%8B%E5%BA%8F%E5%AE%8C%E5%85%A8%E5%85%BC%E5%AE%B9%EF%BC%8C%E5%87%A0%E4%B9%8E%E6%98%AF%E6%97%A0%E7%BC%9D%E5%85%B3%E8%81%94%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%AF%B9%E4%BA%8E%E6%9C%89java%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%8C%E4%B8%8A%E6%89%8B%E5%92%8C%E4%BD%BF%E7%94%A8%E9%83%BD%E9%9D%9E%E5%B8%B8%E5%AE%B9%E6%98%93%E3%80%82%0A%0A%E4%BA%86%E8%A7%A3AspectJ%E5%BA%94%E7%94%A8%E5%88%B0java%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%88%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E7%A7%B0%E4%B8%BA%E7%BB%87%E5%85%A5%EF%BC%89%EF%BC%8C%E5%AF%B9%E4%BA%8E%E7%BB%87%E5%85%A5%E8%BF%99%E4%B8%AA%E6%A6%82%E5%BF%B5%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E4%B8%BAaspect(%E5%88%87%E9%9D%A2)%E5%BA%94%E7%94%A8%E5%88%B0%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0(%E7%B1%BB)%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82%0A%0A%E5%AF%B9%E4%BA%8E%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%EF%BC%8C**%E4%B8%80%E8%88%AC%E5%88%86%E4%B8%BA%E5%8A%A8%E6%80%81%E7%BB%87%E5%85%A5%E5%92%8C%E9%9D%99%E6%80%81%E7%BB%87%E5%85%A5%EF%BC%8C%E5%8A%A8%E6%80%81%E7%BB%87%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%98%AF%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E5%B0%86%E8%A6%81%E5%A2%9E%E5%BC%BA%E7%9A%84%E4%BB%A3%E7%A0%81%E7%BB%87%E5%85%A5%E5%88%B0%E7%9B%AE%E6%A0%87%E7%B1%BB%E4%B8%AD**%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%BE%80%E5%BE%80%E6%98%AF%E9%80%9A%E8%BF%87%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%E5%AE%8C%E6%88%90%E7%9A%84%EF%BC%8C%E5%A6%82%3Cu%3EJava%20JDK%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86(Proxy%EF%BC%8C%E5%BA%95%E5%B1%82%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%AE%9E%E7%8E%B0)%3C%2Fu%3E%E6%88%96%E8%80%85%3Cu%3ECGLIB%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86(%E5%BA%95%E5%B1%82%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0)%3C%2Fu%3E%EF%BC%8CSpring%20AOP%E9%87%87%E7%94%A8%E7%9A%84%E5%B0%B1%E6%98%AF%E5%9F%BA%E4%BA%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A2%9E%E5%BC%BA%E7%9A%84%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%0A%0A<strong>ApectJ%E9%87%87%E7%94%A8%E7%9A%84%E5%B0%B1%E6%98%AF%E9%9D%99%E6%80%81%E7%BB%87%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F</strong>%E3%80%82ApectJ%E4%B8%BB%E8%A6%81%E9%87%87%E7%94%A8%E7%9A%84%E6%98%AF%E7%BC%96%E8%AF%91%E6%9C%9F%E7%BB%87%E5%85%A5%EF%BC%8C%E5%9C%A8%E8%BF%99%E4%B8%AA%E6%9C%9F%E9%97%B4%E4%BD%BF%E7%94%A8AspectJ%E7%9A%84acj%E7%BC%96%E8%AF%91%E5%99%A8(%E7%B1%BB%E4%BC%BCjavac)%E6%8A%8Aaspect%E7%B1%BB%E7%BC%96%E8%AF%91%E6%88%90class%E5%AD%97%E8%8A%82%E7%A0%81%E5%90%8E%EF%BC%8C%E5%9C%A8java%E7%9B%AE%E6%A0%87%E7%B1%BB%E7%BC%96%E8%AF%91%E6%97%B6%E7%BB%87%E5%85%A5%EF%BC%8C%E5%8D%B3%E5%85%88%E7%BC%96%E8%AF%91aspect%E7%B1%BB%E5%86%8D%E7%BC%96%E8%AF%91%E7%9B%AE%E6%A0%87%E7%B1%BB%E3%80%82%0A%0A<strong>spring%E6%95%B4%E5%90%88%E4%BA%86ApectJ%E6%A1%86%E6%9E%B6%EF%BC%8C%E4%BD%86%E6%98%AF%E5%BA%95%E5%B1%82%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8acj%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%8C%E8%80%8C%E6%98%AF%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF</strong>%0A%0A!%5B684cc877c0b4266dc290fdf4ad997f10.png%5D(en-resource%3A%2F%2Fdatabase%2F1017%3A2)%0A%0A%23%23%23%20AOP%E5%AE%9E%E7%8E%B0%E4%B9%8BSpring%20AOP%0A**%E6%9C%AC%E8%B4%A8%E7%9B%AE%E7%9A%84%E5%B0%B1%E6%98%AF%E5%AF%B9%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AE%80%E5%8C%96%EF%BC%8C%E4%B8%BA%E4%BA%86%E6%96%B9%E4%BE%BF%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%AE%80%E5%8C%96%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%8C%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86**%0A%0Aspring%20AOP%E6%98%AF%E9%80%9A%E8%BF%87**%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0**%E7%9A%84%0A%0A*%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%89%EF%BC%9A**%E5%9F%BA%E4%BA%8EJDK%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86**%E5%92%8C%E4%BD%BF%E7%94%A8<strong>CGLib%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86</strong>%0A*%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%E9%80%89%E6%8B%A9%EF%BC%9A%E6%A0%B9%E6%8D%AE%E6%98%AF%E5%90%A6%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E6%9D%A5%E9%80%89%E6%8B%A9%E5%93%AA%E7%A7%8D%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%0A%0A!%5B190c537f5e1b7054e148f07281d52a7e.png%5D(en-resource%3A%2F%2Fdatabase%2F1016%3A1)%0A%0A%23%23%23%23%20%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%0A1.%20%E5%A3%B0%E6%98%8E%E6%8E%A5%E5%8F%A3%EF%BC%9A%E6%B3%A8%E5%86%8C%E9%9C%80%E8%A6%81%E8%A2%AB%E7%9B%91%E5%90%AC%E8%A1%8C%E4%B8%BA%E7%9A%84%E5%90%8D%E7%A7%B0%0A2.%20%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%9A%E6%89%AE%E6%BC%94%E8%A2%AB%E7%9B%91%E6%8E%A7%E7%9A%84%E7%B1%BB%EF%BC%8C%E8%B4%9F%E8%B4%A3%E8%A2%AB%E7%9B%91%E5%90%AC%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%0A3.%20InvocationHanler%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%9A%0A%20%20%20%20*%20%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%2F%E5%A2%9E%E5%BC%BA%E4%B8%9A%E5%8A%A1%0A%20%20%20%20*%20%E5%B0%86%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%E4%B8%8E%E8%A2%AB%E7%9B%91%E5%90%AC%E6%96%B9%E6%B3%95%E7%BB%91%E5%AE%9A%E6%89%A7%E8%A1%8C%0A4.%20%E4%BB%A3%E7%90%86%E7%9B%91%E6%8E%A7%E5%AF%B9%E8%B1%A1%EF%BC%9A%0A%20%20%20%20*%20%E8%A2%AB%E7%9B%91%E6%8E%A7%E7%B1%BB%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%A2%AB%E7%9B%91%E6%8E%A7%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%8E%A5%E5%8F%A3%EF%BC%8CInvocationHanler%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%0A%0A%23%23%23%23%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%0A1.%20%E5%9F%BA%E4%BA%8EJDK%EF%BC%88%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%EF%BC%89%0A2.%20%E4%BD%BF%E7%94%A8CGLib%EF%BC%88%E9%83%BD%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%EF%BC%89%0A%0ASpring%E4%B8%A4%E7%A7%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%E9%83%BD%E6%9C%89%E4%BD%BF%E7%94%A8%EF%BC%8C%E9%80%9A%E8%BF%87%E6%98%AF%E5%90%A6%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E6%9D%A5%E5%88%A4%E6%96%AD%E7%94%A8%E5%93%AA%E4%B8%AA%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%0A%0A%23%23%23%23%23%20JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%0A**%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%BF%85%E9%A1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3**%0A%0A%E4%BD%BF%E7%94%A8Proxy%E7%B1%BB%E6%9D%A5%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A%0A%60%60%60java%0A%C2%A0%C2%A0%C2%A0%20%2F**%0A%C2%A0%C2%A0%C2%A0%C2%A0%20*%20%E4%BD%BF%E7%94%A8JDK%E7%9A%84%E6%96%B9%E5%BC%8F%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%0A%C2%A0%C2%A0%C2%A0%C2%A0%20*%20%40author%20Administrator%0A%C2%A0%C2%A0%C2%A0%C2%A0%20*%2F%0A%C2%A0%C2%A0%C2%A0%20public%20class%20MyProxyUtils%20%7B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20public%20static%20UserService%20getProxy(final%20UserService%20service)%20%7B%0A%20%20%20%20%20%20%20%20%2F%2FPorxy%E6%98%AFJDK%E4%B8%AD%E7%9A%84API%E7%B1%BB%0A%20%20%20%20%20%20%20%20%2F%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%9A%E7%9B%AE%E6%A0%87%E9%98%9F%E5%BD%A2%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%0A%20%20%20%20%20%20%20%20%2F%2F%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%9A%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8E%A5%E5%8F%A3%0A%20%20%20%20%20%20%20%20%2F%2F%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%9A%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E5%A4%84%E7%90%86%E5%99%A8%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%2F%2F%20%E4%BD%BF%E7%94%A8Proxy%E7%B1%BB%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20UserService%20proxy%20%3D%20%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20(UserService)%20Proxy.newProxyInstance(%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20service.getClass().getClassLoader()%2C%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20service.getClass().getInterfaces()%2C%20%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20new%20InvocationHandler()%20%7B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%2F%2F%20%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B8%80%E6%89%A7%E8%A1%8C%EF%BC%8Cinvoke%E6%96%B9%E6%B3%95%E5%B0%B1%E4%BC%9A%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20public%20Object%20invoke(Object%20proxy%2C%20Method%20method%2C%20Object%5B%5D%20args)%20throws%20Throwable%20%7B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20if(%22save%22.equals(method.getName()))%7B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20System.out.println(%22%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97…%22)%3B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%2F%2F%20%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%7D%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%2F%2F%20%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%2F%2F%20%E8%AE%A9service%E7%B1%BB%E7%9A%84save%E6%88%96%E8%80%85update%E6%96%B9%E6%B3%95%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8B%E5%8E%BB%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20return%20method.invoke(service%2C%20args)%3B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%7D%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%7D)%3B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%2F%2F%20%E8%BF%94%E5%9B%9E%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20return%20proxy%3B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%7D%0A%C2%A0%C2%A0%C2%A0%20%7D%0A%60%60%60%0A%0A%23%23%23%23%23%20CGLib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%0A**%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E4%B8%8D%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3**%0A%E5%BA%95%E5%B1%82%E6%98%AF%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E4%BA%A7%E7%94%9F%E4%BB%A3%E7%90%86%E5%AD%90%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BB%A3%E7%90%86%E5%AD%90%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%BB%A7%E6%89%BF%E4%BA%86%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%E5%B9%B6%E5%8F%AF%E4%BB%A5%E5%AF%B9%E8%AF%A5%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%A2%9E%E5%BC%BA%EF%BC%89%0A%0A%60%60%60java%0Apublic%20static%20UserService%20getProxy()%7B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%2F%2F%20%E5%88%9B%E5%BB%BACGLIB%E6%A0%B8%E5%BF%83%E7%9A%84%E7%B1%BB%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20Enhancer%20enhancer%20%3D%20new%20Enhancer()%3B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%2F%2F%20%E8%AE%BE%E7%BD%AE%E7%88%B6%E7%B1%BB%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20enhancer.setSuperclass(UserServiceImpl.class)%3B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%2F%2F%20%E8%AE%BE%E7%BD%AE%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20enhancer.setCallback(new%20MethodInterceptor()%20%7B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%40Override%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20public%20Object%20intercept(Object%20obj%2C%20Method%20method%2C%20Object%5B%5D%20args%2C%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20MethodProxy%20methodProxy)%20throws%20Throwable%20%7B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20if(%22save%22.equals(method.getName()))%7B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%2F%2F%20%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20System.out.println(%22%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%E4%BA%86…%22)%3B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%7D%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20return%20methodProxy.invokeSuper(obj%2C%20args)%3B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%7D%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%7D)%3B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%2F%2F%20%E7%94%9F%E6%88%90%E5%A2%9E%E5%BC%BA%E4%B9%8B%E5%90%8E%E7%9A%84%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20UserService%20proxy%20%3D%20(UserService)%20enhancer.create()%3B%0A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20return%20proxy%3B%0A%C2%A0%C2%A0%C2%A0%20%7D%0A%60%60%60%0A%23%23%23%23%20Spring%20AOP%EF%BC%9A%E7%AE%80%E5%8C%96%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%0A1.%20%E5%A3%B0%E6%98%8E%E6%8E%A5%E5%8F%A3%EF%BC%9A%E6%B3%A8%E5%86%8C%E9%9C%80%E8%A6%81%E8%A2%AB%E7%9B%91%E5%90%AC%E8%A1%8C%E4%B8%BA%E5%90%8D%E7%A7%B0%0A2.%20%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%9A%E6%89%AE%E6%BC%94%E8%A2%AB%E7%9B%91%E6%8E%A7%E7%9A%84%E7%B1%BB%EF%BC%8C%E8%B4%9F%E8%B4%A3%E8%A2%AB%E7%9B%91%E5%90%AC%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%0A3.%20%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%2F%E5%A2%9E%E5%BC%BA%E4%B8%9A%E5%8A%A1%0A%0A**%E6%89%80%E4%BB%A5%E8%AF%B4spring%20AOP%E5%90%A7%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%845%E4%B8%AA%E6%AD%A5%E9%AA%A4%E7%9C%81%E7%95%A5%E4%B8%BA3%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%8C%E5%8F%AA%E9%9C%80%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%85%B3%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%EF%BC%8C%E5%86%8D%E5%8A%A0%E4%BB%A5%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F**%0A%0ASpring%20AOP%E4%B8%AD%E7%9A%84%E6%96%B0%E5%A2%9E%E5%90%8D%E8%AF%8D%E4%B9%9F%E5%9F%BA%E6%9C%AC%E9%83%BD%E6%98%AF%E4%B8%BA%E4%BA%86%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%80%8C%E6%9C%8D%E5%8A%A1%E7%9A%84%EF%BC%8C%E5%AE%83%E7%9A%84**%E6%9C%AC%E8%B4%A8%E5%B0%B1%E6%98%AF%E4%B8%BA%E4%BA%86%E7%AE%80%E5%8C%96%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0**%0A%0A%0A%23%23%20Spring%20AOP%20%E4%BD%BF%E7%94%A8%0A%0ASpring%20AOP%E6%98%AF%E6%8C%87Spring%E8%87%AA%E8%BA%AB%E5%AF%B9AOP%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%B8%8EAspectJ%E6%97%A0%E5%85%B3%E7%B3%BB%0A%0A%0A%23%23%23%20%E7%BC%96%E7%A8%8B%E5%BC%8FAOP%20ProxyFactory%0A%0A%23%23%23%23%20%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%B7%A5%E5%8E%82%EF%BC%8C%E8%AE%BE%E7%BD%AE%E8%A2%AB%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%B7%BB%E5%8A%A0%E9%80%9A%E7%9F%A5%0A%60%60%60java%0Apackage%20com.zhangguo.Spring041.aop05%3B%0A%0Aimport%20org.springframework.aop.framework.ProxyFactory%3B%0A%0Apublic%20class%20Test%20%7B%0A%0A%20%20%20%20%40org.junit.Test%0A%20%20%20%20public%20void%20test01()%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%E5%AE%9E%E4%BE%8B%E5%8C%96Spring%E4%BB%A3%E7%90%86%E5%B7%A5%E5%8E%82%0A%20%20%20%20%20%20%20%20ProxyFactory%20factory%3Dnew%20ProxyFactory()%3B%0A%20%20%20%20%20%20%20%20%2F%2F%E8%AE%BE%E7%BD%AE%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E5%AF%B9%E8%B1%A1%0A%20%20%20%20%20%20%20%20factory.setTarget(new%20Math())%3B%0A%20%20%20%20%20%20%20%20%2F%2F%E6%B7%BB%E5%8A%A0%E9%80%9A%E7%9F%A5%EF%BC%8C%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%0A%20%20%20%20%20%20%20%20factory.addAdvice(new%20BeforeAdvice())%3B%0A%20%20%20%20%20%20%20%20factory.addAdvice(new%20AfterAdvice())%3B%0A%20%20%20%20%20%20%20%20factory.addAdvice(new%20SurroundAdvice())%3B%0A%20%20%20%20%20%20%20%20%2F%2F%E4%BB%8E%E4%BB%A3%E7%90%86%E5%B7%A5%E5%8E%82%E4%B8%AD%E8%8E%B7%E5%BE%97%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%0A%20%20%20%20%20%20%20%20IMath%20math%3D(IMath)%20factory.getProxy()%3B%0A%20%20%20%20%20%20%20%20int%20n1%3D100%2Cn2%3D5%3B%0A%20%20%20%20%20%20%20%20math.add(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.sub(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.mut(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.div(n1%2C%20n2)%3B%0A%20%20%20%20%7D%0A%20%20%20%20%40org.junit.Test%0A%20%20%20%20public%20void%20test02()%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%2F%2Fmessage.message()%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A*%20%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%0A!%5B14990dfb14f83774e14078db4f5fb0bc.png%5D(en-resource%3A%2F%2Fdatabase%2F1006%3A1)%0A%0A%23%23%23%20%E5%A3%B0%E6%98%8E%E5%BC%8FAOP%20ProxyFactoryBean%0A%23%23%23%23%20Advice%0A%0A%0A**%E9%80%9A%E7%9F%A5Advice%E7%9A%84%E7%B1%BB%E5%9E%8B**%0A*%20springAOP%E4%B8%AD%EF%BC%8C%E9%80%9A%E8%BF%87Advice%E5%AE%9A%E4%B9%89%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%EF%BC%8CSpring%E4%B8%AD%E6%94%AF%E6%8C%815%E4%B8%AD%E7%B1%BB%E5%9E%8B%E7%9A%84Advice%0A%0A%7C%20%E9%80%9A%E7%9F%A5%20%7C%20%E8%BF%9E%E6%8E%A5%E7%82%B9%20%7C%20%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%20%7C%0A%7C%20—%20%7C%20—%20%7C%20—%20%7C%0A%7C%20%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%20%7C%20%E6%96%B9%E6%B3%95%E5%89%8D%20%7C%20org.springframework.aop.MethodBeforeAdvice%20%7C%0A%7C%20%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5%20%7C%20%E6%96%B9%E6%B3%95%E5%90%8E%20%7C%20org.springframework.aop.AfterReturningAdvice%20%7C%0A%7C%20%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%20%7C%20%E6%96%B9%E6%B3%95%E5%89%8D%E5%90%8E%20%7C%20org.aopalliance.intercept.MethodInterceptor%20%7C%0A%7C%20%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%8E%E9%80%9A%E7%9F%A5%20%7C%20%E6%96%B9%E6%B3%95%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%20%7C%20org.springframework.aop.ThrowsAdvice%20%7C%0A%7C%20%E5%BC%95%E4%BB%8B%E9%80%9A%E7%9F%A5%20%7C%20%E7%B1%BB%E4%B8%AD%E5%A2%9E%E5%8A%A0%E6%96%B0%E7%9A%84%E6%96%B9%E6%B3%95%E5%B1%9E%E6%80%A7%20%7C%20org.springframework.aop.IntroductionInterceptor%20%7C%0A%0A**%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5**%0A%60%60%60java%0Apackage%20com.zhangguo.Spring041.aop05%3B%0A%0Aimport%20java.lang.reflect.Method%3B%0A%0Aimport%20org.springframework.aop.MethodBeforeAdvice%3B%0A%0A%2F**%0A%20*%20%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%20%EF%BC%8C%E5%B0%B1%E7%9B%B8%E5%BD%93%E4%BA%8EInvocationHandler%E7%B1%BB%0A%20*%2F%0Apublic%20class%20BeforeAdvice%20implements%20MethodBeforeAdvice%20%7B%0A%0A%20%20%20%20%2F**%0A%20%20%20%20%20*%20method%20%E6%96%B9%E6%B3%95%E4%BF%A1%E6%81%AF%0A%20%20%20%20%20*%20args%20%E5%8F%82%E6%95%B0%0A%20%20%20%20%20*%20target%20%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%0A%20%20%20%20%20*%20%E8%AF%A5%E5%88%87%E9%9D%A2%E4%B8%80%E5%AE%9A%E6%98%AF%E5%9C%A8%E6%89%A7%E8%A1%8C%E4%B8%BB%E8%A6%81%E4%B8%9A%E5%8A%A1%E4%B9%8B%E5%89%8D%E6%89%A7%E8%A1%8C%EF%BC%8C%E6%89%80%E4%BB%A5%E6%96%B9%E6%B3%95%E4%B8%AD%E4%B8%8D%E9%9C%80%E8%A6%81%E5%AF%B9Method%E5%81%9A%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C%0A%20%20%20%20%20*%2F%0A%20%20%20%20public%20void%20before(Method%20method%2C%20Object%5B%5D%20args%2C%20Object%20target)%20throws%20Throwable%20%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22-----------------%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5-----------------%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A**%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5**%0A%60%60%60java%0Apackage%20com.zhangguo.Spring041.aop05%3B%0A%0Aimport%20java.lang.reflect.Method%3B%0A%0Aimport%20org.springframework.aop.AfterReturningAdvice%3B%0A%0A%2F**%0A%20*%20%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5%0A%20*%0A%20*%2F%0Apublic%20class%20AfterAdvice%20implements%20AfterReturningAdvice%20%7B%0A%20%20%20%20%2F*%0A%20%20%20%20%20*%20returnValue%20%E8%BF%94%E5%9B%9E%E5%80%BC%0A%20%20%20%20%20*%20method%20%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%0A%20%20%20%20%20*%20args%20%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%0A%20%20%20%20%20*%20target%20%E8%A2%AB%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%0A%20%20%20%20%20*%2F%0A%20%20%20%20public%20void%20afterReturning(Object%20returnValue%2C%20Method%20method%2C%20Object%5B%5D%20args%2C%20Object%20target)%20throws%20Throwable%20%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22-----------------%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5-----------------%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A**%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5**%0A%60%60%60java%0Apackage%20com.zhangguo.Spring041.aop05%3B%0A%0Aimport%20org.aopalliance.intercept.MethodInterceptor%3B%0Aimport%20org.aopalliance.intercept.MethodInvocation%3B%0A%0A%2F**%0A%20*%20%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%0A%20*%20%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA%E5%99%A8%0A%20*%0A%20*%2F%0Apublic%20class%20SurroundAdvice%20implements%20MethodInterceptor%20%7B%0A%0A%20%20%20%20public%20Object%20invoke(MethodInvocation%20i)%20throws%20Throwable%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%E5%89%8D%E7%BD%AE%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%0A%20%20%20%20%20%20%20%20System.out.println(%22%E6%96%B9%E6%B3%95%22%20%2B%20i.getMethod()%20%2B%20%22%20%E8%A2%AB%E8%B0%83%E7%94%A8%E5%9C%A8%E5%AF%B9%E8%B1%A1%22%20%2B%20i.getThis()%20%2B%20%22%E4%B8%8A%EF%BC%8C%E5%8F%82%E6%95%B0%20%22%20%2B%20i.getArguments())%3B%0A%20%20%20%20%20%20%20%20%2F%2F%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%0A%20%20%20%20%20%20%20%20Object%20ret%20%3D%20i.proceed()%3B%0A%20%20%20%20%20%20%20%20%2F%2F%E5%90%8E%E7%BD%AE%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%0A%20%20%20%20%20%20%20%20System.out.println(%22%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A%22%2B%20ret)%3B%0A%20%20%20%20%20%20%20%20return%20ret%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A%0A%23%23%23%23%23%20%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%0A%60%60%60java%0A%2F**%0A%20*%20%E6%8E%A5%E5%8F%A3%0A%20*%20%E6%8A%BD%E8%B1%A1%E4%B8%BB%E9%A2%98%0A%20*%2F%0Apublic%20interface%20IMath%20%7B%0A%20%20%20%20%2F%2F%E5%8A%A0%0A%20%20%20%20int%20add(int%20n1%2C%20int%20n2)%3B%2F%2FJoinCut%20%E8%BF%9E%E6%8E%A5%E7%82%B9%0A%20%20%20%20%2F%2F%E5%87%8F%0A%20%20%20%20int%20sub(int%20n1%2C%20int%20n2)%3B%2F%2FJoinCut%20%E8%BF%9E%E6%8E%A5%E7%82%B9%0A%20%20%20%20%2F%2F%E4%B9%98%0A%20%20%20%20int%20mut(int%20n1%2C%20int%20n2)%3B%2F%2FJoinCut%20%E8%BF%9E%E6%8E%A5%E7%82%B9%0A%20%20%20%20%2F%2F%E9%99%A4%0A%20%20%20%20int%20div(int%20n1%2C%20int%20n2)%3B%2F%2FJoinCut%20%E8%BF%9E%E6%8E%A5%E7%82%B9%0A%7D%0A%60%60%60%0A%23%23%23%23%23%20%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%0A%60%60%60java%0A%2F**%0A%20*%20%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%0A%20*%E7%9C%9F%E5%AE%9E%E4%B8%BB%E9%A2%98%0A%20*%2F%0Apublic%20class%20Math%20implements%20IMath%20%7B%0A%20%20%20%20%2F%2F%E5%8A%A0%0A%20%20%20%20public%20int%20add(int%20n1%2Cint%20n2)%7B%2F%2F%E5%88%87%E5%85%A5%E7%82%B9%20PointCut%20%20%E4%B8%BB%E8%A6%81%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%B3%95%0A%20%20%20%20%20%20%20%20int%20result%3Dn1%2Bn2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22%2B%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%20%20%20%20%2F%2F%E5%87%8F%0A%20%20%20%20public%20int%20sub(int%20n1%2Cint%20n2)%7B%2F%2F%E5%88%87%E5%85%A5%E7%82%B9%20PointCut%20%20%E4%B8%BB%E8%A6%81%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%B3%95%0A%20%20%20%20%20%20%20%20int%20result%3Dn1-n2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22-%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%20%20%20%20%2F%2F%E4%B9%98%0A%20%20%20%20public%20int%20mut(int%20n1%2Cint%20n2)%7B%2F%2F%E5%88%87%E5%85%A5%E7%82%B9%20PointCut%20%20%E4%B8%BB%E8%A6%81%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%B3%95%0A%20%20%20%20%20%20%20%20int%20result%3Dn1<em>n2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22X%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%20%20%20%20%2F%2F%E9%99%A4%0A%20%20%20%20public%20int%20div(int%20n1%2Cint%20n2)%7B%2F%2F%E5%88%87%E5%85%A5%E7%82%B9%20PointCut%20%20%E4%B8%BB%E8%A6%81%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%B3%95%0A%20%20%20%20%20%20%20%20int%20result%3Dn1%2Fn2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22%2F%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A%23%23%23%23%23%20%E5%AE%9A%E4%B9%89Advice%0A%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8FInvocationHandler%0A%60%60%60java%0A%2F</em>%0A%20*%20%20%20public%20class%20Agent%20implements%20InvocationHandler%7B%0A%20*%20%20%20%0A%20*%20%20%20%20%20%20private%20BaseService%20obj%3B%2F%2F%E5%BD%93%E5%89%8D%E5%85%B7%E4%BD%93%E8%A2%AB%E7%9B%91%E6%8E%A7%E5%AF%B9%E8%B1%A1%0A%20*%20%20%20%20%20%20public%20Agent(BasseSercie%20param)%7B%0A%20*%20%20%20%20%20%20%20%20%20%20this.obj%20%3D%20param%3B%0A%20*%20%20%20%20%20%20%7D%0A%20*%20%20%20%20%20%20public%20Object%20invoke(Object%20proxy%2CMethod%20method%2CObject%5B%5D%20args)%7B%0A%20*%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E7%BB%87%E5%85%A5%E9%A1%BA%E5%BA%8F%0A%20*%20%20%20%20%20%20%7D%0A%20*%20%20%20%20%20%20%2F%2F%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%0A%20*%20%20%20%20%20%20public%20wash()%7B%0A%20*%20%20%20%20%20%20%7D%0A%20*%20%20%20%7D%0A%20*%20%0A%20*%20*%2F%0A%60%60%60%0A**%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5**%0A%60%60%60java%0Aimport%20java.lang.reflect.Method%3B%0Aimport%20org.springframework.aop.AfterReturningAdvice%3B%0A%2F**%0A%20*%20%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5%0A%20*%0A%20*%2F%0Apublic%20class%20AfterAdvice%20implements%20AfterReturningAdvice%20%7B%0A%20%20%20%20%2F*%0A%20%20%20%20%20*%20returnValue%20%E8%BF%94%E5%9B%9E%E5%80%BC%0A%20%20%20%20%20*%20method%20%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%0A%20%20%20%20%20*%20args%20%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%0A%20%20%20%20%20*%20target%20%E8%A2%AB%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%0A%20%20%20%20%20*%20%E5%88%87%E9%9D%A2%EF%BC%8C%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%0A%20%20%20%20%20*%2F%0A%20%20%20%20public%20void%20afterReturning(Object%20returnValue%2C%20Method%20method%2C%20Object%5B%5D%20args%2C%20Object%20target)%20throws%20Throwable%20%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22%E5%85%B1%E7%94%A8%E6%97%B6%EF%BC%9Atime%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A%23%23%23%23%23%20%E4%BD%BF%E7%94%A8IOC%E9%85%8D%E7%BD%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%0A*%20%E5%BC%95%E5%85%A5spring%20IOC%E7%9A%84%E6%A0%B8%E5%BF%83jar%E5%8C%85%0A*%20%E5%88%9B%E5%BB%BAIOC%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6beans.xml%0A%60%60%60XML%0A%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%3F%3E%0A%3Cbeans%20xmlns%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%22%0A%20%20%20%20xmlns%3Axsi%3D%22http%3A%2F%<a href="http://2Fwww.w3.org">2Fwww.w3.org</a>%2F2001%2FXMLSchema-instance%22%20xmlns%3Ap%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fp%22%0A%20%20%20%20xsi%3AschemaLocation%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%2Fspring-beans.xsd%22%3E%0A%20%20%20%20%3C!–%20%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%20%EF%BC%8C%E6%B3%A8%E5%86%8C%E8%A2%AB%E7%9B%91%E6%8E%A7%E5%AE%9E%E7%8E%B0%E7%B1%BB–%3E%0A%20%20%20%20%3Cbean%20id%3D%22target%22%20class%3D%22com.zhangguo.Spring041.aop06.Math%22%3E%3C%2Fbean%3E%0A%20%20%20%20%3C!–%E9%80%9A%E7%9F%A5%E3%80%81%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%EF%BC%8C%E6%B3%A8%E5%86%8C%E9%80%9A%E7%9F%A5%E5%AE%9E%E7%8E%B0%E7%B1%BB–%3E%0A%20%20%20%20%3Cbean%20id%3D%22advice%22%20class%3D%22com.zhangguo.Spring041.aop06.AfterAdvice%22%3E%3C%2Fbean%3E%0A%20%20%20%20%3C!–%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%2C%E6%B3%A8%E5%86%8C%E4%BB%A3%E7%90%86%E7%9B%91%E6%8E%A7%E5%AF%B9%E8%B1%A1%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%8E%82%20–%3E%0A%20%20%20%20%3C!–interceptorNames%20%E9%80%9A%E7%9F%A5%E6%95%B0%E7%BB%84%20–%3E%0A%20%20%20%20%3C!–p%3Atarget-ref%20%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E5%AF%B9%E8%B1%A1–%3E%0A%20%20%20%20%3C!–p%3AproxyTargetClass%20%E8%A2%AB%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%98%AF%E5%88%99%E4%BD%BF%E7%94%A8cglib%2C%E5%90%A6%E5%88%99%E4%BD%BF%E7%94%A8jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%20%20–%3E%0A%20%20%20%20%3Cbean%20id%3D%22proxy%22%20class%3D%22org.springframework.aop.framework.ProxyFactoryBean%22%0A%20%20%20%20%20%20%20%20p%3AinterceptorNames%3D%22advice%22%0A%20%20%20%20%20%20%20%20p%3Atarget-ref%3D%22target%22%0A%20%20%20%20%20%20%20%20p%3AproxyTargetClass%3D%22true%22%3E%3C%2Fbean%3E%0A%3C%2Fbeans%3E%0A%20%20%20%20%3C!–%0A%20%20%20%20p%3AinterceptorNames%3D%22advice%22%E7%AD%89%E4%BB%B7%E4%BA%8E%3Cproperty%20name%3D%22interceptorNames%22%20value%3D%22advice%22%3E%3C%2Fproperty%3E%0A%20%20%20%20p%3Atarget-ref%3D%22target%22%E7%AD%89%E4%BB%B7%E4%BA%8E%3Cproperty%20name%3D%22target%22%20ref%3D%22target%22%3E%3C%2Fbean%3E%0A%20%20%20%20–%3E%0A%60%60%60%0A*%20%E8%8E%B7%E5%8F%96%E4%BB%A3%E7%90%86%E7%B1%BB%E5%B9%B6%E6%89%A7%E8%A1%8C%0A%60%60%60java%0Apackage%20com.zhangguo.Spring041.aop06%3B%0A%0Aimport%20org.springframework.context.ApplicationContext%3B%0Aimport%20org.springframework.context.support.ClassPathXmlApplicationContext%3B%0A%0Apublic%20class%20Test%20%7B%0A%0A%20%20%20%20%40org.junit.Test%0A%20%20%20%20public%20void%20test01()%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%E5%AE%B9%E5%99%A8%0A%20%20%20%20%20%20%20%20ApplicationContext%20ctx%3Dnew%20ClassPathXmlApplicationContext(%22beans.xml%22)%3B%0A%20%20%20%20%20%20%20%20%2F%2F%E4%BB%8E%E4%BB%A3%E7%90%86%E5%B7%A5%E5%8E%82%E4%B8%AD%E8%8E%B7%E5%BE%97%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%0A%20%20%20%20%20%20%20%20IMath%20math%3D(IMath)ctx.getBean(%22proxy%22)%3B%0A%20%20%20%20%20%20%20%20int%20n1%3D100%2Cn2%3D5%3B%0A%20%20%20%20%20%20%20%20math.add(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.sub(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.mut(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.div(n1%2C%20n2)%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A*%20%E8%BE%93%E5%87%BA%0A!%5B85c1048f46d8ee0d65a9b050af2b582e.png%5D(en-resource%3A%2F%2Fdatabase%2F1009%3A1)%0A%23%23%23%23%23%20%E5%B0%8F%E7%BB%93%0A*%20**%E8%BF%99%E9%87%8C%E6%9C%89%E4%B8%AA%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98**%EF%BC%9A%E4%BB%8E%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%8E%B7%E5%BE%97proxy%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%BA%94%E8%AF%A5%E6%98%AForg.springframework.aop.framework.ProxyFactoryBean%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1(%E5%A6%82%E4%B8%8B%E4%BB%A3%E7%A0%81%E6%89%80%E7%A4%BA)%EF%BC%8C%E4%BD%86%E8%BF%99%E9%87%8C%E7%9B%B4%E6%8E%A5%E5%B0%B1%E8%BD%AC%E6%8D%A2%E6%88%90IMath%E7%B1%BB%E5%9E%8B%E4%BA%86%EF%BC%8C%E8%BF%99%E6%98%AF%E5%9B%A0%E4%B8%BA%EF%BC%9AProxyFactoryBean%E6%9C%AC%E8%B4%A8%E4%B8%8A%E6%98%AF%E4%B8%80%E4%B8%AA%E7%94%A8%E6%9D%A5%E7%94%9F%E4%BA%A7Proxy%E7%9A%84FactoryBean%E3%80%82%E5%A6%82%E6%9E%9C%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%8C%81%E6%9C%89%E6%9F%90%E4%B8%AAFactoryBean%E7%9A%84%E5%BC%95%E7%94%A8%EE%80%84%E5%AE%83%E5%8F%96%E5%BE%97%E7%9A%84%E4%B8%8D%E6%98%AFFactoryBean%E6%9C%AC%E8%BA%AB%E8%80%8C%E6%98%AF%20FactoryBean%E7%9A%84getObject()%E6%96%B9%E6%B3%95%E6%89%80%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AF%B9%E8%B1%A1%E3%80%82%E6%89%80%E4%BB%A5%E5%A6%82%E6%9E%9C%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BE%9D%E8%B5%96%E4%BA%8EProxyFactoryBean%E9%82%A3%E4%B9%88%E5%AE%83%E5%B0%86%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%88%B0%20ProxyFactoryBean%E7%9A%84getObject()%E6%96%B9%E6%B3%95%E6%89%80%E8%BF%94%E5%9B%9E%E7%9A%84%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E8%BF%99%E5%B0%B1%E6%98%AFProxyFactryBean%E5%BE%97%E4%BB%A5%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8E%9F%E5%9B%A0%0A%0A%3E%20**%E9%80%9A%E7%9F%A5Advice%E7%9A%84%E5%BC%8A%E7%AB%AF%E6%98%AF%EF%BC%8C%E5%AE%83%E5%8F%AA%E5%8F%AF%E4%BB%A5%E5%AF%B9%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%BB%87%E5%85%A5%E5%88%87%E9%9D%A2**%0A%3E%20%E4%BC%9A%E5%BC%BA%E8%A1%8C%E7%9A%84%E4%B8%8E%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%BB%91%E5%AE%9A%0A%0A%23%23%23%23%20Advisor%20%E9%A1%BE%E9%97%AE%0A%E6%AD%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%AF%94advice%E6%9B%B4%E5%8A%A0%E7%81%B5%E6%B4%BB%EF%BC%8C%E5%8F%AA%E9%9C%80%E5%A4%9A%E5%AE%9E%E7%8E%B0%E5%87%A0%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%E7%9B%B8%E5%90%8C%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%9B%B4%E5%8A%A0%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%0A%23%23%23%23%23%20%E5%A3%B0%E6%98%8E%E6%8E%A5%E5%8F%A3%0A%60%60%60java%0Apublic%20interface%20BaseService%20%7B%0A%20%20%20%20%20%20%20public%20void%20eat()%3B%2F%2FJoinCut%20%E8%BF%9E%E6%8E%A5%E7%82%B9%0A%20%20%20%20%20%20%20public%20void%20wc()%3B%2F%2FJoinCut%20%E8%BF%9E%E6%8E%A5%E7%82%B9%0A%7D%0A%60%60%60%0A%23%23%23%23%23%20%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%0A%60%60%60java%0Aimport%20com.kaikeba.service.BaseService%3B%0A%0Apublic%20class%20Person%20implements%20BaseService%20%7B%0A%0A%09public%20void%20eat()%20%7B%2F%2F%E5%88%87%E5%85%A5%E7%82%B9%20PointCut%20%20%E4%B8%BB%E8%A6%81%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%B3%95%0A%09%09%0A%20%20%20%20%20%20%20%20%20%20%20System.out.println(%22%E5%90%83%E6%B3%A1%E9%9D%A2%22)%3B%0A%09%7D%0A%09public%20void%20wc()%20%7B%2F%2F%E5%88%87%E5%85%A5%E7%82%B9%20PointCut%20%20%20%E4%B8%BB%E8%A6%81%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%B3%95%0A%09%09%0A%09%09%20System.out.println(%22%E4%B8%8A%E5%8E%95%E6%89%80%22)%3B%0A%09%7D%0A%7D%0A%60%60%60%0A%23%23%23%23%23%20%E5%88%87%E9%9D%A2Advice%0A%E6%AC%A1%E8%A6%81%E6%96%B9%E6%B3%95%0A%60%60%60java%0Aimport%20java.lang.reflect.Method%3B%0A%0Aimport%20org.springframework.aop.Advisor%3B%0Aimport%20org.springframework.aop.MethodBeforeAdvice%3B%0Aimport%20org.springframework.aop.framework.ProxyFactoryBean%3B%0A%2F*%0A%20*%20%0A%20*%20%20%20public%20class%20Agent%20implements%20InvocationHandler%7B%0A%20*%20%20%20%0A%20*%20%20%20%20%20%20private%20BaseService%20obj%3B%2F%2F%E5%BD%93%E5%89%8D%E5%85%B7%E4%BD%93%E8%A2%AB%E7%9B%91%E6%8E%A7%E5%AF%B9%E8%B1%A1%0A%20*%20%20%20%20%20%20%0A%20*%20%20%20%20%20%20public%20Agent(BasseSercie%20param)%7B%0A%20*%20%20%20%20%20%20%20%20%20%20this.obj%20%3D%20param%3B%0A%20*%20%20%20%20%20%20%7D%0A%20*%20%20%20%0A%20*%20%20%20%20%20%20public%20Object%20invoke(Object%20proxy%2CMethod%20method%2CObject%5B%5D%20args)%7B%0A%20*%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E7%BB%87%E5%85%A5%E9%A1%BA%E5%BA%8F%0A%20*%20%20%20%20%20%20%7D%0A%20*%20%20%20%20%20%20%0A%20*%20%20%20%20%20%20%2F%2F%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%0A%20*%20%20%20%20%20%20public%20wash()%7B%0A%20*%20%20%20%20%20%20%0A%20*%20%20%20%20%20%20%7D%0A%20*%20%20%20%7D%0A%20*%20%0A%20*%20*%2F%0Apublic%20class%20MyBeforeAdvice%20implements%20MethodBeforeAdvice%20%7B%0A%0A%09%2F%2F%E5%88%87%E9%9D%A2%EF%BC%9A%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%0A%09public%20void%20before(Method%20arg0%2C%20Object%5B%5D%20arg1%2C%20Object%20arg2)%20throws%20Throwable%20%7B%0A%09%09System.out.println(%22-----%E6%B4%97%E6%89%8B-----%22)%3B%0A%20%20%20%20%20%20%20%20%0A%09%7D%0A%7D%0A%60%60%60%0A%23%23%23%23%23%20ClassFilter%20%E7%B1%BB%E6%8B%A6%E6%88%AA%E5%99%A8%0A%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E8%A2%AB%E6%8B%A6%E6%88%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%8D%E6%98%AF%E5%BD%93%E5%89%8D%E9%A1%BE%E9%97%AE%E9%9C%80%E8%A6%81%E7%AE%A1%E7%90%86%E5%AF%B9%E8%B1%A1%0A%60%60%60java%0Aimport%20org.springframework.aop.ClassFilter%3B%0A%0Aimport%20com.kaikeba.serviceImpl.Person%3B%0A%0Apublic%20class%20MyClassFilter%20implements%20ClassFilter%20%7B%0A%0A%09%20%2F*%0A%09%20%20*%20%201.%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%E4%B8%8B%E4%BC%9A%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%AE%9E%E7%8E%B0%E7%B1%BB%0A%09%20%20*%20%202.%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%98%AF%E4%B8%8D%E6%98%AF%E6%88%91%E4%BB%AC%E7%BB%87%E5%85%A5%E6%96%B9%E5%BC%8F%E5%85%B3%E5%BF%83%E7%9A%84%E7%9B%AE%E6%A0%87%E7%B1%BB%0A%09%20%20*%20%20BaseService%E6%8E%A5%E5%8F%A3%E6%88%91%E4%BB%AC%E7%8E%B0%E5%9C%A8%E5%8F%AA%E6%83%B3%E7%AE%A1%E7%90%86Person.%0A%09%20%20*%20%20%E5%8F%82%E6%95%B0%EF%BC%9A%E5%B0%B1%E6%98%AF%E5%BD%93%E5%89%8D%E8%A2%AB%E6%8B%A6%E6%88%AA%E7%B1%BB%EF%BC%9A%E5%8F%AF%E8%83%BDPerson%EF%BC%8C%E5%8F%AF%E8%83%BDGog%0A%09%20%20*%20*%2F%0A%09public%20boolean%20matches(Class%3C%3F%3E%20clazz)%20%7B%0A%09%20%20%20%20if(clazz%20%3D%3D%20Person.class)%7B%0A%09%20%20%20%20%09return%20true%3B%2F%2F%E5%91%8A%E8%AF%89%E9%A1%BE%E9%97%AE%EF%BC%8C%E5%BD%93%E5%89%8D%E7%B1%BB%E6%98%AF%E9%9C%80%E8%A6%81%E6%88%91%E4%BB%AC%E6%8F%90%E4%BE%9B%E7%BB%87%E5%85%A5%E6%9C%8D%E5%8A%A1%0A%09%20%20%20%20%7D%0A%09%20%20%20%20%2F%2FGog%0A%09%09return%20false%3B%0A%09%7D%0A%0A%7D%0A%60%60%60%0A%23%23%23%23%23%20MethodMatcher%20%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA%E5%99%A8%0A%E5%BD%93%E5%89%8D%E8%A2%AB%E6%8B%A6%E6%88%AA%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E4%B8%8D%E6%98%AF%E6%88%91%E4%BB%AC%E6%89%80%E9%9C%80%E8%A6%81%E4%B8%BB%E8%A6%81%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%B3%95%0A%60%60%60java%0Aimport%20java.lang.reflect.Method%3B%0A%0Aimport%20org.springframework.aop.MethodMatcher%3B%0A%0Apublic%20class%20MyMethodMatcher%20implements%20MethodMatcher%20%7B%0A%0A%09%2F*%0A%09%20*%20%20%E8%A2%AB%E7%9B%91%E6%8E%A7%E6%8E%A5%E5%8F%A3%E6%AF%94%E5%A6%82%EF%BC%88BaseService%EF%BC%89%EF%BC%8C%E6%B2%A1%E6%9C%89%E9%87%8D%E8%BD%BD%E6%96%B9%E6%B3%95%0A%09%20*%20%20%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0%E9%83%BD%E6%98%AF%E4%BB%A5%E5%94%AF%E4%B8%80%0A%09%20*%20%20%E6%AD%A4%E6%97%B6%E5%8F%AF%E4%BB%A5%E9%87%87%E7%94%A8%20static%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%8F%AA%E6%A0%B9%E6%8D%AE%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0%E5%88%A4%E6%96%AD%0A%09%20*%20%E5%8F%82%E6%95%B0%EF%BC%9Amethod%3A%20%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%9F%90%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%0A%09%20*%20%20%20%20%20targetClass%3A%20%E6%8E%A5%E5%8F%A3%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%8E%B0%E7%B1%BB%0A%09%20*%20%20%20%20%20%0A%09%20*%20%20%E4%B8%9A%E5%8A%A1%EF%BC%9A%E5%8F%AA%E6%83%B3%E4%B8%BAPerson%E7%B1%BB%E4%B8%ADeat%E6%96%B9%E6%B3%95%E6%8F%90%E4%BE%9B%E7%BB%87%E5%85%A5%20%20%20%0A%09%20*%2F%0A%09%0A%09public%20boolean%20matches(Method%20method%2C%20Class%3C%3F%3E%20targetClass)%20%7B%0A%09%09%0A%09%09String%20methodName%20%3D%20method.getName()%3B%0A%09%09if(%22eat%22.equals(methodName))%7B%0A%09%09%09return%20true%3B%0A%09%09%7D%0A%09%09return%20false%3B%0A%09%7D%0A%0A%09public%20boolean%20isRuntime()%20%7B%0A%09%09%2F%2F%20TODO%20Auto-generated%20method%20stub%0A%09%09return%20false%3B%0A%09%7D%0A%0A%09public%20boolean%20matches(Method%20method%2C%20Class%3C%3F%3E%20targetClass%2C%20Object…%20args)%20%7B%0A%09%09%2F%2F%20TODO%20Auto-generated%20method%20stub%0A%09%09return%20false%3B%0A%09%7D%0A%0A%7D%0A%0A%60%60%60%0A%23%23%23%23%23%20PointCut%0A%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%0A%60%60%60java%0Aimport%20org.springframework.aop.ClassFilter%3B%0Aimport%20org.springframework.aop.MethodMatcher%3B%0Aimport%20org.springframework.aop.Pointcut%3B%0A%0Apublic%20class%20MyPointCut%20implements%20Pointcut%20%7B%0A%09%0A%09%0A%09%2F*%0A%09%20*%20InvocationHandler%E6%8E%A5%E5%8F%A3%0A%09%20*%20%20%20%20invoke()%7B%0A%09%20*%20%20%20%20%20%20%20%20if(obj.getClass%20%EF%BC%81%3D%20person.class)%7B%0A%09%20*%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%0A%09%20*%20%20%20%20%20%20%20%20%7D%0A%09%20*%20%20%20%20%20%20%20%20%0A%09%20*%20%20%20%20%20%20%20%20if(!methodObj.getName.equals(%22eat%22))%7B%0A%09%20*%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%0A%09%20*%20%20%20%20%20%20%20%20%7D%0A%09%20*%20%20%20%20%20%20%20%20%2F%2F%E7%BB%87%E5%85%A5%E6%96%B9%E5%BC%8F%3A%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%B3%95%E5%92%8C%20Peson.eat()%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%0A%09%20*%20%20%20%20%20%20%20%20%2F%2F%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%0A%09%20*%20%20%20%20%20%20%20%20%20%20wash%EF%BC%88%EF%BC%89%EF%BC%9B%0A%09%20*%20%20%20%20%20%20%20%20%20%20Person.eat()%0A%09%20*%20%20%20%20%7D%0A%09%20*%20%0A%09%20*%20*%2F%0A%09%2F%2F%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%0A%09private%20ClassFilter%20classFilter%3B%0A%09private%20MethodMatcher%20metodMatcher%3B%0A%0A%09public%20void%20setClassFilter(ClassFilter%20classFilter)%20%7B%0A%09%09this.classFilter%20%3D%20classFilter%3B%0A%09%7D%0A%0A%09public%20void%20setMetodMatcher(MethodMatcher%20metodMatcher)%20%7B%0A%09%09this.metodMatcher%20%3D%20metodMatcher%3B%0A%09%7D%0A%0A%09public%20ClassFilter%20getClassFilter()%20%7B%0A%09%09%2F%2F%20TODO%20Auto-generated%20method%20stub%0A%09%09return%20this.classFilter%3B%0A%09%7D%0A%0A%09public%20MethodMatcher%20getMethodMatcher()%20%7B%0A%09%09%2F%2F%20TODO%20Auto-generated%20method%20stub%0A%09%09return%20this.metodMatcher%3B%0A%09%7D%0A%0A%7D%0A%60%60%60%0A%23%23%23%23%23%20PointCutAdvisor%0A%E5%8F%AF%E4%BB%A5%E7%81%B5%E6%B4%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E5%BD%93%E5%89%8D%E6%8E%A5%E5%8F%A3%E4%B8%8B%E7%9A%84%E5%93%AA%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%AD%E5%93%AA%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E4%B8%8E%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%E8%BF%9B%E8%A1%8C%E7%BB%91%E5%AE%9A%0A%60%60%60java%0Aimport%20org.aopalliance.aop.Advice%3B%0Aimport%20org.springframework.aop.Pointcut%3B%0Aimport%20org.springframework.aop.PointcutAdvisor%3B%0A%0Apublic%20class%20MyPointCutAdvisor%20implements%20PointcutAdvisor%20%7B%0A%09%2F%2F%E9%87%87%E7%94%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%20set%0A%20%20%20%20private%20Advice%20advice%3B%2F%2F%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%E4%BB%A5%E5%8F%8A%E6%AC%A1%E8%A6%81%E4%B8%9A%E5%8A%A1%E4%B8%8E%E4%B8%BB%E8%A6%81%E4%B8%9A%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%0A%20%20%20%20private%20Pointcut%20pointcut%3B%2F%2F%E5%BD%93%E5%89%8D%E6%8B%A6%E6%88%AA%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8%E4%B8%BB%E8%A6%81%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%B3%95%20person%E5%AF%B9%E8%B1%A1.eat()%0A%20%20%20%20%0A%20%20%20%20%0A%20%20%20%20%0A%09public%20void%20setAdvice(Advice%20advice)%20%7B%0A%09%09this.advice%20%3D%20advice%3B%0A%09%7D%0A%0A%09public%20void%20setPointcut(Pointcut%20pointcut)%20%7B%0A%09%09this.pointcut%20%3D%20pointcut%3B%0A%09%7D%0A%0A%09public%20Advice%20getAdvice()%20%7B%0A%09%09%2F%2F%20TODO%20Auto-generated%20method%20stub%0A%09%09return%20this.advice%3B%0A%09%7D%0A%0A%09public%20boolean%20isPerInstance()%20%7B%0A%09%09%2F%2F%20TODO%20Auto-generated%20method%20stub%0A%09%09return%20false%3B%0A%09%7D%0A%0A%09public%20Pointcut%20getPointcut()%20%7B%0A%09%09%2F%2F%20TODO%20Auto-generated%20method%20stub%0A%09%09return%20this.pointcut%3B%0A%09%7D%0A%0A%7D%0A%0A%60%60%60%0A%23%23%23%23%23%20spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%0A%60%60%60xml%0A%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%3F%3E%0A%3Cbeans%20xmlns%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%22%0A%20%20%20%20xmlns%3Axsi%3D%22http%3A%2F%<a href="http://2Fwww.w3.org">2Fwww.w3.org</a>%2F2001%2FXMLSchema-instance%22%0A%20%20%20%20xmlns%3Ap%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fp%22%0A%20%20%20%20xmlns%3Ac%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fc%22%0A%20%20%20%20xsi%3AschemaLocation%3D%22%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%20%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%2Fspring-beans.xsd%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fcontext%20%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fcontext%2Fspring-context.xsd%22%3E%0A%20%20%20%0A%20%20%20%20%20%20%20%3C!–%20%E6%B3%A8%E5%86%8C%E8%A2%AB%E7%9B%91%E6%8E%A7%E5%AE%9E%E7%8E%B0%E7%B1%BB%20–%3E%0A%20%20%20%20%20%20%20%3Cbean%20id%3D%22person%22%20class%3D%22com.kaikeba.serviceImpl.Person%22%3E%3C%2Fbean%3E%0A%20%20%20%20%20%20%20%3Cbean%20id%3D%22dog%22%20class%3D%22com.kaikeba.serviceImpl.Gog%22%3E%3C%2Fbean%3E%0A%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%3C!–%20%E6%B3%A8%E5%86%8C%E9%80%9A%E7%9F%A5%E5%AE%9E%E7%8E%B0%E7%B1%BB%20–%3E%0A%20%20%20%20%20%20%20%3Cbean%20id%3D%22before%22%20class%3D%22com.kaikeba.advice.MyBeforeAdvice%22%3E%3C%2Fbean%3E%0A%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%3C!–%20%E6%B3%A8%E5%86%8C%E7%B1%BB%E5%9E%8B%E8%BF%87%E6%BB%A4%E5%99%A8%20–%3E%0A%20%20%20%20%20%20%20%3Cbean%20id%3D%22classFilter%22%20class%3D%22com.kaikeba.util.MyClassFilter%22%3E%3C%2Fbean%3E%0A%20%20%20%20%20%20%20%3C!–%20%E6%B3%A8%E5%86%8C%E6%96%B9%E6%B3%95%E5%8C%B9%E9%85%8D%E5%99%A8%20–%3E%0A%20%20%20%20%20%20%20%3Cbean%20id%3D%22methodMatcher%22%20class%3D%22com.kaikeba.util.MyMethodMatcher%22%3E%3C%2Fbean%3E%0A%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%3C!–%20%E6%B3%A8%E5%86%8C%E5%88%87%E5%85%A5%E7%82%B9%20–%3E%0A%20%20%20%20%20%20%20%3Cbean%20id%3D%22pointCut%22%20class%3D%22com.kaikeba.util.MyPointCut%22%20%3E%0A%20%20%20%20%20%20%20%20%20%20%3Cproperty%20name%3D%22classFilter%22%20ref%3D%22classFilter%22%3E%3C%2Fproperty%3E%0A%20%20%20%20%20%20%20%20%20%20%3Cproperty%20name%3D%22metodMatcher%22%20ref%3D%22methodMatcher%22%3E%3C%2Fproperty%3E%0A%20%20%20%20%20%20%20%3C%2Fbean%3E%0A%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%3C!–%20%E6%B3%A8%E5%86%8C%E9%A1%BE%E9%97%AE%20–%3E%0A%20%20%20%20%20%20%20%3Cbean%20id%3D%22myAdvisor%22%20class%3D%22com.kaikeba.util.MyPointCutAdvisor%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%3Cproperty%20name%3D%22advice%22%20ref%3D%22before%22%3E%3C%2Fproperty%3E%0A%20%20%20%20%20%20%20%20%20%20%20%3Cproperty%20name%3D%22pointcut%22%20ref%3D%22pointCut%22%3E%3C%2Fproperty%3E%0A%20%20%20%20%20%20%20%3C%2Fbean%3E%0A%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%3C!–%20%E6%B3%A8%E5%86%8C%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E5%B7%A5%E5%8E%82%20–%3E%0A%20%20%20%20%20%20%20%3C!–%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E6%AD%A4%E6%97%B6%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%8F%AA%E4%BC%9A%E8%B4%9F%E8%B4%A3person.eat%E6%96%B9%E6%B3%95%E7%9B%91%E6%8E%A7%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E4%B8%8EAdvice%E4%B8%8D%E5%90%8C%EF%BC%8C%E4%B8%8D%E4%BC%9A%E5%AF%B9BaseService%E6%89%80%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%9B%91%E6%8E%A7%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20–%3E%0A%20%20%20%20%20%20%20%3Cbean%20id%3D%22personProxy%22%20class%3D%22org.springframework.aop.framework.ProxyFactoryBean%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cproperty%20name%3D%22target%22%20ref%3D%22person%22%3E%3C%2Fproperty%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cproperty%20name%3D%22interceptorNames%22%20value%3D%22myAdvisor%22%3E%3C%2Fproperty%3E%0A%20%20%20%20%20%20%20%3C%2Fbean%3E%0A%3C%2Fbeans%3E%0A%60%60%60%0A%0A%0A%23%23%20AspectJ%20AOP%EF%BC%88%E4%B8%80%E8%88%AC%E4%BD%BF%E7%94%A8%E8%AF%A5%E6%96%B9%E5%BC%8F%EF%BC%89%0A%0A<strong>AspectJ%20%E6%98%AFAOP%E5%8D%95%E7%8B%AC%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%8E%B0%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%92%8Cspring%E5%B9%B6%E6%97%A0%E5%85%B3%E7%B3%BB</strong>%0A%0A**%E4%B8%8B%E8%BF%B0%E6%AD%A5%E9%AA%A4%E6%98%AFAspectJ%2BSpring%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%EF%BC%88spring%E8%87%AA%E8%BA%AB%E5%AE%9E%E7%8E%B0%E7%9A%84aop%E6%98%AF%60ProxyFactoryBean%60%EF%BC%89**%0A%0AAspectJ%E6%98%AF%E4%B8%80%E4%B8%AAjava%E5%AE%9E%E7%8E%B0%E7%9A%84AOP%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%AE%83%E8%83%BD%E5%A4%9F%E5%AF%B9java%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8CAOP%E7%BC%96%E8%AF%91%EF%BC%88%E4%B8%80%E8%88%AC%E5%9C%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E8%BF%9B%E8%A1%8C%EF%BC%89%EF%BC%8C%E8%AE%A9java%E4%BB%A3%E7%A0%81%E5%85%B7%E6%9C%89AspectJ%E7%9A%84AOP%E5%8A%9F%E8%83%BD%EF%BC%88%E5%BD%93%E7%84%B6%E9%9C%80%E8%A6%81%E7%89%B9%E6%AE%8A%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%89%0A%0A%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E8%AF%B4AspectJ%E6%98%AF%E7%9B%AE%E5%89%8D%E5%AE%9E%E7%8E%B0AOP%E6%A1%86%E6%9E%B6%E4%B8%AD%E6%9C%80%E6%88%90%E7%86%9F%EF%BC%8C%E5%8A%9F%E8%83%BD%E6%9C%80%E4%B8%B0%E5%AF%8C%E7%9A%84%E8%AF%AD%E8%A8%80%EF%BC%8C%E6%9B%B4%E5%B9%B8%E8%BF%90%E7%9A%84%E6%98%AF%EF%BC%8CAspectJ%E4%B8%8Ejava%E7%A8%8B%E5%BA%8F%E5%AE%8C%E5%85%A8%E5%85%BC%E5%AE%B9%EF%BC%8C%E5%87%A0%E4%B9%8E%E6%98%AF%E6%97%A0%E7%BC%9D%E5%85%B3%E8%81%94%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%AF%B9%E4%BA%8E%E6%9C%89java%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%8C%E4%B8%8A%E6%89%8B%E5%92%8C%E4%BD%BF%E7%94%A8%E9%83%BD%E9%9D%9E%E5%B8%B8%E5%AE%B9%E6%98%93%E3%80%82%0A%0A%E4%BA%86%E8%A7%A3AspectJ%E5%BA%94%E7%94%A8%E5%88%B0java%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%88%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E7%A7%B0%E4%B8%BA%E7%BB%87%E5%85%A5%EF%BC%89%EF%BC%8C%E5%AF%B9%E4%BA%8E%E7%BB%87%E5%85%A5%E8%BF%99%E4%B8%AA%E6%A6%82%E5%BF%B5%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E4%B8%BAaspect(%E5%88%87%E9%9D%A2)%E5%BA%94%E7%94%A8%E5%88%B0%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0(%E7%B1%BB)%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82%0A%0A%E5%AF%B9%E4%BA%8E%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%EF%BC%8C**%E4%B8%80%E8%88%AC%E5%88%86%E4%B8%BA%E5%8A%A8%E6%80%81%E7%BB%87%E5%85%A5%E5%92%8C%E9%9D%99%E6%80%81%E7%BB%87%E5%85%A5%EF%BC%8C%E5%8A%A8%E6%80%81%E7%BB%87%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%98%AF%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E5%B0%86%E8%A6%81%E5%A2%9E%E5%BC%BA%E7%9A%84%E4%BB%A3%E7%A0%81%E7%BB%87%E5%85%A5%E5%88%B0%E7%9B%AE%E6%A0%87%E7%B1%BB%E4%B8%AD**%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%BE%80%E5%BE%80%E6%98%AF%E9%80%9A%E8%BF%87%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%E5%AE%8C%E6%88%90%E7%9A%84%EF%BC%8C%E5%A6%82%3Cu%3EJava%20JDK%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86(Proxy%EF%BC%8C%E5%BA%95%E5%B1%82%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%AE%9E%E7%8E%B0)%3C%2Fu%3E%E6%88%96%E8%80%85%3Cu%3ECGLIB%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86(%E5%BA%95%E5%B1%82%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0)%3C%2Fu%3E%EF%BC%8CSpring%20AOP%E9%87%87%E7%94%A8%E7%9A%84%E5%B0%B1%E6%98%AF%E5%9F%BA%E4%BA%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A2%9E%E5%BC%BA%E7%9A%84%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%0A%0A<strong>ApectJ%E9%87%87%E7%94%A8%E7%9A%84%E5%B0%B1%E6%98%AF%E9%9D%99%E6%80%81%E7%BB%87%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F</strong>%E3%80%82ApectJ%E4%B8%BB%E8%A6%81%E9%87%87%E7%94%A8%E7%9A%84%E6%98%AF%E7%BC%96%E8%AF%91%E6%9C%9F%E7%BB%87%E5%85%A5%EF%BC%8C%E5%9C%A8%E8%BF%99%E4%B8%AA%E6%9C%9F%E9%97%B4%E4%BD%BF%E7%94%A8AspectJ%E7%9A%84acj%E7%BC%96%E8%AF%91%E5%99%A8(%E7%B1%BB%E4%BC%BCjavac)%E6%8A%8Aaspect%E7%B1%BB%E7%BC%96%E8%AF%91%E6%88%90class%E5%AD%97%E8%8A%82%E7%A0%81%E5%90%8E%EF%BC%8C%E5%9C%A8java%E7%9B%AE%E6%A0%87%E7%B1%BB%E7%BC%96%E8%AF%91%E6%97%B6%E7%BB%87%E5%85%A5%EF%BC%8C%E5%8D%B3%E5%85%88%E7%BC%96%E8%AF%91aspect%E7%B1%BB%E5%86%8D%E7%BC%96%E8%AF%91%E7%9B%AE%E6%A0%87%E7%B1%BB%E3%80%82%0A%0A<strong>spring%E6%95%B4%E5%90%88%E4%BA%86ApectJ%E6%A1%86%E6%9E%B6%EF%BC%8C%E4%BD%86%E6%98%AF%E5%BA%95%E5%B1%82%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8acj%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%8C%E8%80%8C%E6%98%AF%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF</strong>%0A%0A!%5B684cc877c0b4266dc290fdf4ad997f10.png%5D(en-resource%3A%2F%2Fdatabase%2F1017%3A2)%0A%0A%23%23%23%20AspectJ%E7%9A%84XML%E5%AE%9E%E7%8E%B0AOP%0A%23%23%23%23%20%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%0A%23%23%23%23%23%20%E7%BC%96%E5%86%99%E7%9B%AE%E6%A0%87%E7%B1%BB%0A%E7%BC%96%E5%86%99%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%88%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%EF%BC%89%0A*%20UserService%E6%8E%A5%E5%8F%A3%0A*%20UserServiceImpl%E5%AE%9E%E7%8E%B0%E7%B1%BB%0A%0A%3E%20%E9%85%8D%E7%BD%AE%E7%9B%AE%E6%A0%87%E7%B1%BB%EF%BC%8C%E5%B0%86%E7%9B%AE%E6%A0%87%E7%B1%BB%E4%BA%A4%E7%BB%99spring%20IoC%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%0A%0A%23%23%23%23%23%20maven%E4%BE%9D%E8%B5%96%0A%60%60%60xml%0A%3C!–%20%E5%9F%BA%E4%BA%8EAspectJ%E7%9A%84aop%E4%BE%9D%E8%B5%96%20–%3E%0A%3Cdependency%3E%0A%20%20%20%20%20%20%3CgroupId%3Eorg.springframework%3C%2FgroupId%3E%0A%20%20%20%20%20%20%3CartifactId%3Espring-aspects%3C%2FartifactId%3E%0A%20%20%20%20%20%20%3Cversion%3E5.0.7.RELEASE%3C%2Fversion%3E%0A%3C%2Fdependency%3E%0A%3C!–%3Cdependency%3E%0A%20%20%20%20%20%20%3CgroupId%3Eaopalliance%3C%2FgroupId%3E%0A%20%20%20%20%20%20%3CartifactId%3Eaopalliance%3C%2FartifactId%3E%0A%20%20%20%20%20%20%3Cversion%3E1.0%3C%2Fversion%3E%0A%3C%2Fdependency%3E–%3E%0A%60%60%60%0A%23%23%23%23%23%20%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAadvice%EF%BC%88%E9%80%9A%E7%9F%A5%EF%BC%89%0A*%20%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAbean%0A%20%20%20%20*%20%E8%AF%A5%E9%80%9A%E7%9F%A5%E4%B8%8D%E5%86%8D%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E4%BB%BB%E4%BD%95%E6%8E%A5%E5%8F%A3%E6%88%96%E7%BB%A7%E6%89%BF%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E7%9A%84bean%E5%8D%B3%E5%8F%AF%EF%BC%8C%E6%96%B9%E6%B3%95**%E5%8F%AF%E4%BB%A5**%EF%BC%88%E4%B9%9F%E5%8F%AF%E4%B8%8D%E5%B8%A6%EF%BC%89%E5%B8%A6%E4%B8%80%E4%B8%AAJoinPoint%E8%BF%9E%E6%8E%A5%E7%82%B9%E5%8F%82%E6%95%B0%EF%BC%8C%E7%94%A8%E4%BA%8E%E8%8E%B7%E5%BE%97%E8%BF%9E%E6%8E%A5%E7%82%B9%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%A6%82%E6%96%B9%E6%B3%95%E5%90%8D%EF%BC%8C%E5%8F%82%E6%95%B0%EF%BC%8C%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%AD%89%0A%60%60%60java%0Apackage%20com.zhangguo.Spring041.aop08%3B%0A%0Aimport%20org.aspectj.lang.JoinPoint%3B%0A%0A%2F**%0A%20*%20%E9%80%9A%E7%9F%A5%0A%20*%2F%0Apublic%20class%20Advices%20%7B%0A%20%20%20%20%2F%2F%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%0A%20%20%20%20public%20void%20before(JoinPoint%20jp)%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22--------------------bofore--------------------%22)%3B%0A%20%20%20%20%20%20%20%20System.out.println(%22%E6%96%B9%E6%B3%95%E5%90%8D%EF%BC%9A%22%2Bjp.getSignature()%2B%22%EF%BC%8C%E5%8F%82%E6%95%B0%EF%BC%9A%22%2Bjp.getArgs().length%2B%22%EF%BC%8C%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%EF%BC%9A%22%2Bjp.getTarget())%3B%0A%20%20%20%20%7D%0A%20%20%20%20%2F%2F%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5%0A%20%20%20%20public%20void%20after(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22--------------------after--------------------%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A*%20%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%BE%88%E5%A4%9A%E7%A7%8D%EF%BC%8C%E6%9C%89%E4%BA%9B%E5%8F%82%E6%95%B0%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%8C%E7%89%B9%E5%88%AB%E6%98%AF%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%0A%20%20%20%20*%20**%E4%B8%8B%E5%88%97%E6%96%B9%E6%B3%95%E5%90%8D%E5%8F%AF%E4%BB%A5%E9%9A%8F%E6%84%8F%E7%BC%96%E5%86%99**%0A%60%60%60java%0A%2F%2F%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%0Apublic%20void%20beforeMethod(JoinPoint%20joinPoint)%0A%0A%2F%2F%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5%0Apublic%20void%20afterMethod(JoinPoint%20joinPoint)%0A%0A%2F%2F%E8%BF%94%E5%9B%9E%E5%80%BC%E9%80%9A%E7%9F%A5%0Apublic%20void%20afterReturning(JoinPoint%20joinPoint%2C%20Object%20result)%0A%0A%2F%2F%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E9%80%9A%E7%9F%A5%0A%2F%2F%E5%9C%A8%E6%96%B9%E6%B3%95%E5%87%BA%E7%8E%B0%E5%BC%82%E5%B8%B8%E6%97%B6%E4%BC%9A%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E5%88%B0%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%8C%87%E5%AE%9A%E5%9C%A8%E5%87%BA%E7%8E%B0%E7%89%B9%E5%AE%9A%E5%BC%82%E5%B8%B8%E6%97%B6%E5%9C%A8%E6%89%A7%E8%A1%8C%E9%80%9A%E7%9F%A5%E4%BB%A3%E7%A0%81%0Apublic%20void%20afterThrowing(JoinPoint%20joinPoint%2C%20Exception%20ex)%0A%0A%2F%2F%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%0A%2F%2F%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E9%9C%80%E8%A6%81%E6%90%BA%E5%B8%A6ProceedingJoinPoint%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%0A%2F%2F%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E7%B1%BB%E4%BC%BC%E4%BA%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%9AProceedingJoinPoint%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%E5%8F%AF%E4%BB%A5%E5%86%B3%E5%AE%9A%E6%98%AF%E5%90%A6%E6%89%A7%E8%A1%8C%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E3%80%82%0A%2F%2F%E8%80%8C%E4%B8%94%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E5%BF%85%E9%A1%BB%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E5%8D%B3%E4%B8%BA%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%0Apublic%20Object%20aroundMethod(ProceedingJoinPoint%20pjd)%7B%0A%20%20%20%20System.out.println(%22%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E5%89%8D%22)%3B%0A%20%20%20%20%2F%2F%E8%B0%83%E7%94%A8%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%0A%20%20%20%20Object%20proceed%20%3D%20pjd.proceed()%3B%20%0A%20%20%20%20System.out.println(%22%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E5%89%8D%22)%3B%0A%20%20%20%20return%20proceed%3B%0A%7D%0A%60%60%60%0A%23%23%23%23%23%20%E9%85%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%0A*%20xml%E9%85%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%EF%BC%8C%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E7%9A%84bean%0A%60%60%60xml%0A%3Cbean%20id%3D%22advices%22%20class%3D%22com.zhangguo.Spring041.aop08.Advices%22%3E%3C%2Fbean%3E%0A…%0A%3C%2Fbean%3E%0A%60%60%60%0A%0A%23%23%23%23%23%20%E9%85%8D%E7%BD%AEAOP%E5%88%87%E9%9D%A2%0A*%20%E5%B0%B1%E6%98%AF%E6%8C%87%E6%98%8E%E4%BD%A0%E7%9A%84%E5%88%87%E9%9D%A2%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%A6%81%E5%9C%A8%E5%93%AA%E4%BA%9B%E7%B1%BB%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E7%9A%84%E5%89%8D%E5%90%8E%E6%89%A7%E8%A1%8C%0A%20%20%20%20*%20%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%A1%88%E4%BE%8B%E6%8C%87%E6%98%8E%E4%BA%86%E6%98%AF%E5%B0%86%E5%88%87%E9%9D%A2%E5%88%87%E5%85%A5service%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%EF%BC%8C%E5%8D%B3%E8%AF%A5%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E5%8F%AA%E8%A6%81%E4%B8%80%E6%89%A7%E8%A1%8C%E5%B0%B1%E8%B0%83%E7%94%A8%E5%88%87%E9%9D%A2%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E9%80%9A%E7%9F%A5%E6%96%B9%E6%B3%95%EF%BC%8C%E8%87%B3%E4%BA%8E%E8%A6%81%E6%89%A7%E8%A1%8C%E5%93%AA%E4%BA%9B%E9%80%9A%E7%9F%A5%E6%96%B9%E6%B3%95%EF%BC%8C%E9%9C%80%E8%A6%81%E5%90%8E%E7%BB%AD%E6%AD%A5%E9%AA%A4%E7%BB%A7%E7%BB%AD%E9%85%8D%E7%BD%AE%0A%0A%60%60%60xml%0A%3Caop%3Aconfig%3E%0A%20%20%20%3Caop%3Aaspect%20id%3D%22myAspect%22%20ref%3D%22aBean%22%3E%0A%20%20%20%20%20%20%3Caop%3Apointcut%20id%3D%22businessService%22%0A%20%20%20%20%20%20%20%20%20expression%3D%22execution(<em>%20com.xyz.myapp.service.</em>.<em>(…))%22%2F%3E%0A%20%20%20%20%20%20%3C!–%20%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%20–%3E%0A%20%20%20%20%20%20%3Caop%3Abefore%20pointcut-ref%3D%22businessService%22%20%0A%20%20%20%20%20%20%20%20%20method%3D%22doRequiredTask%22%2F%3E%0A%20%20%20%20%20%20%3C!–%20%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5%20–%3E%0A%20%20%20%20%20%20%3Caop%3Aafter%20pointcut-ref%3D%22businessService%22%20%0A%20%20%20%20%20%20%20%20%20method%3D%22doRequiredTask%22%2F%3E%0A%20%20%20%20%20%20%3C!–%20%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5%20–%3E%0A%20%20%20%20%20%20%3Caop%3Aafter-returning%20pointcut-ref%3D%22businessService%22%0A%20%20%20%20%20%20%20%20%20returning%3D%22retVal%22%0A%20%20%20%20%20%20%20%20%20method%3D%22doRequiredTask%22%2F%3E%0A%20%20%20%20%20%20%3C!–%20%E5%BC%82%E5%B8%B8%E6%8A%9B%E5%87%BA%E9%80%9A%E7%9F%A5–%3E%0A%20%20%20%20%20%20%3Caop%3Aafter-throwing%20pointcut-ref%3D%22businessService%22%0A%20%20%20%20%20%20%20%20%20throwing%3D%22ex%22%0A%20%20%20%20%20%20%20%20%20method%3D%22doRequiredTask%22%2F%3E%0A%20%20%20%20%20%20%3C!–%20%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%20–%3E%0A%20%20%20%20%20%20%3Caop%3Aaround%20pointcut-ref%3D%22businessService%22%20%0A%20%20%20%20%20%20%20%20%20method%3D%22doRequiredTask%22%2F%3E%0A%20%20%20…%0A%20%20%20%3C%2Faop%3Aaspect%3E%0A%3C%2Faop%3Aconfig%3E%0A%3Cbean%20id%3D%22aBean%22%20class%3D%22…%22%3E%0A…%0A%3C%2Fbean%3E%0A%60%60%60%0A!%5B6906bc90093be45361359b6d422da53f.png%5D(en-resource%3A%2F%2Fdatabase%2F1018%3A1)%0A%0A!%5B7e0223d5cd1e4ba3eeeca3754c226ccb.png%5D(en-resource%3A%2F%2Fdatabase%2F1020%3A1)%0A%0A%23%23%23%23%20%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%0A%3Cu%3E%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A0%BC%E5%BC%8F%3C%2Fu%3E%EF%BC%9A%0A%0A%3Cu%3E</em>%E5%8D%95%E4%B8%AA%E7%82%B9%E7%94%A8%E6%9D%A5%E5%88%86%E5%89%B2%E5%8C%85%E5%90%8D%EF%BC%8C%E7%B1%BB%E5%90%8D%EF%BC%8C%E6%96%B9%E6%B3%95%E5%90%8D*%3C%2Fu%3E%0A%0A<strong>execution(%5B%E4%BF%AE%E9%A5%B0%E7%AC%A6%5D%20%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%20%E5%8C%85%E5%90%8D.%E7%B1%BB%E5%90%8D.%E6%96%B9%E6%B3%95%E5%90%8D(%E5%8F%82%E6%95%B0))</strong>%0A*%20execution%EF%BC%9A%E5%BF%85%E9%A1%BB%E8%A6%81%0A*%20%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A%E5%8F%AF%E7%9C%81%E7%95%A5%0A*%20%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%9A%E5%BF%85%E9%A1%BB%E8%A6%81%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8*%E9%80%9A%E9%85%8D%E7%AC%A6%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%0A%0A*%20**%E5%8C%85%E5%90%8D%C2%A0%EF%BC%9A**%0A%20%20%20%20*%20%E5%A4%9A%E7%BA%A7%E5%8C%85%E4%B9%8B%E9%97%B4%E4%BD%BF%E7%94%A8.%E5%88%86%E5%89%B2%0A%20%20%20%20*%20%E5%8C%85%E5%90%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20*%20%E4%BB%A3%E6%9B%BF%EF%BC%8C%E5%A4%9A%E7%BA%A7%E5%8C%85%E5%90%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%20*%20%E4%BB%A3%E6%9B%BF%0A%20%20%20%20*%20%E5%A6%82%E6%9E%9C%E6%83%B3%E7%9C%81%E7%95%A5%E4%B8%AD%E9%97%B4%E7%9A%84%E5%8C%85%E5%90%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20…%0A*%20**%E7%B1%BB%E5%90%8D%EF%BC%9A**%0A%20%20%20%20*%20%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20*%20%E4%BB%A3%E6%9B%BF%0A%20%20%20%20*%20%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%86%99%E6%88%90%20*%20DaoImpl%0A*%20**%E6%96%B9%E6%B3%95%E5%90%8D%EF%BC%9A**%0A%20%20%20%20*%20%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20*%20%E5%A5%BD%E4%BB%A3%E6%9B%BF%0A%20%20%20%20*%20%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%86%99%E6%88%90add%20*%20%0A*%20**%E5%8F%82%E6%95%B0%EF%BC%9A**%0A%20%20%20%20*%20%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8%20*%20%E4%BB%A3%E6%9B%BF%0A%20%20%20%20*%20%E5%A6%82%E6%9E%9C%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20…%E4%BB%A3%E6%9B%BF%0A%0A!%5B6072916c32e601d94c0f51e6b83d0065.png%5D(en-resource%3A%2F%2Fdatabase%2F1019%3A1)%0A%0A%23%23%23%23%20%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B%0A%0A%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BA%94%E7%A7%8D%EF%BC%89%EF%BC%9A**%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%E3%80%81%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5%E3%80%81%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5%E3%80%81%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E3%80%81%E5%BC%82%E5%B8%B8%E6%8A%9B%E5%87%BA%E9%80%9A%E7%9F%A5**%0A%0A**%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%EF%BC%9A**%0A*%20%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA%EF%BC%9A%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B9%8B%E5%89%8D%E6%89%A7%E8%A1%8C%E9%80%9A%E7%9F%A5%0A*%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9A%3Caop%3Abefore%20method%3D%22before%22%20pointcut-ref%3D%22myPointcut%22%2F%3E%0A*%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%E6%96%B9%E6%B3%95%E5%BC%80%E5%A7%8B%E6%97%B6%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E6%A0%A1%E9%AA%8C%0A%0A**%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5%EF%BC%9A**%0A*%20%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA%EF%BC%9A%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%E9%80%9A%E7%9F%A5%EF%BC%8C%E6%9C%89%E5%BC%82%E5%B8%B8%E5%88%99%E4%B8%8D%E6%89%A7%E8%A1%8C%E4%BA%86%0A*%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9A%3Caop%3Aafter-returning%20method%3D%22afterReturning%22%20%0Apointcut-ref%3D%22myPointcut%22%2F%3E%0A*%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%0A%0A**%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5%EF%BC%9A**%0A*%20%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA%EF%BC%9A%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%E9%80%9A%E7%9F%A5%EF%BC%8C%E6%9C%89%E6%B2%A1%E6%9C%89%E5%BC%82%E5%B8%B8%E9%83%BD%E4%BC%9A%E6%89%A7%E8%A1%8C%0A*%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9A%3Caop%3Aafter%20method%3D%22after%22%20pointcut-ref%3D%22myPointcut%22%2F%3E%0A*%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%E4%BE%8B%E5%A6%82%E5%83%8F%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90%0A%0A**%E5%BC%82%E5%B8%B8%E6%8A%9B%E5%87%BA%E9%80%9A%E7%9F%A5%EF%BC%9A**%0A*%20%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA%EF%BC%9A%E5%9C%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%8E%E9%80%9A%E7%9F%A5%0A*%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9A%3Caop%3Aafter-throwing%20method%3D%22%20afterThrowing%20%22%20pointcut-%20%0Aref%3D%22myPointcut%22%2F%3E%0A*%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%E5%8C%85%E8%A3%85%E5%BC%82%E5%B8%B8%0A%0A**%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%EF%BC%9A%EF%BC%88%E4%BD%BF%E7%94%A8%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E5%8F%AF%E4%BB%A5%E6%9B%BF%E4%BB%A3%E5%85%B6%E4%BB%96%E5%9B%9B%E4%B8%AA%E9%80%9A%E7%9F%A5%EF%BC%89**%0A*%20%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA%EF%BC%9A%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B9%8B%E5%89%8D%E5%92%8C%E4%B9%8B%E5%90%8E%E9%83%BD%E4%BC%9A%E6%89%A7%E8%A1%8C%EF%BC%8C%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%8E%E4%B8%8D%E4%BC%9A%E6%89%A7%E8%A1%8C%0A*%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9A%3Caop%3Aaround%20method%3D%22around%22%20pointcut-ref%3D%22myPointcut%22%2F%3E%0A*%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%E4%BA%8B%E5%8A%A1%E3%80%81%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA%0A%0A!%5Bcc1c8d03855a2cac4b9a39857a6dba3b.png%5D(en-resource%3A%2F%2Fdatabase%2F1021%3A1)%40w%3D400%0A%0A%0A%23%23%23%23%20XML%E5%AE%9E%E7%8E%B0Spring%20AOP%20%E6%A1%88%E4%BE%8B%0A**%E8%A6%81%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84Math%E7%B1%BB**%0A%60%60%60java%0Apackage%20com.zhangguo.Spring052.aop01%3B%0A%0A%2F**%0A%20*%20%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E7%B1%BB%0A%20*%2F%0Apublic%20class%20Math%7B%0A%20%20%20%20%2F%2F%E5%8A%A0%0A%20%20%20%20public%20int%20add(int%20n1%2Cint%20n2)%7B%0A%20%20%20%20%20%20%20%20int%20result%3Dn1%2Bn2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22%2B%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%E5%87%8F%0A%20%20%20%20public%20int%20sub(int%20n1%2Cint%20n2)%7B%0A%20%20%20%20%20%20%20%20int%20result%3Dn1-n2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22-%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%E4%B9%98%0A%20%20%20%20public%20int%20mut(int%20n1%2Cint%20n2)%7B%0A%20%20%20%20%20%20%20%20int%20result%3Dn1<em>n2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22X%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%E9%99%A4%0A%20%20%20%20public%20int%20div(int%20n1%2Cint%20n2)%7B%0A%20%20%20%20%20%20%20%20int%20result%3Dn1%2Fn2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22%2F%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A%20**%E7%BC%96%E8%BE%91%E9%80%9A%E7%9F%A5%E7%B1%BBAdvice**%0A%60%60%60java%0Apackage%20com.zhangguo.Spring052.aop01%3B%0A%0Aimport%20org.aspectj.lang.JoinPoint%3B%0A%0A%2F**%0A%20</em>%20%E9%80%9A%E7%9F%A5%E7%B1%BB%EF%BC%8C%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%0A%20*%0A%20*%2F%0Apublic%20class%20Advices%20%7B%0A%20%20%20%20%0A%20%20%20%20public%20void%20before(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%20%20%20%20System.out.println(jp.getSignature().getName())%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20public%20void%20after(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A**%E9%85%8D%E7%BD%AEAOP%20XML%E6%96%87%E4%BB%B6**%0A*%20%E5%8A%A0%E7%B2%97%E9%83%A8%E5%88%86%E7%9A%84%E5%86%85%E5%AE%B9%E6%98%AF%E5%9C%A8%E5%8E%9FIOC%E5%86%85%E5%AE%B9%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E4%B8%BAAOP%E6%9C%8D%E5%8A%A1%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%BC%95%E5%85%A5%E5%A4%B1%E8%B4%A5%E5%88%99%E6%B2%A1%E6%9C%89%E6%99%BA%E8%83%BD%E6%8F%90%E7%A4%BA%E3%80%82xmlns%3A%E6%98%AFxml%20namespace%E7%9A%84%E7%AE%80%E5%86%99%E3%80%82xmlns%3Axsi%EF%BC%9A%E5%85%B6xsd%E6%96%87%E4%BB%B6%E6%98%AFxml%E9%9C%80%E8%A6%81%E9%81%B5%E5%AE%88%E7%9A%84%E8%A7%84%E8%8C%83%EF%BC%8C%E9%80%9A%E8%BF%87URL%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%EF%BC%8C%E6%98%AFw3%E7%9A%84%E7%BB%9F%E4%B8%80%E8%A7%84%E8%8C%83%EF%BC%8C%E5%90%8E%E9%9D%A2%E9%80%9A%E8%BF%87xsi%3AschemaLocation%E6%9D%A5%E5%AE%9A%E4%BD%8D%E6%89%80%E6%9C%89%E7%9A%84%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6%EF%BC%8C%E8%BF%99%E9%87%8C%E5%8F%AA%E8%83%BD%E6%88%90%E5%81%B6%E6%95%B0%E5%AF%B9%E5%87%BA%E7%8E%B0%E3%80%82%0A*%20%60%3Cbean%20id%3D%22advice%22%20class%3D%22com.zhangguo.Spring041.aop08.Advices%22%3E%3C%2Fbean%3E%60%E8%A1%A8%E7%A4%BA%E9%80%9A%E7%9F%A5bean%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91bean%0A*%20%60%20%3Caop%3Aconfig%20proxy-target-class%3D%22true%22%3E%60%E7%94%A8%E4%BA%8EAOP%E9%85%8D%E7%BD%AE%EF%BC%8Cproxy-target-class%E5%B1%9E%E6%80%A7%E8%A1%A8%E7%A4%BA%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%B1%BB%E6%98%AF%E5%90%A6%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%EF%BC%8CSpring%E4%BC%9A%E4%BE%9D%E6%8D%AE%E5%AE%9E%E7%8E%B0%E4%BA%86%E6%8E%A5%E5%8F%A3%E5%88%99%E4%BD%BF%E7%94%A8JDK%E5%86%85%E7%BD%AE%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%AA%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%88%99%E4%BD%BF%E7%94%A8cblib%EF%BC%9B%E5%9C%A8Bean%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%8C%E6%89%80%E6%9C%89%E7%9A%84Spring%20AOP%E9%85%8D%E7%BD%AE%E9%83%BD%E5%BF%85%E9%A1%BB%E5%AE%9A%E4%B9%89%E5%9C%A8%3Caop%3Aconfig%3E%E5%85%83%E7%B4%A0%E5%86%85%E9%83%A8%E3%80%82%0A%0A*%20%60%3Caop%3Aaspect%3E%60%E5%85%83%E7%B4%A0%E6%9D%A5%E4%B8%BA%E5%85%B7%E4%BD%93%E7%9A%84%E5%88%87%E9%9D%A2%E5%AE%9E%E7%8E%B0%E5%BC%95%E7%94%A8%E5%90%8E%E7%AB%AFBean%E5%AE%9E%E4%BE%8B%E3%80%82%E5%9B%A0%E6%AD%A4%EF%BC%8C%E5%88%87%E9%9D%A2Bean%E5%BF%85%E9%A1%BB%E6%9C%89%E4%B8%80%E4%B8%AA%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%8C%E4%BE%9B%3Caop%3Aaspect%3E%E5%85%83%E7%B4%A0%E5%BC%95%E7%94%A8%E3%80%82aop%3Aaspect%E8%A1%A8%E7%A4%BA%E5%88%87%E9%9D%A2%E9%85%8D%E7%BD%AE%EF%BC%8C%C2%A0ref%E8%A1%A8%E7%A4%BA%E9%80%9A%E7%9F%A5%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%9B%0A*%20%60aop%3Apointcut%60%E6%98%AF%E9%85%8D%E7%BD%AE%E5%88%87%E5%85%A5%E7%82%B9%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%E5%B0%86%E6%B3%A8%E5%85%A5%E7%9A%84%E7%B2%BE%E7%A1%AE%E4%BD%8D%E7%BD%AE%EF%BC%8C%E9%82%A3%E4%BA%9B%E5%8C%85%EF%BC%8C%E7%B1%BB%EF%BC%8C%E6%96%B9%E6%B3%95%E9%9C%80%E8%A6%81%E6%8B%A6%E6%88%AA%E6%B3%A8%E5%85%A5%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%0A%60%60%60xml%0A%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%3F%3E%0A%3Cbeans%20xmlns%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%22%0A%20%20%20%20xmlns%3Axsi%3D%22http%3A%2F%<a href="http://2Fwww.w3.org">2Fwww.w3.org</a>%2F2001%2FXMLSchema-instance%22%20%0A%20%20%20%20xmlns%3Ap%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fp%22%0A%20%20%20%20xmlns%3Aaop%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Faop%22%0A%20%20%20%20xsi%3AschemaLocation%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%2Fspring-beans.xsd%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Faop%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Faop%2Fspring-aop-4.3.xsd%22%3E%0A%20%20%20%20%20%0A%20%20%20%20%3C!–%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%20–%3E%0A%20%20%20%20%3Cbean%20id%3D%22math%22%20class%3D%22com.zhangguo.Spring041.aop08.Math%22%3E%3C%2Fbean%3E%0A%20%20%20%20%3C!–%20%E9%80%9A%E7%9F%A5%20–%3E%0A%20%20%20%20%3Cbean%20id%3D%22advice%22%20class%3D%22com.zhangguo.Spring041.aop08.Advices%22%3E%3C%2Fbean%3E%0A%20%20%20%20%3C!–%20AOP%E9%85%8D%E7%BD%AE%20–%3E%0A%20%20%20%20%3C!–%20proxy-target-class%E5%B1%9E%E6%80%A7%E8%A1%A8%E7%A4%BA%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%B1%BB%E6%98%AF%E5%90%A6%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%EF%BC%8CSpring%E4%BC%9A%E4%BE%9D%E6%8D%AE%E5%AE%9E%E7%8E%B0%E4%BA%86%E6%8E%A5%E5%8F%A3%E5%88%99%E4%BD%BF%E7%94%A8JDK%E5%86%85%E7%BD%AE%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%AA%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%88%99%E4%BD%BF%E7%94%A8cblib%20–%3E%0A%20%20%20%20%3Caop%3Aconfig%20proxy-target-class%3D%22true%22%3E%0A%20%20%20%20%20%20%20%20%3C!–%20%E5%88%87%E9%9D%A2%E9%85%8D%E7%BD%AE%20–%3E%0A%20%20%20%20%20%20%20%20%3C!–ref%E8%A1%A8%E7%A4%BA%E9%80%9A%E7%9F%A5%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%20–%3E%0A%20%20%20%20%20%20%20%20%3Caop%3Aaspect%20ref%3D%22advice%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3C!–%20%E9%85%8D%E7%BD%AE%E5%88%87%E5%85%A5%E7%82%B9(%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%E5%B0%86%E6%B3%A8%E5%85%A5%E7%9A%84%E7%B2%BE%E7%A1%AE%E4%BD%8D%E7%BD%AE)%20–%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Caop%3Apointcut%20expression%3D%22execution(<em>%20com.zhangguo.Spring041.aop08.Math.</em>(…))%22%20id%3D%22pointcut1%22%2F%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3C!–%E5%A3%B0%E6%98%8E%E9%80%9A%E7%9F%A5%EF%BC%8Cmethod%E6%8C%87%E5%AE%9A%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B%EF%BC%8Cpointcut%E6%8C%87%E5%AE%9A%E5%88%87%E7%82%B9%EF%BC%8C%E5%B0%B1%E6%98%AF%E8%AF%A5%E9%80%9A%E7%9F%A5%E5%BA%94%E8%AF%A5%E6%B3%A8%E5%85%A5%E9%82%A3%E4%BA%9B%E6%96%B9%E6%B3%95%E4%B8%AD%20–%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Caop%3Abefore%20method%3D%22before%22%20pointcut-ref%3D%22pointcut1%22%2F%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Caop%3Aafter%20method%3D%22after%22%20pointcut-ref%3D%22pointcut1%22%2F%3E%0A%20%20%20%20%20%20%20%20%3C%2Faop%3Aaspect%3E%0A%20%20%20%20%3C%2Faop%3Aconfig%3E%0A%3C%2Fbeans%3E%0A%60%60%60%0A*%20aop%3Abefore%E7%94%A8%E4%BA%8E%E5%A3%B0%E6%98%8E%E9%80%9A%E7%9F%A5%EF%BC%8Cmethod%E6%8C%87%E5%AE%9A%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B%EF%BC%8Cpointcut%E6%8C%87%E5%AE%9A%E5%88%87%E7%82%B9%EF%BC%8C%E5%B0%B1%E6%98%AF%E8%AF%A5%E9%80%9A%E7%9F%A5%E5%BA%94%E8%AF%A5%E6%B3%A8%E5%85%A5%E9%82%A3%E4%BA%9B%E6%96%B9%E6%B3%95%E4%B8%AD%E3%80%82%E5%9C%A8aop%20Schema%E4%B8%AD%EF%BC%8C%E6%AF%8F%E7%A7%8D%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B%E9%83%BD%E5%AF%B9%E5%BA%94%E4%B8%80%E4%B8%AA%E7%89%B9%E5%AE%9A%E5%9C%B0XML%E5%85%83%E7%B4%A0%E3%80%82%E9%80%9A%E7%9F%A5%E5%85%83%E7%B4%A0%E9%9C%80%E8%A6%81pointcut-ref%E5%B1%9E%E6%80%A7%E6%9D%A5%E5%BC%95%E7%94%A8%E5%88%87%E5%85%A5%E7%82%B9%EF%BC%8C%E6%88%96%E8%80%85%E7%94%A8pointcut%E5%B1%9E%E6%80%A7%E7%9B%B4%E6%8E%A5%E5%B5%8C%E5%85%A5%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%82method%E5%B1%9E%E6%80%A7%E6%8C%87%E5%AE%9A%E5%88%87%E9%9D%A2%E7%B1%BB%E4%B8%AD%E9%80%9A%E7%9F%A5%E6%96%B9%E6%B3%95%E7%9A%84%E5%90%8D%E7%A7%B0%E3%80%82%E6%9C%89%E5%A6%82%E4%B8%8B%E5%87%A0%E7%A7%8D%EF%BC%9A%0A%60%60%60xml%0A%3C!–%20%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%20–%3E%0A%3Caop%3Abefore%20method%3D%22before%22%20pointcut-ref%3D%22pointcut1%22%2F%3E%0A%3C!–%20%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5%20–%3E%0A%3Caop%3Aafter%20method%3D%22after%22%20pointcut-ref%3D%22pointcut1%22%2F%3E%0A%3C!–%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%20–%3E%0A%3Caop%3Aaround%20method%3D%22around%22%20pointcut%3D%22execution(<em>%20com.zhangguo.Spring041.aop08.Math.s</em>(…))%22%2F%3E%0A%3C!–%E5%BC%82%E5%B8%B8%E9%80%9A%E7%9F%A5%20–%3E%0A%3Caop%3Aafter-throwing%20method%3D%22afterThrowing%22%20pointcut%3D%22execution(<em>%20com.zhangguo.Spring041.aop08.Math.d</em>(…))%22%20%20throwing%3D%22exp%22%2F%3E%0A%3C!–%20%E8%BF%94%E5%9B%9E%E5%80%BC%E9%80%9A%E7%9F%A5%20–%3E%0A%3Caop%3Aafter-returning%20method%3D%22afterReturning%22%20pointcut%3D%22execution(<em>%20com.zhangguo.Spring041.aop08.Math.m</em>(…))%22%20returning%3D%22result%22%2F%3E%0A%60%60%60%0A**%E6%B5%8B%E8%AF%95%E8%BF%90%E8%A1%8C**%0A%60%60%60java%0Apackage%20com.zhangguo.Spring052.aop01%3B%0A%0Aimport%20org.springframework.context.ApplicationContext%3B%0Aimport%20org.springframework.context.support.ClassPathXmlApplicationContext%3B%0A%0Apublic%20class%20Test%20%7B%0A%0A%20%20%20%20public%20static%20void%20main(String%5B%5D%20args)%20%7B%0A%20%20%20%20%20%20%20%20ApplicationContext%20ctx%20%3D%20new%20ClassPathXmlApplicationContext(%22aop01.xml%22)%3B%0A%20%20%20%20%20%20%20%20Math%20math%20%3D%20ctx.getBean(%22math%22%2C%20Math.class)%3B%0A%20%20%20%20%20%20%20%20int%20n1%20%3D%20100%2C%20n2%20%3D%205%3B%0A%20%20%20%20%20%20%20%20math.add(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.sub(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.mut(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.div(n1%2C%20n2)%3B%0A%20%20%20%20%7D%0A%0A%7D%0A%60%60%60%0A**%E7%BB%93%E6%9E%9C**%0A!%5Be415ff2a8b4907a06caffe29ca2c164d.png%5D(en-resource%3A%2F%2Fdatabase%2F1013%3A1)%40w%3D200%0A%0A***%0A%20%20%20%20%0A%23%23%23%20AspectJ%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0AOP%0A%23%23%23%23%20%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%0A%23%23%23%23%23%20%E7%BC%96%E5%86%99%E7%9B%AE%E6%A0%87%E7%B1%BB%0A%E7%BC%96%E5%86%99%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%88%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%EF%BC%89%0A*%20UserService%E6%8E%A5%E5%8F%A3%0A*%20UserServiceImpl%E5%AE%9E%E7%8E%B0%E7%B1%BB%0A%0A%3E%20%E9%85%8D%E7%BD%AE%E7%9B%AE%E6%A0%87%E7%B1%BB%EF%BC%8C%E5%B0%86%E7%9B%AE%E6%A0%87%E7%B1%BB%E4%BA%A4%E7%BB%99spring%20IoC%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%0A%0A%0A%23%23%23%23%23%20%E5%BC%80%E5%90%AFAOP%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%90%86%0A*%20%E5%9C%A8spring%E7%9A%84xml%E6%96%87%E4%BB%B6%E4%B8%AD%E5%8A%A0%E5%85%A5%0A%60%60%60xml%0A%3Caop%3Aaspectj-autoproxy%2F%3E%0A%60%60%60%0A%23%23%23%23%23%20%E7%BC%96%E5%86%99Aspect%EF%BC%88%E5%88%87%E9%9D%A2%EF%BC%89%E7%B1%BB%0AAdvice%E9%80%9A%E7%9F%A5%2BPointCut%E5%88%87%E5%85%A5%E7%82%B9%3DAspect%E5%88%87%E9%9D%A2%0A%0A*%20%E5%9C%A8%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8EAspectj%E6%B3%A8%E8%A7%A3%E7%9A%84Spring%20aop%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%8A%8A%40Pointcut%E6%B3%A8%E8%A7%A3%E5%AE%9A%E4%B9%89Pointcut%EF%BC%8C%E6%8C%87%E5%AE%9A%E5%85%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8Pointcut%E8%A1%A8%E8%BE%BE%E6%97%B6%E7%9A%84%E6%97%B6%E5%80%99%E7%9B%B4%E6%8E%A5%E6%8C%87%E5%AE%9APointcut%0A%60%60%60java%0A%2F%2F%E5%88%87%E9%9D%A2%E7%B1%BB%EF%BC%8C%E8%A1%A8%E7%A4%BA%E9%80%9A%E7%9F%A5%E5%8A%A0%E5%88%87%E5%85%A5%E7%82%B9%0A%0A%2F%2F%E9%9C%80%E8%A6%81%E5%B0%86%E5%88%87%E9%9D%A2%E7%B1%BB%E5%B0%86%E7%BB%99spring%20IoC%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%0A%40Component%0A%2F%2F%40Aspect%3A%E6%A0%87%E8%AE%B0%E6%94%B9%E7%B1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%88%87%E9%9D%A2%E7%B1%BB%0A%40Aspect%0Apublic%20class%20MyAspect%20%7B%0A%2F%2F%20%E8%BF%99%E9%87%8C%E7%9A%84%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E5%90%8D%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%AE%9E%E9%99%85%E6%84%8F%E4%B9%89%EF%BC%8C%E7%9B%B8%E5%BD%93%E4%BA%8E%E4%B8%80%E4%B8%AAid%EF%BC%8Cpointcut%E7%A7%8D%E7%9A%84%E5%86%85%E5%AE%B9%E6%98%AF%E8%BF%99%E4%B8%AAid%E6%89%80%E5%8C%B9%E9%85%8D%E7%9A%84%E8%A6%81%E5%88%87%E5%85%A5%E7%9A%84%E9%82%A3%E4%BA%9B%E6%9F%B1%E5%AD%90%EF%BC%8C%E8%A6%81%E5%88%87%E5%85%A5%E6%89%A7%E8%A1%8C%E7%9A%84%E5%86%85%E5%AE%B9%E5%B0%B1%E6%98%AF%E4%B8%8B%E9%9D%A2%E7%9A%84%40before%E6%96%B9%E6%B3%95%EF%BC%8C%40before%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8F%82%E6%95%B0%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B8%AApointcut%E6%B3%A8%E8%A7%A3%E6%96%B9%E6%B3%95%E7%9A%84%E5%90%8D%E5%AD%97%0A%20%20%20%20%40Pointcut(%22execution(<em>%20add(…))%22)%0A%20%20%20%20private%20void%20beforeAdd()%20%7B%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%40Before%E8%A1%A8%E7%A4%BA%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%0A%20%20%20%20%2F%2Fvalue%EF%BC%9A%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%0A%20%20%20%20%40Before(%22execution(</em>%20*…<em>.<em>ServiceImpl.</em>(…))%22)%0A%20%20%20%20public%20void%20before()%20%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22-----------%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5-----------%22)%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%7D%0A%60%60%60%0A%23%23%23%23%23%20%E9%85%8D%E7%BD%AE%E5%88%87%E9%9D%A2%E7%B1%BB%0A%E5%8D%B3%E8%AE%A9%E5%85%B6%E7%BA%B3%E5%85%A5spring%E7%AE%A1%E7%90%86%0A%60%60%60xml%0A%3Ccontext%3Acomponent-scan%20base-package%3D%22com.kkb.spring%22%2F%3E%0A%60%60%60%0A%0A%23%23%23%23%20%E5%85%B6%E4%BB%96%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%0A%60%60%60java%0Aimport%20org.aspectj.lang.JoinPoint%3B%0Aimport%20org.aspectj.lang.ProceedingJoinPoint%3B%0Aimport%20org.aspectj.lang.annotation.After%3B%0Aimport%20org.aspectj.lang.annotation.AfterReturning%3B%0Aimport%20org.aspectj.lang.annotation.AfterThrowing%3B%0Aimport%20org.aspectj.lang.annotation.Around%3B%0Aimport%20org.aspectj.lang.annotation.Aspect%3B%0Aimport%20org.aspectj.lang.annotation.Before%3B%0Aimport%20org.aspectj.lang.annotation.Pointcut%3B%0Aimport%20org.springframework.stereotype.Component%3B%0A%0A%2F**%0A%20</em>%20%E9%80%9A%E7%9F%A5%E7%B1%BB%EF%BC%8C%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%0A%20*%2F%0A%40Component%0A%40Aspect%0Apublic%20class%20Advices%20%7B%0A%20%20%20%20%2F%2F%E5%88%87%E7%82%B9%0A%20%20%20%20%40Pointcut(%22execution(<em>%20com.zhangguo.Spring052.aop04.Math.a</em>(…))%22)%0A%20%20%20%20public%20void%20pointcut()%7B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%0A%20%20%20%20%40Before(%22pointcut()%22)%0A%20%20%20%20public%20void%20before(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(jp.getSignature().getName())%3B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5%0A%20%20%20%20%40After(%22pointcut()%22)%0A%20%20%20%20public%20void%20after(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%0A%20%20%20%20%40Around(%22execution(<em>%20com.zhangguo.Spring052.aop04.Math.s</em>(…))%22)%0A%20%20%20%20public%20Object%20around(ProceedingJoinPoint%20pjp)%20throws%20Throwable%7B%0A%20%20%20%20%20%20%20%20System.out.println(pjp.getSignature().getName())%3B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E7%8E%AF%E7%BB%95%E5%89%8D%E7%BD%AE----------%22)%3B%0A%20%20%20%20%20%20%20%20Object%20result%3Dpjp.proceed()%3B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E7%8E%AF%E7%BB%95%E5%90%8E%E7%BD%AE----------%22)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E9%80%9A%E7%9F%A5%0A%20%20%20%20%40AfterReturning(pointcut%3D%22execution(<em>%20com.zhangguo.Spring052.aop04.Math.m</em>(…))%22%2Creturning%3D%22result%22)%0A%20%20%20%20public%20void%20afterReturning(JoinPoint%20jp%2CObject%20result)%7B%0A%20%20%20%20%20%20%20%20System.out.println(jp.getSignature().getName())%3B%0A%20%20%20%20%20%20%20%20System.out.println(%22%E7%BB%93%E6%9E%9C%E6%98%AF%EF%BC%9A%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C----------%22)%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%E5%BC%82%E5%B8%B8%E5%90%8E%E9%80%9A%E7%9F%A5%0A%20%20%20%20%40AfterThrowing(pointcut%3D%22execution(<em>%20com.zhangguo.Spring052.aop04.Math.d</em>(…))%22%2Cthrowing%3D%22exp%22)%0A%20%20%20%20public%20void%20afterThrowing(JoinPoint%20jp%2CException%20exp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(jp.getSignature().getName())%3B%0A%20%20%20%20%20%20%20%20System.out.println(%22%E5%BC%82%E5%B8%B8%E6%B6%88%E6%81%AF%EF%BC%9A%22%2Bexp.getMessage())%3B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E5%BC%82%E5%B8%B8%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A%23%23%23%23%20%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%EF%BC%88%E7%89%B9%E6%AE%8A%EF%BC%89%0A**%40Around**%0A*%20%E4%BD%9C%E7%94%A8%EF%BC%9A%E6%8A%8A%E5%BD%93%E5%89%8D%E6%96%B9%E6%B3%95%E7%9C%8B%E4%BD%9C%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%0A*%20%E5%B1%9E%E6%80%A7%0A%20%20%20%20*%20value%EF%BC%9A%E7%94%A8%E4%BA%8E%E6%8C%87%E5%AE%9A%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E8%BF%98%E5%8F%AF%E4%BB%A5%E6%8C%87%E5%AE%9A%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%BC%95%E7%94%A8%0A%0A!%5B53eeff2bdceca466fc1fce018e5cbf86.png%5D(en-resource%3A%2F%2Fdatabase%2F1022%3A1)%40w%3D450%0A%0A%23%23%23%23%20%E5%AE%9A%E4%B9%89%E9%80%9A%E7%94%A8%E5%88%87%E5%85%A5%E7%82%B9%0A%E4%BD%BF%E7%94%A8%40PointCut%E6%B3%A8%E8%A7%A3%E5%9C%A8%E5%88%87%E9%9D%A2%E7%B1%BB%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E5%88%87%E5%85%A5%E7%82%B9%EF%BC%8C%E5%85%B6%E4%BB%96%E9%80%9A%E7%9F%A5%E5%8F%AF%E4%BB%A5%E5%BC%95%E7%94%A8%E8%AF%A5%E5%88%87%E5%85%A5%E7%82%B9%0A%0A!%5B8b08a02492b6c0a19f5401cfedcd4f47.png%5D(en-resource%3A%2F%2Fdatabase%2F1023%3A1)%40w%3D400%0A%0A%0A%23%23%23%23%20%E9%9B%B6%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%0A%60%60%60java%0A%2F%2F%E5%A3%B0%E6%98%8E%E6%94%B9%E7%B1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E9%85%8D%E7%BD%AE%E7%B1%BB%0A%40Configuration%0A%2F%2F%E5%B0%86com.kkb%E5%8C%85%E7%BA%B3%E5%85%A5%E6%B3%A8%E8%A7%A3%E6%89%AB%E6%8F%8F%0A%40ComponentScan(basePackages%3D%22com.kkb%22)%0A%2F%2F%E8%BF%99%E4%B8%AA%E5%B0%B1%E7%9B%B8%E5%BD%93%E4%BA%8Exml%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%3Caop%3Aaspectj-autoproxy%2F%3E%20%20AOP%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%90%86%0A%40EnableAspectJAutoProxy%0Apublic%20class%20SpringConfiguration%20%7B%0A%2F%2F%E5%9C%A8%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AAbean%EF%BC%8C%E7%9B%B8%E5%BD%93%E4%BA%8E%3Cbean%20id%3DgetUser%20class%3D%22com.zhangguo.Spring052.aop05.User%22%2F%3E%20%0A%20%20%20%20%40Bean%20%0A%20%20%20%20public%20User%20getUser()%7B%20return%20new%20User()%3B%20%7D%0A%0A%7D%0A%0A%60%60%60%0A%23%23%23%23%20%E5%8E%9F%E7%90%86%0A%0A%E5%85%B6%E5%AE%9EAOP%E7%9A%84%E5%8E%9F%E7%90%86%E9%9D%9E%E5%B8%B8%E7%AE%80%E5%8D%95%E3%80%82%E6%88%91%E4%BB%AC%E4%BB%A5LoggingAspect.doAccessCheck()%E4%B8%BA%E4%BE%8B%EF%BC%8C%E8%A6%81%E6%8A%8A%E5%AE%83%E6%B3%A8%E5%85%A5%E5%88%B0UserService%E7%9A%84%E6%AF%8F%E4%B8%AApublic%E6%96%B9%E6%B3%95%E4%B8%AD%EF%BC%8C%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%AD%90%E7%B1%BB%EF%BC%8C%E5%B9%B6%E6%8C%81%E6%9C%89%E5%8E%9F%E5%A7%8B%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%9A%0A%60%60%60java%0A%0A%40Aspect%40Componentpublic%20class%20LoggingAspect%20%7B%0A%20%20%20%20%2F%2F%20%E5%9C%A8%E6%89%A7%E8%A1%8CUserService%E7%9A%84%E6%AF%8F%E4%B8%AA%E6%96%B9%E6%B3%95%E5%89%8D%E6%89%A7%E8%A1%8C%3A%0A%20%20%20%20%40Before(%22execution(public%20*%20com.itranswarp.learnjava.service.UserService.<em>(…))%22)%0A%20%20%20%20public%20void%20doAccessCheck()%20%7B%0A%20%20%20%20%20%20%20%20System.err.println(%22%5BBefore%5D%20do%20access%20check…%22)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20%E5%9C%A8%E6%89%A7%E8%A1%8CMailService%E7%9A%84%E6%AF%8F%E4%B8%AA%E6%96%B9%E6%B3%95%E5%89%8D%E5%90%8E%E6%89%A7%E8%A1%8C%3A%0A%20%20%20%20%40Around(%22execution(public%20</em>%20com.itranswarp.learnjava.service.MailService.<em>(…))%22)%0A%20%20%20%20public%20Object%20doLogging(ProceedingJoinPoint%20pjp)%20throws%20Throwable%20%7B%0A%20%20%20%20%20%20%20%20System.err.println(%22%5BAround%5D%20start%20%22%20%2B%20pjp.getSignature())%3B%0A%20%20%20%20%20%20%20%20Object%20retVal%20%3D%20pjp.proceed()%3B%0A%20%20%20%20%20%20%20%20System.err.println(%22%5BAround%5D%20done%20%22%20%2B%20pjp.getSignature())%3B%0A%20%20%20%20%20%20%20%20return%20retVal%3B%0A%20%20%20%20%7D%0A%7D%0A%0A%2F%2F%E5%AD%90%E7%B1%BB%0Apublic%20UserServiceAopProxy%20extends%20UserService%20%7B%0A%20%20%20%20private%20UserService%20target%3B%0A%20%20%20%20private%20LoggingAspect%20aspect%3B%0A%0A%20%20%20%20public%20UserServiceAopProxy(UserService%20target%2C%20LoggingAspect%20aspect)%20%7B%0A%20%20%20%20%20%20%20%20this.target%20%3D%20target%3B%0A%20%20%20%20%20%20%20%20this.aspect%20%3D%20aspect%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20public%20User%20login(String%20email%2C%20String%20password)%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20%E5%85%88%E6%89%A7%E8%A1%8CAspect%E7%9A%84%E4%BB%A3%E7%A0%81%3A%0A%20%20%20%20%20%20%20%20aspect.doAccessCheck()%3B%0A%20%20%20%20%20%20%20%20%2F%2F%20%E5%86%8D%E6%89%A7%E8%A1%8CUserService%E7%9A%84%E9%80%BB%E8%BE%91%3A%0A%20%20%20%20%20%20%20%20return%20target.login(email%2C%20password)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20public%20User%20register(String%20email%2C%20String%20password%2C%20String%20name)%20%7B%0A%20%20%20%20%20%20%20%20aspect.doAccessCheck()%3B%0A%20%20%20%20%20%20%20%20return%20target.register(email%2C%20password%2C%20name)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20…%0A%7D%0A%60%60%60%0A%E8%BF%99%E4%BA%9B%E9%83%BD%E6%98%AFSpring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E4%B8%BA%E6%88%91%E4%BB%AC%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B3%A8%E5%85%A5%E4%BA%86Aspect%E7%9A%84%E5%AD%90%E7%B1%BB%EF%BC%8C%E5%AE%83%E5%8F%96%E4%BB%A3%E4%BA%86%E5%8E%9F%E5%A7%8B%E7%9A%84UserService%EF%BC%88%E5%8E%9F%E5%A7%8B%E7%9A%84UserService%E5%AE%9E%E4%BE%8B%E4%BD%9C%E4%B8%BA%E5%86%85%E9%83%A8%E5%8F%98%E9%87%8F%E9%9A%90%E8%97%8F%E5%9C%A8UserServiceAopProxy%E4%B8%AD%EF%BC%89%E3%80%82%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E6%89%93%E5%8D%B0%E4%BB%8ESpring%E5%AE%B9%E5%99%A8%E8%8E%B7%E5%8F%96%E7%9A%84UserService%E5%AE%9E%E4%BE%8B%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%AE%83%E7%B1%BB%E4%BC%BCUserService%24%24EnhancerBySpringCGLIB%24%241f44e01c%EF%BC%8C%E5%AE%9E%E9%99%85%E4%B8%8A%E6%98%AFSpring%E4%BD%BF%E7%94%A8CGLIB%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AD%90%E7%B1%BB%EF%BC%8C%E4%BD%86%E5%AF%B9%E4%BA%8E%E8%B0%83%E7%94%A8%E6%96%B9%E6%9D%A5%E8%AF%B4%EF%BC%8C%E6%84%9F%E8%A7%89%E4%B8%8D%E5%88%B0%E4%BB%BB%E4%BD%95%E5%8C%BA%E5%88%AB%E3%80%82%0A%0A%3ESpring%E5%AF%B9%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%8C%E5%AF%B9%E6%99%AE%E9%80%9A%E7%B1%BB%E4%BD%BF%E7%94%A8CGLIB%E5%88%9B%E5%BB%BA%E5%AD%90%E7%B1%BB%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AABean%E7%9A%84class%E6%98%AFfinal%EF%BC%8CSpring%E5%B0%86%E6%97%A0%E6%B3%95%E4%B8%BA%E5%85%B6%E5%88%9B%E5%BB%BA%E5%AD%90%E7%B1%BB%E3%80%82%0A%0A%E5%8F%AF%E8%A7%81%EF%BC%8C%E8%99%BD%E7%84%B6Spring%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0AOP%E7%9A%84%E9%80%BB%E8%BE%91%E6%AF%94%E8%BE%83%E5%A4%8D%E6%9D%82%EF%BC%88%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8AspectJ%E8%A7%A3%E6%9E%90%E6%B3%A8%E8%A7%A3%EF%BC%8C%E5%B9%B6%E9%80%9A%E8%BF%87CGLIB%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E7%B1%BB%EF%BC%89%EF%BC%8C%E4%BD%86%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8AOP%E9%9D%9E%E5%B8%B8%E7%AE%80%E5%8D%95%EF%BC%8C%E4%B8%80%E5%85%B1%E9%9C%80%E8%A6%81%E4%B8%89%E6%AD%A5%EF%BC%9A%0A</em>%20%E5%AE%9A%E4%B9%89%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95%EF%BC%8C%E5%B9%B6%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%8A%E9%80%9A%E8%BF%87AspectJ%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%91%8A%E8%AF%89Spring%E5%BA%94%E8%AF%A5%E5%9C%A8%E4%BD%95%E5%A4%84%E8%B0%83%E7%94%A8%E6%AD%A4%E6%96%B9%E6%B3%95%EF%BC%9B%0A*%20%E6%A0%87%E8%AE%B0%40Component%E5%92%8C%40Aspect%EF%BC%9B%0A*%20%E5%9C%A8%40Configuration%E7%B1%BB%E4%B8%8A%E6%A0%87%E6%B3%A8%40EnableAspectJAutoProxy%E3%80%82%0A%0A%23%23%23%23%20%E6%A1%88%E4%BE%8B%3A%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AEAOP%0A*%20%E5%9C%A8%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B%E4%B8%AD%E4%BF%AE%E6%94%B9%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%B1%BBMath%2C%E4%B8%BA%E4%BA%86%E5%AE%9E%E7%8E%B0IOC%E6%89%AB%E6%8F%8F%E5%9C%A8Math%E7%B1%BB%E4%B8%8A%E6%B3%A8%E8%A7%A3%E4%BA%86%40Service%E5%B9%B6%E5%91%BD%E5%90%8Dbean%E4%B8%BAmath%E3%80%82%E7%9B%B8%E5%BD%93%E4%BA%8E%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B%E4%B8%AD%E5%9C%A8xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%BA%86%E4%B8%80%E4%B8%AAbean%EF%BC%8C%3C!–%20%E8%A2%AB%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%20–%3E%3Cbean%20id%3D%22math%22%20class%3D%22com.zhangguo.Spring052.aop01.Math%22%3E%3C%2Fbean%3E%EF%BC%8CMath%E7%B1%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A%0A%60%60%60java%0Apackage%20com.zhangguo.Spring052.aop02%3B%0A%0Aimport%20org.springframework.stereotype.Service%3B%0A%0A%2F**%0A%20*%20%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E7%B1%BB%0A%20*%2F%0A%40Service(%22math%22)%0Apublic%20class%20Math%7B%0A%20%20%20%20%2F%2F%E5%8A%A0%0A%20%20%20%20public%20int%20add(int%20n1%2Cint%20n2)%7B%0A%20%20%20%20%20%20%20%20int%20result%3Dn1%2Bn2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22%2B%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%E5%87%8F%0A%20%20%20%20public%20int%20sub(int%20n1%2Cint%20n2)%7B%0A%20%20%20%20%20%20%20%20int%20result%3Dn1-n2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22-%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%E4%B9%98%0A%20%20%20%20public%20int%20mut(int%20n1%2Cint%20n2)%7B%0A%20%20%20%20%20%20%20%20int%20result%3Dn1<em>n2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22X%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%E9%99%A4%0A%20%20%20%20public%20int%20div(int%20n1%2Cint%20n2)%7B%0A%20%20%20%20%20%20%20%20int%20result%3Dn1%2Fn2%3B%0A%20%20%20%20%20%20%20%20System.out.println(n1%2B%22%2F%22%2Bn2%2B%22%3D%22%2Bresult)%3B%0A%20%20%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A</em>%20%E4%BF%AE%E6%94%B9%E9%80%9A%E7%9F%A5%E7%B1%BBAdvices%EF%BC%8C%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%9C%893%E4%B8%AA%E6%B3%A8%E8%A7%A3%EF%BC%8C%40Component%E8%A1%A8%E7%A4%BA%E8%AF%A5%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%BC%9A%E8%A2%ABSpring%20IOC%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%EF%BC%9B%40Aspect%E8%A1%A8%E7%A4%BA%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E5%88%87%E9%9D%A2%EF%BC%9B%40Before%E8%A1%A8%E7%A4%BAbefore%E4%B8%BA%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%EF%BC%8C%E9%80%9A%E8%BF%87%E5%8F%82%E6%95%B0execution%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E5%88%87%E7%82%B9%EF%BC%8CAdvices.java%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA%EF%BC%9A%0A%3E%20%E8%BF%99%E4%B8%AAJava%E7%B1%BB%E5%B0%B1%E7%9B%B8%E5%BD%93%E4%BA%8E%60%E4%BD%BF%E7%94%A8XML%E9%85%8D%E7%BD%AESpring%20MVC%E6%97%B6%E5%80%99%E7%9A%84%3Caop%3Aconfig%3E%60%20%E7%9A%84%E9%85%8D%E7%BD%AE%0A%60%60%60java%0Apackage%20com.zhangguo.Spring052.aop02%3B%0A%0Aimport%20org.aspectj.lang.JoinPoint%3B%0Aimport%20org.aspectj.lang.annotation.After%3B%0Aimport%20org.aspectj.lang.annotation.Aspect%3B%0Aimport%20org.aspectj.lang.annotation.Before%3B%0Aimport%20org.springframework.stereotype.Component%3B%0A%0A%2F**%0A%20*%20%E9%80%9A%E7%9F%A5%E7%B1%BB%EF%BC%8C%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%0A%20*%0A%20*%2F%0A%40Component%0A%40Aspect%0Apublic%20class%20Advices%20%7B%0A%20%20%20%20%40Before(%22execution(<em>%20com.zhangguo.Spring052.aop02.Math.</em>(…))%22)%0A%20%20%20%20public%20void%20before(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%20%20%20%20System.out.println(jp.getSignature().getName())%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%40After(%22execution(<em>%20com.zhangguo.Spring052.aop02.Math.</em>(…))%22)%0A%20%20%20%20public%20void%20after(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A*%20%E4%B8%8A%E9%9D%A2Java%E7%B1%BB%E7%AD%89%E5%90%8C%E4%BA%8E%E4%B8%8B%E9%9D%A2%E7%9A%84xml%0A%60%60%60xml%0A%3C!–%20%E9%80%9A%E7%9F%A5%20–%3E%0A%20%20%20%20%3Cbean%20id%3D%22advices%22%20class%3D%22com.zhangguo.Spring052.aop01.Advices%22%3E%3C%2Fbean%3E%0A%20%20%20%20%0A%20%20%20%20%3C!–%20aop%E9%85%8D%E7%BD%AE%20–%3E%0A%20%20%20%20%3Caop%3Aconfig%20proxy-target-class%3D%22true%22%3E%0A%20%20%20%20%20%20%20%20%3C!–%E5%88%87%E9%9D%A2%20–%3E%0A%20%20%20%20%20%20%20%20%3Caop%3Aaspect%20ref%3D%22advices%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3C!–%20%E5%88%87%E7%82%B9%20–%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Caop%3Apointcut%20expression%3D%22execution(<em>%20com.zhangguo.Spring052.aop01.Math.</em>(…))%22%20id%3D%22pointcut1%22%2F%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3C!–%E8%BF%9E%E6%8E%A5%E9%80%9A%E7%9F%A5%E6%96%B9%E6%B3%95%E4%B8%8E%E5%88%87%E7%82%B9%20–%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Caop%3Abefore%20method%3D%22before%22%20pointcut-ref%3D%22pointcut1%22%2F%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Caop%3Aafter%20method%3D%22after%22%20pointcut-ref%3D%22pointcut1%22%2F%3E%0A%20%20%20%20%20%20%20%20%3C%2Faop%3Aaspect%3E%0A%20%20%20%20%3C%2Faop%3Aconfig%3E%0A%60%60%60%0A*%20Spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%0A%20%20%20%20*%20%E6%96%B0%E5%A2%9E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6aop02.xml%EF%BC%8C%E5%9C%A8%E9%85%8D%E7%BD%AEIOC%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%E5%A2%9E%E5%8A%A0%E4%BA%86aop%3Aaspectj-autoproxy%E8%8A%82%E7%82%B9%EF%BC%8CSpring%E6%A1%86%E6%9E%B6%E4%BC%9A%E8%87%AA%E5%8A%A8%E4%B8%BA%E4%B8%8EAspectJ%E5%88%87%E9%9D%A2%E9%85%8D%E7%BD%AE%E7%9A%84Bean%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%EF%BC%8Cproxy-target-class%3D%22true%22%E5%B1%9E%E6%80%A7%E8%A1%A8%E7%A4%BA%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%80%E4%B8%AA%E7%B1%BB%EF%BC%8C%E8%80%8C%E9%9D%9E%E5%AE%9E%E7%8E%B0%E4%BA%86%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E4%B8%BA%E4%BA%86%E9%80%89%E6%8B%A9%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%0A%60%60%60xml%0A%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%3F%3E%0A%3Cbeans%20xmlns%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%22%0A%20%20%20%20xmlns%3Axsi%3D%22http%3A%2F%<a href="http://2Fwww.w3.org">2Fwww.w3.org</a>%2F2001%2FXMLSchema-instance%22%20%0A%20%20%20%20xmlns%3Ap%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fp%22%0A%20%20%20%20xmlns%3Aaop%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Faop%22%0A%20%20%20%20xmlns%3Acontext%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fcontext%22%0A%20%20%20%20xsi%3AschemaLocation%3D%22http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fbeans%2Fspring-beans.xsd%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fcontext%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Fcontext%2Fspring-context-4.3.xsd%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Faop%0A%20%20%20%20%20%20%20%20http%3A%2F%<a href="http://2Fwww.springframework.org">2Fwww.springframework.org</a>%2Fschema%2Faop%2Fspring-aop-4.3.xsd%22%3E%0A%20%20%20%20%20%20%20%20%3Ccontext%3Acomponent-scan%20base-package%3D%22com.zhangguo.Spring052.aop02%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Caop%3Aaspectj-autoproxy%20proxy-target-class%3D%22true%22%3E%3C%2Faop%3Aaspectj-autoproxy%3E%0A%3C%2Fbeans%3E%0A%60%60%60%0A%23%23%23%23%20AspectJ%E5%88%87%E7%82%B9%E5%87%BD%E6%95%B0%0A%23%23%23%23%23%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%0A*%20%40AspectJ%E4%BD%BF%E7%94%A8AspectJ%E4%B8%93%E9%97%A8%E7%9A%84%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8F%8F%E8%BF%B0%E5%88%87%E9%9D%A2%EF%BC%8CSpring%E6%89%80%E6%94%AF%E6%8C%81%E7%9A%84AspectJ%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%AF%E5%88%86%E4%B8%BA%E5%9B%9B%E7%B1%BB%3A%0A%20%20%20%20*%20%E6%96%B9%E6%B3%95%E5%88%87%E7%82%B9%E5%87%BD%E6%95%B0%EF%BC%9A%E9%80%9A%E8%BF%87%E6%8F%8F%E8%BF%B0%E7%9B%AE%E6%A0%87%E7%B1%BB%E6%96%B9%E6%B3%95%E4%BF%A1%E6%81%AF%E5%AE%9A%E4%B9%89%E8%BF%9E%E6%8E%A5%E7%82%B9%E3%80%82%0A%20%20%20%20*%20%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%88%87%E7%82%B9%E5%87%BD%E6%95%B0%EF%BC%9A%E9%80%9A%E8%BF%87%E6%8F%8F%E8%BF%B0%E7%9B%AE%E6%A0%87%E7%B1%BB%E6%96%B9%E6%B3%95%E5%85%A5%E5%8F%82%E4%BF%A1%E6%81%AF%E5%AE%9A%E4%B9%89%E8%BF%9E%E6%8E%A5%E7%82%B9%E3%80%82%0A%20%20%20%20*%20%E7%9B%AE%E6%A0%87%E7%B1%BB%E5%88%87%E7%82%B9%E5%87%BD%E6%95%B0%EF%BC%9A%E9%80%9A%E8%BF%87%E6%8F%8F%E8%BF%B0%E7%9B%AE%E6%A0%87%E7%B1%BB%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%E5%AE%9A%E4%B9%89%E8%BF%9E%E6%8E%A5%E7%82%B9%E3%80%82%0A%20%20%20%20*%20%E4%BB%A3%E7%90%86%E7%B1%BB%E5%88%87%E7%82%B9%E5%87%BD%E6%95%B0%EF%BC%9A%E9%80%9A%E8%BF%87%E6%8F%8F%E8%BF%B0%E4%BB%A3%E7%90%86%E7%B1%BB%E4%BF%A1%E6%81%AF%E5%AE%9A%E4%B9%89%E8%BF%9E%E6%8E%A5%E7%82%B9%E3%80%82%0A*%20%E6%A0%87%E5%87%86%E7%9A%84Aspectj%20Aop%E7%9A%84pointcut%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E5%BE%88%E4%B8%B0%E5%AF%8C%EF%BC%8C%E4%BD%86%E6%98%AFspring%20AOP%E5%8F%AA%E6%94%AF%E6%8C%819%E7%A7%8D%EF%BC%8C%E5%8F%A6%E5%A4%96%E5%8A%A0Spring%20Aop%E8%87%AA%E5%B7%B1%E6%89%A9%E5%85%85%E7%9A%84%E4%B8%80%E7%A7%8D%EF%BC%8C%E4%B8%80%E5%85%B1%E6%98%AF10%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E5%88%86%E5%88%AB%E5%A6%82%E4%B8%8B%0A%20%20%20%20*%20execution%EF%BC%9A%E6%BB%A1%E8%B6%B3%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%AE%E6%A0%87%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%82%B9%0A%20%20%20%20*%20within%EF%BC%9A%E6%8C%87%E5%AE%9A%E6%9F%90%E4%BA%9B%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%A8%E9%83%A8%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%EF%BC%8C%E4%B9%9F%E5%8F%AF%E7%94%A8%E6%9D%A5%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%8C%85%E3%80%82%0A%20%20%20%20*%20this%EF%BC%9ASpring%20Aop%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%90%86%E7%9A%84%EF%BC%8C%E7%94%9F%E6%88%90%E7%9A%84bean%E4%B9%9F%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%EF%BC%8Cthis%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B8%AA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%BD%93%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%8C%87%E5%AE%9A%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%97%B6%EF%BC%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E5%88%87%E5%85%A5%E7%82%B9%E5%B0%B1%E6%98%AF%E5%AE%83%E4%BA%86%EF%BC%8CSpring%20Aop%E5%B0%86%E7%94%9F%E6%95%88%E3%80%82%0A%20%20%20%20*%20target%EF%BC%9A%E5%BD%93%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%8C%87%E5%AE%9A%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%97%B6%EF%BC%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E5%88%87%E5%85%A5%E7%82%B9%E5%B0%B1%E6%98%AF%E5%AE%83%E4%BA%86%EF%BC%8CSpring%20Aop%E5%B0%86%E7%94%9F%E6%95%88%E3%80%82%0A%20%20%20%20*%20args%EF%BC%9A%E5%BD%93%E6%89%A7%E8%A1%8C%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E6%97%B6%E7%94%9F%E6%95%88%E3%80%82%0A%20%20%20%20*%20%40target%EF%BC%9A%E5%BD%93%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E4%B8%8A%E6%8B%A5%E6%9C%89%E6%8C%87%E5%AE%9A%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%97%B6%E7%94%9F%E6%95%88%E3%80%82%0A%20%20%20%20*%20%40args%EF%BC%9A%E5%BD%93%E6%89%A7%E8%A1%8C%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%B8%8A%E6%8B%A5%E6%9C%89%E6%8C%87%E5%AE%9A%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%97%B6%E7%94%9F%E6%95%88%E3%80%82%0A%20%20%20%20*%20%40within%EF%BC%9A%E4%B8%8E%40target%E7%B1%BB%E4%BC%BC%EF%BC%8C%E7%9C%8B%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%92%8C%E7%BD%91%E4%B8%8A%E7%9A%84%E8%AF%B4%E6%B3%95%E9%83%BD%E6%98%AF%40within%E5%8F%AA%E9%9C%80%E8%A6%81%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E6%88%96%E8%80%85%E7%88%B6%E7%B1%BB%E4%B8%8A%E6%9C%89%E6%8C%87%E5%AE%9A%E7%9A%84%E6%B3%A8%E8%A7%A3%EF%BC%8C%E5%88%99%40within%E4%BC%9A%E7%94%9F%E6%95%88%EF%BC%8C%E8%80%8C%40target%E5%88%99%E6%98%AF%E5%BF%85%E9%A1%BB%E6%98%AF%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E4%B8%8A%E6%9C%89%E6%8C%87%E5%AE%9A%E7%9A%84%E6%B3%A8%E8%A7%A3%E3%80%82%E8%80%8C%E6%A0%B9%E6%8D%AE%E7%AC%94%E8%80%85%E7%9A%84%E6%B5%8B%E8%AF%95%E8%BF%99%E4%B8%A4%E8%80%85%E9%83%BD%E6%98%AF%E5%8F%AA%E8%A6%81%E7%9B%AE%E6%A0%87%E7%B1%BB%E6%88%96%E7%88%B6%E7%B1%BB%E4%B8%8A%E6%9C%89%E6%8C%87%E5%AE%9A%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%8D%B3%E5%8F%AF%E3%80%82%0A%20%20%20%20*%20%40annotation%EF%BC%9A%E5%BD%93%E6%89%A7%E8%A1%8C%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8A%E6%8B%A5%E6%9C%89%E6%8C%87%E5%AE%9A%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%97%B6%E7%94%9F%E6%95%88%E3%80%82%0A%20%20%20%20*%20bean%EF%BC%9A%E5%BD%93%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E6%8C%87%E5%AE%9A%E7%9A%84bean%E7%9A%84%E6%96%B9%E6%B3%95%E6%97%B6%E7%94%9F%E6%95%88%E3%80%82%0A%23%23%23%23%23%20%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%EF%BC%8C%E6%A1%88%E4%BE%8B%0A*%20%E6%96%B0%E5%A2%9E%E4%B8%80%E4%B8%AA%E7%B1%BBStrUtil%0A%60%60%60java%0Apackage%20com.zhangguo.Spring052.aop03%3B%0A%0Aimport%20org.springframework.stereotype.Component%3B%0A%0A%40Component(%22strUtil%22)%0Apublic%20class%20StrUtil%20%7B%0A%20%20%20%20public%20void%20show()%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22Hello%20StrUtil!%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%0A%60%60%60%0A*%20%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%0A%60%60%60java%0Apackage%20com.zhangguo.Spring052.aop03%3B%0A%0Aimport%20org.springframework.context.ApplicationContext%3B%0Aimport%20org.springframework.context.support.ClassPathXmlApplicationContext%3B%0A%0Apublic%20class%20Test%20%7B%0A%0A%20%20%20%20public%20static%20void%20main(String%5B%5D%20args)%20%7B%0A%20%20%20%20%20%20%20%20ApplicationContext%20ctx%20%3D%20new%20ClassPathXmlApplicationContext(%22aop03.xml%22)%3B%0A%20%20%20%20%20%20%20%20IMath%20math%20%3D%20ctx.getBean(%22math%22%2C%20Math.class)%3B%0A%20%20%20%20%20%20%20%20int%20n1%20%3D%20100%2C%20n2%20%3D%205%3B%0A%20%20%20%20%20%20%20%20math.add(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.sub(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.mut(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20math.div(n1%2C%20n2)%3B%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20StrUtil%20strUtil%3Dctx.getBean(%22strUtil%22%2CStrUtil.class)%3B%0A%20%20%20%20%20%20%20%20strUtil.show()%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A%0A*%20<strong>execution</strong>%0A%20%20%20%20*%20execution%E6%98%AF%E4%BD%BF%E7%94%A8%E7%9A%84%E6%9C%80%E5%A4%9A%E7%9A%84%E4%B8%80%E7%A7%8DPointcut%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E8%A1%A8%E7%A4%BA%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%0A%60%60%60%0Aexecution(modifiers-pattern%3F%20ret-type-pattern%20declaring-type-pattern%3F%20name-pattern(param-pattern)%20throws-pattern%3F)%0A%60%60%60%0A1.%20modifiers-pattern%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%9E%8B%EF%BC%8Cpublic%E7%AD%89%EF%BC%9B%0A2.%20ret-type-pattern%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%A6%82String%E8%A1%A8%E7%A4%BA%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E6%98%AFString%EF%BC%8C%E2%80%9C%5C*%E2%80%9D%E8%A1%A8%E7%A4%BA%E6%89%80%E6%9C%89%E7%9A%84%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%EF%BC%9B%0A3.%20declaring-type-pattern%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%E7%9A%84%E5%A3%B0%E6%98%8E%E7%B1%BB%EF%BC%8C%E5%A6%82%E2%80%9Ccom.elim…%5C*%E2%80%9D%E8%A1%A8%E7%A4%BAcom.elim%E5%8C%85%E5%8F%8A%E5%85%B6%E5%AD%90%E5%8C%85%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%89%80%E6%9C%89%E7%B1%BB%E5%9E%8B%EF%BC%9B%0A4.%20name-pattern%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%E7%9A%84%E5%90%8D%E7%A7%B0%EF%BC%8C%E5%A6%82%E2%80%9Cadd%5C*%E2%80%9D%E8%A1%A8%E7%A4%BA%E6%89%80%E6%9C%89%E4%BB%A5add%E5%BC%80%E5%A4%B4%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%8D%EF%BC%9B%0A5.%20param-pattern%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%8Cname-pattern(param-pattern)%E5%85%B6%E5%AE%9E%E6%98%AF%E4%B8%80%E8%B5%B7%E7%9A%84%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%96%B9%E6%B3%95%E9%9B%86%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%A6%82%E2%80%9Cadd()%E2%80%9D%E8%A1%A8%E7%A4%BA%E4%B8%8D%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84add%E6%96%B9%E6%B3%95%EF%BC%8C%E2%80%9Cadd(%5C*)%E2%80%9D%E8%A1%A8%E7%A4%BA%E5%B8%A6%E4%B8%80%E4%B8%AA%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%E7%9A%84add%E6%96%B9%E6%B3%95%EF%BC%8C%E2%80%9Cadd(%5C*%2CString)%E2%80%9D%E5%88%99%E8%A1%A8%E7%A4%BA%E5%B8%A6%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E4%B8%94%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%E6%98%AFString%E7%B1%BB%E5%9E%8B%E7%9A%84add%E6%96%B9%E6%B3%95%EF%BC%9B%0A6.%20throws-pattern%E8%A1%A8%E7%A4%BA%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%EF%BC%9B%E5%85%B6%E4%B8%AD%E4%BB%A5%E9%97%AE%E5%8F%B7%E7%BB%93%E6%9D%9F%E7%9A%84%E9%83%A8%E5%88%86%E9%83%BD%E6%98%AF%E5%8F%AF%E4%BB%A5%E7%9C%81%E7%95%A5%E7%9A%84%E3%80%82%0A%20%20%20%201.%20%E2%80%9Cexecution(<em>%20add())%E2%80%9D%E5%8C%B9%E9%85%8D%E6%89%80%E6%9C%89%E7%9A%84%E4%B8%8D%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84add()%E6%96%B9%E6%B3%95%E3%80%82%0A%20%20%20%202.%20%E2%80%9Cexecution(public%20</em>%20com…%5C*.add*(…))%E2%80%9D%E5%8C%B9%E9%85%8D%E6%89%80%E6%9C%89com%E5%8C%85%E5%8F%8A%E5%85%B6%E5%AD%90%E5%8C%85%E4%B8%8B%E6%89%80%E6%9C%89%E7%B1%BB%E7%9A%84%E4%BB%A5add%E5%BC%80%E5%A4%B4%E7%9A%84%E6%89%80%E6%9C%89public%E6%96%B9%E6%B3%95%E3%80%82%0A%20%20%20%203.%20%E2%80%9Cexecution(<em>%20%5C</em>(…)%20throws%20Exception)%E2%80%9D%E5%8C%B9%E9%85%8D%E6%89%80%E6%9C%89%E6%8A%9B%E5%87%BAException%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82%0A%60%60%60java%0A%0A%40Component%0A%40Aspect%0Apublic%20class%20Advices%20%7B%0A%20%20%20%20%40Before(%22execution(<em>%20com.zhangguo.Spring052.aop03.Math.</em>(…))%22)%0A%20%20%20%20public%20void%20before(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%20%20%20%20System.out.println(jp.getSignature().getName())%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2Fexecution%E5%88%87%E7%82%B9%E5%87%BD%E6%95%B0%0A%20%20%20%20%2F%2Fcom.zhangguo.Spring052.aop03%E5%8C%85%E4%B8%8B%E6%89%80%E6%9C%89%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E8%A2%AB%E5%88%87%E5%85%A5%0A%20%20%20%20%40After(%22execution(<em>%20com.zhangguo.Spring052.aop03.</em>.<em>(…))%22)%0A%20%20%20%20public%20void%20after(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A!%5B41399f848259aa40b4120ab23785623e.png%5D(en-resource%3A%2F%2Fdatabase%2F1007%3A2)%0A%0A</em>%20<strong>within</strong>%0A%20%20%20%20*%20%20%20within%E6%98%AF%E7%94%A8%E6%9D%A5%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E7%A7%8D%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E5%B0%86%E8%A2%AB%E6%8B%A6%E6%88%AA%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%201.%20%E2%80%9Cwithin(com.spring.aop.service.UserServiceImpl)%E2%80%9D%E5%8C%B9%E9%85%8DUserServiceImpl%E7%B1%BB%E5%AF%B9%E5%BA%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%EF%BC%8C%E8%80%8C%E4%B8%94%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%8F%AA%E8%83%BD%E6%98%AFUserServiceImpl%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%B8%8D%E8%83%BD%E6%98%AF%E5%85%B6%E5%AD%90%E7%B1%BB%E5%9E%8B%0A%20%20%20%20%20%20%20%202.%20%E2%80%9Cwithin(com.elim…<em>)%E2%80%9D%E5%8C%B9%E9%85%8Dcom.elim%E5%8C%85%E5%8F%8A%E5%85%B6%E5%AD%90%E5%8C%85%E4%B8%8B%E9%9D%A2%E6%89%80%E6%9C%89%E7%9A%84%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E3%80%82%0A%60%60%60java%0A%2F%2Fwithin%E5%88%87%E7%82%B9%E5%87%BD%E6%95%B0%0A%20%20%20%20%2F%2Fcom.zhangguo.Spring052.aop03%E5%8C%85%E4%B8%8B%E6%89%80%E6%9C%89%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E8%A2%AB%E5%88%87%E5%85%A5%0A%20%20%20%20%40After(%22within(com.zhangguo.Spring052.aop03.</em>)%22)%0A%20%20%20%20public%20void%20after(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%7D%0A%60%60%60%0A!%5B41399f848259aa40b4120ab23785623e.png%5D(en-resource%3A%2F%2Fdatabase%2F1007%3A2)%0A%0A*%20<strong>this</strong>%0A%20%20%20%20*%20Spring%20Aop%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%90%86%E7%9A%84%EF%BC%8Cthis%E5%B0%B1%E8%A1%A8%E7%A4%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E3%80%82this%E7%B1%BB%E5%9E%8B%E7%9A%84Pointcut%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95%E6%98%AFthis(type)%EF%BC%8C%E5%BD%93%E7%94%9F%E6%88%90%E7%9A%84%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%BD%AC%E6%8D%A2%E4%B8%BAtype%E6%8C%87%E5%AE%9A%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%97%B6%E5%88%99%E8%A1%A8%E7%A4%BA%E5%8C%B9%E9%85%8D%E3%80%82%E5%9F%BA%E4%BA%8EJDK%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BB%A3%E7%90%86%E5%92%8C%E5%9F%BA%E4%BA%8ECGLIB%E7%9A%84%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%0A%20%20%20%20%20%20%20%201.%20%E2%80%9Cthis(com.spring.aop.service.IUserService)%E2%80%9D%E5%8C%B9%E9%85%8D%E7%94%9F%E6%88%90%E7%9A%84%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E6%98%AFIUserService%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%0A%60%60%60java%0A%2F%2Fthis%E5%88%87%E7%82%B9%E5%87%BD%E6%95%B0%0A%20%20%20%20%2F%2F%E5%AE%9E%E7%8E%B0%E4%BA%86IMath%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BB%BB%E6%84%8F%E8%BF%9E%E6%8E%A5%E7%82%B9%0A%20%20%20%20%40After(%22this(com.zhangguo.Spring052.aop03.IMath)%22)%0A%20%20%20%20public%20void%20after(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%7D%0A%60%60%60%0A!%5B91c5dd274415195d349d174a80bebe5a.png%5D(en-resource%3A%2F%2Fdatabase%2F1011%3A1)%0A%0A%0A*%20<strong>target</strong>%0A%20%20%20%20*%20Spring%20aop%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%90%86%E7%9A%84%EF%BC%8Ctarget%E5%88%99%E8%A1%A8%E7%A4%BA%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E5%B8%83%E6%A0%87%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%BD%93%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%8C%87%E5%AE%9A%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%97%B6%E5%88%99%E8%A1%A8%E7%A4%BA%E5%8C%B9%E9%85%8D%0A%20%20%20%20%20%20%20%201.%20%E2%80%9Ctarget(com.spring.aop.service.IUserService)%E2%80%9D%E5%88%99%E5%8C%B9%E9%85%8D%E6%89%80%E6%9C%89%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E8%83%BD%E5%A4%9F%E8%BD%AC%E6%8D%A2%E4%B8%BAIUserService%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%0A%0A*%20<strong>args</strong>%0A%20%20%20%20*%20arge%E7%94%A8%E6%9D%A5%E5%8C%B9%E9%85%8D%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%0A%20%20%20%20%20%20%20%201.%20%E2%80%9Cargs()%E2%80%9D%E5%8C%B9%E9%85%8D%E4%BB%BB%E4%BD%95%E4%B8%8D%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82%0A%20%20%20%20%20%20%20%202.%20%E2%80%9Cargs(java.lang.String)%E2%80%9D%E5%8C%B9%E9%85%8D%E4%BB%BB%E4%BD%95%E5%8F%AA%E5%B8%A6%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E8%80%8C%E4%B8%94%E8%BF%99%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AFString%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82%0A%20%20%20%20%20%20%20%203.%20%E2%80%9Cargs(…)%E2%80%9D%E5%B8%A6%E4%BB%BB%E6%84%8F%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82%0A%20%20%20%20%20%20%20%204.%20%E2%80%9Cargs(java.lang.String%2C…)%E2%80%9D%E5%8C%B9%E9%85%8D%E5%B8%A6%E4%BB%BB%E6%84%8F%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E4%BD%86%E6%98%AF%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AFString%E7%9A%84%E6%96%B9%E6%B3%95%0A%20%20%20%20%20%20%20%205.%20%E2%80%9Cargs(…%2Cjava.lang.String)%E2%80%9D%E5%8C%B9%E9%85%8D%E5%B8%A6%E4%BB%BB%E6%84%8F%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AFString%E7%9A%84%E6%96%B9%E6%B3%95%0A%0A%60%60%60java%0A%2F%2Fargs%E5%88%87%E7%82%B9%E5%87%BD%E6%95%B0%0A%20%20%20%20%2F%2F%E8%A6%81%E6%B1%82%E6%96%B9%E6%B3%95%E6%9C%89%E4%B8%A4%E4%B8%AAint%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E8%80%83%E6%89%8D%E4%BC%9A%E8%A2%AB%E7%BB%87%E5%85%A5%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%0A%20%20%20%20%40After(%22args(int%2Cint)%22)%0A%20%20%20%20public%20void%20after(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%7D%0A%60%60%60%0A!%5Bd3cad0fd1024c7f80ea8d574ffc4e30a.png%5D(en-resource%3A%2F%2Fdatabase%2F1012%3A1)%0A%0A*%20**%40target**%0A%20%20%20%20*%20%40target%E5%8C%B9%E9%85%8D%E5%BD%93%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%AF%B9%E5%BA%94%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E7%88%B6%E7%B1%BB%E5%9E%8B%E4%B8%8A%E6%8B%A5%E6%9C%89%E6%8C%87%E5%AE%9A%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%97%B6%0A%20%20%20%20%20%20%20%201.%20%E2%80%9C%40target(com.spring.support.MyAnnotation)%E2%80%9D%E5%8C%B9%E9%85%8D%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%AF%B9%E5%BA%94%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%8A%E6%8B%A5%E6%9C%89MyAnnotation%E6%B3%A8%E8%A7%A3%E6%97%B6%0A%0A*%20**%40args**%0A%20%20%20%20*%20%40args%E5%8C%B9%E9%85%8D%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8A%E5%90%AB%E6%9C%89%E5%8F%82%E6%95%B0%EF%BC%8C%E4%B8%94%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%B8%8A%E6%8B%A5%E6%9C%89%E6%8C%87%E5%AE%9A%E7%9A%84%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%83%85%E5%86%B5%0A%20%20%20%20%20%20%20%201.%20%E2%80%9C%40args(com.spring.support.MyAnnotation)%E2%80%9D%E5%8C%B9%E9%85%8D%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%B8%8A%E6%8B%A5%E6%9C%89MyAnnotation%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E3%80%82%E5%A6%82%E6%88%91%E4%BB%AC%E6%9C%89%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95add(MyParam%20param)%E6%8E%A5%E6%94%B6%E4%B8%80%E4%B8%AAMyParam%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%8C%E8%80%8CMyParam%E8%BF%99%E4%B8%AA%E7%B1%BB%E6%98%AF%E6%8B%A5%E6%9C%89%E6%B3%A8%E8%A7%A3MyAnnotation%E7%9A%84%EF%BC%8C%E5%88%99%E5%AE%83%E5%8F%AF%E4%BB%A5%E8%A2%ABPointcut%E8%A1%A8%E8%BE%BE%E5%BC%8F%E2%80%9C%40args(com.elim.spring.support.MyAnnotation)%E2%80%9D%E5%8C%B9%E9%85%8D%E4%B8%8A%0A%0A*%20**%40within**%0A%20%20%20%20*%20%40within%E7%94%A8%E4%BA%8E%E5%8C%B9%E9%85%8D%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%AF%B9%E5%BA%94%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%88%96%E5%85%B6%E7%88%B6%E7%B1%BB%E5%9E%8B%E6%8B%A5%E6%9C%89%E6%8C%87%E5%AE%9A%E7%9A%84%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E4%BD%86%E5%8F%AA%E6%9C%89%E5%9C%A8%E8%B0%83%E7%94%A8%E6%8B%A5%E6%9C%89%E6%8C%87%E5%AE%9A%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%B1%BB%E4%B8%8A%E7%9A%84%E6%96%B9%E6%B3%95%E6%97%B6%E6%89%8D%E5%8C%B9%E9%85%8D%0A%20%20%20%20%20%20%20%201.%20%E2%80%9C%40within(com.spring.support.MyAnnotation)%E2%80%9D%E5%8C%B9%E9%85%8D%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E5%A3%B0%E6%98%8E%E7%9A%84%E7%B1%BB%E4%B8%8A%E6%8B%A5%E6%9C%89MyAnnotation%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%83%85%E5%86%B5%E3%80%82%E6%AF%94%E5%A6%82%E6%9C%89%E4%B8%80%E4%B8%AAClassA%E4%B8%8A%E4%BD%BF%E7%94%A8%E4%BA%86%E6%B3%A8%E8%A7%A3MyAnnotation%E6%A0%87%E6%B3%A8%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%AE%9A%E4%B9%89%E4%BA%86%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95a()%EF%BC%8C%E9%82%A3%E4%B9%88%E5%9C%A8%E8%B0%83%E7%94%A8ClassA.a()%E6%96%B9%E6%B3%95%E6%97%B6%E5%B0%86%E5%8C%B9%E9%85%8D%E8%AF%A5Pointcut%EF%BC%9B%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E4%B8%AAClassB%E4%B8%8A%E6%B2%A1%E6%9C%89MyAnnotation%E6%B3%A8%E8%A7%A3%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%83%E7%BB%A7%E6%89%BF%E8%87%AAClassA%EF%BC%8C%E5%90%8C%E6%97%B6%E5%AE%83%E4%B8%8A%E9%9D%A2%E5%AE%9A%E4%B9%89%E4%BA%86%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95b()%EF%BC%8C%E9%82%A3%E4%B9%88%E5%9C%A8%E8%B0%83%E7%94%A8ClassB().b()%E6%96%B9%E6%B3%95%E6%97%B6%E4%B8%8D%E4%BC%9A%E5%8C%B9%E9%85%8D%E8%AF%A5Pointcut%EF%BC%8C%E4%BD%86%E6%98%AF%E5%9C%A8%E8%B0%83%E7%94%A8ClassB().a()%E6%97%B6%E5%B0%86%E5%8C%B9%E9%85%8D%E8%AF%A5%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%8C%E5%9B%A0%E4%B8%BAa()%E6%98%AF%E5%AE%9A%E4%B9%89%E5%9C%A8%E7%88%B6%E7%B1%BB%E5%9E%8BClassA%E4%B8%8A%E7%9A%84%EF%BC%8C%E4%B8%94ClassA%E4%B8%8A%E4%BD%BF%E7%94%A8%E4%BA%86MyAnnotation%E6%B3%A8%E8%A7%A3%E3%80%82%E4%BD%86%E6%98%AF%E5%A6%82%E6%9E%9C%E5%AD%90%E7%B1%BBClassB%E8%A6%86%E5%86%99%E4%BA%86%E7%88%B6%E7%B1%BBClassA%E7%9A%84a()%E6%96%B9%E6%B3%95%EF%BC%8C%E5%88%99%E8%B0%83%E7%94%A8ClassB.a()%E6%96%B9%E6%B3%95%E6%97%B6%E4%B9%9F%E4%B8%8D%E5%8C%B9%E9%85%8D%E8%AF%A5Pointcut%0A%0A*%20**%40annotation**%0A%20%20%20%20*%20%40annotation%E7%94%A8%E4%BA%8E%E5%8C%B9%E9%85%8D%E6%96%B9%E6%B3%95%E4%B8%8A%E6%8B%A5%E6%9C%89%E6%8C%87%E5%AE%9A%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%83%85%E5%86%B5%0A%20%20%20%20%20%20%20%201.%20%E2%80%9C%40annotation(com.spring.support.MyAnnotation)%E2%80%9D%E5%8C%B9%E9%85%8D%E6%89%80%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8A%E6%8B%A5%E6%9C%89MyAnnotation%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B9%E6%B3%95%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%0A%0A*%20%60%E5%85%88%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%8A%E7%9A%84%E6%B3%A8%E8%A7%A3%60%0A%60%60%60java%0Apackage%20com.zhangguo.Spring052.aop03%3B%0A%0Aimport%20java.lang.annotation.Documented%3B%0Aimport%20java.lang.annotation.ElementType%3B%0Aimport%20java.lang.annotation.Retention%3B%0Aimport%20java.lang.annotation.RetentionPolicy%3B%0Aimport%20java.lang.annotation.Target%3B%0A%0A%40Target(%7BElementType.METHOD%7D)%0A%40Retention(RetentionPolicy.RUNTIME)%0A%40Documented%0Apublic%20%40interface%20MyAnno%20%7B%0A%7D%0A%60%60%60%0A%60%60%60java%0A%2F%2F%40annotation%E5%88%87%E7%82%B9%E5%87%BD%E6%95%B0%0A%20%20%20%20%2F%2F%E8%A6%81%E6%B1%82%E6%96%B9%E6%B3%95%E5%BF%85%E9%A1%BB%E8%A2%AB%E6%B3%A8%E8%A7%A3com.zhangguo.Spring052.aop03.MyAnno%E6%89%8D%E4%BC%9A%E8%A2%AB%E7%BB%87%E5%85%A5%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%0A%20%20%20%20%40After(%22%40annotation(com.zhangguo.Spring052.aop03.MyAnno)%22)%0A%20%20%20%20public%20void%20after(JoinPoint%20jp)%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22----------%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5----------%22)%3B%0A%20%20%20%20%7D%0A%60%60%60%0A%60%60%60java%0Apackage%20com.zhangguo.Spring052.aop03%3B%0A%0Aimport%20org.springframework.stereotype.Component%3B%0A%0A%40Component(%22strUtil%22)%0Apublic%20class%20StrUtil%20%7B%0A%20%20%20%20%40MyAnno%0A%20%20%20%20public%20void%20show()%7B%0A%20%20%20%20%20%20%20%20System.out.println(%22Hello%20StrUtil!%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A!%5Beb7609a8f95aa8f96cd01f8fddd9646c.png%5D(en-resource%3A%2F%2Fdatabase%2F1014%3A1)%0A%0A*%20<strong>bean</strong>%0A%20%20%20%20*%20bean%E7%94%A8%E4%BA%8E%E5%8C%B9%E9%85%8D%E5%BD%93%E8%B0%83%E7%94%A8%E7%9A%84%E6%98%AF%E6%8C%87%E5%AE%9A%E7%9A%84Spring%E7%9A%84%E6%9F%90%E4%B8%AAbean%E7%9A%84%E6%96%B9%E6%B3%95%E6%97%B6%0A%20%20%20%20%20%20%20%201.%20%E2%80%9Cbean(abc)%E2%80%9D%E5%8C%B9%E9%85%8DSpring%20Bean%E5%AE%B9%E5%99%A8%E4%B8%ADid%E6%88%96name%E4%B8%BAabc%E7%9A%84bean%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%0A%20%20%20%20%20%20%20%202.%20%E2%80%9Cbean(user*)%E2%80%9D%E5%8C%B9%E9%85%8D%E6%89%80%E6%9C%89id%E6%88%96name%E4%B8%BA%E4%BB%A5user%E5%BC%80%E5%A4%B4%E7%9A%84bean%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%0A%0A%23%23%23%23%23%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%84%E5%90%88%0A*%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%84%E5%90%88%E5%B0%B1%E6%98%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%EF%BC%8C%E4%B8%8E%EF%BC%8C%E6%88%96%EF%BC%8C%E9%9D%9E%E3%80%82%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E4%BB%96%E4%BB%AC%E6%8A%8A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%84%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7%0A%20%20%20%201.%20bean(userService)%20%26%26%20args()%E2%80%9D%E5%8C%B9%E9%85%8Did%E6%88%96name%E4%B8%BAuserService%E7%9A%84bean%E7%9A%84%E6%89%80%E6%9C%89%E6%97%A0%E5%8F%82%E6%96%B9%E6%B3%95%E3%80%82%0A%20%20%20%202.%20%E2%80%9Cbean(userService)%20%7C%7C%20%40annotation(MyAnnotation)%E2%80%9D%E5%8C%B9%E9%85%8Did%E6%88%96name%E4%B8%BAuserService%E7%9A%84bean%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%8C%E6%88%96%E8%80%85%E6%98%AF%E6%96%B9%E6%B3%95%E4%B8%8A%E4%BD%BF%E7%94%A8%E4%BA%86MyAnnotation%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E3%80%82%0A%20%20%20%203.%20%E2%80%9Cbean(userService)%20%26%26%20!args()%E2%80%9D%E5%8C%B9%E9%85%8Did%E6%88%96name%E4%B8%BAuserService%E7%9A%84bean%E7%9A%84%E6%89%80%E6%9C%89%E6%9C%89%E5%8F%82%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E3%80%82%0A%0A%0A%23%23%23%23%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E8%A3%85%E9%85%8DAOP%0A%0A%E4%BD%BF%E7%94%A8AspectJ%E7%9A%84%E6%B3%A8%E8%A7%A3%EF%BC%8C%E5%B9%B6%E9%85%8D%E5%90%88%E4%B8%80%E4%B8%AA%E5%A4%8D%E6%9D%82%E7%9A%84%60execution(<em>%20xxx.Xyz.</em>(…))%60%20%20%E8%AF%AD%E6%B3%95%E6%9D%A5%E5%AE%9A%E4%B9%89%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E8%A3%85%E9%85%8DAOP%E3%80%82%0A%0A%E5%9C%A8%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%EF%BC%8C%E8%BF%99%E7%A7%8D%E5%86%99%E6%B3%95%E5%85%B6%E5%AE%9E%E5%BE%88%E5%B0%91%E4%BD%BF%E7%94%A8%E3%80%82%E5%81%87%E8%AE%BE%E4%BD%A0%E5%86%99%E4%BA%86%E4%B8%80%E4%B8%AASecurityAspect%EF%BC%9A%0A%60%60%60java%0A%40Aspect%0A%40Component%0Apublic%20class%20SecurityAspect%20%7B%0A%20%20%20%20%40Before(%22execution(public%20*%20com.itranswarp.learnjava.service.<em>.</em>(…))%22)%0A%20%20%20%20public%20void%20check()%20%7B%0A%20%20%20%20%20%20%20%20if%20(SecurityContext.getCurrentUser()%20%3D%3D%20null)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20throw%20new%20RuntimeException(%22check%20failed%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A%E5%9F%BA%E6%9C%AC%E8%83%BD%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%B7%AE%E5%88%AB%E5%85%A8%E8%A6%86%E7%9B%96%EF%BC%8C%E5%8D%B3%E6%9F%90%E4%B8%AA%E5%8C%85%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%89%80%E6%9C%89Bean%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E9%83%BD%E4%BC%9A%E8%A2%AB%E8%BF%99%E4%B8%AAcheck()%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA%E3%80%82%0A%0A%E8%BF%98%E6%9C%89%E7%9A%84%E7%AB%A5%E9%9E%8B%E5%96%9C%E6%AC%A2%E7%94%A8%E6%96%B9%E6%B3%95%E5%90%8D%E5%89%8D%E7%BC%80%E8%BF%9B%E8%A1%8C%E6%8B%A6%E6%88%AA%EF%BC%9A%0A%60%60%60java%0A%40Around(%22execution(public%20*%20update*(…))%22)%0Apublic%20Object%20doLogging(ProceedingJoinPoint%20pjp)%20throws%20Throwable%20%7B%0A%20%20%20%20%2F%2F%20%E5%AF%B9update%E5%BC%80%E5%A4%B4%E7%9A%84%E6%96%B9%E6%B3%95%E5%88%87%E6%8D%A2%E6%95%B0%E6%8D%AE%E6%BA%90%3A%0A%20%20%20%20String%20old%20%3D%20setCurrentDataSource(%22master%22)%3B%0A%20%20%20%20Object%20retVal%20%3D%20pjp.proceed()%3B%0A%20%20%20%20restoreCurrentDataSource(old)%3B%0A%20%20%20%20return%20retVal%3B%0A%7D%0A%60%60%60%0A%E8%BF%99%E7%A7%8D%E9%9D%9E%E7%B2%BE%E5%87%86%E6%89%93%E5%87%BB%E8%AF%AF%E4%BC%A4%E9%9D%A2%E6%9B%B4%E5%A4%A7%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%BB%8E%E6%96%B9%E6%B3%95%E5%89%8D%E7%BC%80%E5%8C%BA%E5%88%86%E6%98%AF%E5%90%A6%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E6%98%AF%E9%9D%9E%E5%B8%B8%E4%B8%8D%E5%8F%AF%E5%8F%96%E7%9A%84%E3%80%82%0A%0A%E6%88%91%E4%BB%AC%E5%9C%A8%E4%BD%BF%E7%94%A8AOP%E6%97%B6%EF%BC%8C%E8%A6%81%E6%B3%A8%E6%84%8F%E5%88%B0%E8%99%BD%E7%84%B6Spring%E5%AE%B9%E5%99%A8%E5%8F%AF%E4%BB%A5%E6%8A%8A%E6%8C%87%E5%AE%9A%E7%9A%84%E6%96%B9%E6%B3%95%E9%80%9A%E8%BF%87AOP%E8%A7%84%E5%88%99%E8%A3%85%E9%85%8D%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9A%84Bean%E7%9A%84%E6%8C%87%E5%AE%9A%E6%96%B9%E6%B3%95%E5%89%8D%E5%90%8E%EF%BC%8C%E4%BD%86%E6%98%AF%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%97%B6%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%B8%8D%E6%81%B0%E5%BD%93%E7%9A%84%E8%8C%83%E5%9B%B4%EF%BC%8C%E5%AE%B9%E6%98%93%E5%AF%BC%E8%87%B4%E6%84%8F%E6%83%B3%E4%B8%8D%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%8C%E5%8D%B3%E5%BE%88%E5%A4%9A%E4%B8%8D%E9%9C%80%E8%A6%81AOP%E4%BB%A3%E7%90%86%E7%9A%84Bean%E4%B9%9F%E8%A2%AB%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%90%86%E4%BA%86%EF%BC%8C%E5%B9%B6%E4%B8%94%EF%BC%8C%E5%90%8E%E7%BB%AD%E6%96%B0%E5%A2%9E%E7%9A%84Bean%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%B8%85%E6%A5%9A%E7%8E%B0%E6%9C%89%E7%9A%84AOP%E8%A3%85%E9%85%8D%E8%A7%84%E5%88%99%EF%BC%8C%E5%AE%B9%E6%98%93%E8%A2%AB%E5%BC%BA%E8%BF%AB%E8%A3%85%E9%85%8D%E3%80%82%0A%0A%E4%BD%BF%E7%94%A8AOP%E6%97%B6%EF%BC%8C%E8%A2%AB%E8%A3%85%E9%85%8D%E7%9A%84Bean%E6%9C%80%E5%A5%BD%E8%87%AA%E5%B7%B1%E8%83%BD%E6%B8%85%E6%B8%85%E6%A5%9A%E6%A5%9A%E5%9C%B0%E7%9F%A5%E9%81%93%E8%87%AA%E5%B7%B1%E8%A2%AB%E5%AE%89%E6%8E%92%E4%BA%86%E3%80%82%E4%BE%8B%E5%A6%82%EF%BC%8CSpring%E6%8F%90%E4%BE%9B%E7%9A%84%40Transactional%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%B8%B8%E5%A5%BD%E7%9A%84%E4%BE%8B%E5%AD%90%E3%80%82%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84Bean%E5%B8%8C%E6%9C%9B%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E4%B8%AD%E8%A2%AB%E8%B0%83%E7%94%A8%EF%BC%8C%E5%B0%B1%E6%A0%87%E6%B3%A8%E4%B8%8A%40Transactional%E3%80%82%0A%0A%E9%80%9A%E8%BF%87%40Transactional%EF%BC%8C%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%90%AF%E7%94%A8%E4%BA%86%E4%BA%8B%E5%8A%A1%E5%B0%B1%E4%B8%80%E6%B8%85%E4%BA%8C%E6%A5%9A%E4%BA%86%E3%80%82%E5%9B%A0%E6%AD%A4%EF%BC%8C%E8%A3%85%E9%85%8DAOP%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%98%AF%E6%9C%80%E5%A5%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E3%80%82%0A%0A%E6%88%91%E4%BB%AC%E4%BB%A5%E4%B8%80%E4%B8%AA%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90%E6%BC%94%E7%A4%BA%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0AOP%E8%A3%85%E9%85%8D%E3%80%82%E4%B8%BA%E4%BA%86%E7%9B%91%E6%8E%A7%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD%EF%BC%8C%E6%88%91%E4%BB%AC%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E7%9A%84%E6%B3%A8%E8%A7%A3%EF%BC%9A%0A%60%60%60java%0A%40Target(METHOD)%0A%40Retention(RUNTIME)%0Apublic%20%40interface%20MetricTime%20%7B%0A%20%20%20%20String%20value()%3B%0A%7D%0A%60%60%60%0A%0A%E5%9C%A8%E9%9C%80%E8%A6%81%E8%A2%AB%E7%9B%91%E6%8E%A7%E7%9A%84%E5%85%B3%E9%94%AE%E6%96%B9%E6%B3%95%E4%B8%8A%E6%A0%87%E6%B3%A8%E8%AF%A5%E6%B3%A8%E8%A7%A3%EF%BC%9A%0A%60%60%60java%0A%40Component%0Apublic%20class%20UserService%20%7B%0A%20%20%20%20%2F%2F%20%E7%9B%91%E6%8E%A7register()%E6%96%B9%E6%B3%95%E6%80%A7%E8%83%BD%3A%0A%20%20%20%20%40MetricTime(%22register%22)%0A%20%20%20%20public%20User%20register(String%20email%2C%20String%20password%2C%20String%20name)%20%7B%0A%20%20%20%20%20%20%20%20…%0A%20%20%20%20%7D%0A%20%20%20%20…%0A%7D%0A%60%60%60%0A%E7%84%B6%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E5%AE%9A%E4%B9%89MetricAspect%EF%BC%9A%0A%60%60%60java%0A%40Aspect%0A%40Component%0Apublic%20class%20MetricAspect%20%7B%0A%20%20%20%20%40Around(%22%40annotation(metricTime)%22)%0A%20%20%20%20public%20Object%20metric(ProceedingJoinPoint%20joinPoint%2C%20MetricTime%20metricTime)%20throws%20Throwable%20%7B%0A%20%20%20%20%20%20%20%20String%20name%20%3D%20metricTime.value()%3B%0A%20%20%20%20%20%20%20%20long%20start%20%3D%20System.currentTimeMillis()%3B%0A%20%20%20%20%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20joinPoint.proceed()%3B%0A%20%20%20%20%20%20%20%20%7D%20finally%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20long%20t%20%3D%20System.currentTimeMillis()%20-%20start%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E5%86%99%E5%85%A5%E6%97%A5%E5%BF%97%E6%88%96%E5%8F%91%E9%80%81%E8%87%B3JMX%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20System.err.println(%22%5BMetrics%5D%20%22%20%2B%20name%20%2B%20%22%3A%20%22%20%2B%20t%20%2B%20%22ms%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%60%60%60%0A%E6%B3%A8%E6%84%8Fmetric()%E6%96%B9%E6%B3%95%E6%A0%87%E6%B3%A8%E4%BA%86%40Around(%22%40annotation(metricTime)%22)%EF%BC%8C%E5%AE%83%E7%9A%84%E6%84%8F%E6%80%9D%E6%98%AF%EF%BC%8C%E7%AC%A6%E5%90%88%E6%9D%A1%E4%BB%B6%E7%9A%84%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E6%98%AF%E5%B8%A6%E6%9C%89%40MetricTime%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E5%9B%A0%E4%B8%BAmetric()%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%98%AFMetricTime%EF%BC%88%E6%B3%A8%E6%84%8F%E5%8F%82%E6%95%B0%E5%90%8D%E6%98%AFmetricTime%E4%B8%8D%E6%98%AFMetricTime%EF%BC%89%EF%BC%8C%E6%88%91%E4%BB%AC%E9%80%9A%E8%BF%87%E5%AE%83%E8%8E%B7%E5%8F%96%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E7%9A%84%E5%90%8D%E7%A7%B0%E3%80%82%0A%0A%E6%9C%89%E4%BA%86%40MetricTime%E6%B3%A8%E8%A7%A3%EF%BC%8C%E5%86%8D%E9%85%8D%E5%90%88MetricAspect%EF%BC%8C%E4%BB%BB%E4%BD%95Bean%EF%BC%8C%E5%8F%AA%E8%A6%81%E6%96%B9%E6%B3%95%E6%A0%87%E6%B3%A8%E4%BA%86%40MetricTime%E6%B3%A8%E8%A7%A3%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%82%0A</p>]]>
    </content>
    <id>http://example.com/2023/06/29/Spring_AOP/</id>
    <link href="http://example.com/2023/06/29/Spring_AOP/"/>
    <published>2023-06-29T04:00:00.000Z</published>
    <summary>AOP采取横向抽取机制，取代了传统纵向继承体系的重复性代码（性能监视，事务管理，安全检查，缓存）在程序运行期间，不修改源码对已有方法进行增强，将业务逻辑和系统处理的代码（关闭连接，事务管理，操作日志记录）解耦</summary>
    <title>Spring AOP</title>
    <updated>2026-02-26T09:23:53.372Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    <content>
      <![CDATA[<h1 id="spring-jdbc事务"><a class="markdownIt-Anchor" href="#spring-jdbc事务"></a> $Spring JDBC/事务</h1><h1 id="springjdbc"><a class="markdownIt-Anchor" href="#springjdbc"></a> SpringJDBC</h1><ul><li><a href="">SpringJDBC</a><ul><li><a href="">Spring对JDBC的整合支持</a><ul><li><a href="">spring对DAO技术提供了那些支持</a><ul><li><a href="">Spring对DAO异常的支持</a></li><li><a href="">Spring对DAO编写的支持</a></li></ul></li><li><a href="">如何编写DAO组件</a></li></ul></li><li><a href="">Spring jdbcTemplate的应用(XML)</a><ul><li><a href="">maven依赖</a></li><li><a href="">入门直接使用</a></li><li><a href="">spring管理使用方式</a><ul><li><a href="">spring配置文件</a></li><li><a href="">测试使用</a></li><li><a href="">增删改查</a></li><li><a href="">dbcp/c3p0连接池使用</a></li></ul></li></ul></li><li><a href="">Spring jdbcTemplate的应用(注解)</a><ul><li><a href="">JdbcTemplate用法</a></li></ul></li><li><a href="">Sprng JdbcDaoSupport应用</a><ul><li><a href="">使用</a></li></ul></li></ul></li><li><a href="">Spring 事务</a><ul><li><a href="">事务概念</a><ul><li><a href="">事务介绍</a></li><li><a href="">事务的并发问题（隔离性导致）</a></li><li><a href="">事务隔离级别</a><ul><li><a href="">四种隔离级别</a></li><li><a href="">事务的传播行为</a></li><li><a href="">注意事项</a></li></ul></li></ul></li><li><a href="">Spring框架的事务管理相关的类和API</a><ul><li><a href="">PlatformTransactionManager接口</a></li><li><a href="">TransactionDefinition接口</a></li><li><a href="">TransactionStatus接口</a></li></ul></li><li><a href="">Spring框架事务管理的分类</a><ul><li><a href="">编程式事务管理（了解）</a><ul><li><a href="">配置一个事务管理器</a></li><li><a href="">配置事务管理模板</a></li><li><a href="">注入事务管理模板</a></li><li><a href="">在业务层使用模板管理事务</a></li></ul></li><li><a href="">声明式事务管理（重点）</a><ul><li><a href="">基于AspectJ的XML方式</a><ul><li><a href="">maven依赖</a></li><li><a href="">数据库表</a></li><li><a href="">持久层</a></li><li><a href="">业务层</a></li><li><a href="">spring 配置</a></li><li><a href="">测试</a></li><li><a href="">源码分析</a></li></ul></li><li><a href="">基于AspectJ的注解方式</a></li></ul></li><li><a href="">使用声明式事务</a><ul><li><a href="">回滚事务</a></li><li><a href="">事务边界</a></li><li><a href="">事务传播</a></li></ul></li></ul></li></ul></li></ul><h2 id="spring对jdbc的整合支持"><a class="markdownIt-Anchor" href="#spring对jdbc的整合支持"></a> Spring对JDBC的整合支持</h2><p>Spring JDBC就是指spring自身对jdbc的代码进行了一些封装，使得使用更加的简单，方便，快捷。</p><h3 id="spring对dao技术提供了那些支持"><a class="markdownIt-Anchor" href="#spring对dao技术提供了那些支持"></a> spring对DAO技术提供了那些支持</h3><ul><li>Spring对JDBC等数据库访问技术编写DAO提供了以下几个重要支持<ul><li>Spring对DAO异常提供了统一处理</li><li>Spring对DAO编写提供了支持的抽象类</li><li>提高编程效率，减少JDBC编码量</li></ul></li></ul><h4 id="spring对dao异常的支持"><a class="markdownIt-Anchor" href="#spring对dao异常的支持"></a> Spring对DAO异常的支持</h4><ul><li>Spring把特定某种技术的异常，如SQLException,统一转化为自己的异常类型，这些异常以DataAccessException为父类，它们封装了原始异常对象，不会丢失原始错误信息</li><li>DataAccessException继承于RuntimeException，是非检查异常，不会因为没有处理异常而出现编译错误，异常必须处理，可以用拦截器或者在界面层统一处理</li></ul><h4 id="spring对dao编写的支持"><a class="markdownIt-Anchor" href="#spring对dao编写的支持"></a> Spring对DAO编写的支持</h4><ul><li>Spring为了便于以一种一致的方式使用各种数据访问技术，如JDBC,Hibernate，Spring提供了一套抽象的DAO类，这些抽象类提供了一些方法，通过他们可以获得与数据访问技术相关的数据源和其他配置信息<ul><li><code>JdbcTemplate</code> 封装常用的JDBC方法</li><li><code>HibernateTemplate</code> 封装常用Hibernate方法</li><li><code>JdbcDaoSupport</code> -JDBC数据访问对象的基类</li><li><code>HibernateDaoSupport</code> -Hibernate数据访问对象的基类</li></ul></li></ul><h3 id="如何编写dao组件"><a class="markdownIt-Anchor" href="#如何编写dao组件"></a> 如何编写DAO组件</h3><ul><li>基于JDBC技术编写DAO组件可以采用下面两种模式<ol><li><strong>DAO继承JdbcDaoSupport</strong>，通过getJdbcTemplate()方法获取JdbcTemplate对象，需要在DAO实现类中注入一个DataSource对象来完成JdbcTemplate的实例化</li><li><strong>DAO使用JdbcTemplate</strong>，在Spring容器中配置一个JdbcTemplate的bean，然后注入给DAO实现类</li></ol></li></ul><h2 id="spring-jdbctemplate的应用xml"><a class="markdownIt-Anchor" href="#spring-jdbctemplate的应用xml"></a> Spring jdbcTemplate的应用(XML)</h2><p>JdbcTemplate封装了连接获取以及连接释放等工作，从而简化了我买对JDBC的使用，避免忘记关闭连接等错误</p><ul><li>JdbcTemplate提供了以下主要方法<ul><li><code>queryForInt</code>()</li><li><code>queryForObject</code>()</li><li><code>query</code>()</li><li><code>update</code>()</li><li><code>execute</code>()</li></ul></li></ul><p>正确编写JDBC代码的关键是使用try … finally释放资源，涉及到事务的代码需要正确提交或回滚事务。</p><p>在Spring使用JDBC，首先我们通过IoC容器创建并管理一个DataSource实例，然后，Spring提供了一个JdbcTemplate，可以方便地让我们操作JDBC，因此，通常情况下，我们会实例化一个JdbcTemplate。顾名思义，这个类主要使用了Template模式。</p><p>编写示例代码或者测试代码时，我们强烈推荐使用HSQLDB这个数据库，它是一个用Java编写的关系数据库，可以以内存模式或者文件模式运行，本身只有一个jar包，非常适合演示代码或者测试代码。</p><h3 id="maven依赖"><a class="markdownIt-Anchor" href="#maven依赖"></a> maven依赖</h3><blockquote><p>或者可以使用阿里的<strong>druid连接�</strong>�</p></blockquote><pre><code class="highlight plaintext">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;groupId&gt;com.lee&lt;/groupId&gt;&lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;dependencies&gt;&lt;!-- spring ioc组件需要的依赖包 --&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-core&lt;/artifactId&gt;&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-context&lt;/artifactId&gt;&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-expression&lt;/artifactId&gt;&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 基于AspectJ的aop依赖 --&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;aopalliance&lt;/groupId&gt;&lt;artifactId&gt;aopalliance&lt;/artifactId&gt;&lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring 事务管理和JDBC依赖包 --&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-tx&lt;/artifactId&gt;&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring 单元测试组件包 --&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-test&lt;/artifactId&gt;&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 单元测试Junit --&gt;&lt;dependency&gt;&lt;groupId&gt;junit&lt;/groupId&gt;&lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql数据库驱动包 --&gt;&lt;dependency&gt;&lt;groupId&gt;mysql&lt;/groupId&gt;&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;version&gt;5.1.35&lt;/version&gt;&lt;/dependency&gt;&lt;!-- dbcp连接池的依赖包 --&gt;&lt;dependency&gt;&lt;groupId&gt;commons-dbcp&lt;/groupId&gt;&lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;&lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt;&lt;plugins&gt;&lt;!-- 配置Maven的JDK编译级别 --&gt;&lt;plugin&gt;&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&lt;version&gt;3.2&lt;/version&gt;&lt;configuration&gt;&lt;source&gt;1.8&lt;/source&gt;&lt;target&gt;1.8&lt;/target&gt;&lt;encoding&gt;UTF-8&lt;/encoding&gt;&lt;/configuration&gt;&lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt;&lt;/project&gt;</code></pre><h3 id="入门直接使用"><a class="markdownIt-Anchor" href="#入门直接使用"></a> 入门直接使用</h3><p>不使用spring管理，直接调用</p><pre><code class="highlight plaintext">import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;public class Test &#123;    @org.junit.Test    public void run1()&#123;        // 创建连接池，先使用Spring框架内置的连接池        DriverManagerDataSource dataSource = new DriverManagerDataSource();        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);        dataSource.setUrl(&quot;jdbc:mysql:///leetest&quot;);        dataSource.setUsername(&quot;root&quot;);        dataSource.setPassword(&quot;123456&quot;);        // 创建模板类        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);        // 完成数据的添加        jdbcTemplate.update(&quot;insert into account values (?,?,?)&quot;, 1,&quot;测试&quot;,10000);    &#125;&#125;</code></pre><h3 id="spring管理使用方式"><a class="markdownIt-Anchor" href="#spring管理使用方式"></a> spring管理使用方式</h3><p>使用方式改为纳入spring管理的使用方式</p><p><strong>使用spring自带的datasource连接�</strong>�</p><h4 id="spring配置文件"><a class="markdownIt-Anchor" href="#spring配置文件"></a> spring配置文件</h4><p>applicationContext.xml</p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--配置Spring内置数据源dataSource--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/leetest?characterEncoding=UTF-8&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;    &lt;/bean&gt;    &lt;!--spring管理模板类 --&gt;    &lt;bean id=&quot;JdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h4 id="测试使用"><a class="markdownIt-Anchor" href="#测试使用"></a> 测试使用</h4><pre><code class="highlight plaintext">import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:ApplicationContext.xml&quot;)public class TestSpring &#123;    @Resource    JdbcTemplate template;    @Test    public void test()&#123;        template.update(&quot;insert into account values (?,?,?)&quot;, 2,&quot;测试222&quot;,10000);    &#125;&#125;</code></pre><h4 id="增删改查"><a class="markdownIt-Anchor" href="#增删改查"></a> 增删改查</h4><p>Account</p><pre><code class="highlight plaintext">public class Account &#123;    private int id;    private String name;    private Double salary;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Double getSalary() &#123;        return salary;    &#125;    public void setSalary(Double salary) &#123;        this.salary = salary;    &#125;&#125;</code></pre><pre><code class="highlight plaintext">import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;import java.sql.ResultSet;import java.sql.SQLException;import java.util.List;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:ApplicationContext.xml&quot;)public class SpringDemo &#123;    @Resource    private JdbcTemplate jdbcTemplate;    @Test    // 插入操作    public void demo1() &#123;        jdbcTemplate.update(&quot;insert into account values (null,?,?)&quot;, &quot;冠希&quot;, 10000d);    &#125;    @Test    // 修改操作    public void demo2() &#123;        jdbcTemplate.update(&quot;update account set name=?,money =? where id = ?&quot;, &quot;思雨&quot;, 10000d, 5);    &#125;    @Test    // 删除操作    public void demo3() &#123;        jdbcTemplate.update(&quot;delete from account where id = ?&quot;, 5);    &#125;    @Test    // 查询一条记录    public void demo4() &#123;        Account account = jdbcTemplate.queryForObject(&quot;select * from account where id = ?&quot;, new BeanMapper(), 1);        System.out.println(account);    &#125;    @Test    // 查询所有记录    public void demo5() &#123;        List&lt;Account&gt; list = jdbcTemplate.query(&quot;select * from t_account&quot;, new BeanMapper());        for (Account account : list) &#123;            System.out.println(account);        &#125;    &#125;&#125;class BeanMapper implements RowMapper&lt;Account&gt; &#123;    public Account mapRow(ResultSet rs, int arg1) throws SQLException &#123;        Account account = new Account();        account.setId(rs.getInt(&quot;id&quot;));        account.setName(rs.getString(&quot;name&quot;));        account.setSalary(rs.getDouble(&quot;salary&quot;));        return account;    &#125;&#125;</code></pre><h4 id="dbcpc3p0连接池使用"><a class="markdownIt-Anchor" href="#dbcpc3p0连接池使用"></a> dbcp/c3p0连接池使用</h4><p><strong>spring配置文件</strong></p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--配置Spring内置数据源dataSource--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/leetest?characterEncoding=UTF-8&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;    &lt;/bean&gt;    &lt;!--spring管理模板类 --&gt;    &lt;bean id=&quot;JdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;c3p0DataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!--使用dbcp连接池--&gt;    &lt;bean id=&quot;dbcpDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/leetest?characterEncoding=UTF-8&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;    &lt;/bean&gt;    &lt;!--使用c3p0连接池--&gt;    &lt;bean id=&quot;c3p0DataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/leetest?characterEncoding=UTF-8&quot;/&gt;        &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h2 id="spring-jdbctemplate的应用注解"><a class="markdownIt-Anchor" href="#spring-jdbctemplate的应用注解"></a> Spring jdbcTemplate的应用(注解)</h2><p>在Spring使用JDBC，首先我们通过IoC容器创建并管理一个DataSource实例，然后，Spring提供了一个JdbcTemplate，可以方便地让我们操作JDBC，因此，通常情况下，我们会实例化一个JdbcTemplate。顾名思义，这个类主要使用了Template模式。</p><p>编写示例代码或者测试代码时，我们强烈推荐使用HSQLDB这个数据库，它是一个用Java编写的关系数据库，可以以内存模式或者文件模式运行，本身只有一个jar包，非常适合演示代码或者测试代码。</p><p>我们以实际工程为例，先创建Maven工程spring-data-jdbc，然后引入以下依赖：</p><pre><code class="highlight plaintext">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;        &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.annotation&lt;/groupId&gt;        &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;        &lt;version&gt;1.3.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.zaxxer&lt;/groupId&gt;        &lt;artifactId&gt;HikariCP&lt;/artifactId&gt;        &lt;version&gt;3.4.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;        &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;        &lt;version&gt;2.5.0&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>在AppConfig中，我们需要创建以下几个必须的Bean：</p><pre><code class="highlight plaintext">Configuration@ComponentScan@PropertySource(&quot;jdbc.properties&quot;)public class AppConfig &#123;    @Value(&quot;$&#123;jdbc.url&#125;&quot;)    String jdbcUrl;    @Value(&quot;$&#123;jdbc.username&#125;&quot;)    String jdbcUsername;    @Value(&quot;$&#123;jdbc.password&#125;&quot;)    String jdbcPassword;    @Bean    DataSource createDataSource() &#123;        HikariConfig config = new HikariConfig();        config.setJdbcUrl(jdbcUrl);        config.setUsername(jdbcUsername);        config.setPassword(jdbcPassword);        config.addDataSourceProperty(&quot;autoCommit&quot;, &quot;true&quot;);        config.addDataSourceProperty(&quot;connectionTimeout&quot;, &quot;5&quot;);        config.addDataSourceProperty(&quot;idleTimeout&quot;, &quot;60&quot;);        return new HikariDataSource(config);    &#125;    @Bean    JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) &#123;        return new JdbcTemplate(dataSource);    &#125;&#125;</code></pre><p>在上述配置中：</p><ol><li>通过@PropertySource(“jdbc.properties”)读取数据库配置文件；</li><li>通过@Value(“${jdbc.url}”)注入配置文件的相关配置；</li><li>创建一个DataSource实例，它的实际类型是HikariDataSource，创建时需要用到注入的配置；</li><li>创建一个JdbcTemplate实例，它需要注入DataSource，这是通过方法参数完成注入的。</li></ol><p>最后，针对HSQLDB写一个配置文件jdbc.properties：</p><pre><code class="highlight plaintext"># 数据库文件名为testdb:jdbc.url=jdbc:hsqldb:file:testdb# Hsqldb默认的用户名是sa，口令是空字符串:jdbc.username=sajdbc.password=</code></pre><p>可以通过HSQLDB自带的工具来初始化数据库表，这里我们写一个Bean，在Spring容器启动时自动创建一个users表：</p><pre><code class="highlight plaintext">@Componentpublic class DatabaseInitializer &#123;    @Autowired    JdbcTemplate jdbcTemplate;    @PostConstruct    public void init() &#123;        jdbcTemplate.update(&quot;CREATE TABLE IF NOT EXISTS users (&quot; //                + &quot;id BIGINT IDENTITY NOT NULL PRIMARY KEY, &quot; //                + &quot;email VARCHAR(100) NOT NULL, &quot; //                + &quot;password VARCHAR(100) NOT NULL, &quot; //                + &quot;name VARCHAR(100) NOT NULL, &quot; //                + &quot;UNIQUE (email))&quot;);    &#125;&#125;</code></pre><p>现在，所有准备工作都已完毕。我们只需要在需要访问数据库的Bean中，注入JdbcTemplate即可：</p><pre><code class="highlight plaintext">@Componentpublic class UserService &#123;    @Autowired    JdbcTemplate jdbcTemplate;    ...&#125;</code></pre><h3 id="jdbctemplate用法"><a class="markdownIt-Anchor" href="#jdbctemplate用法"></a> JdbcTemplate用法</h3><p>Spring提供的JdbcTemplate采用Template模式，提供了一系列以回调为特点的工具方法，目的是避免繁琐的try…catch语句。</p><p>我们以具体的示例来说明JdbcTemplate的用法。</p><p>首先我们看T execute(ConnectionCallback<T> action)方法，它提供了Jdbc的Connection供我们使用：</p><pre><code class="highlight plaintext">public User getUserById(long id) &#123;    // 注意传入的是ConnectionCallback:    return jdbcTemplate.execute((Connection conn) -&gt; &#123;        // 可以直接使用conn实例，不要释放它，回调结束后JdbcTemplate自动释放:        // 在内部手动创建的PreparedStatement、ResultSet必须用try(...)释放:        try (var ps = conn.prepareStatement(&quot;SELECT * FROM users WHERE id = ?&quot;)) &#123;            ps.setObject(1, id);            try (var rs = ps.executeQuery()) &#123;                if (rs.next()) &#123;                    return new User( // new User object:                            rs.getLong(&quot;id&quot;), // id                            rs.getString(&quot;email&quot;), // email                            rs.getString(&quot;password&quot;), // password                            rs.getString(&quot;name&quot;)); // name                &#125;                throw new RuntimeException(&quot;user not found by id.&quot;);            &#125;        &#125;    &#125;);&#125;</code></pre><p>也就是说，上述回调方法允许获取Connection，然后做任何基于Connection的操作。</p><p>我们再看T execute(String sql, PreparedStatementCallback<T> action)的用法：</p><pre><code class="highlight plaintext">public User getUserByName(String name) &#123;    // 需要传入SQL语句，以及PreparedStatementCallback:    return jdbcTemplate.execute(&quot;SELECT * FROM users WHERE name = ?&quot;, (PreparedStatement ps) -&gt; &#123;        // PreparedStatement实例已经由JdbcTemplate创建，并在回调后自动释放:        ps.setObject(1, name);        try (var rs = ps.executeQuery()) &#123;            if (rs.next()) &#123;                return new User( // new User object:                        rs.getLong(&quot;id&quot;), // id                        rs.getString(&quot;email&quot;), // email                        rs.getString(&quot;password&quot;), // password                        rs.getString(&quot;name&quot;)); // name            &#125;            throw new RuntimeException(&quot;user not found by id.&quot;);        &#125;    &#125;);&#125;</code></pre><p>最后，我们看T queryForObject(String sql, Object[] args, RowMapper<T> rowMapper)方法：</p><pre><code class="highlight plaintext">public User getUserByEmail(String email) &#123;    // 传入SQL，参数和RowMapper实例:    return jdbcTemplate.queryForObject(&quot;SELECT * FROM users WHERE email = ?&quot;, new Object[] &#123; email &#125;,            (ResultSet rs, int rowNum) -&gt; &#123;                // 将ResultSet的当前行映射为一个JavaBean:                return new User( // new User object:                        rs.getLong(&quot;id&quot;), // id                        rs.getString(&quot;email&quot;), // email                        rs.getString(&quot;password&quot;), // password                        rs.getString(&quot;name&quot;)); // name            &#125;);&#125;</code></pre><p>在queryForObject()方法中，传入SQL以及SQL参数后，JdbcTemplate会自动创建PreparedStatement，自动执行查询并返回ResultSet，我们提供的RowMapper需要做的事情就是把ResultSet的当前行映射成一个JavaBean并返回。整个过程中，使用Connection、PreparedStatement和ResultSet都不需要我们手动管理。</p><p>RowMapper不一定返回JavaBean，实际上它可以返回任何Java对象。例如，使用<code>SELECT COUNT(*)</code>查询时，可以返回Long：</p><pre><code class="highlight plaintext">public long getUsers() &#123;    return jdbcTemplate.queryForObject(&quot;SELECT COUNT(*) FROM users&quot;, null, (ResultSet rs, int rowNum) -&gt; &#123;        // SELECT COUNT(*)查询只有一列，取第一列数据:        return rs.getLong(1);    &#125;);&#125;```如果我们期望返回多行记录，而不是一行，可以用query()方法：```javapublic List&lt;User&gt; getUsers(int pageIndex) &#123;    int limit = 100;    int offset = limit * (pageIndex - 1);    return jdbcTemplate.query(&quot;SELECT * FROM users LIMIT ? OFFSET ?&quot;, new Object[] &#123; limit, offset &#125;,            new BeanPropertyRowMapper&lt;&gt;(User.class));&#125;</code></pre><p>上述query()方法传入的参数仍然是SQL、SQL参数以及RowMapper实例。这里我们直接使用Spring提供的BeanPropertyRowMapper。如果数据库表的结构恰好和JavaBean的属性名称一致，那么BeanPropertyRowMapper就可以直接把一行记录按列名转换为JavaBean。</p><p>如果我们执行的不是查询，而是插入、更新和删除操作，那么需要使用update()方法：</p><pre><code class="highlight plaintext">public void updateUser(User user) &#123;    // 传入SQL，SQL参数，返回更新的行数:    if (1 != jdbcTemplate.update(&quot;UPDATE users SET name = ? WHERE id=?&quot;, user.getName(), user.getId())) &#123;        throw new RuntimeException(&quot;User not found by id&quot;);    &#125;&#125;</code></pre><p>只有一种INSERT操作比较特殊，那就是如果某一列是自增列（例如自增主键），通常，我们需要获取插入后的自增值。JdbcTemplate提供了一个KeyHolder来简化这一操作：</p><pre><code class="highlight plaintext">public User register(String email, String password, String name) &#123;    // 创建一个KeyHolder:    KeyHolder holder = new GeneratedKeyHolder();    if (1 != jdbcTemplate.update(        // 参数1:PreparedStatementCreator        (conn) -&gt; &#123;            // 创建PreparedStatement时，必须指定RETURN_GENERATED_KEYS:            var ps = conn.prepareStatement(&quot;INSERT INTO users(email,password,name) VALUES(?,?,?)&quot;,                    Statement.RETURN_GENERATED_KEYS);            ps.setObject(1, email);            ps.setObject(2, password);            ps.setObject(3, name);            return ps;        &#125;,        // 参数2:KeyHolder        holder)    ) &#123;        throw new RuntimeException(&quot;Insert failed.&quot;);    &#125;    // 从KeyHolder中获取返回的自增值:    return new User(holder.getKey().longValue(), email, password, name);&#125;</code></pre><p>JdbcTemplate还有许多重载方法，这里我们不一一介绍。需要强调的是，JdbcTemplate只是对JDBC操作的一个简单封装，它的目的是尽量减少手动编写try(resource) {…}的代码，对于查询，主要通过RowMapper实现了JDBC结果集到Java对象的转换。</p><h2 id="sprng-jdbcdaosupport应用"><a class="markdownIt-Anchor" href="#sprng-jdbcdaosupport应用"></a> Sprng JdbcDaoSupport应用</h2><ul><li>JdbcDaoSupport是利用JDBC技术编写DAO的父类，通过该类提供的方法，可便于获取Connection和JdbcTemplate等对象信息</li><li>JdbcDaoSupport使用时需要注入一个DataSource对象</li><li>JdbcDaoSupport对代码有一定的<strong>侵入性</strong></li></ul><p><strong>jdbcDaoSupport有个成员变量jdbcTemplate</strong>，所以可以直接继承改类来获取jdbcTemplate，使用方式完全相同，<strong>只需把注入的方式改为继承的方式</strong></p><h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3><p>使用JdbcDaoSupport，<strong>只需让sql操作类继承改类</strong>，然后在spring配置文件中，给sql操作类<strong>显式的注入datasource</strong>即可</p><pre><code class="highlight plaintext">import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:ApplicationContext.xml&quot;)public class TestSpring extends JdbcDaoSupport &#123;//使用JdbcDaoSupport就无需注入JdbcTemplate//    @Resource//    JdbcTemplate template;    @Test    public void test()&#123;        this.template.update(&quot;insert into account values (?,?,?)&quot;, 2,&quot;测试222&quot;,10000);    &#125;&#125;</code></pre><p>applicationContext.xml配置文件给该类注入datasource</p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--配置Spring内置数据源dataSource--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/leetest?characterEncoding=UTF-8&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;    &lt;/bean&gt;    &lt;!--spring管理模板类 --&gt;    &lt;!--在这里显式的注入dataSource--&gt;    &lt;bean id=&quot;TestSpring&quot; class=&quot;com.lee.TestSpring&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><p>集成Hibernate</p><h1 id="spring-事务"><a class="markdownIt-Anchor" href="#spring-事务"></a> Spring 事务</h1><h2 id="事务概念"><a class="markdownIt-Anchor" href="#事务概念"></a> 事务概念</h2><h3 id="事务介绍"><a class="markdownIt-Anchor" href="#事务介绍"></a> 事务介绍</h3><p>事务：指的是逻辑上一组操作，组成这个事务的各个执行单元，要么一起成功，要么一起失败</p><p>事务的特新：</p><ul><li><strong>原子性</strong>（Atomicity）<ul><li>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚</li></ul></li><li><strong>一致性</strong>（Consistecy）<ul><li>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态</li><li>比如：转账，a用户和b用户两者的钱加起来一共是5000，那么不管a和b之间如何转账，转几次帐，事务结束后两个用户的钱加起来还要是5000，这就是事务的一致性</li></ul></li><li>隔离性（Isolation）<ul><li>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离</li></ul></li><li>持久性（Durability）<ul><li>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即使实在数据库系统中遇到故障的情况下，也不会丢失提交事务的操作</li></ul></li></ul><h3 id="事务的并发问题隔离性导致"><a class="markdownIt-Anchor" href="#事务的并发问题隔离性导致"></a> 事务的并发问题（隔离性导致）</h3><p>在事务的并发操作中可能会出现一些问题：</p><ul><li><strong>脏读</strong>：一个事务读取到另一个事务<strong>未提交</strong>的数据</li><li><strong>不可重复读</strong>：一个事务因读取到另一个事务已提交的数据，导致对<strong>同一条记录</strong>读取两次以上的结果不一致，update操作</li><li><strong>幻读</strong>：一个事务因读取到另一个事务已提交的数据，导致<strong>对同一张表</strong>读取两次以上的结果不一致，insert,delete操作</li></ul><p><img src="image/.png" alt=".png" /></p><h3 id="事务隔离级别"><a class="markdownIt-Anchor" href="#事务隔离级别"></a> 事务隔离级别</h3><p>为了避免出现上述的几种情况，在标准sql规范中，定义了4个事务隔离级别，不同的隔离级别对事务的处理不同</p><h4 id="四种隔离级别"><a class="markdownIt-Anchor" href="#四种隔离级别"></a> 四种隔离级别</h4><p>MySQL数据库为我们提供了四种隔离级别（由低到高）：</p><ul><li><strong>Read uncommitted</strong>（读未提交）：最低级别，任何情况都无法保证</li><li><strong>Read committed</strong>（读已提交）：可避免脏读的发生</li><li><strong>Repeatable read</strong>（可重复读）：可避免脏读，不可重复读的发生</li><li><strong>Serializable</strong>（串行化）：可避免脏读，不可重复读，幻读的发生</li></ul><p><strong>默认隔离级别</strong></p><p>大多数数据库的默认隔离级别时Read committed，比如Oracle，DB2等</p><p>MySQL数据库的隔离级别时Repeatable read</p><h4 id="事务的传播行为"><a class="markdownIt-Anchor" href="#事务的传播行为"></a> 事务的传播行为</h4><p>事务的传播行为：解决的是业务层之间的方法调用</p><p>比如：事务都是针对service层进行设置的，但是service层的代码之间是可以相互调用的，s1和s2方法，两个方法都有各自的事务，如果此时s1调用了s2，那么为了保证在一个事务内进行操作的，需要进行事务传播特性的设置</p><ul><li><strong>PROPAGATION_REQUIRED</strong>（默认值）：A中有事务,使用A中的事务.如果没有，B就会开启一个新的事务,将A包含进来.(保证A,B在同一个事务中)，<strong>默认值</strong></li><li><strong>PROPAGATION_SUPPORTS</strong>：A中有事务,使用A中的事务.如果A中没有事务.那么B也不使用事务.</li><li><strong>PROPAGATION_MANDATORY</strong>：A中有事务,使用A中的事务.如果A没有事务.抛出异常.</li><li><strong>PROPAGATION_REQUIRES_NEW</strong>：A中有事务,将A中的事务挂起.B创建一个新的事务.(保证A,B没有在一个事务中)</li><li><strong>PROPAGATION_NOT_SUPPORTED</strong>：A中有事务,将A中的事务挂起.</li><li><strong>PROPAGATION_NEVER</strong>：A中有事务,抛出异常.</li><li><strong>PROPAGATION_NESTED</strong>：嵌套事务.当A执行之后,就会在这个位置设置一个保存点.如果B没有问题.执行通过.如果B出现异常,运行客户根据需求回滚(选择回滚到保存点或者是最初始状态)</li></ul><h4 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h4><p><strong>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大</strong></p><p>对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制</p><h2 id="spring框架的事务管理相关的类和api"><a class="markdownIt-Anchor" href="#spring框架的事务管理相关的类和api"></a> Spring框架的事务管理相关的类和API</h2><p>Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。 <strong>Spring事务管理器的接口是PlatformTransactionManager</strong>，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了</p><p><img src="image/-1.png" alt="-1.png" /></p><h3 id="platformtransactionmanager接口"><a class="markdownIt-Anchor" href="#platformtransactionmanager接口"></a> PlatformTransactionManager接口</h3><p>平台事务管理器（真正管理事务的类），该接口有具体的实现类，根据不同的持久层框架，需要选择不同的实现类</p><ul><li><strong>接口的实现类：</strong><ul><li>如果使用spring的jdbc模板或者mybatis框架，需要选择<code>DataSourceTransactionManager</code>实现类</li><li>如果使用的是Hibernate的框架，需要选择的是<code>HibernateTransactionManager</code>实现类</li></ul></li><li><strong>该接口的常用方法：</strong><ul><li>void commit(TransactionStatus status)</li><li>TransactionStatus getTransaction(TransactionDefinition definition)</li><li>void rollback(TransactionStatus status)</li></ul></li></ul><h3 id="transactiondefinition接口"><a class="markdownIt-Anchor" href="#transactiondefinition接口"></a> TransactionDefinition接口</h3><p>事务定义信息（事务的隔离级别，传播行为，超时，只读）</p><ul><li><strong>事务隔离级别的常量</strong><ul><li>static int ISOLATION_DEFAULT             – 采用数据库的默认隔离级别</li><li>static int ISOLATION_READ_UNCOMMITTED</li><li>static int ISOLATION_READ_COMMITTED</li><li>static int ISOLATION_REPEATABLE_READ</li><li>static int ISOLATION_SERIALIZABLE</li></ul></li><li><strong>事务的传播行为</strong><ul><li>PROPAGATION_REQUIRED（默认值） – A中有事务,使用A中的事务.如果没有，B就会开启一个新的事务,将A包含进来.(保证A,B在同一个事务中)，默认值！！</li><li>PROPAGATION_SUPPORTS          – A中有事务,使用A中的事务.如果A中没有事务.那么B也不使用事务.</li><li>PROPAGATION_MANDATORY         – A中有事务,使用A中的事务.如果A没有事务.抛出异常.</li><li>PROPAGATION_REQUIRES_NEW      – A中有事务,将A中的事务挂起.B创建一个新的事务.(保证A,B没有在一个事务中)</li><li>PROPAGATION_NOT_SUPPORTED     – A中有事务,将A中的事务挂起.</li><li>PROPAGATION_NEVER             – A中有事务,抛出异常.</li><li>PROPAGATION_NESTED            – 嵌套事务.当A执行之后,就会在这个位置设置一个保存点.如果B没有问题.执行通过.如果B出现异常,运行客户根据需求回滚(选择回滚到保存点或者是最初始状态)</li></ul></li></ul><h3 id="transactionstatus接口"><a class="markdownIt-Anchor" href="#transactionstatus接口"></a> TransactionStatus接口</h3><p>事务的状态（是否新事物，是否已提交，是否有保存点，是否回滚）</p><blockquote><p>总结：上述对象之间的关系：平台事务管理器PlatformTransactionManager真正管理事务对象，根据事务定义的信息TransactionDefinition进行事务管理，在管理事务中产生一些状态，将状态记录到TransactionStatus中</p></blockquote><h2 id="spring框架事务管理的分类"><a class="markdownIt-Anchor" href="#spring框架事务管理的分类"></a> Spring框架事务管理的分类</h2><ol><li>spring的<strong>编程式事务管理</strong>（不推荐使用）<ul><li>通过手动编写代码的方式完成事务的管理</li></ul></li><li>spring的<strong>声明式事务管理</strong>（底层采用AOP的技术）<ul><li>通过一段配置的方式完成事务的管理</li><li>一般使用基于aspectJ的xml方式 和 基于aspectJ的注解方式</li></ul></li></ol><h3 id="编程式事务管理了解"><a class="markdownIt-Anchor" href="#编程式事务管理了解"></a> 编程式事务管理（了解）</h3><p>spring为了简化事务管理的代码，提供了模板类TransactionTemplate，所以手手动编程的方式管理事务，只需要使用该模板类即可</p><h4 id="配置一个事务管理器"><a class="markdownIt-Anchor" href="#配置一个事务管理器"></a> 配置一个事务管理器</h4><p>配置一个事务管理器，Spring使用PlatformTransactionManager接口来管理事务，所以咱们需要使用到他的实现类</p><pre><code class="highlight plaintext">&lt;!-- 配置事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;</code></pre><h4 id="配置事务管理模板"><a class="markdownIt-Anchor" href="#配置事务管理模板"></a> 配置事务管理模板</h4><pre><code class="highlight plaintext">&lt;!-- 配置事务管理的模板 --&gt;&lt;bean id=&quot;transactionTemplate&quot; class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt;    &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;&lt;/bean&gt;</code></pre><h4 id="注入事务管理模板"><a class="markdownIt-Anchor" href="#注入事务管理模板"></a> 注入事务管理模板</h4><p>在需要在进行事务管理的类中，注入事务管理的模板</p><pre><code class="highlight plaintext">&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.demo1.AccountServiceImpl&quot;&gt;    &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;    &lt;property name=&quot;transactionTemplate&quot; ref=&quot;transactionTemplate&quot;/&gt;&lt;/bean&gt;</code></pre><h4 id="在业务层使用模板管理事务"><a class="markdownIt-Anchor" href="#在业务层使用模板管理事务"></a> 在业务层使用模板管理事务</h4><pre><code class="highlight plaintext">        // 注入事务模板对象        private TransactionTemplate transactionTemplate;        public void setTransactionTemplate(TransactionTemplate transactionTemplate) &#123;            this.transactionTemplate = transactionTemplate;        &#125;        public void pay(final String out, final String in, final double money) &#123;            transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;                protected void doInTransactionWithoutResult(TransactionStatus status) &#123;                    // 扣钱                    accountDao.outMoney(out, money);                    int a = 10/0;                    // 加钱                    accountDao.inMoney(in, money);                &#125;            &#125;);        &#125;</code></pre><h3 id="声明式事务管理重点"><a class="markdownIt-Anchor" href="#声明式事务管理重点"></a> 声明式事务管理（重点）</h3><p>声明式事务管理又分成两种方式</p><ul><li>基于AspectJ的XML方式（重点掌握）</li><li>基于AspectJ的注解方式（重点掌握）</li></ul><h4 id="基于aspectj的xml方式"><a class="markdownIt-Anchor" href="#基于aspectj的xml方式"></a> 基于AspectJ的XML方式</h4><h5 id="maven依赖-2"><a class="markdownIt-Anchor" href="#maven依赖-2"></a> maven依赖</h5><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.lee&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;!-- spring ioc组件需要的依赖包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 基于AspectJ的aop依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;aopalliance&lt;/groupId&gt;            &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;            &lt;version&gt;1.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- spring 事务管理依赖包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--spring jdbc依赖包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- spring 单元测试组件包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 单元测试Junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- mysql数据库驱动包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.35&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- dbcp连接池的依赖包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;            &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;            &lt;version&gt;1.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--c3p0连接池--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.mchange&lt;/groupId&gt;            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;            &lt;version&gt;0.9.5.4&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;!-- 配置Maven的JDK编译级别 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><h5 id="数据库表"><a class="markdownIt-Anchor" href="#数据库表"></a> 数据库表</h5><p><img src="image/-2.png" alt="-2.png" /></p><h5 id="持久层"><a class="markdownIt-Anchor" href="#持久层"></a> 持久层</h5><ul><li>AccountDao</li></ul><pre><code class="highlight plaintext">package com.lee.dao;public interface AccountDao &#123;    void updateAccount(String name,double mony);    Double selectAccount(String name);&#125;</code></pre><ul><li>AccountDaoImpl</li></ul><pre><code class="highlight plaintext">package com.lee.dao;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowCallbackHandler;import org.springframework.jdbc.core.RowMapper;import org.springframework.stereotype.Repository;import javax.annotation.Resource;import java.sql.ResultSet;import java.sql.SQLException;@Repositorypublic class AccountDaoImpl implements AccountDao &#123;    @Resource    JdbcTemplate jdbcTemplate;    //根据名字修改金钱    public void updateAccount(String name, double money) &#123;        jdbcTemplate.update(&quot;update account set money = ? where name = ? &quot;, money, name);    &#125;    //根据名字查金钱    public Double selectAccount(String name) &#123;        Double money = jdbcTemplate.queryForObject(&quot;select money from account where name = ?&quot;, new BeanMapper(),name);        return money;    &#125;    class BeanMapper implements RowMapper&lt;Double&gt; &#123;        public Double mapRow(ResultSet rs, int arg1) throws SQLException &#123;            return rs.getDouble(&quot;money&quot;);        &#125;    &#125;&#125;</code></pre><h5 id="业务层"><a class="markdownIt-Anchor" href="#业务层"></a> 业务层</h5><ul><li>AccountService</li></ul><pre><code class="highlight plaintext">package com.lee.service;public interface AccountService &#123;    void transfer(String form,String to,double money);&#125;</code></pre><ul><li>AccountServiceImpl</li></ul><pre><code class="highlight plaintext">package com.lee.service;import com.lee.dao.AccountDao;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Servicepublic class AccountServiceImpl implements AccountService &#123;    @Resource    AccountDao dao;    @Override    public void transfer(String form, String to, double money) &#123;        //给from减去金额        double money1 = dao.selectAccount(form);        dao.updateAccount(form,money1-money);        System.out.println(1/0);        //给to加上金额        double money2 = dao.selectAccount(to);        dao.updateAccount(to,money2+money);    &#125;&#125;</code></pre><h5 id="spring-配置"><a class="markdownIt-Anchor" href="#spring-配置"></a> spring 配置</h5><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd       http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.lee&quot;&gt;&lt;/context:component-scan&gt;    &lt;!--配置Spring内置数据源dataSource--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/leetest?characterEncoding=UTF-8&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;    &lt;/bean&gt;    &lt;!--spring管理模板类 --&gt;    &lt;bean id=&quot;JdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!--基于AspectJ + XML方式实现声明式事务--&gt;    &lt;!--配置平台事务管理器DataSourceTransactionManager--&gt;    &lt;!--底层实际还是使用jdbc进行事务管理--&gt;    &lt;bean id=&quot;TransactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!--事务通知--&gt;    &lt;!--tx:advice：对应的处理器类就是TransactionInterceptor类（实现MethodInterceptor环绕通知接口）--&gt;    &lt;!--TransactionInterceptor类实现事务是通过transaction-manager属性指定的值实现事务管理的--&gt;    &lt;tx:advice id=&quot;txAdvice&quot;  transaction-manager=&quot;TransactionManager&quot;&gt;        &lt;!--设置事务管理信息（隔离级别，传播行为）--&gt;        &lt;tx:attributes&gt;            &lt;!--name：要管理的方法名，可以使用通配符*--&gt;            &lt;!--isolation:隔离级别，一般使用默认--&gt;            &lt;!--propagation:事务传播行为：增删改一般使用required，查询一般使用read-only--&gt;            &lt;tx:method name=&quot;trans*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot;/&gt;                        &lt;!--该标签可以写多条--&gt;            &lt;tx:method name=&quot;query*&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!--配置aop--&gt;    &lt;aop:config&gt;        &lt;!--使用advisor的原因是我们使用的advice不是自己写的--&gt;        &lt;!--aop:advisor标签使用的是传统spring aop开发方式实现的--&gt;        &lt;!--spring已经提前实现了该增强功能，spring使用的是MethodInterceptor（环绕通知）接口的方式--&gt;        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* *..*.*ServiceImpl.*(..))&quot;/&gt;&lt;!--        这里不使用aspect的原因是aspect自由度更高，当我们自定义实现advice的时候使用aspect--&gt;&lt;!--        &lt;aop:aspect ref=&quot;txAdvice&quot;&gt;--&gt;&lt;!--            &lt;aop:around method=&quot;&quot; pointcut=&quot;execution(* *..*.*ServiceImpl.*(..))&quot;/&gt;--&gt;&lt;!--        &lt;/aop:aspect&gt;--&gt;    &lt;/aop:config&gt;&lt;/beans&gt;</code></pre><h5 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h5><pre><code class="highlight plaintext">import com.lee.service.AccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:ApplicationContext.xml&quot;)public class TestSpring &#123;    @Resource    AccountService service;    @Test    public void test2()&#123;        service.transfer(&quot;李博&quot;,&quot;李菊&quot;,200);    &#125;&#125;</code></pre><p>加上事务管理后，如果程序报错，则转账双方的金额都不会改变</p><h5 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h5><p><strong>源码入口</strong></p><p>此处需要了解TxAdviceBeanDefinitionParser的继承体系，TxAdviceBeanDefinitionParseràAbstractSingleBeanDefinitionParseràAbstractBeanDefinitionParser，因为根据上面loadBeanDefinitions流程源码分析，我们知道自定义元素的解析工作是从一个namespaceHandler.parser方法开始的，该方法在AbstractBeanDefinitionParser类中</p><p><img src="image/-3.png" alt="-3.png" /></p><p><img src="image/-4.png" alt="-4.png" /></p><p>我们重点关心如何获取BeanDefinition对象的，所以接下来，我们进入parseInternal方法，该方法在AbstractSingleBeanDefinitionParser中（参考上面继承体系）</p><p><img src="image/-5.png" alt="-5.png" /></p><p>接下来，我们来到了TxAdviceBeanDefinitionParser类，因为getBeanClass方法和doParser方法都在该类里面</p><p><img src="image/-6.png" alt="-6.png" /></p><p>此时我们重点了解一下TransactionInterceptor这个类，它是我们分析的最终目标</p><p><img src="image/-7.png" alt="-7.png" /></p><p>invokeWithInTransaction方法在TransactionInterceptor类的父类TransactionAspectSupport中：</p><p><img src="image/-8.png" alt="-8.png" /></p><p>对于事务源码，了解到此处基本上可以了，如果想再了解事务是如何开启和提交的，请继续往下看，接下来我们进入createTransactionIfNecessary方法看看，事务是如何开启的</p><p><img src="image/-9.png" alt="-9.png" /></p><p>我们进入AbstractPlatformTransactionManager中的getTransaction方法继续了解事务是如何开启的：</p><p><img src="image/-10.png" alt="-10.png" /></p><p>接下来，该进入doBegin方法了，不过该方法在具体的平台事务管理器的子类中，我们此处使用DataSourceTransactionManager子类进行源码跟踪</p><p><img src="image/-11.png" alt="-11.png" /></p><p>DataSourceTransactionManager的事务管理是通过底层的JDBC代码实现的，但是不同的平台事务管理器，它们底层的事务处理也是不同的</p><h4 id="基于aspectj的注解方式"><a class="markdownIt-Anchor" href="#基于aspectj的注解方式"></a> 基于AspectJ的注解方式</h4><p><strong>service类上或者方法上加注解：</strong></p><ul><li>类上加@Transactional：表示该类中所有的方法都被事务管理</li><li>方法上加@Transactional：表示只有该方法被事务管理</li></ul><pre><code class="highlight plaintext">package com.lee.service;import com.lee.dao.AccountDao;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import javax.annotation.Resource;//@Transactional：标记改类的所有方法都已经被事务管理了，至于管理属性，不设置的话，都采取默认值@Transactional@Servicepublic class AccountServiceImpl implements AccountService &#123;    @Resource    AccountDao dao;    @Override    public void transfer(String form, String to, double money) &#123;        //给from减去金额        double money1 = dao.selectAccount(form);        dao.updateAccount(form,money1-money);        System.out.println(1/0);        //给to加上金额        double money2 = dao.selectAccount(to);        dao.updateAccount(to,money2+money);    &#125;&#125;</code></pre><p><strong>开启事务注解：</strong></p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd       http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.lee&quot;&gt;&lt;/context:component-scan&gt;    &lt;!--配置Spring内置数据源dataSource--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/leetest?characterEncoding=UTF-8&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;    &lt;/bean&gt;    &lt;!--spring管理模板类 --&gt;    &lt;bean id=&quot;JdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置平台事务管理器DataSourceTransactionManager--&gt;    &lt;!--底层实际还是使用jdbc进行事务管理--&gt;    &lt;bean id=&quot;TransactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!--开启事务注解--&gt;    &lt;tx:annotation-driven transaction-manager=&quot;TransactionManager&quot;/&gt;&lt;/beans&gt;</code></pre><p><strong>@Transactional注解就相当于以下的配置，即使用注解后，以下代码就可以省略</strong></p><pre><code class="highlight plaintext">  &lt;!--事务通知--&gt;    &lt;!--tx:advice：对应的处理器类就是TransactionInterceptor类（实现MethodInterceptor环绕通知接口）--&gt;    &lt;!--TransactionInterceptor类实现事务是通过transaction-manager属性指定的值实现事务管理的--&gt;    &lt;tx:advice id=&quot;txAdvice&quot;  transaction-manager=&quot;TransactionManager&quot;&gt;        &lt;!--设置事务管理信息（隔离级别，传播行为）--&gt;        &lt;tx:attributes&gt;            &lt;!--name：要管理的方法名，可以使用通配符*--&gt;            &lt;!--isolation:隔离级别，一般使用默认--&gt;            &lt;!--propagation:事务传播行为：增删改一般使用required，查询一般使用read-only--&gt;            &lt;tx:method name=&quot;trans*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!--配置aop--&gt;    &lt;aop:config&gt;        &lt;!--使用advisor的原因是我们使用的advice不是自己写的--&gt;        &lt;!--aop:advisor标签使用的是传统spring aop开发方式实现的--&gt;        &lt;!--spring已经提前实现了该增强功能，spring使用的是MethodInterceptor（环绕通知）接口的方式--&gt;        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* *..*.*ServiceImpl.*(..))&quot;/&gt;&lt;!--        这里不使用aspect的原因是aspect自由度更高，当我们自定义实现advice的时候使用aspect--&gt;&lt;!--        &lt;aop:aspect ref=&quot;txAdvice&quot;&gt;--&gt;&lt;!--            &lt;aop:around method=&quot;&quot; pointcut=&quot;execution(* *..*.*ServiceImpl.*(..))&quot;/&gt;--&gt;&lt;!--        &lt;/aop:aspect&gt;--&gt;    &lt;/aop:config&gt;</code></pre><h3 id="使用声明式事务"><a class="markdownIt-Anchor" href="#使用声明式事务"></a> 使用声明式事务</h3><p>使用Spring操作JDBC虽然方便，但是我们在前面讨论JDBC的时候，讲到过JDBC事务，如果要在Spring中操作事务，没必要手写JDBC事务，可以使用Spring提供的高级接口来操作事务。</p><p>Spring提供了一个PlatformTransactionManager来表示事务管理器，所有的事务都由它负责管理。而事务由TransactionStatus表示。如果手写事务代码，使用try…catch如下：</p><pre><code class="highlight plaintext">TransactionStatus tx = null;try &#123;    // 开启事务:    tx = txManager.getTransaction(new DefaultTransactionDefinition());    // 相关JDBC操作:    jdbcTemplate.update(&quot;...&quot;);    jdbcTemplate.update(&quot;...&quot;);    // 提交事务:    txManager.commit(tx);&#125; catch (RuntimeException e) &#123;    // 回滚事务:    txManager.rollback(tx);    throw e;&#125;</code></pre><p>Spring为啥要抽象出PlatformTransactionManager和TransactionStatus？原因是JavaEE除了提供JDBC事务外，它还支持分布式事务JTA（Java Transaction API）。分布式事务是指多个数据源（比如多个数据库，多个消息系统）要在分布式环境下实现事务的时候，应该怎么实现。分布式事务实现起来非常复杂，简单地说就是通过一个分布式事务管理器实现两阶段提交，但本身数据库事务就不快，基于数据库事务实现的分布式事务就慢得难以忍受，所以使用率不高。</p><p>Spring为了同时支持JDBC和JTA两种事务模型，就抽象出PlatformTransactionManager。因为我们的代码只需要JDBC事务，因此，在AppConfig中，需要再定义一个PlatformTransactionManager对应的Bean，它的实际类型是DataSourceTransactionManager：</p><pre><code class="highlight plaintext">@Configuration@ComponentScan@PropertySource(&quot;jdbc.properties&quot;)public class AppConfig &#123;    ...    @Bean    PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) &#123;        return new DataSourceTransactionManager(dataSource);    &#125;&#125;</code></pre><p>使用编程的方式使用Spring事务仍然比较繁琐，更好的方式是通过声明式事务来实现。使用声明式事务非常简单，除了在AppConfig中追加一个上述定义的PlatformTransactionManager外，再加一个@EnableTransactionManagement就可以启用声明式事务：</p><pre><code class="highlight plaintext">@Configuration@ComponentScan@EnableTransactionManagement // 启用声明式@PropertySource(&quot;jdbc.properties&quot;)public class AppConfig &#123;    ...&#125;</code></pre><p>然后，对需要事务支持的方法，加一个@Transactional注解：</p><pre><code class="highlight plaintext">@Componentpublic class UserService &#123;    // 此public方法自动具有事务支持:    @Transactional    public User register(String email, String password, String name) &#123;       ...    &#125;&#125;</code></pre><p>或者更简单一点，直接在Bean的class处加上，表示所有public方法都具有事务支持：</p><pre><code class="highlight plaintext">@Component@Transactionalpublic class UserService &#123;    ...&#125;</code></pre><p>Spring对一个声明式事务的方法，如何开启事务支持？原理仍然是AOP代理，即通过自动创建Bean的Proxy实现：</p><pre><code class="highlight plaintext">public class UserService$$EnhancerBySpringCGLIB extends UserService &#123;    UserService target = ...    PlatformTransactionManager txManager = ...    public User register(String email, String password, String name) &#123;        TransactionStatus tx = null;        try &#123;            tx = txManager.getTransaction(new DefaultTransactionDefinition());            target.register(email, password, name);            txManager.commit(tx);        &#125; catch (RuntimeException e) &#123;            txManager.rollback(tx);            throw e;        &#125;    &#125;    ...&#125;</code></pre><blockquote><p>注意：声明了@EnableTransactionManagement后，不必额外添加@EnableAspectJAutoProxy。</p></blockquote><h4 id="回滚事务"><a class="markdownIt-Anchor" href="#回滚事务"></a> 回滚事务</h4><p>默认情况下，如果发生了RuntimeException，Spring的声明式事务将自动回滚。在一个事务方法中，如果程序判断需要回滚事务，只需抛出RuntimeException，例如：</p><pre><code class="highlight plaintext">@Transactionalpublic buyProducts(long productId, int num) &#123;    ...    if (store &lt; num) &#123;        // 库存不够，购买失败:        throw new IllegalArgumentException(&quot;No enough products&quot;);    &#125;    ...&#125;</code></pre><p>如果要针对Checked Exception回滚事务，需要在@Transactional注解中写出来：</p><pre><code class="highlight plaintext">@Transactional(rollbackFor = &#123;RuntimeException.class, IOException.class&#125;)public buyProducts(long productId, int num) throws IOException &#123;    ...&#125;</code></pre><p>上述代码表示在抛出RuntimeException或IOException时，事务将回滚。</p><p>为了简化代码，我们强烈建议业务异常体系从RuntimeException派生，这样就不必声明任何特殊异常即可让Spring的声明式事务正常工作：</p><pre><code class="highlight plaintext">public class BusinessException extends RuntimeException &#123;    ...&#125;public class LoginException extends BusinessException &#123;    ...&#125;public class PaymentException extends BusinessException &#123;    ...&#125;</code></pre><h4 id="事务边界"><a class="markdownIt-Anchor" href="#事务边界"></a> 事务边界</h4><p>在使用事务的时候，明确事务边界非常重要。对于声明式事务，例如，下面的register()方法：</p><pre><code class="highlight plaintext">@Componentpublic class UserService &#123;    @Transactional    public User register(String email, String password, String name) &#123; // 事务开始       ...    &#125; // 事务结束&#125;</code></pre><p>它的事务边界就是register()方法开始和结束。</p><p>类似的，一个负责给用户增加积分的addBonus()方法：</p><pre><code class="highlight plaintext">@Componentpublic class BonusService &#123;    @Transactional    public void addBonus(long userId, int bonus) &#123; // 事务开始       ...    &#125; // 事务结束&#125;</code></pre><p>它的事务边界就是addBonus()方法开始和结束。</p><p>在现实世界中，问题总是要复杂一点点。用户注册后，能自动获得100积分，因此，实际代码如下：</p><pre><code class="highlight plaintext">@Componentpublic class UserService &#123;    @Autowired    BonusService bonusService;    @Transactional    public User register(String email, String password, String name) &#123;        // 插入用户记录:        User user = jdbcTemplate.insert(&quot;...&quot;);        // 增加100积分:        bonusService.addBonus(user.id, 100);    &#125;&#125;</code></pre><p>现在问题来了：调用方（比如RegisterController）调用UserService.register()这个事务方法，它在内部又调用了BonusService.addBonus()这个事务方法，一共有几个事务？如果addBonus()抛出了异常需要回滚事务，register()方法的事务是否也要回滚？</p><h4 id="事务传播"><a class="markdownIt-Anchor" href="#事务传播"></a> 事务传播</h4><p>要解决上面的问题，我们首先要定义事务的传播模型。</p><p>假设用户注册的入口是RegisterController，它本身没有事务，仅仅是调用UserService.register()这个事务方法：</p><pre><code class="highlight plaintext">@Controllerpublic class RegisterController &#123;    @Autowired    UserService userService;    @PostMapping(&quot;/register&quot;)    public ModelAndView doRegister(HttpServletRequest req) &#123;        String email = req.getParameter(&quot;email&quot;);        String password = req.getParameter(&quot;password&quot;);        String name = req.getParameter(&quot;name&quot;);        User user = userService.register(email, password, name);        return ...    &#125;&#125;</code></pre><p>因此，UserService.register()这个事务方法的起始和结束，就是事务的范围。</p><p>我们需要关心的问题是，在UserService.register()这个事务方法内，调用BonusService.addBonus()，我们期待的事务行为是什么：</p><pre><code class="highlight plaintext">@Transactionalpublic User register(String email, String password, String name) &#123;    // 事务已开启:    User user = jdbcTemplate.insert(&quot;...&quot;);    // ???:    bonusService.addBonus(user.id, 100);&#125; // 事务结束</code></pre><p>对于大多数业务来说，我们期待BonusService.addBonus()的调用，和UserService.register()应当融合在一起，它的行为应该如下：</p><p>UserService.register()已经开启了一个事务，那么在内部调用BonusService.addBonus()时，BonusService.addBonus()方法就没必要再开启一个新事务，直接加入到BonusService.register()的事务里就好了。</p><p>其实就相当于：</p><ol><li>UserService.register()先执行了一条INSERT语句：INSERT INTO users …</li><li>BonusService.addBonus()再执行一条INSERT语句：INSERT INTO bonus …</li></ol><p>因此，Spring的声明式事务为事务传播定义了几个级别，<strong>默认传播级别就是REQUIRED</strong>，它的意思是，<strong>如果当前没有事务，就创建一个新事务，如果当前有事务，就加入到当前事务中执行</strong>。</p><p>我们观察UserService.register()方法，它在RegisterController中执行，因为RegisterController没有事务，因此，UserService.register()方法会自动创建一个新事务。</p><p>在UserService.register()方法内部，调用BonusService.addBonus()方法时，因为BonusService.addBonus()检测到当前已经有事务了，因此，它会加入到当前事务中执行。</p><p>因此，整个业务流程的事务边界就清晰了：它只有一个事务，并且范围就是UserService.register()方法。</p><p>有的童鞋会问：把BonusService.addBonus()方法的@Transactional去掉，变成一个普通方法，那不就规避了复杂的传播模型吗？</p><p>去掉BonusService.addBonus()方法的@Transactional，会引来另一个问题，即其他地方如果调用BonusService.addBonus()方法，那就没法保证事务了。例如，规定用户登录时积分+5：</p><pre><code class="highlight plaintext">@Controllerpublic class LoginController &#123;    @Autowired    BonusService bonusService;    @PostMapping(&quot;/login&quot;)    public ModelAndView doLogin(HttpServletRequest req) &#123;        User user = ...        bonusService.addBonus(user.id, 5);    &#125;&#125;</code></pre><p>可见，BonusService.addBonus()方法必须要有@Transactional，否则，登录后积分就无法添加了。</p><p>默认的事务传播级别是REQUIRED，它满足绝大部分的需求。还有一些其他的传播级别：</p><ul><li>SUPPORTS：表示如果有事务，就加入到当前事务，如果没有，那也不开启事务执行。这种传播级别可用于查询方法，因为SELECT语句既可以在事务内执行，也可以不需要事务；</li><li>MANDATORY：表示必须要存在当前事务并加入执行，否则将抛出异常。这种传播级别可用于核心更新逻辑，比如用户余额变更，它总是被其他事务方法调用，不能直接由非事务方法调用；</li><li>REQUIRES_NEW：表示不管当前有没有事务，都必须开启一个新的事务执行。如果当前已经有事务，那么当前事务会挂起，等新事务完成后，再恢复执行；</li><li>NOT_SUPPORTED：表示不支持事务，如果当前有事务，那么当前事务会挂起，等这个方法执行完成后，再恢复执行；</li><li>NEVER：和NOT_SUPPORTED相比，它不但不支持事务，而且在监测到当前有事务时，会抛出异常拒绝执行；</li><li>NESTED：表示如果当前有事务，则开启一个嵌套级别事务，如果当前没有事务，则开启一个新事务。</li></ul><p>定义事务的传播级别也是写在@Transactional注解里的：</p><pre><code class="highlight plaintext">@Transactional(propagation = Propagation.REQUIRES_NEW)public Product createProduct() &#123;    ...&#125;</code></pre><p>现在只剩最后一个问题了：Spring是如何传播事务的？</p><p>我们在JDBC中使用事务的时候，是这么个写法：</p><pre><code class="highlight plaintext">Connection conn = openConnection();try &#123;    // 关闭自动提交:    conn.setAutoCommit(false);    // 执行多条SQL语句:    insert(); update(); delete();    // 提交事务:    conn.commit();&#125; catch (SQLException e) &#123;    // 回滚事务:    conn.rollback();&#125; finally &#123;    conn.setAutoCommit(true);    conn.close();&#125;</code></pre><p>Spring使用声明式事务，最终也是通过执行JDBC事务来实现功能的，那么，一个事务方法，如何获知当前是否存在事务？</p><p>答案是使用ThreadLocal。Spring总是把JDBC相关的Connection和TransactionStatus实例绑定到ThreadLocal。如果一个事务方法从ThreadLocal未取到事务，那么它会打开一个新的JDBC连接，同时开启一个新的事务，否则，它就直接使用从ThreadLocal获取的JDBC连接以及TransactionStatus。</p><p>因此，事务能正确传播的前提是，方法调用是在一个线程内才行。如果像下面这样写：</p><pre><code class="highlight plaintext">@Transactionalpublic User register(String email, String password, String name) &#123; // BEGIN TX-A    User user = jdbcTemplate.insert(&quot;...&quot;);    new Thread(() -&gt; &#123;        // BEGIN TX-B:        bonusService.addBonus(user.id, 100);        // END TX-B    &#125;).start();&#125; // END TX-A</code></pre><p>在另一个线程中调用BonusService.addBonus()，它根本获取不到当前事务，因此，UserService.register()和BonusService.addBonus()两个方法，将分别开启两个完全独立的事务。</p><p>换句话说，事务只能在当前线程传播，无法跨线程传播。</p><p>那如果我们想实现跨线程传播事务呢？原理很简单，就是要想办法把当前线程绑定到ThreadLocal的Connection和TransactionStatus实例传递给新线程，但实现起来非常复杂，根据异常回滚更加复杂，不推荐自己去实现。</p>]]>
    </content>
    <id>http://example.com/2023/03/29/Spring_JDBC-%E4%BA%8B%E5%8A%A1/</id>
    <link href="http://example.com/2023/03/29/Spring_JDBC-%E4%BA%8B%E5%8A%A1/"/>
    <published>2023-03-29T04:00:00.000Z</published>
    <summary>Spring JDBC就是指spring自身对jdbc的代码进行了一些封装，使得使用更加的简单，方便，快捷。</summary>
    <title>Spring JDBC/事务</title>
    <updated>2026-02-26T09:22:10.910Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    <content>
      <![CDATA[<h1 id="spring-mvc"><a class="markdownIt-Anchor" href="#spring-mvc"></a> $Spring MVC</h1><h1 id="spring-mvc-2"><a class="markdownIt-Anchor" href="#spring-mvc-2"></a> Spring MVC</h1><ul><li><a href="">Spring MVC</a><ul><li><a href="">MVC简介</a><ul><li><a href="">MVC模式简介</a></li><li><a href="">什么是Spring MVC</a></li><li><a href="">核心组件/处理流程</a></li></ul></li><li><a href="">springMVC架构</a><ul><li><a href="">架构流程</a></li><li><a href="">组件说明</a></li><li><a href="">默认配置文件</a></li></ul></li><li><a href="">spring MVC应用</a><ul><li><a href="">搭建Spring Web MVC环境（IDEA）</a><ul><li><a href="">maven创建spring mvc项目</a></li><li><a href="">添加依赖的jar�</a>�</li></ul></li><li><a href="">Spring MVC配置文件</a></li><li><a href="">配置DispatcherServlet（web.xml）</a></li><li><a href="">编写处理器Handler（Controller）</a><ul><li><a href="">方式一（接口方式）</a></li><li><a href="">方式二（注解方式）</a></li></ul></li><li><a href="">创建视图</a><ul><li><a href="">ModelAndView组件</a><ul><li><a href="">Model和ModelMap</a></li><li><a href="">ModelAndView和Model的区别</a></li></ul></li><li><a href="">ViewResolver组件</a></li></ul></li><li><a href="">配置tomcat部署项目</a></li><li><a href="">设置引导页</a></li></ul></li><li><a href="">SpringMVC详解</a><ul><li><a href="">@RequestMapping注解</a><ul><li><a href="">属性</a><ul><li><a href="">value属性</a></li><li><a href="">methods/consumes/produces/params/headers/path属性</a></li></ul></li><li><a href="">@RequestMapping源码解析</a></li><li><a href="">@RequestMapping快捷方式</a></li></ul></li><li><a href="">@Controller注解应用</a></li><li><a href="">请求参数值绑定</a><ul><li><a href="">什么是请求参数绑定</a></li><li><a href="">默认支持的参数类型</a></li><li><a href="">直接绑定</a><ul><li><a href="">绑定基本类型</a></li><li><a href="">绑定pojo类型</a></li><li><a href="">绑定包装pojo</a></li><li><a href="">使用简单类型数组</a></li><li><a href="">使用pojo类型集合或者数组</a></li><li><a href="">自定义参数绑定</a></li></ul></li><li><a href="">注解绑定</a><ul><li><a href="">@RequestParam</a></li><li><a href="">@PathVariable</a></li><li><a href="">@RequestBody</a></li></ul></li><li><a href="">传参校验</a><ul><li><a href="">使用@Valid</a></li><li><a href="">自定义校验标签</a></li></ul></li><li><a href="">自定义参数绑定</a></li></ul></li><li><a href="">向页面传值</a><ul><li><a href="">1.使用request.setAttribute方法</a></li><li><a href="">2.ModeAndView对象</a></li><li><a href="">3.ModelMap参数</a></li><li><a href="">4.@ModelAttribute</a></li><li><a href="">5.Sessioin存储</a></li></ul></li><li><a href="">Controller返回值</a><ul><li><a href="">不用注解修饰</a><ul><li><a href="">返回ModelAndView</a></li><li><a href="">返回void</a></li><li><a href="">返回字符串（推荐）</a><ul><li><a href="">逻辑视图名</a></li><li><a href="">redirect重定向</a></li><li><a href="">forward转发</a></li></ul></li></ul></li><li><a href="">使用注解修饰@ResponseBody</a><ul><li><a href="">@RestController</a></li></ul></li></ul></li><li><a href="">@ControllerAdvice</a><ul><li><a href="">@ExceptionHandler</a></li><li><a href="">@InitBinder</a><ul><li><a href="">防止XSS注入</a></li></ul></li><li><a href="">@ModelAttribute</a></li></ul></li><li><a href="">bmi健康指数案例</a></li></ul></li><li><a href="">集成Filter</a></li><li><a href="">使用Interceptor</a><ul><li><a href="">处理异常</a></li></ul></li><li><a href="">处理CORS</a><ul><li><a href="">使用@CrossOrigin</a></li><li><a href="">使用CorsRegistry</a></li><li><a href="">使用CorsFilter</a></li></ul></li><li><a href="">异步处理</a><ul><li><a href="">Filter处理</a></li></ul></li><li><a href="">使用WebSocket</a><ul><li><a href="">处理WebSocket连接</a></li><li><a href="">客户端开发</a></li></ul></li><li><a href="">使用Scheduler</a><ul><li><a href="">使用Cron任务</a></li><li><a href="">集成Quarz</a></li></ul></li><li><a href="">Spring MVC源码解析</a><ul><li><a href="">知识储备</a><ul><li><a href="">Servlet的生命周期方法</a></li><li><a href="">DispatcherServlet继承体系</a></li><li><a href="">InitializingBean接口介绍</a></li></ul></li><li><a href="">主流程DispatcherServlet</a></li><li><a href="">处理器映射器</a></li><li><a href="">处理器适配器</a></li><li><a href="">视图解析器</a></li><li><a href="">mvc:annotation-driver</a></li><li><a href="">异常处理流程</a></li><li><a href="">文件上传流程</a></li></ul></li></ul></li><li><a href="">SSM整合</a><ul><li><a href="">系统分层</a><ul><li><a href="">如何分层</a><ul><li><a href="">表现层</a></li><li><a href="">业务层Service</a></li><li><a href="">持久层DAO</a></li></ul></li></ul></li><li><a href="">SSM框架整合</a><ul><li><a href="">整合思路</a></li><li><a href="">工程搭建（maven依赖）</a></li><li><a href="">工程整合（配置文件）</a><ul><li><a href="">web.xml</a></li><li><a href="">整合mapper</a></li><li><a href="">整合Service</a></li><li><a href="">整合controller</a></li></ul></li><li><a href="">整合测试（编写代码）</a><ul><li><a href="">数据库</a></li><li><a href="">持久层</a><ul><li><a href="">pojo</a></li><li><a href="">mapper</a></li></ul></li><li><a href="">业务层</a></li><li><a href="">表现层</a></li></ul></li></ul></li><li><a href="">实战技巧</a><ul><li><a href="">中文乱码解决方案</a><ul><li><a href="">数据库乱码</a></li><li><a href="">解决get乱码</a></li><li><a href="">解决post乱码</a></li><li><a href="">jsp乱码</a></li><li><a href="">@responsebody 乱码</a></li><li><a href="">html页面编码</a></li></ul></li><li><a href="">拦截器</a><ul><li><a href="">什么是拦截器</a></li><li><a href="">如何写一个拦截器</a></li><li><a href="">定义拦截器（实现登陆检查）</a><ul><li><a href="">先定义拦截器</a></li><li><a href="">配置拦截器</a></li></ul></li><li><a href="">session验证案例</a><ul><li><a href="">Controller</a></li><li><a href="">定义与配置拦截器</a></li></ul></li></ul></li><li><a href="">异常处理</a><ul><li><a href="">异常概念</a></li><li><a href="">异常处理思路</a></li><li><a href="">使用SimpleMappingExceptionResolver</a></li><li><a href="">实现HandlerExceptionResolver接口自定义异常处理器</a></li><li><a href="">@ExceptionHandler注解实现异常处理</a></li><li><a href="">@ResponseStatus</a></li><li><a href="">对于框架内部异常或代码无法捕获的异常</a></li></ul></li><li><a href="">文件上�</a>�<ul><li><a href="">SpringMVC文件上传简介</a></li><li><a href="">CommonsMultipartResolver组件</a></li><li><a href="">实现步骤</a></li><li><a href="">限制文件上传类型</a></li></ul></li><li><a href="">文件下载</a></li><li><a href="">JSON数据交互</a><ul><li><a href="">kv/json</a></li><li><a href="">json/json</a></li></ul></li><li><a href="">Mock测试（模拟测试）</a><ul><li><a href="">Mock各模块介绍</a></li><li><a href="">MockMVC使用</a></li></ul></li><li><a href="">RESTful支持</a><ul><li><a href="">介绍</a></li><li><a href="">springMVC对RESTful的支持</a></li><li><a href="">静态资源访问``</a></li></ul></li><li><a href="">SpringMVC父子容器</a></li><li><a href="">跨域处理</a><ul><li><a href="">CORS</a></li><li><a href="">CORS请求分类</a><ul><li><a href="">简单请求</a></li><li><a href="">非简单请求</a></li></ul></li><li><a href="">CORS实现</a><ul><li><a href="">跨域提交Cookie</a></li><li><a href="">跨域提交Cookie</a></li></ul></li></ul></li><li><a href="">@PathVariable和@RequestParam的区别</a></li></ul></li></ul></li></ul><h2 id="mvc简介"><a class="markdownIt-Anchor" href="#mvc简介"></a> MVC简介</h2><h3 id="mvc模式简介"><a class="markdownIt-Anchor" href="#mvc模式简介"></a> MVC模式简介</h3><p>是一种用于设计创建web应用程序表现层的模式</p><ul><li>M-<strong>Model</strong>模型<ul><li>模型（Model）的职责是负责业务逻辑，模型包含业务模型和数据模型，数据模型用于封装数据，业务模型用于处理业务</li></ul></li><li>V-<strong>View</strong>视图<ul><li>视图（View）的职责是负责显示界面和用户交互（手机用户信息），属于视图的组件是不包含业务逻辑和控制逻辑的JSP</li></ul></li><li>C-<strong>Controller</strong>控制器<ul><li>控制器是模型层M和视图层V之间的桥梁，用于控制流程，比如：在Servlet项目中的单一控制器ActionServlet</li><li>是应用程序中处理用户交互的部分。作用一般就是处理程序逻辑的</li></ul></li><li><h2 id="关系图"><a class="markdownIt-Anchor" href="#关系图"></a> 关系图</h2></li></ul><h3 id="什么是spring-mvc"><a class="markdownIt-Anchor" href="#什么是spring-mvc"></a> 什么是Spring MVC</h3><ul><li>Spring MVC是Spring框架一个非常重要的功能模块，实现了MVC结构，便于简单，快速开发MVC结构的Web程序，Spring Web MVC提供的API封装了Web开发中常用的功能，简化了Web过程。</li><li>springMVC是为了解决表现层问题的web框架，他们都是基于MVC设计模式的，表现层的主要职责就是处理前端HTTP请求</li><li></li></ul><p><strong>优点</strong></p><ul><li>轻量</li><li>高效</li><li>与spring兼容好</li><li>功能强大</li><li>简洁灵活</li></ul><p><strong>功能</strong></p><p>清晰的角色划分</p><ul><li>控制器（controller）、验证器（validator）、 命令对象（command object）、表单对象（form object）、模型对象（model object）、 Servlet分发器（DispatcherServlet）、 处理器映射（handler mapping）、视图解析器（view resolver）等等。 每一个角色都可以由一个专门的对象来实现</li></ul><p>强大而直接的配置方式</p><ul><li>将框架类和应用程序类都能作为JavaBean配置，支持跨多个context的引用，例如，在web控制器中对业务对象和验证器（validator）的引用</li></ul><p>可适配，非侵入</p><ul><li>可以根据不同的应用常见，选择合适的控制器子类（simple型、command型、form型、wizard型、multi-action型或者自定义），而不是从单一控制器 （比如Action/ActionForm）继承</li></ul><p>可重用的业务代码</p><ul><li>可以使用现有的业务对象作为命令或表单对象，而不需要去扩展某个特定框架的基类</li></ul><p>可定制的绑定（binding） 和验证（validation）</p><ul><li>比如将类型不匹配作为应用级的验证错误， 这可以保存错误的值。再比如本地化的日期和数字绑定等等。在其他某些框架中，你只能使用字符串表单对象， 需要手动解析它并转换到业务对象</li></ul><p>可定制的handler mapping和view resolution</p><ul><li>Spring提供从最简单的URL映射， 到复杂的、专用的定制策略。与某些web MVC框架强制开发人员使用单一特定技术相比，Spring显得更加灵活</li></ul><p>灵活的model转换</p><ul><li>在Springweb框架中，使用基于Map的 键/值对来达到轻易地与各种视图技术的集成</li></ul><p>可定制的本地化和主题（theme）解析</p><ul><li>支持在JSP中可选择地使用Spring标签库、支持JSTL、支持Velocity（不需要额外的中间层）等等</li></ul><p>简单而强大的JSP标签库（Spring Tag Library）</p><ul><li>支持包括诸如数据绑定和主题（theme） 之类的许多功能。它提供在标记方面的最大灵活性</li></ul><p>JSP表单标签库</p><ul><li>在Spring2.0中引入的表单标签库，使得在JSP中编写 表单更加容易</li></ul><p>Spring Bean的生命周期可以被限制在当前的HTTP Request或者HTTP Session</p><ul><li>准确的说，这并非Spring MVC框架本身特性，而应归属于Sping MVC使用的WebApplicationContext容器。</li></ul><h3 id="核心组件处理流程"><a class="markdownIt-Anchor" href="#核心组件处理流程"></a> 核心组件/处理流程</h3><p><strong>核心组件</strong></p><ul><li><strong>DispatcherServlet</strong>（前端控制器，请求入口）<ul><li>接受请求，依据HandlerMapping的配置调用相应的模型来处理</li></ul></li><li><strong>HandlerMapping</strong>（控制器，请求派发）<ul><li>包含了请求路劲与模型的对应关系</li></ul></li><li><strong>Controller</strong>（处理器，请求处理流程）<ul><li>负责处理业务逻辑</li></ul></li><li><strong>ModelAndView</strong>（模型，封装业务处理结果和视图）<ul><li>封装了处理结果</li><li>注：处理结果除了数据之外，可能还有视图名</li></ul></li><li><strong>ViewResolver</strong>（视图解析器，视图显示处理器）<ul><li>DispatcherServlet依据ViewResolver的解析，调用真正的视图对象来生成相应的页面</li></ul></li></ul><p><strong>处理流程</strong></p><ul><li>浏览器向Spring发出请求，请求交给前端控制器<strong>DispatcherServlet</strong>通过<strong>HandlerMapping</strong>找到<strong>Controller</strong>组件处理请求</li><li>执行<strong>Controller</strong>组件约定方法处理请求，在约定方法调用模型组件完成业务处理，约定方法可以返回一个<strong>ModelAndView</strong>对象，封装了处理结果数据和视图名称信息</li><li><strong>DispatcherServlet</strong>控制器接受<strong>ModelAndView</strong>之后，调用<strong>ViewResolver</strong>组件，定位View(JSP)并传递数据信息，生成响应界面结果</li><li></li><li></li></ul><h2 id="springmvc架构"><a class="markdownIt-Anchor" href="#springmvc架构"></a> springMVC架构</h2><p>springMVC是基于MVC设计模式的，MVC模式指的就是Model(业务模型)，View(视图)，Controller(控制器)。SpringMVC处理请求就是通过MVC这三种角色实现的</p><p>不过千万不要把<strong>MVC设计模式</strong>和<strong>工程的三层结构</strong>混淆，三层结构指的是<strong>表现层</strong>，<strong>业务层</strong>，<strong>数据持久层</strong>；而MVC只针对<strong>表现层</strong>进行设计</p><h3 id="架构流程"><a class="markdownIt-Anchor" href="#架构流程"></a> 架构流程</h3><ol><li>用户发送请求至前端控制器DispatcherServlet</li><li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li><li>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li><li>DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</li><li>HandlerAdapter执行处理器(handler，也叫后端控制器)。</li><li>Controller执行完成返回ModelAndView</li><li>HandlerAdapter将handler执行结果ModelAndView返回给DispatcherServlet</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li><li>ViewReslover解析后返回具体View对象</li><li>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</li><li>DispatcherServlet响应用户</li></ol><h3 id="组件说明"><a class="markdownIt-Anchor" href="#组件说明"></a> 组件说明</h3><p><strong>DispatcherServlet</strong>：前端控制器</p><ul><li>用户请求到达前端控制器，它就相当于mvc模式中的C，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</li></ul><p><strong>HandlerMapping</strong>：处理器映射器</p><ul><li>HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</li></ul><p><strong>Handler</strong>：处理器</p><ul><li>Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。</li><li>由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</li></ul><p><strong>HandlAdapter</strong>：处理器适配器</p><ul><li>通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行</li></ul><p><strong>View Resolver</strong>：视图解析器</p><ul><li>View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。</li></ul><p><strong>View</strong>：视图</p><ul><li>springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。</li><li>一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面</li></ul><blockquote><p>说明：在springmvc的各个组件中，<strong>处理器映射器、处理器适配器、视图解析器</strong>称为springmvc的三大组件。</p></blockquote><blockquote><p>需要用户开发的组件有：处理器、视图</p></blockquote><h3 id="默认配置文件"><a class="markdownIt-Anchor" href="#默认配置文件"></a> 默认配置文件</h3><p>spring-webmvc-xxx.jar包中有一个DispatcherServlet.properties文件，该配置中默认加载了一些springmvc默认的其他组件，其中就包括三大组件</p><h2 id="spring-mvc应用"><a class="markdownIt-Anchor" href="#spring-mvc应用"></a> spring MVC应用</h2><h3 id="搭建spring-web-mvc环境idea"><a class="markdownIt-Anchor" href="#搭建spring-web-mvc环境idea"></a> 搭建Spring Web MVC环境（IDEA）</h3><h5 id="maven创建spring-mvc项目"><a class="markdownIt-Anchor" href="#maven创建spring-mvc项目"></a> maven创建spring mvc项目</h5><ul><li><p>在Idea中新建Maven项目，选择“org.apache.maven.archetypes:maven-archetype-webapp”骨架（模板），创建一个Web项目</p></li><li><p>输入项目的坐标</p></li><li><p>选择仓库位置与配置信息，建议使用默认设置（先使用IDEA的默认设置将Maven配置好）</p></li><li><p>输出项目位置，点完成</p></li><li><p>初始化的项目如下</p></li><li><p>根据Maven规范，需要创建源代码、资源与测试目录</p></li><li><p>在main上右键创建java目录、resources目录，创建与main平级的test测试目录：</p></li><li><p>设置目录的特殊属性</p></li><li><p>设置完成后的结果</p></li></ul><h5 id="添加依赖的jar包"><a class="markdownIt-Anchor" href="#添加依赖的jar包"></a> 添加依赖的jar包</h5><ul><li>导入Spring Web MVC相关开发包，主要有Spring框架核心库，Spring MVC，JSTL等<ul><li>pom.xml</li></ul></li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;com.zhangguo.springmvc01&lt;/groupId&gt;  &lt;artifactId&gt;SpringMVC01&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;  &lt;name&gt;SpringMVC01 Maven Webapp&lt;/name&gt;  &lt;!-- FIXME change it to the project&#x27;s website --&gt;  &lt;url&gt;http://www.example.com&lt;/url&gt;  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;    &lt;spring.version&gt;4.3.0.RELEASE&lt;/spring.version&gt;  &lt;/properties&gt;  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;4.11&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!--Spring框架核心库 --&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- Spring MVC --&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Servlet核心--&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;      &lt;version&gt;3.0.1&lt;/version&gt;      &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- JSTL --&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;jstl&lt;/artifactId&gt;      &lt;version&gt;1.2&lt;/version&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;build&gt;    &lt;finalName&gt;SpringMVC01&lt;/finalName&gt;    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;      &lt;plugins&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;          &lt;version&gt;3.0.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;          &lt;version&gt;3.0.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;          &lt;version&gt;3.7.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;          &lt;version&gt;2.20.1&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;          &lt;version&gt;3.2.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;          &lt;version&gt;2.5.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;          &lt;version&gt;2.8.2&lt;/version&gt;        &lt;/plugin&gt;      &lt;/plugins&gt;    &lt;/pluginManagement&gt;  &lt;/build&gt;&lt;/project&gt;</code></pre><p><strong>详细版pom依赖</strong></p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.lee&lt;/groupId&gt;    &lt;artifactId&gt;springmvcDemo&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;name&gt;springmvcDemo Maven Webapp&lt;/name&gt;    &lt;!-- FIXME change it to the project&#x27;s website --&gt;    &lt;url&gt;http://www.example.com&lt;/url&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;    &lt;/properties&gt;    &lt;!-- 持久层：mysql驱动、dbcp连接池、mybatis、mybatis和spring整合依赖、spring依赖 --&gt; &lt;!-- 业务层：aop相关依赖 --&gt;    &lt;dependencies&gt;        &lt;!-- spring ioc组件需要的依赖包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 基于AspectJ的aop依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;aopalliance&lt;/groupId&gt;            &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;            &lt;version&gt;1.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- spring 事务管理和JDBC依赖包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- spring 单元测试组件包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 单元测试Junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- mysql数据库驱动包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.35&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- dbcp连接池的依赖包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;            &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;            &lt;version&gt;1.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- mybatis依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.5&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- mybatis和spring的整合依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;1.3.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--spring mvc依赖包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--Servlet核心--&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;            &lt;version&gt;2.5&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- JSTL --&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;jstl&lt;/artifactId&gt;            &lt;version&gt;1.2&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;finalName&gt;springmvcDemo&lt;/finalName&gt;        &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;            &lt;plugins&gt;                &lt;!-- 配置Maven的JDK编译级别 --&gt;                &lt;plugin&gt;                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                    &lt;version&gt;3.2&lt;/version&gt;                    &lt;configuration&gt;                        &lt;source&gt;1.8&lt;/source&gt;                        &lt;target&gt;1.8&lt;/target&gt;                        &lt;encoding&gt;UTF-8&lt;/encoding&gt;                    &lt;/configuration&gt;                &lt;/plugin&gt;&lt;!--                &amp;lt;!&amp;ndash; 配置Tomcat插件 &amp;ndash;&amp;gt;--&gt;&lt;!--                &lt;plugin&gt;--&gt;&lt;!--                    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;--&gt;&lt;!--                    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;--&gt;&lt;!--                    &lt;version&gt;2.2&lt;/version&gt;--&gt;&lt;!--                    &lt;configuration&gt;--&gt;&lt;!--                        &lt;port&gt;8080&lt;/port&gt;--&gt;&lt;!--                        &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt;--&gt;&lt;!--                    &lt;/configuration&gt;--&gt;&lt;!--                &lt;/plugin&gt;--&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;                    &lt;version&gt;3.1.0&lt;/version&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;                    &lt;version&gt;3.0.2&lt;/version&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                    &lt;version&gt;3.8.0&lt;/version&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;                    &lt;version&gt;2.22.1&lt;/version&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;                    &lt;version&gt;3.2.2&lt;/version&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;                    &lt;version&gt;2.5.2&lt;/version&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;                    &lt;version&gt;2.8.2&lt;/version&gt;                &lt;/plugin&gt;            &lt;/plugins&gt;        &lt;/pluginManagement&gt;        &lt;!--maven默认不加载xml非resources目录下的xml文件，Mapper文件就无法加载，所以得加上如下配置--&gt;        &lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/java&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;/includes&gt;                &lt;filtering&gt;true&lt;/filtering&gt;            &lt;/resource&gt;        &lt;/resources&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><h3 id="spring-mvc配置文件"><a class="markdownIt-Anchor" href="#spring-mvc配置文件"></a> Spring MVC配置文件</h3><p>不配置 <code>&lt;mvc:annotation-driven/&gt;</code>也可以正常使用@RequestMapping注解的原因是，spring-webmvc-xxx.jar包中有一个DispatcherServlet.properties文件，该配置中默认加载了一些springmvc默认的其他组件，其中就包括三大组件<strong>HandlerMapping,HandlerAdapter,ViewResolver</strong></p><ul><li>在resource下添加Spring的XML配置文件<ul><li>名称可自定义，例如spring-mvc.xml</li></ul></li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;!--配置注解扫描,多个包中间使用半角逗号分隔 --&gt;    &lt;context:component-scan base-package=&quot;com.lee.controller&quot;/&gt;    &lt;!-- Spring MVC不处理静态资源 --&gt;    &lt;mvc:default-servlet-handler /&gt;    &lt;!--在spring中一般采用@RequestMapping注解来完成映射关系， 要想使@RequestMapping注解生效必须向上下文中注册DefaultAnnotationHandlerMapping和一个AnnotationMethodHandlerAdapter 实例，这两个实例分别在类级别和方法级别处理。而annotation-driven配置帮助我们自动完成上述两个实例的注入。--&gt;    &lt;!--配置注解的适配器和映射器，同时还注入了其他很多的bean--&gt;    &lt;mvc:annotation-driven/&gt;    &lt;!-- 视图解析器（该解析器不配置也会默认加载，但是自己配置的话可以注入自定义配置）--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;          id=&quot;internalResourceViewResolver&quot;&gt;        &lt;!-- 前缀 --&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/item/&quot;/&gt;        &lt;!-- 后缀 --&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><blockquote><p>视图解析器中我们把所有的视图都放在/WEB-INF/目录下，这样是为了视图安全，因为这个目录用户端不能直接访问</p></blockquote><hr /><p><strong>mvc:annotation-drivern</strong>标签的作用，详见AnnotationDrivenBeanDefinitionParser类的parse方法。</p><p>分析得知：mvc:annotation-drivern往spring容器中注册了以下的一些BeanDefinition：</p><p><strong>RequestMappingHandlerMapping</strong>：注解式处理器映射器，对类中标记@ResquestMapping的方法进行映射，根据ResquestMapping定义的url匹配ResquestMapping标记的方法，匹配成功返回HandlerMethod对象给前端控制器，HandlerMethod对象中封装url对应的方法Method。</p><p><strong>RequestMappingHandlerAdapter</strong>：注解式处理器适配器，对标记@ResquestMapping的方法进行适配</p><pre><code class="highlight plaintext">&lt;!--注解映射器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;&lt;!--注解适配器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;&lt;!--替换上面两句--&gt;&lt;mvc:annotation-driven/&gt;</code></pre><blockquote><p>springmvc.xml配置文件中使用<code>&lt;mvc:annotation-driven/&gt;</code>标签替代bean标签配置的注解处理器和适配器</p></blockquote><h3 id="配置dispatcherservletwebxml"><a class="markdownIt-Anchor" href="#配置dispatcherservletwebxml"></a> 配置DispatcherServlet（web.xml）</h3><ul><li>Spring MVC框架像许多其他MVC框架一样, 请求驱动,围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。如下图所示当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者</li><li></li><li>在web.xml中配置DispatcherServlet前端控制器组件<ul><li>DispatcherServlet组件在spring mvc中已提供，只需配置即可</li><li>配置DispatcherServlet时，同时指定xml配置文件</li></ul></li></ul><pre><code class="highlight plaintext">&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;!--配置前端控制器--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;!--设置spring配置文件路径--&gt;    &lt;!--如果不设置初始化参数，那么DispatcherServlet会读取默认路径下的配置文件--&gt;    &lt;!--默认配置文件路径：/WEB-INF/springmvc-servlet.xml--&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;!--指定初始化日期，设置为2，表示tomcat启动时，DispatcherServlet会跟随着初始化--&gt;    &lt;!--如果未指定初始化日期，DispatcherServlet就会在第一次请求的时候，才会初始化，而且只会被初始化一次--&gt;    &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;!--url-pattern的配置--&gt;    &lt;!--不要配置为/*，否则会报错（因为它拦截了jsp请求但是不会去处理）--&gt;    &lt;!--通俗解释：/*会拦截整个项目中的资源访问，包含jsp和静态资源的访问，对于静态资源的访问springMVC提供了默认的handler处理器--&gt;    &lt;!--但是对于jsp来讲，springMVC没有提供默认的处理器，我们也没有手动编写对应的处理器，此时按照springMVC的处理流程分析得知，它短路了--&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p><strong>url-pattern匹配顺序详解</strong></p><p><strong>web.xml配置内容的加载顺序</strong></p><h3 id="编写处理器handlercontroller"><a class="markdownIt-Anchor" href="#编写处理器handlercontroller"></a> 编写处理器Handler（Controller）</h3><p>处理器开发方式有多种：实现HttpRequestHandler接口、实现Controller接口、<strong>注解方式</strong>等。</p><h4 id="方式一接口方式"><a class="markdownIt-Anchor" href="#方式一接口方式"></a> <s>方式一（接口方式）</s></h4><p>不推荐使用</p><p><strong>1 HandlerMapping组件（映射器）</strong></p><ul><li>通过handlerMapping组件，DispatcherServlet控制器可以将客户HTTP请求映射到Controller组件上</li><li><strong>SimpleUrlHandlerMapping</strong><ul><li>维护一个HTTP请求和Controller映射关系表（map）,根据列表对应关系调用Controller</li></ul></li></ul><pre><code class="highlight plaintext">       &lt;!-- 配置HandlerMapping --&gt;       &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;             &lt;property name=&quot;mappings&quot;&gt;                    &lt;props&gt;                           &lt;prop key=&quot;/hello.do&quot;&gt;helloController&lt;/prop&gt;                    &lt;/props&gt;             &lt;/property&gt;       &lt;/bean&gt;       &lt;!-- 配置处理器，这里的id要和上面的prop中的值相等，才能调用 --&gt;       &lt;bean id=&quot;helloController&quot; class=&quot;controller.HelloController&quot;&gt;&lt;/bean&gt;</code></pre><ul><li><strong>RequestMappingHandlerMapping</strong></li><li><strong>RequestMappingHandlerAdapter</strong><ul><li>在Controller类和方法上使用@RequestMapping注解指定对应的客户HTTP请求</li></ul></li></ul><p><strong>2 Controller组件（处理器）</strong></p><ul><li>实现Controller有两种方法<ol><li>实现Controller接口,重写handleRequest方法</li><li>使用@Controller定义控制器</li></ol></li><li>Controller组件负责执行具体的业务逻辑，可以调用DAO等组件，编写时需要实现Controller接口及约定的方法</li></ul><blockquote><p>这是一种比较古老的方式，缺点是：一个控制器中只有一个Action，如果要多个Action，则需要定义多个Controller，定义方式比较麻烦，推荐<strong>使用注解的方法</strong></p></blockquote><pre><code class="highlight plaintext">public class HelloController implements Controller&#123;    public ModelAndView handleRequest(HttpServletRequest req,HttpServletResponse res) throws Exception&#123;        System.out.println(&quot;hello spring!&quot;);                     /*              * ModelAndView有两个构造器              *     1.ModelAndView(String viewName)              *     viewName就是视图名              *  2.ModelAndView(String viewName,Map date)              *     map用于封装处理结果的数据              */         return new ModelAndView(&quot;hello&quot;);//下一个ppt    &#125;&#125;</code></pre><h4 id="方式二注解方式"><a class="markdownIt-Anchor" href="#方式二注解方式"></a> 方式二（注解方式）</h4><p><strong>@Controller注解</strong>：在类上添加该注解，指定该类为一个请求处理器，不需要实现任何接口或者继承任何类。</p><p><strong>@RequestMapping注解</strong>：在方法上添加该注解，指定请求的url由该方法处理。其中“.do”可以加也可以不加。</p><p>处理器的返回值是ModelAndView对象，该对象的具体理解如下：</p><p><strong>ModelAndView</strong>：方法返回值对象，该对象包含两个功能：一个是将数据存储到Request域中，一个是设置响应视图，比如将视图设置为“/WEB-INF/jsp/itemList.jsp”</p><pre><code class="highlight plaintext">package com.lee.controller;import com.lee.pojo.Item;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpSession;import java.util.ArrayList;import java.util.List;@Controllerpublic class ItemController &#123;    //@RequestMapping此时填写的是URL    //ModelAndView表示的是数据模型，view就是最终要展示给用户的视图    @RequestMapping(&quot;queryItem&quot;)    public ModelAndView queryItem(HttpSession session)&#123;        List&lt;Item&gt; items = new ArrayList&lt;Item&gt;();        items.add(new Item(&quot;联想笔记本&quot;, (float) 5000,&quot;ThinkPad T430 联想笔记本电脑&quot;));        items.add(new Item(&quot;苹果手机&quot;, (float) 8000,&quot;iPhone 11 苹果手机&quot;));        System.out.println(items.get(0));        System.out.println(items.get(1));        ModelAndView modelAndView = new ModelAndView();        //设置数据模型，相当于request的setAttrbute方法，实质上，底层也确实是转成了request        //先将k/v数据放入map中，最终根据视图对象不同，在进行后续处理        modelAndView.addObject(&quot;itemList&quot;,items);        //设置视图（逻辑路径）        modelAndView.setViewName(&quot;item-list&quot;);        return modelAndView;    &#125;&#125;</code></pre><blockquote><p>注解为@<strong>Controller</strong>是为了让Spring IOC容器初始化时自动扫描到；@<strong>RequestMapping</strong>是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/hello/hi；方法中声明Model类型的参数是为了把Action中的数据带到视图中；方法返回的结果是<strong>视图的名称</strong>hi，加上配置文件中的前后缀变成WEB-INF/view/hi.jsp</p></blockquote><p>pojo类</p><pre><code class="highlight plaintext">package com.lee.pojo;import java.util.Date;public class Item &#123;    private Integer id;    private String name;    private Float price;    private String pic;    private Date createtime;    private String detail;    public Item(String name,Float price,String detail)&#123;        this.id = 1;        this.name = name;        this.price = price;        this.pic = &quot;哈哈&quot;;        this.createtime = new Date();        this.detail = detail;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Float getPrice() &#123;        return price;    &#125;    public void setPrice(Float price) &#123;        this.price = price;    &#125;    public String getPic() &#123;        return pic;    &#125;    public void setPic(String pic) &#123;        this.pic = pic;    &#125;    public Date getCreatetime() &#123;        return createtime;    &#125;    public void setCreatetime(Date createtime) &#123;        this.createtime = createtime;    &#125;    public String getDetail() &#123;        return detail;    &#125;    public void setDetail(String detail) &#123;        this.detail = detail;    &#125;    public String toString() &#123;        return &quot;Item&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +                &quot;, price=&quot; + price +                &quot;, pic=&#x27;&quot; + pic + &#x27;\&#x27;&#x27; +                &quot;, createtime=&quot; + createtime +                &quot;, detail=&#x27;&quot; + detail + &#x27;\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;</code></pre><h3 id="创建视图"><a class="markdownIt-Anchor" href="#创建视图"></a> 创建视图</h3><ul><li>在WEB-INF/view目录中创建视图，hi.jsp视图将从Action中带回的信息展示，具体内容如下：</li></ul><p><strong>一定要注意加上<code>&lt;%@page isELIgnored=&quot;false&quot;%&gt;</code>，否则$符号无法使用</strong></p><pre><code class="highlight plaintext">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot; %&gt;&lt;%@page isELIgnored=&quot;false&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;查询商品列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath &#125;/itemList.do&quot; method=&quot;post&quot;&gt;    查询条件：    &lt;table width=&quot;100%&quot; border=1&gt;        &lt;tr&gt;            &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;查询&quot;/&gt;&lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;    商品列表：    &lt;table width=&quot;100%&quot; border=1&gt;        &lt;tr&gt;            &lt;td&gt;商品名称&lt;/td&gt;            &lt;td&gt;商品价格&lt;/td&gt;            &lt;td&gt;生产日期&lt;/td&gt;            &lt;td&gt;商品描述&lt;/td&gt;            &lt;td&gt;操作&lt;/td&gt;        &lt;/tr&gt;        &lt;c:forEach items=&quot;$&#123;itemList&#125;&quot; var=&quot;item&quot;&gt;            &lt;tr&gt;                &lt;td&gt;$&#123;item.name&#125;&lt;/td&gt;                &lt;td&gt;$&#123;item.price&#125;&lt;/td&gt;                &lt;td&gt;&lt;fmt:formatDate value=&quot;$&#123;item.createtime&#125;&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&lt;/td&gt;                &lt;td&gt;$&#123;item.detail&#125;&lt;/td&gt;                &lt;td&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/itemEdit.do?id=$&#123;item.id&#125;&quot;&gt;修改&lt;/a&gt;&lt;/td&gt;            &lt;/tr&gt;        &lt;/c:forEach&gt;    &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="modelandview组件"><a class="markdownIt-Anchor" href="#modelandview组件"></a> ModelAndView组件</h4><ul><li>Controller组件约定的handleRequest方法执行后返回一个ModelAndView对象，该对象可封装模型数据和视图名响应信息，ModelAndView构造器如下<ul><li><code>ModelAndView(String viewName)</code></li><li><code>ModelAndView(String viewName,Map model)</code></li></ul></li><li>viewName是jsp页面名字</li><li>model的数据存储到request的attribute中</li></ul><pre><code class="highlight plaintext">@RequestMapping(&quot;listCategory&quot;)public ModelAndView listCategory() &#123;     //创建一个模型视图对象     ModelAndView mav = new ModelAndView();     //获取到查询的数据     List&lt;Category&gt; cs= categoryService.list();     //将数据放置到ModelAndView对象view中,第二个参数可以是任何java类型     mav.addObject(&quot;cs&quot;, cs);     // 放入jsp路径 ，或者可以new的时候直接绑定路径    mav.setViewName(&quot;listCategory&quot;);     //返回ModelAndView对象mav     return mav; &#125;</code></pre><p><strong>JSP取值</strong></p><pre><code class="highlight plaintext">&lt;!-- 使用c标签库，循环遍历出数据 ，命名为c--&gt; &lt;c:forEach items=&quot;$&#123;cs&#125;&quot; var=&quot;c&quot; varStatus=&quot;st&quot;&gt;     &lt;tr&gt;         &lt;td&gt;$&#123;c.id&#125;&lt;/td&gt;         &lt;td&gt;$&#123;c.name&#125;&lt;/td&gt;     &lt;/tr&gt;&lt;/c:forEach&gt;</code></pre><h5 id="model和modelmap"><a class="markdownIt-Anchor" href="#model和modelmap"></a> Model和ModelMap</h5><p>ModelMap对象主要用于传递控制方法处理数据到结果页面，也就是说我们把结果页面上需要的数据放到ModelMap对象中即可；</p><p>他的作用类似于request对象的setAttribute方法的作用: 用来在一个请求过程中传递处理的数据。</p><p>ModelMap或者Model通过<code>addAttribute</code>方法向页面传递参数.</p><p>然后在jsp页面上可以通过el表达式语言$attributeName或者是C标签库下的方法，来获取并展示modelmap中的数据。</p><p><strong>modelmap本身不能设置页面跳转的url地址别名或者物理跳转地址</strong>.</p><p>那么我们可以通过控制器方法的字符串返回值来设置跳转url地址别名或者物理跳转地址</p><pre><code class="highlight plaintext">@RequestMapping(value=&quot;/list-books&quot;)private String getAllBooks(Model model)&#123;    logger.error(&quot;/list-books&quot;);    List&lt;Book&gt; books= bookService.getAllBooks();    //绑定数据，相当于request.setAttribute()    //在jsp页面利$&#123;books&#125;即可取出其中的值    model.addAttribute(&quot;books&quot;, books);    //返回视图名，即BookList.jsp，这个要看自己具体配置    return &quot;BookList&quot;;&#125;</code></pre><blockquote><p>在jsp页面利<code>$&#123;books&#125;</code>即可取出其中的值</p></blockquote><h5 id="modelandview和model的区别"><a class="markdownIt-Anchor" href="#modelandview和model的区别"></a> ModelAndView和Model的区别</h5><p><strong>Model</strong>是每次请求中都存在的默认参数，利用其addAttribute()方法即可将服务器的值传递到jsp页面中；</p><p><strong>ModelAndView</strong>包含model和view两部分，使用时需要自己实例化，利用ModelMap用来传值，也可以设置view的名称，ModelAndView的实例是需要我们手动new的，这也是和ModelMap的一个区别</p><p>而且，ModelAndView 可以自己寻址，只需要return 返回其对象即可</p><h4 id="viewresolver组件"><a class="markdownIt-Anchor" href="#viewresolver组件"></a> ViewResolver组件</h4><ul><li>所有Controller组件都返回一个ModelAndView实例，封装了视图名，spring中的视图以名字为标识，视图解析器ViewResolver通过名字来解析视图</li><li>Spring提供了多种视图解析器<blockquote><p><strong>UrlBasedViewResolver</strong> <code>将视图名直接解析成对应的URL，不需要显示的映射定义，如果你的视图名和视图资源的名字是一致的，就可以使用该解释器，而无须进行映射</code></p><p><strong>InternalResourceViewResolver</strong> <code>UrlBasedViewResolver的子类，它支持InternalResourceView（对Servlet和JSP的包装），以及其子类JstlView和TilesView响应类型</code></p><p><strong>XmlViewResolver</strong> <code>支持用XML文件定义具体的响应视图文件</code></p><p><strong>VelocityViewResolver/FreeMarkerViewResolver</strong><code>UrlBasedViewResolver的子类，他能支持Velocity和FreeMarker等视图技术</code></p></blockquote></li><li><strong>InternalResourceViewResolver使用实例如下</strong></li></ul><pre><code class="highlight plaintext">       &lt;!-- 配置ViewResolver视图解析器 --&gt;       &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;             &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot;&gt;&lt;/property&gt;             &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;       &lt;/bean&gt;</code></pre><blockquote><p>如：视图名hello<code>（即new ModelAndView(&quot;hello&quot;)中的参数）</code>通过以上配置可以映射到/WEB-INF/jsp/hello.jsp</p></blockquote><h3 id="配置tomcat部署项目"><a class="markdownIt-Anchor" href="#配置tomcat部署项目"></a> 配置tomcat部署项目</h3><ul><li><p>点击右上角的Edit Configurations添加对tomcat的配置</p></li><li><p>添加对tomcat的配置，设置名称，添加Deployment</p></li><li><p>可以设置context也可以没有，类似虚拟目录</p></li></ul><h3 id="设置引导页"><a class="markdownIt-Anchor" href="#设置引导页"></a> 设置引导页</h3><ul><li>使用了spring mvc如果想直接访问控制器下的某个action为引导页，可以通过如下方式实现：<br /><strong>方法一</strong></li><li>删除index.jsp默认引导文件</li><li>定义以下Home控制器，如下所示</li></ul><pre><code class="highlight plaintext">package com.zhangguo.springmvc01.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;/**控制器*/@Controller@RequestMapping(&quot;/&quot;)public class HomeController &#123;    /**动作，action*/    @RequestMapping(&quot;&quot;)    public String index(Model model)&#123;        //向模型中添加属性msg与值，将与页面模板渲染后输出        model.addAttribute(&quot;msg&quot;,&quot;Welcome my website!&quot;);        return &quot;hi&quot;;    &#125;&#125;</code></pre><p><strong>方法二</strong></p><ul><li>修改Spring MVC配置文件，增加如下配置：</li></ul><pre><code class="highlight plaintext">&lt;!--此标签用以在springMVC配置文件中实现路径的转发和资源的请求--&gt;&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;redirect:/hello/&quot;&gt;&lt;/mvc:view-controller&gt;</code></pre><pre><code class="highlight plaintext">package com.zhangguo.springmvc01.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;/**控制器*/@Controller@RequestMapping(&quot;/hello&quot;)public class HelloController &#123;    /**动作，action*/    @RequestMapping(&quot;/hi&quot;)    public String hi(Model model)&#123;        //向模型中添加属性msg与值，将与页面模板渲染后输出        model.addAttribute(&quot;msg&quot;,&quot;Hello Spring MVC!&quot;);        return &quot;hi&quot;;    &#125;    /**动作，action*/    @RequestMapping(&quot;&quot;)    public String index(Model model)&#123;        //向模型中添加属性msg与值，将与页面模板渲染后输出        model.addAttribute(&quot;msg&quot;,&quot;Index Page!&quot;);        return &quot;hi&quot;;    &#125;&#125;</code></pre><blockquote><p>注意这种方法是使用的重定向方式，需发起两次请求，尽量转发</p></blockquote><h2 id="springmvc详解"><a class="markdownIt-Anchor" href="#springmvc详解"></a> SpringMVC详解</h2><ul><li>导包</li><li>添加spring的配置文件</li><li>配置DispatcherServlet</li><li>写Controller</li><li>写jsp</li><li>在spring配置文件中，添加如下配置<ul><li>a.组件扫描</li><li>b.mvc注解扫描</li><li>c.视图解析器</li><li></li></ul></li></ul><h3 id="requestmapping注解"><a class="markdownIt-Anchor" href="#requestmapping注解"></a> @RequestMapping注解</h3><p><strong>spring.xml定义</strong></p><ul><li>开启@RequestMapping注解映射，需要在Spring的xml配置文件中定义<strong>RequestMappingHandlerMapping</strong>（注解映射器）和<strong>RequestMappingHandlerAdapter</strong>（注解适配器）两个bean组件</li></ul><pre><code class="highlight plaintext">Spring 3.1版本之前需要定义&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;Spring3.2之后可以使用下面xml简化配置&lt;mvc:annotation-driven/&gt;</code></pre><h4 id="属性"><a class="markdownIt-Anchor" href="#属性"></a> 属性</h4><h5 id="value属性"><a class="markdownIt-Anchor" href="#value属性"></a> value属性</h5><p><strong>基础用法</strong></p><ul><li>@RequestMapping可以用在类定义和方法定义上<ul><li><strong>用在类上</strong>：表示类中的所有响应请求的方法都是以该地址作为父路径，通过此种方法对url进行分类管理</li><li><strong>用在方法上</strong>：URL路径映射</li></ul></li><li>@RequestMapping表明这个<strong>类</strong>或<strong>方法</strong>与哪一个客户请求想对应</li><li><strong>方法名不作要求，返回类型可以是ModelAndview，也可以是String</strong></li><li>当@<strong>RequestMapping为空</strong>时<ul><li>注解在方法时，表示该方法为类下默认的action</li><li>注解在类上时，可表示项目的起始页</li></ul></li></ul><pre><code class="highlight plaintext">/* * 如何写一个处理器： * 1.不用实现Controller接口 * 2.可以在处理器类当中，添加多个方法，每一个方法处理一种类型的请求 * 3.方法名不作要求，返回类型可以是ModelAndview，也可以是String * 4.使用@Controler，将该处理器纳入容器进行管理（也就是说，spring配置文件不用配置该处理器了） * 5.使用@RequestMapping，告诉前端控制器（DispatcherServlet），请求路径与处理器的方法对应关系（spring配置文件不用配置HandlerMapping了） *  */@Controller@RequestMapping(&quot;/login&quot;)//@RequestMapping(value=&#123;&quot;/item&quot;,&quot;/item2&quot;&#125;)public class HelloController &#123;       @RequestMapping(&quot;/hello.do&quot;)                                                                                        // http://localhost:8080/srpingmvc02/login/hello.do       public String hello() &#123;             System.out.println(&quot;hello()&quot;);             return &quot;hello&quot;;       &#125;@RequestMapping(&quot;/toLogin.do&quot;)        // //http://localhost:8080/srpingmvc02/login/toLogin.do        public String toLogin()&#123;            System.out.println(&quot;toLogin()&quot;);            return &quot;login&quot;;            &#125;            @RequestMapping   //http://localhost:8087/SpringMVC02/login    public String action2(Model model)&#123;        //在模型中添加属性message值为action2，渲染页面时使用        model.addAttribute(&quot;message&quot;, &quot;action2&quot;);        return &quot;foo/index&quot;;    &#125;</code></pre><p><strong>路径变量占位URL模板模式</strong></p><ul><li>可以使用@<strong>PathVariable</strong>注释方法参数的值绑定到一个URL模板变量</li></ul><pre><code class="highlight plaintext">@RequestMapping(&quot;/action3/&#123;p1&#125;/&#123;p2&#125;&quot;)    public String action3(@PathVariable int p1,@PathVariable int p2,Model model)&#123;        model.addAttribute(&quot;message&quot;, p1+p2);        return &quot;foo/index&quot;;    &#125;</code></pre><blockquote><p>使用路径变量的<strong>好处</strong>：使路径变得更加简洁；获得参数更加方便，框架会自动进行类型转换。通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到action，如这里访问是的路径是/action3/1/a，则路径与方法不匹配，而不会是参数转换失败</p></blockquote><p><strong>正则表达式模式的URL模板</strong></p><ul><li>案例要求id必须为6位数字，name必须位3位小写字母</li></ul><pre><code class="highlight plaintext">@RequestMapping(value=&quot;/action4/&#123;id:\\d&#123;6&#125;&#125;-&#123;name:[a-z]&#123;3&#125;&#125;&quot;)    public String action4(@PathVariable int id,@PathVariable String name,Model model)&#123;        model.addAttribute(&quot;message&quot;, &quot;id:&quot;+id+&quot; name:&quot;+name);        return &quot;foo/index&quot;;    &#125;</code></pre><p><strong>矩阵变量@MatrixVariable</strong></p><ul><li>矩阵变量可以出现在任何路径段,每个矩阵变量用“;”分隔。例如:“/汽车;颜色=红;年=2012”。多个值可以是“,”分隔“颜色=红、绿、蓝”或变量名称可以重复“颜色=红;颜色=绿色;颜色=蓝”，如下所示：</li><li>案例1</li></ul><pre><code class="highlight plaintext">// GET /pets/42;q=11;r=22    @RequestMapping(value = &quot;/pets/&#123;petId&#125;&quot;)    public void findPet(@PathVariable String petId, @MatrixVariable int q) &#123;        // petId == 42        // q == 11    &#125;</code></pre><ul><li>案例2</li></ul><pre><code class="highlight plaintext">// 矩阵变量    @RequestMapping(value = &quot;/action5/&#123;name&#125;&quot;)    public String action5(Model model,             @PathVariable String name,   //路径变量，用于获得路径中的变量name的值            @MatrixVariable String r,            @MatrixVariable(required = true) String g,  //参数g是必须的            @MatrixVariable(defaultValue = &quot;99&quot;, required = false) String b) &#123;  //参数b不是必须的，默认值是99        model.addAttribute(&quot;message&quot;, name + &quot; is #&quot; + r + g + b);        return &quot;foo/index&quot;;    &#125;    //Get http://localhost:8087/SpringMVC02/action5/the%20book%20color;r=33;g=66    //the book color is #336699</code></pre><ul><li>默认时不允许使用矩阵变量的，需要设置配置文中的RequestMappingHandlerMapping的属性removeSemicolonContent为false；在annotation-driven中增加属性enable-matrix-variables=“true”，修改后的springmvc-servlet.xml文件如下：</li></ul><pre><code class="highlight plaintext">&lt;!-- 支持mvc注解驱动 --&gt;    &lt;mvc:annotation-driven enable-matrix-variables=&quot;true&quot; /&gt;    &lt;!-- 配置映射媒体类型的策略 --&gt;    &lt;bean        class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;&gt;        &lt;property name=&quot;removeSemicolonContent&quot; value=&quot;false&quot; /&gt;    &lt;/bean&gt;</code></pre><p><strong>Ant风格路径模式</strong></p><ul><li></li><li></li><li></li><li>@RequestMapping注解也支持ant风格的路径模式，如/myPath/<em>.do，/owners/</em>/pets/{petId}，示例代码如下：</li></ul><pre><code class="highlight plaintext">//http://localhost:8080/SpringMVC02/action6/ant.do//Ant风格路径模式    @RequestMapping(value = &quot;/action6/*.do&quot;)    public String action6(Model model)&#123;         model.addAttribute(&quot;message&quot;,&quot;Ant风格路径模式&quot;);        return &quot;foo/index&quot;;    &#125;</code></pre><p><strong>处理多个URI</strong></p><ul><li>你可以将多个请求映射到一个方法上去，只需要添加一个带有请求路径值列表的 @RequestMapping 注解就行了</li></ul><pre><code class="highlight plaintext">@RestController  @RequestMapping(&quot;/home&quot;)  public class IndexController &#123;        @RequestMapping(value = &#123;&quot;&quot;,&quot;/page&quot;,&quot;page*&quot;,  &quot;view/*&quot;,&quot;**/msg&quot;&#125;)      String indexMultipleMapping() &#123;          return &quot;Hello from index multiple mapping.&quot;;      &#125;  &#125;可以匹配路径localhost:8080/homelocalhost:8080/home/localhost:8080/home/pagelocalhost:8080/home/pageabclocalhost:8080/home/view/localhost:8080/home/view/view</code></pre><h5 id="methodsconsumesproducesparamsheaderspath属性"><a class="markdownIt-Anchor" href="#methodsconsumesproducesparamsheaderspath属性"></a> methods/consumes/produces/params/headers/path属性</h5><p><strong>method属性指定请求类型</strong></p><ul><li>用于约束请求的谓词类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE，如下代码所示：</li></ul><pre><code class="highlight plaintext">//谓词类型    @RequestMapping(value = &quot;/action6&quot;,method=&#123;RequestMethod.POST,RequestMethod.DELETE&#125;)    public String action6(Model model) &#123;        model.addAttribute(&quot;message&quot;, &quot;请求谓词只能是POST与DELETE&quot;);        return &quot;foo/index&quot;;    &#125;</code></pre><p><strong>consumes属性指定请求的Content-Type</strong></p><ul><li>@RequestMapping 注解的 produces 和 consumes 这两个元素来缩小请求映射类型的范围，达到处理生产和消费对象的目的</li><li>指定处理请求的提交内容类型（Content-Type），例如application/json, text/html，收窄请求范围，<strong>如果用户发送的请求内容类型不匹配则方法不会响应请求</strong>，具体使用如下代码所示：</li></ul><pre><code class="highlight plaintext">package com.zhangguo.springmvc02.controllers;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;/home&quot;)public class HomeController &#123;    // 请求内容类型必须为text/html，注意浏览器默认没有指定Content-type    @RequestMapping(value = &quot;/action8&quot;,consumes=&quot;text/html&quot;)    public String action8(Model model) &#123;        model.addAttribute(&quot;message&quot;, &quot;请求的提交内容类型（Content-Type）是text/html&quot;);        return &quot;foo/index&quot;;    &#125;&#125;</code></pre><blockquote><p>注意：可以使用！号，如consumes=“!text/html”</p></blockquote><p><strong>produces属性指定响应的Content-Type</strong></p><ul><li>设置响应体包头中的<strong>Content-Type</strong>属性，常用<strong>来解决乱码</strong></li><li>指定返回的内容类型，<strong>仅当request请求头中的(Accept)类型中包含该指定类型才返回</strong>(请求头中的Accept指明浏览器能接受的类型)，方法才处理客户端的请求否则会报406错误，常用设置如下：<ul><li>produces = “text/plain”  //客户端只接收纯文本</li><li>produces = {“text/plain”, “application/*”}   //客户端接收纯文本与application/*类型的内容</li><li>produces = “application/json; charset=UTF-8”  <strong>设置响应体中Content-Type</strong></li></ul></li></ul><pre><code class="highlight plaintext">//设置响应体的包头中Content-Type设置为application/json；charset=utf-8    @RequestMapping(value = &quot;/action9&quot;,produces=&quot;application/json; charset=UTF-8&quot;)    public String action9(Model model) &#123;        model.addAttribute(&quot;message&quot;, &quot;客户端可以接收的类型是application/json; charset=UTF-8&quot;);        return &quot;foo/index&quot;;    &#125;</code></pre><blockquote><p>注意：可以使用！号，如produces=“!text/html”</p></blockquote><p><strong>params属性指定请求中必须有特定参数与值</strong></p><ul><li>映射请求的参数，收窄请求范围。可以限制客户端发送到服务器的请求参数为某些特定值或不为某些值，如下代码所示</li><li>代码中我们用@RequestMapping 的params 属性指定了三个参数，这些参数都是针对请求参数而言的，它们分别表示参数param1 的值必须等于value1 ，参数param2 必须存在，值无所谓，参数param3 必须不存在，只有当请求/testParams.do 并且满足指定的三个参数条件的时候才能访问到该方法。所以当请求/testParams.do?param1=value1&amp;param2=value2 的时候能够正确访问到该testParams 方法，当请求/testParams.do?param1=value1&amp;param2=value2&amp;param3=value3 的时候就不能够正常的访问到该方法，因为在@RequestMapping 的params 参数里面指定了参数param3 是不能存在的</li></ul><pre><code class="highlight plaintext">@RequestMapping (value= &quot;testParams&quot; , params=&#123; &quot;param1=value1&quot; , &quot;param2&quot; , &quot;!param3&quot; &#125;)  public String testParams() &#123;     System. out .println( &quot;test Params...........&quot; );     return &quot;testParams&quot; ;  &#125;</code></pre><p><strong>headers属性指定请求中必须有特定header值</strong></p><ul><li>映射请求头部，收窄请求范围。约束客户端发送的请求头部信息中必须包含某个特定的值或不包含某个值，作用范围明显大于前面讲过的几种，示例代码如下：</li></ul><pre><code class="highlight plaintext">@RequestMapping (value= &quot;testHeaders&quot; , headers=&#123; &quot;host=localhost&quot; , &quot;Accept&quot; &#125;)  public String testHeaders() &#123;  return &quot;headers&quot; ;  &#125;</code></pre><blockquote><p>这里同样可以使用！号；可以使用通配符如：Content-Type=“application/*”</p></blockquote><p><strong>path属性指定路径</strong></p><ul><li>源码</li></ul><pre><code class="highlight plaintext">@AliasFor(&quot;path&quot;)String[] value() default &#123;&#125;;@AliasFor(&quot;value&quot;)String[] path() default &#123;&#125;;</code></pre><ul><li>从Spring 4.2开始引入了@AliasFor注解，可以实现属性的别名，如value本身并没有特定的含义，而path会更加具体，能见名知义，通俗说可以认为<strong>两者使用过程中是一样的</strong><ul><li>@RequestMapping(“/foo”)} 与 @RequestMapping(path=“/foo”)相同</li></ul></li></ul><h4 id="requestmapping源码解析"><a class="markdownIt-Anchor" href="#requestmapping源码解析"></a> @RequestMapping源码解析</h4><pre><code class="highlight plaintext">package org.springframework.web.bind.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.util.concurrent.Callable;import org.springframework.core.annotation.AliasFor;/** * 用于映射url到控制器类或一个特定的处理程序方法. *///该注解只能用于方法或类型上@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Mappingpublic @interface RequestMapping &#123;    /**     * 指定映射的名称     */    String name() default &quot;&quot;;    /**     * 指定请求的路径映射，指定的地址可以是uri模板,别名为path     */    @AliasFor(&quot;path&quot;)    String[] value() default &#123;&#125;;    /** 别名为value，使用path更加形象     * 只有用在一个Servlet环境：路径映射URI（例如“/myPath.do”）。     * Ant风格的路径模式，同时也支持（例如，“/myPath/*.do”）。在方法层面，在主要的映射在类型级别表示相对路径（例如，“edit.do”）     * 的支持。路径映射的URI可能包含占位符（例如“/$ &#123;&#125;连接”）     */    @AliasFor(&quot;value&quot;)    String[] path() default &#123;&#125;;    /**     * 指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE. 收窄请求范围 The     * HTTP request methods to map to, narrowing the primary mapping: GET, POST,     * HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE.     */    RequestMethod[] method() default &#123;&#125;;    /**     * 映射请求的参数，收窄请求范围 The parameters of the mapped request, narrowing the     * primary mapping.     */    String[]params() default &#123;&#125;;    /**     * 映射请求头部，收窄请求范围 The headers of the mapped request, narrowing the primary     * mapping. RequestMapping(value = &quot;/something&quot;, headers =     * &quot;content-type=text/*&quot;)     */    String[] headers() default &#123;&#125;;    /**     * 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html，收窄请求范围 The     * consumable media types of the mapped request, narrowing the primary     * mapping.     */    String[] consumes() default &#123;&#125;;    /**     * 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回 The producible media types     * of the mapped request, narrowing the primary mapping. produces =     * &quot;text/plain&quot; produces = &#123;&quot;text/plain&quot;, &quot;application/*&quot;&#125; produces =     * &quot;application/json; charset=UTF-8&quot;     */    String[] produces() default &#123;&#125;;&#125;</code></pre><blockquote><p>从上面的源码可以发现除了name基本都是数组类型，在设置时我们可以指定单个值，如@RequestMapping(value=“/foo”)；也可以同时指定多个值如：@RequestMapping(value={“/foo”,“/bar”})</p></blockquote><h4 id="requestmapping快捷方式"><a class="markdownIt-Anchor" href="#requestmapping快捷方式"></a> @RequestMapping快捷方式</h4><ul><li>Spring 4.3 引入了方法级注解的变体，也被叫做 @RequestMapping 的组合注解。组合注解可以更好的表达被注解方法的语义。它们所扮演的角色就是针对 @RequestMapping 的封装，而且成了定义端点的标准方法。</li><li>例如，@GetMapping 是一个组合注解，它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。</li></ul><pre><code class="highlight plaintext">@GetMapping@PostMapping@PutMapping@DeleteMapping@PatchMappin例如@RequestMapping(value = &quot;/action3&quot;,method = RequestMethod.GET)等价于@GetMapping(&quot;/action3&quot;)</code></pre><h3 id="controller注解应用"><a class="markdownIt-Anchor" href="#controller注解应用"></a> @Controller注解应用</h3><ul><li>推荐使用@Controller注解声明Controller组件，这样可以使得Controller定义更加灵活，可以不用实现Controller接口，请求处理的方法也可以灵活定义</li></ul><pre><code class="highlight plaintext">@Controller@RequestMapping(&quot;/day01&quot;)public class HelloController&#123;    @RequestMapping(&quot;/hello.form&quot;)    public String execute() throws Exception&#123;        return &quot;hello&quot;;    &#125;&#125;</code></pre><ul><li>为了使@Controller注解生效，需要在Spring的XML配置文件中开启组件扫描定义，并指定Controller组件所在的包</li></ul><pre><code class="highlight plaintext">&lt;context:component-scan base-package=&quot;com.tarena.controller&quot;/&gt;</code></pre><h3 id="请求参数值绑定"><a class="markdownIt-Anchor" href="#请求参数值绑定"></a> 请求参数值绑定</h3><h4 id="什么是请求参数绑定"><a class="markdownIt-Anchor" href="#什么是请求参数绑定"></a> 什么是请求参数绑定</h4><p><strong>请求参数格式</strong></p><ul><li>默认是<strong>key/value</strong>格式，比如：<a href="http://XXXXX?id=1&amp;type=301">http://XXXXX?id=1&amp;type=301</a></li></ul><p><strong>请求参数值的数据类型</strong></p><ul><li>都是<strong>字符串</strong>类型的各种值</li></ul><p><strong>请求参数值要绑定的目标类型</strong></p><ul><li><strong>controller类中的方法参数</strong>，比如简单类型，pojo类型，集合类型等</li></ul><p><strong>springMVC内置的参数解析组件</strong></p><ul><li>默认内置了<strong>24种</strong>参数解析组件（ArgumentResolver）</li></ul><p><strong>什么是参数绑定？</strong></p><ul><li>就是将请求参数串中的<strong>value值获取到之后</strong>，再进行<strong>类型转换</strong>，然后将转换后的值<strong>赋值给controller类中方法的形参</strong>，这个过程就是参数绑定</li></ul><h4 id="默认支持的参数类型"><a class="markdownIt-Anchor" href="#默认支持的参数类型"></a> 默认支持的参数类型</h4><p>Controller方法<strong>形参</strong>中可以<strong>随时添加如下类型的参数</strong>，处理适配器会自动识别并进行赋值。</p><hr /><p><strong>HttpServlet</strong></p><p>主要包括HttpServletRequest 、HttpServletResponse 和HttpSession 对象。 这些参数Spring 在调用处理器方法的时候会自动给它们赋值，所以当在处理器方法中需要使用到这些对象的时候，可以直接在方法上给定一个方法参数的申明，然后在方法体里面直接用就可以了。但是有一点需要注意的是在使用HttpSession 对象的时候，如果此时HttpSession 对象还没有建立起来的话就会有问题</p><ul><li><strong>HttpServletRequest</strong>：通过request对象获取请求信息</li></ul><pre><code class="highlight plaintext">@RequestMapping(&quot;/login-action1.form&quot;) public String checkLogin1(HttpServletRequest req)&#123;     String name = req.getParameter(&quot;name&quot;);&#125;</code></pre><ul><li><strong>HttpServletResponse</strong>：通过response处理响应信息</li><li><strong>HttpSession</strong>：通过session对象得到session中存放的对象</li></ul><hr /><p><strong>Spring 自己的WebRequest 对象</strong></p><p>使用该对象可以访问到存放在HttpServletRequest 和HttpSession 中的属性值。</p><hr /><p><strong>使用@PathVariable 、@RequestParam 、@CookieValue 和@RequestHeader 标记的参数</strong></p><hr /><p><strong>使用@ModelAttribute 标记的参数</strong></p><hr /><p><strong>java.util.Map 、Spring 封装的Model 和ModelMap</strong></p><p>这些都可以用来封装模型数据，用来给视图做展示。</p><ul><li>ModelMap继承自LinkedHashMap，Model是一个接口，它们的底层实现都是同一个类（BindingAwareModelMap），作用就是向页面传递数据，相当于Request的作用，如下：</li></ul><pre><code class="highlight plaintext">//调用service查询商品信息Item item = service.queryItemById(id);model.addAttribute(&quot;item&quot;, item);</code></pre><hr /><p><strong>InputStream、OutputStream</strong>，<strong>Reader、Writer</strong></p><p>InputStream 和Reader 是针对HttpServletRequest 而言的，可以从里面取数据；OutputStream 和Writer 是针对HttpServletResponse 而言的，可以往里面写数据。</p><hr /><p><strong>实体类</strong></p><p>可以用来接收上传的参数</p><hr /><p><strong>Spring 封装的MultipartFile</strong></p><p>用来接收上传文件的</p><hr /><p><strong>Spring 封装的Errors 和BindingResult 对象</strong></p><p>这两个对象参数必须紧接在需要验证的实体对象参数之后，它里面包含了实体对象的验证结果</p><h4 id="直接绑定"><a class="markdownIt-Anchor" href="#直接绑定"></a> 直接绑定</h4><h5 id="绑定基本类型"><a class="markdownIt-Anchor" href="#绑定基本类型"></a> 绑定基本类型</h5><p><strong>使用要求</strong></p><p>http请求参数的<strong>key</strong>和controller方法的<strong>形参名称</strong>一致</p><p><strong>请求url</strong></p><p>请求参数的key为id</p><pre><code class="highlight plaintext">http://localhost:8080/xxx/findItem?id=1</code></pre><p><strong>controller方法</strong></p><p>controller的形参为inteeger id，他和请求参数的key一致，所以直接绑定成功</p><pre><code class="highlight plaintext">@RequestMapping(value = &quot;/findItem&quot;)public String findItem(Integer id) &#123;     System.out.println(&quot;接收到的请求参数是：&quot;+ id);    return &quot;success&quot;;&#125;</code></pre><h5 id="绑定pojo类型"><a class="markdownIt-Anchor" href="#绑定pojo类型"></a> 绑定pojo类型</h5><p><strong>使用要求</strong></p><p>控制器的方法的参数类型是pojo类型</p><p>要求表单中<strong>参数名称</strong>和pojo类的<strong>属性名称</strong>保持一致</p><p>使用自动机制封装成实体参数实例</p><ul><li>在Controller组件处理方法定义User类型参数</li><li>Spring会自动把请求参数封装new为User类型传入</li></ul><pre><code class="highlight plaintext">@RequestMapping(&quot;/login-action3.form&quot;)public String checkLogin3(User user)&#123;    System.out.println(user.getName());    System.out.println(user.getPwd());    User u = userService.login(user.getName(),user.getPwd());    //...    return &quot;success&quot;;&#125;</code></pre><p><strong>请求url</strong></p><pre><code class="highlight plaintext">http://localhost:8080/xxx/updateItem?id=1&amp;name=iphone&amp;price=1000</code></pre><p><strong>controller方法</strong></p><ul><li><p>pojo定义</p></li><li><p>controller方法</p></li></ul><pre><code class="highlight plaintext">@RequestMapping(&quot;/updateItem&quot;)public String updateItem(Integer id,Item item) &#123; System.out.println(&quot;接收到的请求参数是：&quot;+ id); System.out.println(&quot;接收到的请求参数是：&quot;+ item);return &quot;success&quot;;&#125;</code></pre><h5 id="绑定包装pojo"><a class="markdownIt-Anchor" href="#绑定包装pojo"></a> 绑定包装pojo</h5><p><strong>包装pojo类</strong>，依然是一个pojo类，将POJO中包含另一个pojo的这种类，称之为包装pojo</p><p><strong>包装对象</strong></p><pre><code class="highlight plaintext">public class ItemQueryVO &#123;//商品信息private Item item;&#125;</code></pre><p><strong>页面定义</strong></p><pre><code class="highlight plaintext">&lt;table width=&quot;100%&quot; border=1&gt;&lt;tr&gt;&lt;td&gt;商品名称：&lt;input type=&quot;text&quot; name=&quot;item.name&quot; /&gt;&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;查询&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</code></pre><p><strong>controller方法</strong></p><h5 id="使用简单类型数组"><a class="markdownIt-Anchor" href="#使用简单类型数组"></a> 使用简单类型数组</h5><p><strong>使用要求</strong></p><p>通过HTTP请求<strong>批量传递简单类型数据</strong>的情况，Controller方法中可以用<strong>String</strong>[]或者<strong>pojo的String[]属性</strong>接收（两种方式任选其一），但是<strong>不能使用集合</strong>接收。</p><p><strong>请求url</strong></p><pre><code class="highlight plaintext">http://localhost:8080/xxx/deleteItem?id=1&amp;id=2&amp;id=3</code></pre><p><strong>controller方法</strong></p><p>数组类型一定要和url参数类型一致</p><pre><code class="highlight plaintext">@RequestMapping(&quot;/deleteItem&quot;)public String deleteitem(Integer[] Id)&#123;return &quot;success&quot;;&#125;</code></pre><h5 id="使用pojo类型集合或者数组"><a class="markdownIt-Anchor" href="#使用pojo类型集合或者数组"></a> 使用pojo类型集合或者数组</h5><p><strong>使用要求</strong></p><p>批量传递的请求参数，最终要使用List<POJO>来接收，那么这个List<POJO>必须放在<strong>另一个POJO类中</strong></p><p><strong>接受商品列表的pojo</strong></p><pre><code class="highlight plaintext">public class ItemQueryVO &#123;// 商品信息private Item item;// 其他信息// 商品信息集合private List&lt;Item&gt; itemList;&#125;</code></pre><p><strong>请求URL</strong></p><pre><code class="highlight plaintext">http://localhost:8080/xxx/batchUpdateItem?itemList[0].id=1&amp; itemList[0].name=iphone&amp; itemList[0].price=1000&amp;itemList[1].id=2&amp; itemList[1].name=iphone x&amp; itemList[1].price=2000</code></pre><p><strong>controller</strong></p><pre><code class="highlight plaintext">@RequestMapping(&quot;/batchUpdateItem&quot;)public String batchUpdateItem(ItemQueryVO vo) &#123;return &quot;success&quot;;&#125;</code></pre><h5 id="自定义参数绑定"><a class="markdownIt-Anchor" href="#自定义参数绑定"></a> 自定义参数绑定</h5><p><strong>请求url</strong></p><pre><code class="highlight plaintext">http://localhost:8080/xxx/saveItem?date=2018-08-12</code></pre><p><strong>controller</strong></p><pre><code class="highlight plaintext">@RequestMapping(&quot;/saveItem&quot;)public String saveItem(String date)&#123;System.out.println(&quot;接收到的请求参数是：&quot;+ date);return &quot;success&quot;;&#125;</code></pre><blockquote><p>但是如果将data参数的类型由string改为date，则报错</p></blockquote><p><strong>自定义Converter</strong></p><pre><code class="highlight plaintext">public class DateConverter implements Converter&lt;String, Date&gt; &#123;@Overridepublic Date convert(String source) &#123;SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);try &#123;return simpleDateFormat.parse(source);&#125; catch (ParseException e) &#123;e.printStackTrace();&#125;return null;&#125;&#125;</code></pre><p><strong>配置Converter</strong></p><p>在springmvc.xml文件中添加如下代码</p><pre><code class="highlight plaintext">&lt;!-- 加载注解驱动 --&gt;&lt;!--处理器适配器会去调用conversionService--&gt;&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt;&lt;!-- 转换器配置（配置自定义转换器） --&gt;&lt;bean id=&quot;conversionService&quot;class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;&lt;property name=&quot;converters&quot;&gt;&lt;set&gt;&lt;bean class=&quot;com.kkb.ssm.controller.converter.DateConverter&quot;/&gt;&lt;/set&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h4 id="注解绑定"><a class="markdownIt-Anchor" href="#注解绑定"></a> 注解绑定</h4><h5 id="requestparam"><a class="markdownIt-Anchor" href="#requestparam"></a> @RequestParam</h5><hr /><p>@RequestParam注解只适用与Key/Value的http请求，即浏览器默认的表单类型（如果为json，xml等类型，不可以使用）</p><p>@RequestParam用来处理  <strong>Content-Type  为  application/x-www-form-urlencoded</strong>  编码的内容， Content-Type 默认为该属性</p><p>@RequestParam也可用于其它类型的请求，例如：POST、DELETE等请求。比如向表中插入单条数据</p><p>@RequestParam(value)相当于<code>Request.getParameter(请求参数key)</code></p><blockquote><p>@RequestParam不支持批量插入数据，如果改用  json  字符串来传值的话，类型设置为  application/json ，点击发送的话，会报错，后台接收不到值，为null</p></blockquote><blockquote><p>如果参数前写了@RequestParam(xxx)，那么前端必须有对应的xxx名字才行(不管其是否有值，当然可以通过设置该注解的required属性来调节是否必须传)，如果没有xxx名的话，那么请求会出错，报400</p></blockquote><blockquote><p>这里与feign消费服务时不同；feign消费服务时，如果参数前什么也不写，那么会被默认是@RequestBody的</p></blockquote><hr /><p><strong>使用要求</strong></p><p>请求参数的key和controller方法的形参名称不一致时，需要使用@<strong>RequestParam注解</strong>才能将请求参数绑定成功</p><ul><li><strong>value</strong>：参数名字，即入参的请求参数名字，如value=“itemid”表示请求的参数中的名字为itemid的参数的值将传入；</li><li><strong>required</strong>：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报；<code>TTP Status 400 - Required Integer parameter 'XXXX' is not present</code></li><li><strong>defaultValue</strong>：默认值，表示如果请求中没有同名参数时的默认值</li></ul><p><strong>请求url</strong></p><p>请求参数的id为itemid=1</p><pre><code class="highlight plaintext">http://localhost:8080/xxx/findItem?itemid=1</code></pre><p><strong>controller方法</strong></p><p>Controller的形参为Integer id,它和请求的参数不一致，要使用@RequestParam注解才能绑定成功</p><pre><code class="highlight plaintext"> @RequestMapping(value = &quot;/findItem&quot;)// 通过@RequestParam注解绑定简单类型// 学习@RequestParam注解中的value、required、defaultValue属性public String findItem (@RequestParam(value = &quot;itemid&quot;, required = true, defaultValue = &quot;2&quot;) Integer id) &#123; System.out.println(&quot;接收到的请求参数是：&quot;+ id);  return &quot;success&quot;;&#125;</code></pre><h5 id="pathvariable"><a class="markdownIt-Anchor" href="#pathvariable"></a> @PathVariable</h5><p>@PathVariable只适用于参数再URL路径的绑定情况</p><p>通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过@PathVariable(“xxx“) 绑定到操作方法的入参中</p><pre><code class="highlight plaintext">@RequestMapping(value = &quot;/hosts/pushInstallClient/&#123;id&#125;&quot;, method = RequestMethod.PUT, consumes = &quot;application/json&quot;)//@PathVariable直接接收url中的参数值public void pushInstallClient(@PathVariable(&quot;id&quot;) int id, HttpServletRequest request) &#123;        System.out.println(id);&#125;</code></pre><h5 id="requestbody"><a class="markdownIt-Anchor" href="#requestbody"></a> @RequestBody</h5><p>注解用于将Controller的方法参数，根据HTTP Request Header的content-Type的内容,<strong>通过适当的HttpMessageConverter转换为JAVA类</strong></p><p>@RequestBody只适用与参数在请求体body中，并且请求体数据为json/xml类型的情况（注：框架将json对象转换为Java对象，<strong>故参数必须为引用类型对象</strong>）</p><p>注解@RequestBody接收的参数是来自requestBody中，即请求体。一般用于处理非  Content-Type: application/x-www-form-urlencoded 编码格式的数据，比如： application/json 、 application/xml 等类型的数据</p><p>就 application/json 类型的数据而言，使用注解@RequestBody可以将body里面所有的json数据传到后端，后端再进行解析</p><blockquote><p>@RequestBody与@RequestParam()可以同时使用，@RequestBody最多只能有一个，而@RequestParam()可以有多个</p></blockquote><blockquote><p>当，@RequestBody 与@RequestParam()可以同时使用时，原SpringMVC接收参数的机制不变，只不过RequestBody 接收的是请求体里面的数据；而RequestParam接收的是key-value里面的参数，所以它会被切面进行处理从而可以用普通元素、数组、集合、对象等接收</p></blockquote><hr /><p>如果后端参数是一个对象，且该参数前是以@RequestBody修饰的，那么前端传递json参数时，必须满足以下要求：</p><ul><li>后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类(即：@RequestBody后面的类)时，会根据json字符串中的key来匹配对应实体类的属性，如果匹配一致且json中的该key对应的值符合(或可转换为)，实体类的对应属性的类型要求时,会调用实体类的setter方法将值赋给该属性</li><li>json字符串中，如果value为&quot;“的话，后端对应属性如果是String类型的，那么接受到的就是”&quot;，如果是后端属性的类型是Integer、Double等类型，那么接收到的就是null</li><li>json字符串中，如果value为null的话，后端对应收到的就是null</li><li>如果某个参数没有value的话，在传json字符串给后端时，要么干脆就不把该字段写到json字符串中；要么写value时， 必须有值，null  或&quot;“都行。千万不能有类似&quot;stature”:，这样的写法</li></ul><hr /><p><strong>@RequestBody与前端传过来的json数据的匹配规则</strong></p><p><strong>声明</strong></p><ul><li>根据不同的Content-Type等情况,Spring-MVC会采取不同的HttpMessageConverter实现来进行信息转换解析。下面介绍的是最常模型接收数据的情况。</li></ul><p><strong>解析json数据大体流程概述：</strong></p><ul><li>Http传递请求体信息，最终会被封装进com.fasterxml.jackson.core.json.UTF8StreamJsonParser中(提示：Spring采用CharacterEncodingFilter设置了默认编码为UTF-8)，然后在public class BeanDeserializer extends BeanDeserializerBase implements java.io.Serializable中，通过 public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException方法进行解析。</li><li>假设前端传的json串是这样的： {“name1”:“邓沙利文”,“age”:123,“mot”:“我是一只小小小小鸟~”} 后端的模型只有name和age属性，以及对应的setter/getter方法；给出一般用到的deserializeFromObject(JsonParser p, DeserializationContext ctxt)方法的核心逻辑：</li></ul><p><strong>可以使用@JsonAlias指定模型中的属性对应什么key</strong></p><pre><code class="highlight plaintext">public class User&#123;    @JsonAlias(value=&#123;&quot;Name&quot;,&quot;name123&quot;&#125;)    private String name;    private Integer age;    private String gender;    @JsonProperty(&quot;MOTTO&quot;)    private String motto;        ...getter and setter...        public String toString()&#123;        return age+&quot;岁&quot;+gender+&quot;人[&quot;+name+&quot;]的座右铭居然是：&quot;+motto+&quot;!!!&quot;    &#125;&#125;</code></pre><ul><li><strong>@JsonAlias注解</strong>，实现:json转模型时，使json中的特定key能转化为特定的模型属性;但是模型转json时，对应的转换后的key仍然与属性名一致，见：上图示例中的name字段的请求与响应。以下图进一步说明：</li></ul><blockquote><p>此时，json字符串转换为模型时，json中key为Name或为name123或为name的都能识别</p></blockquote><ul><li><strong>@JsonProperty注解</strong>，实现：json转模型时，使json中的特定key能转化为指定的模型属性；同样的，模型转json时，对应的转换后的key为指定的key，见：示例中的motto字段的请求与响应。以下图进一步说明：</li></ul><blockquote><p>此时，json字符串转换为模型时，key为MOTTO的能识别，但key为motto的不能识别</p></blockquote><blockquote><p>@JsonAlias注解需要依赖于setter、getter，而@JsonProperty注解不需要</p></blockquote><blockquote><p>在不考虑上述两个注解的一般情况下，key与属性匹配时,默认大小写敏感</p></blockquote><blockquote><p>有多个相同的key的json字符串中，转换为模型时，会以相同的几个key中，排在最后的那个key的值给模型属性复制，因为setter会覆盖原来的值。见示例中的gender属性</p></blockquote><blockquote><p>后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类(即:@RequestBody后面的类)时，会根据json字符串中的key来匹配对应实体类的属性，如果匹配一致且json中的该key对应的值符合(或可转换为)实体类的对应属性的类型要求时，会调用实体类的setter方法将值赋给该属性</p></blockquote><hr /><p><strong>@RequestBody直接以String接收前端传过来的json数据：</strong></p><pre><code class="highlight plaintext">/***   直接以String接收前端传来的json数据*/@RequestMapping(value = &quot;/testRequestBody&quot;)public Person testRequestBody(@RequestBody String jsonString) &#123;    System.out.println(jsonString);    return jsonString;&#125;</code></pre><hr /><p><strong>@RequestBody以简单对象接收前端传过来的json数据：</strong></p><pre><code class="highlight plaintext">/***   以比较简单的user对象接收前端传过来的json数据（SpringMVC会智能的将符合要求的数据装配进User对象中）*/@RequestMapping(value = &quot;/testRequestBody&quot;)public Person testRequestBody(@RequestBody User user) &#123;    System.out.println(user.toString());    return user.toString();&#125;</code></pre><pre><code class="highlight plaintext">public class User&#123;    private String name;    private Integer age;    private String gender;    private String motto;        ...getter and setter...        public String toString()&#123;        return age+&quot;岁&quot;+gender+&quot;人[&quot;+name+&quot;]的座右铭居然是：&quot;+motto+&quot;!!!&quot;    &#125;&#125;</code></pre><hr /><p><strong>@RequestBody以复杂对象接收前端传过来的json数据：</strong></p><pre><code class="highlight plaintext">/*** 以较复杂的Team对象接收前端传过来的json数据（SpringMVC会智能的将符合要求的数据装配进该Team对象中）* 注：如果后端@RequestBody后的对象，持有了集合等，当前端向传参令该对象持有的该集合为空时，json空字符串中，对象位置应该形如&quot;teamMembers&quot;:[]这么写，即：传递的json字符串中必须要有key，发否则请求出错*/@RequestMapping(value = &quot;/testRequestBody&quot;)public Person testRequestBody(@RequestBody Team team) &#123;    System.out.println(team.toString());    return team.toString();&#125;</code></pre><pre><code class="highlight plaintext">public class Team&#123;    private Integer id;    //小组名字    private String teamName;    //小组所获荣誉    private List&lt;String&gt; honors;    //小组成员    private List&lt;User&gt; teamMembers;        ...getter and setter ...        public String toString()&#123;        //遍历出小组所获荣耀        StringBuffer sbHonors = new StringBuffer(&quot;荣耀start----\n&quot;);        for(String honor:honors)&#123;            sbHonors.append(honor);            sbHonors.append(&quot;\n&quot;);        &#125;        sbHonors.append(&quot;荣耀end----\n&quot;);                //遍历出小组成员        StringBuffer sbMembers = new StringBuffer(&quot;成员start----\n&quot;);        for(User user:sbMembers)&#123;            sbHonors.append(user.toString());            sbHonors.append(&quot;\n&quot;);        &#125;        sbHonors.append(&quot;成员end----\n&quot;);                return &quot;小组id:&quot;+id+&quot;\n&quot;+&quot;小组名字：&quot;+teamName+&quot;\n&quot;+&quot;小组所获荣耀：&quot;+sbHonors+&quot;\n&quot;+&quot;小组成员：&quot;+sbMembers    &#125;    &#125;</code></pre><hr /><p><strong>@RequestBody与简单的@RequestParam()同时使用：</strong></p><pre><code class="highlight plaintext">//@RequestBody与复杂的@RequestParam()同时使用  注：这里以集合或者以数组接收数据都可以@RequestMapping(value = &quot;/testRequestBody&quot;)public String myTestController(@RequestBody User user,@RequestParam(&quot;token&quot;) String token)&#123;    System.out.println(user.toString());    System.our.println(tijeb);    return token+&quot;&gt;&gt;&gt;&quot;+user.toString();&#125;</code></pre><hr /><p><strong>@RequestBody与复杂的@RequestParam()同时使用：</strong></p><pre><code class="highlight plaintext">//这里@RequestParam以集合或者数组接收都可以@RequestMapping(&quot;&quot;)public String myTestController(@RequestBody User user,@RequestParam(&quot;arrays&quot;) List&lt;String&gt; arrays)&#123;System.out.println(user.toString());StringBuffer sb = new StringBuffer();for(String array:arrays)&#123;sb.append(&quot;array&quot;);sb.append(&quot; &quot;);System.out.println(array);&#125;return sb.toString()+user.toString();&#125;</code></pre><hr /><p><strong>@RequestBody接收请求体中的json数据；不加注解接收URL中的数据并组装为对象：</strong></p><pre><code class="highlight plaintext">//这里@RequestParam以集合或者数组接收都可以@RequestMapping(&quot;&quot;)public String myTestController(@RequestBody User user1,User user2)&#123;System.out.println(user1.toString());System.out.println(user2.toString());return user2.toString()+&quot;\n&quot;+user1.toString();&#125;</code></pre><blockquote><p>注：如果在后端方法参数前，指定了@RequestParam()的话，那么前端必须要有对应字段才行(当然可以通过设置该注解的required属性来调节是否必须传)，否者会报错400；如果参数前没有任何该注解，那么前端可以传，也可以不传</p></blockquote><h4 id="传参校验"><a class="markdownIt-Anchor" href="#传参校验"></a> 传参校验</h4><h5 id="使用valid"><a class="markdownIt-Anchor" href="#使用valid"></a> 使用@Valid</h5><p>使用该注解的主要目的时减轻表单验证的代码量，使逻辑看起来简单易用</p><ul><li>增加相关依赖：</li></ul><pre><code class="highlight plaintext">&lt;dependency&gt;        &lt;groupId&gt;javax.validation&lt;/groupId&gt;        &lt;artifactId&gt;validation-api&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ul><li>在Controller层的方法的欲校验的参数上添加@Valid注解</li></ul><pre><code class="highlight plaintext">@PostMapping(&quot;/action/register&quot;)public Result registerByForm(@Valid @RequestBody RegisterUser registerUser)&#123;    return userService.register(registerUser);&#125;</code></pre><ul><li>在实体类中增加校验标签</li></ul><p>空检查</p><p>@Null 验证对象是否为null</p><p>@NotNull 验证对象是否不为null, 无法查检长度为0的字符串</p><p>@NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.</p><p>@NotEmpty 检查约束元素是否为NULL或者是EMPTY.</p><p>Booelan检查</p><p>@AssertTrue 验证 Boolean 对象是否为 true</p><p>@AssertFalse 验证 Boolean 对象是否为 false</p><p>长度检查</p><ul><li>@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内</li><li>@Length(min=, max=) Validates that the annotated string is between min and max included.</li></ul><p>日期检查</p><ul><li>@Past 验证 Date 和 Calendar 对象是否在当前时间之前</li><li>@Future 验证 Date 和 Calendar 对象是否在当前时间之后</li><li>@Pattern 验证 String 对象是否符合正则表达式的规则</li></ul><p>数值检查</p><blockquote><p>建议使用在Stirng,Integer类型，不建议使用在int类型上，因为表单值为“”时无法转换为int，但可以转换为Stirng为&quot;&quot;,Integer为null</p></blockquote><ul><li>@Min 验证 Number 和 String 对象是否大等于指定的值</li><li>@Max 验证 Number 和 String 对象是否小等于指定的值</li><li>@DecimalMax 被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过BigDecimal定义的最大值的字符串表示.小数存在精度</li><li>@DecimalMin 被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过BigDecimal定义的最小值的字符串表示.小数存在精度</li><li>@Digits 验证 Number 和 String 的构成是否合法</li><li>@Digits(integer=,fraction=) 验证字符串是否是符合指定格式的数字，interger指定整数精度，fraction指定小数精度。</li><li>@Range(min=, max=) Checks whether the annotated value lies between (inclusive) the specified minimum and maximum. *</li><li>@Range(min=10000,max=50000,message=“range.bean.wage”) private BigDecimal wage;</li></ul><p>其他：</p><ul><li>@Valid 递归的对关联对象进行校验, 如果关联对象是个集合或者数组,那么对其中的元素进行递归校验,如果是一个map,则对其中的值部分进行校验.(是否进行递归验证)</li><li>@CreditCardNumber信用卡验证</li><li>@Email 验证是否是邮件地址，如果为null,不进行验证，算通过验证。</li><li>@ScriptAssert(lang= ,script=, alias=)</li><li>@URL(protocol=,host=, port=,regexp=, flags=)</li></ul><blockquote><p>要注意每个注解对应的数据类型</p></blockquote><pre><code class="highlight plaintext">@Data@AllArgsConstructor@NoArgsConstructorpublic class RegisterUser &#123;@Min(value = 1000000)@NotNull(message = &quot;ID不能为空&quot;)private Long userId;@NotNull(message = &quot;用户名不能为空&quot;)@Email(message = &quot;邮箱不正确&quot;)private String username;/*** 教师职称*/@Pattern(regexp = &quot;^[^&lt;&gt;():=]*$&quot;)private String position;/*** 教师所属教研室*/private String office;&#125;</code></pre><ul><li>异常处理（两种方式）</li></ul><ol><li>直接在@Valid修饰的对象后增加Errors形参，该形参即可获取相关异常</li></ol><pre><code class="highlight plaintext">@PostMapping(&quot;/action/register&quot;)public Result registerByForm(@Valid @RequestBody RegisterUser registerUser, Errors erros)&#123;       if (errors.hasErrors()) &#123;            throw new Exception(errors.getAllErrors().get(0).getDefaultMessage());        &#125;    return userService.register(registerUser);&#125;</code></pre><ol><li>定义全局处理异常类</li></ol><pre><code class="highlight plaintext">@Slf4j@ControllerAdvicepublic class GlobalExceptionHandler &#123;    private final static String EXCEPTION_MSG_KEY = &quot;Exception message : &quot;;    @ResponseBody    @ExceptionHandler(MethodArgumentNotValidException.class)    public Result handleValidException(MethodArgumentNotValidException e)&#123;                //日志记录错误信息                log.error(Objects.requireNonNull(e.getBindingResult().getFieldError()).getDefaultMessage());                //将错误信息返回给前台                return Result.error(103, Objects.requireNonNull(e.getBindingResult().getFieldError()).getDefaultMessage());    &#125;&#125;------------------------------------------------------------------------------------------@Data@JsonInclude(JsonInclude.Include.NON_NULL)public class Result&lt;T&gt; &#123;    private Integer code;    private String message;    private T data;    public Result() &#123;        this.code = 200;        this.message = &quot;操作成功&quot;;    &#125;    /**     * 用于错误处理     * @param code 错误码      * @param message 错误提示信息     */    public Result(Integer code,String message)&#123;        this.code = code;        this.message = message;    &#125;    public static  Result&lt;String&gt; error(Integer code,String msg)&#123;        return new Result&lt;&gt;(code,msg);    &#125;&#125;</code></pre><p>或者：</p><pre><code class="highlight plaintext">@ControllerAdvice@ResponseBodypublic class AppliCationExceptionHandler &#123; @ExceptionHandler(value=Exception.class)public Result&lt;String&gt; exceptionHandler(HttpServletRequest request, Exception e)&#123;e.printStackTrace();if(e instanceof ApplicationException) &#123;ApplicationException ex = (ApplicationException)e;return Result.error(ex.getErrorCode()+&quot;:&quot;+ex.getMsg());&#125;else if(e instanceof BindException) &#123;BindException ex = (BindException)e;List&lt;ObjectError&gt; errors = ex.getAllErrors();ObjectError error = errors.get(0);String msg = error.getDefaultMessage();return Result.errorArgs(msg, errors);&#125;return Result.error(e.getMessage()) ;&#125;&#125;</code></pre><h5 id="自定义校验标签"><a class="markdownIt-Anchor" href="#自定义校验标签"></a> 自定义校验标签</h5><ul><li>编写注解<ul><li>@Constraint注解的值就是我们的自己已注解处理类</li></ul></li></ul><pre><code class="highlight plaintext">@Constraint(validatedBy = GeneralNameValidator.class)@Target(&#123;ElementType.METHOD, ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface GeneralNameCheck &#123;    String message() default &quot;格式不合法&quot;;    long min() default 1;    long max() default 64;    Class&lt;?&gt;[] groups() default &#123;&#125;;    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125;</code></pre><ul><li>编写处理方法<ul><li>方法必须要实现ConstraintValidator接口</li></ul></li></ul><pre><code class="highlight plaintext">public class GeneralNameValidator implements ConstraintValidator&lt;GeneralNameCheck, String&gt; &#123;   private long max ;   private long min ;   private Pattern pattern ;        //初始化   public void initialize(GeneralNameCheck constraint) &#123;      max = constraint.max();      min = constraint.min();      pattern = Pattern.compile(&quot;^\\w&#123;&quot;+min+&quot;,&quot;+max+&quot;&#125;$&quot;);   &#125;   //校验   public boolean isValid(String value, ConstraintValidatorContext context) &#123;      return pattern.matcher(value).matches();   &#125;&#125;</code></pre><ul><li>使用</li></ul><p>使用方式与上述方式一致，@Valid定义在Controller形参上，自定义标签写在对应的pojo类成员变量即可。</p><h4 id="自定义参数绑定-2"><a class="markdownIt-Anchor" href="#自定义参数绑定-2"></a> 自定义参数绑定</h4><p>如果在参数绑定spring无法满足，我们就可以自定义参数绑定。</p><p><strong>自定义注解</strong></p><pre><code class="highlight plaintext">import java.lang.annotation.*;@Target(&#123;ElementType.PARAMETER&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface LoginUserInfo &#123;&#125;</code></pre><p><strong>定义处理类</strong></p><pre><code class="highlight plaintext">@Componentpublic class UserInfoArgumentResolver implements HandlerMethodArgumentResolver &#123;    @Autowired    private UserService userService;    /**     * 判断是否对参数类型的支持     * @param methodParameter     * @return     */    @Override    public boolean supportsParameter(MethodParameter methodParameter) &#123;        return methodParameter.hasParameterAnnotation(LoginUserInfo.class);    &#125;    /**     * 对参数的处理     * @param methodParameter     * @param modelAndViewContainer     * @param nativeWebRequest     * @param webDataBinderFactory     * @return     * @throws Exception     */    @Override    public Integer resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,                                NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception &#123;        HttpServletRequest servletRequest = nativeWebRequest.getNativeRequest(HttpServletRequest.class);        String userId = servletRequest.getParameter(&quot;userId&quot;);        if ((userId==null||&quot;&quot;.equals(userId))||//页面未传用户信息                (CommonConstants.CURRENT_USER_ID.equals(userId) &amp;&amp; CommonUtils.isAjaxReqeust(servletRequest)))&#123;//页面传currentuser用户信息            int userId1 = SingleLogin.getUserId(servletRequest);            if (userId1==-1)&#123;                throw new LoginException(&quot;登录异常，请重新登录&quot;);            &#125;            return  userId1;        &#125;        //页面传的真实的用户id        if (IntegerUtils.isNumeric(userId))&#123;            return  Integer.valueOf(userId);        &#125;       throw new LoginException(&quot;登录异常，请重新登录&quot;);    &#125;&#125;</code></pre><p><strong>添加到Configuration</strong></p><pre><code class="highlight plaintext">@Configurationpublic class AdmWebMvcConfiguration extends WebMvcConfigurerAdapter &#123; /*   @Override    public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123;        argumentResolvers.add(new UserInfoArgumentResolver());    &#125;*/    @Autowired    public  void setRequestMappingHandlerAdapter(RequestMappingHandlerAdapter adapter, UserInfoArgumentResolver userInfoArgumentResolver)&#123;        List&lt;HandlerMethodArgumentResolver&gt; resolvers = new ArrayList(adapter.getArgumentResolvers());        resolvers.add(0,userInfoArgumentResolver);        adapter.setArgumentResolvers(resolvers);    &#125;&#125;</code></pre><p><strong>页面使用</strong></p><pre><code class="highlight plaintext">@Override@RequestMapping(value = &quot;/mysqlSrcs/&#123;id&#125;&quot;, method = RequestMethod.DELETE)@ResponseStatus(HttpStatus.NO_CONTENT)public MysqlSrc delete(@PathVariable int id, HttpServletRequest request,@LoginUserInfo Integer userId) &#123;    return mysqlSrcOperationService.deleteMysqlSrc(id, request);&#125;</code></pre><h3 id="向页面传值"><a class="markdownIt-Anchor" href="#向页面传值"></a> 向页面传值</h3><ul><li>当Controller组件处理后，需要向JSP传值，用下述步骤</li><li>直接使用HttpSerlvetRequest和Session</li><li>使用ModeAndView对象</li><li>使用ModeMap参数对象</li><li>使用@ModelAttribute注解</li><li></li></ul><h5 id="1使用requestsetattribute方法"><a class="markdownIt-Anchor" href="#1使用requestsetattribute方法"></a> 1.使用request.setAttribute方法</h5><ul><li>将数据绑定到request，然后转发某个jsp</li></ul><blockquote><p>注：springmvc<strong>默认使用转发</strong></p></blockquote><pre><code class="highlight plaintext">       @RequestMapping(&quot;/login4.do&quot;)       //页面传值的第一钟方式：使用request       public String login4(AdminParam ap,HttpServletRequest request) &#123;             System.out.println(&quot;login4()&quot;);             String adminCode = ap.getAdminCode();             System.out.println(adminCode);             //将数据绑定到request中,就是给request对象存储一个值，用来在jsp页面用getAttribute()方法获取             request.setAttribute(&quot;adminCode&quot;,adminCode);             //springmvc默认使用转发             //框架后台默认调用转发方法 request.getRequestDispatcher(&quot;WEB-INF/findAll2.jsp&quot;).forward(req, res)             return &quot;index&quot;;       &#125;</code></pre><ul><li><strong>共用前端代码</strong></li></ul><pre><code class="highlight plaintext">login.jsp&lt;%@page pageEncoding=&quot;utf-8&quot; contentType=&quot;text/html; charset=utf-8&quot;%&gt;&lt;%@page isELIgnored=&quot;false&quot;%&gt;&lt;html&gt;       &lt;head&gt;&lt;u&gt;登陆&lt;/u&gt;&lt;/head&gt;       &lt;body&gt;             &lt;form action=&quot;login4.do&quot; method=&quot;post&quot;&gt;                    账号：&lt;input name=&quot;adminCode&quot;/&gt;                    密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;/&gt;                    &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;/&gt;            &lt;/form&gt;       &lt;/body&gt;&lt;/html&gt;index.jsp&lt;h1&gt;&lt;u&gt;succes&lt;/u&gt;...&lt;/h1&gt;&lt;h1&gt;$&#123;adminCode&#125;&lt;/h1&gt;</code></pre><h5 id="2modeandview对象"><a class="markdownIt-Anchor" href="#2modeandview对象"></a> 2.ModeAndView对象</h5><ul><li>在Controller处理方法完成后返回一个ModelAndView对象，包含显示视图名和模型数据</li><li>DispatcherServlet对象在收到ModelAndView后分析其携带的参数，然后调用request.setAttribute()方法传入参数，然后调用request.getRequestDispatcher(“WEB-INF/findAll2.jsp”).forward(req, res)方法转发到JSP页面</li></ul><pre><code class="highlight plaintext">       @RequestMapping(&quot;/login5.do&quot;)//向页面传值的第二中方式：使用ModelAndView       public ModelAndView login5(AdminParam ap) &#123;             System.out.println(&quot;login5()&quot;);             String adminCode = ap.getAdminCode();             System.out.println(adminCode);             Map&lt;String,Object&gt; data = new HashMap&lt;String,Object&gt;();             //相当于request.setAttribute(&quot;adminCode&quot;,adminCode)             //虽然这里是吧参数放到了一个map里面，但是框架本身还是要吧参数放到request里面             data.put(&quot;adminCode&quot;, adminCode);             //构造ModeAndView对象             ModelAndView mav = new ModelAndView(&quot;index&quot;,data);             return mav;       &#125;</code></pre><blockquote><p>Model数据会利用HttpServletRequest的Attribute传递到JSP页面中</p></blockquote><h5 id="3modelmap参数"><a class="markdownIt-Anchor" href="#3modelmap参数"></a> 3.ModelMap参数</h5><ul><li>将该对象作为方法的参数，然后将数据绑定到该对象</li></ul><pre><code class="highlight plaintext">       @RequestMapping(&quot;/login6.do&quot;)//像页面传值的第三种方式：使用ModelMap       public String login6(AdminParam ap,ModelMap mm) &#123;             System.out.println(&quot;login6()&quot;);             String adminCode = ap.getAdminCode();             System.out.println(adminCode);             //相当于request。setAttribute...             mm.addAttribute(&quot;adminCode&quot;,adminCode);             return &quot;index&quot;;       &#125;</code></pre><blockquote><p>ModelMap数据会利用HttpServletRequest的Attribute传递到JSP页面中</p></blockquote><h5 id="4modelattribute"><a class="markdownIt-Anchor" href="#4modelattribute"></a> 4.@ModelAttribute</h5><ul><li>在Controller方法的参数部分或Bean属性方法上使用</li></ul><pre><code class="highlight plaintext"> @RequestMappint(&quot;/login-action6.form&quot;) public String checkLogin6(@ModelAttribute(&quot;user&quot;)User user)&#123;     return &quot;success&quot;; &#125; @ModelAttribute(&quot;name&quot;)public String getName()&#123; return name;&#125;</code></pre><blockquote><p>ModelMap数据会利用HttpServletRequest的Attribute传递到JSP页面中</p></blockquote><h5 id="5sessioin存储"><a class="markdownIt-Anchor" href="#5sessioin存储"></a> 5.Sessioin存储</h5><ul><li>可以利用HttpServletRequest的getSession()方法访问</li><li>request的生命周期是一次请求的响应时间内可以使用，session的生命周期多次请求都可以使用，存在时间是30分钟（优先使用生命周期短的）</li><li>前端控制器DispatcherServlet会使用反射机制分析这个方法的参数，如果有session则会把session对象传入进来</li></ul><pre><code class="highlight plaintext">       @RequestMapping(&quot;login7.do&quot;)       //像页面传值的第四种方式：使用Session       public String login7(AdminParam ap,HttpSession session) &#123;             System.out.println(&quot;login7&quot;);             String adminCode = ap.getAdminCode();             System.out.println(adminCode);             session.setAttribute(&quot;adminCode&quot;, adminCode);             return &quot;index&quot;;       &#125;</code></pre><ul><li>案例2：就是每次访问为session中的count+1.</li></ul><pre><code class="highlight plaintext">    @RequestMapping(&quot;/check&quot;)    public ModelAndView check(HttpSession session) &#123;        Integer i = (Integer) session.getAttribute(&quot;count&quot;);        if (i == null)            i = 0;        i++;        session.setAttribute(&quot;count&quot;, i);        ModelAndView mav = new ModelAndView(&quot;check&quot;);        return mav;    &#125;</code></pre><ul><li>check.jsp</li></ul><pre><code class="highlight plaintext">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot; isELIgnored=&quot;false&quot;%&gt;session中记录的访问次数：$&#123;count&#125;</code></pre><h3 id="controller返回值"><a class="markdownIt-Anchor" href="#controller返回值"></a> Controller返回值</h3><ul><li>一个包含模型和视图的ModelAndView 对象。</li><li>一个模型对象，这主要包括Spring 封装好的Model 和ModelMap ，以及java.util.Map ，当没有视图返回的时候视图名称将由RequestToViewNameTranslator 来决定。</li><li>一个View 对象。这个时候如果在渲染视图的过程中模型的话就可以给处理器方法定义一个模型参数，然后在方法体里面往模型中添加值。</li><li>一个String 字符串。这往往代表的是一个视图名称。这个时候如果需要在渲染视图的过程中需要模型的话就可以给处理器方法一个模型参数，然后在方法体里面往模型中添加值就可以了。</li><li>返回值是void 。这种情况一般是我们直接把返回结果写到HttpServletResponse 中了，如果没有写的话，那么Spring 将会利用RequestToViewNameTranslator 来返回一个对应的视图名称。如果视图中需要模型的话，处理方法与返回字符串的情况相同。</li><li>如果处理器方法被注解@ResponseBody 标记的话，那么处理器方法的任何返回类型都会通过HttpMessageConverters 转换之后写到HttpServletResponse 中，而不会像上面的那些情况一样当做视图或者模型来处理。</li><li>除以上几种情况之外的其他任何返回类型都会被当做模型中的一个属性来处理，而返回的视图还是由RequestToViewNameTranslator 来决定，添加到模型中的属性名称可以在该方法上用@ModelAttribute(“attributeName”) 来定义，否则将使用返回类型的类名称的首字母小写形式来表示。使用@ModelAttribute 标记的方法会在@RequestMapping 标记的方法执行之前执行。</li></ul><h4 id="不用注解修饰"><a class="markdownIt-Anchor" href="#不用注解修饰"></a> 不用注解修饰</h4><h5 id="返回modelandview"><a class="markdownIt-Anchor" href="#返回modelandview"></a> <strong>返回ModelAndView</strong></h5><p>controller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定view</p><pre><code class="highlight plaintext">@Controllerpublic class ItemController &#123;    @Autowired    ItemService service;    @RequestMapping(&quot;queryItem&quot;)    public ModelAndView queryItem()&#123;        List&lt;Item&gt; items = service.queryItemList();        ModelAndView modelAndView = new ModelAndView();        modelAndView.addObject(&quot;itemList&quot;,items);        //设置视图（逻辑路径）        modelAndView.setViewName(&quot;item-list&quot;);        return modelAndView;    &#125;&#125;</code></pre><h5 id="返回void"><a class="markdownIt-Anchor" href="#返回void"></a> <strong>返回void</strong></h5><ul><li>request/response</li></ul><p>在controller<strong>方法形参上可以定义request和response</strong>，使用request或response指定响应结果：</p><pre><code class="highlight plaintext">void service(HttpServletRequest request,HttpServletResponse response,Model model)&#123;    //可以使用request绑定返回值    request.setAttribute(&quot;itemList&quot;, itemList);    //也可以使用model绑定返回值    model.addAttribute(&quot;itemList&quot;, itemList);          //使用request转发向页面（ModelAndView底层用的其实也是转发）    request.getRequestDispatcher(&quot;页面路径&quot;).forward(request, response);    //也可以使用response页面重定向    response.sendRedirect(&quot;url&quot;)    //也可以通过response指定响应结果，例如响应json数据如下：    response.setCharacterEncoding(&quot;utf-8&quot;);    response.setContentType(&quot;application/json;charset=utf-8&quot;);    response.getWriter().write(&quot;json串&quot;);&#125;</code></pre><h5 id="返回字符串推荐"><a class="markdownIt-Anchor" href="#返回字符串推荐"></a> <strong>返回字符串（推荐）</strong></h5><h6 id="逻辑视图名"><a class="markdownIt-Anchor" href="#逻辑视图名"></a> 逻辑视图名</h6><pre><code class="highlight plaintext">return &quot;item/item-list&quot;;</code></pre><h6 id="redirect重定向"><a class="markdownIt-Anchor" href="#redirect重定向"></a> <strong>redirect重定向</strong></h6><ul><li>Spring MVC默认采用转发方式定位视图，如果需要重定向方式可采用下面几种方法<ul><li>使用RedirectView<code>（如果返回值是ModelAndView）</code></li><li>使用redirect:前缀<code>（如果返回值是String）</code></li></ul></li></ul><p><strong>RedirectView</strong></p><ul><li>如果Controller的请求处理方法返回的是ModelAndView对象，可以使用RedirectView方法重定向</li></ul><pre><code class="highlight plaintext">       @RequestMapping(&quot;/login9.do&quot;)       //重定向第二种方法：使用RedirectView       public ModelAndView login9() &#123;             System.out.println(&quot;login9&quot;);             RedirectView rv = new RedirectView(&quot;toIndex.do&quot;);             return new ModelAndView(rv);       &#125;</code></pre><p><strong>redirect</strong></p><ul><li>重定向到其他网址</li><li>重定向到其他视图</li></ul><pre><code class="highlight plaintext">//testRedirect：url，可以是url网址，也可以是其他requestMappingreturn &quot;redirect:testRedirect&quot;;//直接重定向到http://www.baidu.comreturn &quot;redirect:http://www.baidu.com&quot;;//重定向到其他requestMapping,重定向到下面的controller中return &quot;redirect:testRedirect&quot;;@RequestMapping(&quot;testRedirect&quot;)public String testRedirect(HttpServletRequest request) &#123;&#125;</code></pre><blockquote><p>相当于<code>response.sendRedirect()</code>，<strong>浏览器URL发生改变，Request域不共享</strong></p></blockquote><h6 id="forward转发"><a class="markdownIt-Anchor" href="#forward转发"></a> <strong>forward转发</strong></h6><p>转发：从Controller转发到jsp然后再返回给浏览器</p><pre><code class="highlight plaintext">//testRedirect：url，可以是url网址，也可以是其他requestMappingreturn &quot;forward:testForward&quot;;</code></pre><blockquote><p>相当于<code>request.getRequestDispatcher().forward(request,response)</code>，<strong>浏览器URL不发生改变，Request域可以共享</strong></p></blockquote><h4 id="使用注解修饰responsebody"><a class="markdownIt-Anchor" href="#使用注解修饰responsebody"></a> 使用注解修饰@ResponseBody</h4><p><strong>返回带@ResponseBody注解的值</strong></p><p>@<strong>ResponseBody</strong>的作用：</p><ul><li>将返回的<strong>pojo类型转换为json格式</strong>返回给浏览器（将响应体的Content-Type设置为application/json；charset=utf-8）<br />将返回的<strong>字符串类型直接返回</strong>给浏览器（将响应体的Content-Type设置为text/plain；charset=utf-8）</li><li>ResponseBody注解可以通过内置的9种HttpMessageConverter，匹配<strong>不同的Controller返回值类型</strong>，然后进行不同的<strong>消息转换处理</strong></li><li>将转换之后的数据放到HttpServletResponse对象的<strong>响应体</strong>返回到页面，不同的HttpMessageConverter处理的数据，指定的<strong>ContentType值</strong>也不同</li></ul><pre><code class="highlight plaintext">@RequestMapping(&quot;jsonTest&quot;)@ResponseBodypublic Item jsonTest()&#123;    Item item = service.queryItemById(1);    System.out.println(item);    return item;&#125;</code></pre><p>@<strong>RequestBody</strong></p><ul><li>注解的作用和@ResponseBody注解正好相反，它是处理<strong>请求参数</strong>的Http消息转换的</li></ul><hr /><p><strong>常用的HttpMessageConverter</strong></p><ul><li><code>MappingJacksonHttpMessageConverter</code>处理POJO类型返回值<ul><li>默认使用MappingJackson的JSON处理能力，将后台返回的Java对象（POJO类型）</li><li>转为JSON格式输出到页面,将响应体的Content-Type设置为application/json；charset=utf-8</li></ul></li><li><code>StringHttpMessageConverter</code>处理String类型返回值<ul><li>调用response.getWriter()方法将String类型的字符串写回给调用者。</li><li>将响应体的Content-Type设置为text/plain；charset=utf-8</li></ul></li></ul><h5 id="restcontroller"><a class="markdownIt-Anchor" href="#restcontroller"></a> @RestController</h5><p>@RestController相当于@<strong>Controller和@ResponseBody</strong>的组合</p><p>该类所有方法的返回值都将被@ResponseBody注解给修饰</p><pre><code class="highlight plaintext">@RestControllerpublic class RestItemController &#123;&#125;</code></pre><h3 id="controlleradvice"><a class="markdownIt-Anchor" href="#controlleradvice"></a> @ControllerAdvice</h3><p>ControllerAdvice标注的Class的作用是用来辅助Controller的，我们可以在ControllerAdvice标注的Class中使用@ExceptionHandler、@InitBinder和@ModelAttribute标记对应的方法，以便它们可以对指定范围内的Controller起作用</p><ul><li>@ExceptionHandler：用来进行异常处理的</li><li>@InitBinder：</li><li>@ModelAttribute：</li></ul><p>在没有ControllerAdvice时，我们定义的<code>@ExceptionHandler、@InitBinder和@ModelAttribute</code>都只能在Controller中<strong>对当前Controller生效</strong>，如果需要让更多的Controller应用相同的逻辑，只能把它们定义在共同的父类中。有了ControllerAdvice后则可以把它们定义在使用@ControllerAdvice标注的Class中</p><p><strong>ControllerAdvice定义的Class是有作用范围的</strong>，默认情况下，什么参数都不指定时它的作用范围是所有的范围。ControllerAdvice提供了一些可以缩小它的处理范围的参数。</p><ul><li>value：数组类型，用来指定可以作用的基包，即将对指定的包下面的Controller及其子包下面的Controller起作用。</li><li>basePackages：数组类型，等价于value。</li><li>basePackageClasses：数组类型，此时的基包将以指定的Class所在的包为准。</li><li>assignableTypes：数组类型，用来指定具体的Controller类型，它可以是一个共同的接口或父类等。</li><li>annotations：数组类型，用来指定Class上拥有指定的注解的Controller。</li></ul><ol><li>下面的ControllerAdvice将对定义在com.elim.app.mvc.controller包及其子包中的Controller起作用</li></ol><pre><code class="highlight plaintext">@ControllerAdvice(value=&quot;com.elim.app.mvc.controller&quot;)//@ControllerAdvice(basePackages=&quot;com.elim.app.mvc.controller&quot;)public class DefaultExceptionHandler &#123;    //...&#125;</code></pre><ol><li>下面的ControllerAdvice也将对定义在com.elim.app.mvc.controller包及其子包中的Controller起作用。它通过basePackageClasses指定了需要作为基包的Class，此时基包将以basePackageClasses指定的Class所在的包为准，即com.elim.app.mvc.controller</li></ol><pre><code class="highlight plaintext">@ControllerAdvice(basePackageClasses=com.elim.app.mvc.controller.Package.class)public class DefaultExceptionHandler &#123;    //...&#125;</code></pre><ol><li>下面的ControllerAdvice将对FooController及其子类型的Controller起作用。</li></ol><pre><code class="highlight plaintext">@ControllerAdvice(assignableTypes=FooController.class)public class DefaultExceptionHandler &#123;    //...&#125;</code></pre><ol><li>下面的ControllerAdvice将对所有Class上使用了RestController注解标注的Controller起作用。</li></ol><pre><code class="highlight plaintext">@ControllerAdvice(annotations=RestController.class)public class DefaultExceptionHandler &#123;    //...&#125;</code></pre><ol><li>也可以同时指定多个属性，比如下面的ControllerAdvice将对FooController及其子类型的Controller起作用，同时也将对com.elim.app.mvc.controller包及其子包下面的Controller起作用。</li></ol><pre><code class="highlight plaintext">@ControllerAdvice(assignableTypes=FooController.class, basePackages=&quot;com.elim.app.mvc.controller&quot;)public class DefaultExceptionHandler &#123;    //...&#125;</code></pre><blockquote><p>当一个异常可以同时被多个ControllerAdvice的@ExceptionHandler标注的方法处理时只有第一个匹配的处理器方法可以处理。</p></blockquote><h4 id="exceptionhandler"><a class="markdownIt-Anchor" href="#exceptionhandler"></a> @ExceptionHandler</h4><p>springMVC提供的异常处理主要有两种方式，一种是直接实现自己的HandlerExceptionResolver，当然这也包括使用Spring已经为我们提供好的SimpleMappingExceptionResolver和DefaultHandlerExceptionResolver，另一种是使用注解的方式实现一个专门用于处理异常的Controller——ExceptionHandler</p><p>比如下面的示例中就在ControllerAdvice标注的Class中定义了两个使用ExceptionHandler标注的方法以处理对应的异常，其中handleException()方法将用来处理除java.lang.IllegalStateException以外的所有其它异常，它的处理结果是转到一个固定的视图上。而handleIllegalStateException()将用来处理java.lang.IllegalStateException，它的处理结果是以JSON的形式响应的。</p><ul><li>在@ExceptionHandler标注的处理方法中如果希望获取到当前抛出的异常，则可以在方法参数中声明一个需要处理的异常类型的参数，SpringMVC在调用对应的处理方法处理异常时将传递当前的异常对象。</li><li>@ExceptionHandler标注的处理方法可以声明任何正常的处理器方法可以声明的参数类型，比如HttpServletRequest、HttpServletResponse、java.util.Map、Model等。</li><li>@ExceptionHandler标注的处理方法的返回结果也可以跟正常的Controller处理方法拥有一样的返回类型，比如String、Model、ModelAndView、void、Object等，所以我们可以把它看作是和Controller处理方法等价的方法定义的这么一个方法。</li></ul><pre><code class="highlight plaintext">@ControllerAdvicepublic class DefaultExceptionHandler &#123;    /**         * 该方法将处理SpringMVC处理过程中抛出的所有的异常，         * 将使用该方法的返回值来替换正常的Controller方法的返回值         * @param e         * @return         */    @ExceptionHandler(Exception.class)    public ModelAndView handleException(Exception e) &#123;        return new ModelAndView(&quot;viewName&quot;);    &#125;        /**         * 该方法将处理SpringMVC过程中抛出的所有的java.lang.IllegalStateException，         * 而其它异常的处理还由上面定义的handleException()处理。当抛出了一个异常可以同时被         * 多个@ExceptionHandler标注的方法处理时，对应的异常将交由更精确的异常处理方法处理。         *          * 且抛出该异常时将把处理结果以@ResponseBody的形式返回，此时将被当作JSON返回。         * @param e         * @return         */    @ExceptionHandler(IllegalStateException.class)    @ResponseBody    public Object handleIllegalStateException(IllegalStateException e) &#123;        Map&lt;String, Object&gt; jsonObj = new HashMap&lt;&gt;();        jsonObj.put(&quot;errorMessage&quot;, e.getMessage());        return jsonObj;    &#125;    &#125;</code></pre><p><strong>使用@ExceptionHandler进行处理有一个不好的地方是进行异常处理的方法必须与出错的方法在同一个Controller里面</strong></p><pre><code class="highlight plaintext">import org.springframework.stereotype.Controller;  import org.springframework.web.bind.annotation.ExceptionHandler;  import org.springframework.web.bind.annotation.RequestMapping;  import com.tiantian.blog.web.servlet.MyException;  @Controller  public class GlobalController &#123;  /**  * 用于处理异常的  * @return  */  @ExceptionHandler(&#123;MyException.class&#125;)  public String exception(MyException e) &#123;      System.out.println(e.getMessage());      e.printStackTrace();      return &quot;exception&quot;;  &#125;    @RequestMapping(&quot;test&quot;)  public void test() &#123;      throw new MyException(&quot;出错了！&quot;);  &#125;    &#125;</code></pre><h4 id="initbinder"><a class="markdownIt-Anchor" href="#initbinder"></a> @InitBinder</h4><p>在通过处理器方法参数接收 request 请求参数绑定数据的时候，对于一些简单的数据类型 Spring 会帮我们自动进行类型转换，而对于一些复杂的类型由于 Spring 没法识别，所以也就不能帮助我们进行自动转换了，这个时候如果我们需要 Spring 来帮我们自动转换的话就需要我们给 Spring 注册一个对特定类型的识别转换器。 Spring 允许我们提供两种类型的识别转换器，一种是注册在 Controller 中的，一种是注册在 SpringMVC 的配置文件中。聪明的读者看到这里应该可以想到它们的区别了，定义在 Controller 中的是局部的，只在当前 Controller 中有效，而放在 SpringMVC 配置文件中的是全局的，所有 Controller 都可以拿来使用</p><p>自定义springMVC的属性编辑器主要有两种方式，</p><ul><li>一种是使用@InitBinder标签在运行期注册一个属性编辑器，这种编辑器只在当前Controller里面有效；</li><li>还有一种是实现自己的 WebBindingInitializer，然后定义一个 AnnotationMethodHandlerAdapter的bean，在此bean里面进行注册 ，这种属性编辑器是全局的</li></ul><p>我们可以使用 @InitBinder 注解标注在 Controller 方法上，然后在方法体里面注册数据绑定的转换器，这主要是通过 WebDataBinder 进行的。我们可以给需要注册数据绑定的转换器的方法一个 WebDataBinder 参数，然后给该方法加上 @InitBinder 注解，这样当该 Controller 中在处理请求方法时如果发现有不能解析的对象的时候，就会看该类中是否有使用 @InitBinder 标记的方法，如果有就会执行该方法，然后看里面定义的类型转换器是否与当前需要的类型匹配</p><p>使用示例一：</p><pre><code class="highlight plaintext">@Controller  @RequestMapping ( &quot;/myTest&quot; )  public class MyController &#123;        @InitBinder      public void dataBinder(WebDataBinder binder) &#123;         DateFormat dateFormat = new SimpleDateFormat( &quot;yyyyMMdd&quot; );         PropertyEditor propertyEditor = new CustomDateEditor(dateFormat, true ); // 第二个参数表示是否允许为空         binder.registerCustomEditor(Date. class , propertyEditor);      &#125;        @RequestMapping ( &quot;dataBinder/&#123;date&#125;&quot; )      public void testDate( @PathVariable Date date, Writer writer) throws IOException &#123;         writer.write(String.valueOf (date.getTime()));      &#125;  &#125;</code></pre><p>在上面的代码中当我们请求 /myTest/dataBinder/20121212.do 的时候， Spring 就会利用 @InitBinder 标记的方法里面定义的类型转换器把字符串 20121212 转换为一个 Date 对象。这样定义的类型转换器是局部的类型转换器，一旦出了这个 Controller 就不会再起作用。类型转换器是通过 WebDataBinder 对象的 registerCustomEditor 方法来注册的，要实现自己的类型转换器就要实现自己的 PropertyEditor 对象。 Spring 已经给我们提供了一些常用的属性编辑器，如 CustomDateEditor 、 CustomBooleanEditor 等</p><p>PropertyEditor 是一个接口，要实现自己的 PropertyEditor 类我们可以实现这个接口，然后实现里面的方法。但是 PropertyEditor 里面定义的方法太多了，这样做比较麻烦。在 java 中有一个封装类是实现了 PropertyEditor 接口的，它是 PropertyEditorSupport 类。所以如果需要实现自己的 PropertyEditor 的时候只需要继承 PropertyEditorSupport 类，然后重写其中的一些方法。一般就是重写 setAsText 和 getAsText 方法就可以了， setAsText 方法是用于把字符串类型的值转换为对应的对象的，而 getAsText 方法是用于把对象当做字符串来返回的。在 setAsText 中我们一般先把字符串类型的对象转为特定的对象，然后利用 PropertyEditor 的 setValue 方法设定转换后的值。在 getAsText 方法中一般先使用 getValue 方法取代当前的对象，然后把它转换为字符串后再返回给 getAsText 方法。下面是一个示例：</p><pre><code class="highlight plaintext">@InitBinder  public void dataBinder(WebDataBinder binder) &#123;  // 定义一个 User 属性编辑器  PropertyEditor userEditor = new PropertyEditorSupport() &#123;     @Override     public String getAsText() &#123;        // TODO Auto-generated method stub        User user = (User) getValue();        return user.getUsername();     &#125;     @Override     public void setAsText(String userStr) throws IllegalArgumentException &#123;        // TODO Auto-generated method stub        User user = new User(1, userStr);        setValue(user);     &#125;  &#125;;  // 使用 WebDataBinder 注册 User 类型的属性编辑器  binder.registerCustomEditor(User. class , userEditor);  &#125;</code></pre><p>使用示例二：</p><pre><code class="highlight plaintext">import java.beans.PropertyEditorSupport;  import java.io.IOException;  import java.text.SimpleDateFormat;  import java.util.Date;  import javax.servlet.http.HttpServletResponse;  import org.springframework.beans.propertyeditors.CustomDateEditor;  import org.springframework.stereotype.Controller;  import org.springframework.web.bind.WebDataBinder;  import org.springframework.web.bind.annotation.InitBinder;  import org.springframework.web.bind.annotation.PathVariable;  import org.springframework.web.bind.annotation.RequestMapping;  @Controller  public class GlobalController &#123;    @RequestMapping(&quot;test/&#123;date&#125;&quot;)  public void test(@PathVariable Date date, HttpServletResponse response) throws IOException      response.getWriter().write( date);  &#125;    @InitBinder//必须有一个参数WebDataBinder  public void initBinder(WebDataBinder binder) &#123;      binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;), false));  binder.registerCustomEditor(int.class, new PropertyEditorSupport() &#123;  @Override  public String getAsText() &#123;      // TODO Auto-generated method stub      return getValue().toString();  &#125;  @Override  public void setAsText(String text) throws IllegalArgumentException &#123;      // TODO Auto-generated method stub      System.out.println(text + &quot;...........................................&quot;);      setValue(Integer.parseInt(text));  &#125;        &#125;);  &#125;  &#125;</code></pre><hr /><p>第二种属性编辑器的方式：</p><p>如果需要定义全局的类型转换器就需要实现自己的 WebBindingInitializer 对象，然后把该对象注入到 AnnotationMethodHandlerAdapter 中，这样 Spring 在遇到自己不能解析的对象的时候就会到全局的 WebBindingInitializer 的 initBinder 方法中去找，每次遇到不认识的对象时， initBinder 方法都会被执行一遍</p><ol><li>定义自己的WebBindingInitializer</li></ol><pre><code class="highlight plaintext">public class MyWebBindingInitializer implements WebBindingInitializer &#123;        @Override      public void initBinder(WebDataBinder binder, WebRequest request) &#123;         // TODO Auto-generated method stub         DateFormat dateFormat = new SimpleDateFormat( &quot;yyyyMMdd&quot; );         PropertyEditor propertyEditor = new CustomDateEditor(dateFormat, true );         binder.registerCustomEditor(Date. class , propertyEditor);      &#125;  &#125;</code></pre><blockquote><p>定义了这么一个 WebBindingInitializer 对象之后 Spring 还是不能识别其中指定的对象，这是因为我们只是定义了 WebBindingInitializer 对象，还没有把它交给 Spring ， Spring 不知道该去哪里找解析器。要让 Spring 能够识别还需要我们在 SpringMVC 的配置文件中定义一个 AnnotationMethodHandlerAdapter 类型的 bean 对象，然后利用自己定义的 WebBindingInitializer 覆盖它的默认属性 webBindingInitializer</p></blockquote><ol><li>在springMVC的配置文件里面定义一个AnnotationMethodHandlerAdapter，并设置其WebBindingInitializer属性为我们自己定义的WebBindingInitializer对象</li></ol><pre><code class="highlight plaintext">&lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;&gt;      &lt;property name=&quot;cacheSeconds&quot; value=&quot;0&quot;/&gt;      &lt;property name=&quot;webBindingInitializer&quot;&gt;  &lt;bean class=&quot;com.xxx.blog.util.MyWebBindingInitializer&quot;/&gt;      &lt;/property&gt;  &lt;/bean&gt;</code></pre><blockquote><p>注意：当使用了&lt;mvc:annotation-driven /&gt;的时候，它 会自动注册DefaultAnnotationHandlerMapping与AnnotationMethodHandlerAdapter 两个bean。这时候第二种方式指定的全局属性编辑器就不会起作用了，解决办法就是手动的添加上述bean，并把它们加在<code>&lt;mvc:annotation-driven/&gt;</code>的前面。如果不生效，则将手动注册AnnotationMethodHandlerAdapter改为手动注册RequestMappingHandlerAdapter</p></blockquote><hr /><p>3.触发数据绑定方法的时间</p><p>当Controller处理器方法参数使用@RequestParam、@PathVariable、@RequestHeader、@CookieValue和@ModelAttribute标记的时候都会触发initBinder方法的执行，这包括使用WebBindingInitializer定义的全局方法和在Controller中使用@InitBinder标记的局部方法。而且每个使用了这几个注解标记的参数都会触发一次initBinder方法的执行，这也意味着有几个参数使用了上述注解就会触发几次initBinder方法的执行。</p><h5 id="防止xss注入"><a class="markdownIt-Anchor" href="#防止xss注入"></a> 防止XSS注入</h5><pre><code class="highlight plaintext">@InitBinderprotected void initBinder(WebDataBinder binder) &#123;    // String类型转换，将所有传递进来的String进行HTML编码，防止XSS攻击    binder.registerCustomEditor(String.class, new PropertyEditorSupport() &#123;        @Override        public void setAsText(String text) &#123;            setValue(text == null ? null : StringEscapeUtils.escapeJavaScript(text.trim()));        &#125;        @Override        public String getAsText() &#123;            Object value = getValue();            return value != null ? value.toString() : &quot;&quot;;        &#125;    &#125;);&#125;</code></pre><h4 id="modelattribute"><a class="markdownIt-Anchor" href="#modelattribute"></a> @ModelAttribute</h4><p>使用 @ModelAttribute 和 @SessionAttributes 传递和保存数据</p><p>SpringMVC 支持使用 @ModelAttribute 和 @SessionAttributes 在不同的模型和控制器之间共享数据</p><p>@ModelAttribute 主要有两种使用方式，一种是标注在方法上，一种是标注在 Controller 方法参数上</p><p>当 @ModelAttribute 标记在方法上的时候，该方法将在处理器方法执行之前执行，然后把返回的对象存放在 session 或模型属性中，属性名称可以使用 @ModelAttribute(“attributeName”) 在标记方法的时候指定，若未指定，则使用返回类型的类名称（首字母小写）作为属性名称。关于 @ModelAttribute 标记在方法上时对应的属性是存放在 session 中还是存放在模型中，我们来做一个实验，看下面一段代码。</p><pre><code class="highlight plaintext">@Controller  @RequestMapping ( &quot;/myTest&quot; )  public class MyController &#123;        @ModelAttribute ( &quot;hello&quot; )      public String getModel() &#123;         System. out .println( &quot;-------------Hello---------&quot; );         return &quot;world&quot; ;      &#125;        @ModelAttribute ( &quot;intValue&quot; )      public int getInteger() &#123;         System. out .println( &quot;-------------intValue---------------&quot; );         return 10;      &#125;        @RequestMapping ( &quot;sayHello&quot; )      public void sayHello( @ModelAttribute ( &quot;hello&quot; ) String hello, @ModelAttribute ( &quot;intValue&quot; ) int num, @ModelAttribute ( &quot;user2&quot; ) User user, Writer writer, HttpSession session) throws IOException &#123;         writer.write( &quot;Hello &quot; + hello + &quot; , Hello &quot; + user.getUsername() + num);         writer.write( &quot;\r&quot; );         Enumeration enume = session.getAttributeNames();         while (enume.hasMoreElements())             writer.write(enume.nextElement() + &quot;\r&quot; );      &#125;        @ModelAttribute ( &quot;user2&quot; )      public User getUser() &#123;         System. out .println( &quot;---------getUser-------------&quot; );         return new User(3, &quot;user2&quot; );      &#125;  &#125;</code></pre><p>当我们请求 /myTest/sayHello.do 的时候使用 @ModelAttribute 标记的方法会先执行，然后把它们返回的对象存放到模型中。最终访问到 sayHello 方法的时候，使用 @ModelAttribute 标记的方法参数都能被正确的注入值。</p><p>由执行结果我们可以看出来，此时 session 中没有包含任何属性，也就是说上面的那些对象都是存放在模型属性中，而不是存放在 session 属性中。那要如何才能存放在 session 属性中呢？这个时候我们先引入一个新的概念 @SessionAttributes ，它的用法会在讲完 @ModelAttribute 之后介绍，这里我们就先拿来用一下。我们在 MyController 类上加上 @SessionAttributes 属性标记哪些是需要存放到 session 中的。看下面的代码：</p><pre><code class="highlight plaintext">@Controller  @RequestMapping ( &quot;/myTest&quot; )  @SessionAttributes (value=&#123; &quot;intValue&quot; , &quot;stringValue&quot; &#125;, types=&#123;User. class &#125;)  public class MyController &#123;        @ModelAttribute ( &quot;hello&quot; )      public String getModel() &#123;         System. out .println( &quot;-------------Hello---------&quot; );         return &quot;world&quot; ;      &#125;        @ModelAttribute ( &quot;intValue&quot; )      public int getInteger() &#123;         System. out .println( &quot;-------------intValue---------------&quot; );         return 10;      &#125;           @RequestMapping ( &quot;sayHello&quot; )      public void sayHello(Map&lt;String, Object&gt; map, @ModelAttribute ( &quot;hello&quot; ) String hello, @ModelAttribute ( &quot;intValue&quot; ) int num, @ModelAttribute ( &quot;user2&quot; ) User user, Writer writer, HttpServletRequest request) throws IOException &#123;         map.put( &quot;stringValue&quot; , &quot;String&quot; );         writer.write( &quot;Hello &quot; + hello + &quot; , Hello &quot; + user.getUsername() + num);         writer.write( &quot;\r&quot; );         HttpSession session = request.getSession();         Enumeration enume = session.getAttributeNames();         while (enume.hasMoreElements())             writer.write(enume.nextElement() + &quot;\r&quot; );         System. out .println(session);      &#125;        @ModelAttribute ( &quot;user2&quot; )      public User getUser() &#123;         System. out .println( &quot;---------getUser-------------&quot; );         return new User(3, &quot;user2&quot; );      &#125;  &#125;</code></pre><p>在上面代码中我们指定了属性为 intValue 或 stringValue 或者类型为 User 的都会放到 Session 中，利用上面的代码当我们访问 /myTest/sayHello.do 的时候</p><p>仍然没有打印出任何 session 属性，这是怎么回事呢？怎么定义了把模型中属性名为 intValue 的对象和类型为 User 的对象存到 session 中，而实际上没有加进去呢？难道我们错啦？我们当然没有错，只是在第一次访问 /myTest/sayHello.do 的时候 @SessionAttributes 定义了需要存放到 session 中的属性，而且这个模型中也有对应的属性，但是这个时候还没有加到 session 中，所以 session 中不会有任何属性，等处理器方法执行完成后 Spring 才会把模型中对应的属性添加到 session 中。</p><p>当 @ModelAttribute 标记在处理器方法参数上的时候，表示该参数的值将从模型或者 Session 中取对应名称的属性值，该名称可以通过 @ModelAttribute(“attributeName”) 来指定，若未指定，则使用参数类型的类名称（首字母小写）作为属性名称。</p><pre><code class="highlight plaintext">@Controller  @RequestMapping ( &quot;/myTest&quot; )  public class MyController &#123;        @ModelAttribute ( &quot;hello&quot; )      public String getModel() &#123;         return &quot;world&quot; ;      &#125;        @RequestMapping ( &quot;sayHello&quot; )      public void sayHello( @ModelAttribute ( &quot;hello&quot; ) String hello, Writer writer) throws IOException &#123;         writer.write( &quot;Hello &quot; + hello);      &#125;     &#125;</code></pre><p>在上面代码中，当我们请求/myTest/sayHello.do 的时候，由于MyController 中的方法getModel 使用了注解@ModelAttribute 进行标记，所以在执行请求方法sayHello 之前会先执行getModel 方法，这个时候getModel 方法返回一个字符串world 并把它以属性名hello 保存在模型中，接下来访问请求方法sayHello 的时候，该方法的hello 参数使用@ModelAttribute(“hello”) 进行标记，这意味着将从session 或者模型中取属性名称为hello 的属性值赋给hello 参数，所以这里hello 参数将被赋予值world ，所以请求完成后将会在页面上看到Hello world 字符串</p><p>@SessionAttributes 用于标记需要在Session 中使用到的数据，包括从Session 中取数据和存数据。@SessionAttributes 一般是标记在Controller 类上的，可以通过名称、类型或者名称加类型的形式来指定哪些属性是需要存放在session 中的。</p><pre><code class="highlight plaintext">@Controller  @RequestMapping ( &quot;/myTest&quot; )  @SessionAttributes (value=&#123; &quot;user1&quot; , &quot;blog1&quot; &#125;, types=&#123;User. class , Blog. class &#125;)  public class MyController &#123;        @RequestMapping ( &quot;setSessionAttribute&quot; )      public void setSessionAttribute(Map&lt;String, Object&gt; map, Writer writer) throws IOException &#123;         User user = new User(1, &quot;user&quot; );         User user1 = new User(2, &quot;user1&quot; );         Blog blog = new Blog(1, &quot;blog&quot; );         Blog blog1 = new Blog(2, &quot;blog1&quot; );         map.put( &quot;user&quot; , user);         map.put( &quot;user1&quot; , user1);         map.put( &quot;blog&quot; , blog);         map.put( &quot;blog1&quot; , blog1);         writer.write( &quot;over.&quot; );      &#125;      @RequestMapping ( &quot;useSessionAttribute&quot; )      public void useSessionAttribute(Writer writer, @ModelAttribute ( &quot;user1&quot; ) User user1, @ModelAttribute ( &quot;blog1&quot; ) Blog blog1) throws IOException &#123;         writer.write(user1.getId() + &quot;--------&quot; + user1.getUsername());         writer.write( &quot;\r&quot; );         writer.write(blog1.getId() + &quot;--------&quot; + blog1.getTitle());      &#125;        @RequestMapping ( &quot;useSessionAttribute2&quot; )      public void useSessionAttribute(Writer writer, @ModelAttribute ( &quot;user1&quot; ) User user1, @ModelAttribute ( &quot;blog1&quot; ) Blog blog1, @ModelAttribute User user, HttpSession session) throws IOException &#123;         writer.write(user1.getId() + &quot;--------&quot; + user1.getUsername());         writer.write( &quot;\r&quot; );         writer.write(blog1.getId() + &quot;--------&quot; + blog1.getTitle());         writer.write( &quot;\r&quot; );         writer.write(user.getId() + &quot;---------&quot; + user.getUsername());         writer.write( &quot;\r&quot; );         Enumeration enume = session.getAttributeNames();         while (enume.hasMoreElements())             writer.write(enume.nextElement() + &quot; \r&quot; );      &#125;        @RequestMapping ( &quot;useSessionAttribute3&quot; )      public void useSessionAttribute( @ModelAttribute ( &quot;user2&quot; ) User user) &#123;        &#125;  &#125;</code></pre><p>在上面代码中我们可以看到在MyController 上面使用了@SessionAttributes 标记了需要使用到的Session 属性。可以通过名称和类型指定需要存放到Session 中的属性，对应@SessionAttributes 注解的value 和types 属性。当使用的是types 属性的时候，那么使用的Session 属性名称将会是对应类型的名称（首字母小写）。当value 和types 两个属性都使用到了的时候，这时候取的是它们的并集，而不是交集，所以上面代码中指定要存放在Session 中的属性有名称为user1 或blog1 的对象，或类型为User 或Blog 的对象。在上面代码中我们首先访问/myTest/setSessionAttribute.do ，该请求将会请求到MyController 的setSessionAttribute 方法，在该方法中，我们往模型里面添加了user 、user1 、blog 和blog1 四个属性，因为它们或跟类上的@SessionAttributes 定义的需要存到session 中的属性名称相同或类型相同，所以在请求完成后这四个属性都将添加到session 属性中。接下来访问/myTest/useSessionAttribute.do ，该请求将会请求MyController 的useSessionAttribute(Writer writer, @ModelAttribute(“user1”) User user1, @ModelAttribute(“blog1”) Blog blog) 方法，该方法参数中用@ModelAttribute 指定了参数user1 和参数blog1 是需要从session 或模型中绑定的，恰好这个时候session 中已经有了这两个属性，所以这个时候在方法执行之前会先绑定这两个参数。</p><p>接下来访问/myTest/useSessionAttribute2.do ，这个时候请求的是上面代码中对应的第二个useSessionAttribute 方法，方法参数user 、user1 和blog1 用@ModelAttribute 声明了需要session 或模型属性注入，我们知道在请求/myTest/setSessionAttribute.do 的时候这些属性都已经添加到了session 中</p><p>接下来访问/myTest/useSessionAttribute3.do ，这个时候请求的是上面代码中对应的第三个useSessionAttribute 方法，我们可以看到该方法的方法参数user 使用了@ModelAttribute(“user2”) 进行标记，表示user 需要session 中的user2 属性来注入，但是这个时候我们知道session 中是不存在user2 属性的，所以这个时候就会报错了。</p><h3 id="bmi健康指数案例"><a class="markdownIt-Anchor" href="#bmi健康指数案例"></a> bmi健康指数案例</h3><ul><li><h2 id="目录结构"><a class="markdownIt-Anchor" href="#目录结构"></a> 目录结构</h2></li><li>pom.xml</li></ul><pre><code class="highlight plaintext">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;com.lee.bmi&lt;/groupId&gt;  &lt;artifactId&gt;spring-bmi&lt;/artifactId&gt;  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;      &lt;dependencies&gt;              &lt;dependency&gt;                      &lt;groupId&gt;org.springframework&lt;/groupId&gt;                      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;                      &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;              &lt;/dependency&gt;              &lt;dependency&gt;                     &lt;groupId&gt;junit&lt;/groupId&gt;                     &lt;artifactId&gt;junit&lt;/artifactId&gt;                     &lt;version&gt;4.10&lt;/version&gt;              &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><ul><li>web.xml</li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; version=&quot;2.5&quot;&gt;       &lt;servlet&gt;             &lt;servlet-name&gt;&lt;u&gt;springmvc&lt;/u&gt;&lt;/servlet-name&gt;             &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;             &lt;!-- DispatcherServlet在初始化方法里面，会读取该初始化参数的值来获取spring配置文件的位置，然后启动spring容器 --&gt;             &lt;init-param&gt;                    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;                    &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;             &lt;/init-param&gt;             &lt;!-- 表示启动&lt;u&gt;tomcat&lt;/u&gt;立即启动容器实例化参数 --&gt;             &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;       &lt;/servlet&gt;       &lt;servlet-mapping&gt;             &lt;servlet-name&gt;&lt;u&gt;springmvc&lt;/u&gt;&lt;/servlet-name&gt;             &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;       &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><ul><li>springmvc.xml</li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:task=&quot;http://www.springframework.org/schema/task&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx-3.1.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop-3.1.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context-3.1.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd        http://www.springframework.org/schema/task        http://www.springframework.org/schema/task/spring-task-3.1.xsd&quot;&gt;             &lt;!-- 配置组件扫描 --&gt;       &lt;context:component-scan base-package=&quot;bmi&quot;/&gt;       &lt;!-- 配置mvc注解扫描 --&gt;       &lt;mvc:annotation-driven/&gt;       &lt;!-- 配置ViewResolver视图解析器 --&gt;       &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;             &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot;&gt;&lt;/property&gt;             &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;       &lt;/bean&gt;&lt;/beans&gt;</code></pre><ul><li>前端页面bmi_form.jsp/result.jsp</li></ul><pre><code class="highlight plaintext">bmi_form.jsp&lt;%@page pageEncoding=&quot;utf-8&quot; contentType=&quot;text/html; charset=utf-8&quot;%&gt;&lt;html&gt;       &lt;head&gt;bmi&lt;/head&gt;       &lt;body&gt;             &lt;form action=&quot;bmiContro.do&quot; method=&quot;post&quot;&gt;                    体重：&lt;input name=&quot;height&quot;/&gt;                    身高：&lt;input type=&quot;password&quot; name=&quot;weight&quot;/&gt;                    &lt;input type=&quot;submit&quot; value=&quot;测量&quot;/&gt;             &lt;/form&gt;       &lt;/body&gt;&lt;/html&gt;result.sjp&lt;%@page pageEncoding=&quot;utf-8&quot; contentType=&quot;text/html; charset=utf-8&quot;%&gt;&lt;html&gt;       &lt;head&gt;&lt;u&gt;bmi&lt;/u&gt;&lt;/head&gt;       &lt;body&gt;             &lt;h1&gt;$&#123;bmi&#125;&lt;/h1&gt;       &lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>HeightAndWeight.java</li></ul><pre><code class="highlight plaintext">package bmi;public class HeightAndWeigh &#123;       private int height;       private int weight;              public int getHeight() &#123;             return height;       &#125;       public void setHeight(int height) &#123;             this.height = height;       &#125;       public int getWeight() &#123;             return weight;       &#125;       public void setWeight(int weight) &#123;             this.weight = weight;       &#125;&#125;</code></pre><ul><li>bmiController.java</li></ul><pre><code class="highlight plaintext">package bmi;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class BmiController &#123;@RequestMapping(&quot;/toBmi.do&quot;)public String toBmi() &#123;System.out.println(&quot;toBmi&quot;);return &quot;bmi_form&quot;;&#125;@RequestMapping(&quot;/bmiContro.do&quot;)    //框架会自动吧from表单的参数封装成我们自定义的bean对象HeightAdnWeigh传入进来public String bmiContro(HeightAndWeigh haw,ModelMap mm) &#123;System.out.println(&quot;bmiContro&quot;);int bmi = haw.getWeight()/haw.getHeight()/haw.getHeight();if(bmi&gt;23) &#123;mm.addAttribute(&quot;bmi&quot;, &quot;过重&quot;);&#125;else if(bmi&lt;19) &#123;mm.addAttribute(&quot;bmi&quot;, &quot;过轻&quot;);&#125;else &#123;mm.addAttribute(&quot;bmi&quot;, &quot;正常&quot;);&#125;return &quot;result&quot;;&#125;&#125;</code></pre><h2 id="集成filter"><a class="markdownIt-Anchor" href="#集成filter"></a> 集成Filter</h2><p>有的童鞋在上一节的Web应用中可能发现了，如果注册时输入中文会导致乱码，因为Servlet默认按非UTF-8编码读取参数。为了修复这一问题，我们可以简单地使用一个EncodingFilter，在全局范围类给HttpServletRequest和HttpServletResponse强制设置为UTF-8编码。</p><p>可以自己编写一个EncodingFilter，也可以直接使用Spring MVC自带的一个CharacterEncodingFilter。配置Filter时，只需在web.xml中声明即可：</p><pre><code class="highlight plaintext">&lt;web-app&gt;    &lt;filter&gt;        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;UTF-8&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;            &lt;param-name&gt;forceEncoding&lt;/param-name&gt;            &lt;param-value&gt;true&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    ...&lt;/web-app&gt;</code></pre><p>因为这种Filter和我们业务关系不大，注意到CharacterEncodingFilter其实和Spring的IoC容器没有任何关系，两者均互不知晓对方的存在，因此，配置这种Filter十分简单。</p><p>我们再考虑这样一个问题：如果允许用户使用Basic模式进行用户验证，即在HTTP请求中添加头Authorization: Basic email:password，这个需求如何实现？</p><pre><code class="highlight plaintext">@Componentpublic class AuthFilter implements Filter &#123;    @Autowired    UserService userService;    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)            throws IOException, ServletException &#123;        HttpServletRequest req = (HttpServletRequest) request;        // 获取Authorization头:        String authHeader = req.getHeader(&quot;Authorization&quot;);        if (authHeader != null &amp;&amp; authHeader.startsWith(&quot;Basic &quot;)) &#123;            // 从Header中提取email和password:            String email = prefixFrom(authHeader);            String password = suffixFrom(authHeader);            // 登录:            User user = userService.signin(email, password);            // 放入Session:            req.getSession().setAttribute(UserController.KEY_USER, user);        &#125;        // 继续处理请求:        chain.doFilter(request, response);    &#125;&#125;</code></pre><p>现在问题来了：在Spring中创建的这个AuthFilter是一个普通Bean，Servlet容器并不知道，所以它不会起作用。</p><p>如果我们直接在web.xml中声明这个AuthFilter，注意到AuthFilter的实例将由Servlet容器而不是Spring容器初始化，因此，@Autowire根本不生效，用于登录的UserService成员变量永远是null。</p><p>所以，得通过一种方式，让Servlet容器实例化的Filter，间接引用Spring容器实例化的AuthFilter。Spring MVC提供了一个DelegatingFilterProxy，专门来干这个事情：</p><pre><code class="highlight plaintext">&lt;web-app&gt;    &lt;filter&gt;        &lt;filter-name&gt;authFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;authFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    ...&lt;/web-app&gt;</code></pre><p>我们来看实现原理：</p><ol><li>Servlet容器从web.xml中读取配置，实例化DelegatingFilterProxy，注意命名是authFilter；</li><li>Spring容器通过扫描@Component实例化AuthFilter。</li></ol><p>当DelegatingFilterProxy生效后，它会自动查找注册在ServletContext上的Spring容器，再试图从容器中查找名为authFilter的Bean，也就是我们用@Component声明的AuthFilter。</p><p>DelegatingFilterProxy将请求代理给AuthFilter，核心代码如下：</p><pre><code class="highlight plaintext">public class DelegatingFilterProxy implements Filter &#123;    private Filter delegate;    public void doFilter(...) throws ... &#123;        if (delegate == null) &#123;            delegate = findBeanFromSpringContainer();        &#125;        delegate.doFilter(req, resp, chain);    &#125;&#125;</code></pre><p>这就是一个代理模式的简单应用。我们画个图表示它们之间的引用关系如下：</p><p>如果在web.xml中配置的Filter名字和Spring容器的Bean的名字不一致，那么需要指定Bean的名字：</p><pre><code class="highlight plaintext">&lt;filter&gt;    &lt;filter-name&gt;basicAuthFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;    &lt;!-- 指定Bean的名字 --&gt;    &lt;init-param&gt;        &lt;param-name&gt;targetBeanName&lt;/param-name&gt;        &lt;param-value&gt;authFilter&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;</code></pre><h2 id="使用interceptor"><a class="markdownIt-Anchor" href="#使用interceptor"></a> 使用Interceptor</h2><p>在Web程序中，注意到使用Filter的时候，Filter由Servlet容器管理，它在Spring MVC的Web应用程序中作用范围如下：</p><p>上图虚线框就是Filter2的拦截范围，Filter组件实际上并不知道后续内部处理是通过Spring MVC提供的DispatcherServlet还是其他Servlet组件，因为Filter是Servlet规范定义的标准组件，它可以应用在任何基于Servlet的程序中。</p><p>如果只基于Spring MVC开发应用程序，还可以使用Spring MVC提供的一种功能类似Filter的拦截器：Interceptor。和Filter相比，Interceptor拦截范围不是后续整个处理流程，而是仅针对Controller拦截：</p><p>上图虚线框就是Interceptor的拦截范围，注意到Controller的处理方法一般都类似这样：</p><pre><code class="highlight plaintext">@Controllerpublic class Controller1 &#123;    @GetMapping(&quot;/path/to/hello&quot;)    ModelAndView hello() &#123;        ...    &#125;&#125;</code></pre><p>所以，Interceptor的拦截范围其实就是Controller方法，它实际上就相当于基于AOP的方法拦截。因为Interceptor只拦截Controller方法，所以要注意，返回ModelAndView并渲染后，后续处理就脱离了Interceptor的拦截范围。</p><p>使用Interceptor的好处是Interceptor本身是Spring管理的Bean，因此注入任意Bean都非常简单。此外，可以应用多个Interceptor，并通过简单的@Order指定顺序。我们先写一个LoggerInterceptor：</p><pre><code class="highlight plaintext">@Order(1)@Componentpublic class LoggerInterceptor implements HandlerInterceptor &#123;    final Logger logger = LoggerFactory.getLogger(getClass());    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        logger.info(&quot;preHandle &#123;&#125;...&quot;, request.getRequestURI());        if (request.getParameter(&quot;debug&quot;) != null) &#123;            PrintWriter pw = response.getWriter();            pw.write(&quot;&lt;p&gt;DEBUG MODE&lt;/p&gt;&quot;);            pw.flush();            return false;        &#125;        return true;    &#125;    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        logger.info(&quot;postHandle &#123;&#125;.&quot;, request.getRequestURI());        if (modelAndView != null) &#123;            modelAndView.addObject(&quot;__time__&quot;, LocalDateTime.now());        &#125;    &#125;    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;        logger.info(&quot;afterCompletion &#123;&#125;: exception = &#123;&#125;&quot;, request.getRequestURI(), ex);    &#125;&#125;</code></pre><p>一个Interceptor<strong>必须实现HandlerInterceptor接口</strong>，可以<strong>选择实现preHandle()、postHandle()和afterCompletion()方法</strong>。preHandle()是Controller方法调用<strong>前执行</strong>，postHandle()是Controller方法正常返回<strong>后执行</strong>，而afterCompletion()无论Controller方法是否抛异常都会执行，参数ex就是Controller方法抛出的异常（未抛出异常是null）。</p><p>在preHandle()中，也可以直接处理响应，然后返回false表示无需调用Controller方法继续处理了，通常在认证或者安全检查失败时直接返回错误响应。在postHandle()中，因为捕获了Controller方法返回的ModelAndView，所以可以继续往ModelAndView里添加一些通用数据，很多页面需要的全局数据如Copyright信息等都可以放到这里，无需在每个Controller方法中重复添加。</p><p>我们再继续添加一个AuthInterceptor，用于替代上一节使用AuthFilter进行Basic认证的功能：</p><pre><code class="highlight plaintext">@Order(2)@Componentpublic class AuthInterceptor implements HandlerInterceptor &#123;    final Logger logger = LoggerFactory.getLogger(getClass());    @Autowired    UserService userService;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)            throws Exception &#123;        logger.info(&quot;pre authenticate &#123;&#125;...&quot;, request.getRequestURI());        try &#123;            authenticateByHeader(request);        &#125; catch (RuntimeException e) &#123;            logger.warn(&quot;login by authorization header failed.&quot;, e);        &#125;        return true;    &#125;    private void authenticateByHeader(HttpServletRequest req) &#123;        String authHeader = req.getHeader(&quot;Authorization&quot;);        if (authHeader != null &amp;&amp; authHeader.startsWith(&quot;Basic &quot;)) &#123;            logger.info(&quot;try authenticate by authorization header...&quot;);            String up = new String(Base64.getDecoder().decode(authHeader.substring(6)), StandardCharsets.UTF_8);            int pos = up.indexOf(&#x27;:&#x27;);            if (pos &gt; 0) &#123;                String email = URLDecoder.decode(up.substring(0, pos), StandardCharsets.UTF_8);                String password = URLDecoder.decode(up.substring(pos + 1), StandardCharsets.UTF_8);                User user = userService.signin(email, password);                req.getSession().setAttribute(UserController.KEY_USER, user);                logger.info(&quot;user &#123;&#125; login by authorization header ok.&quot;, email);            &#125;        &#125;    &#125;&#125;</code></pre><p>这个AuthInterceptor是由Spring容器直接管理的，因此注入UserService非常方便。</p><p>最后，要让拦截器生效，我们在WebMvcConfigurer中注册所有的Interceptor：</p><pre><code class="highlight plaintext">@BeanWebMvcConfigurer createWebMvcConfigurer(@Autowired HandlerInterceptor[] interceptors) &#123;    return new WebMvcConfigurer() &#123;        public void addInterceptors(InterceptorRegistry registry) &#123;            for (var interceptor : interceptors) &#123;                registry.addInterceptor(interceptor);            &#125;        &#125;        ...    &#125;;&#125;</code></pre><h3 id="处理异常"><a class="markdownIt-Anchor" href="#处理异常"></a> 处理异常</h3><p>在Controller中，Spring MVC还允许定义基于@ExceptionHandler注解的异常处理方法。我们来看具体的示例代码：</p><pre><code class="highlight plaintext">@Controllerpublic class UserController &#123;    @ExceptionHandler(RuntimeException.class)    public ModelAndView handleUnknowException(Exception ex) &#123;        return new ModelAndView(&quot;500.html&quot;, Map.of(&quot;error&quot;, ex.getClass().getSimpleName(), &quot;message&quot;, ex.getMessage()));    &#125;    ...&#125;</code></pre><p>异常处理方法没有固定的方法签名，可以传入Exception、HttpServletRequest等，返回值可以是void，也可以是ModelAndView，上述代码通过@ExceptionHandler(RuntimeException.class)表示当发生RuntimeException的时候，就自动调用此方法处理。</p><p>注意到我们返回了一个新的ModelAndView，这样在应用程序内部如果发生了预料之外的异常，可以给用户显示一个出错页面，而不是简单的500 Internal Server Error或404 Not Found。例如B站的错误页：</p><p>可以编写多个错误处理方法，每个方法针对特定的异常。例如，处理LoginException使得页面可以自动跳转到登录页。</p><p>使用ExceptionHandler时，要注意它仅作用于当前的Controller，即ControllerA中定义的一个ExceptionHandler方法对ControllerB不起作用。如果我们有很多Controller，每个Controller都需要处理一些通用的异常，例如LoginException，思考一下应该怎么避免重复代码？</p><h2 id="处理cors"><a class="markdownIt-Anchor" href="#处理cors"></a> 处理CORS</h2><p>在JavaScript与REST交互的时候，有很多安全限制。默认情况下，浏览器按同源策略放行JavaScript调用API，即：</p><ul><li>如果A站在域名a.com页面的JavaScript调用A站自己的API时，没有问题；</li><li>如果A站在域名a.com页面的JavaScript调用B站b.com的API时，将被浏览器拒绝访问，因为不满足同源策略。</li></ul><p>同源要求域名要完全相同（a.com和www.a.com不同），协议要相同（http和https不同），端口要相同 。</p><p>那么，在域名a.com页面的JavaScript要调用B站b.com的API时，还有没有办法？</p><p>办法是有的，那就是CORS，全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。如果A站的JavaScript访问B站API的时候，B站能够返回响应头<strong>Access-Control-Allow-Origin: <a href="http://a.com">http://a.com</a></strong>，那么，浏览器就允许A站的JavaScript访问B站的API。</p><p>注意到跨域访问能否成功，取决于B站是否愿意给A站返回一个正确的Access-Control-Allow-Origin响应头，所以决定权永远在提供API的服务方手中。</p><p>使用Spring的@RestController开发REST应用时，同样会面对跨域问题。如果我们允许指定的网站通过页面JavaScript访问这些REST API，就必须正确地设置CORS。</p><h3 id="使用crossorigin"><a class="markdownIt-Anchor" href="#使用crossorigin"></a> 使用@CrossOrigin</h3><p>第一种方法是使用@CrossOrigin注解，可以在@RestController的class级别或方法级别定义一个@CrossOrigin，例如</p><pre><code class="highlight plaintext">@CrossOrigin(origins = &quot;http://local.liaoxuefeng.com:8080&quot;)@RestController@RequestMapping(&quot;/api&quot;)public class ApiController &#123;    ...&#125;</code></pre><p>上述定义在ApiController处的@CrossOrigin指定了只允许来自local.liaoxuefeng.com跨域访问，允许多个域访问需要写成数组形式，例如origins = {“<a href="http://a.com">http://a.com</a>”, “<a href="https://www.b.com">https://www.b.com</a>”})。如果要允许任何域访问，写成<code>origins = &quot;*&quot;</code>即可。</p><p>如果有多个REST Controller都需要使用CORS，那么，每个Controller都必须标注@CrossOrigin注解。</p><h3 id="使用corsregistry"><a class="markdownIt-Anchor" href="#使用corsregistry"></a> 使用CorsRegistry</h3><p>第二种方法是在WebMvcConfigurer中定义一个全局CORS配置，下面是一个示例：</p><pre><code class="highlight plaintext">@BeanWebMvcConfigurer createWebMvcConfigurer() &#123;    return new WebMvcConfigurer() &#123;        @Override        public void addCorsMappings(CorsRegistry registry) &#123;            registry.addMapping(&quot;/api/**&quot;)                    .allowedOrigins(&quot;http://local.liaoxuefeng.com:8080&quot;)                    .allowedMethods(&quot;GET&quot;, &quot;POST&quot;)                    .maxAge(3600);            // 可以继续添加其他URL规则:            // registry.addMapping(&quot;/rest/v2/**&quot;)...        &#125;    &#125;;&#125;</code></pre><p>这种方式可以创建一个全局CORS配置，如果仔细地设计URL结构，那么可以一目了然地看到各个URL的CORS规则，推荐使用这种方式配置CORS。</p><h3 id="使用corsfilter"><a class="markdownIt-Anchor" href="#使用corsfilter"></a> 使用CorsFilter</h3><p>第三种方法是使用Spring提供的CorsFilter，我们在集成Filter中详细介绍了将Spring容器内置的Bean暴露为Servlet容器的Filter的方法，由于这种配置方式需要修改web.xml，也比较繁琐，所以推荐使用第二种方式。</p><h2 id="异步处理"><a class="markdownIt-Anchor" href="#异步处理"></a> 异步处理</h2><p>在Servlet模型中，<strong>每个请求都是由某个线程处理</strong>，然后，将响应写入IO流，发送给客户端。从开始处理请求，到写入响应完成，都是在同一个线程中处理的。</p><p>实现Servlet容器的时候，只要每处理一个请求，就创建一个新线程处理它，就能保证正确实现了Servlet线程模型。在实际产品中，例如Tomcat，总是通过线程池来处理请求，它仍然符合一个请求从头到尾都由某一个线程处理。</p><p>这种线程模型非常重要，因为<strong>Spring的JDBC事务是基于ThreadLocal实现的</strong>，如果在处理过程中，一会由线程A处理，一会又由线程B处理，那事务就全乱套了。此外，很多安全认证，也是基于ThreadLocal实现的，可以保证在处理请求的过程中，各个线程互不影响。</p><p>但是，如果一个请求处理的时间较长，例如几秒钟甚至更长，那么，这种基于线程池的同步模型很快就会把所有线程耗尽，导致服务器无法响应新的请求。如果把长时间处理的请求改为异步处理，那么线程池的利用率就会大大提高。Servlet从3.0规范开始添加了异步支持，允许对一个请求进行异步处理。</p><p>我们先来看看在Spring MVC中如何实现对请求进行异步处理的逻辑。首先建立一个Web工程，然后编辑web.xml文件如下：</p><pre><code class="highlight plaintext">&lt;web-app&gt;    &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextClass&lt;/param-name&gt;            &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;com.itranswarp.learnjava.AppConfig&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;        &lt;async-supported&gt;true&lt;/async-supported&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p>和前面普通的MVC程序相比，这个web.xml主要对DispatcherServlet的配置多了一个&lt;<strong>async-supported</strong>&gt;，默认值是false，必须明确写成true，这样Servlet容器才会支持async处理。</p><p>下一步就是在Controller中编写async处理逻辑。我们以ApiController为例，演示如何异步处理请求。</p><p>第一种async处理方式是返回一个Callable，Spring MVC自动把返回的Callable放入线程池执行，等待结果返回后再写入响应：</p><pre><code class="highlight plaintext">@GetMapping(&quot;/users&quot;)public Callable&lt;List&lt;User&gt;&gt; users() &#123;    return () -&gt; &#123;        // 模拟3秒耗时:        try &#123;            Thread.sleep(3000);        &#125; catch (InterruptedException e) &#123;        &#125;        return userService.getUsers();    &#125;;&#125;</code></pre><p>第二种async处理方式是返回一个DeferredResult对象，然后在另一个线程中，设置此对象的值并写入响应：</p><pre><code class="highlight plaintext">@GetMapping(&quot;/users/&#123;id&#125;&quot;)public DeferredResult&lt;User&gt; user(@PathVariable(&quot;id&quot;) long id) &#123;    DeferredResult&lt;User&gt; result = new DeferredResult&lt;&gt;(3000L); // 3秒超时    new Thread(() -&gt; &#123;        // 等待1秒:        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;        &#125;        try &#123;            User user = userService.getUserById(id);            // 设置正常结果并由Spring MVC写入Response:            result.setResult(user);        &#125; catch (Exception e) &#123;            // 设置错误结果并由Spring MVC写入Response:            result.setErrorResult(Map.of(&quot;error&quot;, e.getClass().getSimpleName(), &quot;message&quot;, e.getMessage()));        &#125;    &#125;).start();    return result;&#125;</code></pre><p>使用DeferredResult时，可以设置超时，超时会自动返回超时错误响应。在另一个线程中，可以调用setResult()写入结果，也可以调用setErrorResult()写入一个错误结果。</p><p>运行程序，当我们访问<a href="http://localhost:8080/api/users/1%E6%97%B6%EF%BC%8C%E5%81%87%E5%AE%9A%E7%94%A8%E6%88%B7%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%A81%E7%A7%92%E5%90%8E%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8080/api/users/1时，假定用户存在，则浏览器在1秒后返回结果：</a></p><p>访问一个不存在的User ID，则等待1秒后返回错误结果：</p><h3 id="filter处理"><a class="markdownIt-Anchor" href="#filter处理"></a> Filter处理</h3><p>当我们使用async模式处理请求时，原有的Filter也可以工作，但我们必须在web.xml中添加<async-supported>并设置为true。我们用两个Filter：SyncFilter和AsyncFilter分别测试：</p><pre><code class="highlight plaintext">&lt;web-app ...&gt;    ...    &lt;filter&gt;        &lt;filter-name&gt;sync-filter&lt;/filter-name&gt;        &lt;filter-class&gt;com.itranswarp.learnjava.web.SyncFilter&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter&gt;        &lt;filter-name&gt;async-filter&lt;/filter-name&gt;        &lt;filter-class&gt;com.itranswarp.learnjava.web.AsyncFilter&lt;/filter-class&gt;        &lt;async-supported&gt;true&lt;/async-supported&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;sync-filter&lt;/filter-name&gt;        &lt;url-pattern&gt;/api/version&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;async-filter&lt;/filter-name&gt;        &lt;url-pattern&gt;/api/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    ...&lt;/web-app&gt;</code></pre><p>一个声明为支持<async-supported>的Filter既可以过滤async处理请求，也可以过滤正常的同步处理请求，而未声明<async-supported>的Filter无法支持async请求，如果一个普通的Filter遇到async请求时，会直接报错，因此，务必<strong>注意普通Filter的<url-pattern>不要匹配async请求路径</strong>。</p><p>在logback.xml配置文件中，我们把输出格式加上[%thread]，可以输出当前线程的名称：</p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt;    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;            &lt;Pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/Pattern&gt;        &lt;/layout&gt;    &lt;/appender&gt;    ...&lt;/configuration&gt;</code></pre><p>对于同步请求，例如/api/version，我们可以看到如下输出：</p><pre><code class="highlight plaintext">2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.SyncFilter - start SyncFilter...2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.AsyncFilter - start AsyncFilter...2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.ApiController - get version...2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.AsyncFilter - end AsyncFilter.2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.SyncFilter - end SyncFilter.</code></pre><p>可见，每个Filter和ApiController都是由同一个线程执行。</p><p>对于异步请求，例如/api/users，我们可以看到如下输出：</p><pre><code class="highlight plaintext">2020-05-16 11:23:49 [http-nio-8080-exec-4] INFO  c.i.learnjava.web.AsyncFilter - start AsyncFilter...2020-05-16 11:23:49 [http-nio-8080-exec-4] INFO  c.i.learnjava.web.ApiController - get users...2020-05-16 11:23:49 [http-nio-8080-exec-4] INFO  c.i.learnjava.web.AsyncFilter - end AsyncFilter.2020-05-16 11:23:52 [MvcAsync1] INFO  c.i.learnjava.web.ApiController - return users...</code></pre><p>可见，AsyncFilter和ApiController是由同一个线程执行的，但是，返回响应的是另一个线程。</p><p>对DeferredResult测试，可以看到如下输出：</p><pre><code class="highlight plaintext">2020-05-16 11:25:24 [http-nio-8080-exec-8] INFO  c.i.learnjava.web.AsyncFilter - start AsyncFilter...2020-05-16 11:25:24 [http-nio-8080-exec-8] INFO  c.i.learnjava.web.AsyncFilter - end AsyncFilter.2020-05-16 11:25:25 [Thread-2] INFO  c.i.learnjava.web.ApiController - deferred result is set.</code></pre><p>同样，返回响应的是另一个线程。</p><p>在实际使用时，经常用到的就是DeferredResult，因为返回DeferredResult时，可以设置超时、正常结果和错误结果，易于编写比较灵活的逻辑。</p><p>使用async异步处理响应时，要时刻牢记，在另一个异步线程中的事务和Controller方法中执行的事务不是同一个事务，在Controller中绑定的ThreadLocal信息也无法在异步线程中获取。</p><p>此外，Servlet 3.0规范添加的异步支持是针对同步模型打了一个“补丁”，虽然可以异步处理请求，但高并发异步请求时，它的处理效率并不高，因为这种异步模型并没有用到真正的“原生”异步。Java标准库提供了封装操作系统的异步IO包java.nio，是真正的多路复用IO模型，可以用少量线程支持大量并发。使用NIO编程复杂度比同步IO高很多，因此我们很少直接使用NIO。相反，大部分需要高性能异步IO的应用程序会选择Netty这样的框架，它基于NIO提供了更易于使用的API，方便开发异步应用程序。</p><h2 id="使用websocket"><a class="markdownIt-Anchor" href="#使用websocket"></a> 使用WebSocket</h2><p>WebSocket是一种基于HTTP的长链接技术。传统的HTTP协议是一种请求-响应模型，如果浏览器不发送请求，那么服务器无法主动给浏览器推送数据。如果需要定期给浏览器推送数据，例如股票行情，或者不定期给浏览器推送数据，例如在线聊天，基于HTTP协议实现这类需求，只能依靠浏览器的JavaScript定时轮询，效率很低且实时性不高。</p><p>因为HTTP本身是基于TCP连接的，所以，WebSocket在HTTP协议的基础上做了一个简单的升级，即建立TCP连接后，浏览器发送请求时，附带几个头：</p><pre><code class="highlight plaintext">GET /chat HTTP/1.1Host: www.example.comUpgrade: websocketConnection: Upgrade</code></pre><p>就表示客户端希望升级连接，变成长连接的WebSocket，服务器返回升级成功的响应：</p><pre><code class="highlight plaintext">HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: Upgrade</code></pre><p>收到成功响应后表示WebSocket“握手”成功，这样，代表WebSocket的这个TCP连接将不会被服务器关闭，而是一直保持，服务器可随时向浏览器推送消息，浏览器也可随时向服务器推送消息。双方推送的消息既可以是文本消息，也可以是二进制消息，一般来说，绝大部分应用程序会推送基于JSON的文本消息。</p><p>现代浏览器都已经支持WebSocket协议，服务器则需要底层框架支持。Java的Servlet规范从3.1开始支持WebSocket，所以，必须选择支持Servlet 3.1或更高规范的Servlet容器，才能支持WebSocket。最新版本的Tomcat、Jetty等开源服务器均支持WebSocket。</p><p>我们以实际代码演示如何在Spring MVC中实现对WebSocket的支持。首先，我们需要在pom.xml中加入以下依赖：</p><pre><code class="highlight plaintext">org.apache.tomcat.embed:tomcat-embed-websocket:10.1.1org.springframework:spring-websocket:6.0.0</code></pre><p>第一项是嵌入式Tomcat支持WebSocket的组件，第二项是Spring封装的支持WebSocket的接口。</p><p>接下来，我们需要在AppConfig中加入Spring Web对WebSocket的配置，此处我们需要创建一个WebSocketConfigurer实例：</p><pre><code class="highlight plaintext">@BeanWebSocketConfigurer createWebSocketConfigurer(        @Autowired ChatHandler chatHandler,        @Autowired ChatHandshakeInterceptor chatInterceptor)&#123;    return new WebSocketConfigurer() &#123;        public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123;            // 把URL与指定的WebSocketHandler关联，可关联多个:            registry.addHandler(chatHandler, &quot;/chat&quot;).addInterceptors(chatInterceptor);        &#125;    &#125;;&#125;</code></pre><p>此实例在内部通过WebSocketHandlerRegistry注册能处理WebSocket的WebSocketHandler，以及可选的WebSocket拦截器HandshakeInterceptor。我们注入的这两个类都是自己编写的业务逻辑，后面我们详细讨论如何编写它们，这里只需关注浏览器连接到WebSocket的URL是/chat</p><h3 id="处理websocket连接"><a class="markdownIt-Anchor" href="#处理websocket连接"></a> 处理WebSocket连接</h3><p>和处理普通HTTP请求不同，没法用一个方法处理一个URL。Spring提供了TextWebSocketHandler和BinaryWebSocketHandler分别处理文本消息和二进制消息，这里我们选择文本消息作为聊天室的协议，因此，ChatHandler需要继承自TextWebSocketHandler：</p><pre><code class="highlight plaintext">@Componentpublic class ChatHandler extends TextWebSocketHandler &#123;    ...&#125;</code></pre><p>当浏览器请求一个WebSocket连接后，如果成功建立连接，Spring会自动调用afterConnectionEstablished()方法，任何原因导致WebSocket连接中断时，Spring会自动调用afterConnectionClosed方法，因此，覆写这两个方法即可处理连接成功和结束后的业务逻辑：</p><pre><code class="highlight plaintext">@Componentpublic class ChatHandler extends TextWebSocketHandler &#123;    // 保存所有Client的WebSocket会话实例:    private Map&lt;String, WebSocketSession&gt; clients = new ConcurrentHashMap&lt;&gt;();    @Override    public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123;        // 新会话根据ID放入Map:        clients.put(session.getId(), session);        session.getAttributes().put(&quot;name&quot;, &quot;Guest1&quot;);    &#125;    @Override    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception &#123;        clients.remove(session.getId());    &#125;&#125;</code></pre><p>每个WebSocket会话以WebSocketSession表示，且已分配唯一ID。和WebSocket相关的数据，例如用户名称等，均可放入关联的getAttributes()中。</p><p>用实例变量clients持有当前所有的WebSocketSession是为了广播，即向所有用户推送同一消息时，可以这么写：</p><pre><code class="highlight plaintext">String json = ...TextMessage message = new TextMessage(json);for (String id : clients.keySet()) &#123;    WebSocketSession session = clients.get(id);    session.sendMessage(message);&#125;</code></pre><p>我们发送的消息是序列化后的JSON，可以用ChatMessage表示：</p><pre><code class="highlight plaintext">public class ChatMessage &#123;        public long timestamp;        public String name;    public String text;&#125;</code></pre><p>每收到一个用户的消息后，我们就需要广播给所有用户：</p><pre><code class="highlight plaintext">@Componentpublic class ChatHandler extends TextWebSocketHandler &#123;    ...    @Override    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception &#123;        String s = message.getPayload();        String r = ... // 根据输入消息构造待发送消息        broadcastMessage(r); // 推送给所有用户    &#125;&#125;</code></pre><p>如果要推送给指定的几个用户，那就需要在clients中根据条件查找出某些WebSocketSession，然后发送消息。</p><p>注意到我们在注册WebSocket时还传入了一个ChatHandshakeInterceptor，这个类实际上可以从HttpSessionHandshakeInterceptor继承，它的主要作用是在WebSocket建立连接后，把HttpSession的一些属性复制到WebSocketSession，例如，用户的登录信息等：</p><pre><code class="highlight plaintext">@Componentpublic class ChatHandshakeInterceptor extends HttpSessionHandshakeInterceptor &#123;    public ChatHandshakeInterceptor() &#123;        // 指定从HttpSession复制属性到WebSocketSession:        super(List.of(UserController.KEY_USER));    &#125;&#125;</code></pre><p>这样，在ChatHandler中，可以从WebSocketSession.getAttributes()中获取到复制过来的属性。</p><h3 id="客户端开发"><a class="markdownIt-Anchor" href="#客户端开发"></a> 客户端开发</h3><p>在完成了服务器端的开发后，我们还需要在页面编写一点JavaScript逻辑：</p><pre><code class="highlight plaintext">// 创建WebSocket连接:var ws = new WebSocket(&#x27;ws://&#x27; + location.host + &#x27;/chat&#x27;);// 连接成功时:ws.addEventListener(&#x27;open&#x27;, function (event) &#123;    console.log(&#x27;websocket connected.&#x27;);&#125;);// 收到消息时:ws.addEventListener(&#x27;message&#x27;, function (event) &#123;    console.log(&#x27;message: &#x27; + event.data);    var msgs = JSON.parse(event.data);    // TODO:&#125;);// 连接关闭时:ws.addEventListener(&#x27;close&#x27;, function () &#123;    console.log(&#x27;websocket closed.&#x27;);&#125;);// 绑定到全局变量:window.chatWs = ws;</code></pre><p>用户可以在连接成功后任何时候给服务器发送消息：</p><pre><code class="highlight plaintext">var inputText = &#x27;Hello, WebSocket.&#x27;;window.chatWs.send(JSON.stringify(&#123;text: inputText&#125;));</code></pre><h2 id="使用scheduler"><a class="markdownIt-Anchor" href="#使用scheduler"></a> 使用Scheduler</h2><p>我们还是以实际代码为例，建立工程spring-integration-schedule，无需额外的依赖，我们可以直接在AppConfig中加上@<strong>EnableScheduling</strong>就开启了定时任务的支持：</p><pre><code class="highlight plaintext">@Configuration@ComponentScan@EnableWebMvc@EnableScheduling@EnableTransactionManagement@PropertySource(&#123; &quot;classpath:/jdbc.properties&quot;, &quot;classpath:/task.properties&quot; &#125;)public class AppConfig &#123;    ...&#125;</code></pre><p>接下来，我们可以直接在一个Bean中编写一个public void无参数方法，然后加上@Scheduled注解：</p><pre><code class="highlight plaintext">@Componentpublic class TaskService &#123;    final Logger logger = LoggerFactory.getLogger(getClass());    @Scheduled(initialDelay = 60_000, fixedRate = 60_000)    public void checkSystemStatusEveryMinute() &#123;        logger.info(&quot;Start check system status...&quot;);    &#125;&#125;</code></pre><p>上述注解指定了启动延迟60秒，并以60秒的间隔执行任务。现在，我们直接运行应用程序，就可以在控制台看到定时任务打印的日志：</p><pre><code class="highlight plaintext">2020-06-03 18:47:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start check system status...2020-06-03 18:48:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start check system status...2020-06-03 18:49:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start check system status...</code></pre><p>如果没有看到定时任务的日志，需要检查：</p><ul><li>是否忘记了在AppConfig中标注@EnableScheduling；</li><li>是否忘记了在定时任务的方法所在的class标注@Component。</li></ul><p>除了可以使用fixedRate外，还可以使用fixedDelay，两者的区别我们已经在使用线程池一节中讲过，这里不再重复。</p><p>有的童鞋在实际开发中会遇到一个问题，因为Java的注解全部是常量，写死了fixedDelay=30000，如果根据实际情况要改成60秒怎么办，只能重新编译？</p><p>我们可以把定时任务的配置放到配置文件中，例如task.properties：</p><pre><code class="highlight plaintext">task.checkDiskSpace=30000</code></pre><p>这样就可以随时修改配置文件而无需动代码。但是在代码中，我们需要用fixedDelayString取代fixedDelay：</p><pre><code class="highlight plaintext">@Componentpublic class TaskService &#123;    ...    @Scheduled(initialDelay = 30_000, fixedDelayString = &quot;$&#123;task.checkDiskSpace:30000&#125;&quot;)    public void checkDiskSpaceEveryMinute() &#123;        logger.info(&quot;Start check disk space...&quot;);    &#125;&#125;</code></pre><p>注意到上述代码的注解参数fixedDelayString是一个属性占位符，并配有默认值30000，Spring在处理@Scheduled注解时，如果遇到String，会根据占位符自动用配置项替换，这样就可以灵活地修改定时任务的配置。</p><p>此外，fixedDelayString还可以使用更易读的Duration，例如：</p><pre><code class="highlight plaintext">@Scheduled(initialDelay = 30_000, fixedDelayString = &quot;$&#123;task.checkDiskSpace:PT2M30S&#125;&quot;)</code></pre><p>以字符串PT2M30S表示的Duration就是2分30秒，请参考LocalDateTime一节的Duration相关部分。</p><p>多个@Scheduled方法完全可以放到一个Bean中，这样便于统一管理各类定时任务。</p><h3 id="使用cron任务"><a class="markdownIt-Anchor" href="#使用cron任务"></a> 使用Cron任务</h3><p>还有一类定时任务，它不是简单的重复执行，而是按时间触发，我们把这类任务称为Cron任务，例如：</p><ul><li>每天凌晨2:15执行报表任务；</li><li>每个工作日12:00执行特定任务；</li><li>……<br />Cron源自Unix/Linux系统自带的crond守护进程，以一个简洁的表达式定义任务触发时间。在Spring中，也可以使用Cron表达式来执行Cron任务，在Spring中，它的格式是：</li></ul><pre><code class="highlight plaintext">秒 分 小时 天 月份 星期 年</code></pre><p>年是可以忽略的，通常不写。每天凌晨2:15执行的Cron表达式就是：</p><pre><code class="highlight plaintext">0 15 2 * * *</code></pre><p>每个工作日12:00执行的Cron表达式就是：</p><pre><code class="highlight plaintext">0 0 12 * * MON-FRI</code></pre><p>每个月1号，2号，3号和10号12:00执行的Cron表达式就是：</p><pre><code class="highlight plaintext">0 0 12 1-3,10 * *</code></pre><p>在Spring中，我们定义一个每天凌晨2:15执行的任务：</p><pre><code class="highlight plaintext">@Componentpublic class TaskService &#123;    ...    @Scheduled(cron = &quot;$&#123;task.report:0 15 2 * * *&#125;&quot;)    public void cronDailyReport() &#123;        logger.info(&quot;Start daily report task...&quot;);    &#125;&#125;</code></pre><p>Cron任务同样可以使用属性占位符，这样修改起来更加方便。</p><p>Cron表达式还可以表达每10分钟执行，例如：</p><pre><code class="highlight plaintext">0 */10 * * * *</code></pre><p>这样，在每个小时的0:00，10:00，20:00，30:00，40:00，50:00均会执行任务，实际上它可以取代fixedRate类型的定时任务。</p><h3 id="集成quarz"><a class="markdownIt-Anchor" href="#集成quarz"></a> 集成Quarz</h3><p>在Spring中使用定时任务和Cron任务都十分简单，但是要注意到，这些任务的调度都是在每个JVM进程中的。如果在本机启动两个进程，或者在多台机器上启动应用，这些进程的定时任务和Cron任务都是独立运行的，互不影响。</p><p>如果一些定时任务要以集群的方式运行，例如每天23:00执行检查任务，只需要集群中的一台运行即可，这个时候，可以考虑使用Quartz。</p><p>Quartz可以配置一个JDBC数据源，以便存储所有的任务调度计划以及任务执行状态。也可以使用内存来调度任务，但这样配置就和使用Spring的调度没啥区别了，额外集成Quartz的意义就不大。</p><h2 id="spring-mvc源码解析"><a class="markdownIt-Anchor" href="#spring-mvc源码解析"></a> Spring MVC源码解析</h2><h3 id="知识储备"><a class="markdownIt-Anchor" href="#知识储备"></a> 知识储备</h3><h4 id="servlet的生命周期方法"><a class="markdownIt-Anchor" href="#servlet的生命周期方法"></a> Servlet的生命周期方法</h4><p>init：Servlet对象创建之后调用</p><p>service：Servlet对象被HTTP请求访问时调用</p><p>destroy：Servlet对象销毁之前调用</p><h4 id="dispatcherservlet继承体系"><a class="markdownIt-Anchor" href="#dispatcherservlet继承体系"></a> DispatcherServlet继承体系</h4><h4 id="initializingbean接口介绍"><a class="markdownIt-Anchor" href="#initializingbean接口介绍"></a> InitializingBean接口介绍</h4><p>Spring有两种Bean的初始化（不是实例化）方法：</p><ul><li>一种时实现InitializingBean接口</li><li>一种是通过反射调用Bean标签中的init-method属性指定的方法</li></ul><blockquote><p>不同点：接口比配置效率高，但是配置消除了对spring的依赖</p></blockquote><p><strong>InitializingBean</strong>接口为bean提供了初始化方法的方式</p><ul><li>它只包括<strong>afterPropertiesSet</strong>方法</li><li>凡是实现该接口的类，在<strong>初始化bean</strong>的时候会执行该方法</li></ul><p>实现InitializingBean接口与在配置文件中指定init-method有什么不同？</p><ul><li>系统先调用afterPropertiesSet方法</li><li>然后再调用init-method方法</li></ul><h3 id="主流程dispatcherservlet"><a class="markdownIt-Anchor" href="#主流程dispatcherservlet"></a> 主流程DispatcherServlet</h3><h3 id="处理器映射器"><a class="markdownIt-Anchor" href="#处理器映射器"></a> 处理器映射器</h3><h3 id="处理器适配器"><a class="markdownIt-Anchor" href="#处理器适配器"></a> 处理器适配器</h3><h3 id="视图解析器"><a class="markdownIt-Anchor" href="#视图解析器"></a> 视图解析器</h3><h3 id="mvcannotation-driver"><a class="markdownIt-Anchor" href="#mvcannotation-driver"></a> mvc:annotation-driver</h3><h3 id="异常处理流程"><a class="markdownIt-Anchor" href="#异常处理流程"></a> 异常处理流程</h3><h3 id="文件上传流程"><a class="markdownIt-Anchor" href="#文件上传流程"></a> 文件上传流程</h3><h1 id="ssm整合"><a class="markdownIt-Anchor" href="#ssm整合"></a> SSM整合</h1><h2 id="系统分层"><a class="markdownIt-Anchor" href="#系统分层"></a> 系统分层</h2><h3 id="如何分层"><a class="markdownIt-Anchor" href="#如何分层"></a> 如何分层</h3><ul><li>把MVC中的VC合并为表示层，M拆分为业务层和持久层</li><li>上一层通过接口调用下一层提供的服务</li><li><h2 id="下一层发生变化不影响上层的代码方便代码的维护"><a class="markdownIt-Anchor" href="#下一层发生变化不影响上层的代码方便代码的维护"></a> 下一层发生变化，不影响上层的代码，方便代码的维护</h2></li></ul><h4 id="表现层"><a class="markdownIt-Anchor" href="#表现层"></a> 表现层</h4><ul><li>数据展现和控制逻辑（请求分发），表示层也就是web层，负责http响应</li><li>表现曾包括展示层和控制层，控制层负责接受请求，展示层负责结果的展示</li><li><strong>表现层的设计一般都使用MVC模型（MVC是表现层的设计模型，和其他层没有关系）</strong></li></ul><h4 id="业务层service"><a class="markdownIt-Anchor" href="#业务层service"></a> 业务层Service</h4><ul><li>业务逻辑的处理，和开发项目的需求息息相关</li><li>业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的， 事务应该放到业务层来控制）</li></ul><h4 id="持久层dao"><a class="markdownIt-Anchor" href="#持久层dao"></a> 持久层DAO</h4><ul><li>数据访问，负责数据持久化，就是和数据库交互，对数据库表进行增上改查的</li></ul><h2 id="ssm框架整合"><a class="markdownIt-Anchor" href="#ssm框架整合"></a> SSM框架整合</h2><h3 id="整合思路"><a class="markdownIt-Anchor" href="#整合思路"></a> 整合思路</h3><p>将工程的三层结构中的JavaBean分别使用Spring容器（通过XML方式）进行管理。</p><ol><li>整合持久层mapper，包括数据源、会话工程及mapper代理对象的整合；</li><li>整合业务层Service，包括事务及service的bean的配置；</li><li>整合表现层Controller，直接使用springmvc的配置。</li><li>Web.xml加载spring容器（包含多个XML文件）</li></ol><h3 id="工程搭建maven依赖"><a class="markdownIt-Anchor" href="#工程搭建maven依赖"></a> 工程搭建（maven依赖）</h3><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.lee&lt;/groupId&gt;    &lt;artifactId&gt;ssmDemo&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;name&gt;ssmDemo Maven Webapp&lt;/name&gt;    &lt;!-- FIXME change it to the project&#x27;s website --&gt;    &lt;url&gt;http://www.example.com&lt;/url&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!-- 持久层依赖 开始 --&gt;        &lt;!-- spring ioc组件需要的依赖包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- spring 事务管理和JDBC依赖包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- mysql数据库驱动包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.35&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- dbcp连接池的依赖包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;            &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;            &lt;version&gt;1.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- mybatis依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.5&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- mybatis和spring的整合依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;1.3.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 持久层依赖 结束 --&gt;        &lt;!-- 业务层依赖 开始 --&gt;        &lt;!-- 基于AspectJ的aop依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;aopalliance&lt;/groupId&gt;            &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;            &lt;version&gt;1.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 业务层依赖 结束 --&gt;        &lt;!-- 表现层依赖 开始 --&gt;        &lt;!-- spring MVC依赖包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- jstl 取决于视图对象是否是JSP --&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;jstl&lt;/artifactId&gt;            &lt;version&gt;1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 使用Mock测试需要使用该高版本的servlet-api --&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;version&gt;3.1.0&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!--@ResponsBody相关注解需要的jar包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--@ResponsBody相关注解需要的jar包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;            &lt;version&gt;2.9.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 表现层依赖 结束 --&gt;        &lt;!-- spring 单元测试组件包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 单元测试Junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 文件上传 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;            &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;            &lt;version&gt;1.3.1&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;finalName&gt;ssmDemo&lt;/finalName&gt;        &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;            &lt;plugins&gt;                &lt;!-- 配置Maven的JDK编译级别 --&gt;                &lt;plugin&gt;                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                    &lt;version&gt;3.2&lt;/version&gt;                    &lt;configuration&gt;                        &lt;source&gt;1.8&lt;/source&gt;                        &lt;target&gt;1.8&lt;/target&gt;                        &lt;encoding&gt;UTF-8&lt;/encoding&gt;                    &lt;/configuration&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;                    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;                    &lt;version&gt;2.2&lt;/version&gt;                    &lt;configuration&gt;                        &lt;port&gt;8080&lt;/port&gt;                    &lt;/configuration&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;                    &lt;version&gt;3.1.0&lt;/version&gt;                &lt;/plugin&gt;                &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;                    &lt;version&gt;3.0.2&lt;/version&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                    &lt;version&gt;3.8.0&lt;/version&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;                    &lt;version&gt;2.22.1&lt;/version&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;                    &lt;version&gt;3.2.2&lt;/version&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;                    &lt;version&gt;2.5.2&lt;/version&gt;                &lt;/plugin&gt;                &lt;plugin&gt;                    &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;                    &lt;version&gt;2.8.2&lt;/version&gt;                &lt;/plugin&gt;            &lt;/plugins&gt;        &lt;/pluginManagement&gt;        &lt;!--maven默认不加载xml非resources目录下的xml文件，Mapper文件就无法加载，所以得加上如下配置--&gt;        &lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/java&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;/includes&gt;                &lt;filtering&gt;true&lt;/filtering&gt;            &lt;/resource&gt;        &lt;/resources&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><h3 id="工程整合配置文件"><a class="markdownIt-Anchor" href="#工程整合配置文件"></a> 工程整合（配置文件）</h3><h4 id="webxml"><a class="markdownIt-Anchor" href="#webxml"></a> web.xml</h4><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;         version=&quot;2.5&quot;&gt;  &lt;!-- 配置前端控制器加载spring子容器 --&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;ssm&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;ssm&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;  &lt;!-- 配置ContextLoaderListener监听器加载spring父容器 --&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;      classpath:spring/applicationContext-*.xml    &lt;/param-value&gt;  &lt;/context-param&gt;  &lt;!-- 监听器 --&gt;  &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;!-- POST乱码过滤器 --&gt;  &lt;filter&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;utf-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;&lt;/web-app&gt;</code></pre><h4 id="整合mapper"><a class="markdownIt-Anchor" href="#整合mapper"></a> 整合mapper</h4><p>applicationContext-dao.xml</p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!-- 读取java配置文件，替换占位符数据 --&gt;&lt;context:property-placeholderlocation=&quot;classpath:db.properties&quot; /&gt;&lt;!-- 配置数据源 --&gt;&lt;bean id=&quot;dataSource&quot;class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;&lt;property name=&quot;driverClassName&quot;value=&quot;$&#123;db.driverClassName&#125;&quot; /&gt;&lt;property name=&quot;url&quot; value=&quot;$&#123;db.url&#125;&quot; /&gt;&lt;property name=&quot;username&quot; value=&quot;$&#123;db.username&#125;&quot; /&gt;&lt;property name=&quot;password&quot; value=&quot;$&#123;db.password&#125;&quot; /&gt;&lt;/bean&gt;&lt;!-- 配置SqlSessionFactory --&gt;&lt;bean id=&quot;sqlSessionFactory&quot;class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;&lt;!-- 注入dataSource --&gt;&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;!-- mybatis批量别名配置 --&gt;&lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.lee.pojo&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 批量代理对象的生成 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;&lt;!-- 指定需要生成代理的接口所在的包名 --&gt;&lt;property name=&quot;basePackage&quot; value=&quot;com.lee.mapper&quot;&gt;&lt;/property&gt;&lt;!--使用下面配置会报错，因为使用ref会没等到$占位符号赋值就直接创建sqlSessionFactory--&gt;&lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;&lt;!--使用下面配置就不会报错sql,SessionFactory属性可以不用指定，会以Autowired方式自动注入--&gt;&lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><p>db.properties</p><pre><code class="highlight plaintext">db.driverClassName=com.mysql.jdbc.Driverdb.url=jdbc:mysql://localhost:3306/leessm?characterEncoding=UTF-8db.username=rootdb.password=123456</code></pre><p>log4j.properties</p><pre><code class="highlight plaintext">#dev env [debug] product env [info]log4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</code></pre><h4 id="整合service"><a class="markdownIt-Anchor" href="#整合service"></a> 整合Service</h4><p>applicationContext-service.xml</p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!-- 扫描业务bean --&gt;&lt;context:component-scan base-package=&quot;com.lee.service&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt;</code></pre><p>applicationContext-tx.xml（事务相关）</p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!-- 配置平台事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot;class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 事务通知 --&gt;&lt;!-- tx:advice：对应的处理器类就是TransactionInterceptor类（实现了MethodInterceptor） --&gt;&lt;!-- TransactionInterceptor类实现事务是通过transaction-manager属性指定的值进行事务管理 --&gt;&lt;tx:advice id=&quot;txAdvice&quot;transaction-manager=&quot;transactionManager&quot;&gt;&lt;!-- 设置事务管理信息 --&gt;&lt;tx:attributes&gt;&lt;!-- 增删改使用REQUIRED事务传播行为 --&gt;&lt;!-- 查询使用read-only --&gt;&lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;tx:method name=&quot;create*&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;tx:method name=&quot;remove*&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;tx:method name=&quot;del*&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;tx:method name=&quot;modify*&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;tx:method name=&quot;edit*&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot;/&gt;&lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;&lt;tx:method name=&quot;select*&quot; read-only=&quot;true&quot;/&gt;&lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 基于AspectJ + XML方式实现声明式事务 --&gt;&lt;aop:config&gt;&lt;!-- aop:advisor标签使用的是传统spring aop开发方式实现的 --&gt;&lt;!-- spring已经实现了该增强功能，spring使用的是实现MethodInterceptor接口的方式实现的 --&gt;&lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* *..*.*ServiceImpl.*(..))&quot; /&gt;&lt;/aop:config&gt;&lt;/beans&gt;</code></pre><h4 id="整合controller"><a class="markdownIt-Anchor" href="#整合controller"></a> 整合controller</h4><p>springmvc.xml</p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!-- 处理器类的扫描 --&gt;&lt;context:component-scanbase-package=&quot;com.lee.controller&quot; /&gt;&lt;!-- 配置注解的适配器和映射器，同时还注入了很多其他的bean --&gt;&lt;!-- 处理器适配器会去调用conversion-service --&gt;&lt;mvc:annotation-driven/&gt;    &lt;!-- 显式的配置视图解析器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/item/&quot;&gt;&lt;/property&gt;&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><h3 id="整合测试编写代码"><a class="markdownIt-Anchor" href="#整合测试编写代码"></a> 整合测试（编写代码）</h3><h4 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h4><pre><code class="highlight plaintext">CREATE TABLE `leessm`.`Untitled`  (  `id` int(10),  `name` varchar(20) ,  `price` float,  `pic` varchar(20) ,  `createtime` datetime ,  `detail` varchar(100) ) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;</code></pre><h4 id="持久层"><a class="markdownIt-Anchor" href="#持久层"></a> 持久层</h4><p>持久层相关代码使用mybatis逆向工程生成</p><h5 id="pojo"><a class="markdownIt-Anchor" href="#pojo"></a> pojo</h5><p>Item.java</p><pre><code class="highlight plaintext">package com.lee.pojo;import java.util.Date;public class Item &#123;    private Integer id;    private String name;    private Float price;    private String pic;    private Date createtime;    private String detail;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name == null ? null : name.trim();    &#125;    public Float getPrice() &#123;        return price;    &#125;    public void setPrice(Float price) &#123;        this.price = price;    &#125;    public String getPic() &#123;        return pic;    &#125;    public void setPic(String pic) &#123;        this.pic = pic == null ? null : pic.trim();    &#125;    public Date getCreatetime() &#123;        return createtime;    &#125;    public void setCreatetime(Date createtime) &#123;        this.createtime = createtime;    &#125;    public String getDetail() &#123;        return detail;    &#125;    public void setDetail(String detail) &#123;        this.detail = detail == null ? null : detail.trim();    &#125;    @Override    public String toString() &#123;        return &quot;Item&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +                &quot;, price=&quot; + price +                &quot;, pic=&#x27;&quot; + pic + &#x27;\&#x27;&#x27; +                &quot;, createtime=&quot; + createtime +                &quot;, detail=&#x27;&quot; + detail + &#x27;\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;</code></pre><p>ItemExample.java</p><pre><code class="highlight plaintext">package com.lee.pojo;import java.util.ArrayList;import java.util.Date;import java.util.List;public class ItemExample &#123;    protected String orderByClause;    protected boolean distinct;    protected List&lt;Criteria&gt; oredCriteria;    public ItemExample() &#123;        oredCriteria = new ArrayList&lt;Criteria&gt;();    &#125;    public void setOrderByClause(String orderByClause) &#123;        this.orderByClause = orderByClause;    &#125;    public String getOrderByClause() &#123;        return orderByClause;    &#125;    public void setDistinct(boolean distinct) &#123;        this.distinct = distinct;    &#125;    public boolean isDistinct() &#123;        return distinct;    &#125;    public List&lt;Criteria&gt; getOredCriteria() &#123;        return oredCriteria;    &#125;    public void or(Criteria criteria) &#123;        oredCriteria.add(criteria);    &#125;    public Criteria or() &#123;        Criteria criteria = createCriteriaInternal();        oredCriteria.add(criteria);        return criteria;    &#125;    public Criteria createCriteria() &#123;        Criteria criteria = createCriteriaInternal();        if (oredCriteria.size() == 0) &#123;            oredCriteria.add(criteria);        &#125;        return criteria;    &#125;    protected Criteria createCriteriaInternal() &#123;        Criteria criteria = new Criteria();        return criteria;    &#125;    public void clear() &#123;        oredCriteria.clear();        orderByClause = null;        distinct = false;    &#125;    protected abstract static class GeneratedCriteria &#123;        protected List&lt;Criterion&gt; criteria;        protected GeneratedCriteria() &#123;            super();            criteria = new ArrayList&lt;Criterion&gt;();        &#125;        public boolean isValid() &#123;            return criteria.size() &gt; 0;        &#125;        public List&lt;Criterion&gt; getAllCriteria() &#123;            return criteria;        &#125;        public List&lt;Criterion&gt; getCriteria() &#123;            return criteria;        &#125;        protected void addCriterion(String condition) &#123;            if (condition == null) &#123;                throw new RuntimeException(&quot;Value for condition cannot be null&quot;);            &#125;            criteria.add(new Criterion(condition));        &#125;        protected void addCriterion(String condition, Object value, String property) &#123;            if (value == null) &#123;                throw new RuntimeException(&quot;Value for &quot; + property + &quot; cannot be null&quot;);            &#125;            criteria.add(new Criterion(condition, value));        &#125;        protected void addCriterion(String condition, Object value1, Object value2, String property) &#123;            if (value1 == null || value2 == null) &#123;                throw new RuntimeException(&quot;Between values for &quot; + property + &quot; cannot be null&quot;);            &#125;            criteria.add(new Criterion(condition, value1, value2));        &#125;        public Criteria andIdIsNull() &#123;            addCriterion(&quot;id is null&quot;);            return (Criteria) this;        &#125;        public Criteria andIdIsNotNull() &#123;            addCriterion(&quot;id is not null&quot;);            return (Criteria) this;        &#125;        public Criteria andIdEqualTo(Integer value) &#123;            addCriterion(&quot;hljs-string&quot; style=&quot;color: #d69d85; line-height: 160%; box-sizing: content-box;&quot;&gt;&quot;id&quot;);            return (Criteria) this;        &#125;        public Criteria andIdNotEqualTo(Integer value) &#123;            addCriterion(&quot;id &lt;&gt;&quot;, value, &quot;id&quot;);            return (Criteria) this;        &#125;        public Criteria andIdGreaterThan(Integer value) &#123;            addCriterion(&quot;id &gt;&quot;, value, &quot;id&quot;);            return (Criteria) this;        &#125;        public Criteria andIdGreaterThanOrEqualTo(Integer value) &#123;            addCriterion(&quot;id &gt;=&quot;, value, &quot;id&quot;);            return (Criteria) this;        &#125;        public Criteria andIdLessThan(Integer value) &#123;            addCriterion(&quot;id &lt;&quot;, value, &quot;id&quot;);            return (Criteria) this;        &#125;        public Criteria andIdLessThanOrEqualTo(Integer value) &#123;            addCriterion(&quot;id &lt;=&quot;, value, &quot;id&quot;);            return (Criteria) this;        &#125;        public Criteria andIdIn(List&lt;Integer&gt; values) &#123;            addCriterion(&quot;id in&quot;, values, &quot;id&quot;);            return (Criteria) this;        &#125;        public Criteria andIdNotIn(List&lt;Integer&gt; values) &#123;            addCriterion(&quot;id not in&quot;, values, &quot;id&quot;);            return (Criteria) this;        &#125;        public Criteria andIdBetween(Integer value1, Integer value2) &#123;            addCriterion(&quot;id between&quot;, value1, value2, &quot;id&quot;);            return (Criteria) this;        &#125;        public Criteria andIdNotBetween(Integer value1, Integer value2) &#123;            addCriterion(&quot;id not between&quot;, value1, value2, &quot;id&quot;);            return (Criteria) this;        &#125;        public Criteria andNameIsNull() &#123;            addCriterion(&quot;name is null&quot;);            return (Criteria) this;        &#125;        public Criteria andNameIsNotNull() &#123;            addCriterion(&quot;name is not null&quot;);            return (Criteria) this;        &#125;        public Criteria andNameEqualTo(String value) &#123;            addCriterion(&quot;name =&quot;, value, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andNameNotEqualTo(String value) &#123;            addCriterion(&quot;name &lt;&gt;&quot;, value, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andNameGreaterThan(String value) &#123;            addCriterion(&quot;name &gt;&quot;, value, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andNameGreaterThanOrEqualTo(String value) &#123;            addCriterion(&quot;name &gt;=&quot;, value, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andNameLessThan(String value) &#123;            addCriterion(&quot;name &lt;&quot;, value, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andNameLessThanOrEqualTo(String value) &#123;            addCriterion(&quot;name &lt;=&quot;, value, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andNameLike(String value) &#123;            addCriterion(&quot;name like&quot;, value, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andNameNotLike(String value) &#123;            addCriterion(&quot;name not like&quot;, value, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andNameIn(List&lt;String&gt; values) &#123;            addCriterion(&quot;name in&quot;, values, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andNameNotIn(List&lt;String&gt; values) &#123;            addCriterion(&quot;name not in&quot;, values, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andNameBetween(String value1, String value2) &#123;            addCriterion(&quot;name between&quot;, value1, value2, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andNameNotBetween(String value1, String value2) &#123;            addCriterion(&quot;name not between&quot;, value1, value2, &quot;name&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceIsNull() &#123;            addCriterion(&quot;price is null&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceIsNotNull() &#123;            addCriterion(&quot;price is not null&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceEqualTo(Float value) &#123;            addCriterion(&quot;price =&quot;, value, &quot;price&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceNotEqualTo(Float value) &#123;            addCriterion(&quot;price &lt;&gt;&quot;, value, &quot;price&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceGreaterThan(Float value) &#123;            addCriterion(&quot;price &gt;&quot;, value, &quot;price&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceGreaterThanOrEqualTo(Float value) &#123;            addCriterion(&quot;price &gt;=&quot;, value, &quot;price&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceLessThan(Float value) &#123;            addCriterion(&quot;price &lt;&quot;, value, &quot;price&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceLessThanOrEqualTo(Float value) &#123;            addCriterion(&quot;price &lt;=&quot;, value, &quot;price&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceIn(List&lt;Float&gt; values) &#123;            addCriterion(&quot;price in&quot;, values, &quot;price&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceNotIn(List&lt;Float&gt; values) &#123;            addCriterion(&quot;price not in&quot;, values, &quot;price&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceBetween(Float value1, Float value2) &#123;            addCriterion(&quot;price between&quot;, value1, value2, &quot;price&quot;);            return (Criteria) this;        &#125;        public Criteria andPriceNotBetween(Float value1, Float value2) &#123;            addCriterion(&quot;price not between&quot;, value1, value2, &quot;price&quot;);            return (Criteria) this;        &#125;        public Criteria andPicIsNull() &#123;            addCriterion(&quot;pic is null&quot;);            return (Criteria) this;        &#125;        public Criteria andPicIsNotNull() &#123;            addCriterion(&quot;pic is not null&quot;);            return (Criteria) this;        &#125;        public Criteria andPicEqualTo(String value) &#123;            addCriterion(&quot;pic =&quot;, value, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andPicNotEqualTo(String value) &#123;            addCriterion(&quot;pic &lt;&gt;&quot;, value, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andPicGreaterThan(String value) &#123;            addCriterion(&quot;pic &gt;&quot;, value, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andPicGreaterThanOrEqualTo(String value) &#123;            addCriterion(&quot;pic &gt;=&quot;, value, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andPicLessThan(String value) &#123;            addCriterion(&quot;pic &lt;&quot;, value, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andPicLessThanOrEqualTo(String value) &#123;            addCriterion(&quot;pic &lt;=&quot;, value, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andPicLike(String value) &#123;            addCriterion(&quot;pic like&quot;, value, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andPicNotLike(String value) &#123;            addCriterion(&quot;pic not like&quot;, value, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andPicIn(List&lt;String&gt; values) &#123;            addCriterion(&quot;pic in&quot;, values, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andPicNotIn(List&lt;String&gt; values) &#123;            addCriterion(&quot;pic not in&quot;, values, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andPicBetween(String value1, String value2) &#123;            addCriterion(&quot;pic between&quot;, value1, value2, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andPicNotBetween(String value1, String value2) &#123;            addCriterion(&quot;pic not between&quot;, value1, value2, &quot;pic&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeIsNull() &#123;            addCriterion(&quot;createtime is null&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeIsNotNull() &#123;            addCriterion(&quot;createtime is not null&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeEqualTo(Date value) &#123;            addCriterion(&quot;createtime =&quot;, value, &quot;createtime&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeNotEqualTo(Date value) &#123;            addCriterion(&quot;createtime &lt;&gt;&quot;, value, &quot;createtime&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeGreaterThan(Date value) &#123;            addCriterion(&quot;createtime &gt;&quot;, value, &quot;createtime&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeGreaterThanOrEqualTo(Date value) &#123;            addCriterion(&quot;createtime &gt;=&quot;, value, &quot;createtime&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeLessThan(Date value) &#123;            addCriterion(&quot;createtime &lt;&quot;, value, &quot;createtime&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeLessThanOrEqualTo(Date value) &#123;            addCriterion(&quot;createtime &lt;=&quot;, value, &quot;createtime&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeIn(List&lt;Date&gt; values) &#123;            addCriterion(&quot;createtime in&quot;, values, &quot;createtime&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeNotIn(List&lt;Date&gt; values) &#123;            addCriterion(&quot;createtime not in&quot;, values, &quot;createtime&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeBetween(Date value1, Date value2) &#123;            addCriterion(&quot;createtime between&quot;, value1, value2, &quot;createtime&quot;);            return (Criteria) this;        &#125;        public Criteria andCreatetimeNotBetween(Date value1, Date value2) &#123;            addCriterion(&quot;createtime not between&quot;, value1, value2, &quot;createtime&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailIsNull() &#123;            addCriterion(&quot;detail is null&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailIsNotNull() &#123;            addCriterion(&quot;detail is not null&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailEqualTo(String value) &#123;            addCriterion(&quot;detail =&quot;, value, &quot;detail&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailNotEqualTo(String value) &#123;            addCriterion(&quot;detail &lt;&gt;&quot;, value, &quot;detail&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailGreaterThan(String value) &#123;            addCriterion(&quot;detail &gt;&quot;, value, &quot;detail&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailGreaterThanOrEqualTo(String value) &#123;            addCriterion(&quot;detail &gt;=&quot;, value, &quot;detail&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailLessThan(String value) &#123;            addCriterion(&quot;detail &lt;&quot;, value, &quot;detail&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailLessThanOrEqualTo(String value) &#123;            addCriterion(&quot;detail &lt;=&quot;, value, &quot;detail&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailLike(String value) &#123;            addCriterion(&quot;detail like&quot;, value, &quot;detail&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailNotLike(String value) &#123;            addCriterion(&quot;detail not like&quot;, value, &quot;detail&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailIn(List&lt;String&gt; values) &#123;            addCriterion(&quot;detail in&quot;, values, &quot;detail&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailNotIn(List&lt;String&gt; values) &#123;            addCriterion(&quot;detail not in&quot;, values, &quot;detail&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailBetween(String value1, String value2) &#123;            addCriterion(&quot;detail between&quot;, value1, value2, &quot;detail&quot;);            return (Criteria) this;        &#125;        public Criteria andDetailNotBetween(String value1, String value2) &#123;            addCriterion(&quot;detail not between&quot;, value1, value2, &quot;detail&quot;);            return (Criteria) this;        &#125;    &#125;    public static class Criteria extends GeneratedCriteria &#123;        protected Criteria() &#123;            super();        &#125;    &#125;    public static class Criterion &#123;        private String condition;        private Object value;        private Object secondValue;        private boolean noValue;        private boolean singleValue;        private boolean betweenValue;        private boolean listValue;        private String typeHandler;        public String getCondition() &#123;            return condition;        &#125;        public Object getValue() &#123;            return value;        &#125;        public Object getSecondValue() &#123;            return secondValue;        &#125;        public boolean isNoValue() &#123;            return noValue;        &#125;        public boolean isSingleValue() &#123;            return singleValue;        &#125;        public boolean isBetweenValue() &#123;            return betweenValue;        &#125;        public boolean isListValue() &#123;            return listValue;        &#125;        public String getTypeHandler() &#123;            return typeHandler;        &#125;        protected Criterion(String condition) &#123;            super();            this.condition = condition;            this.typeHandler = null;            this.noValue = true;        &#125;        protected Criterion(String condition, Object value, String typeHandler) &#123;            super();            this.condition = condition;            this.value = value;            this.typeHandler = typeHandler;            if (value instanceof List&lt;?&gt;) &#123;                this.listValue = true;            &#125; else &#123;                this.singleValue = true;            &#125;        &#125;        protected Criterion(String condition, Object value) &#123;            this(condition, value, null);        &#125;        protected Criterion(String condition, Object value, Object secondValue, String typeHandler) &#123;            super();            this.condition = condition;            this.value = value;            this.secondValue = secondValue;            this.typeHandler = typeHandler;            this.betweenValue = true;        &#125;        protected Criterion(String condition, Object value, Object secondValue) &#123;            this(condition, value, secondValue, null);        &#125;    &#125;&#125;</code></pre><h5 id="mapper"><a class="markdownIt-Anchor" href="#mapper"></a> mapper</h5><p>ItemMapper.java</p><pre><code class="highlight plaintext">package com.lee.mapper;import java.util.List;import com.lee.pojo.Item;import com.lee.pojo.ItemExample;import org.apache.ibatis.annotations.Param;public interface ItemMapper &#123;    int countByExample(ItemExample example);    int deleteByExample(ItemExample example);    int insert(Item record);    int insertSelective(Item record);    List&lt;Item&gt; selectByExample(ItemExample example);    int updateByExampleSelective(@Param(&quot;record&quot;) Item record, @Param(&quot;example&quot;) ItemExample example);    int updateByExample(@Param(&quot;record&quot;) Item record, @Param(&quot;example&quot;) ItemExample example);&#125;</code></pre><p>ItemMapper.xml</p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.lee.mapper.ItemMapper&quot; &gt;  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.lee.pojo.Item&quot; &gt;    &lt;result column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot; /&gt;    &lt;result column=&quot;name&quot; property=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; /&gt;    &lt;result column=&quot;price&quot; property=&quot;price&quot; jdbcType=&quot;REAL&quot; /&gt;    &lt;result column=&quot;pic&quot; property=&quot;pic&quot; jdbcType=&quot;VARCHAR&quot; /&gt;    &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;    &lt;result column=&quot;detail&quot; property=&quot;detail&quot; jdbcType=&quot;VARCHAR&quot; /&gt;  &lt;/resultMap&gt;  &lt;sql id=&quot;Example_Where_Clause&quot; &gt;    &lt;where &gt;      &lt;foreach collection=&quot;oredCriteria&quot; item=&quot;criteria&quot; separator=&quot;or&quot; &gt;        &lt;if test=&quot;criteria.valid&quot; &gt;          &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; prefixOverrides=&quot;and&quot; &gt;            &lt;foreach collection=&quot;criteria.criteria&quot; item=&quot;criterion&quot; &gt;              &lt;choose &gt;                &lt;when test=&quot;criterion.noValue&quot; &gt;                  and $&#123;criterion.condition&#125;                &lt;/when&gt;                &lt;when test=&quot;criterion.singleValue&quot; &gt;                  and $&#123;criterion.condition&#125; #&#123;criterion.value&#125;                &lt;/when&gt;                &lt;when test=&quot;criterion.betweenValue&quot; &gt;                  and $&#123;criterion.condition&#125; #&#123;criterion.value&#125; and #&#123;criterion.secondValue&#125;                &lt;/when&gt;                &lt;when test=&quot;criterion.listValue&quot; &gt;                  and $&#123;criterion.condition&#125;                  &lt;foreach collection=&quot;criterion.value&quot; item=&quot;listItem&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot; &gt;                    #&#123;listItem&#125;                  &lt;/foreach&gt;                &lt;/when&gt;              &lt;/choose&gt;            &lt;/foreach&gt;          &lt;/trim&gt;        &lt;/if&gt;      &lt;/foreach&gt;    &lt;/where&gt;  &lt;/sql&gt;  &lt;sql id=&quot;Update_By_Example_Where_Clause&quot; &gt;    &lt;where &gt;      &lt;foreach collection=&quot;example.oredCriteria&quot; item=&quot;criteria&quot; separator=&quot;or&quot; &gt;        &lt;if test=&quot;criteria.valid&quot; &gt;          &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; prefixOverrides=&quot;and&quot; &gt;            &lt;foreach collection=&quot;criteria.criteria&quot; item=&quot;criterion&quot; &gt;              &lt;choose &gt;                &lt;when test=&quot;criterion.noValue&quot; &gt;                  and $&#123;criterion.condition&#125;                &lt;/when&gt;                &lt;when test=&quot;criterion.singleValue&quot; &gt;                  and $&#123;criterion.condition&#125; #&#123;criterion.value&#125;                &lt;/when&gt;                &lt;when test=&quot;criterion.betweenValue&quot; &gt;                  and $&#123;criterion.condition&#125; #&#123;criterion.value&#125; and #&#123;criterion.secondValue&#125;                &lt;/when&gt;                &lt;when test=&quot;criterion.listValue&quot; &gt;                  and $&#123;criterion.condition&#125;                  &lt;foreach collection=&quot;criterion.value&quot; item=&quot;listItem&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot; &gt;                    #&#123;listItem&#125;                  &lt;/foreach&gt;                &lt;/when&gt;              &lt;/choose&gt;            &lt;/foreach&gt;          &lt;/trim&gt;        &lt;/if&gt;      &lt;/foreach&gt;    &lt;/where&gt;  &lt;/sql&gt;  &lt;sql id=&quot;Base_Column_List&quot; &gt;    id, name, price, pic, createtime, detail  &lt;/sql&gt;  &lt;select id=&quot;selectByExample&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;com.lee.pojo.ItemExample&quot; &gt;    select    &lt;if test=&quot;distinct&quot; &gt;      distinct    &lt;/if&gt;    &lt;include refid=&quot;Base_Column_List&quot; /&gt;    from item    &lt;if test=&quot;_parameter != null&quot; &gt;      &lt;include refid=&quot;Example_Where_Clause&quot; /&gt;    &lt;/if&gt;    &lt;if test=&quot;orderByClause != null&quot; &gt;      order by $&#123;orderByClause&#125;    &lt;/if&gt;  &lt;/select&gt;  &lt;delete id=&quot;deleteByExample&quot; parameterType=&quot;com.lee.pojo.ItemExample&quot; &gt;    delete from item    &lt;if test=&quot;_parameter != null&quot; &gt;      &lt;include refid=&quot;Example_Where_Clause&quot; /&gt;    &lt;/if&gt;  &lt;/delete&gt;  &lt;insert id=&quot;insert&quot; parameterType=&quot;com.lee.pojo.Item&quot; &gt;    insert into item (id, name, price,       pic, createtime, detail      )    values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;name,jdbcType=VARCHAR&#125;, #&#123;price,jdbcType=REAL&#125;,       #&#123;pic,jdbcType=VARCHAR&#125;, #&#123;createtime,jdbcType=TIMESTAMP&#125;, #&#123;detail,jdbcType=VARCHAR&#125;      )  &lt;/insert&gt;  &lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.lee.pojo.Item&quot; &gt;    insert into item    &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot; &gt;      &lt;if test=&quot;id != null&quot; &gt;        id,      &lt;/if&gt;      &lt;if test=&quot;name != null&quot; &gt;        name,      &lt;/if&gt;      &lt;if test=&quot;price != null&quot; &gt;        price,      &lt;/if&gt;      &lt;if test=&quot;pic != null&quot; &gt;        pic,      &lt;/if&gt;      &lt;if test=&quot;createtime != null&quot; &gt;        createtime,      &lt;/if&gt;      &lt;if test=&quot;detail != null&quot; &gt;        detail,      &lt;/if&gt;    &lt;/trim&gt;    &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot; &gt;      &lt;if test=&quot;id != null&quot; &gt;        #&#123;id,jdbcType=INTEGER&#125;,      &lt;/if&gt;      &lt;if test=&quot;name != null&quot; &gt;        #&#123;name,jdbcType=VARCHAR&#125;,      &lt;/if&gt;      &lt;if test=&quot;price != null&quot; &gt;        #&#123;price,jdbcType=REAL&#125;,      &lt;/if&gt;      &lt;if test=&quot;pic != null&quot; &gt;        #&#123;pic,jdbcType=VARCHAR&#125;,      &lt;/if&gt;      &lt;if test=&quot;createtime != null&quot; &gt;        #&#123;createtime,jdbcType=TIMESTAMP&#125;,      &lt;/if&gt;      &lt;if test=&quot;detail != null&quot; &gt;        #&#123;detail,jdbcType=VARCHAR&#125;,      &lt;/if&gt;    &lt;/trim&gt;  &lt;/insert&gt;  &lt;select id=&quot;countByExample&quot; parameterType=&quot;com.lee.pojo.ItemExample&quot; resultType=&quot;java.lang.Integer&quot; &gt;    select count(*) from item    &lt;if test=&quot;_parameter != null&quot; &gt;      &lt;include refid=&quot;Example_Where_Clause&quot; /&gt;    &lt;/if&gt;  &lt;/select&gt;  &lt;update id=&quot;updateByExampleSelective&quot; parameterType=&quot;map&quot; &gt;    update item    &lt;set &gt;      &lt;if test=&quot;record.id != null&quot; &gt;        id = #&#123;record.id,jdbcType=INTEGER&#125;,      &lt;/if&gt;      &lt;if test=&quot;record.name != null&quot; &gt;        name = #&#123;record.name,jdbcType=VARCHAR&#125;,      &lt;/if&gt;      &lt;if test=&quot;record.price != null&quot; &gt;        price = #&#123;record.price,jdbcType=REAL&#125;,      &lt;/if&gt;      &lt;if test=&quot;record.pic != null&quot; &gt;        pic = #&#123;record.pic,jdbcType=VARCHAR&#125;,      &lt;/if&gt;      &lt;if test=&quot;record.createtime != null&quot; &gt;        createtime = #&#123;record.createtime,jdbcType=TIMESTAMP&#125;,      &lt;/if&gt;      &lt;if test=&quot;record.detail != null&quot; &gt;        detail = #&#123;record.detail,jdbcType=VARCHAR&#125;,      &lt;/if&gt;    &lt;/set&gt;    &lt;if test=&quot;_parameter != null&quot; &gt;      &lt;include refid=&quot;Update_By_Example_Where_Clause&quot; /&gt;    &lt;/if&gt;  &lt;/update&gt;  &lt;update id=&quot;updateByExample&quot; parameterType=&quot;map&quot; &gt;    update item    set id = #&#123;record.id,jdbcType=INTEGER&#125;,      name = #&#123;record.name,jdbcType=VARCHAR&#125;,      price = #&#123;record.price,jdbcType=REAL&#125;,      pic = #&#123;record.pic,jdbcType=VARCHAR&#125;,      createtime = #&#123;record.createtime,jdbcType=TIMESTAMP&#125;,      detail = #&#123;record.detail,jdbcType=VARCHAR&#125;    &lt;if test=&quot;_parameter != null&quot; &gt;      &lt;include refid=&quot;Update_By_Example_Where_Clause&quot; /&gt;    &lt;/if&gt;  &lt;/update&gt;&lt;/mapper&gt;</code></pre><h4 id="业务层"><a class="markdownIt-Anchor" href="#业务层"></a> 业务层</h4><p>ItemService.java</p><pre><code class="highlight plaintext">package com.lee.service;import com.lee.pojo.Item;import java.util.List;public interface ItemService &#123;    List&lt;Item&gt; queryItemList();    Item queryItemById(Integer id);    void updateItem(Item item);&#125;</code></pre><p>ItemServiceImpl.java</p><pre><code class="highlight plaintext">package com.lee.service;import com.lee.mapper.ItemMapper;import com.lee.pojo.Item;import com.lee.pojo.ItemExample;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class ItemServiceImpl implements ItemService &#123;    @Autowired    ItemMapper mapper;    @Override    public List&lt;Item&gt; queryItemList() &#123;        // 使用逆向工程代码完成持久层查询        ItemExample example = new ItemExample();        // Criteria criteria = example.createCriteria();        // criteria.andIdEqualTo(1);        List&lt;Item&gt; list = mapper.selectByExample(example);        return list;    &#125;    @Override    public Item queryItemById(Integer id) &#123;        return null;    &#125;    @Override    public void updateItem(Item item) &#123;    &#125;&#125;</code></pre><h4 id="表现层-2"><a class="markdownIt-Anchor" href="#表现层-2"></a> 表现层</h4><p>ItemController.java</p><pre><code class="highlight plaintext">package com.lee.controller;import com.lee.pojo.Item;import com.lee.service.ItemService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import java.util.List;@Controllerpublic class ItemController &#123;    @Autowired    ItemService service;    @RequestMapping(&quot;queryItem&quot;)    public ModelAndView queryItem()&#123;        List&lt;Item&gt; items = service.queryItemList();        ModelAndView modelAndView = new ModelAndView();        //设置数据模型，相当于request的setAttrbute方法，实质上，底层也确实是转成了request        //先将k/v数据放入map中，最终根据视图对象不同，在进行后续处理        modelAndView.addObject(&quot;itemList&quot;,items);        //设置视图（逻辑路径）        modelAndView.setViewName(&quot;item-list&quot;);        return modelAndView;    &#125;&#125;</code></pre><p>item-list.jsp</p><pre><code class="highlight plaintext">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;         pageEncoding=&quot;UTF-8&quot; %&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot; %&gt;&lt;%@page isELIgnored=&quot;false&quot; %&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;查询商品列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath &#125;/itemList.do&quot; method=&quot;post&quot;&gt;    查询条件：    &lt;table width=&quot;100%&quot; border=1&gt;        &lt;tr&gt;            &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;查询&quot;/&gt;&lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;    商品列表：    &lt;table width=&quot;100%&quot; border=1&gt;        &lt;tr&gt;            &lt;td&gt;商品名称&lt;/td&gt;            &lt;td&gt;商品价格&lt;/td&gt;            &lt;td&gt;生产日期&lt;/td&gt;            &lt;td&gt;商品描述&lt;/td&gt;            &lt;td&gt;操作&lt;/td&gt;        &lt;/tr&gt;        &lt;c:forEach items=&quot;$&#123;itemList &#125;&quot; var=&quot;item&quot; varStatus=&quot;status&quot;&gt;            &lt;tr&gt;                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;itemList[$&#123;status.index &#125;].name&quot; value=&quot;$&#123;item.name &#125;&quot;/&gt;&lt;/td&gt;                &lt;td&gt;$&#123;item.price &#125;&lt;/td&gt;                &lt;td&gt;&lt;fmt:formatDate value=&quot;$&#123;item.createtime&#125;&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&lt;/td&gt;                &lt;td&gt;$&#123;item.detail &#125;&lt;/td&gt;                &lt;td&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/itemEdit.do?id=$&#123;item.id&#125;&quot;&gt;修改&lt;/a&gt;&lt;/td&gt;            &lt;/tr&gt;        &lt;/c:forEach&gt;    &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>测试运行结果</strong></p><h2 id="实战技巧"><a class="markdownIt-Anchor" href="#实战技巧"></a> 实战技巧</h2><h3 id="中文乱码解决方案"><a class="markdownIt-Anchor" href="#中文乱码解决方案"></a> 中文乱码解决方案</h3><ul><li>以前使用方法<ul><li>表单方式要使用post方式提交</li><li>request.setCharacterEncoding(“utf-8”)</li></ul></li><li>服务端要和浏览器端编码规则一致才可以解决乱码问题<ul><li>浏览器编码在返回报文的表头中，你给浏览器发送的页面是什么编码，浏览器就返回什么编码</li></ul></li></ul><h4 id="数据库乱码"><a class="markdownIt-Anchor" href="#数据库乱码"></a> 数据库乱码</h4><ul><li>设置mysql编码为utf-8</li></ul><pre><code class="highlight plaintext">CREATE TABLE hero (    id int(11) AUTO_INCREMENT,    name varchar(30) ,     hp float ,    damage int(11) ,PRIMARY KEY (id) )  DEFAULT CHARSET=utf8;</code></pre><h4 id="解决get乱码"><a class="markdownIt-Anchor" href="#解决get乱码"></a> 解决get乱码</h4><p><strong>方式一</strong></p><ul><li>修改tomcat配置文件添加编码与工程一致</li></ul><pre><code class="highlight plaintext">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;               connectionTimeout=&quot;20000&quot;               redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot; /&gt;</code></pre><p><strong>方式二</strong></p><ul><li>对参数进行重新编码</li></ul><pre><code class="highlight plaintext">String username = new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;);</code></pre><h4 id="解决post乱码"><a class="markdownIt-Anchor" href="#解决post乱码"></a> 解决post乱码</h4><p><strong>方式一</strong></p><ul><li>在表单提交时，如果遇到中文字符会出现乱码现象，String提供了一个<strong>CharacterEncodingFilter</strong>过滤器，可用来解决乱码问题</li><li>使用CharacterEncodingFilter需要<strong>注意</strong>以下问题<ul><li>表单数据以post方式提交</li><li>在web.xml中配置CharacterEncodingFilter过滤器</li><li>页面编码和过滤器指定编码要保持一致</li></ul></li><li>修改web.xml文件</li></ul><pre><code class="highlight plaintext">&lt;filter&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;!--/*表示所有的页面进行拦截--&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><p><strong>方式二</strong></p><p>使用@RequestMapping注解中的consumes属性，指定响应体的编码</p><h4 id="jsp乱码"><a class="markdownIt-Anchor" href="#jsp乱码"></a> jsp乱码</h4><p>在jsp首行添加</p><pre><code class="highlight plaintext">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;</code></pre><h4 id="responsebody-乱码"><a class="markdownIt-Anchor" href="#responsebody-乱码"></a> @responsebody 乱码</h4><p><strong>方式一</strong></p><p>在springMVC中添加</p><pre><code class="highlight plaintext">&lt;mvc:annotation-driven&gt;&lt;!-- 消息转换器,解决responseBody返回中外乱码问题 --&gt;&lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;&lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;&lt;property name=&quot;supportedMediaTypes&quot; value=&quot;text/plain;charset=UTF-8&quot; /&gt;&lt;/bean&gt;&lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;</code></pre><p><strong>方式二</strong></p><p>使用@RequestMapping注解中的produce属性，指定响应体的编码</p><h4 id="html页面编码"><a class="markdownIt-Anchor" href="#html页面编码"></a> html页面编码</h4><pre><code class="highlight plaintext">&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;    &lt;title&gt;用AJAX以JSON方式提交数据&lt;/title&gt;&lt;/head&gt;</code></pre><h3 id="拦截器"><a class="markdownIt-Anchor" href="#拦截器"></a> 拦截器</h3><p>SpringMVC的拦截器主要是针对特定处理器进行拦截的</p><h4 id="什么是拦截器"><a class="markdownIt-Anchor" href="#什么是拦截器"></a> 什么是拦截器</h4><p>SpringMVC拦截器（<strong>Interceptor</strong>）实现对每一个请求处理前后进行相关的业务处理，类似与servlet中的<strong>Filter</strong></p><p>spring提供的一个特殊的的组件，当DispatcherServlet收到请求后，如果有拦截器，会先调用拦截器，然后调用相应的处理器（Controller）</p><blockquote><p>过滤器属于servlet规范，过滤器在DispatcherServlet之前；</p><p>而拦截器属于spring框架，在dispatcherServlet之后</p></blockquote><h4 id="如何写一个拦截器"><a class="markdownIt-Anchor" href="#如何写一个拦截器"></a> 如何写一个拦截器</h4><p>SpringMVC 中的Interceptor 拦截请求是通过HandlerInterceptor来实现的</p><p>在SpringMVC中定义一个Interceptor非常简单，主要有4种方式：</p><ol><li><strong>实现Spring的HandlerInterceptor接口</strong>；</li><li>继承实现了HandlerInterceptor接口的类，比如Spring 已经提供的实现了HandlerInterceptor 接口的抽象类HandlerInterceptorAdapter；</li><li>实现Spring的WebRequestInterceptor接口；</li><li>继承实现了WebRequestInterceptor的类；</li></ol><p>写一个Java类，实现HandlerInterceptor接口实现具体的拦截处理逻辑，比如：session验证配置拦截器</p><h4 id="定义拦截器实现登陆检查"><a class="markdownIt-Anchor" href="#定义拦截器实现登陆检查"></a> 定义拦截器（实现登陆检查）</h4><h5 id="先定义拦截器"><a class="markdownIt-Anchor" href="#先定义拦截器"></a> 先定义拦截器</h5><ul><li>Spring的HandlerMapping处理器支持拦截器应用，当需要为某些请求提供特殊功能时，例如对用户进行身份认证</li><li><strong>拦截器必须实现HandlerInterceptor接口</strong>，这个接口有三个方法<ul><li><strong>preHandle(…)</strong><ul><li><strong>处理器执行前</strong>被调用，方法返回true标识会继续调用其他拦截器核处理器，返回<strong>false</strong>表示中断流程，不会执行后续拦截器和处理器</li></ul></li><li><strong>postHandle(…)</strong><ul><li><strong>处理器执行后，视图处理前</strong>调用，此时可以通过modelAndView对象对模型数据进行处理或对视图进行处理</li></ul></li><li><strong>afterCompletion(…)</strong><ul><li><strong>整个请求处理完毕后调用</strong>，如果性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，只有preHandle返回true时才会执行afterCompletion方法</li></ul></li></ul></li><li>自定义拦截器示例代码</li></ul><pre><code class="highlight plaintext">public class SomeInterceptor implements HandlerInterceptor&#123;        /**      * 在业务处理器处理请求之前被调用      * 如果返回false      *     从当前的拦截器往回执行所有拦截器的afterCompletion(),再退出拦截器链     * 如果返回true      *    执行下一个拦截器,直到所有的拦截器都执行完毕      *    再执行被拦截的Controller      *    然后进入拦截器链,      *    从最后一个拦截器往回执行所有的postHandle()      *    接着再从最后一个拦截器往回执行所有的afterCompletion()      */  //应用场景：登录认证、身份授权   public boolean preHandle(HttpServletRequest req,HttpServletResponse res,Object handler) throws Exception&#123;        //处理器执行前调用        System.out.println(&quot;preHandle()&quot;);        return true;    &#125;    /**     * 在业务处理器处理请求执行完成后,生成视图之前执行的动作        * 可在modelAndView中加入数据，比如当前时间，可以把公共模型数据传到前台，可以统一指定视图 *      */         public void postHandle(HttpServletRequest req,HttpServletResponse res,Object handler,ModelAndView mv) throws Exception&#123;     System.out.println(&quot;postHandler&quot;);        //处理器执行后调用    &#125;    /**      * 在DispatcherServlet完全处理完请求后被调用,可用于清理资源等       *       * 当有拦截器抛出异常时,会从当前拦截器往回执行所有的拦截器的afterCompletion()  * 访问视图之后调用     */    //应用场景：统一异常处理、统一日志处理    public void afterCompletion(HttpServletRequest req,HttpServletResponse res,Object handler,Exception e)&#123;    System.out.println(&quot;afterCompletion()&quot;);        //请求完成处理后调用    &#125;&#125;</code></pre><blockquote><p>提示：自定义拦截器时，实现HandlerInterceptor接口需要实现接口定义的所有方法，如果只需要某一个方法可以继承HandlerInterceptorAdapter</p><p><strong>方法执行顺序</strong></p></blockquote><h5 id="配置拦截器"><a class="markdownIt-Anchor" href="#配置拦截器"></a> 配置拦截器</h5><p>如果有多个拦截器，那么配置到springmvc.xml中<strong>最上面的拦截器，拦截优先级最高</strong></p><p><strong>全局拦截器配置（推荐）</strong></p><p>自定义连接器的spring.xml配置如下</p><ul><li>如果要拦截其他路径：<ul><li>/** 拦截所有</li><li>/* 只拦截一层，如只拦截/hello.do，不拦截/demo/hello.do</li><li>/category/** 拦截/category路径下的所有</li></ul></li></ul><blockquote><p>SpringMVC的全局拦截器配置，其实是把配置的拦截器注入到每个已初始化的HandlerMapping中了</p></blockquote><pre><code class="highlight plaintext">&lt;!-- 配置全局mapping的拦截器 --&gt;&lt;mvc:interceptors&gt;     &lt;!-- 公共拦截器可以拦截所有请求，而且可以有多个 --&gt;     &lt;!-- 当设置多个拦截器时，先按顺序调用preHandle方法，然后逆序调用每个拦截器的postHandle和afterCompletion方法 --&gt;     &lt;bean class=&quot;com.kkb.ssm.interceptor.MyHandlerInterceptor1&quot; /&gt;    &lt;bean class=&quot;com.kkb.ssm.interceptor.MyHandlerInterceptor2&quot; /&gt;&lt;!-- 如果有多个拦截器，则按照顺序进行配置 --&gt;    &lt;!-- 定义在mvc:interceptor下面的表示是对特定的请求才进行拦截的 --&gt; &lt;mvc:interceptor&gt;&lt;!-- /**表示所有URL和子URL路径 --&gt;&lt;mvc:mapping path=&quot;/test/**&quot; /&gt;        &lt;!--exclude-mapping配置表示此路径不拦截--&gt;        &lt;mvc:exclude-mapping path=&quot;/login/*&quot;/&gt;         &lt;!-- 特定请求的拦截器只能有一个 --&gt;&lt;bean class=&quot;com.kkb.ssm.interceptor.MyHandlerInterceptor3&quot; /&gt;&lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;</code></pre><p><strong>针对单个handlerMapping配置</strong></p><p>只有通过该处理器映射器查找到的处理器，才能使用该拦截器。</p><p>如果现在有两个处理器映射器：其中一个设置了处理器拦截器，另外一个没有设置，如果通过第二个映射器查找到的处理器，是无法使用拦截器的</p><pre><code class="highlight plaintext">&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&gt;&lt;property name=&quot;interceptors&quot;&gt;&lt;list&gt;&lt;ref bean=&quot;interceptor&quot; /&gt;&lt;/list&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;interceptor&quot; class=&quot;com.kkb.ssm.interceptor.MyHandlerInterceptor&quot; /&gt;</code></pre><h4 id="session验证案例"><a class="markdownIt-Anchor" href="#session验证案例"></a> session验证案例</h4><ul><li>session需要手动用<code>httpSession.setAttribute(&quot;admin&quot;,adminCode);</code>方法放值，session中有值后才可以用来session验证</li></ul><h5 id="controller"><a class="markdownIt-Anchor" href="#controller"></a> Controller</h5><ul><li>loginController</li></ul><pre><code class="highlight plaintext">@RequestMapping(&quot;/toLogin.do&quot;)public String toLogin() &#123;System.out.println(&quot;toLogin()&quot;);return &quot;login&quot;;&#125;@RequestMapping(&quot;/login.do&quot;)public String login(HttpServletRequest request, HttpSession httpSession) &#123;String adminCode = request.getParameter(&quot;adminCode&quot;);String password = request.getParameter(&quot;pwd&quot;);System.out.println(adminCode);try &#123;Admin admin = loginService.checkLogin(adminCode, password);//登陆成功，将用户名存储到session对象中，方便以后session验证httpSession.setAttribute(&quot;admin&quot;,adminCode);&#125; catch (Exception e) &#123;if(e instanceof ApplicationException) &#123;request.setAttribute(&quot;admin_flag&quot;, e.getMessage());return &quot;login&quot;;&#125;return &quot;error&quot;;&#125;return &quot;redirect:toIndex.do&quot;;&#125;</code></pre><h5 id="定义与配置拦截器"><a class="markdownIt-Anchor" href="#定义与配置拦截器"></a> 定义与配置拦截器</h5><ul><li><strong>定义拦截器</strong></li></ul><pre><code class="highlight plaintext">package com.lee.netctoss.interceptors;/** * 用于session验证的拦截器 */import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class SomeInterceptor implements HandlerInterceptor &#123;    /*        DispatcherServlet收到请求之后，会先调用parHandle方法        返回true:则继续向后调用        返回false:则不在向后调用        第三个参数：表示处理器方法的反射对象     */    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        System.out.println(&quot;preHandle()&quot;);        HttpSession httpSession = request.getSession();        Object obj = httpSession.getAttribute(&quot;admin&quot;);        if (obj == null)&#123;            //没有登陆，重定向到登陆页面            response.sendRedirect(&quot;toLogin.do&quot;);            return false;        &#125;        //已经登陆过则允许访问        return true;    &#125;    /*        Controller的方法已经执行完毕，正准备处理结果(ModelAndView)返回给DisPatcherServlet之前，执行postHandler方法，可以在改方法里面修改处理结果     */    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        System.out.println(&quot;postHandler&quot;);    &#125;    /*        最后执行的方法        注意：只有当perHandle方法返回值为true时，该方法才会执行        ex:是处理器所抛出的异常，可以写一个拦截器，用来处理这些异常        比如：我们可以使用拦截器处理所有处理器抛出的异常     */    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;        System.out.println(&quot;afterCompletion()&quot;);    &#125;&#125;</code></pre><ul><li><strong>配置拦截器</strong></li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:task=&quot;http://www.springframework.org/schema/task&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;     xmlns:p=&quot;http://www.springframework.org/schema/p&quot;     xmlns:util=&quot;http://www.springframework.org/schema/util&quot;    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;    xmlns:cache=&quot;http://www.springframework.org/schema/cache&quot;    xsi:schemaLocation=&quot;    http://www.springframework.org/schema/context    http://www.springframework.org/schema/context/spring-context.xsd    http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/tx    http://www.springframework.org/schema/tx/spring-tx.xsd    http://www.springframework.org/schema/jdbc    http://www.springframework.org/schema/jdbc/spring-jdbc-3.1.xsd    http://www.springframework.org/schema/cache    http://www.springframework.org/schema/cache/spring-cache-3.1.xsd    http://www.springframework.org/schema/aop    http://www.springframework.org/schema/aop/spring-aop.xsd    http://www.springframework.org/schema/util    http://www.springframework.org/schema/util/spring-util.xsd    http://www.springframework.org/schema/mvc    http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd    http://www.springframework.org/schema/task    http://www.springframework.org/schema/task/spring-task-3.1.xsd&quot;&gt;    &lt;!-- 配置组件扫描 --&gt;&lt;context:component-scan base-package=&quot;com.lee.netctoss&quot;/&gt;&lt;!-- 配置mvc注解扫描 --&gt;&lt;mvc:annotation-driven/&gt;&lt;!-- 配置ViewResolver视图解析器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot;&gt;&lt;/property&gt;&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 读取配置文件 --&gt;&lt;util:properties id=&quot;config&quot; location=&quot;classpath:db.properties&quot;/&gt;&lt;!-- 数据库连接池 --&gt;&lt;bean id=&quot;ds&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;&lt;property name=&quot;driverClassName&quot; value=&quot;#&#123;config.driverClassName&#125;&quot;&gt;&lt;/property&gt;&lt;property name=&quot;url&quot; value=&quot;#&#123;config.url&#125;&quot;&gt;&lt;/property&gt;&lt;property name=&quot;username&quot; value=&quot;#&#123;config.username&#125;&quot;&gt;&lt;/property&gt;&lt;property name=&quot;password&quot; value=&quot;#&#123;config.password&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--拦截器配置--&gt;&lt;!--如果有多个拦截器，会按照配置的先后顺序执行--&gt;&lt;mvc:interceptors&gt;&lt;mvc:interceptor&gt;&lt;!--哪些请求拦截--&gt;&lt;!--拦截所有的要用/** ，/* 只能拦截/hello.do，不能拦截/demo/hello.do--&gt;&lt;mvc:mapping path=&quot;/**&quot;/&gt;&lt;!--哪些请求不拦截--&gt; &lt;mvc:exclude-mapping path=&quot;/toLogin.do&quot;/&gt;&lt;mvc:exclude-mapping path=&quot;/login.do&quot;/&gt;&lt;!--拦截器的类名--&gt;&lt;bean class=&quot;com.lee.netctoss.interceptors.SomeInterceptor&quot;/&gt;&lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;&lt;/beans&gt;</code></pre><h3 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h3><p>springmvc在处理请求过程中出现异常信息交由异常处理器进行处理，自定义异常处理器可以实现一个系统的异常处理逻辑</p><p>可以将异常抛给spring，由spring来处理这些异常</p><ul><li>Spring MVC处理异常的方式有以下三种<ol><li>使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver</li><li>实现HandlerExceptionResolver接口自定义异常处理器</li><li>使用@ExceptionHandler注解实现异常处理</li></ol></li></ul><p>当发生异常的时候，SpringMVC会如下处理：</p><p>（1）SpringMVC会先从配置文件找异常解析器HandlerExceptionResolver</p><p>（2）如果找到了异常异常解析器，那么接下来就会判断该异常解析器能否处理当前发生的异常</p><p>（3）如果可以处理的话，那么就进行处理，然后给前台返回对应的异常视图</p><p>（4）如果没有找到对应的异常解析器或者是找到的异常解析器不能处理当前的异常的时候，就看当前的Controller中有没有提供对应的异常处理器，如果提供了就由Controller自己进行处理并返回对应的视图</p><p>（5）如果配置文件里面没有定义对应的异常解析器，而当前Controller中也没有定义的话，那么该异常就会被抛出来。</p><h4 id="异常概念"><a class="markdownIt-Anchor" href="#异常概念"></a> 异常概念</h4><p>异常包含<strong>编译时异常</strong>和<strong>运行时异常</strong>，其中编译时异常也叫预期异常。运行时异常只有在项目运行的情况下才会发现，编译的时候不需要关心。</p><ul><li><strong>运行时异常</strong>，比如：空指针异常、数组越界异常，对于这样的异常，只能通过程序员丰富的经验来解决和测试人员不断的严格测试来解决。</li><li><strong>编译时异常</strong>，比如：数据库异常、文件读取异常、自定义异常等。对于这样的异常，必须使用try catch代码块或者throws关键字来处理异常</li></ul><h4 id="异常处理思路"><a class="markdownIt-Anchor" href="#异常处理思路"></a> 异常处理思路</h4><p>系统中异常包括两类：预期异常（编译时异常）和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。</p><p>系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理，如下图：</p><h4 id="使用simplemappingexceptionresolver"><a class="markdownIt-Anchor" href="#使用simplemappingexceptionresolver"></a> 使用SimpleMappingExceptionResolver</h4><ul><li>使用只需要在Spring的XML配置文件中定义就可以了</li><li><strong>异常处理页面获取异常对象名exception适合全局处理简单异常</strong></li><li>TimeoutException为异常类型</li><li>login为视图页面</li></ul><pre><code class="highlight plaintext">    &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;    &lt;property name=&quot;exceptionMapping&quot;&gt;        &lt;props&gt;            &lt;prop key=&quot;java.lang.Exception&quot;&gt;error&lt;/prop&gt;            &lt;prop key=&quot;com.tarena.TimeoutException&quot;&gt;login&lt;/prop&gt;        &lt;props&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h4 id="实现handlerexceptionresolver接口自定义异常处理器"><a class="markdownIt-Anchor" href="#实现handlerexceptionresolver接口自定义异常处理器"></a> 实现HandlerExceptionResolver接口自定义异常处理器</h4><p>为了区别不同的异常通常根据异常类型自定义异常类，这里我们创建一个自定义系统异常，如果controller、service、dao抛出此类异常说明是系统预期处理的异常信息</p><pre><code class="highlight plaintext">public class BusinessException extends Exception &#123;private static final long serialVersionUID = 1L;//异常信息private String message;public BusinessException(String message) &#123;super(message);this.message = message;&#125;public String getMessage() &#123;return message;&#125;public void setMessage(String message) &#123;this.message = message;&#125;&#125;</code></pre><p>自定义异常处理器</p><pre><code class="highlight plaintext">public class BusinessExceptionResolver implements HandlerExceptionResolver &#123;@Overridepublic ModelAndView resolveException(HttpServletRequest request,HttpServletResponse response, Object handler, Exception ex) &#123;//自定义预期异常BusinessException businessException = null; //如果抛出的是系统自定义的异常if(ex instanceof BusinessException)&#123;businessException = (BusinessException) ex;&#125;else&#123;businessException = new BusinessException(&quot;未知错误&quot;);&#125;ModelAndView modelAndView = new ModelAndView();//把错误信息传递到页面modelAndView.addObject(&quot;message&quot;, businessException.getMessage());//指向错误页面modelAndView.setViewName(&quot;error&quot;);return modelAndView;&#125;&#125;</code></pre><p>错误页面</p><pre><code class="highlight plaintext">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;错误信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;message &#125;&lt;/body&gt;&lt;/html&gt;</code></pre><p>自定义的异常处理器需要在Spring的XML配置文件中定义下才可以使用</p><pre><code class="highlight plaintext">&lt;!--自定义异常处理器（全局）--&gt;&lt;bean id=&quot;exceptionHandler&quot; class=&quot;com.kkb.ssm.resolver.BusinessExceptionResolver&quot;/&gt;</code></pre><p>异常测试</p><pre><code class="highlight plaintext">@RequestMapping(value = &quot;/showItemEdit&quot;)public String showItemEdit(Integer id,Model model) throws Exception&#123;// 查询要显示的商品内容Item item = itemService.queryItemById(id);if(item == null) throw new BusinessException(&quot;查询不到商品无法修改&quot;);model.addAttribute(&quot;item&quot;, item);// 由于配置了ViewResolver，所以此处只写逻辑视图名称即可return &quot;item/item-edit&quot;;&#125;</code></pre><h4 id="exceptionhandler注解实现异常处理"><a class="markdownIt-Anchor" href="#exceptionhandler注解实现异常处理"></a> @ExceptionHandler注解实现异常处理</h4><ul><li>首先编写一个BaseController类</li><li>适合局部处理有“处理过程”的异常</li><li>然后其他的Controller继承BaseController类即可</li></ul><pre><code class="highlight plaintext">//该注解可以对Controller进行增强@ControllerAdvice  public class BaseController&#123;         //应用到所有@RequestMapping注解的方法，在其执行之前把返回值放入ModelMap中         public Map&lt;String,Map&gt;  ma()&#123;            Map&lt;String,Map&gt; map = new HashMap();            map.put(&quot;name&quot;,&quot;tom&quot;);            return map;         &#125;                              //应用到所有带参数的@RequestMapping的方法，在其执行之前初始化数据绑定@InitBinderpublic void initBinder(WebDataBinder dataBinder)&#123;   DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-mm-dd&quot;);   dataBinder.registerCustomEditor(Date.class,new CustomDateEditor(dateFormat));   System.out.println(&quot;...initBider...&quot;);&#125;                        //应用到所有@RequestMapping注解的方法，在其有抛出指定异常时执行        @ExceptionHandler(Exception.class)        public String execute(HttpServletRequest request,Exception ex)&#123;            request.setAttribute(&quot;ex&quot;,ex);            //可以根据异常类型返回不同的视图名        &#125;    &#125;</code></pre><h4 id="responsestatus"><a class="markdownIt-Anchor" href="#responsestatus"></a> @ResponseStatus</h4><p>带有@ResponseStatus注解的异常类会被ResponseStatusExceptionResolver 解析。可以实现自定义的一些异常,同时在页面上进行显示。具体的使用方法如下:</p><ul><li>value属性：指定状态码</li><li>code属性：指定状态码</li><li>reason属性：错误描述（注：如果期望返回状态码为2XX，则一定不要填写reason属性，reason属性只要不为空，返回的状态码就错误状态码）</li></ul><blockquote><p><strong>注解底层还是通过设置  response.setStatus来实现.</strong></p></blockquote><blockquote><p>该注解在@RequestMapping方法执行完成，Spring解析返回值之前，进行了responseStatus设置</p></blockquote><hr /><p><strong>定义在自定义异常类上</strong></p><ul><li>如果定义在自定义异常类上，如果controller抛出这个异常，则springMVC会把返回的状态码设置为@ResponseStatus中指定的状态码</li><li>在SpringMvc中如果有某个 @RequestMapping方法抛出该异常,  只要开启<a href="">mvc:annotation-driven/</a></li></ul><ol><li>首先自定义一个异常类</li></ol><pre><code class="highlight plaintext">@ResponseStatus(value = HttpStatus.FORBIDDEN,reason = &quot;用户名和密码不匹配!&quot;)public class UserNameNotMatchPasswordException extends RuntimeException&#123;        &#125;</code></pre><ol><li>人为抛出一个异常:</li></ol><pre><code class="highlight plaintext">@RequestMapping(&quot;/testResponseStatusExceptionResolver&quot;)  public String testResponseStatusExceptionResolver(@RequestParam(&quot;i&quot;) int i)&#123;      if (i==13)&#123;          throw new UserNameNotMatchPasswordException();      &#125;      System.out.println(&quot;testResponseStatusExceptionResolver....&quot;);      return &quot;success&quot;;  &#125;</code></pre><ol><li>输入如下额路径:</li></ol><p><a href="">http://localhost:8090/testResponseStatusExceptionResolver?i=13</a></p><hr /><p><strong>定义在Controller方法上</strong></p><ul><li>定义在Controller方法上时，每次访问返回的状态码都为你指定的状态码</li><li>@ResponseStatus(code=A,reason=B)标注在 @RequestMapping方法上，作用效果与 response.sendError(A,B)是一样的.</li></ul><pre><code class="highlight plaintext">@ResponseStatus(reason = &quot;测试&quot;,value = HttpStatus.NOT_FOUND)@RequestMapping(&quot;/testResponseStatusExceptionResolver&quot;)public String testResponseStatusExceptionResolver(@RequestParam(&quot;i&quot;) int i)&#123;    if (i==13)&#123;        throw new UserNameNotMatchPasswordException();    &#125;    System.out.println(&quot;testResponseStatusExceptionResolver....&quot;);    return &quot;success&quot;;&#125;</code></pre><p>每次访问都会返回你指定的状态码</p><blockquote><p>如果只是为了指示返回状态码，最好不要添加reason属性（如果添加了reason属性，且reason不为&quot;&quot;，且code &gt; 0(哪怕状态码是200)，会对当前请求走错误处理）</p></blockquote><hr /><p><strong>定义在@ControllerAdvice中</strong></p><ul><li>@ControllerAdvice标注初衷我想就是程序运行过程中发生异常，对异常如何处理？  而@ResponseStatus标注在@ControllerAdvice类或者该类下的@ExceptionHandler上，区别大概就是，原来比如请求程序抛出异常，异常被捕获，走@ExceptionHandler，正常走完状态码是200.</li><li>@ControllerAdvice或者 @ExceptionHandler标注了@ReponseStatus，那走完状态码就是500.如果你再给@ResponseStatus添加了reason属性，不管捕获异常方法咋返回，都是服务器的错误码捕获界面，比如上面我的例子，给@ResponseStatus添加reason=”your defined message”.不管怎么说，下面界面比一大堆异常堆栈信息看起来更简洁，但我还是不推荐使用诶,原因啊，界面不友好.</li></ul><pre><code class="highlight plaintext">@ControllerAdvice@ResponseStatuspublic class MyControllerAdvice &#123;     @ExceptionHandler(&#123;ArithmeticException.class&#125;)    public ModelAndView fix(Exception e)&#123;        Map map=new HashMap();        map.put(&quot;ex&quot;,e.getMessage());        return new ModelAndView(&quot;error&quot;,map);    &#125; &#125;</code></pre><h4 id="对于框架内部异常或代码无法捕获的异常"><a class="markdownIt-Anchor" href="#对于框架内部异常或代码无法捕获的异常"></a> 对于框架内部异常或代码无法捕获的异常</h4><ul><li>对于此种异常，可以再web.xml通过<error-page>定义，目前绝大多数服务器都支持此配置，配置示例如下</li></ul><pre><code class="highlight plaintext">&lt;error-page&gt;        &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt;        &lt;location&gt;/WEB-INF/views/error/500.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt;       &lt;error-code&gt;404&lt;/error-code&gt;       &lt;location&gt;/WEB-INF/views/error/404.jsp&lt;/location&gt;&lt;/error-page&gt;</code></pre><h3 id="文件上传"><a class="markdownIt-Anchor" href="#文件上传"></a> 文件上传</h3><h4 id="springmvc文件上传简介"><a class="markdownIt-Anchor" href="#springmvc文件上传简介"></a> SpringMVC文件上传简介</h4><ul><li>再springMVC中，文件上传功能可以由即插即用的CommonsMultipartResolver解析器组件实现，它定义再org.springframework.web.multipart包里，Spring提供的CommonsMultipartResolver解析器可以支持Commons FileUpload和COS FileUpload两种上传组件</li></ul><h4 id="commonsmultipartresolver组件"><a class="markdownIt-Anchor" href="#commonsmultipartresolver组件"></a> CommonsMultipartResolver组件</h4><ul><li>CommonsMultipartResolver解析器可以调用common-fileupload.jar的功能，将请求提交的文件信息结息出来，该组件使用步骤如下<ul><li>引入common-fileupload.jar和<br />common-io.jar开发包</li><li>再spring配置文件中添加CommonsMultipartResolver组件的bean定义</li></ul></li></ul><pre><code class="highlight plaintext">&lt;!--这个bean的id不能修改，是底层写死的，写错了就找不到改类了--&gt;&lt;bean id=&quot;multipartReslver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;</code></pre><h4 id="实现步骤"><a class="markdownIt-Anchor" href="#实现步骤"></a> 实现步骤</h4><p><strong>maven依赖</strong></p><pre><code class="highlight plaintext">&lt;dependency&gt;&lt;groupId&gt;commons-fileupload&lt;/groupId&gt;&lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;&lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>jsp页面（上传）</strong></p><ul><li>再JSP视图表单中，<form>标记必须追加<strong>enctype=&quot;multipart/form-data&quot;设置</strong>，指定表单数据的提交格式，默认情况，提交格式是application/x-www-form-urlencoded（key/value格式），不能用于文件上传<ul><li><h2 id="enctypemultipartform-data格式表单"><a class="markdownIt-Anchor" href="#enctypemultipartform-data格式表单"></a> enctype=&quot;multipart/form-data&quot;格式表单</h2></li><li><h2 id="enctypeapplicationx-www-form-urlencoded格式表单"><a class="markdownIt-Anchor" href="#enctypeapplicationx-www-form-urlencoded格式表单"></a> enctype=&quot;application/x-www-form-urlencoded&quot;格式表单</h2></li></ul></li><li>method属性也必须设置为<strong>post方式</strong>提交</li></ul><pre><code class="highlight plaintext">&lt;form action=&quot;upload.from&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;     &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;     &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;/&gt;&lt;/form&gt;</code></pre><p><strong>Controller实现</strong></p><ul><li>再Controller处理方法中，可以使用@RequestParam注解将CommonsMultipartResolver解析出的文件赋值给MultipartFile参数对象，该对象包含了上传的文件信息</li></ul><pre><code class="highlight plaintext">@RequestMapping(value=&quot;/upload.from&quot;)//@RequestParam写不写都可以public String upload( @RequestParam(value=&quot;file&quot;,required=false)MultipartFile file,HttpServletRequest request,ModelMao model)&#123;        //获取10位的随机数        String name = RandomStringUtils.randomAlphanumeric(10);        //创建文件名    String newFileName = name + &quot;.jpg&quot;;    //获取到WEB目录下的image目录，用于存放上传后的文件        File newFile = new File(request.getServletContext().getRealPath(&quot;/image&quot;), newFileName);    //调用file.getImage().transferTo(newFile); 复制文件    file.getImage().transferTo(newFile);        //一般将文件全路径名存放到数据库中        //把生成的随机文件名提交给视图        ModelAndView mav = new ModelAndView(&quot;showUploadedFile&quot;);        mav.addObject(&quot;imageName&quot;, newFileName);        return mav;&#125;</code></pre><hr /><p>另一个controller处理逻辑</p><pre><code class="highlight plaintext">@RequestMapping(value = &quot;/updateItem&quot;)public String updateItem(Model model,Item item,MultipartFile pictureFile) throws Exception &#123;if(pictureFile != null)&#123;System.out.println(pictureFile.getOriginalFilename());//原始图片名称String originalFilename = pictureFile.getOriginalFilename();//如果没有图片名称，则上传不成功if(originalFilename != null &amp;&amp; originalFilename.length()&gt;0)&#123;//存放图片的物理路径String picPath = &quot;E:\\03-teach\\07-upload\\temp\\&quot;;//新文件的名称，substring是对文件扩展名的截取 String newFileName = UUID.randomUUID()+originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));//确保目录是否存在File dirFile = new File(picPath);if(!dirFile.exists())&#123;      dirFile.mkdirs();&#125;//新的文件File newFile = new File(picPath+newFileName);//把上传的文件保存成一个新的文件pictureFile.transferTo(newFile);//同时需要把新的文件名更新到数据库中item.setPic(newFileName);&#125;else&#123;throw new BusinessException(&quot;图片名称不存在，上传不成功&quot;);&#125;&#125;// 根据页面传入的商品信息，调用修改方法，进行修改（此时还没有讲参数绑定，暂时无法进行）itemService.updateItem(item);return &quot;success&quot;;&#125;</code></pre><p><strong>showUploadedFile.jsp显示图片界面</strong></p><pre><code class="highlight plaintext">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot; isELIgnored=&quot;false&quot;%&gt; &lt;img src=&quot;image/$&#123;imageName&#125;&quot;/&gt;</code></pre><p><strong>限制上传文件大小</strong></p><ul><li>CommonsMultipartResolver解析器可以设置对上传文件大小的限定，配置示例如下</li></ul><pre><code class="highlight plaintext">&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;property name=&quot;maxUploadSize&quot; value=&quot;102400&quot;/&gt;&lt;/bean&gt;</code></pre><ul><li>当设置maxUploadSize大小限制后，如果上传文件大于指定大小，会抛出MaxUploadSizeExceededException异常，可以采用异常处理给客户显示友好提示</li><li>在处理上传的Controller组件中定义@ExceptionHandler异常处理方法</li><li><strong>@ExceptionHandler异常处理示例</strong></li></ul><pre><code class="highlight plaintext">    @ExceptionHandler    public ModelAndView doException(Exception ex)&#123;        Map&lt;String,Object&gt;model = new HashMap&lt;String,Object&gt;();        if(ex instanceof MaxUploadSizeExceededException)&#123;            long size = ((MaxUploadSizeExceededException)ex).getMaxUploadSize();            model.put(&quot;errors&quot;,&quot;文件应小于&quot;+ex.getMessage());        &#125;else&#123;            model.put(&quot;errors&quot;,&quot;未知错误：&quot;+ex.getMessage());        &#125;        return new ModelAndView(&quot;upload&quot;,model);    &#125;    提示:CommonsMultipartResolver的resolveLazily属性指定为true，将文件解析演出加载，才能出发上面的异常处理</code></pre><h4 id="限制文件上传类型"><a class="markdownIt-Anchor" href="#限制文件上传类型"></a> 限制文件上传类型</h4><pre><code class="highlight plaintext">public enum FileType &#123;        /**          * JEPG.          */          JPEG(&quot;FFD8FF&quot;),                /**          * PNG.          */          PNG(&quot;89504E47&quot;),                /**          * GIF.          */          GIF(&quot;47494638&quot;),                /**          * TIFF.          */          TIFF(&quot;49492A00&quot;),                /**          * Windows Bitmap.          */          BMP(&quot;424D&quot;),                /**          * CAD.          */          DWG(&quot;41433130&quot;),                /**          * Adobe Photoshop.          */          PSD(&quot;38425053&quot;),                /**          * Rich Text Format.          */          RTF(&quot;7B5C727466&quot;),                /**          * XML.          */          XML(&quot;3C3F786D6C&quot;),                /**          * HTML.          */          HTML(&quot;68746D6C3E&quot;),          /**          * CSS.          */          CSS(&quot;48544D4C207B0D0A0942&quot;),          /**          * JS.          */          JS(&quot;696B2E71623D696B2E71&quot;),          /**          * Email [thorough only].          */          EML(&quot;44656C69766572792D646174653A&quot;),                /**          * Outlook Express.          */          DBX(&quot;CFAD12FEC5FD746F&quot;),                /**          * Outlook (pst).          */          PST(&quot;2142444E&quot;),                /**          * MS Word/Excel.          */          XLS_DOC(&quot;D0CF11E0&quot;), XLSX_DOCX(&quot;504B030414000600080000002100&quot;),          /**          * Visio          */          VSD(&quot;d0cf11e0a1b11ae10000&quot;),          /**          * MS Access.          */          MDB(&quot;5374616E64617264204A&quot;),          /**          * WPS文字wps、表格et、演示dps都是一样的          */          WPS(&quot;d0cf11e0a1b11ae10000&quot;),          /**          * torrent          */          TORRENT(&quot;6431303A637265617465&quot;),          /**          * WordPerfect.          */          WPD(&quot;FF575043&quot;),                /**          * Postscript.          */          EPS(&quot;252150532D41646F6265&quot;),                /**          * Adobe Acrobat.          */          PDF(&quot;255044462D312E&quot;),                /**          * Quicken.          */          QDF(&quot;AC9EBD8F&quot;),                /**          * Windows Password.          */          PWL(&quot;E3828596&quot;),                /**          * ZIP Archive.          */          ZIP(&quot;504B0304&quot;),                /**          * RAR Archive.          */          RAR(&quot;52617221&quot;),          /**          * JSP Archive.          */          JSP(&quot;3C2540207061676520&quot;),          /**          * JAVA Archive.          */          JAVA(&quot;7061636B61676520&quot;),          /**          * CLASS Archive.          */          CLASS(&quot;CAFEBABE0000002E00&quot;),          /**          * JAR Archive.          */          JAR(&quot;504B03040A000000&quot;),          /**          * MF Archive.          */          MF(&quot;4D616E69666573742D56&quot;),          /**          *EXE Archive.          */          EXE(&quot;4D5A9000030000000400&quot;),          /**          *CHM Archive.          */          CHM(&quot;49545346030000006000&quot;),          /*          * INI(&quot;235468697320636F6E66&quot;), SQL(&quot;494E5345525420494E54&quot;), BAT(          * &quot;406563686F206f66660D&quot;), GZ(&quot;1F8B0800000000000000&quot;), PROPERTIES(          * &quot;6C6F67346A2E726F6F74&quot;), MXP(          * &quot;04000000010000001300&quot;),          */          /**          * Wave.          */          WAV(&quot;57415645&quot;),                /**          * AVI.          */          AVI(&quot;41564920&quot;),                /**          * Real Audio.          */          RAM(&quot;2E7261FD&quot;),                /**          * Real Media.          */          RM(&quot;2E524D46&quot;),                /**          * MPEG (mpg).          */          MPG(&quot;000001BA&quot;),                /**          * Quicktime.          */          MOV(&quot;6D6F6F76&quot;),                /**          * Windows Media.          */          ASF(&quot;3026B2758E66CF11&quot;),                /**          * MIDI.          */          MID(&quot;4D546864&quot;),          /**          * MP4.          */          MP4(&quot;00000020667479706d70&quot;),          /**          * MP3.          */          MP3(&quot;49443303000000002176&quot;),          /**          * FLV.          */          FLV(&quot;464C5601050000000900&quot;);          private String value = &quot;&quot;;                /**          * Constructor.          *           * @param type          */          private FileType(String value) &#123;              this.value = value;          &#125;                public String getValue() &#123;              return value;          &#125;                public void setValue(String value) &#123;              this.value = value;          &#125;&#125;</code></pre><pre><code class="highlight plaintext">public final class FileTypeJudge &#123;        /**      * Constructor      */      private FileTypeJudge() &#123;      &#125;        /**      * 将文件头转换成16进制字符串      *       * @param 原生byte      * @return 16进制字符串      */      private static String bytesToHexString(byte[] src) &#123;            StringBuilder stringBuilder = new StringBuilder();          if (src == null || src.length &lt;= 0) &#123;              return null;          &#125;          for (int i = 0; i &lt; src.length; i++) &#123;              int v = src[i] &amp; 0xFF;              String hv = Integer.toHexString(v);              if (hv.length() &lt; 2) &#123;                  stringBuilder.append(0);              &#125;              stringBuilder.append(hv);          &#125;          return stringBuilder.toString();      &#125;        /**      * 得到文件头      *       * @param filePath      *            文件路径      * @return 文件头      * @throws IOException      */      private static String getFileContent(InputStream is) throws IOException &#123;            byte[] b = new byte[28];            InputStream inputStream = null;            try &#123;              is.read(b, 0, 28);          &#125; catch (IOException e) &#123;              e.printStackTrace();              throw e;          &#125; finally &#123;              if (inputStream != null) &#123;                  try &#123;                      inputStream.close();                  &#125; catch (IOException e) &#123;                      e.printStackTrace();                      throw e;                  &#125;              &#125;          &#125;          return bytesToHexString(b);      &#125;        /**      * 判断文件类型      *       * @param filePath      *            文件路径      * @return 文件类型      */      public static FileType getType(InputStream is) throws IOException &#123;            String fileHead = getFileContent(is);          if (fileHead == null || fileHead.length() == 0) &#123;              return null;          &#125;          fileHead = fileHead.toUpperCase();          FileType[] fileTypes = FileType.values();            for (FileType type : fileTypes) &#123;              if (fileHead.startsWith(type.getValue())) &#123;                  return type;              &#125;          &#125;            return null;      &#125;      /**     *      * @param value 表示文件类型     * @return 1 表示图片,2 表示文档,3 表示视频,4 表示种子,5 表示音乐,6 表示其它     * @return     */    public static Integer isFileType(FileType value) &#123;          Integer type = 6;// 其他          // 图片          FileType[] pics = &#123; FileType.JPEG, FileType.PNG, FileType.GIF, FileType.TIFF, FileType.BMP, FileType.DWG, FileType.PSD &#125;;            FileType[] docs = &#123; FileType.RTF, FileType.XML, FileType.HTML, FileType.CSS, FileType.JS, FileType.EML, FileType.DBX, FileType.PST, FileType.XLS_DOC, FileType.XLSX_DOCX, FileType.VSD,                  FileType.MDB, FileType.WPS, FileType.WPD, FileType.EPS, FileType.PDF, FileType.QDF, FileType.PWL, FileType.ZIP, FileType.RAR, FileType.JSP, FileType.JAVA, FileType.CLASS,                  FileType.JAR, FileType.MF, FileType.EXE, FileType.CHM &#125;;            FileType[] videos = &#123; FileType.AVI, FileType.RAM, FileType.RM, FileType.MPG, FileType.MOV, FileType.ASF, FileType.MP4, FileType.FLV, FileType.MID &#125;;            FileType[] tottents = &#123; FileType.TORRENT &#125;;            FileType[] audios = &#123; FileType.WAV, FileType.MP3 &#125;;            FileType[] others = &#123;&#125;;            // 图片          for (FileType fileType : pics) &#123;              if (fileType.equals(value)) &#123;                  type = 1;              &#125;          &#125;          // 文档          for (FileType fileType : docs) &#123;              if (fileType.equals(value)) &#123;                  type = 2;              &#125;          &#125;          // 视频          for (FileType fileType : videos) &#123;              if (fileType.equals(value)) &#123;                  type = 3;              &#125;          &#125;          // 种子          for (FileType fileType : tottents) &#123;              if (fileType.equals(value)) &#123;                  type = 4;              &#125;          &#125;          // 音乐          for (FileType fileType : audios) &#123;              if (fileType.equals(value)) &#123;                  type = 5;              &#125;          &#125;          return type;      &#125;        public static void main(String args[]) throws Exception &#123;           System.out.println(                 FileTypeJudge.isFileType(                         FileTypeJudge.getType(                                 new FileInputStream(                                         new File(&quot;C:\\Users\\ituser1\\Desktop\\123.pptx&quot;)))));        for (FileType type : FileType.values()) &#123;              System.out.print(type + &quot;\t&quot;);          &#125;      &#125;  &#125;</code></pre><h3 id="文件下载"><a class="markdownIt-Anchor" href="#文件下载"></a> 文件下载</h3><p>方式一：</p><ul><li>使用apache.commons包中的FileUtils工具类</li></ul><pre><code class="highlight plaintext">public void downloadTemplate(HttpServletRequest request, HttpServletResponse response) &#123;    String dataDirectory = request.getServletContext().getRealPath(&quot;/WEB-INF/download&quot;);    String fileName = &quot;HostBatchTemplate.xlsx&quot;;    File file = new File(dataDirectory, fileName);    response.setCharacterEncoding(&quot;UTF-8&quot;);    response.setContentType(&quot;application/vnd.ms-excel&quot;);    response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot;+fileName);    //response.setContentType(&quot;application/msexcel&quot;);//定义输出类型        try(OutputStream os = response.getOutputStream()) &#123;        byte[] bytes = FileUtils.readFileToByteArray(file);        os.write(bytes);        os.flush();    &#125; catch (IOException e) &#123;        logger.error(e.getMessage());    &#125;&#125;</code></pre><p>方式二：</p><pre><code class="highlight plaintext">@RequestMapping(value = &quot;getUeditorImg/&#123;imgname&#125;/&#123;imgType&#125;&quot;, method = RequestMethod.GET)      public void getUeditorImg(@PathVariable String imgname, @PathVariable String imgType,              HttpServletResponse response) &#123;          if (&quot;null&quot;.equals(imgname) || &quot;null&quot;.equals(imgType) || StringUtils.isBlank(imgname)                  || StringUtils.isNotBlank(imgType)) &#123;              return;          &#125;          BufferedInputStream in = null;          BufferedOutputStream out = null;          try &#123;              DateFormat df = new SimpleDateFormat(&quot;yyyyMMdd&quot;);              String timeStr = imgname.substring(0, imgname.length() - 6);              String dateFile = df.format(new Date(Long.parseLong(timeStr)));              File file = new File(UEDITOR_IMG_PATH + &quot;/&quot; + dateFile + &quot;/&quot; + imgname + &quot;.&quot; + imgType);              in = new BufferedInputStream(new FileInputStream(file));              out = new BufferedOutputStream(response.getOutputStream());              response.setContentType(new MimetypesFileTypeMap().getContentType(file));// 设置response内容的类型              response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename=&quot; + imgname + &quot;.&quot; + imgType);// 设置头部信息              byte[] buffer = new byte[10240];              int length = 0;              while ((length = in.read(buffer)) &gt; 0) &#123;                  out.write(buffer, 0, length);              &#125;              out.flush();          &#125; catch (IOException e) &#123;              getLogger().error(e.getMessage(), e);              writeError500(response, e);          &#125; finally &#123;              try &#123;                  if (in != null) &#123;                      in.close();                  &#125;                  if (out != null) &#123;                      out.close();                  &#125;              &#125; catch (IOException e) &#123;                  e.printStackTrace();              &#125;          &#125;      &#125;</code></pre><h3 id="json数据交互"><a class="markdownIt-Anchor" href="#json数据交互"></a> JSON数据交互</h3><p>JSON数据格式比较简单，解析比较方便，在接口调用及html页面Ajax调用时比较常用</p><p><strong>JSON交互方式</strong></p><ul><li>请求时K/V，响应是JSON（推荐）</li><li>请求时JSON，响应是JSON</li></ul><p><strong>加入依赖</strong></p><pre><code class="highlight plaintext">&lt;dependency&gt;&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;version&gt;2.9.6&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="kvjson"><a class="markdownIt-Anchor" href="#kvjson"></a> kv/json</h4><p><strong>JSP页面</strong></p><pre><code class="highlight plaintext">function responseKV()&#123;$.ajax(&#123;type:&quot;post&quot;,url:&#x27;$&#123;pageContext.request.contextPath &#125;/responseKV&#x27;,//输入是key/value时，默认就指定好了contentType了，不需要再指定了//contentType:&#x27;application/json;charset=utf-8&#x27;,//data为key/value形式data:&#x27;name=json测试&amp;price=999&#x27;,success:function(data)&#123;alert(data);&#125;&#125;);&#125;</code></pre><p><strong>controller类</strong></p><pre><code class="highlight plaintext">// 输入是key/value，输出是json// @ResponseBody 将返回值转成json串响应给前台@RequestMapping(&quot;/responseKV&quot;)@ResponseBodypublic Item responseKV(Item item) &#123;return item;&#125;</code></pre><h4 id="jsonjson"><a class="markdownIt-Anchor" href="#jsonjson"></a> json/json</h4><p><strong>jsp页面</strong></p><pre><code class="highlight plaintext">function requestJson()&#123;$.ajax(&#123;type:&quot;post&quot;,url:&#x27;$&#123;pageContext.request.contextPath &#125;/requestJson&#x27;,//输入是json是 ，需要指定contentType为application/jsoncontentType:&#x27;application/json;charset=utf-8&#x27;,data:&#x27;&#123;&quot;name&quot;:&quot;json测试&quot;,&quot;price&quot;:999&#125;&#x27;,success:function(data)&#123;alert(data.name);&#125;&#125;);&#125;</code></pre><p><strong>controller类</strong></p><p>@RequestBody的作用是将返回值转成json串响应给前台</p><pre><code class="highlight plaintext">@Controllerpublic class JsonController &#123;// 输入是json，输出是json// @RequestBody 将请求的json串转成java对象// @ResponseBody 将返回值转成json串响应给前台@RequestMapping(&quot;/requestJson&quot;)    @ResponseBodypublic Item requestJson(@RequestBody Item item) &#123;return item;&#125;&#125;</code></pre><h3 id="mock测试模拟测试"><a class="markdownIt-Anchor" href="#mock测试模拟测试"></a> Mock测试（模拟测试）</h3><p>在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个<strong>虚拟的对象</strong>来创建以便测试的测试方法，就是<strong>mock测试</strong></p><blockquote><p>Servlet、Request、Response等Servlet API相关对象本来是由Servlet容器（tomcat）创建的</p></blockquote><p>这个虚拟的对象就是mock对象，mock对象就是真实对象在调试期间的代替品</p><h4 id="mock各模块介绍"><a class="markdownIt-Anchor" href="#mock各模块介绍"></a> Mock各模块介绍</h4><p>基于RESTful风格的springMVC的测试，我们可以测试完整的springMVC流程，即从<strong>URL请求到控制器处理，在到视图渲染都可以测试</strong></p><p><strong>MockMVCBuilder</strong></p><ul><li>MockMVCBuilder是用来构造MockMVC的构造器</li><li>其主要有两个实现：StandaloneMockMvcBuilder和DefaultMockMvcBuilder，分别对应之前的两种测试方式。</li><li>对于我们来说直接使用静态工厂MockMvcBuilders创建即可</li></ul><p><strong>MockMVCBuilders</strong></p><ul><li>负责创建MockMVCBuilder对象</li><li>两种创建方式<ul><li><code>standaloneSetup(Object... controllers)</code>:通过参数指定一组控制器，这样就不需要从上下文获取了</li><li><code>webAppContextSetup(WebApplicationContext wac)</code>：指定WebApplicationContext，将会从该上下文获取相应的控制器并得到相应的MockMvc</li></ul></li></ul><p><strong>MockMVC</strong></p><ul><li>对于服务端的spring MVC测试支持主入口点</li><li>通过MockMVCBuilder构造</li><li>MockMVCBuilder由MockMVCBuilders建造者的静态方法去构建</li><li>核心方法：<ul><li>perform(RequestBuilder rb) ：执行一个RequestBuilder请求，会自动执行SpringMVC的流程并映射到相应的控制器执行处理，该方法的返回值是一个ResultActions；</li><li>ResultActions<ul><li>andExpect()：添加ResultMatcher验证规则，验证控制器执行完成后结果是否正确；</li><li>andDo()：添加ResultHandler结果处理器，比如调试时打印结果到控制台；</li><li>andReturn()：最后返回相应的MvcResult；然后进行自定义验证/进行下一步的异步处理；</li></ul></li></ul></li></ul><p><strong>MockMvcRequestBuilders</strong></p><ul><li>用来构建请求的</li><li>其主要有两个子类MockHttpServletRequestBuilder和MockMultipartHttpServletRequestBuilder（如文件上传使用），即用来Mock客户端请求需要的所有数据。</li></ul><p><strong>MockMvcResultMatchers</strong></p><ul><li>用来匹配执行完请求后的<strong>结果验证</strong></li><li>如果匹配失败将抛出相应的异常</li><li>包含了很多验证API方法</li></ul><p><strong>MockMvcResultHandlers</strong></p><ul><li>结果处理器，表示要对结果做点什么事情</li><li>比如此处使用MockMvcResultHandlers.print()输出整个响应结果信息。<br /><strong>MvcResult</strong></li><li>单元测试执行结果，可以针对执行结果进行<strong>自定义验证逻辑。</strong></li></ul><h4 id="mockmvc使用"><a class="markdownIt-Anchor" href="#mockmvc使用"></a> MockMVC使用</h4><p><strong>maven依赖</strong></p><pre><code class="highlight plaintext">&lt;!-- spring 单元测试组件包 --&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-test&lt;/artifactId&gt;&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 单元测试Junit --&gt;&lt;dependency&gt;&lt;groupId&gt;junit&lt;/groupId&gt;&lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Mock测试使用的json-path依赖 --&gt;&lt;dependency&gt;&lt;groupId&gt;com.jayway.jsonpath&lt;/groupId&gt;&lt;artifactId&gt;json-path&lt;/artifactId&gt;&lt;version&gt;2.2.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>测试类</strong></p><ul><li>@WebAppConfiguration：用于声明一个ApplicationContext集成测试加载WebApplicationContext</li></ul><pre><code class="highlight plaintext">import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.MediaType;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.MvcResult;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;import org.springframework.test.web.servlet.result.MockMvcResultHandlers;import org.springframework.test.web.servlet.result.MockMvcResultMatchers;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;//@WebAppConfiguration：可以在单元测试的时候，不用启动Servlet容器，就可以获取一个Web应用上下文@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:spring/*.xml&quot;)@WebAppConfigurationpublic class TestMockMVC &#123;@Autowiredprivate WebApplicationContext wac;private MockMvc mockMvc;@Beforepublic void setup() &#123;// 初始化一个MockMVC对象的方式有两种：单独设置、web应用上下文设置// 建议使用Web应用上下文设置mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();&#125;@Testpublic void test() throws Exception &#123;// 通过perform去发送一个HTTP请求// andExpect：通过该方法，判断请求执行是否成功// andDo :对请求之后的结果进行输出MvcResult result = mockMvc.perform(MockMvcRequestBuilders.get(&quot;/item/showEdit&quot;).param(&quot;id&quot;, &quot;1&quot;)).andExpect(MockMvcResultMatchers.view().name(&quot;item/item-edit&quot;)).andExpect(MockMvcResultMatchers.status().isOk()).andDo(MockMvcResultHandlers.print()).andReturn();System.out.println(&quot;================================&quot;);System.out.println(result.getHandler());&#125;@Testpublic void test2() throws Exception &#123;// 通过perform去发送一个HTTP请求// andExpect：通过该方法，判断请求执行是否成功// andDo :对请求之后的结果进行输出MvcResult result = mockMvc.perform(get(&quot;/item/findItem&quot;).param(&quot;id&quot;, &quot;1&quot;).accept(MediaType.APPLICATION_JSON)).andExpect(status().isOk()).andExpect(content().contentTypeCompatibleWith(MediaType.APPLICATION_JSON)).andExpect(jsonPath(&quot;$.id&quot;).value(1)).andExpect(jsonPath(&quot;$.name&quot;).value(&quot;台式机123&quot;)).andDo(print()).andReturn();System.out.println(&quot;================================&quot;);System.out.println(result.getHandler());&#125;&#125;</code></pre><h3 id="restful支持"><a class="markdownIt-Anchor" href="#restful支持"></a> RESTful支持</h3><h4 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h4><p><strong>什么是REST</strong></p><p>REST（英文：Representational State Transfer，简称 REST，意思是：（资源）<strong>表述性状态转化</strong>）描述了一个架构样式的网络系统， 比如 web 应用程序。</p><p>它是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于<strong>客户端和服务器</strong>交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><p>它本身并没有什么实用性，其核心价值在于如何设计出符合 REST 风格的网络接口</p><p><strong>什么是RESTful</strong></p><p>REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful</p><p><strong>RESTful的特性</strong></p><ul><li><strong>资源</strong>（Resources）：网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个 URI（统一资源定位符）指向它，每种资源对应一个特定的 URI 。要获取这个资源，访问它的 URI 就可以，因此 URI 即为每一个资源的独一无二的识别符。</li><li><strong>表现层</strong>（Representation）：把资源具体呈现出来的形式，叫做它的表现层<br />（Representation）。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式。</li><li><strong>状态转化</strong>（State Transfer）：每发出一个请求，就代表了客户端和服务器的一次交互过程。HTTP协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器， 必须通过某种手段，让服务器端发生“状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是 “ 表现层状态转化” 。具体说， 就是 HTTP 协议里面，四个表示操作方式的动词：GET 、POST 、PUT 、DELETE 。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源</li></ul><p><strong>如何设计RESTful应用程序的API</strong></p><ul><li><strong>路径设计</strong>：数据库设计完毕之后，基本上就可以确定有哪些资源要进行操作，相对于的路径也可以设计出来</li><li><strong>动词设计</strong>：也就是针对资源的具体操作类型，由HTTP动词表示，常用的HTTP动词如下：POST、DELETE、PUT、GET</li></ul><p><strong>RESTful的示例</strong></p><pre><code class="highlight plaintext">/account/1  HTTP GET ：   得到 id = 1 的 account/account/1  HTTP DELETE： 删除 id = 1 的 account/account/1  HTTP PUT：    更新 id = 1 的 account</code></pre><h4 id="springmvc对restful的支持"><a class="markdownIt-Anchor" href="#springmvc对restful的支持"></a> springMVC对RESTful的支持</h4><p><strong>@PathVariable</strong></p><ul><li><strong>URL-PATTERN</strong> ：设置为/，方便拦截RESTful 请求。</li><li>@<strong>PathVariable</strong>：可以解析出来URL中的模板变量（{id}）</li></ul><pre><code class="highlight plaintext">URL:http://localhost:8080/ssm/item/1/zhangsanController:@RequestMapping(“&#123;id&#125;/&#123;name&#125;”)@ResponseBodypublic Item queryItemById(@PathVariable Integer id, @PathVariable String name)</code></pre><hr /><p><strong>使用@PathVariable接收数组</strong></p><pre><code class="highlight plaintext">http://127.0.0.1:8088/years/1,2,3/districtId/1</code></pre><pre><code class="highlight plaintext">@RestControllerpublic class IndexController &#123;    @RequestMapping(&quot;/years/&#123;years&#125;/districtId/&#123;districtId&#125;&quot;)    public String testMethod(@PathVariable String[] years, @PathVariable int districtId) &#123;        String myStr = &quot;&quot;;        for (String temp : years) &#123;            myStr += temp;        &#125;        return &quot;Years is :&quot; + myStr + &quot;&lt;br&gt; districtId is :&quot; + districtId;    &#125;&#125;</code></pre><hr /><p><strong>RESTful的CRUD</strong></p><ul><li>@<strong>RequestMapping</strong>：通过设置method属性的CRUD，可以将同一个URL映射到不同的HandlerMethod方法上</li><li>@<strong>GetMapping</strong>、@<strong>PostMapping</strong>、@<strong>PutMapping</strong>、@<strong>DeleteMapping</strong>注解等价@RequestMapping注解的method属性设置</li></ul><p><strong>RESTful的资源表述</strong></p><ul><li>RESTful服务中一个重要的特性就是<strong>一种资源可以有多种表现形式</strong>，在SpringMVC中可以使用<strong>ContentNegotiatingManager</strong>这个<strong>内容协商管理器</strong>来实现这种方式。</li><li>内容协商的方式有三种：<ul><li><strong>扩展名</strong>,比如.json表示我要JSON格式数据、.xml表示我要XML格式数据</li><li><strong>请求参数</strong>：默认是”format”</li><li><strong>请求头设置Accept参数</strong>，比如设置Accept为application/json表示要JSON格式数据</li></ul></li><li>不过现在RESTful响应的数据一般都是<strong>JSON格式</strong>，所以一般也不使用内容协商管理器，直接使用**@ResponseBody**注解将数据按照JSON格式返回</li></ul><h4 id="静态资源访问mvcresources"><a class="markdownIt-Anchor" href="#静态资源访问mvcresources"></a> 静态资源访问<code>&lt;mvc:resources&gt;</code></h4><p>以前页面可以显示图片是通过servlet跳转到jsp，jsp访问的本地图片，通过配置<a href="">mvc:resources</a>可以直接通过url方法服务器的图片</p><p><strong>如果在DispatcherServlet中设置url-pattern为/则必须对静态资源进行访问处理</strong></p><p>在springmvc.xml文件中，使用mvc:resources标签，具体如下：</p><pre><code class="highlight plaintext">&lt;!--配置静态资源chu&#x27;li--&gt;&lt;!--location：本地资源路径--&gt;&lt;!--mapping：拦截到的网路资源路径--&gt;&lt;!-- 当DispatcherServlet配置为/来拦截请求的时候，需要配置静态资源的访问映射 --&gt;&lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot;/&gt;&lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot;/&gt;&lt;mvc:resources location=&quot;/img/&quot; mapping=&quot;/img/**&quot;/&gt;</code></pre><p>Springmvc会把mapping映射到ResourceHttpRequestHandler，这样静态资源在经过DispatcherServlet转发时就可以找到对应的Handler了</p><h3 id="springmvc父子容器"><a class="markdownIt-Anchor" href="#springmvc父子容器"></a> SpringMVC父子容器</h3><p>springMVC。xml是通过子容器DispatcherServlet加载的，所以为子容器，父容器为ApplicationContext</p><h3 id="跨域处理"><a class="markdownIt-Anchor" href="#跨域处理"></a> 跨域处理</h3><p>由于浏览器对于Javascript的<strong>同源策略</strong>的限制，导致A网站不能通过JS（主要就是Ajax请求）去访问B网站的数据，于是跨域问题就出现了。</p><p>跨域指的是<strong>域名、端口、协议</strong>的组合不同就是跨域。</p><pre><code class="highlight plaintext">http://www.kkb.com/https://www.kkb.comhttp://www.kkb.cnhttp://www.kkb.com:8080/</code></pre><p><strong>为什么要有同源策略？</strong></p><p>我们举例说明：比如一个黑客程序，他利用IFrame把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了</p><h4 id="cors"><a class="markdownIt-Anchor" href="#cors"></a> CORS</h4><p>CORS是一个<strong>W3C</strong>标准，全称是&quot;<strong>跨域资源共享</strong>&quot;（Cross-origin resource</p><p>sharing）。</p><p>它允许浏览器向跨源服务器，发出<strong>XMLHttpRequest</strong>请求，从而克服了AJAX只能同源使用的限制。</p><p>CORS需要<strong>浏览器和服务器同时支持</strong>。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p><p>CORS原理：只需要向响应头header中注入<strong>Access-Control-Allow-Origin</strong>，这样浏览器检测到header中的Access-Control-Allow-Origin，则就可以跨域操作了</p><h4 id="cors请求分类"><a class="markdownIt-Anchor" href="#cors请求分类"></a> CORS请求分类</h4><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）</p><p>只要同时满足以下两大条件，就属于<strong>简单请求</strong></p><p>凡是不同时满足上面两个条件，就属于<strong>非简单请求</strong>。</p><p>浏览器对这两种请求的处理，是不一样的</p><h5 id="简单请求"><a class="markdownIt-Anchor" href="#简单请求"></a> 简单请求</h5><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<strong>Origin</strong>字段</p><p><strong>请求信息</strong></p><p><strong>响应信息</strong></p><p><strong>字段说明</strong></p><ul><li>Access-Control-Allow-Origin<ul><li>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</li></ul></li><li>Access-Control-Allow-Credentials<ul><li>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可</li></ul></li></ul><h5 id="非简单请求"><a class="markdownIt-Anchor" href="#非简单请求"></a> 非简单请求</h5><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;<strong>预检</strong>&quot;请求（preflight）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错</p><p><strong>请求信息</strong></p><p>HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。</p><p>浏览器发现，这是一个非简单请求，就自动发出一个&quot;预检&quot;请求，要求服务器确认可以这样请求。下面是这个&quot;预检&quot;请求的HTTP头信息</p><p>&quot;预检&quot;请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。</p><p>除了Origin字段，&quot;预检&quot;请求的头信息包括两个特殊字段。</p><ul><li><strong>Access-Control-Request-Method</strong><br />该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</li><li><strong>Access-Control-Request-Headers</strong><br />该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header</li></ul><blockquote><p><strong>一旦服务器通过了&quot;预检&quot;请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样</strong>，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段</p></blockquote><h4 id="cors实现"><a class="markdownIt-Anchor" href="#cors实现"></a> CORS实现</h4><p>使用<strong>springmvc的拦截器</strong>实现</p><h5 id="跨域提交cookie"><a class="markdownIt-Anchor" href="#跨域提交cookie"></a> 跨域提交Cookie</h5><pre><code class="highlight plaintext">public class AllowOriginInterceptor implements HandlerInterceptor &#123;     @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object arg2) throws Exception &#123;       // 有跨域行为时参考网址 http://namezhou.iteye.com/blog/2384434       if (request.getHeader(&quot;Origin&quot;) != null) &#123;           response.setContentType(&quot;text/html;charset=UTF-8&quot;);           // 允许哪一个URL          response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);           // 允许那种请求方法          response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE&quot;);          response.setHeader(&quot;XDomainRequestAllowed&quot;, &quot;1&quot;);           System.out.println(&quot;正在跨域&quot;);       &#125;       return true;    &#125; &#125;</code></pre><blockquote><p>然后配置拦截器</p></blockquote><h5 id="跨域提交cookie-2"><a class="markdownIt-Anchor" href="#跨域提交cookie-2"></a> 跨域提交Cookie</h5><p><strong>注意事项</strong></p><ul><li><strong>Access-Control-Allow-Credentials</strong> 为 <strong>true</strong>的时候，Access-Control-Allow-Origin一定不能设置为”* ”，否则<strong>报错</strong></li><li>如果有多个拦截器，一定要把处理跨域请求的拦截器放到<strong>首位</strong></li></ul><p><strong>js代码</strong></p><ul><li>jquery Ajax</li></ul><pre><code class="highlight plaintext">$.ajax(&#123;url: &#x27;自己要请求的url&#x27;,method:&#x27;请求方式&#x27;,  //GET POST PUT DELETExhrFields:&#123;withCredentials:true&#125;,success:function(data)&#123;   //自定义请求成功做什么&#125;,error:function()&#123;//自定义请求失败做什么&#125;&#125;)</code></pre><ul><li>angular JS</li></ul><pre><code class="highlight plaintext">1. 全局 在模块配置中添加app.config([&#x27;$httpProvider&#x27;,function($httpProvider) &#123;   $httpProvider.defaults.withCredentials = true; &#125; ]);2. 单个请求$http.get(url, &#123;withCredentials: true&#125;);$http.post(url,data, &#123;withCredentials: true&#125;);$httpProvider.defaults.withCredentials = true;</code></pre><p><strong>java代码</strong></p><pre><code class="highlight plaintext">public class AllowOriginInterceptor implements HandlerInterceptor &#123;     @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object arg2) throws Exception &#123;       // 有跨域行为时参考网址 http://namezhou.iteye.com/blog/2384434       if (request.getHeader(&quot;Origin&quot;) != null) &#123;           response.setContentType(&quot;text/html;charset=UTF-8&quot;);           // 允许哪一个URL 访问 request.getHeader(&quot;Origin&quot;) 根据请求来的url动态允许          response.setHeader(&quot;Access-Control-Allow-Origin&quot;, request.getHeader(&quot;Origin&quot;));           // 允许那种请求方法          response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE,HEAD&quot;);           response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;0&quot;);           // 允许请求头里的参数列表           response.setHeader(&quot;Access-Control-Allow-Headers&quot;,                  &quot;Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With,userId,token&quot;);           // 允许对方带cookie访问     response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);          response.setHeader(&quot;XDomainRequestAllowed&quot;, &quot;1&quot;);           System.out.println(&quot;正在跨域&quot;);       &#125;       return true;    &#125;&#125;</code></pre><h3 id="pathvariable和requestparam的区别"><a class="markdownIt-Anchor" href="#pathvariable和requestparam的区别"></a> @PathVariable和@RequestParam的区别</h3><p><strong>用法上的不同</strong>：从名字上可以看出来，PathVariable只能用于接收url路径上的参数，而RequestParam只能用于接收请求带的params</p><p>看下面一个例子：</p><pre><code class="highlight plaintext">package com.lrm.springbootdemo.web;import org.springframework.web.bind.annotation.*;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;@RestController@RequestMapping(&quot;/api/v1&quot;)public class HelloController &#123;    @GetMapping(&quot;/books/&#123;username&#125;&quot;)    public Object testPathVariable(@PathVariable String username)&#123;        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;username&quot;,username);        return map;    &#125;    @PostMapping(&quot;/books2&quot;)    public Object testRequestParam(@RequestParam(&quot;name&quot;) String name,                       @RequestParam(&quot;author&quot;) String author,                       @RequestParam(&quot;isbn&quot;) String isbn) &#123;        Map&lt;String, Object&gt; book = new HashMap&lt;String, Object&gt;();        book.put(&quot;name&quot;, name);        book.put(&quot;author&quot;, author);        book.put(&quot;isbn&quot;, isbn);        return book;    &#125;    @PostMapping(&quot;/books2/&#123;id&#125;&quot;)    public Object test(@PathVariable(&quot;id&quot;) long id,@RequestParam(&quot;name&quot;) String name,                       @RequestParam(&quot;author&quot;) String author,                       @RequestParam(&quot;isbn&quot;) String isbn) &#123;        Map&lt;String, Object&gt; book = new HashMap&lt;String, Object&gt;();        book.put(&quot;id&quot;,id);        book.put(&quot;name&quot;, name);        book.put(&quot;author&quot;, author);        book.put(&quot;isbn&quot;, isbn);        return book;    &#125;&#125;</code></pre><p>其中testPathVariable这个方法中的username参数只能使用@PathVariable来接收，因为username参数是url的path上携带的参数。username是无法使用RequestParam来接受的。</p><p>testRequestParam这个方法只能用于</p><pre><code class="highlight plaintext">localhost:8080/api/v1/books2/12?name=java in action&amp;author=ric&amp;isbn=dsdas2334</code></pre><p>这种模式的请求，因为RequestParam只能用于接收请求上带的params，testPathVariable是无法接收上面的name、author、isbn参数的。</p><p><strong>内部参数不同</strong></p><p>PathVariable有value，name，required这三个参数，而RequestParam也有这三个参数，并且比PathVariable多一个参数defaultValue（该参数用于当请求体中不包含对应的参数变量时，参数变量使用defaultValue指定的默认值）</p><p><strong>PathVariable一般用于get和delete请求，RequestParam一般用于post请求</strong></p>]]>
    </content>
    <id>http://example.com/2023/03/16/Spring_MVC/</id>
    <link href="http://example.com/2023/03/16/Spring_MVC/"/>
    <published>2023-03-16T04:00:00.000Z</published>
    <summary>Spring MVC是Spring框架一个非常重要的功能模块，实现了MVC结构，便于简单，快速开发MVC结构的Web程序，Spring Web MVC提供的API封装了Web开发中常用的功能，简化了Web过程。springMVC是为了解决表现层问题的web框架，他们都是基于MVC设计模式的，表现层的主要职责就是处理前端HTTP请求</summary>
    <title>Spring MVC</title>
    <updated>2026-02-26T09:19:24.591Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    <content>
      <![CDATA[<h1 id="spring"><a class="markdownIt-Anchor" href="#spring"></a> $Spring</h1><ul><li><a href="">Spring IOC</a><ul><li><a href="">1. Spring是什么？</a><ul><li><a href="">优点</a></li><li><a href="">Spring的组成</a></li><li><a href="">spring体系结构</a></li><li><a href="">spring容器的核心</a><ul><li><a href="">IoC</a></li><li><a href="">AOP</a></li></ul></li><li><a href="">为什么使用IoC</a></li><li><a href="">Spring IoC源码分析</a><ul><li><a href="">什么是IoC容器</a></li><li><a href="">如何创建IoC容器</a></li><li><a href="">如何创建web环境中的IoC容器</a></li><li><a href="">容器初始化主流程分析</a><ul><li><a href="">创建Bean Factory子流程</a></li><li><a href="">加载解析BeanDefinition子流程（loadDefinitions方法）</a></li><li><a href="">创建bean流程分析</a></li></ul></li></ul></li></ul></li><li><a href="">2.Spring使用</a><ul><li><a href="">启动spring容器</a><ul><li><a href="">spring Maven依赖</a></li><li><a href="">spring核心配置文件 applicationContext.xml</a></li><li><a href="">启动spring容器</a></li></ul></li><li><a href="">Spring Bean定义</a><ul><li><a href="">bean属性</a></li><li><a href="">Bean和spring容器的关系</a></li></ul></li><li><a href="">如何创建对象</a><ul><li><a href="">bean标签详解</a></li><li><a href="">实例化bean的三种方式</a></li><li><a href="">spring 原理</a></li></ul></li><li><a href="">作用域（scope）</a><ul><li><a href="">spring scope原理</a></li></ul></li><li><a href="">生命周期 init-method/destroy-method</a></li><li><a href="">后置处理器</a><ul><li><a href="">Spring_Bean后置处理器</a></li><li><a href="">基础案例</a></li><li><a href="">高级案例</a></li><li><a href="">后置对象原理</a></li></ul></li><li><a href="">延迟加载（lazy-init=“true”）</a></li><li><a href="">Spring Bean定义继承（parent）</a><ul><li><a href="">Bean定义模板（abstract=“true”）</a></li></ul></li><li><a href="">Spring bean依赖关系</a></li><li><a href="">动态工厂DynamicFactory</a><ul><li><a href="">Spring动态工厂原理</a></li></ul></li><li><a href="">静态工厂</a></li></ul></li><li><a href="">3.IOC(Inversion Of Controll 控制反转)</a><ul><li><a href="">IOC实现原理</a></li><li><a href="">DI(Dependency Injection)依赖注入</a><ul><li><a href="">DI概述</a></li><li><a href="">DI 依赖注入原理</a></li></ul></li><li><a href="">1.Set方式注入（property）</a><ul><li><a href="">使用p名称空间注入数据</a></li><li><a href="">Spring注入内部Beans</a></li></ul></li><li><a href="">2构造器方式注入</a></li><li><a href="">3自动装配（了解）</a></li><li><a href="">4 注入基本/集合类型的值</a></li><li><a href="">5 引用的方式注入集合类型的值</a></li><li><a href="">6 注入空值</a></li><li><a href="">7 读取配置文件properties的值</a></li><li><a href="">8 使用spring表达式</a></li></ul></li><li><a href="">Spring IoC注解</a><ul><li><a href="">1.什么是组件扫描</a></li><li><a href="">2.如何进行组件扫描</a></li><li><a href="">3.作用域原型/单例 AND 延迟加载 AND 初始化和销毁 回掉方法</a></li><li><a href="">4 依赖注入相关的注解</a><ul><li><a href="">@Autowired</a></li><li><a href="">@Resource（重点）</a></li><li><a href="">@Value</a><ul><li><a href="">@value(“#{}”)和@value(“${}”)的区别</a></li><li><a href="">通过util:properties</a></li><li><a href="">通过PropertyPlaceholderConfigurer</a></li><li><a href="">通过PreferencesPlaceholderConfigurer</a></li><li><a href="">通过PropertiesFactoryBean</a></li></ul></li></ul></li></ul></li><li><a href="">Java类取代spring xml配置</a><ul><li><a href="">@Configuration和@Bean注解</a></li><li><a href="">@ComponentScan</a></li><li><a href="">@PropertySource</a></li><li><a href="">@Resource</a></li><li><a href="">@Import</a></li><li><a href="">注入List</a></li><li><a href="">生命周期回调</a></li><li><a href="">创建第三方Bean</a></li><li><a href="">初始化和销毁</a></li><li><a href="">使用别名</a></li><li><a href="">@Profile</a></li><li><a href="">@Conditional</a></li><li><a href="">注入Bean的依赖性</a></li><li><a href="">通过注解获取容器</a></li><li><a href="">使用FactoryBean</a></li></ul></li><li><a href="">Spring 分模块开发</a><ul><li><a href="">如何加载多个配置文件</a></li></ul></li><li><a href="">Spring 整合Junit</a></li><li><a href="">Spring中事件处理</a><ul><li><a href="">Spring中的事件处理</a></li><li><a href="">监听上下文</a></li><li><a href="">案例</a><ul><li><a href="">Spring中的自定义事件</a></li></ul></li></ul></li></ul></li></ul><h1 id="spring-ioc"><a class="markdownIt-Anchor" href="#spring-ioc"></a> Spring IOC</h1><pre><code class="highlight plaintext">spring.io</code></pre><h2 id="1-spring是什么"><a class="markdownIt-Anchor" href="#1-spring是什么"></a> 1. Spring是什么？</h2><ul><li>Spring是一个开源的轻量级的应用开发框架，其目的是用于简化企业级应用程序开发，<strong>减少侵入</strong></li><li>Spring提供的IOC和AOP应用，可以将组建的耦合度降至最低，即解耦，便于系统日后的维护和升级</li><li><strong>宗旨</strong><ul><li>不发明重复的轮子</li></ul></li><li>Spring的本质是管理软件中的对象，如何创建对象和维护对象之间的关系</li></ul><hr /><ul><li>是spring框架中的一个核心模块，用来管理对象</li><li>在Spring中，任何的Java类都被当成Bean处理，这些Bean通过容器管理和应用</li><li>Spring容器实现了IOC和AOP机制，这些机制可以简化Bean对象创建和Bean对象之间的解耦</li><li>Spring容器有<strong>BeanFactory</strong>和<strong>ApplicationContext 建议使用</strong>两种类型</li></ul><h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3><ol><li><strong>方便解耦，简化开发</strong> 通过spring提供的ioc容器，我们可以将对象之间的依赖关系交给spring控制，避免硬编码所造成的过度程序耦合。有了spring，用户不用再为单例模式，属性文件解析等底层的需求编写代码，可以更加专注于上层的应用</li><li><strong>AOP编程支持</strong> 通过spring提供的AOP功能，方便的进行面向切面的编程，许多不容易用传统OOP实现的功能可以使用AOP轻松的应付</li><li><strong>声明式事务的支持</strong> 在spring中，我们可以从单调烦闷的事务管理的代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量</li><li><strong>方便程序的测试</strong> 可以用非容器依赖的编程方式进行几乎所有的测试工作，在spring里，测试不再是昂贵的操作，而是随手可做的事情，例如：spring对Junit4支持，可以通过注解方便的测试Spring程序</li><li><strong>方便集成各种优秀的框架</strong> spring对于主流的应用框架提供了集成支持，如hibernate，JPA，Struts，Hessian，Quartz等</li><li><strong>降低Java EE API的使用难度</strong> Spring对于很多难用的Java EE API（如：JDBCJavaMail,远程调用等）提供了一个薄薄的封装层，通过spring的简易封装，这些Java EE API的使用难度大为降低</li><li><strong>Java源码四经典学习范例</strong> spring的源码设计精妙，结构清晰，匠心独运，处处提心着大师对Java设计模式的灵活运用以及对Java技术的高深造诣，spring框架源码无疑式Java技术的最佳实践范例，如果想在短时间迅速提高自己的Java技术水平和应用开发水平，学习和研究spring源码将会使你收到意想不到的效果</li></ol><p><strong>总结起来，spring有如下优点</strong></p><ol><li>低倾入式设计，代码污染极低</li><li>独立于各种应用服务器，基于spring框架的应用，可以真正实现一次编写，到处运行的承诺</li><li>spring的DI机制降低了业务对象替换的复杂性，提高了组件之间的解耦</li><li>spring的AOP支持允许将一些通用任务如安全，事务，日志等进行集中式管理，从而提供了更好的复用</li><li>spring的orm和dao提供了第三方持久层框架的良好整合，并简化了底层的数据库访问</li><li>spring并不强制应用完全依赖于spring，开发者可以自由选用spring框架的部分或者全部</li></ol><h3 id="spring的组成"><a class="markdownIt-Anchor" href="#spring的组成"></a> Spring的组成</h3><ul><li>DAO<ul><li>Spring DAO : 对JDBC的抽象，简化了数据访问异常的处理，Spring提供了对JDBC的操作支持：JdbcTemplate模板工具类</li></ul></li><li>ORM<ul><li>Spring可以和ORM框架整合，例如Spring整合Hibernate框架，其中Spring还提供HibernateDaoSupport工具类，简化了Hibernate操作</li></ul></li><li>AOP<ul><li>Spring提供了面向切面的编程，可以给某一层提供事物管理，例如再Service层添加事物控制</li></ul></li><li>JEE<ul><li>J2EE开发规范的支持，例如EJB</li></ul></li><li>WEB<ul><li>Spring提供了对Struts，Springmvc的支持，支持WEB开发，于此同事Spring自身也提供了基于MVC的解决方案</li></ul></li><li>CORE<ul><li>核心类库，提供IOC容器对象的创建和处理以来对象关系</li></ul></li><li>Context<ul><li>提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）</li></ul></li><li>MVC<ul><li>提供面向Web应用的Model-View-Controller实现</li></ul></li></ul><h3 id="spring体系结构"><a class="markdownIt-Anchor" href="#spring体系结构"></a> spring体系结构</h3><h3 id="spring容器的核心"><a class="markdownIt-Anchor" href="#spring容器的核心"></a> spring容器的核心</h3><p>spring框架的核心就是<strong>ioc（控制反转）和AOP（面向切面编程）</strong></p><ul><li>IoC简单理解就是<strong>控制对象创建的角色</strong>由程序员反转为Spring IoC容器</li><li>AOP简单理解就是针对目标对象进行动态代理，横向增强JavaBean的功能</li></ul><h4 id="ioc"><a class="markdownIt-Anchor" href="#ioc"></a> IoC</h4><p>Spring IoC容器的本质就是<strong>创建类实例的工厂</strong>，并且对类实例进行管理</p><p>Spring IoC容器需要<strong>通过Bean工厂来是实现</strong>，在spring框架中，主要有两个工厂接口：BeanFactory接口和ApplicationContext接口（该接口实现了Bean Factory接口）</p><ul><li>其中BeanFactory接口时Spring早期创建Bean对象的工厂接口</li><li>而我们现在大多数是通过ApplicationContext接口进行Bean工厂的创建</li></ul><p>Spring IoC容器<strong>加载Bean信息</strong>的方式有XML配置方式和注解方式</p><ul><li>XML配置方式：bean标签</li><li>注解方式：@Component、@Controller、@Service、@Repository，需要使用context:component-scan标签配合使用</li></ul><p>Spring IoC<strong>容器的创建方式</strong>主要有两种场景：Java Application中创建（jar包）和在Web Application（war包）中创建（重点）</p><ul><li>在Java application中创建Spring IoC容器主要通过applicationContext接口的两个实现类来完成：<code>ClassPathXmlApplicationContext</code>和<code>FileSystemXmlApplicationContext</code></li><li>在Web Application中创建sprig IoC容器主要是通过ApplicationContext接口的子接口<code>WebApplicationContext</code>来实现的<ul><li>WebApplicationContext是通过<code>ContextLoaderListener</code>（实现ServletcontextListener接口）创建后，放入<code>ServletContext</code>域对象中的</li></ul></li></ul><p>Spring DI(依赖注入)是基于IoC使用的，简单理解就是Bean工厂在生成Bean对象的时候，如果Bean对象需要装配一个属性，那么就会通过DI将属性值注入给对象的属性</p><ul><li>依赖注入的方式主要有<strong>构造方法注入</strong>和<strong>set方式注入</strong></li><li>set方式注入又分为<strong>手动装配方式注入</strong>和<strong>自动装配方式注入</strong><ul><li>手动装配方式（XML方式）：Bean标签的子标签propery，需要在类中指定set方法</li><li>自动装配方式（注解方式）：<code>@Autowired</code>注解，<code>@Resource</code>注解<ul><li>@Autowired：一部分功能是<strong>查找实例</strong>，从spring容器中根据类型（Java类）获取对应的实例，另一部分功能就是<strong>赋值</strong>，将找到的实例，装配给另一个实例的属性值（注意：一个Java类型在同一个spring容器中，只能有一个实例）</li><li>@Resource：一部分功能是<strong>查找实例</strong>，从spring容器中根据Bean的名称（bean标签的名称）获取对应的实例。另一部分功能就是<strong>赋值</strong>，将找到的实例，装配给另一个实力的属性值</li></ul></li></ul></li></ul><h4 id="aop"><a class="markdownIt-Anchor" href="#aop"></a> AOP</h4><p>Spring AOP实现原理是什么？</p><ul><li>动态代理技术（反射）：<strong>基于JDK的动态代理</strong>和使用<strong>CGLib的动态代理</strong></li><li>动态代理方式选择：根据是否实现接口来选择哪种代理方式</li></ul><h3 id="为什么使用ioc"><a class="markdownIt-Anchor" href="#为什么使用ioc"></a> 为什么使用IoC</h3><p>Spring提供的容器又称为IoC容器，什么是IoC？</p><p>IoC全称Inversion of Control，直译为控制反转。那么何谓IoC？在理解IoC之前，我们先看看通常的Java组件是如何协作的。</p><p>我们假定一个在线书店，通过BookService获取书籍：</p><pre><code class="highlight plaintext">public class BookService &#123;    private HikariConfig config = new HikariConfig();    private DataSource dataSource = new HikariDataSource(config);    public Book getBook(long bookId) &#123;        try (Connection conn = dataSource.getConnection()) &#123;            ...            return book;        &#125;    &#125;&#125;</code></pre><p>为了从数据库查询书籍，BookService持有一个DataSource。为了实例化一个HikariDataSource，又不得不实例化一个HikariConfig。</p><p>现在，我们继续编写UserService获取用户：</p><pre><code class="highlight plaintext">public class UserService &#123;    private HikariConfig config = new HikariConfig();    private DataSource dataSource = new HikariDataSource(config);    public User getUser(long userId) &#123;        try (Connection conn = dataSource.getConnection()) &#123;            ...            return user;        &#125;    &#125;&#125;</code></pre><p>因为UserService也需要访问数据库，因此，我们不得不也实例化一个HikariDataSource。</p><p>在处理用户购买的CartServlet中，我们需要实例化UserService和BookService：</p><pre><code class="highlight plaintext">public class CartServlet extends HttpServlet &#123;    private BookService bookService = new BookService();    private UserService userService = new UserService();    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        long currentUserId = getFromCookie(req);        User currentUser = userService.getUser(currentUserId);        Book book = bookService.getBook(req.getParameter(&quot;bookId&quot;));        cartService.addToCart(currentUser, book);        ...    &#125;&#125;</code></pre><p>类似的，在购买历史HistoryServlet中，也需要实例化UserService和BookService：</p><pre><code class="highlight plaintext">public class HistoryServlet extends HttpServlet &#123;    private BookService bookService = new BookService();    private UserService userService = new UserService();&#125;</code></pre><p>上述每个组件都采用了一种简单的通过new创建实例并持有的方式。仔细观察，会发现以下缺点：</p><ol><li>实例化一个组件其实很难，例如，BookService和UserService要创建HikariDataSource，实际上需要读取配置，才能先实例化HikariConfig，再实例化HikariDataSource。</li><li>没有必要让BookService和UserService分别创建DataSource实例，完全可以共享同一个DataSource，但谁负责创建DataSource，谁负责获取其他组件已经创建的DataSource，不好处理。类似的，CartServlet和HistoryServlet也应当共享BookService实例和UserService实例，但也不好处理。</li><li>很多组件需要销毁以便释放资源，例如DataSource，但如果该组件被多个组件共享，如何确保它的使用方都已经全部被销毁？</li><li>随着更多的组件被引入，例如，书籍评论，需要共享的组件写起来会更困难，这些组件的依赖关系会越来越复杂。</li><li>测试某个组件，例如BookService，是复杂的，因为必须要在真实的数据库环境下执行。</li></ol><p>从上面的例子可以看出，如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。</p><p>因此，核心问题是：</p><ul><li>谁负责创建组件？</li><li>谁负责根据依赖关系组装组件？<br />销毁时，如何按依赖顺序正确销毁？</li></ul><p>解决这一问题的核心方案就是IoC。</p><p>传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制，例如：CartServlet创建了BookService，在创建BookService的过程中，又创建了DataSource组件。这种模式的缺点是，一个组件如果要使用另一个组件，必须先知道如何正确地创建它。</p><p>在IoC模式下，<strong>控制权发生了反转</strong>，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，例如，BookService自己并不会创建DataSource，而是等待外部通过setDataSource()方法来注入一个DataSource：</p><pre><code class="highlight plaintext">public class BookService &#123;    private DataSource dataSource;    public void setDataSource(DataSource dataSource) &#123;        this.dataSource = dataSource;    &#125;&#125;</code></pre><p>不直接new一个DataSource，而是注入一个DataSource，这个小小的改动虽然简单，却带来了一系列好处：</p><ol><li>BookService不再关心如何创建DataSource，因此，不必编写读取数据库配置之类的代码；</li><li>DataSource实例被注入到BookService，同样也可以注入到UserService，因此，共享一个组件非常简单；</li><li>测试BookService更容易，因为注入的是DataSource，可以使用内存数据库，而不是真实的MySQL配置。</li></ol><p>因此，IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：<strong>将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期</strong>。</p><p>因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。一种最简单的配置是通过XML文件来实现，例如：</p><pre><code class="highlight plaintext">&lt;beans&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;HikariDataSource&quot; /&gt;    &lt;bean id=&quot;bookService&quot; class=&quot;BookService&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;/bean&gt;    &lt;bean id=&quot;userService&quot; class=&quot;UserService&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为dataSource的组件通过属性dataSource（即调用setDataSource()方法）注入到另外两个组件中。</p><p>在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。</p><h3 id="spring-ioc源码分析"><a class="markdownIt-Anchor" href="#spring-ioc源码分析"></a> Spring IoC源码分析</h3><h4 id="什么是ioc容器"><a class="markdownIt-Anchor" href="#什么是ioc容器"></a> 什么是IoC容器</h4><p>所谓的IoC容器就是指spring中bean工厂里面的Map存储结构（存储了Bean实例）</p><p><strong>spring框架中的工厂有哪些？</strong></p><ul><li><code>ApplicationContext</code>接口（）<ul><li>实现了BeanFactory接口</li><li>实现ApplicationContext接口的工厂，可以获取到容器中具体的Bean对象</li></ul></li><li><code>BeanFactory</code>工厂（是Spring框架早期的创建Bean对象的工厂接口）<ul><li>实现BeanFactory接口的工厂也可以获取到Bean对象</li></ul></li></ul><blockquote><p>其实通过源码分析，不管是<code>BeanFactory</code>还是<code>ApplicationContext</code>，其实最终的底层<code>BeanFactory</code>都是<code>DefaultListableBeanFactory</code></p></blockquote><p><strong>ApplicationContext和BeanFactory的区别？</strong></p><ul><li><code>BeanFactory</code>采取延迟加载，第一次getBean时才会初始化Bean。</li><li><code>ApplicationContext</code>是加载完applicationContext.xml时，就创建具体的Bean对象的实例。（只对BeanDefition中描述为是单例的bean，才进行饿汉式加载）</li></ul><p><strong>继承结构</strong></p><h4 id="如何创建ioc容器"><a class="markdownIt-Anchor" href="#如何创建ioc容器"></a> 如何创建IoC容器</h4><p><strong>创建方式</strong></p><p>Application接口常用实现类</p><ul><li><code>ClassPathXmlApplicationContext</code>: 它是从类的根路径下加载配置文件，推荐使用这种</li><li><code>FileSystemXmlApplicationContext</code>: 它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置</li><li><code>AnnotationConfigApplicationContext</code>: 当我们使用注解配置容器对象时，需要使用此类来创建spring容器，它用来读取注解</li></ul><p><strong>Java应用中创建IoC容器</strong></p><pre><code class="highlight plaintext">ApplicationContext context = new ClassPathXmlApplicationContext(xml路径)</code></pre><h4 id="如何创建web环境中的ioc容器"><a class="markdownIt-Anchor" href="#如何创建web环境中的ioc容器"></a> 如何创建web环境中的IoC容器</h4><p>web.xml中配置ContextLoaderListener接口，并配置ContextConfigLocation参数</p><ol><li><p>web服务器tomcat启动会加载web.xml（启动<strong>ContextLoaderListener</strong>监听器）</p></li><li><p>web服务器启动后，会创建ServletContext（web上下文，也就是web容器）此时会触发ContextLoaderListener监听器的<strong>contextInitialized</strong>()方法</p></li><li><p>contextInitialized()方法中会调用<strong>initWebApplicationContext</strong>()方法，该方法负责创建spring容器（<strong>DefaultListableBeanFctory</strong>）和生产bean对象</p></li><li><p>initWebApplicationContext()方法负责创建WebApplicationContext，通过createWebApplicationContext()方法</p></li></ol><blockquote><p>WebApplicationContext是一个接口，此处创建的是它的默认实现类，XmlWebApplicationContext（Web容器中真正的实例）</p></blockquote><ol><li><p>加载spring配置文件，并创建beans，通过configureAndRefreshWebApplicationContext()方法</p></li><li><p>将spring容器context挂载到ServletContext这个web容器的上下文中，通过servletContext.setAttribute()方法</p></li></ol><hr /><p><strong>Web三类八种监听器</strong></p><p><strong>监听域对象的生命周期：</strong></p><p>ServletContextListener:</p><ul><li>创建：服务器启动</li><li>销毁：服务器正常关闭</li><li>spring ContextLoaderListener（服务器启动时负责加载spring配置文件）</li></ul><p>HttpSessionListener</p><ul><li>创建：第一次访问request.getHttpSession()</li><li>销毁：调用invalidate()，非法关闭，国企</li></ul><p>ServletRequestListener</p><ul><li>创建：每一次访问</li><li>销毁：响应结束</li></ul><p><strong>监听域对象的属性：（添加，删除，替换）</strong></p><ul><li>ServletContextAttributeListener</li><li>HttpSessionAttributeListener</li><li>ServletRequestAttributeListener</li></ul><p><strong>监听HttpSession中JavaBean的改变：</strong></p><ul><li>HttpSessionBindingListener（HttpSession和JavaBean对象的绑定和解绑）</li><li>HttpSessionActivationListener（HttpSession的序列化，活化、钝化）</li></ul><h4 id="容器初始化主流程分析"><a class="markdownIt-Anchor" href="#容器初始化主流程分析"></a> 容器初始化主流程分析</h4><p>主流程入口</p><pre><code class="highlight plaintext">ApplicationContext context = new ClassPathXmlApplicationContext（“spring.xml”）</code></pre><p>ClassPathXmlApplicationContext类：重载的构造方法依次调用，进入下面代码</p><p>AbstractApplicationContext的refresh方法：初始化spring容器的核心代码</p><pre><code class="highlight plaintext">public void refresh() throws BeansException, IllegalStateException &#123;    synchronized (this.startupShutdownMonitor) &#123;        // Prepare this context for refreshing.        prepareRefresh();        // 1.创建真正的Spring容器（DefaultListableBeanFactory）        // 2.加载BeanDefition（描述要初始化的Bean的信息）        // 3.将BeanDefition注册到BeanDefitionRegistry        // Tell the subclass to refresh the internal bean factory.        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();        // Prepare the bean factory for use in this context.        prepareBeanFactory(beanFactory);        try &#123;            // Allows post-processing of the bean factory in context subclasses.            postProcessBeanFactory(beanFactory);            // 执行实现了BeanFactoryPostProcessor接口的Bean            // 比如PropertyPlaceHolderConfigurer（context:property-placeholer）就是此处被调用的，替换掉BeanDefition中的占位符（$&#123;&#125;）中的内容            // Invoke factory processors registered as beans in the context.            invokeBeanFactoryPostProcessors(beanFactory);            // 注册BeanPostProcessor（后置处理器）            // 比如容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器（实现@Autowired注解功能）            // Register bean processors that intercept bean creation.            registerBeanPostProcessors(beanFactory);            // Initialize message source for this context.            initMessageSource();            // Initialize event multicaster for this context.            initApplicationEventMulticaster();            // Initialize other special beans in specific context subclasses.            onRefresh();            // Check for listener beans and register them.            registerListeners();            // 初始化非懒加载方式的单例Bean实例            // Instantiate all remaining (non-lazy-init) singletons.            finishBeanFactoryInitialization(beanFactory);            // Last step: publish corresponding event.            finishRefresh();        &#125;catch (BeansException ex) &#123;            if (logger.isWarnEnabled()) &#123;                logger.warn(&quot;Exception encountered during context initialization - &quot; +                        &quot;cancelling refresh attempt: &quot; + ex);            &#125;            // Destroy already created singletons to avoid dangling resources.            destroyBeans();            // Reset &#x27;active&#x27; flag.            cancelRefresh(ex);            // Propagate exception to caller.            throw ex;        &#125;        finally &#123;            // Reset common introspection caches in Spring&#x27;s core, since we            // might not ever need metadata for singleton beans anymore...            resetCommonCaches();        &#125;    &#125;&#125;</code></pre><p>流程说明：</p><ol><li>ResourceLoader从存储介质中加载Spring配置信息，并使用Resource表示这个配置文件的资源；</li><li>BeanDefinitionReader读取Resource所指向的配置文件资源，然后解析配置文件。配置文件中每一个<bean>解析成一个BeanDefinition对象，并保存到BeanDefinitionRegistry中；</li><li>容器扫描BeanDefinitionRegistry中的BeanDefinition，使用Java的反射机制自动识别出Bean工厂后处理后器（实现BeanFactoryPostProcessor接口）的Bean，然后调用这些Bean工厂后处理器对BeanDefinitionRegistry中的BeanDefinition进行加工处理。主要完成以下两项工作：<ul><li>对使用到占位符的<bean>元素标签进行解析，得到最终的配置值，这意味对一些半成品式的BeanDefinition对象进行加工处理并得到成品的BeanDefinition对象；</li><li>对BeanDefinitionRegistry中的BeanDefinition进行扫描，通过Java反射机制找出所有属性编辑器的Bean（实现java.beans.PropertyEditor接口的Bean），并自动将它们注册到Spring容器的属性编辑器注册表中（PropertyEditorRegistry）；</li></ul></li><li>Spring容器从BeanDefinitionRegistry中取出加工后的BeanDefinition，并调用InstantiationStrategy着手进行Bean实例化的工作；</li><li>在实例化Bean时，Spring容器使用BeanWrapper对Bean进行封装，BeanWrapper提供了很多以Java反射机制操作Bean的方法，它将结合该Bean的BeanDefinition以及容器中属性编辑器，完成Bean属性的设置工作；</li><li>利用容器中注册的Bean后处理器（实现BeanPostProcessor接口的Bean）对已经完成属性设置工作的Bean进行后续加工，直接装配出一个准备就绪的Bean。<br />Spring容器确实堪称一部设计精密的机器，其内部拥有众多的组件和装置。Spring的高明之处在于，它使用众多接口描绘出了所有装置的蓝图，构建好Spring的骨架，继而通过继承体系层层推演，不断丰富，最终让Spring成为有血有肉的完整的框架。所以查看Spring框架的源码时，有两条清晰可见的脉络：<ul><li>接口层描述了容器的重要组件及组件间的协作关系；</li><li>继承体系逐步实现组件的各项功能。</li></ul></li><li>接口层清晰地勾勒出Spring框架的高层功能，框架脉络呼之欲出。有了接口层抽象的描述后，不但Spring自己可以提供具体的实现，任何第三方组织也可以提供不同实现， 可以说Spring完善的接口层使框架的扩展性得到了很好的保证。纵向继承体系的逐步扩展，分步骤地实现框架的功能，这种实现方案保证了框架功能不会堆积在某些类的身上，造成过重的代码逻辑负载，框架的复杂度被完美地分解开了。</li></ol><p>Spring组件按其所承担的角色可以划分为两类：</p><ul><li>物料组件：Resource、BeanDefinition、PropertyEditor以及最终的Bean等，它们是加工流程中被加工、被消费的组件，就像流水线上被加工的物料；</li><li>加工设备组件：ResourceLoader、BeanDefinitionReader、BeanFactoryPostProcessor、InstantiationStrategy以及BeanWrapper等组件像是流水线上不同环节的加工设备，对物料组件进行加工处理。</li></ul><h5 id="创建bean-factory子流程"><a class="markdownIt-Anchor" href="#创建bean-factory子流程"></a> 创建Bean Factory子流程</h5><p>子流程入口（从主流程refresh方法中的第二步开始）</p><p>调用AbstractApplicationContext中的obtainFreshBeanFactory方法</p><p>调用AbstractRefreshableApplicationContext的refreshBeanFactory方法</p><h5 id="加载解析beandefinition子流程loaddefinitions方法"><a class="markdownIt-Anchor" href="#加载解析beandefinition子流程loaddefinitions方法"></a> 加载解析BeanDefinition子流程（loadDefinitions方法）</h5><p>此处依次调用多个类的loadBeanDefinitions方法（AbstractXmlApplicationContextà</p><p>AbstractBeanDefinitionReaderà XmlBeanDefinitionReader），一直调用到XmlBeanDefinitionReader 类的doLoadBeanDefinitions方法</p><p>对于doLoadDocument方法不是我们关注的重点，我们进入到该类的registerBeanDefinitions方法看看</p><p>此处有两个地方是我们关注的：一个createRederContext方法，一个是DefaultBeanDefinitionDocumentReader类的registerBeanDefinitions方法，先进入createRederContext方法看看</p><p>至此，14个NamespaceHandlerResolver初始化成功。然后我们再进入DefaultBeanDefinitionDocumentReader类的registerBeanDefinitions方法</p><p>继续进入到该类的doRegisterBeanDefinitions方法看看，这是真正干活的方法</p><p>继续进入parseBeanDefinitions方法</p><p>我们看到有两种解析方案，先看看parseDefaultElement方法</p><p>不过我们重点看看BeanDefinitionParserDelegate类的parseCustomElement方法（AOP标签、tx标签的解析都是在该步骤中完成的）</p><p>getNamespaceURI方法的作用一目了然，我们就不去追踪了，接下来我们进入DefaultNamespaceHandlerResolver类的resolve方法看看：</p><p>在上面代码中，我们看到了一行代码：namespaceHandler.init();这个方法是很重要的。它实现了自定义标签到处理类的注册工作，不过NamespaceHandler是一个接口，具体的init方法需要不同的实现类进行实现，我们通过AopNamespaceHandler了解一下init的作用，其中aop:config标签是由ConfigBeanDefinitionParser类进行处理：</p><p>至此，我们了解到了xml中的aop标签都是由哪些类进行处理的了。不过init方法只是注册了标签和处理类的对应关系，那么什么时候调用处理类进行解析的呢？我们再回到BeanDefinitionParserDelegate类的parseCustomElement方法看看</p><p>我们看到，最后一行执行了parse方法，那么parse方法，在哪呢？我们需要到NamespaceHandlerSupport类中去看看，它是实现NamespaceHandler接口的，并且AopNamespaceHandler是继承了NamespaceHandlerSupport类，那么该方法也会继承到AopNamespaceHandler类中。</p><p>至此，整个XML文档的解析工作，包括bean标签以及自定义标签如何解析为BeanDefinition信息的过程，我们已经了解了</p><h5 id="创建bean流程分析"><a class="markdownIt-Anchor" href="#创建bean流程分析"></a> 创建bean流程分析</h5><p>子流程入口</p><p>我们进入finishBeanFactoryInitialization方法看看：</p><p>继续进入DefaultListableBeanFactory类的preInstantiateSingletons方法，我们找到下面部分的代码，看到工厂Bean或者普通Bean，最终都是通过getBean的方法获取实例的。</p><p>继续跟踪下去，我们进入到了AbstractBeanFactory类的doGetBean方法，这个方法中的代码很多，我们直接找到核心部分：</p><p>接着进入到AbstractAutowireCapableBeanFactory类的方法，找到以下代码部分</p><p>我们终于找到核心的地方了，进入doCreateBean方法看看，该方法我们关注两块重点区域：</p><p>对于如何创建Bean的实例，和填充属性，暂时先不去追踪了，我们先去看看initializeBean方法是如何调用BeanPostProcessor的，因为这个牵扯到我们对于AOP动态代理的理解</p><h2 id="2spring使用"><a class="markdownIt-Anchor" href="#2spring使用"></a> 2.Spring使用</h2><h3 id="启动spring容器"><a class="markdownIt-Anchor" href="#启动spring容器"></a> 启动spring容器</h3><h4 id="spring-maven依赖"><a class="markdownIt-Anchor" href="#spring-maven依赖"></a> spring Maven依赖</h4><p>Spring框架的基础依赖</p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.lee.SimpleSpring&lt;/groupId&gt;    &lt;artifactId&gt;SimpleSpring&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;    &lt;!--Spring核心组件中的四个依赖--&gt;        &lt;!--spring5.0 核心工具包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--spring5.0 Bean管理工具包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;            &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;c        &lt;/dependency&gt;        &lt;!--spring5.0 context管理工具包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--spring5.0 AOP工具包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;            &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 单元测试Junit--&gt;        &lt;dependency&gt;              &lt;groupId&gt;junit&lt;/groupId&gt;              &lt;artifactId&gt;junit&lt;/artifactId&gt;              &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;            &lt;/dependencies&gt;    &lt;!--这里的配置影响构建过程--&gt;    &lt;build&gt;          &lt;plugins&gt;              &lt;!-- 配置Maven的JDK编译级别 --&gt;              &lt;plugin&gt;                   &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                   &lt;artifactId&gt;maven-compiler-plugin&lt;/u&gt;&lt;/artifactId&gt;                   &lt;version&gt;3.2&lt;/version&gt;                   &lt;configuration&gt;                            &lt;source&gt;1.8&lt;/source&gt;                            &lt;target&gt;1.8&lt;/target&gt;                            &lt;encoding&gt;UTF-8&lt;/encoding&gt;                   &lt;/configuration&gt;              &lt;/plugin&gt;          &lt;/plugins&gt;     &lt;/build&gt;&lt;/project&gt;</code></pre><h4 id="spring核心配置文件-applicationcontextxml"><a class="markdownIt-Anchor" href="#spring核心配置文件-applicationcontextxml"></a> spring核心配置文件 applicationContext.xml</h4><p>xml命名空间：xmlns表示的那几行</p><p>如果命名空间没有声明，则下面无法使用</p><p>例子： <code>xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</code></p><p><code>xsi:schemaLocation=&quot;http://www.springframework.org/schema/context</code>    <code>http://www.springframework.org/schema/context/spring-context.xsd</code></p><p><strong>xmlns与xsi:schemaLocation是一一对应的</strong></p><blockquote><p>在spring的xml配置文件中配置一个bean标签，该标签最终会被加载为一个BeanDefition对象（描述对象信息）</p></blockquote><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;     &lt;bean id=&quot;teacher&quot; class=&quot;com.lee.beans.Teacher&quot;&gt;        &lt;property name=&quot;tname&quot; value=&quot;leeBo&quot;&gt;&lt;/property&gt;     &lt;/bean&gt;          &lt;bean id=&quot;student&quot; class=&quot;com.lee.beans.Student&quot;&gt;        &lt;property name=&quot;sname&quot; value=&quot;mike&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;age&quot; value=&quot;22&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;teacher&quot; ref=&quot;teacher&quot;&gt;&lt;/property&gt;     &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>一般的目录结构：</p><h4 id="启动spring容器-2"><a class="markdownIt-Anchor" href="#启动spring容器-2"></a> 启动spring容器</h4><pre><code class="highlight plaintext">       public static void main(String[] args) &#123;             //启动spring容器             ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);             System.err.println(ac);       &#125;</code></pre><hr /><ul><li>使用BeanFactory启动容器<ul><li>第一步利用框架提供的XmlBeanFactory()API去生成工厂bean以及利用<strong>ClassPathResource</strong>()去加载在路劲CLASSPATH下可用的bean配置文件，<strong>XmlBeanFactory</strong>()负责创建并初始化所有的对象，即在配置文件中提到的bean</li></ul></li></ul><pre><code class="highlight plaintext">import ....public class MainApp &#123;   public static void main(String[] args) &#123;      XmlBeanFactory factory = new XmlBeanFactory                             (new ClassPathResource(&quot;Beans.xml&quot;));      HelloWorld obj = (HelloWorld) factory.getBean(&quot;helloWorld&quot;);      obj.getMessage();   &#125;&#125;</code></pre><p>BeanFactory和ApplicationContext的区别在于，BeanFactory的实现是按需创建，即第一次获取Bean时才创建这个Bean，而ApplicationContext会一次性创建所有的Bean。实际上，ApplicationContext接口是从BeanFactory接口继承而来的，并且，ApplicationContext提供了一些额外的功能，包括国际化支持、事件和通知机制等。通常情况下，我们总是使用ApplicationContext，很少会考虑使用BeanFactory。</p><ul><li><strong>ApplicationContext</strong>继承自BeanFactory接口，该容器为较高级的容器，有BeanFacory所具有的全部功能，并增加了企业所需要的功能</li><li>最常被使用的ApplicationContext接口实现<ul><li><strong>FileSystemXmlApplicationContext</strong>：该容器从XML文件中加载被定义的bean，需要提供XML文件的完整路劲</li><li><strong>ClassPathXmlApplicationContext</strong>：该容器从XML文件中加载被定义的bean，不需要完整路径，正确配置CLASSPATH环境变量，容器会从CLASSPATH中搜索bean配置文件</li><li><strong>WebXmlApplicationContext</strong>：该容器会在一个web应用程序的范围内加载在XML文件中已被定义的bean</li></ul></li><li>实例化方法如下：</li></ul><pre><code class="highlight plaintext">//加载文件系统中的配置文件实例化String conf = &quot;C:\applicationContext.xml&quot;;ApplicationContext ac = new FileSystemXmlApplicationContext(conf);//加载工程classpath下的配置文件实例化String conf = &quot;applicationContext.xml&quot;;ApplicationContext ac = new ClassPathXmlApplicationContext(conf);</code></pre><h3 id="spring-bean定义"><a class="markdownIt-Anchor" href="#spring-bean定义"></a> Spring Bean定义</h3><ul><li><strong>bean对象是构成应用程序的支柱也是由Spring IOC容器管理的，bean是一个被实例化，组装，并通过Spring IOC容器所管理的对象</strong></li></ul><hr /><ul><li><strong>如何创建一个Bean</strong></li><li><strong>bean的生命周期</strong></li><li><strong>bean的以来关系</strong></li></ul><h4 id="bean属性"><a class="markdownIt-Anchor" href="#bean属性"></a> bean属性</h4><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><strong>id</strong></td><td>id标签是bean的唯一标识，IoC容器中bean的id标签不能重复，否则报错。</td></tr><tr><td><strong>class</strong></td><td>强制的，用来指定创建bean的类路径</td></tr><tr><td><strong>scope</strong></td><td>指定由特定的bean定义创建的对象的作用域</td></tr><tr><td><strong>autowire</strong></td><td>autowire表示bean的自动装配</td></tr><tr><td>factory-method</td><td>factory-method工厂方法属性，通过该属性，我们可以调用一个指定的静态工厂方法，创建bean实例</td></tr><tr><td>factory-bean</td><td>顾名思义，factory-bean就是生成bean的工厂对象，factory-bean属性和factory-method属性一起使用，首先要创建生成bean的工厂类和方法</td></tr><tr><td>init-method</td><td>bean的初始方法，在创建好bean后调用该方法</td></tr><tr><td>destory-method</td><td>是bean的销毁方法，在销毁bean之前调用该方法，一般在该方法中释放资源</td></tr><tr><td>name</td><td>唯一的bean标识符,与id等义</td></tr></tbody></table><h4 id="bean和spring容器的关系"><a class="markdownIt-Anchor" href="#bean和spring容器的关系"></a> Bean和spring容器的关系</h4><h3 id="如何创建对象"><a class="markdownIt-Anchor" href="#如何创建对象"></a> 如何创建对象</h3><h4 id="bean标签详解"><a class="markdownIt-Anchor" href="#bean标签详解"></a> bean标签详解</h4><p><strong>bean标签的作用</strong></p><ul><li>用于配置对象让spring来创建的</li><li>默认情况下它调用的是类中的无参构造器，如果没有无参构造函数，则不能创建成功</li></ul><p><strong>bean标签属性</strong></p><ul><li><strong>id</strong>：给对象在容器中提供一个<strong>唯一标识</strong>，用于获取对象</li><li><strong>class</strong>：指定类的全限定名，用于反射出啊关键对象，默认情况下调用<strong>无参构造函数</strong></li><li><strong>scope</strong>：指定对象的作用范围<ul><li>singleton：默认值，单例的（在整个容器中只有一个对象）</li><li>prototype：多例的</li><li>request：web项目中，spring创建一个bean对象，将对象存入到request域中</li><li>session：web项目中，spring创建一个bean对象，将对象存入到session域中</li><li>global session：web项目中，应用在Portlet环境，如果没有Portlet环境那么globalSession相当于session</li></ul></li><li>init-method：指定类中的初始化方法名称</li><li>destroy-method：指定类中销毁方法名称，比如DataSource的配置中一般需要指定destroy-method=“close”</li></ul><p><strong>bean的作用范围：</strong></p><ul><li>单例对象：scope=“singleton”<ul><li>一个应用只有一个对象的实例。它的作用范围就是整个引用。</li><li>生命周期：<ul><li>对象出生：当应用加载，创建容器时，对象就被创建了。</li><li>对象活着：只要容器在，对象一直活着。</li><li>对象死亡：当应用卸载，销毁容器时，对象就被销毁了。</li></ul></li></ul></li><li>多例对象：scope=“prototype”<ul><li>每次访问对象时，都会重新创建对象实例。</li><li>生命周期：<ul><li>对象出生：当使用对象时，创建新的对象实例。</li><li>对象活着：只要对象在使用中，就一直活着。</li><li>对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了。</li></ul></li></ul></li></ul><h4 id="实例化bean的三种方式"><a class="markdownIt-Anchor" href="#实例化bean的三种方式"></a> 实例化bean的三种方式</h4><ul><li><strong>方式1 使用无参构造器（重点）</strong></li></ul><ol><li>给类添加无参构造器（或者缺省构造器）<ul><li>在默认情况下：他会根据默认无参构造函数来创建类对象</li><li>如果bean中没有默认无参构造函数，将会创建失败</li><li><code>&lt;bean /&gt;</code><ul><li>id：给对象在容器中提供一个唯一标识。用于获取对象</li><li>class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数</li></ul></li></ul></li></ol><blockquote><p>如果我们没有创建构造器，系统会为我们自动创建一个无参构造器，如果我们创建了构造器，那么系统将不会为我们创建无参构造器</p></blockquote><pre><code class="highlight plaintext">package com.lee.first;public class Student &#123;       public Student()&#123;             System.out.println(&quot;Student()&quot;);       &#125;&#125;</code></pre><ol><li>使用<bean>元素<ul><li>①xmlns=“<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>”，默认命名空间：它没有空间名，用于Spring Bean的定义；</li><li>②xmlns:xsi=“<a href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>”，xsi命名空间：这个命名空间用于为每个文档中命名空间指定相应的Schema样式文件，是标准组织定义的标准命名空间</li></ul></li></ol><pre><code class="highlight plaintext">applicationContet.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;       &lt;!--IoC XML配置方式管理bean--&gt;        &lt;!--使用无参构造器创建属性--&gt;        &lt;!-- id属性：整个spring容器中要求唯一 --&gt;            &lt;!--class属性：类的全限定名（要求包含包名）,容器会自动调用无参构造器创建对象--&gt;       &lt;bean id=&quot;stu1&quot; class=&quot;com.lee.first.Student&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;date1&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><ol><li>调用容器的getBean方法来获得对象</li></ol><pre><code class="highlight plaintext">@Testpublic void test1&#123;    //创建spring容器     ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);     //从容器中获取Bean实例     //方式一：根据类型从容器中获取Bean实例     Student stu = ac.getBean(Student.class);     //方式二：根据bean的id从容器中获取bean实例     Student stu = (Student)ac.getBean(&quot;stu1&quot;);     System.out.println(stu);   &#125;</code></pre><ul><li><strong>方式2 使用静态工厂方法（了解）</strong><ol><li>通过调用类的静态方法来创建对象</li></ol></li><li><code>&lt;bean factory-method=&quot;&quot;/&gt;</code><ul><li>id属性用于指定 bean名称</li><li>class属性用于指定工厂类型</li><li>factory-method属性用于指定工厂中创建bean对象的方法，必须用static修饰的方法</li></ul></li></ul><pre><code class="highlight plaintext"> applicationContet.xml&lt;!--    使用静态工厂方法创建对象    factory-method属性：指定一个   静态方法   spring容器会调用这个静态方法来创建对象   当使用getBean方法调用cal1时，返回的是Calendar类中getInstance方法的返回值       --&gt;       &lt;bean id=&quot;cal1&quot; class=&quot;java.util.Calendar&quot; factory-method=&quot;getInstance&quot;&gt;&lt;/bean&gt;</code></pre><ul><li><strong>方式3 使用实例工厂方法来创建对象（了解）</strong><ol><li>通过调用对象的实例方法来创建对象</li></ol></li></ul><pre><code class="highlight plaintext"> applicationContet.xml       &lt;!--     使用实例工厂方法创建对象    factory-bean属性：指定一个bean的id    factory-method属性：指定一个方法    spring容器会调用这个bean的对应的方法来创建对象    表示调用id为cal1的类的getTime方法        --&gt;&lt;bean id=&quot;time1&quot; factory-bean=&quot;cal1&quot; factory-method=&quot;getTime&quot;&gt;&lt;/bean&gt;</code></pre><blockquote><p><strong>Bean的别名</strong></p><p>为已经定义好的Bena，再增加另外一个名字引用</p><p><code>&lt;alias name=&quot;fromName&quot; alias=&quot;toName&quot;/&gt;</code></p></blockquote><h4 id="spring-原理"><a class="markdownIt-Anchor" href="#spring-原理"></a> spring 原理</h4><ol><li>spring框架启动时<code>ApplicationContext ac = new ClassPathXmlApplicationContext(conf);</code>，会加载核心配置文件，实际就是通过xml解析器解析配置文件中的xml属性</li><li>然后用每个<bean>标签中的classpath通过<code>class.forName(classpath)</code>获取Class对象，然后<code>clazz.newInstance()</code>创建出实例对象，把该bean的id和实际对象存入Map中</li><li>每当<code>factory.getBean(beanId);</code>时，就通过Map键值取得value值返回</li></ol><pre><code class="highlight plaintext">public class BeanDefined &#123;private String beanId;private String classPath;public String getBeanId() &#123;return beanId;&#125;public void setBeanId(String beanId) &#123;this.beanId = beanId;&#125;public String getClassPath() &#123;return classPath;&#125;public void setClassPath(String classPath) &#123;this.classPath = classPath;&#125;&#125;</code></pre><p>模拟spring工厂的getBean方法，初始版</p><pre><code class="highlight plaintext">import java.util.List;public class BeanFactory &#123;   private List&lt;BeanDefined&gt; beanDefinedList;public List&lt;BeanDefined&gt; getBeanDefinedList() &#123;return beanDefinedList;&#125;public void setBeanDefinedList(List&lt;BeanDefined&gt; beanDefinedList) &#123;this.beanDefinedList = beanDefinedList;&#125;public Object getBean(String beanId) throws Exception&#123;   Object instance;   for(BeanDefined beanObj:beanDefinedList)&#123;     if(beanId.equals(beanObj.getBeanId()))&#123;     String classPath = beanObj.getClassPath();      Class classFile= Class.forName(classPath); //在默认情况下，Spring工厂是通过调用当前类默认工作方法创建实例对象 instance= classFile.newInstance(); return instance;     &#125;   &#125;   return null;&#125;&#125;</code></pre><p><strong>测试使用</strong></p><pre><code class="highlight plaintext">public class TestMain &#123;public static void main(String[] args) throws Exception &#123;  //1.声明注册bean  BeanDefined beanObj = new BeanDefined();  beanObj.setBeanId(&quot;teacher&quot;);  beanObj.setClassPath(&quot;com.kaikeba.beans.Teacher&quot;);    List beanList = new ArrayList();  beanList.add(beanObj);//spring核心配置    //2.声明一个Spring提供BeanFacotory  BeanFactory factory = new BeanFactory();  factory.setBeanDefinedList(beanList);    //3.开发人员向BeanFactory索要实例对象.  Teacher t= (Teacher) factory.getBean(&quot;teacher&quot;);  System.out.println(t);&#125;&#125;</code></pre><h3 id="作用域scope"><a class="markdownIt-Anchor" href="#作用域scope"></a> 作用域（scope）</h3><ul><li>默认情况下，容器对于某个bean，只会创建一个实例</li><li>Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是<strong>Spring中的缺省作用域</strong></li><li>Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们<code>getBean(beanId)</code>获取bean的时候才会去创建一个对象，而且我们<strong>每次获取到的对象都不是同一个对象</strong>。</li></ul><blockquote><p><strong>根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域</strong></p></blockquote><table><thead><tr><th>作用域</th><th>描述</th></tr></thead><tbody><tr><td>singleton</td><td>在spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，<strong>默认值</strong></td></tr><tr><td>prototype</td><td>每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()</td></tr><tr><td>request</td><td>每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境</td></tr><tr><td>session</td><td>同一个HTTP Session共享一个Bean，不同Session使用不同的Bean，仅适用于WebApplicationContext环境</td></tr><tr><td>global Session</td><td>一般用于Portlet应用环境，该运用域仅适用于WebApplicationContext环境</td></tr></tbody></table><pre><code class="highlight plaintext">      &lt;!--             scope属性：用来配置作用域，缺省值是singleton（单例，即一个bean只创建一个实例）            如果值为prototype（原型，即一个bean会创建多个实例）       --&gt;      &lt;bean id=&quot;s1&quot; class=&quot;scope.ScopeBean&quot; scope=&quot;prototype&quot;/&gt;</code></pre><ul><li>默认情况下，下列代码输出true，当设置完scope属性之后，每次getBean都会创建新的对象</li></ul><pre><code class="highlight plaintext">      //测试作用域@Test      public void test1()&#123;            //启动spring容器            ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;scope.xml&quot;);            //获得对象            ScopeBean s1 = ac.getBean(&quot;s1&quot;,ScopeBean.class);            ScopeBean s2 = ac.getBean(&quot;s1&quot;,ScopeBean.class);            System.out.println(s1 == s2);      &#125;</code></pre><h4 id="spring-scope原理"><a class="markdownIt-Anchor" href="#spring-scope原理"></a> spring scope原理</h4><pre><code class="highlight plaintext">public class BeanDefined &#123;private String beanId;private String classPath;private String scope =&quot;singleton&quot;;public String getScope() &#123;return scope;&#125;public void setScope(String scope) &#123;this.scope = scope;&#125;public String getBeanId() &#123;return beanId;&#125;public void setBeanId(String beanId) &#123;this.beanId = beanId;&#125;public String getClassPath() &#123;return classPath;&#125;public void setClassPath(String classPath) &#123;this.classPath = classPath;&#125;&#125;</code></pre><pre><code class="highlight plaintext">import java.util.HashMap;import java.util.List;import java.util.Map;public class BeanFactory &#123;   private List&lt;BeanDefined&gt; beanDefinedList;   private Map&lt;String ,Object&gt; SpringIoc;//已经创建好实例对象public BeanFactory(List&lt;BeanDefined&gt; beanDefinedList) throws Exception &#123;this.beanDefinedList = beanDefinedList;SpringIoc  = new HashMap(); //所有scope=&quot;singleton&quot; 采用单类模式管理bean对象for(BeanDefined beanObj:this.beanDefinedList)&#123;if(&quot;singleton&quot;.equals(beanObj.getScope()))&#123;Class classFile= Class.forName(beanObj.getClassPath());Object instance= classFile.newInstance();SpringIoc.put(beanObj.getBeanId(), instance);&#125;&#125;&#125;public List&lt;BeanDefined&gt; getBeanDefinedList() &#123;return beanDefinedList;&#125;public void setBeanDefinedList(List&lt;BeanDefined&gt; beanDefinedList) &#123;this.beanDefinedList = beanDefinedList;&#125;public Object getBean(String beanId) throws Exception&#123;   Object instance = null;   for(BeanDefined beanObj:beanDefinedList)&#123;     if(beanId.equals(beanObj.getBeanId()))&#123;     String classPath = beanObj.getClassPath();      Class classFile= Class.forName(classPath); String scope=beanObj.getScope(); if(&quot;prototype&quot;.equals(scope))&#123;//.getBean每次都要返回一个全新实例对象    instance= classFile.newInstance(); &#125;else&#123; instance=SpringIoc.get(beanId); &#125; return instance;     &#125;   &#125;   return null;&#125;   &#125;</code></pre><p><strong>测试使用</strong></p><pre><code class="highlight plaintext">public class TestMain &#123;public static void main(String[] args) throws Exception &#123;  //1.声明注册bean  BeanDefined beanObj = new BeanDefined();  beanObj.setBeanId(&quot;teacher&quot;);  beanObj.setClassPath(&quot;com.kaikeba.beans.Teacher&quot;);  //beanObj.setScope(&quot;prototype&quot;);    List beanList = new ArrayList();  beanList.add(beanObj);//spring核心配置    //2.声明一个Spring提供BeanFacotory  BeanFactory factory = new BeanFactory(beanList);     //3.开发人员向BeanFactory索要实例对象.  Teacher t= (Teacher) factory.getBean(&quot;teacher&quot;);  System.out.println(&quot;t=&quot;+t);  Teacher t2= (Teacher) factory.getBean(&quot;teacher&quot;);  System.out.println(&quot;t2=&quot;+t2);&#125;&#125;</code></pre><h3 id="生命周期-init-methoddestroy-method"><a class="markdownIt-Anchor" href="#生命周期-init-methoddestroy-method"></a> 生命周期 init-method/destroy-method</h3><ul><li>Bean的生命周期为<ul><li>bean的定义-beand的初始化-bean的使用-bean的销毁</li></ul></li><li>初始化方法<ul><li>使用<strong>init-method</strong>属性来指定初始化方法名</li><li>注：spring容器创建对象之后，会立即调用初始化方法</li></ul></li><li>销毁方法<ul><li>使用<strong>destroy-method</strong>属性来指定销毁方法名</li><li>注：spring容器再关闭之前，会先销毁对象，再销毁对象之前，会先调用对象的销毁方法。</li><li>只有作用域为单例时，销毁方法才会执行，当为原型时销毁方法就不会执行。</li></ul></li><li>在顶级的<beans/>元素中的default-init-method属性，可以为容器所有<bean>指定初始化方法，<ul><li><code>&lt;beans default-init-method=&quot;init&quot;&gt;&lt;/beans&gt;</code></li></ul></li><li>在顶级的<beans/>元素总default-destroy-method属性，可以为容器所有<bean>指定销毁方法<ul><li><code>&lt;beans default-destroy-method=&quot;destroy&quot;&gt;&lt;/beans&gt;</code></li></ul></li></ul><pre><code class="highlight plaintext">     &lt;!--             init-method属性：用来指定初始化方法            即spring创建该对象的时候会立即调用init-method属性中标注的方法来完成初始化            destroy-method属性：用来指定销毁方法       --&gt;       &lt;bean id=&quot;mb1&quot; class=&quot;scope.MessageBean&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;/&gt;</code></pre><ul><li>bean类和测试类，配置初始化方法后，创建该对象就会先执行初始化方法，关闭容器时会先执行销毁方法</li></ul><pre><code class="highlight plaintext">package scope;public class MessageBean &#123;      public MessageBean()&#123;            System.out.println(&quot;MessageBean()&quot;);      &#125;      //初始化方法      public void init()&#123;            System.out.println(&quot;init()&quot;);      &#125;      public void sendMsg()&#123;            System.out.println(&quot;sendMsg()&quot;);      &#125;      //销毁方法      public void destroy()&#123;            System.out.println(&quot;destroy()&quot;);      &#125;&#125;      //测试生命周期      @Test      public void test2()&#123;            //启动spring容器            //ApplicationContext:接口（无close方法）            //AbstractApplicationContext:上述接口的子接口（有close方法）            //ClassPathXmlApplicationContext:实现了上述接口            AbstractApplicationContext ac = new ClassPathXmlApplicationContext(&quot;scope.xml&quot;);            //获得对象            MessageBean mb = ac.getBean(&quot;mb1&quot;,MessageBean.class);            mb.sendMsg();            //关闭容器            //容器关闭之前会先执行对象的销毁方法            ac.close();      &#125;输出：MessageBean()init()sendMsg()destroy()</code></pre><h3 id="后置处理器"><a class="markdownIt-Anchor" href="#后置处理器"></a> 后置处理器</h3><h4 id="spring_bean后置处理器"><a class="markdownIt-Anchor" href="#spring_bean后置处理器"></a> Spring_Bean后置处理器</h4><p><strong>只要定义该处理器：</strong></p><p>该处理器不针对与某一个类或者接口，是拦截<strong>所有</strong></p><p>后面初始化所有的bean的时候都会经过该处理器，无论<strong>单例</strong>还是<strong>原型</strong>，<strong>只要创建bean实例就会经过该后置处理器</strong></p><p>所以我们要拦截某个特定的接口时，一定要清晰判断，以放拦截所有报错</p><hr /><ul><li>Bean后置处理器运行在调用初始化方法前后对Bean进行额外的处理</li><li><strong>ApplicationContext</strong>会自动检测由<strong>BeanPostProcessor</strong>接口的实现定义的bean，注册这些bean后置处理器，然后通过在容器中创建bean，在适当的时候调用它</li><li>你可以配置多个 BeanPostProcessor 接口，通过设置 BeanPostProcessor 实现的 Ordered 接口提供的 order 属性来控制这些 BeanPostProcessor 接口的执行顺序。</li><li>BeanPostProcessor 可以对 bean（或对象）实例进行操作，这意味着 Spring IoC 容器实例化一个 bean 实例，然后 BeanPostProcessor 接口进行它们的工作</li></ul><h4 id="基础案例"><a class="markdownIt-Anchor" href="#基础案例"></a> 基础案例</h4><ul><li>HelloWorld.java</li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;public class HelloWorld &#123;   private String message;   public void setMessage(String message)&#123;      this.message  = message;   &#125;   public void getMessage()&#123;      System.out.println(&quot;Your Message : &quot; + message);   &#125;   public void init()&#123;      System.out.println(&quot;Bean is going through init.&quot;);   &#125;   public void destroy()&#123;      System.out.println(&quot;Bean will destroy now.&quot;);   &#125;&#125;</code></pre><ul><li>这是实现BeanPostProcessor非常简单的例子，他在任何bean的初始化的之前和之后输入该Bean的名称，也可以在初始化bean的之前和之后实现更加复杂的逻辑，因为你有两个访问内置bean对象的后置处理程序的方法</li><li>InitHelloWorld.java</li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;import org.springframework.beans.factory.config.BeanPostProcessor;import org.springframework.beans.BeansException;public class InitHelloWorld implements BeanPostProcessor &#123;    //bean表示这个bean本身，beanName表示这个bean的id   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;      System.out.println(&quot;BeforeInitialization : &quot; + beanName);      //这里可以返回bean对象，或者返回它的监控代理对象      return bean;     &#125;   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;      System.out.println(&quot;AfterInitialization : &quot; + beanName);      return bean;  //这里可以返回bean对象，或者返回它的监控代理对象   &#125;&#125;</code></pre><ul><li>MainApp.java</li><li>需要注册一个AbstractApplicationContext类中声明的关闭hook的registerShutdownHook() 方法，它将确保正常关闭，并且调用相关的destroy方法</li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;import org.springframework.context.support.AbstractApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123;   public static void main(String[] args) &#123;      AbstractApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;);      HelloWorld obj = (HelloWorld) context.getBean(&quot;helloWorld&quot;);      obj.getMessage();      context.registerShutdownHook();   &#125;&#125;</code></pre><ul><li>Beans.xml</li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;   &lt;bean id=&quot;helloWorld&quot; class=&quot;com.tutorialspoint.HelloWorld&quot;       init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;       &lt;property name=&quot;message&quot; value=&quot;Hello World!&quot;/&gt;   &lt;/bean&gt;   &lt;bean class=&quot;com.tutorialspoint.InitHelloWorld&quot; /&gt;&lt;/beans&gt;</code></pre><ul><li>输出</li></ul><pre><code class="highlight plaintext">BeforeInitialization : helloWorldBean is going through init.AfterInitialization : helloWorldYour Message : Hello World!Bean will destroy now.</code></pre><h4 id="高级案例"><a class="markdownIt-Anchor" href="#高级案例"></a> 高级案例</h4><p>接口</p><pre><code class="highlight plaintext">public interface BaseService &#123;        public String doSome();&#125;</code></pre><p>接口实现类</p><pre><code class="highlight plaintext">public class ISomeService implements BaseService &#123;public String doSome() &#123;// TODO Auto-generated method stubreturn &quot;Hello mike&quot;;//增强效果，doSome方法返回值都是大写&#125;&#125;</code></pre><p>前后置增强类<strong>BeanPostProcessor</strong></p><ul><li><strong>所有</strong>的bean对象初始化都会经过该后置对象</li><li>我们可以自行定义我们需要拦截的某个接口的实现类或者某个类</li></ul><pre><code class="highlight plaintext">import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;import com.kaikeba.serviceImpl.ISomeService;public class MyBeanPostProcessor implements BeanPostProcessor &#123;public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;System.out.println(&quot;bean对象初始化之前。。。。。&quot;);return bean;//return  bean对象监控代理对象&#125;public Object postProcessAfterInitialization(final Object beanInstance, String beanName) throws BeansException &#123;// 为当前bean对象注册代理监控对象，负责增强bean对象方法能力Class beanClass = beanInstance.getClass();       // if (beanInstance instanceof BaseService) &#123;&#125;  //可以使用该语句拦截某一个接口的所有实现类        //这里只拦截了ISomeService的实例对象if (beanClass == ISomeService.class) &#123;Object proxy = Proxy.newProxyInstance(beanInstance.getClass().getClassLoader(),beanInstance.getClass().getInterfaces(), new InvocationHandler() &#123;/* *  * method:doSome args:doSome执行接受实参 proxy:代理监控对对象 **/public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;System.out.println(&quot;ISomeService doSome 被拦截&quot;);String result = (String) method.invoke(beanInstance, args);// beanInstance.doSomereturn result.toUpperCase();&#125;&#125;);return proxy;&#125;return beanInstance;&#125;&#125;</code></pre><p>注册</p><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;    xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context         http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;         &lt;!-- 注册bean:被监控实现类 --&gt;      &lt;bean id=&quot;isomeService&quot; class=&quot;com.kaikeba.serviceImpl.ISomeService&quot;&gt;&lt;/bean&gt;       &lt;!-- 注册代理实现类 --&gt;      &lt;bean class=&quot;com.kaikeba.util.MyBeanPostProcessor&quot;&gt;&lt;/bean&gt;   &lt;/beans&gt;</code></pre><p>测试</p><pre><code class="highlight plaintext">public class Test &#123;    public static void main(String[] args) &#123;        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;springConfig.xml&quot;);        BaseService baseService = (BaseService) ac.getBean(&quot;isomeservice&quot;);        System.out.println(baseService.doSome());    &#125;&#125;</code></pre><h4 id="后置对象原理"><a class="markdownIt-Anchor" href="#后置对象原理"></a> 后置对象原理</h4><p>后置对象接口</p><pre><code class="highlight plaintext">public interface BeanPostProcessor &#123;default Object postProcessBeforeInitialization(Object bean, String beanName) throws Exception &#123;return bean;&#125;default Object postProcessAfterInitialization(Object bean, String beanName) throws Exception &#123;return bean;&#125;&#125;</code></pre><p>接口实现</p><pre><code class="highlight plaintext">public class MyBeanPostProcessor implements BeanPostProcessor &#123;public Object postProcessBeforeInitialization(Object bean, String beanName) throws Exception &#123;System.out.println(&quot;bean对象初始化之前。。。。。&quot;);return bean;//return  bean对象监控代理对象&#125;public Object postProcessAfterInitialization(final Object beanInstance, String beanName) throws Exception &#123;// 为当前bean对象注册代理监控对象，负责增强bean对象方法能力Class beanClass = beanInstance.getClass();if (beanClass == ISomeService.class) &#123;Object proxy = Proxy.newProxyInstance(beanInstance.getClass().getClassLoader(),beanInstance.getClass().getInterfaces(), new InvocationHandler() &#123;/* *  * method:doSome args:doSome执行接受实参 proxy:代理监控对对象 **/public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;System.out.println(&quot;ISomeService doSome 被拦截&quot;);String result = (String) method.invoke(beanInstance, args);// beanInstance.doSomereturn result.toUpperCase();&#125;&#125;);return proxy;&#125;return beanInstance;&#125;&#125;</code></pre><pre><code class="highlight plaintext">public class BeanDefined &#123;/* *   &lt;bean id  ,class,  scope.factory-bean,factory-method&gt; **/private String beanId;private String classPath;private String scope =&quot;singleton&quot;;private String factoryBean=null;private String factoryMethod=null;public String getFactoryBean() &#123;return factoryBean;&#125;public void setFactoryBean(String factoryBean) &#123;this.factoryBean = factoryBean;&#125;public String getFactoryMethod() &#123;return factoryMethod;&#125;public void setFactoryMethod(String factoryMethod) &#123;this.factoryMethod = factoryMethod;&#125;public String getScope() &#123;return scope;&#125;public void setScope(String scope) &#123;this.scope = scope;&#125;public String getBeanId() &#123;return beanId;&#125;public void setBeanId(String beanId) &#123;this.beanId = beanId;&#125;public String getClassPath() &#123;return classPath;&#125;public void setClassPath(String classPath) &#123;this.classPath = classPath;&#125;&#125;</code></pre><p><strong>spring实现后置对象基本原理</strong></p><pre><code class="highlight plaintext">import java.lang.reflect.Method;import java.util.HashMap;import java.util.List;import java.util.Map;public class BeanFactory &#123;   private List&lt;BeanDefined&gt; beanDefinedList;   private Map&lt;String ,Object&gt; SpringIoc;//已经创建好实例对象   private BeanPostProcessor processorObj;//后置对象   public List&lt;BeanDefined&gt; getBeanDefinedList() &#123;return beanDefinedList;&#125;public BeanFactory(List&lt;BeanDefined&gt; beanDefinedList) throws Exception &#123;this.beanDefinedList = beanDefinedList;SpringIoc  = new HashMap(); //所有scope=&quot;singleton&quot; 采用单类模式管理bean对象for(BeanDefined beanObj:this.beanDefinedList)&#123;if(&quot;singleton&quot;.equals(beanObj.getScope()))&#123;Class classFile= Class.forName(beanObj.getClassPath());Object instance= classFile.newInstance();//判断当前对象是一个bean对象还是后置处理处理对象isProcessor(instance,classFile);SpringIoc.put(beanObj.getBeanId(), instance);&#125;&#125;&#125;    //判断是否是后置对象处理器    private void isProcessor(Object instance,Class classFile)&#123;             Class interfaceArray[] = classFile.getInterfaces();             if(interfaceArray==null)&#123;             return;             &#125;                          for(int i=0;i&lt;interfaceArray.length;i++)&#123;             Class interfaceType = interfaceArray[i];             if(interfaceType == BeanPostProcessor.class)&#123;//证明当前实例对象是后置处理器             this.processorObj = (BeanPostProcessor)instance;             &#125;             &#125;    &#125;public void setBeanDefinedList(List&lt;BeanDefined&gt; beanDefinedList) &#123;this.beanDefinedList = beanDefinedList;&#125;public Object getBean(String beanId) throws Exception&#123;   Object instance = null;   Object proxyObj = null;//当前实例对象的代理监控对象   for(BeanDefined beanObj:beanDefinedList)&#123;     if(beanId.equals(beanObj.getBeanId()))&#123;     String classPath = beanObj.getClassPath();      Class classFile= Class.forName(classPath); String scope=beanObj.getScope(); String factoryBean = beanObj.getFactoryBean(); String factoryMehtod=beanObj.getFactoryMethod(); if(&quot;prototype&quot;.equals(scope))&#123;//.getBean每次都要返回一个全新实例对象    if(factoryBean!=null &amp;&amp; factoryMehtod!=null)&#123;//用户希望使用指定工厂创建实例对象       Object factoryObj=  SpringIoc.get(factoryBean);       Class factoryClass=factoryObj.getClass();       Method methodObj= factoryClass.getDeclaredMethod(factoryMehtod, null);       methodObj.setAccessible(true);       instance= methodObj.invoke(factoryObj, null);  &#125;else&#123;  instance= classFile.newInstance();  &#125; &#125;else&#123; instance=SpringIoc.get(beanId); &#125;  if(this.processorObj!=null)&#123; proxyObj = this.processorObj.postProcessBeforeInitialization(instance, beanId); //实例对象初始化。Spring依赖注入 proxyObj = this.processorObj.postProcessAfterInitialization(instance, beanId); //此时返回proxyObj可能就是原始bean对象，也有可能就是代理对象 return proxyObj; &#125;else&#123; return instance; &#125;      &#125;   &#125;   return null;&#125;   &#125;</code></pre><h3 id="延迟加载lazy-inittrue"><a class="markdownIt-Anchor" href="#延迟加载lazy-inittrue"></a> 延迟加载（lazy-init=“true”）</h3><ul><li>spring容器直接启动时，会读一遍配置文件，会将所有所用域为<strong>单例</strong>的bean创建好，原型的bean（即scope属性值为prototype<br />）会在getBean（）的时候创建</li><li>lazy-init=“true” 时，spring容器对于作用域为单例的bean，就不会再创建相应的实例了</li></ul><pre><code class="highlight plaintext">      &lt;!--             lazy-init属性：指定是否延迟加载，如果值为true,表示延迟加载       --&gt;&lt;bean id=&quot;mb1&quot; class=&quot;scope.MessageBean&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot; lazy-init=&quot;true&quot;/&gt;</code></pre><h3 id="spring-bean定义继承parent"><a class="markdownIt-Anchor" href="#spring-bean定义继承parent"></a> Spring Bean定义继承（parent）</h3><ul><li>Spring Bean 定义的继承与 Java 类的继承无关，但是继承的概念是一样的。你可以定义一个父 bean 的定义作为模板和其他子 bean 就可以从父 bean 中继承所需的配置</li><li>使用<strong>parent</strong>属性定义自己的父亲，子bean继承了message2属性，重写message1属性，引入一个属性message3</li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;   &lt;bean id=&quot;helloWorld&quot; class=&quot;com.tutorialspoint.HelloWorld&quot;&gt;      &lt;property name=&quot;message1&quot; value=&quot;Hello World!&quot;/&gt;      &lt;property name=&quot;message2&quot; value=&quot;Hello Second World!&quot;/&gt;   &lt;/bean&gt;   &lt;bean id=&quot;helloIndia&quot; class=&quot;com.tutorialspoint.HelloIndia&quot; parent=&quot;helloWorld&quot;&gt;      &lt;property name=&quot;message1&quot; value=&quot;Hello India!&quot;/&gt;      &lt;property name=&quot;message3&quot; value=&quot;Namaste India!&quot;/&gt;   &lt;/bean&gt;&lt;/beans&gt;</code></pre><h4 id="bean定义模板abstracttrue"><a class="markdownIt-Anchor" href="#bean定义模板abstracttrue"></a> Bean定义模板（abstract=“true”）</h4><ul><li>创建一个Bean定义模板，让其他bean定义使用，指定模板时，不应该指定类的属性，指定<code>abstract=&quot;true&quot;</code></li><li>抽象的父亲并不等被实例化</li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;   &lt;bean id=&quot;beanTeamplate&quot; abstract=&quot;true&quot;&gt;      &lt;property name=&quot;message1&quot; value=&quot;Hello World!&quot;/&gt;      &lt;property name=&quot;message2&quot; value=&quot;Hello Second World!&quot;/&gt;      &lt;property name=&quot;message3&quot; value=&quot;Namaste India!&quot;/&gt;   &lt;/bean&gt;   &lt;bean id=&quot;helloIndia&quot; class=&quot;com.tutorialspoint.HelloIndia&quot; parent=&quot;beanTeamplate&quot;&gt;      &lt;property name=&quot;message1&quot; value=&quot;Hello India!&quot;/&gt;      &lt;property name=&quot;message3&quot; value=&quot;Namaste India!&quot;/&gt;   &lt;/bean&gt;&lt;/beans&gt;</code></pre><h3 id="spring-bean依赖关系"><a class="markdownIt-Anchor" href="#spring-bean依赖关系"></a> Spring bean依赖关系</h3><ul><li>当一个bean对另一个bean存在依赖关系，可以利用<bean>元素的<strong>depends-on</strong>属性指定</li><li><strong>1 depends-on用来表示一个bean A的实例化依靠另一个bean B的实例化， 但是A并不需要持有一个B的对象，如果需要的话就不用depends-on，直接用set依赖注入就可以了</strong></li></ul><pre><code class="highlight plaintext">&lt;bean id=&quot;beanOne&quot; class=&quot;ExampleBean&quot; depends-on=&quot;manager&quot;/&gt;&lt;bean id=&quot;manager&quot; class=&quot;ManagerBean&quot;/&gt;多个依赖关系时，用逗号隔开</code></pre><ul><li><strong>2 如果A既依赖于B，而A又需要持有B的实例，那么使用构造器注入就可以了</strong></li><li><strong>3 同样是如果A既依赖于B，而A又需要持有B的实例，那么也可以使用setter方式注入</strong></li><li><strong>4 如果A不依赖于B，但是需要B的实例，单单使用setter就好了</strong></li></ul><h3 id="动态工厂dynamicfactory"><a class="markdownIt-Anchor" href="#动态工厂dynamicfactory"></a> 动态工厂DynamicFactory</h3><p>动态工厂就是配置我们自己的bean对象创建工厂，不使用spring的工厂逻辑</p><p>适用场合：在不同的环境下需要不同的bean创建方式</p><p><strong>定义一个基础的bean</strong></p><pre><code class="highlight plaintext">public class Teacher &#123;       private String tname;public String getTname() &#123;return tname;&#125;public void setTname(String tname) &#123;this.tname = tname;&#125;   &#125;</code></pre><p><strong>bean创建工厂1</strong></p><pre><code class="highlight plaintext">import com.kaikeba.beans.Teacher;public class TeacherFactory &#123;  public Teacher createTeacher()&#123;      Teacher teacher =    new Teacher();      System.out.println(&quot;TeacherFactory 负责创建 teacher类实例对象..&quot;);      return teacher;  &#125;&#125;</code></pre><p><strong>bean创建工厂2</strong></p><pre><code class="highlight plaintext">import com.kaikeba.beans.Teacher;public class TeacherFactory2 &#123; public Teacher createTeacher()&#123;      Teacher teacher =    new Teacher();      teacher.setTname(&quot;Mr&quot;);      System.out.println(&quot;TeacherFactory 负责创建 teacher类实例对象..&quot;);      return teacher; &#125;&#125;</code></pre><p><strong>动态工厂的注册方式</strong></p><p>注册好后，teacher类的创建方式就不是由spring的规则来创建，就是使用我们自己定义的teacherFactory来创建，如果像更换创建方式，也不用重新编译，可以直接修改该文件即可</p><pre><code class="highlight plaintext"> &lt;!-- 注册工厂 --&gt; &lt;bean id=&quot;factory1&quot; class=&quot;com.kaikeba.util.TeacherFactory&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;factory2&quot; class=&quot;com.kaikeba.util.TeacherFactory2&quot;&gt;&lt;/bean&gt;&lt;!--       Spring容器，当前teacher类的实例化操作，由动态工厂进行创建，此时scope属性依然有效，为单例就只调用一次创建工厂，在初始化时调用；为原型时，每次getBean时都会调用一次创建工厂创建一个对象 --&gt; &lt;bean id=&quot;teacher&quot;       class=&quot;com.kaikeba.beans.Teacher&quot; scope=&quot;singleton&quot; factory-bean=&quot;factory2&quot; factory-method=&quot;createTeacher&quot;&gt;       &lt;/bean&gt;</code></pre><blockquote><p><strong>此种方式如果用户访问量过大，会造成大量的资源消耗</strong></p></blockquote><h4 id="spring动态工厂原理"><a class="markdownIt-Anchor" href="#spring动态工厂原理"></a> Spring动态工厂原理</h4><pre><code class="highlight plaintext">public class Teacher &#123;    private String tname;public String getTname() &#123;return tname;&#125;public void setTname(String tname) &#123;this.tname = tname;&#125; &#125;</code></pre><pre><code class="highlight plaintext">public class TeacherFactory &#123;  public Teacher createTeacher()&#123;      Teacher teacher =    new Teacher();      System.out.println(&quot;TeacherFactory 负责创建 teacher类实例对象..&quot;);      return teacher;  &#125;&#125;</code></pre><pre><code class="highlight plaintext">public class BeanDefined &#123;/* *   &lt;bean id  ,class,  scope.factory-bean,factory-method&gt; **/private String beanId;private String classPath;private String scope =&quot;singleton&quot;;private String factoryBean=null;private String factoryMethod=null;public String getFactoryBean() &#123;return factoryBean;&#125;public void setFactoryBean(String factoryBean) &#123;this.factoryBean = factoryBean;&#125;public String getFactoryMethod() &#123;return factoryMethod;&#125;public void setFactoryMethod(String factoryMethod) &#123;this.factoryMethod = factoryMethod;&#125;public String getScope() &#123;return scope;&#125;public void setScope(String scope) &#123;this.scope = scope;&#125;public String getBeanId() &#123;return beanId;&#125;public void setBeanId(String beanId) &#123;this.beanId = beanId;&#125;public String getClassPath() &#123;return classPath;&#125;public void setClassPath(String classPath) &#123;this.classPath = classPath;&#125;&#125;</code></pre><pre><code class="highlight plaintext">import java.lang.reflect.Method;import java.util.HashMap;import java.util.List;import java.util.Map;public class BeanFactory &#123;   private List&lt;BeanDefined&gt; beanDefinedList;   private Map&lt;String ,Object&gt; SpringIoc;//已经创建好实例对象   public List&lt;BeanDefined&gt; getBeanDefinedList() &#123;return beanDefinedList;&#125;public BeanFactory(List&lt;BeanDefined&gt; beanDefinedList) throws Exception &#123;this.beanDefinedList = beanDefinedList;SpringIoc  = new HashMap(); //所有scope=&quot;singleton&quot; 采用单类模式管理bean对象(但不包括有创建工厂的bean)for(BeanDefined beanObj:this.beanDefinedList)&#123;if(&quot;singleton&quot;.equals(beanObj.getScope())&amp;&amp;(beanObj.getFactoryBean()==null||beanObj.getFactoryBean()==&quot;&quot;))&#123;Class classFile= Class.forName(beanObj.getClassPath());Object instance= classFile.newInstance();SpringIoc.put(beanObj.getBeanId(), instance);&#125;&#125;//这里单独创建有动态工厂的beanfor(BeanDefined beanObj:this.beanDefinedList)&#123;if(beanObj.getFactoryBean()!=null||beanObj.getFactoryBean()!=&quot;&quot;)&#123;Object factoryObj=  SpringIoc.get(beanObj.getFactoryBean);Class factoryClass=factoryObj.getClass();Method methodObj= factoryClass.getDeclaredMethod(beanObj.getFactoryMehtod, null);methodObj.setAccessible(true);SpringIoc.put(beanObj.getBeanId(), methodObj.invoke(factoryObj, null));&#125;&#125;&#125;public void setBeanDefinedList(List&lt;BeanDefined&gt; beanDefinedList) &#123;this.beanDefinedList = beanDefinedList;&#125;public Object getBean(String beanId) throws Exception&#123;   Object instance = null;   for(BeanDefined beanObj:beanDefinedList)&#123;     if(beanId.equals(beanObj.getBeanId()))&#123;     String classPath = beanObj.getClassPath();      Class classFile= Class.forName(classPath); String scope=beanObj.getScope(); String factoryBean = beanObj.getFactoryBean(); String factoryMehtod=beanObj.getFactoryMethod(); if(&quot;prototype&quot;.equals(scope))&#123;//.getBean每次都要返回一个全新实例对象    if(factoryBean!=null &amp;&amp; factoryMehtod!=null)&#123;//用户希望使用指定工厂创建实例对象       Object factoryObj=  SpringIoc.get(factoryBean);       Class factoryClass=factoryObj.getClass();       Method methodObj= factoryClass.getDeclaredMethod(factoryMehtod, null);       methodObj.setAccessible(true);       instance= methodObj.invoke(factoryObj, null);  &#125;else&#123;  instance= classFile.newInstance();  &#125; &#125;else&#123; instance=SpringIoc.get(beanId); &#125; return instance;     &#125;   &#125;   return null;&#125;&#125;</code></pre><p><strong>测试使用</strong></p><pre><code class="highlight plaintext">public class TestMain &#123;public static void main(String[] args) throws Exception &#123;  //1.声明注册bean  BeanDefined beanObj = new BeanDefined();  beanObj.setBeanId(&quot;teacher&quot;);  beanObj.setClassPath(&quot;com.kaikeba.beans.Teacher&quot;);  beanObj.setFactoryBean(&quot;factory1&quot;);  beanObj.setFactoryMethod(&quot;createTeacher&quot;);  beanObj.setScope(&quot;prototype&quot;);    BeanDefined beanObj2 = new BeanDefined();  beanObj2.setBeanId(&quot;factory1&quot;);  beanObj2.setClassPath(&quot;com.kaikeba.beans.TeacherFactory&quot;);    List configuration = new ArrayList();  configuration.add(beanObj);//spring核心配置  configuration.add(beanObj2);    //2.声明一个Spring提供BeanFacotory  BeanFactory factory = new BeanFactory(configuration);   //3.开发人员向BeanFactory索要实例对象.  Teacher t= (Teacher) factory.getBean(&quot;teacher&quot;);  System.out.println(&quot;t=&quot;+t);&#125;&#125;</code></pre><h3 id="静态工厂"><a class="markdownIt-Anchor" href="#静态工厂"></a> 静态工厂</h3><p>静态工厂和动态工厂的使用方法基本相同</p><p><strong>作用</strong>：节省内存的消耗</p><pre><code class="highlight plaintext">public class TeacherFactory &#123; //这里只需要把方法改为静态方法即可    public static Teacher createTeacher()&#123;         Teacher teacher = new Teacher();         System.out.println(&quot;TeacherFactory 负责创建 teacher类实例对象..&quot;);         return teacher;     &#125; &#125;</code></pre><p><strong>配置文件</strong></p><p>只需要把class属性改为创建工厂的类路径即可</p><pre><code class="highlight plaintext">&lt;bean id=&quot;teacher&quot; class=&quot;com.lee.util.TeacherFactory&quot; factory-method=&quot;createTeacher&quot;&gt;&lt;/bean&gt;</code></pre><h2 id="3iocinversion-of-controll-控制反转"><a class="markdownIt-Anchor" href="#3iocinversion-of-controll-控制反转"></a> 3.IOC(Inversion Of Controll 控制反转)</h2><ul><li><p><strong>IOC就是一个生产和管理bean的容器就行了，原来需要在调用类中new的东西，现在都是通过容器生成，同时，要是产生的是单例的bean，他还可以给管理bean的生命周期</strong></p></li><li><p>对象之间的依赖关系由容器来建立（而不是对象自己直接通过new调用或建立关系）</p></li><li><p>IOC实现方法有DI和依赖查找</p></li><li><p><strong>Spring容器采用DI方式</strong></p></li><li><p>IoC是Spring框架的核心内容，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象</p></li></ul><h3 id="ioc实现原理"><a class="markdownIt-Anchor" href="#ioc实现原理"></a> IOC实现原理</h3><ul><li>控制反转也叫依赖注入，IOC利用java反射机制，AOP利用代理模式。所谓控制反转是指，本来被调用者的实例是有调用者来创建的，这样的缺点是耦合性太强，IOC则是统一交给spring来管理创建，将对象交给容器管理，你只需要在spring配置文件总配置相应的bean，以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类</li></ul><h3 id="didependency-injection依赖注入"><a class="markdownIt-Anchor" href="#didependency-injection依赖注入"></a> DI(Dependency Injection)依赖注入</h3><ul><li>容器通过调用对象提供的set方法或者构造器来建立依赖关系</li><li><strong>IOC是目标，DI是手段</strong></li><li>DI主要有两种注入方式，即Setter注入和构造器注入</li></ul><h4 id="di概述"><a class="markdownIt-Anchor" href="#di概述"></a> DI概述</h4><p><strong>什么是依赖？</strong></p><ul><li>依赖指的就是Bean实例中的属性</li><li>属性分为：简单类型（8种基本类型和String类型）的属性、POJO类型的属性、集合数组类型的属性</li></ul><p><strong>什么是依赖注入？</strong></p><ul><li>依赖注入：Dependency Injection。它是 spring 框架核心 ioc 的具体实现</li></ul><p><strong>为什么要进行依赖注入？</strong></p><ul><li>我们的程序在编写时，通过控制反转，把对象的创建交给了 spring，但是代码中不可能出现没有依赖的情况</li><li>ioc 解耦只是降低他们的依赖关系，但不会消除。例如：我们的业务层仍会调用持久层的方法。那这种业务层和持久层的依赖关系，在使用 spring 之后，就让 spring 来维护了</li><li>简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取</li></ul><h4 id="di-依赖注入原理"><a class="markdownIt-Anchor" href="#di-依赖注入原理"></a> DI 依赖注入原理</h4><p><strong>Spring框架通过反射机制，调用属性对应Set方法进行赋值</strong></p><pre><code class="highlight plaintext">import java.util.HashMap;import java.util.Map;public class BeanDefined &#123;/* *  *    *   &lt;bean id  ,class,  scope.factory-bean,factory-method&gt; **/private String beanId;private String classPath;private String scope =&quot;singleton&quot;;private String factoryBean=null;private String factoryMethod=null;private Map&lt;String,String&gt; propertyMap=new HashMap();public Map&lt;String, String&gt; getPropertyMap() &#123;return propertyMap;&#125;public void setPropertyMap(Map&lt;String, String&gt; propertyMap) &#123;this.propertyMap = propertyMap;&#125;public String getFactoryBean() &#123;return factoryBean;&#125;public void setFactoryBean(String factoryBean) &#123;this.factoryBean = factoryBean;&#125;public String getFactoryMethod() &#123;return factoryMethod;&#125;public void setFactoryMethod(String factoryMethod) &#123;this.factoryMethod = factoryMethod;&#125;public String getScope() &#123;return scope;&#125;public void setScope(String scope) &#123;this.scope = scope;&#125;public String getBeanId() &#123;return beanId;&#125;public void setBeanId(String beanId) &#123;this.beanId = beanId;&#125;public String getClassPath() &#123;return classPath;&#125;public void setClassPath(String classPath) &#123;this.classPath = classPath;&#125;&#125;</code></pre><pre><code class="highlight plaintext">import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Set;public class BeanFactory &#123;   private List&lt;BeanDefined&gt; beanDefinedList;   private Map&lt;String ,Object&gt; SpringIoc;//已经创建好实例对象   private BeanPostProcessor processorObj;//后置对象   public List&lt;BeanDefined&gt; getBeanDefinedList() &#123;return beanDefinedList;&#125;//依赖注入public void setValue(Object instance,Class classFile,Map propertyMap) throws NoSuchFieldException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException&#123;     //循环便利  propertyMap&lt;属性名,属性值&gt;      Method methodArray[]= classFile.getDeclaredMethods();     Set fieldNameSet = propertyMap.keySet();     Iterator fieldIterator = fieldNameSet.iterator();     while(fieldIterator.hasNext())&#123;     String fieldName = (String) fieldIterator.next();     String value = (String) propertyMap.get(fieldName);     Field fieldObj = classFile.getDeclaredField(fieldName);//同名属性对象     for(int i=0;i&lt;methodArray.length;i++)&#123;     Method methodObj  = methodArray[i];     String methodName =&quot;set&quot;+fieldName;// sid == setsid     if(methodName.equalsIgnoreCase(methodObj.getName()))&#123;       Class fieldType=   fieldObj.getType();//属性的数据类型 Integer,String,Double,boolean,list           if(fieldType == String.class)&#123;           methodObj.invoke(instance, value);           &#125;else if(fieldType == Integer.class)&#123;           methodObj.invoke(instance, Integer.valueOf(value));           &#125;else if(fieldType == Boolean.class)&#123;           methodObj.invoke(instance, Boolean.valueOf(value));           &#125;else if(fieldType==List.class)&#123;             List tempList = new ArrayList();             String dataArray[]=value.split(&quot;,&quot;);             for(int j=0;j&lt;dataArray.length;j++)&#123;             tempList.add(dataArray[j]);             &#125;             methodObj.invoke(instance, tempList);           &#125;else&#123; //此时属性类型是数组           String dataArray[]=value.split(&quot;,&quot;);           Object data[] = new Object[1];           data[0]=dataArray;           methodObj.invoke(instance, data);           &#125;              break;     &#125;     &#125;     &#125;&#125;public BeanFactory(List&lt;BeanDefined&gt; beanDefinedList) throws Exception &#123;this.beanDefinedList = beanDefinedList;SpringIoc  = new HashMap(); //所有scope=&quot;singleton&quot; 采用单类模式管理bean对象for(BeanDefined beanObj:this.beanDefinedList)&#123;if(&quot;singleton&quot;.equals(beanObj.getScope()))&#123;Class classFile= Class.forName(beanObj.getClassPath());Object instance= classFile.newInstance();//判断当前对象是一个bean对象还是后置处理处理对象isProcessor(instance,classFile);SpringIoc.put(beanObj.getBeanId(), instance);&#125;&#125;&#125;    private void isProcessor(Object instance,Class classFile)&#123;             Class interfaceArray[] = classFile.getInterfaces();             if(interfaceArray==null)&#123;             return;             &#125;                          for(int i=0;i&lt;interfaceArray.length;i++)&#123;             Class interfaceType = interfaceArray[i];             if(interfaceType == BeanPostProcessor.class)&#123;//证明当前实例对象是后置处理器             this.processorObj = (BeanPostProcessor)instance;             &#125;             &#125;    &#125;public void setBeanDefinedList(List&lt;BeanDefined&gt; beanDefinedList) &#123;this.beanDefinedList = beanDefinedList;&#125;public Object getBean(String beanId) throws Exception&#123;   Object instance = null;   Object proxyObj = null;//当前实例对象的代理监控对象   for(BeanDefined beanObj:beanDefinedList)&#123;     if(beanId.equals(beanObj.getBeanId()))&#123;     String classPath = beanObj.getClassPath();      Class classFile= Class.forName(classPath); String scope=beanObj.getScope(); String factoryBean = beanObj.getFactoryBean(); String factoryMehtod=beanObj.getFactoryMethod(); Map propertyMap = beanObj.getPropertyMap(); if(&quot;prototype&quot;.equals(scope))&#123;//.getBean每次都要返回一个全新实例对象    if(factoryBean!=null &amp;&amp; factoryMehtod!=null)&#123;//用户希望使用指定工厂创建实例对象       Object factoryObj=  SpringIoc.get(factoryBean);       Class factoryClass=factoryObj.getClass();       Method methodObj= factoryClass.getDeclaredMethod(factoryMehtod, null);       methodObj.setAccessible(true);       instance= methodObj.invoke(factoryObj, null);  &#125;else&#123;  instance= classFile.newInstance();  &#125; &#125;else&#123; instance=SpringIoc.get(beanId); &#125;  if(this.processorObj!=null)&#123; proxyObj = this.processorObj.postProcessBeforeInitialization(instance, beanId); //实例对象初始化。Spring依赖注入 setValue(instance,classFile,propertyMap); proxyObj = this.processorObj.postProcessAfterInitialization(instance, beanId); //此时返回proxyObj可能就是原始bean对象，也有可能就是代理对象 return proxyObj; &#125;else&#123; //实例对象初始化 setValue(instance,classFile,propertyMap); return instance; &#125;      &#125;   &#125;   return null;&#125;   &#125;</code></pre><h3 id="1set方式注入property"><a class="markdownIt-Anchor" href="#1set方式注入property"></a> 1.Set方式注入（property）</h3><ul><li><p><strong>类中提供相应的set方法</strong></p></li><li><p><strong>在配置<bean>中添加<property>元�</strong>�</p></li><li><p>Spring容器会先将配置文件中的A和B创建好，然后把B对象的引用地址通过A类的setB(B b)方法赋值给A对象的b成员私有变量，实现A类对B类的调用，这种实现方法就叫做依赖注入。</p></li><li><p>从而解决代码之间耦合度太高的问题</p></li><li><p>原来是自己想要什么对象就创建什么对象，耦合度太高，spring就相当于一个公司，我们提出自己的诉求，让spring帮忙找我需要的对象。</p></li></ul><pre><code class="highlight plaintext">      &lt;!--             property元素：表示使用set方法来注入依赖关系            name属性指定属性名（给name大写然后前面加set,即setB(),就是调用A的setB()方法传入id为b1的对象）            ref属性指定属性值（是被注入的bean的id）(传入id为b1的对象)            A和B的先后创建顺序不重要，spring容器会把所有容器创建好之后再处理依赖关系       --&gt;      &lt;bean id=&quot;a1&quot; class=&quot;ioc.A&quot;&gt;            &lt;property name=&quot;b&quot; ref=&quot;b1&quot;&gt;&lt;/property&gt;      &lt;/bean&gt;</code></pre><pre><code class="highlight plaintext">package ioc;public class A &#123;      private B b;      public void setB(B b) &#123;            System.out.println(&quot;setB()&quot;);           this.b = b;      &#125;      public A()&#123;            System.out.println(&quot;A()&quot;);      &#125;      public void execute()&#123;            //new B().f1();  这样写A和B的耦合度太高            System.out.println(&quot;execute()&quot;);            b.f1();      &#125;&#125;package ioc;public class B &#123;      public B()&#123;            System.out.println(&quot;B()&quot;);      &#125;      public void f1()&#123;            System.out.println(&quot;B is f1()&quot;);      &#125;&#125;</code></pre><ul><li>调用测试方法，输出：</li></ul><pre><code class="highlight plaintext">      @Test      //测试set方式的注入      public void test5()&#123;            //启动容器            ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;ioc.xml&quot;);            A a1 = ac.getBean(&quot;a1&quot;,A.class);            a1.execute();      &#125;      输出：B()A()setB()execute()B is f1()</code></pre><ul><li><strong>如果想要新建一个C类让A类调用，而不去修改A类源代码，解决办法</strong></li><li>创建一个接口，让B和C都去实现它，然后再A的代码也改为接口就可以实现直接修改xml文件而更改A类所调用的方法的类。</li></ul><pre><code class="highlight plaintext">package ioc;public interface IB &#123;      public void f1();&#125;package ioc;public class B implements IB&#123;      public B()&#123;            System.out.println(&quot;B()&quot;);      &#125;            public void f1()&#123;            System.out.println(&quot;B is f1()&quot;);      &#125;&#125;package ioc;public class C implements IB&#123;      public C()&#123;            System.out.println(&quot;C()&quot;);      &#125;      public void f1()&#123;            System.out.println(&quot;C is f1()&quot;);      &#125;&#125;package ioc;public class A &#123;      private IB b;  //这里修改为IB接口      public void setB(IB b) &#123;            System.out.println(&quot;setB()&quot;);            this.b = b;      &#125;      public A()&#123;            System.out.println(&quot;A()&quot;);       &#125;         public void execute()&#123;            //new B().f1();  这样写A和B的耦合度太高            System.out.println(&quot;execute()&quot;);            b.f1();      &#125;&#125;</code></pre><ul><li>修改为接口的形式后，要想修改A类注入的其他类，直接修改ref的值即可</li></ul><pre><code class="highlight plaintext">&lt;bean id=&quot;a1&quot; class=&quot;ioc.A&quot;&gt;            &lt;property name=&quot;b&quot; ref=&quot;c1&quot;&gt;&lt;/property&gt;      &lt;/bean&gt;</code></pre><h4 id="使用p名称空间注入数据"><a class="markdownIt-Anchor" href="#使用p名称空间注入数据"></a> 使用p名称空间注入数据</h4><p>如果你有许多的设值函数方法，那么在 XML 配置文件中使用 p-namespace 是非常方便的</p><ul><li>首先子schema的名称空间中加入该行：<code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code></li><li>使用p名称空间的语法<ul><li><code>p:属性名=&quot;&quot;</code></li><li><code>p:属性名-ref=&quot;&quot;</code></li></ul></li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;   &lt;bean id=&quot;john-classic&quot; class=&quot;com.example.Person&quot;&gt;      &lt;property name=&quot;name&quot; value=&quot;John Doe&quot;/&gt;      &lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;   &lt;/bean&gt;   &lt;bean name=&quot;jane&quot; class=&quot;com.example.Person&quot;&gt;      &lt;property name=&quot;name&quot; value=&quot;John Doe&quot;/&gt;   &lt;/bean&gt;&lt;/beans&gt;简写后-------------------------------------------------------------------&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;   &lt;bean id=&quot;john-classic&quot; class=&quot;com.example.Person&quot;      p:name=&quot;John Doe&quot;      p:spouse-ref=&quot;jane&quot;/&gt;   &lt;/bean&gt;   &lt;bean name=&quot;jane&quot; class=&quot;com.example.Person&quot;      p:name=&quot;John Doe&quot;/&gt;   &lt;/bean&gt;&lt;/beans&gt;</code></pre><h4 id="spring注入内部beans"><a class="markdownIt-Anchor" href="#spring注入内部beans"></a> Spring注入内部Beans</h4><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;   &lt;bean id=&quot;outerBean&quot; class=&quot;...&quot;&gt;      &lt;property name=&quot;target&quot;&gt;         &lt;bean id=&quot;innerBean&quot; class=&quot;...&quot;/&gt;      &lt;/property&gt;   &lt;/bean&gt;&lt;/beans&gt;</code></pre><h3 id="2构造器方式注入"><a class="markdownIt-Anchor" href="#2构造器方式注入"></a> 2构造器方式注入</h3><ul><li><p><strong>1.添加相应的构造器</strong></p></li><li><p><strong>2.配置constructor-arg元�</strong>�</p><ul><li><code>index</code>：指定参数在构造函数参数列表的索引位置</li><li><code>name</code>：指定参数在构造函数的名称</li><li><code>value</code>：它能给基本数据类型和String类型赋值</li><li><code>ref</code>：他能赋值引用类型</li></ul></li><li><p>当构造器有多个值时，可以使用index参数配置参数的位置</p></li><li><p>如果要把一个引用传递给一个对象，需要使用标签的<strong>ref</strong>属性；如果要直接传递一个值，应该使用<strong>value</strong>属性</p></li><li><p>配置xml</p></li></ul><pre><code class="highlight plaintext">      &lt;bean id=&quot;b1&quot; class=&quot;ioc2.B&quot;&gt;&lt;/bean&gt;      &lt;!--              构造器方式注入            constructor-arg元素：用来配置构造器方式的注入，其中，            index属性指定参数的下标（从0开始）       --&gt;      &lt;bean id=&quot;a1&quot; class=&quot;ioc2.A&quot;&gt;            &lt;constructor-arg index=&quot;0&quot; ref=&quot;b1&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/constructor-arg&gt;            &lt;constructor-arg name=&quot;name&quot; value=&quot;zhangsan&quot;&gt;&lt;/constructor-arg&gt;      &lt;/bean&gt;</code></pre><pre><code class="highlight plaintext">package ioc2;public class A &#123;      private B b;      public A()&#123;            System.out.println(&quot;A()&quot;);      &#125;       //构造器传入      public A(B b)&#123;            this.b = b;            System.out.println(&quot;A(b)&quot;);      &#125;      public void execute()&#123;            System.out.println(&quot;execute()&quot;);            b.f1();      &#125;&#125;package ioc2;public class B &#123;      public B()&#123;            System.out.println(&quot;B()&quot;);      &#125;      public void f1()&#123;            System.out.println(&quot;B is f1()&quot;);      &#125;&#125;</code></pre><ul><li>测试输出</li></ul><pre><code class="highlight plaintext">public class TestCase2 &#123;      @Test      public void test()&#123;            ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;ioc2.xml&quot;);            A a = ac.getBean(&quot;a1&quot;,A.class);            a.execute();      &#125;      输出：B()A(b)execute()B is f1()</code></pre><h3 id="3自动装配了解"><a class="markdownIt-Anchor" href="#3自动装配了解"></a> 3自动装配（了解）</h3><ul><li>容器依据某种规则，自动建立对象之间的依赖关系</li><li>默认情况下，容器不会自动装配</li><li>可以通过指定autowire属性来告诉容器进行自动装配（容器仍然需要通过调用set方法或者构造器来完成关系的建立）<ul><li><strong>byName</strong>：private Waiter wt;根据wt来找相同的id对象注入到setWt()方法中</li><li><strong>byType</strong>：private Waiter wt;根据Waiter属性来找相同的class对应的对象注入到setWaiter()方法中</li><li><s><strong>constructor</strong></s>：与byType的方式类似，不同之处在于它应用于构造器参数</li></ul></li></ul><pre><code class="highlight plaintext">&lt;!--             autowire属性：表示让容器自动装配            如果值为：            byName:容器依据属性名(成员变量名)查找(id)对应的bean,然后调用对应的（set加属性名大写）方法来完成注入                        注意：如果找不到对应的bean,注入null.不可能找到多个符合条件的bean，因为id唯一            byType:容器依据属性的类型查找对应的属性（class）相同的bean,然后调用对应的set方法来完成注入。                        注意：找不到对应的bean,注入null,找到多个就会报错。            constructor:与byType类似，不同的是调用对应的构造器来完成注入。       --&gt;       &lt;bean id=&quot;wt&quot; class=&quot;ioc2.Waiter&quot;/&gt;      &lt;bean id=&quot;rest&quot; class=&quot;ioc2.Restaurant&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;</code></pre><pre><code class="highlight plaintext">package ioc2;public class Restaurant &#123;      private Waiter wt;         public Restaurant()&#123;            System.out.println(&quot;Restaurant()&quot;);      &#125;            public void setWt(Waiter wt)&#123;            this.wt = wt;            System.out.println(&quot;setWt()&quot;);      &#125;      public String toString()&#123;            return &quot;Restaurant [wt=&quot;+wt+&quot;]&quot;;      &#125;&#125;package ioc2;public class Waiter &#123;      public Waiter()&#123;            System.out.println(&quot;waiter&quot;);      &#125;&#125;      @Test      //测试自动装配      public void test2()&#123;            ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;ioc2.xml&quot;);            Restaurant rest = ac.getBean(&quot;rest&quot;,Restaurant.class);            System.out.println(rest);      &#125;输出：waiterRestaurant()setWt()Restaurant [wt=ioc2.Waiter@1877ab81]</code></pre><h3 id="4-注入基本集合类型的值"><a class="markdownIt-Anchor" href="#4-注入基本集合类型的值"></a> 4 注入基本/集合类型的值</h3><ul><li>注入基本类型的值：使用value属性/标签即可，容器将字符串从java.lang.String类型转化为实际的属性或参数类型后给Bean对象注入</li><li>如果集合内是简单类型，使用value子标签，如果是POJO(引用)类型，则使用bean标签</li></ul><p>List Set Map Properties</p><ul><li>代码如下</li></ul><pre><code class="highlight plaintext">      &lt;bean id=&quot;vb1&quot; class=&quot;value.ValueBean&quot;&gt;&lt;!-- 上下两种写法都可以 --&gt;            &lt;property name=&quot;name&quot; value=&quot;胡八一&quot;&gt;&lt;/property&gt;      &lt;property name=&quot;age&quot;&gt;&lt;value&gt;30&lt;/value&gt;&lt;/property&gt;            &lt;!--两种方式都可以--&gt;      &lt;property name=&quot;otherName&quot; value=&quot;张三,李四,王五&quot;&gt;&lt;/property&gt;      &lt;property name=&quot;otherName&quot;&gt;                  &lt;array&gt;                       &lt;value&gt;张三&lt;/value&gt;                        &lt;value&gt;李四&lt;/value&gt;                        &lt;bean&gt;&lt;/bean&gt;                  &lt;/arrya&gt;            &lt;/property&gt;                  &lt;property name=&quot;city&quot;&gt;                  &lt;list&gt;                       &lt;value&gt;北京&lt;/value&gt;                        &lt;value&gt;上海&lt;/value&gt;                        &lt;value&gt;广州&lt;/value&gt;                  &lt;/list&gt;            &lt;/property&gt;                  &lt;property name=&quot;interest&quot;&gt;                  &lt;set&gt;                        &lt;value&gt;盗墓&lt;/value&gt;                       &lt;value&gt;战斗&lt;/value&gt;                        &lt;value&gt;喝酒&lt;/value&gt;                  &lt;/set&gt;            &lt;/property&gt;                  &lt;property name=&quot;score&quot;&gt;                  &lt;map&gt;                        &lt;entry key=&quot;english&quot; value=&quot;60&quot;&gt;&lt;/entry&gt;                        &lt;entry key=&quot;math&quot; value=&quot;66&quot;&gt;&lt;/entry&gt;                  &lt;/map&gt;            &lt;/property&gt;                  &lt;property name=&quot;db&quot;&gt;                  &lt;props&gt;                        &lt;prop key=&quot;username&quot;&gt;Tiger&lt;/prop&gt;                        &lt;prop key=&quot;password&quot;&gt;1234&lt;/prop&gt;                  &lt;/props&gt;            &lt;/property&gt;      &lt;/bean&gt;</code></pre><pre><code class="highlight plaintext">package value;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;public class ValueBean &#123;private String name;private int age;    private String[] otherName;private List&lt;String&gt; city;private Set&lt;String&gt; interest;private Map&lt;String,Double&gt; score;private Properties db;    public ValueBean()&#123;System.out.println(&quot;ValueBean()&quot;);&#125;public void setName(String name) &#123;this.name = name;&#125;public void setAge(int age) &#123;this.age = age;&#125;public void setCity(List&lt;String&gt; city) &#123;this.city = city;&#125;public void setInterest(Set&lt;String&gt; interest) &#123;this.interest = interest;&#125;public void setScore(Map&lt;String, Double&gt; score) &#123;this.score = score;&#125;public void setDb(Properties db) &#123;this.db = db;&#125;@Overridepublic String toString() &#123;return &quot;ValueBean [name=&quot; + name + &quot;, age=&quot; + age + &quot;, city=&quot; + city + &quot;, interest=&quot; + interest + &quot;, score=&quot;+ score + &quot;, db=&quot; + db + &quot;]&quot;;&#125;&#125;      @Test      public void test3()&#123;            ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;value.xml&quot;);            ValueBean vb = ac.getBean(&quot;vb1&quot;,ValueBean.class);            System.out.println(vb);      &#125;输出:ValueBean()ValueBean [name=胡八一, age=30, city=[北京, 上海, 广州], interest=[盗墓, 战斗, 喝酒], score=&#123;english=60.0, math=66.0&#125;, db=&#123;password=1234, username=Tiger&#125;]</code></pre><h3 id="5-引用的方式注入集合类型的值"><a class="markdownIt-Anchor" href="#5-引用的方式注入集合类型的值"></a> 5 引用的方式注入集合类型的值</h3><pre><code class="highlight plaintext">&lt;!--             util表示命名空间            将集合类型的值配置为一个bean,       --&gt;      &lt;util:list id=&quot;cityBean&quot;&gt;            &lt;value&gt;上海&lt;/value&gt;            &lt;value&gt;深圳&lt;/value&gt;            &lt;value&gt;武汉&lt;/value&gt;      &lt;/util:list&gt;      &lt;util:set id=&quot;interestBean&quot;&gt;            &lt;value&gt;书法&lt;/value&gt;            &lt;value&gt;绘画&lt;/value&gt;            &lt;value&gt;拳击&lt;/value&gt;      &lt;/util:set&gt;      &lt;util:map id=&quot;scoreBean&quot;&gt;            &lt;entry key=&quot;english&quot; value=&quot;80&quot;&gt;&lt;/entry&gt;            &lt;entry key=&quot;math&quot; value=&quot;99&quot;&gt;&lt;/entry&gt;      &lt;/util:map&gt;      &lt;util:properties id=&quot;dbBean&quot;&gt;            &lt;prop key=&quot;username&quot;&gt;Sally&lt;/prop&gt;            &lt;prop key=&quot;password&quot;&gt;1234&lt;/prop&gt;      &lt;/util:properties&gt;      &lt;!-- 引用的方式注入集合类型的值 --&gt;      &lt;bean id=&quot;vb2&quot; class=&quot;value.ValueBean&quot;&gt;            &lt;property name=&quot;city&quot; ref=&quot;cityBean&quot;&gt;&lt;/property&gt;            &lt;property name=&quot;interest&quot; ref=&quot;interestBean&quot;&gt;&lt;/property&gt;            &lt;property name=&quot;score&quot; ref=&quot;scoreBean&quot;&gt;&lt;/property&gt;            &lt;property name=&quot;db&quot; ref=&quot;dbBean&quot;&gt;&lt;/property&gt;      &lt;/bean&gt;</code></pre><h3 id="6-注入空值"><a class="markdownIt-Anchor" href="#6-注入空值"></a> 6 注入空值</h3><ul><li>例子相当于 Java 代码：exampleBean.setEmail(“”)</li></ul><pre><code class="highlight plaintext">&lt;bean id=&quot;...&quot; class=&quot;exampleBean&quot;&gt;   &lt;property name=&quot;email&quot; value=&quot;&quot;/&gt;&lt;/bean&gt;</code></pre><ul><li>例子相当于 Java 代码：exampleBean.setEmail(null)</li></ul><pre><code class="highlight plaintext">&lt;bean id=&quot;...&quot; class=&quot;exampleBean&quot;&gt;   &lt;property name=&quot;email&quot;&gt;&lt;null/&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h3 id="7-读取配置文件properties的值"><a class="markdownIt-Anchor" href="#7-读取配置文件properties的值"></a> 7 读取配置文件properties的值</h3><p>config.properties</p><pre><code class="highlight plaintext">pagesize=10</code></pre><p>value.xml</p><pre><code class="highlight plaintext">location:表示配置文件的路劲&lt;!-- 读取properties文件的内容             classpath:按照类路劲来搜索（实际就是按照resource来找,如果有文件夹，就config/config.properties）             spring容器会根基路径来找到对应的properties文件，然后读取该文件的内容到Properties对象       --&gt;      &lt;util:properties id=&quot;config&quot; location=&quot;classpath:config.properties&quot;&gt;&lt;/util:properties&gt;</code></pre><p>@test</p><pre><code class="highlight plaintext">      @Testpublic class TestCase2 &#123;      //测试 读取properties文件      public void test5()&#123;            ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;value.xml&quot;);            System.out.println(ac.getBean(&quot;config&quot;));      &#125;&#125;</code></pre><h3 id="8-使用spring表达式"><a class="markdownIt-Anchor" href="#8-使用spring表达式"></a> 8 使用spring表达式</h3><ul><li>Spring引入了一种表达式语言，这和统一的EL再语法上很相似，这种表达式语言可以读取一个bean对象/集合中的数据</li></ul><blockquote><p><strong>注意事项，要想使用spring表达式读取属性值，必须要被读取bean有相应的get方法</strong></p></blockquote><pre><code class="highlight plaintext">&lt;!-- 通过#来读取其他bean的属性值，前提是其他bean的该属性需要有get方法，否则无法读取值 --&gt;配置文件properties的bean      &lt;util:properties id=&quot;config&quot; location=&quot;classpath:config.properties&quot;&gt;&lt;/util:properties&gt;      &lt;bean id=&quot;sp1&quot; class=&quot;value.SpelBean&quot;&gt;表示读取bean的属性                  &lt;property name=&quot;name&quot; value=&quot;#&#123;vb1.name&#125;&quot;&gt;&lt;/property&gt;表示用下标读取list                        &lt;property name=&quot;city&quot; value=&quot;#&#123;vb1.city[1]&#125;&quot;&gt;&lt;/property&gt;表示用map的key读取value                        &lt;property name=&quot;score&quot; value=&quot;#&#123;vb1.score.english&#125;&quot;&gt;&lt;/property&gt;表示读取配置文件            &lt;property name=&quot;pageSize&quot; value=&quot;#&#123;config.pagesize&#125;&quot;&gt;&lt;/property&gt;      &lt;/bean&gt;                 &lt;bean id=&quot;vb1&quot; class=&quot;value.ValueBean&quot;&gt;            &lt;property name=&quot;name&quot; value=&quot;胡八一&quot;&gt;&lt;/property&gt;            &lt;property name=&quot;age&quot; value=&quot;30&quot;&gt;&lt;/property&gt;            &lt;property name=&quot;city&quot;&gt;                  &lt;list&gt;                        &lt;value&gt;北京&lt;/value&gt;                        &lt;value&gt;上海&lt;/value&gt;                        &lt;value&gt;广州&lt;/value&gt;                  &lt;/list&gt;            &lt;/property&gt;            &lt;property name=&quot;interest&quot;&gt;                  &lt;set&gt;                        &lt;value&gt;盗墓&lt;/value&gt;                        &lt;value&gt;战斗&lt;/value&gt;                        &lt;value&gt;喝酒&lt;/value&gt;                  &lt;/set&gt;            &lt;/property&gt;            &lt;property name=&quot;score&quot;&gt;                  &lt;map&gt;                        &lt;entry key=&quot;english&quot; value=&quot;60&quot;&gt;&lt;/entry&gt;                        &lt;entry key=&quot;math&quot; value=&quot;66&quot;&gt;&lt;/entry&gt;                  &lt;/map&gt;            &lt;/property&gt;            &lt;property name=&quot;db&quot;&gt;                  &lt;props&gt;                        &lt;prop key=&quot;username&quot;&gt;Tiger&lt;/prop&gt;                        &lt;prop key=&quot;password&quot;&gt;1234&lt;/prop&gt;                  &lt;/props&gt;            &lt;/property&gt;      &lt;/bean&gt;</code></pre><pre><code class="highlight plaintext">package value;public class SpelBean &#123;      private String name;      private String city;      private double score;      private String pageSize;      public SpelBean()&#123;            System.out.println(&quot;SpelBean()&quot;);      &#125;      public void setName(String name) &#123;            this.name = name;      &#125;      public void setCity(String city) &#123;            this.city = city;      &#125;      public void setScore(double score) &#123;            this.score = score;      &#125;      public void setPageSize(String pageSize) &#123;            this.pageSize = pageSize;      &#125;  &#125;</code></pre><p>输出</p><pre><code class="highlight plaintext">SpelBean [name=胡八一, city=上海, score=60.0, pageSize=10]</code></pre><h2 id="spring-ioc注解"><a class="markdownIt-Anchor" href="#spring-ioc注解"></a> Spring IoC注解</h2><p>学习基于注解的 IoC 配置，大家脑海里首先得有一个认知，即<strong>注解配置和 xml 配置要实现的功能都是一样的</strong>，都是要降低程序间的耦合。只是配置的形式不一样。</p><p>关于实际的开发中到底使用xml 还是注解，每家公司有着不同的使用习惯。所以这两种配置方式我们都需要掌握</p><p><strong>注解的优势：</strong></p><p>配置简单，维护方便（我们找到类，就相当于找到了对应的配置）</p><p><strong>XML的优势：</strong></p><p>修改时，不用改源码。不涉及重新编译和部署</p><h3 id="1什么是组件扫描"><a class="markdownIt-Anchor" href="#1什么是组件扫描"></a> 1.什么是组件扫描</h3><ul><li>spring容器启动后，会扫描该包及其子包下面的所有的类如果改类前面有特定的注解（比如@Component）,则spring容器会将其纳入容器进行管理（相当于这里配置了一个bean元素）</li><li>指定扫描路径后，并不是该路径下的所有组件类都扫描到spring容器，只有再组件类定义前面有以下注解标记时，才会扫描都Spring容器</li><li>以下注解都是一个作用，但语义不同<blockquote><p>@Componect 通用注解</p><p>@Named 通用注解</p><p>@Repository 持久化层注解扫描</p><p>@Service 业务层组件扫描</p><p>@Controller 表现层组件扫描</p></blockquote></li></ul><hr /><blockquote><p><strong>上述注解有个value属性，用来指定bean的id</strong>，如果不写，则bean的默认id就是<strong>类名首字母小写</strong></p></blockquote><h3 id="2如何进行组件扫描"><a class="markdownIt-Anchor" href="#2如何进行组件扫描"></a> 2.如何进行组件扫描</h3><ul><li>1 一个无参构造器</li><li>2 类标注解 @Component</li><li>3 xml的<beans>中写包名<ul><li><code>&lt;context:component-scan base-package=&quot;org.example&quot;</code></li></ul></li><li>上面的配置，容器实例化时会自动扫描org.example包及其子包下所有组件类</li></ul><pre><code class="highlight plaintext">package annotation;import org.springframework.stereotype.Component;//相当于再spring配置文件中有一条bean，它的id为sb1,缺省值为someBean@Component(&quot;sb1&quot;)public class SomeBean &#123;      public SomeBean()&#123;            System.out.println(&quot;SomeBean()&quot;);      &#125;&#125;</code></pre><p>applicationContext.xml</p><pre><code class="highlight plaintext">      &lt;!-- 配置组件扫描 --&gt;      &lt;!--两种方式都可以--&gt;      &lt;context:annotation-config/&gt;      &lt;!--             base-package属性：指定要扫描的包名，spring容器会扫描该包及其子包下面的所有的类            如果改类前面有特定的注解（比如@Component）,则spring容器会将其纳入容器进行管理（相当于这里配置了一个bean元素）       --&gt;       &lt;beans&gt;      &lt;context:component-scan base-package=&quot;annotation&quot;&gt;&lt;/context:component-scan&gt;    &lt;/beans&gt;</code></pre><h3 id="3作用域原型单例-and-延迟加载-and-初始化和销毁-回掉方法"><a class="markdownIt-Anchor" href="#3作用域原型单例-and-延迟加载-and-初始化和销毁-回掉方法"></a> 3.作用域原型/单例 AND 延迟加载 AND 初始化和销毁 回掉方法</h3><ul><li><code>@Scope('singleton')</code> <strong>单例</strong></li><li><code>@Lazy(true)</code><strong>延迟加载</strong></li><li><code>@PostConstruct</code> <strong>初始化</strong></li><li><code>@PreDestroy</code> <strong>销毁</strong><ul><li>注：初始化和销毁要单独导入tomcat相关包</li></ul></li></ul><pre><code class="highlight plaintext">package annotation;import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;import org.springframework.context.annotation.Lazy;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;//相当于再spring配置文件中有一条bean，它的id为sb1,缺省值为someBean@Component(&quot;sb1&quot;)//指定作用域，原型/单例，prototype原型/singleton单例@Scope(&quot;singleton&quot;)//默认单例都是容器启动就创建对象，延迟加载再启动容器时不创建对象，使用对象时再创建@Lazy(true)public class SomeBean &#123;//@PostConstruct和@PreDestroy都是sun的包，需要导入tomcat对应依赖包@PostConstructpublic void init()&#123;System.out.println(&quot;init()&quot;);&#125;//销毁方法需要作用域为单例@PreDestroypublic void destroy()&#123;System.out.println(&quot;destroy()&quot;);&#125;public SomeBean()&#123;System.out.println(&quot;SomeBean()&quot;);&#125;&#125;</code></pre><h3 id="4-依赖注入相关的注解"><a class="markdownIt-Anchor" href="#4-依赖注入相关的注解"></a> 4 依赖注入相关的注解</h3><table><thead><tr><th>属性</th><th>解释</th></tr></thead><tbody><tr><td><s>@Required</s></td><td>@Required 注释应用于 bean 属性的 setter 方法，它用来<strong>检查</strong>受影响的 bean 属性在配置时必须放在 XML 配置文件中，否则容器就会抛出一个 BeanInitializationException 异常</td></tr><tr><td>@Autowired/@Qualifier</td><td>一般成对使用，autowired默认使用byType方式传入，需要用Quelifier来指定bean的id</td></tr><tr><td>@Resource</td><td>只能用于setter,先按byName方式，然后用byType方式，也可以直接指定要传入的bean的id</td></tr></tbody></table><h4 id="autowired"><a class="markdownIt-Anchor" href="#autowired"></a> @Autowired</h4><ul><li><strong>@Autowired</strong><ul><li>可以处理构造器注入和Setter注入</li><li>默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如：<code>@Autowired(required=false)</code></li><li>a.当采用set方式注入时，可以将@Autowired添加到set方法前面，如果不使用@Qualifier,则容器会使用byType的方式来注入，有可能出错，所以建议使用@Qualifier，明确指定要注入的bean的id</li><li>b.也可以直接将两个注解添加到属性前（写在属性前容器会自动跳过set方法，用反射机制跳过private给赋值）</li><li>c.当采用构造器方式注入时，可以将该注解添加到对应的构造器前面即可</li></ul></li><li><strong>@Qualifier</strong><ul><li>在自动按照类型注入的基础之上，再按照 Bean 的 id 注入</li><li>它在给字段注入时不能独立使用，必须和@Autowire 一起使用；但是给方法参数注入时，可以独立使用</li></ul></li></ul><pre><code class="highlight plaintext">public class UserService&#123;    //@Autowired    //@Qualifier(&quot;mysqlUserDao&quot;)    private UserDao userDao;    @Autowired    public void setUserDao(@Qualifier(&quot;mysqlUserDao&quot;)userDao dao)&#123;        this.userDao = dao;    &#125;&#125;</code></pre><pre><code class="highlight plaintext">package annotation;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Component;@Component(&quot;rest&quot;)public class Restaurant &#123;      //两种写法都可以，写在成员变量前面可以省掉写set方法      //    @Autowired      //    @Qualifier(&quot;wt&quot;)      private Waiter wt;      public Restaurant()&#123;            System.out.println(&quot;Restaurant()&quot;);      &#125;      //@Autowired告诉容器set方法注入      //@Qualifier告诉容器注入对象id为wt      @Autowired      public void setWt(@Qualifier(&quot;wt&quot;)Waiter wt) &#123;            System.out.println(&quot;setWt()&quot;);            this.wt = wt;      &#125;      public String toString() &#123;            return &quot;Restaurant [wt=&quot; + wt + &quot;]&quot;;      &#125;&#125;package annotation;import org.springframework.stereotype.Component;@Component(&quot;wt&quot;)public class Waiter &#123;      public Waiter()&#123;            System.out.println(&quot;Waiter()&quot;);      &#125;&#125;annotation.xml&lt;context:component-scan base-package=&quot;annotation&quot;/&gt;</code></pre><ul><li><s>@Inject/@Named</s><ul><li>和@Autowired用法一致，需要额外导包</li><li>Inject注解标记是Spring3.0开始增添的对JSR-330标准的支持，使用前需要添加JSR-330的jar包,使用方法与@Autowired相似</li></ul></li></ul><pre><code class="highlight plaintext">public class UserService&#123;    private UserDao userDao;    @Inject    public void  setUserDao(@Named(&quot;mysqlUserDao&quot;)UserDao dao)&#123;        this.userDao = dao;    &#125;&#125;</code></pre><h4 id="resource重点"><a class="markdownIt-Anchor" href="#resource重点"></a> @Resource（重点）</h4><ul><li><strong>@Resource（重点）</strong><ul><li>默认按照<strong>名称（byName）进行装配</strong>，名称可以通过name属性进行指定</li><li>该注解属于J2EE</li><li>只能处理Setter注入，但是大部分情况都是Setter注入</li><li>Resource注解标记可以用在<strong>字段定义</strong>或<strong>setter方法定义</strong>前面(区别就是字段前面只是单纯的赋值，方法前面可以捎带执行方法内的其他语句)</li><li>如果没有指定name属性，当注解写在字段上时，<strong>默认首先按字段名匹配注入，当找不到与名称匹配的bean时才按照类型进行装配</strong></li><li>当遇到多个匹配Bean时注入会发生错误，可以显示指定名称（但是需要注意的是，如果<strong>name属性一旦指定</strong>，就<strong>只会</strong>按照名称进行装配），例如<code>@Resource(name=&quot;empDao1&quot;)</code></li></ul></li></ul><pre><code class="highlight plaintext">@Component(&quot;us&quot;)public class UserService&#123;    @Resource(name=&quot;userDao&quot;)    private UserDao userDao;    @Resource    public void setUserDao(UserDao dao)&#123;        this.userDao = dao;    &#125;&#125;</code></pre><h4 id="value"><a class="markdownIt-Anchor" href="#value"></a> @Value</h4><ul><li>可以给基本类型和String类型注入值</li><li>可以使用占位符获取properties属性文件中的值</li></ul><h5 id="value和value的区别"><a class="markdownIt-Anchor" href="#value和value的区别"></a> @value(“#{}”)和@value(“${}”)的区别</h5><p><strong>@value(“${}”)</strong></p><p>一般用来获取properties属性文件中的值，获取的前提是需要在applicationContext.xml文件中配置properties文件</p><pre><code class="highlight plaintext">@Value(“$&#123;name&#125;”)//name是properties文件中的keyprivate String name;</code></pre><p>applicationContext.xml配置文件</p><pre><code class="highlight plaintext">&lt;!-- 加载配置属性文件 --&gt;&lt;context:property-placeholder location=&quot;classpath:sys.properties&quot; /&gt;</code></pre><p><strong>@value(“#{}”)</strong></p><p>此种用法SpEl表达式通常用来获取bean的属性，或者调用bean的某个方法。当然还有可以表示常量</p><pre><code class="highlight plaintext">public class LoginController &#123;@Value(&quot;#&#123;1&#125;&quot;)private int number; //获取数字 1@Value(&quot;#&#123;&#x27;Spring Expression Language&#x27;&#125;&quot;) //获取字符串常量private String str;@Value(&quot;#&#123;dataSource.url&#125;&quot;) //获取bean的属性private String jdbcUrl;    ... ...&#125;</code></pre><h5 id="通过utilproperties"><a class="markdownIt-Anchor" href="#通过utilproperties"></a> 通过util:properties</h5><ul><li>可以使用该注解来注入基本类型的值</li><li>@Value注解可以注入Spring表达式值，使用方法</li><li>首先在XML配置中指定要注入的properties文件<ul><li><code>&lt;util:properties location=&quot;classpath:db.properties&quot;/&gt;</code></li></ul></li><li>然后再setter方法前使用@Value注解</li></ul><pre><code class="highlight plaintext">public class JDBCDateSource&#123;    @Value(&quot;#&#123;jdbcProps.url&#125;&quot;)    private String url;    @Value(&quot;#&#123;jdbcProps.driver&#125;&quot;)    public void setUrl(String driver)&#123;        Class.forName(driver);    &#125;&#125;</code></pre><h5 id="通过propertyplaceholderconfigurer"><a class="markdownIt-Anchor" href="#通过propertyplaceholderconfigurer"></a> 通过PropertyPlaceholderConfigurer</h5><ul><li>dev.properties</li></ul><pre><code class="highlight plaintext">tag=123</code></pre><ul><li>spring.xml 配置</li></ul><pre><code class="highlight plaintext">&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;&lt;property name=&quot;location&quot; value=&quot;dev.properties&quot; /&gt;&lt;/bean&gt;</code></pre><ul><li>使用</li></ul><pre><code class="highlight plaintext">@Value(&quot;$&#123;tag&#125;&quot;)private String tag;</code></pre><h5 id="通过preferencesplaceholderconfigurer"><a class="markdownIt-Anchor" href="#通过preferencesplaceholderconfigurer"></a> 通过PreferencesPlaceholderConfigurer</h5><ul><li>配置</li></ul><pre><code class="highlight plaintext">&lt;bean id=&quot;appConfig&quot; class=&quot;org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer&quot;&gt;&lt;property name=&quot;location&quot; value=&quot;dev.properties&quot; /&gt;&lt;/bean&gt;</code></pre><ul><li>使用</li></ul><pre><code class="highlight plaintext">@Value(&quot;$&#123;tag&#125;&quot;)private String tag;</code></pre><h5 id="通过propertiesfactorybean"><a class="markdownIt-Anchor" href="#通过propertiesfactorybean"></a> 通过PropertiesFactoryBean</h5><ul><li>配置</li></ul><pre><code class="highlight plaintext">&lt;bean id=&quot;config&quot; class=&quot;org.springframework.beans.factory.config.PropertiesFactoryBean&quot;&gt;&lt;property name=&quot;location&quot; value=&quot;dev.properties&quot; /&gt;&lt;/bean&gt;</code></pre><ul><li>使用</li></ul><pre><code class="highlight plaintext">@Value(&quot;#&#123;config[&#x27;tag&#x27;]&#125;&quot;)private String tag;</code></pre><h2 id="java类取代spring-xml配置"><a class="markdownIt-Anchor" href="#java类取代spring-xml配置"></a> Java类取代spring xml配置</h2><h3 id="configuration和bean注解"><a class="markdownIt-Anchor" href="#configuration和bean注解"></a> @Configuration和@Bean注解</h3><p>@<strong>Configuration</strong></p><ul><li>@<strong>Configuration</strong>相当于配置文件中<strong>的<beans/>根标签</strong></li><li>从Spring3.0，@Configuration用于定义配置类，<strong>可替换xml配置文件</strong></li><li>配置类内部包含有一个或多个被@Bean注解的方法，这些方法将会被<code>AnnotationConfigApplicationContext</code>或<code>AnnotationConfigWebApplicationContext</code>类进行扫描，并用于构建bean定义，初始化Spring容器</li><li><strong>属性</strong><ul><li>value:用于指定配置类的字节码</li></ul></li></ul><p>@<strong>Bean</strong></p><ul><li>@<strong>Bean</strong>相当于<bean/>，只能注解在方法和注解上，一般在方法上使用</li><li>带有@<strong>Configuration</strong>的注解类表示这个类可以使用Spring IOC容器作为bean定义的来源，@<strong>Bean</strong>注解告诉Spring，一个带有@Bean的注解方法将返回一个对象，该对象应该被注册在Spring应用程序上下文中的bean</li><li><strong>属性</strong><ul><li>name：给当前@Bean 注解方法创建的对象指定一个名称(即 bean 的 id）</li><li>如果不指定，<strong>默认与标注的方法名相同</strong></li><li>@Bean注解默认作用域为单例singleton作用域，可通过@Scope(“prototype”)设置为原型作用域；</li></ul></li></ul><blockquote><p>使用零配置和注解虽然方便，不需要编写麻烦的xml文件，但并非为了取代xml，应该根据实例需要选择，或二者结合使用，毕竟使用一个类作为容器的配置信息是硬编码的，<strong>无法在发布后修改</strong></p></blockquote><ul><li>案例</li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;import org.springframework.context.annotation.*;@Configurationpublic class SpringConfiguration &#123;   @Bean    public HelloWorld helloWorld()&#123;      return new HelloWorld();   &#125;      //spring容器初始化时，会调用配置类的无参构造函数   public SpringConfiguration()&#123;       System.out.println(“容器启动初始化。。。”);   &#125;&#125;</code></pre><ul><li>上面的代码将等同于下面的XML配置</li></ul><pre><code class="highlight plaintext">&lt;beans&gt;   &lt;bean id=&quot;helloWorld&quot; class=&quot;com.tutorialspoint.HelloWorld&quot; /&gt;&lt;/beans&gt;</code></pre><ul><li>在这里，带有@Bean注解的方法名称作为bean的id,它创建并返回实际的bean，你的配置类可以声明多个@Bean，一旦定义了<strong>配置类</strong>，就可以使用AnnotationConfigApplicationContext来加载并把他们提供给spring容器</li></ul><pre><code class="highlight plaintext">public static void main(String[] args) &#123;   ApplicationContext ctx =    new AnnotationConfigApplicationContext(HelloWorldConfig.class); //这个HolloWorldConfig就是一个配置类，里面@Bean声明的方法就相当于在spring容器中添加了一个bean配置   HelloWorld helloWorld = ctx.getBean(HelloWorld.class);   helloWorld.setMessage(&quot;Hello World!&quot;);   helloWorld.getMessage();&#125;</code></pre><ul><li>或者可以加载各种配置类</li></ul><pre><code class="highlight plaintext">public static void main(String[] args) &#123;   AnnotationConfigApplicationContext ctx =    new AnnotationConfigApplicationContext();   ctx.register(AppConfig.class, OtherConfig.class);   ctx.register(AdditionalConfig.class);   ctx.refresh();   MyService myService = ctx.getBean(MyService.class);   myService.doStuff();&#125;</code></pre><h3 id="componentscan"><a class="markdownIt-Anchor" href="#componentscan"></a> @ComponentScan</h3><p>@<strong>ComponentScan</strong></p><ul><li>相当于context:component-scan标签</li><li>组件扫描器，扫描@Component、@Controller、@Service、@Repository注解的类。</li><li>该注解是编写在类上面的，一般配合@Configuration注解一起使用</li><li><strong>属性</strong><ul><li>basePackages：用于指定要扫描的包</li><li>value：和basePackages作用一样</li></ul></li></ul><pre><code class="highlight plaintext">@Configuration@ComponentScan(basePackages=&quot;com.kkb.spring.service&quot;)public class SpringConfiguration &#123;         public SpringConfiguration() &#123;                  System.out.println(&quot;容器初始化...&quot;);         &#125;&#125;</code></pre><h3 id="propertysource"><a class="markdownIt-Anchor" href="#propertysource"></a> @PropertySource</h3><p>在开发应用程序时，经常需要读取配置文件。最常用的配置方法是以key=value的形式写在.properties文件中。</p><p>例如，MailService根据配置的app.zone=Asia/Shanghai来决定使用哪个时区。要读取配置文件，我们可以使用上一节讲到的Resource来读取位于classpath下的一个app.properties文件。但是，这样仍然比较繁琐。</p><p>Spring容器还提供了一个更简单的@PropertySource来自动读取配置文件。我们只需要在@Configuration配置类上再添加一个注解：</p><pre><code class="highlight plaintext">@Configuration@ComponentScan@PropertySource(&quot;app.properties&quot;) // 表示读取classpath的app.propertiespublic class AppConfig &#123;    @Value(&quot;$&#123;app.zone:Z&#125;&quot;)    String zoneId;    @Bean    ZoneId createZoneId() &#123;        return ZoneId.of(zoneId);    &#125;&#125;</code></pre><p>Spring容器看到@PropertySource(“app.properties”)注解后，自动读取这个配置文件，然后，我们使用@Value正常注入：</p><pre><code class="highlight plaintext">@Value(&quot;$&#123;app.zone:Z&#125;&quot;)String zoneId;</code></pre><p>注意注入的字符串语法，它的格式如下：</p><ul><li>&quot;${app.zone}&quot;表示读取key为app.zone的value，如果key不存在，启动将报错；</li><li>&quot;${app.zone:Z}&quot;表示读取key为app.zone的value，但如果key不存在，就使用默认值Z。</li></ul><p>这样一来，我们就可以根据app.zone的配置来创建ZoneId。</p><p>还可以把注入的注解写到方法参数中：</p><pre><code class="highlight plaintext">@BeanZoneId createZoneId(@Value(&quot;$&#123;app.zone:Z&#125;&quot;) String zoneId) &#123;    return ZoneId.of(zoneId);&#125;</code></pre><p>可见，先使用@PropertySource读取配置文件，然后通过@Value以${key:defaultValue}的形式注入，可以极大地简化读取配置的麻烦。</p><p>另一种注入配置的方式是先通过一个简单的JavaBean持有所有的配置，例如，一个SmtpConfig：</p><pre><code class="highlight plaintext">@Componentpublic class SmtpConfig &#123;    @Value(&quot;$&#123;smtp.host&#125;&quot;)    private String host;    @Value(&quot;$&#123;smtp.port:25&#125;&quot;)    private int port;    public String getHost() &#123;        return host;    &#125;    public int getPort() &#123;        return port;    &#125;&#125;</code></pre><p>然后，在需要读取的地方，使用#{smtpConfig.host}注入：</p><pre><code class="highlight plaintext">@Componentpublic class MailService &#123;    @Value(&quot;#&#123;smtpConfig.host&#125;&quot;)    private String smtpHost;    @Value(&quot;#&#123;smtpConfig.port&#125;&quot;)    private int smtpPort;&#125;</code></pre><p>注意观察#{}这种注入语法，它和${key}不同的是，#{}表示从JavaBean读取属性。&quot;#{smtpConfig.host}&quot;的意思是，从名称为smtpConfig的Bean读取host属性，即调用getHost()方法。一个Class名为SmtpConfig的Bean，它在Spring容器中的默认名称就是smtpConfig，除非用@Qualifier指定了名称。</p><p>使用一个独立的JavaBean持有所有属性，然后在其他Bean中以#{bean.property}注入的好处是，多个Bean都可以引用同一个Bean的某个属性。例如，如果SmtpConfig决定从数据库中读取相关配置项，那么MailService注入的@Value(“#{smtpConfig.host}”)仍然可以不修改正常运行。</p><p>示例：</p><pre><code class="highlight plaintext">@Configuration@PropertySource(“classpath:jdbc.properties”)public class JdbcConfig &#123;    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)    private String driver;    @Value(&quot;$&#123;jdbc.url&#125;&quot;)    private String url;    @Value(&quot;$&#123;jdbc.username&#125;&quot;)    private String username;    @Value(&quot;$&#123;jdbc.password&#125;&quot;)    private String password;    /**    创建一个数据源，并存入 spring 容器中    @return    */    @Bean(name=&quot;dataSource&quot;)    public DataSource createDataSource() &#123;        try &#123;            ComboPooledDataSource ds = new ComboPooledDataSource();             ds.setDriverClass(driver);            ds.setJdbcUrl(url);             ds.setUser(username);             ds.setPassword(password);             return ds;        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;</code></pre><p>jdbc.properties</p><pre><code class="highlight plaintext">jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql:///springjdbc.username=root jdbc.password=root</code></pre><h3 id="resource"><a class="markdownIt-Anchor" href="#resource"></a> @Resource</h3><p>在Java程序中，我们经常会读取配置文件、资源文件等。使用Spring容器时，我们也可以把“文件”注入进来，方便程序读取。</p><p>例如，AppService需要读取logo.txt这个文件，通常情况下，我们需要写很多繁琐的代码，主要是为了定位文件，打开InputStream。</p><p>Spring提供了一个org.springframework.core.io.Resource（注意不是jarkata.annotation.Resource或javax.annotation.Resource），它可以像String、int一样使用@Value注入：</p><pre><code class="highlight plaintext">@Componentpublic class AppService &#123;    @Value(&quot;classpath:/logo.txt&quot;)    private Resource resource;    private String logo;    @PostConstruct    public void init() throws IOException &#123;        try (var reader = new BufferedReader(                new InputStreamReader(resource.getInputStream(), StandardCharsets.UTF_8))) &#123;            this.logo = reader.lines().collect(Collectors.joining(&quot;\n&quot;));        &#125;    &#125;&#125;</code></pre><p>注入Resource最常用的方式是通过classpath，即类似classpath:/logo.txt表示在classpath中搜索logo.txt文件，然后，我们直接调用Resource.getInputStream()就可以获取到输入流，避免了自己搜索文件的代码。也可以直接指定文件的路径，例如：</p><pre><code class="highlight plaintext">@Value(&quot;file:/path/to/logo.txt&quot;)private Resource resource;</code></pre><p>但使用classpath是最简单的方式。上述工程结构如下：</p><h3 id="import"><a class="markdownIt-Anchor" href="#import"></a> @Import</h3><p>@<strong>import</strong></p><ul><li>注解允许从另一个配置类中加载@Bean定义</li><li>用来组合多个配置类</li><li>相当于spring标签中的import标签</li><li>在引入其他配置类时，可以不用再写@Configuration 注解。当然，写上也没问题</li><li><strong>属性</strong><ul><li>value：用来指定其他配置类的字节码文件</li></ul></li></ul><pre><code class="highlight plaintext">@Configurationpublic class ConfigA &#123;   @Bean   public A a() &#123;      return new A();    &#125;&#125;</code></pre><ul><li>可以在另一个bean声明中导入上述Bean声明</li></ul><pre><code class="highlight plaintext">@Configuration@Import(ConfigA.class)public class ConfigB &#123;   @Bean   public B a() &#123;      return new A();    &#125;&#125;</code></pre><ul><li>现在，当实例化上下文时，不需要同时指定ConfigA.class和ConfigB.class，只有ConfigB类需要提供</li></ul><pre><code class="highlight plaintext">public static void main(String[] args) &#123;   ApplicationContext ctx =    new AnnotationConfigApplicationContext(ConfigB.class);   // now both beans A and B will be available...   A a = ctx.getBean(A.class);   B b = ctx.getBean(B.class);&#125;</code></pre><h3 id="注入list"><a class="markdownIt-Anchor" href="#注入list"></a> 注入List</h3><p>有些时候，我们会有一系列接口相同，不同实现类的Bean。例如，注册用户时，我们要对email、password和name这3个变量进行验证。为了便于扩展，我们先定义验证接口：</p><pre><code class="highlight plaintext">public interface Validator &#123;    void validate(String email, String password, String name);&#125;</code></pre><p>然后，分别使用3个Validator对用户参数进行验证：</p><pre><code class="highlight plaintext">@Componentpublic class EmailValidator implements Validator &#123;    public void validate(String email, String password, String name) &#123;        if (!email.matches(&quot;^[a-z0-9]+\\@[a-z0-9]+\\.[a-z]&#123;2,10&#125;$&quot;)) &#123;            throw new IllegalArgumentException(&quot;invalid email: &quot; + email);        &#125;    &#125;&#125;@Componentpublic class PasswordValidator implements Validator &#123;    public void validate(String email, String password, String name) &#123;        if (!password.matches(&quot;^.&#123;6,20&#125;$&quot;)) &#123;            throw new IllegalArgumentException(&quot;invalid password&quot;);        &#125;    &#125;&#125;@Componentpublic class NameValidator implements Validator &#123;    public void validate(String email, String password, String name) &#123;        if (name == null || name.isBlank() || name.length() &gt; 20) &#123;            throw new IllegalArgumentException(&quot;invalid name: &quot; + name);        &#125;    &#125;&#125;</code></pre><p>最后，我们通过一个Validators作为入口进行验证：</p><pre><code class="highlight plaintext">@Componentpublic class Validators &#123;    @Autowired    List&lt;Validator&gt; validators;    public void validate(String email, String password, String name) &#123;        for (var validator : this.validators) &#123;            validator.validate(email, password, name);        &#125;    &#125;&#125;</code></pre><p>注意到Validators被注入了一个List<Validator>，Spring会自动把<strong>所有类型为Validator的Bean装配为一个List注入</strong>进来，这样一来，我们每新增一个Validator类型，就自动被Spring装配到Validators中了，非常方便。</p><p>因为Spring是通过扫描classpath获取到所有的Bean，而List是有序的，要指定List中Bean的顺序，可以加上@Order注解：</p><pre><code class="highlight plaintext">@Component@Order(1)public class EmailValidator implements Validator &#123;    ...&#125;@Component@Order(2)public class PasswordValidator implements Validator &#123;    ...&#125;@Component@Order(3)public class NameValidator implements Validator &#123;    ...&#125;</code></pre><h3 id="生命周期回调"><a class="markdownIt-Anchor" href="#生命周期回调"></a> 生命周期回调</h3><ul><li>@Bean注解支持任意的初始化和销毁的回调方法，就像在bean元素中spring的xml的初始化方法和销毁方法的属性</li></ul><pre><code class="highlight plaintext">public class Foo &#123;   public void init() &#123;      // initialization logic   &#125;   public void cleanup() &#123;      // destruction logic   &#125;&#125;@Configurationpublic class AppConfig &#123;   @Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;cleanup&quot; )   public Foo foo() &#123;      return new Foo();   &#125;&#125;</code></pre><ul><li><strong>指定bean的范围</strong></li><li>默认范围时单例，但是你可以重写带有@Scope注解的该方法</li></ul><pre><code class="highlight plaintext">@Configurationpublic class AppConfig &#123;   @Bean   @Scope(&quot;prototype&quot;)   public Foo foo() &#123;      return new Foo();   &#125;&#125;</code></pre><h3 id="创建第三方bean"><a class="markdownIt-Anchor" href="#创建第三方bean"></a> 创建第三方Bean</h3><p>如果一个Bean不在我们自己的package管理之内，例如ZoneId，如何创建它？</p><p>答案是我们自己在@Configuration类中编写一个Java方法创建并返回它，注意给方法标记一个@Bean注解：</p><pre><code class="highlight plaintext">@Configuration@ComponentScanpublic class AppConfig &#123;    // 创建一个Bean:    @Bean    ZoneId createZoneId() &#123;        return ZoneId.of(&quot;Z&quot;);    &#125;&#125;</code></pre><p>Spring对标记为@Bean的方法只调用一次，因此返回的Bean仍然是单例。</p><h3 id="初始化和销毁"><a class="markdownIt-Anchor" href="#初始化和销毁"></a> 初始化和销毁</h3><p>有些时候，一个Bean在注入必要的依赖后，需要进行初始化（监听消息等）。在容器关闭时，有时候还需要清理资源（关闭连接池等）。我们通常会定义一个init()方法进行初始化，定义一个shutdown()方法进行清理，然后，引入JSR-250定义的Annotation：</p><ul><li>jakarta.annotation:jakarta.annotation-api:2.1.1</li></ul><p>在Bean的初始化和清理方法上标记@PostConstruct和@PreDestroy：</p><pre><code class="highlight plaintext">@Componentpublic class MailService &#123;    @Autowired(required = false)    ZoneId zoneId = ZoneId.systemDefault();    @PostConstruct    public void init() &#123;        System.out.println(&quot;Init mail service with zonehljs-keyword&quot; style=&quot;color: #569cd6; line-height: 160%; box-sizing: content-box;&quot;&gt;this.zoneId);    &#125;    @PreDestroy    public void shutdown() &#123;        System.out.println(&quot;Shutdown mail service&quot;);    &#125;&#125;</code></pre><p>Spring容器会对上述Bean做如下初始化流程：</p><ul><li>调用构造方法创建MailService实例；</li><li>根据@Autowired进行注入；</li><li>调用标记有@PostConstruct的init()方法进行初始化。</li></ul><p>而销毁时，容器会首先调用标记有@PreDestroy的shutdown()方法。</p><p>Spring只根据Annotation查找无参数方法，对方法名不作要求。</p><h3 id="使用别名"><a class="markdownIt-Anchor" href="#使用别名"></a> 使用别名</h3><p>默认情况下，对一种类型的Bean，容器只创建一个实例。但有些时候，我们需要对一种类型的Bean创建多个实例。</p><p>例如，同时连接多个数据库，就必须创建多个DataSource实例。如果我们在@Configuration类中创建了多个同类型的Bean：</p><pre><code class="highlight plaintext">@Configuration@ComponentScanpublic class AppConfig &#123;    @Bean    ZoneId createZoneOfZ() &#123;        return ZoneId.of(&quot;Z&quot;);    &#125;    @Bean    ZoneId createZoneOfUTC8() &#123;        return ZoneId.of(&quot;UTC+08:00&quot;);    &#125;&#125;</code></pre><p>Spring会报NoUniqueBeanDefinitionException异常，意思是出现了重复的Bean定义。这个时候，需要给每个Bean添加不同的名字：</p><pre><code class="highlight plaintext">@Configuration@ComponentScanpublic class AppConfig &#123;    @Bean(&quot;z&quot;)    ZoneId createZoneOfZ() &#123;        return ZoneId.of(&quot;Z&quot;);    &#125;    @Bean    @Qualifier(&quot;utc8&quot;)    ZoneId createZoneOfUTC8() &#123;        return ZoneId.of(&quot;UTC+08:00&quot;);    &#125;&#125;</code></pre><p>可以用@Bean(“name”)指定别名，也可以用@Bean+@Qualifier(“name”)指定别名。</p><p>存在多个同类型的Bean时，注入ZoneId又会报错：</p><pre><code class="highlight plaintext">NoUniqueBeanDefinitionException: No qualifying bean of type &#x27;java.time.ZoneId&#x27; available: expected single matching bean but found 2</code></pre><p>意思是期待找到唯一的ZoneId类型Bean，但是找到两。因此，注入时，要指定Bean的名称：</p><pre><code class="highlight plaintext">@Componentpublic class MailService &#123;        @Autowired(required = false)        @Qualifier(&quot;z&quot;) // 指定注入名称为&quot;z&quot;的ZoneId        ZoneId zoneId = ZoneId.systemDefault();    ...&#125;</code></pre><p>还有一种方法是把其中某个Bean指定为@Primary：</p><pre><code class="highlight plaintext">@Configuration@ComponentScanpublic class AppConfig &#123;    @Bean    @Primary // 指定为主要Bean    @Qualifier(&quot;z&quot;)    ZoneId createZoneOfZ() &#123;        return ZoneId.of(&quot;Z&quot;);    &#125;    @Bean    @Qualifier(&quot;utc8&quot;)    ZoneId createZoneOfUTC8() &#123;        return ZoneId.of(&quot;UTC+08:00&quot;);    &#125;&#125;</code></pre><p>这样，在注入时，如果没有指出Bean的名字，Spring会注入标记有@Primary的Bean。这种方式也很常用。例如，对于主从两个数据源，通常将主数据源定义为@Primary：</p><pre><code class="highlight plaintext">@Configuration@ComponentScanpublic class AppConfig &#123;    @Bean    @Primary    DataSource createMasterDataSource() &#123;        ...    &#125;    @Bean    @Qualifier(&quot;slave&quot;)    DataSource createSlaveDataSource() &#123;        ...    &#125;&#125;</code></pre><p>其他Bean默认注入的就是主数据源。如果要注入从数据源，那么只需要指定名称即可。</p><h3 id="profile"><a class="markdownIt-Anchor" href="#profile"></a> @Profile</h3><p>开发应用程序时，我们会使用开发环境，例如，使用内存数据库以便快速启动。而运行在生产环境时，我们会使用生产环境，例如，使用MySQL数据库。如果应用程序可以根据自身的环境做一些适配，无疑会更加灵活。</p><p>Spring为应用程序准备了Profile这一概念，用来表示不同的环境。例如，我们分别定义开发、测试和生产这3个环境：</p><ul><li>native</li><li>test</li><li>production</li></ul><p>创建某个Bean时，Spring容器可以根据注解@Profile来决定是否创建。例如，以下配置：</p><pre><code class="highlight plaintext">@Configuration@ComponentScanpublic class AppConfig &#123;    @Bean    @Profile(&quot;!test&quot;)    ZoneId createZoneId() &#123;        return ZoneId.systemDefault();    &#125;    @Bean    @Profile(&quot;test&quot;)    ZoneId createZoneIdForTest() &#123;        return ZoneId.of(&quot;America/New_York&quot;);    &#125;&#125;</code></pre><p>如果当前的Profile设置为test，则Spring容器会调用createZoneIdForTest()创建ZoneId，否则，调用createZoneId()创建ZoneId。注意到@Profile(“!test”)表示非test环境。</p><p>在运行程序时，加上JVM参数-Dspring.profiles.active=test就可以指定以test环境启动。</p><p>实际上，Spring允许指定多个Profile，例如：</p><pre><code class="highlight plaintext">-Dspring.profiles.active=test,master</code></pre><p>可以表示test环境，并使用master分支代码。</p><p>要满足多个Profile条件，可以这样写：</p><pre><code class="highlight plaintext">@Bean@Profile(&#123; &quot;test&quot;, &quot;master&quot; &#125;) // 满足test或masterZoneId createZoneId() &#123;    ...&#125;</code></pre><h3 id="conditional"><a class="markdownIt-Anchor" href="#conditional"></a> @Conditional</h3><p>除了根据@Profile条件来决定是否创建某个Bean外，Spring还可以根据@Conditional决定是否创建某个Bean。</p><p>例如，我们对SmtpMailService添加如下注解：</p><pre><code class="highlight plaintext">@Component@Conditional(OnSmtpEnvCondition.class)public class SmtpMailService implements MailService &#123;    ...&#125;</code></pre><p>它的意思是，如果满足OnSmtpEnvCondition的条件，才会创建SmtpMailService这个Bean。OnSmtpEnvCondition的条件是什么呢？我们看一下代码：</p><pre><code class="highlight plaintext">public class OnSmtpEnvCondition implements Condition &#123;    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;        return &quot;true&quot;.equalsIgnoreCase(System.getenv(&quot;smtp&quot;));    &#125;&#125;</code></pre><p>因此，OnSmtpEnvCondition的条件是存在环境变量smtp，值为true。这样，我们就可以通过环境变量来控制是否创建SmtpMailService。</p><p>Spring只提供了@Conditional注解，具体判断逻辑还需要我们自己实现。Spring Boot提供了更多使用起来更简单的条件注解，例如，如果配置文件中存在app.smtp=true，则创建MailService：</p><pre><code class="highlight plaintext">@Component@ConditionalOnProperty(name=&quot;app.smtp&quot;, havingValue=&quot;true&quot;)public class MailService &#123;    ...&#125;</code></pre><p>如果当前classpath中存在类javax.mail.Transport，则创建MailService：</p><pre><code class="highlight plaintext">@Component@ConditionalOnClass(name = &quot;javax.mail.Transport&quot;)public class MailService &#123;    ...&#125;</code></pre><p>后续我们会介绍Spring Boot的条件装配。我们以文件存储为例，假设我们需要保存用户上传的头像，并返回存储路径，在本地开发运行时，我们总是存储到文件：</p><pre><code class="highlight plaintext">@Component@ConditionalOnProperty(name = &quot;app.storage&quot;, havingValue = &quot;file&quot;, matchIfMissing = true)public class FileUploader implements Uploader &#123;    ...&#125;</code></pre><p>在生产环境运行时，我们会把文件存储到类似AWS S3上：</p><pre><code class="highlight plaintext">@Component@ConditionalOnProperty(name = &quot;app.storage&quot;, havingValue = &quot;s3&quot;)public class S3Uploader implements Uploader &#123;    ...&#125;</code></pre><p>其他需要存储的服务则注入Uploader：</p><pre><code class="highlight plaintext">@Componentpublic class UserImageService &#123;    @Autowired    Uploader uploader;&#125;</code></pre><p>当应用程序检测到配置文件存在app.storage=s3时，自动使用S3Uploader，如果存在配置app.storage=file，或者配置app.storage不存在，则使用FileUploader。</p><h3 id="注入bean的依赖性"><a class="markdownIt-Anchor" href="#注入bean的依赖性"></a> 注入Bean的依赖性</h3><ul><li>当@Bean依赖其他的Bean时，表达这种依赖性非常简单，只要有一个bean方法调用另一个即可</li><li>这里，foo Bean通过构造函数注入来接受参数</li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;import org.springframework.context.annotation.*;@Configurationpublic class AppConfig &#123;   @Bean   public Foo foo() &#123;      return new Foo(bar());   &#125;   @Bean   public Bar bar() &#123;      return new Bar();   &#125;&#125;</code></pre><h3 id="通过注解获取容器"><a class="markdownIt-Anchor" href="#通过注解获取容器"></a> 通过注解获取容器</h3><p><strong>Java应用（AnnotationConfigApplicationContext）</strong></p><pre><code class="highlight plaintext">ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfiguration.class);UserService service = context.getBean(UserService.class);service.saveUser();</code></pre><p><strong>Web应用（AnnotationConfigWebApplicationContext</strong></p><pre><code class="highlight plaintext">&lt;web-app&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextClass&lt;/param-name&gt;        &lt;param-value&gt;            org.springframework.web.context.            support.AnnotationConfigWebApplicationContext        &lt;/param-value&gt;    &lt;/context-param&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;            com.kkb.spring.test.SpringConfiguration        &lt;/param-value&gt;    &lt;/context-param&gt;    &lt;listener&gt;        &lt;listener-class&gt;            org.springframework.web.context.ContextLoaderListener        &lt;/listener-class&gt;    &lt;/listener&gt;&lt;/web-app&gt;</code></pre><h3 id="使用factorybean"><a class="markdownIt-Anchor" href="#使用factorybean"></a> 使用FactoryBean</h3><p>我们在设计模式的工厂方法中讲到，很多时候，可以通过工厂模式创建对象。Spring也提供了工厂模式，允许定义一个工厂，然后由工厂创建真正的Bean。</p><p>用工厂模式创建Bean需要实现FactoryBean接口。我们观察下面的代码：</p><pre><code class="highlight plaintext">@Componentpublic class ZoneIdFactoryBean implements FactoryBean&lt;ZoneId&gt; &#123;    String zone = &quot;Z&quot;;    @Override    public ZoneId getObject() throws Exception &#123;        return ZoneId.of(zone);    &#125;    @Override    public Class&lt;?&gt; getObjectType() &#123;        return ZoneId.class;    &#125;&#125;</code></pre><p>当一个Bean实现了FactoryBean接口后，Spring会先实例化这个工厂，然后调用getObject()创建真正的Bean。getObjectType()可以指定创建的Bean的类型，因为指定类型不一定与实际类型一致，可以是接口或抽象类。</p><p>因此，如果定义了一个FactoryBean，要注意Spring创建的Bean实际上是这个FactoryBean的getObject()方法返回的Bean。为了和普通Bean区分，我们通常都以XxxFactoryBean命名。</p><p>由于可以用@Bean方法创建第三方Bean，本质上@Bean方法就是工厂方法，所以，FactoryBean已经用得越来越少了。</p><h2 id="spring-分模块开发"><a class="markdownIt-Anchor" href="#spring-分模块开发"></a> Spring 分模块开发</h2><p>分模块开发的场景描述：</p><ul><li>表现层：spring配置文件，只想管理表现层的Bean</li><li>业务层：spring配置文件，只想管理业务层的Bean，并且进行事务控制</li><li>持久层：spring配置文件，只想管理持久层的Bean，并且还有需要管理数据源的Bean</li></ul><p><strong>为了方便管理项目中不同层的Bean对象，一般都是将一个spring配置文件，分解为多个spring配置文件</strong></p><h3 id="如何加载多个配置文件"><a class="markdownIt-Anchor" href="#如何加载多个配置文件"></a> 如何加载多个配置文件</h3><p><strong>1. 同时指定多个配置文件的地址一起加载</strong></p><pre><code class="highlight plaintext">ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext1.xml&quot;,&quot;applicationContext2.xml&quot;,&quot;applicationContext3.xml&quot;);</code></pre><p><strong>2. 定义一个import.xml文件，通过import标签将其他多个spring配置文件导入到该文件中，tomcat启动时只需要加载import.xml就可以</strong></p><pre><code class="highlight plaintext">&lt;beans&gt;    &lt;!--import中放入其他的配置文件--&gt;    &lt;import resource=&quot;&quot;&gt;&lt;/import&gt;&lt;/beans&gt;</code></pre><h2 id="spring-整合junit"><a class="markdownIt-Anchor" href="#spring-整合junit"></a> Spring 整合Junit</h2><p><strong>要解决的问题</strong></p><p>为了避免每次测试业务代码，都手动的写一遍启动spring框架的代码，我们需要的是程序能自动帮我们创建容器。一旦程序能自动为我们创建 spring 容器，我们就无须手动创建了，问题也就解决了。</p><p>但紧接的问题就是junit它本身不认识spring，更无法帮助创建Spring容器了，不过好在Junit 给我们暴露了一个注解（@<strong>RunWith</strong>），可以让我们替换掉它的运行器。</p><p>这时，我们需要依靠 spring 框架，因为它提供了一个<strong>运行器</strong>，可以读取配置文件（或注解）来创建容器。我们只需要告诉它配置文件在哪就行了。</p><hr /><p><strong>具体实现</strong></p><ol><li>添加依赖</li></ol><pre><code class="highlight plaintext">&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;    &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol><li>通过@RunWith注解，指定spring的运行器<ul><li>Spring的运行器是<strong>SpringJunit4ClassRunner</strong></li></ul></li><li>通过<code>@ContextConfiguration</code>注解，指定spring运行器需要的配置文件路径</li><li>通过<code>@Autowired</code>注解给测试类中的变量注入数据</li></ol><pre><code class="highlight plaintext">import com.lee.util.BaseService;import javafx.application.Application;import org.junit.runner.RunWith;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;//@RunWith：Junit自身的注解，它的作用是可以指定一个新的运行器，进行单元测试//SpringJUnit4ClassRunner：spring提供的单元测试运行器@RunWith(SpringJUnit4ClassRunner.class)//@ContextConfiguration:SpringJUnit4ClassRunner运行器需要的上下文配置信息，方便创建spring容器//classes：纯注解方式，读取配置类//locations：XML方式，读取配置文件@ContextConfiguration(locations = &quot;classpath:springConfig.xml&quot;)//@ContextConfiguration(classes = SpringConfiguration.class)public class Test &#123;    @Resource    private UserService userService;    @Test    public void test1()&#123;        userService.saveUser();    &#125;&#125;</code></pre><h2 id="spring中事件处理"><a class="markdownIt-Anchor" href="#spring中事件处理"></a> Spring中事件处理</h2><h3 id="spring中的事件处理"><a class="markdownIt-Anchor" href="#spring中的事件处理"></a> Spring中的事件处理</h3><ul><li>Spring的核心时<strong>ApplicationContext</strong>，它负责管理beans的完整生命周期，当加载beans时，ApplicationContext发布某些类型的事件，例如，当上下文启动时，ContextStartedEvent发布，当上下文停止时，ContextStoppedEvent发布</li><li>通过<strong>ApplicationEvent</strong>类和<strong>ApplicationListener</strong>接口来提供在ApplicationContext中处理事件。如果一个bean实现ApplicationListener，那么每次ApplicationEvent被发布到ApplicationContext上，那么bean会被通知</li><li>spring提供了以下标准事件</li></ul><table><thead><tr><th>序号</th><th>Spring内置事件&amp;描述</th></tr></thead><tbody><tr><td>1</td><td><strong>ContextRefreshedEvent</strong> ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在 ConfigurableApplicationContext 接口中使用 refresh() 方法来发生</td></tr><tr><td>2</td><td><strong>ContextStartedEvent</strong> 当使用 ConfigurableApplicationContext 接口中的 start() 方法启动 ApplicationContext 时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</td></tr><tr><td>3</td><td><strong>ContextStoppedEvent</strong> 当使用 ConfigurableApplicationContext 接口中的 stop() 方法停止 ApplicationContext 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作。</td></tr><tr><td>4</td><td><strong>ContextClosedEvent</strong> 当使用 ConfigurableApplicationContext 接口中的 close() 方法关闭 ApplicationContext 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启。</td></tr><tr><td>5</td><td><strong>RequestHandledEvent</strong> 这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务</td></tr></tbody></table><ul><li>由于spring的事件处理是单线程的，所以如果一个事件被发布，直至并且除非所有的接收者都得到消息，该进程被阻塞并且流程将不会继续</li></ul><h3 id="监听上下文"><a class="markdownIt-Anchor" href="#监听上下文"></a> 监听上下文</h3><ul><li>为了监听上下文事件，一个 bean 应该实现只有一个方法 <strong>onApplicationEvent</strong>() 的 <strong>ApplicationListener</strong>接口。因此，我们写一个例子来看看事件是如何传播的，以及如何可以用代码来执行基于某些事件所需的任务。</li></ul><h3 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例</h3><pre><code class="highlight plaintext">package com.tutorialspoint;public class HelloWorld &#123;   private String message;   public void setMessage(String message)&#123;      this.message  = message;   &#125;   public void getMessage()&#123;      System.out.println(&quot;Your Message : &quot; + message);   &#125;&#125;</code></pre><ul><li>CStartEventHandler.java</li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;import org.springframework.context.ApplicationListener;import org.springframework.context.event.ContextStartedEvent;public class CStartEventHandler  implements ApplicationListener&lt;ContextStartedEvent&gt;&#123;   public void onApplicationEvent(ContextStartedEvent event) &#123;      System.out.println(&quot;ContextStartedEvent Received&quot;);   &#125;&#125;</code></pre><ul><li>CStopEvnetHandler.java</li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;import org.springframework.context.ApplicationListener;import org.springframework.context.event.ContextStoppedEvent;public class CStopEventHandler  implements ApplicationListener&lt;ContextStoppedEvent&gt;&#123;   public void onApplicationEvent(ContextStoppedEvent event) &#123;      System.out.println(&quot;ContextStoppedEvent Received&quot;);   &#125;&#125;</code></pre><ul><li>MainApp.java</li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123;   public static void main(String[] args) &#123;      ConfigurableApplicationContext context =       new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;);      // Let us raise a start event.      context.start();      HelloWorld obj = (HelloWorld) context.getBean(&quot;helloWorld&quot;);      obj.getMessage();      // Let us raise a stop event.      context.stop();   &#125;&#125;</code></pre><ul><li>Beans.xml</li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;   &lt;bean id=&quot;helloWorld&quot; class=&quot;com.tutorialspoint.HelloWorld&quot;&gt;      &lt;property name=&quot;message&quot; value=&quot;Hello World!&quot;/&gt;   &lt;/bean&gt;   &lt;bean id=&quot;cStartEventHandler&quot;          class=&quot;com.tutorialspoint.CStartEventHandler&quot;/&gt;   &lt;bean id=&quot;cStopEventHandler&quot;          class=&quot;com.tutorialspoint.CStopEventHandler&quot;/&gt;&lt;/beans&gt;</code></pre><ul><li>运行结果</li></ul><pre><code class="highlight plaintext">ContextStartedEvent ReceivedYour Message : Hello World!ContextStoppedEvent Received</code></pre><h4 id="spring中的自定义事件"><a class="markdownIt-Anchor" href="#spring中的自定义事件"></a> Spring中的自定义事件</h4><ul><li>CustomEvent.java -先定义事件<ul><li>通过继承ApplicationEvent,创建一个事件类 CustomEvent。这个类必须定义一个默认的构造函数，它应该从 ApplicationEvent 类中继承的构造函数</li></ul></li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;import org.springframework.context.ApplicationEvent;public class CustomEvent extends ApplicationEvent&#123;    public CustomEvent(Object source) &#123;      super(source);   &#125;   public String toString()&#123;      return &quot;My Custom Event&quot;;   &#125;&#125;</code></pre><ul><li>CustomEventPublisher.java -事件的发行者<ul><li>一旦定义事件类，你可以从任何类中发布它，假定 EventClassPublisher 实现了 ApplicationEventPublisherAware。你还需要在 XML 配置文件中声明这个类作为一个 bean，之所以容器可以识别 bean 作为事件发布者，是因为它实现了 ApplicationEventPublisherAware 接口</li></ul></li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;import org.springframework.context.ApplicationEventPublisher;import org.springframework.context.ApplicationEventPublisherAware;public class CustomEventPublisher    implements ApplicationEventPublisherAware &#123;   private ApplicationEventPublisher publisher;   public void setApplicationEventPublisher              (ApplicationEventPublisher publisher)&#123;      this.publisher = publisher;   &#125;   public void publish() &#123;      CustomEvent ce = new CustomEvent(this);      publisher.publishEvent(ce);   &#125;&#125;</code></pre><ul><li>CustomEventHandler.java --事件处理者<ul><li>发布的事件可以在一个类中被处理，假定 EventClassHandler 实现了 ApplicationListener 接口，而且实现了自定义事件的 onApplicationEvent 方法</li></ul></li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;import org.springframework.context.ApplicationListener;public class CustomEventHandler    implements ApplicationListener&lt;CustomEvent&gt;&#123;   public void onApplicationEvent(CustomEvent event) &#123;      System.out.println(event.toString());   &#125;&#125;</code></pre><ul><li>MainApp.java</li></ul><pre><code class="highlight plaintext">package com.tutorialspoint;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123;   public static void main(String[] args) &#123;      ConfigurableApplicationContext context =       new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;);          CustomEventPublisher cvp =       (CustomEventPublisher) context.getBean(&quot;customEventPublisher&quot;);      cvp.publish();        cvp.publish();   &#125;&#125;</code></pre><ul><li>Beans.xml</li></ul><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;   &lt;bean id=&quot;customEventHandler&quot;       class=&quot;com.tutorialspoint.CustomEventHandler&quot;/&gt;   &lt;bean id=&quot;customEventPublisher&quot;       class=&quot;com.tutorialspoint.CustomEventPublisher&quot;/&gt;&lt;/beans&gt;</code></pre><ul><li>输出</li></ul><pre><code class="highlight plaintext">My Custom EventMy Custom Event</code></pre>]]>
    </content>
    <id>http://example.com/2023/03/05/Spring/</id>
    <link href="http://example.com/2023/03/05/Spring/"/>
    <published>2023-03-05T04:00:00.000Z</published>
    <summary>Spring是一个开源的轻量级的应用开发框架，其目的是用于简化企业级应用程序开发，Spring提供的IOC和AOP应用，可以将组建的耦合度降至最低，即解耦，便于系统日后的维护和升级</summary>
    <title>Spring</title>
    <updated>2026-02-26T09:17:16.655Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    <content>
      <![CDATA[<h1 id="redis"><a class="markdownIt-Anchor" href="#redis"></a> Redis</h1><p>[toc]</p><h2 id="redis下载安装"><a class="markdownIt-Anchor" href="#redis下载安装"></a> Redis下载安装</h2><h3 id="什么是redis"><a class="markdownIt-Anchor" href="#什么是redis"></a> 什么是Redis</h3><ul><li><strong>Redis</strong>是一个开源的使用ANSI <strong>C语言</strong>编写、支持网络、可基于内存亦可持久化的日志型、<strong>Key-Value</strong> <strong>内存数据库</strong></li><li>它提供了<strong>五种数据类型</strong>来存储，<strong>字符串类型，散列类型，列表类型，集合类型，有序集合类型</strong></li><li>换句话说，Redis就像是一个HashMap，不过不是在JVM中运行，而是以一个独立进程的形式运行。</li><li>一般说来，会被当作缓存使用。 因为它比数据库(mysql)快，所以常用的数据，可以考虑放在这里，这样就提高了性能。</li><li>redis是一种<strong>NoSQL</strong>数据库</li></ul><h3 id="什么是nosql"><a class="markdownIt-Anchor" href="#什么是nosql"></a> 什么是NoSQL?</h3><p>NoSQL，即Not-Only-SQL(不仅仅是SQL)，泛指非关系型的数据库</p><p>NoSQL数据库是为了解决<strong>高并发，高可用，高扩展，大数据存储</strong>问题而产生的数据库解决方案</p><p>NoSQL可以作为关系型数据库的良好补充，但是<strong>不能替代关系型数据库</strong></p><blockquote><p>关系型数据库指：数据结构是一种有行有列的数据库</p></blockquote><h3 id="nosql数据库分类"><a class="markdownIt-Anchor" href="#nosql数据库分类"></a> NoSQL数据库分类</h3><p><strong>key-value</strong>存储数据库</p><ul><li>相关产品：Tokyo Cabinet/Tyrant，Redis，Voldemort，Berkeley DB</li><li>典型应用：内容缓存，主要用于处理大量数据的高访问负载</li><li>数据模型：一系列键值对</li><li>优势：快速查询</li><li>劣势：存储的数据缺少结构化</li></ul><p><strong>列存储数据库</strong></p><ul><li>相关产品：Cassandra, HBase, Riak</li><li>典型应用：分布式的文件系统</li><li>数据模型：以列簇式存储，将同一列数据存在一起</li><li>优势：查找速度快，可扩展性强，更容易进行分布式扩展</li><li>劣势：功能相对局限</li></ul><p><strong>文档型数据库</strong></p><ul><li>相关产品：CouchDB、MongoDB</li><li>典型应用：Web应用（与Key-Value类似，Value是结构化的）</li><li>数据模型： 一系列键值对</li><li>优势：数据结构要求不严格</li><li>劣势：</li></ul><p><strong>图形(Graph)数据库</strong></p><ul><li>相关数据库：Neo4J、InfoGrid、Infinite Graph</li><li>典型应用：社交网络</li><li>数据模型：图结构</li><li>优势：利用图结构相关算法。</li><li>劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案</li></ul><h3 id="redis的应用场景"><a class="markdownIt-Anchor" href="#redis的应用场景"></a> Redis的应用场景</h3><ul><li><p>内存数据库（登录信息、购物车信息、用户浏览记录等）</p></li><li><p>缓存服务器（商品数据、广告数据等等）。（最多使用）</p></li><li><p>解决分布式集群架构中的session分离问题（session共享）。</p></li><li><p>任务队列。（秒杀、抢购、12306等等）</p></li><li><p>支持发布订阅的消息模式</p></li><li><p>应用排行榜。</p></li><li><p>网站访问统计。</p></li><li><p>数据过期处理（可以精确到毫秒）</p></li></ul><h2 id="redis运行"><a class="markdownIt-Anchor" href="#redis运行"></a> Redis运行</h2><h3 id="windows版本"><a class="markdownIt-Anchor" href="#windows版本"></a> Windows版本</h3><h4 id="下载安装"><a class="markdownIt-Anchor" href="#下载安装"></a> 下载安装</h4><p>下载Redis Windows版本解压即可</p><h4 id="运行服务端"><a class="markdownIt-Anchor" href="#运行服务端"></a> 运行服务端</h4><ul><li>通过cmd运行命令行</li></ul><pre><code class="highlight plaintext">d:cd softwarecd D:\software\redis-64.3.0.503redis-server.exe</code></pre><ul><li>这样就启动了服务端</li></ul><h4 id="运行客户端"><a class="markdownIt-Anchor" href="#运行客户端"></a> 运行客户端</h4><ul><li>cmd命令行运行</li></ul><pre><code class="highlight plaintext">d:cd softwarecd D:\software\redis-64.3.0.503redis-cli.exe</code></pre><ul><li>可以使用如图所示的命令行访问redis服务器</li></ul><h3 id="linux版本"><a class="markdownIt-Anchor" href="#linux版本"></a> Linux版本</h3><h4 id="redis下载"><a class="markdownIt-Anchor" href="#redis下载"></a> Redis下载</h4><ul><li>官网地址：<u><a href="http://redis.io/">http://redis.io/</a></u></li><li>中文官网地址：<u><a href="http://www.redis.cn/">http://www.redis.cn/</a></u></li><li>下载地址：<u><a href="http://download.redis.io/releases/">http://download.redis.io/releases/</a></u></li></ul><h4 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h4><ol><li><p>将redis-3.0.0.tar.gz包用ftp工具拷贝到服务器</p></li><li><p>安装c语言需要的GCC环境</p></li></ol><pre><code class="highlight shell">yum install gcc-c++</code></pre><ol start="3"><li>解压缩Redis源码压缩包</li></ol><pre><code class="highlight linux">tar -zxf redis-3.2.9.tar.gz</code></pre><ol start="4"><li>编译Redis源码，进入redis-3.0.0目录，执行编译命令</li></ol><pre><code class="highlight plaintext">mike</code></pre><ol start="5"><li>安装Redis，通过PREFIX指定安装目录(在redis-3.0.0目录)</li></ol><pre><code class="highlight plaintext">make install PREFIX=/usr/local/redis</code></pre><h4 id="redis启动"><a class="markdownIt-Anchor" href="#redis启动"></a> Redis启动</h4><p><strong>前端启动</strong></p><p>进入redis安装目录</p><pre><code class="highlight plaintext">./redis-server</code></pre><blockquote><p>启动缺点：客户端窗口<code>ctrl+c</code>关闭则redis-server程序结束，不推荐使用此方法</p></blockquote><p><strong>后端启动（守护进程启动）</strong></p><ol><li>拷贝redis-3.2.9/redis.conf配置文件到Redis安装目录的bin目录</li></ol><pre><code class="highlight plaintext">cp /home/leeboer/leeftp/redis-3.0.0/redis.conf /usr/local/redis/bin/</code></pre><ol start="2"><li>修改redis.conf，将daemonize由no改为yes</li></ol><pre><code class="highlight plaintext">vim redis.conf</code></pre><blockquote><p>进入vim编辑器，可以使用“/”键进行搜索</p></blockquote><ol start="3"><li><p>修改redis.conf中的61行代码，<code>bind 127.0.0.1</code> 改为 <code>bind &lt;redis实例所在机器的真实IP&gt;</code></p><ul><li>这里指定了ip后，就只有指定的ip可以访问redis</li></ul></li><li><p>执行命令</p></li></ol><pre><code class="highlight plaintext">./redis-server redis.conf</code></pre><p><strong>后端启动的关闭方式</strong></p><p>非正常关闭</p><pre><code class="highlight plaintext">kill 5586</code></pre><p>正常关闭</p><pre><code class="highlight plaintext">./redis-cli shutdown</code></pre><p><strong>其他命令</strong></p><pre><code class="highlight plaintext">redis-server ：启动redis服务redis-cli ：进入redis命令客户redis-benchmark： 性能测试的工具redis-check-aof ： aof文件进行检查的工具redis-check-dump ：  rdb文件进行检查的工具redis-sentinel ：  启动哨兵监控服务</code></pre><h3 id="简单运用"><a class="markdownIt-Anchor" href="#简单运用"></a> 简单运用</h3><ul><li>输入指令</li></ul><pre><code class="highlight plaintext">set hero gareenget hero</code></pre><ul><li>如图就实现了向服务器设置hero这个键值，并从服务器获取hero对应的值</li></ul><h2 id="redis客户端"><a class="markdownIt-Anchor" href="#redis客户端"></a> Redis客户端</h2><h3 id="自带命令行客户端"><a class="markdownIt-Anchor" href="#自带命令行客户端"></a> 自带命令行客户端</h3><p><strong>命令格式</strong></p><ul><li>-h ：redis服务器的ip地址</li><li>-p ：redis实例的端口号</li></ul><pre><code class="highlight plaintext">./redis-cli -h 127.0.0.1 -p 6379</code></pre><p><strong>修改redis.conf配置文件（解决IP绑定问题）</strong></p><p><code>bind 127.0.0.1</code>     绑定的IP才能访问redis服务器，注释掉该配置</p><p><code>protected-mode yes</code>  是否开启保护模式，由yes该为no</p><p><strong>默认方式</strong></p><p>如果不指定主机和端口也可以</p><ul><li>默认主机地址是127.0.0.1</li><li>默认端口是6379</li></ul><pre><code class="highlight plaintext">./redis-cli</code></pre><h3 id="图形客户端"><a class="markdownIt-Anchor" href="#图形客户端"></a> 图形客户端</h3><p>前提：需要安装图形界面管理器</p><h4 id="关闭防火墙命令"><a class="markdownIt-Anchor" href="#关闭防火墙命令"></a> 关闭防火墙命令</h4><p>永久关闭</p><pre><code class="highlight plaintext">chkconfig iptables off/on</code></pre><p>本次关闭</p><pre><code class="highlight plaintext">service iptables stop</code></pre><h4 id="多数据库支持"><a class="markdownIt-Anchor" href="#多数据库支持"></a> 多数据库支持</h4><p>默认一共是16个数据库，每个数据库之间是相互隔离（但是可以使用flushall一次清空所有的库）。数据库的数量是在redis.conf中配置的。</p><p>切换数据库使用命令：select 数据库编号（0-15）</p><pre><code class="highlight plaintext">例如：select 1</code></pre><h3 id="程序客户端java"><a class="markdownIt-Anchor" href="#程序客户端java"></a> 程序客户端（java）</h3><p>在实际工作中却需要用到Java代码才能访问，使用第三方jar包 ：Jedis就能方便地访问Redis的各种服务了</p><h4 id="jedis介绍"><a class="markdownIt-Anchor" href="#jedis介绍"></a> Jedis介绍</h4><p>Redis不仅使用命令客户端来操作，而且可以使用<strong>程序客户端</strong>操作</p><p>现在基本上主流的语言都有客户端支持，比如<strong>Java</strong>、C、C#、C++、php、Node.js、Go等。</p><p>在官方网站里列一些Java的客户端，有<strong>Jedis</strong>、Redisson、Jredis、JDBC-Redis、等其中官方推荐使用Jedis和Redisson。</p><p>在<strong>企业中用的最多的就是Jedis</strong>，下面我们就重点学习下Jedis。</p><p>Jedis同样也是托管在github上，地址：<u><a href="https://github.com/xetorthio/jedis">https://github.com/xetorthio/jedis</a></u></p><h4 id="添加jar包"><a class="markdownIt-Anchor" href="#添加jar包"></a> 添加jar包</h4><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h4 id="单实例连接"><a class="markdownIt-Anchor" href="#单实例连接"></a> 单实例连接</h4><p>注意事项：需要去设置redis服务器的防火墙策略（临时关闭、永久关闭、端口暴露）</p><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJedis</span><span class="params">()</span> &#123;<span class="comment">//创建一个Jedis的连接</span><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);<span class="comment">//执行redis命令</span>jedis.set(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;hello world&quot;</span>);<span class="comment">//从redis中取值</span><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;key1&quot;</span>);<span class="comment">//打印结果</span>System.out.println(result);<span class="comment">//关闭连接</span>jedis.close();&#125;</code></pre><blockquote><p>注意：使用Windows版本的redis，要保持redis 的cmd窗口一直打开，服务运行</p></blockquote><p><strong>详细使用案例</strong></p><pre><code class="highlight java"><span class="keyword">package</span> redis;<span class="keyword">import</span> java.util.HashMap;<span class="keyword">import</span> java.util.Iterator;<span class="keyword">import</span> java.util.List;<span class="keyword">import</span> java.util.Map; <span class="keyword">import</span> org.junit.Before;<span class="keyword">import</span> org.junit.Test; <span class="keyword">import</span> redis.clients.jedis.Jedis;<span class="keyword">import</span> redis.clients.jedis.JedisPool;  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRedisManyCommands</span> &#123;     JedisPool pool;     Jedis jedis;     <span class="meta">@Before</span>     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;            jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>);                &#125;      <span class="comment">/**</span><span class="comment">     * Redis存储初级的字符串</span><span class="comment">     * CRUD</span><span class="comment">     */</span>     <span class="meta">@Test</span>     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBasicString</span><span class="params">()</span>&#123;         <span class="comment">//-----添加数据---------- </span>        jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;meepo&quot;</span>);<span class="comment">//向key--&gt;name中放入了value--&gt;meepo </span>        System.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));<span class="comment">//执行结果：meepo </span>         <span class="comment">//-----修改数据----------- </span>        <span class="comment">//1、在原来基础上修改 </span>        jedis.append(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;dota&quot;</span>);   <span class="comment">//很直观，类似map 将dota append到已经有的value之后 </span>        System.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));<span class="comment">//执行结果:meepodota </span>         <span class="comment">//2、直接覆盖原来的数据 </span>        jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;poofu&quot;</span>);         System.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));<span class="comment">//执行结果：poofu </span>         <span class="comment">//删除key对应的记录 </span>        jedis.del(<span class="string">&quot;name&quot;</span>);         System.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));<span class="comment">//执行结果：null </span>         <span class="comment">/**</span><span class="comment">         * mset相当于</span><span class="comment">         * jedis.set(&quot;name&quot;,&quot;meepo&quot;);</span><span class="comment">         * jedis.set(&quot;dota&quot;,&quot;poofu&quot;);</span><span class="comment">         */</span>         jedis.mset(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;meepo&quot;</span>,<span class="string">&quot;dota&quot;</span>,<span class="string">&quot;poofu&quot;</span>);         System.out.println(jedis.mget(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;dota&quot;</span>));      &#125;      <span class="comment">/**</span><span class="comment">     * jedis操作Map</span><span class="comment">     */</span>     <span class="meta">@Test</span>     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMap</span><span class="params">()</span>&#123;         Map&lt;String,String&gt; user=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();         user.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;meepo&quot;</span>);         user.put(<span class="string">&quot;pwd&quot;</span>,<span class="string">&quot;password&quot;</span>);         jedis.hmset(<span class="string">&quot;user&quot;</span>,user);         <span class="comment">//取出user中的name，执行结果:[meepo]--&gt;注意结果是一个泛型的List </span>        <span class="comment">//第一个参数是存入redis中map对象的key，后面跟的是放入map中的对象的key，后面的key可以跟多个，是可变参数 </span>        List&lt;String&gt; rsmap = jedis.hmget(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;name&quot;</span>);         System.out.println(rsmap);          <span class="comment">//删除map中的某个键值 </span><span class="comment">//        jedis.hdel(&quot;user&quot;,&quot;pwd&quot;); </span>        System.out.println(jedis.hmget(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;pwd&quot;</span>)); <span class="comment">//因为删除了，所以返回的是null </span>        System.out.println(jedis.hlen(<span class="string">&quot;user&quot;</span>)); <span class="comment">//返回key为user的键中存放的值的个数1 </span>        System.out.println(jedis.exists(<span class="string">&quot;user&quot;</span>));<span class="comment">//是否存在key为user的记录 返回true </span>        System.out.println(jedis.hkeys(<span class="string">&quot;user&quot;</span>));<span class="comment">//返回map对象中的所有key  [pwd, name] </span>        System.out.println(jedis.hvals(<span class="string">&quot;user&quot;</span>));<span class="comment">//返回map对象中的所有value  [meepo, password] </span>         Iterator&lt;String&gt; iter=jedis.hkeys(<span class="string">&quot;user&quot;</span>).iterator();         <span class="keyword">while</span> (iter.hasNext())&#123;             <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();             System.out.println(key+<span class="string">&quot;:&quot;</span>+jedis.hmget(<span class="string">&quot;user&quot;</span>,key));         &#125;      &#125;      <span class="comment">/**</span><span class="comment">     * jedis操作List</span><span class="comment">     */</span>     <span class="meta">@Test</span>     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;         <span class="comment">//开始前，先移除所有的内容 </span>        jedis.del(<span class="string">&quot;java framework&quot;</span>);         <span class="comment">// 第一个是key，第二个是起始位置，第三个是结束位置，jedis.llen获取长度 -1表示取得所有</span>        System.out.println(jedis.lrange(<span class="string">&quot;java framework&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));        <span class="comment">//先向key java framework中存放三条数据 </span>       jedis.lpush(<span class="string">&quot;java framework&quot;</span>,<span class="string">&quot;spring&quot;</span>);        jedis.lpush(<span class="string">&quot;java framework&quot;</span>,<span class="string">&quot;struts&quot;</span>);        jedis.lpush(<span class="string">&quot;java framework&quot;</span>,<span class="string">&quot;hibernate&quot;</span>);        <span class="comment">//再取出所有数据jedis.lrange是按范围取出， </span>       <span class="comment">// 第一个是key，第二个是起始位置，第三个是结束位置，jedis.llen获取长度 -1表示取得所有 </span>       System.out.println(jedis.lrange(<span class="string">&quot;java framework&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));     &#125;      <span class="comment">/**</span><span class="comment">     * jedis操作Set</span><span class="comment">     */</span>     <span class="meta">@Test</span>     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span>&#123;         <span class="comment">//添加 </span>        jedis.sadd(<span class="string">&quot;sname&quot;</span>,<span class="string">&quot;meepo&quot;</span>);         jedis.sadd(<span class="string">&quot;sname&quot;</span>,<span class="string">&quot;dota&quot;</span>);         jedis.sadd(<span class="string">&quot;sname&quot;</span>,<span class="string">&quot;poofu&quot;</span>);         jedis.sadd(<span class="string">&quot;sname&quot;</span>,<span class="string">&quot;noname&quot;</span>);        <span class="comment">//移除noname </span>        jedis.srem(<span class="string">&quot;sname&quot;</span>,<span class="string">&quot;noname&quot;</span>);         System.out.println(jedis.smembers(<span class="string">&quot;sname&quot;</span>));<span class="comment">//获取所有加入的value </span>        System.out.println(jedis.sismember(<span class="string">&quot;sname&quot;</span>, <span class="string">&quot;meepo&quot;</span>));<span class="comment">//判断 meepo 是否是sname集合的元素 </span>        System.out.println(jedis.srandmember(<span class="string">&quot;sname&quot;</span>));         System.out.println(jedis.scard(<span class="string">&quot;sname&quot;</span>));<span class="comment">//返回集合的元素个数 </span>    &#125;      <span class="meta">@Test</span>     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;         <span class="comment">//keys中传入的可以用通配符 </span>        System.out.println(jedis.keys(<span class="string">&quot;*&quot;</span>)); <span class="comment">//返回当前库中所有的key  [sose, sanme, name, dota, foo, sname, java framework, user, braand] </span>        System.out.println(jedis.keys(<span class="string">&quot;*name&quot;</span>));<span class="comment">//返回的sname   [sname, name] </span>        System.out.println(jedis.del(<span class="string">&quot;sanmdde&quot;</span>));<span class="comment">//删除key为sanmdde的对象  删除成功返回1 删除失败（或者不存在）返回 0 </span>        System.out.println(jedis.ttl(<span class="string">&quot;sname&quot;</span>));<span class="comment">//返回给定key的有效时间，如果是-1则表示永远有效 </span>        jedis.setex(<span class="string">&quot;timekey&quot;</span>, <span class="number">10</span>, <span class="string">&quot;min&quot;</span>);<span class="comment">//通过此方法，可以指定key的存活（有效时间） 时间为秒 </span>        Thread.sleep(<span class="number">5000</span>);<span class="comment">//睡眠5秒后，剩余时间将为&lt;=5 </span>        System.out.println(jedis.ttl(<span class="string">&quot;timekey&quot;</span>));   <span class="comment">//输出结果为5 </span>        jedis.setex(<span class="string">&quot;timekey&quot;</span>, <span class="number">1</span>, <span class="string">&quot;min&quot;</span>);        <span class="comment">//设为1后，下面再看剩余时间就是1了 </span>        System.out.println(jedis.ttl(<span class="string">&quot;timekey&quot;</span>));  <span class="comment">//输出结果为1 </span>        System.out.println(jedis.exists(<span class="string">&quot;key&quot;</span>));<span class="comment">//检查key是否存在 </span>        System.out.println(jedis.rename(<span class="string">&quot;timekey&quot;</span>,<span class="string">&quot;time&quot;</span>));         System.out.println(jedis.get(<span class="string">&quot;timekey&quot;</span>));<span class="comment">//因为移除，返回为null </span>        System.out.println(jedis.get(<span class="string">&quot;time&quot;</span>)); <span class="comment">//因为将timekey 重命名为time 所以可以取得值 min </span>         <span class="comment">//jedis 排序 </span>        <span class="comment">//注意，此处的rpush和lpush是List的操作。是一个双向链表（但从表现来看的） </span>        jedis.del(<span class="string">&quot;a&quot;</span>);<span class="comment">//先清除数据，再加入数据进行测试 </span>        jedis.rpush(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;1&quot;</span>);         jedis.lpush(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;6&quot;</span>);         jedis.lpush(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;3&quot;</span>);         jedis.lpush(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;9&quot;</span>);         System.out.println(jedis.lrange(<span class="string">&quot;a&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));<span class="comment">// [9, 3, 6, 1] </span>        System.out.println(jedis.sort(<span class="string">&quot;a&quot;</span>)); <span class="comment">//[1, 3, 6, 9]  //输入排序后结果 </span>        System.out.println(jedis.lrange(<span class="string">&quot;a&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));      &#125; &#125;</code></pre><h4 id="连接池连接"><a class="markdownIt-Anchor" href="#连接池连接"></a> 连接池连接</h4><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJedisPool</span><span class="params">()</span> &#123;<span class="comment">//创建一连接池对象</span><span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);<span class="comment">//从连接池中获得连接</span><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource();<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;key1&quot;</span>) ;System.out.println(result);<span class="comment">//关闭连接</span>jedis.close();<span class="comment">//关闭连接池</span>jedisPool.close();&#125;</code></pre><h4 id="spring整合jedispool"><a class="markdownIt-Anchor" href="#spring整合jedispool"></a> Spring整合JedisPool</h4><p>添加spring和jedis相关jar包的jar包</p><p><strong>配置spring配置文件</strong></p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd </span></span><span class="string"><span class="tag">http://www.springframework.org/schema/mvc </span></span><span class="string"><span class="tag">http://www.springframework.org/schema/mvc/spring-mvc.xsd </span></span><span class="string"><span class="tag">http://www.springframework.org/schema/context </span></span><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd </span></span><span class="string"><span class="tag">http://www.springframework.org/schema/aop </span></span><span class="string"><span class="tag">http://www.springframework.org/schema/aop/spring-aop.xsd </span></span><span class="string"><span class="tag">http://www.springframework.org/schema/tx </span></span><span class="string"><span class="tag">http://www.springframework.org/schema/tx/spring-tx.xsd &quot;</span>&gt;</span><span class="comment">&lt;!-- 连接池配置 --&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisPoolConfig&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisPoolConfig&quot;</span>&gt;</span><span class="comment">&lt;!-- 最大连接数 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxTotal&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span> /&gt;</span><span class="comment">&lt;!-- 最大空闲连接数 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span><span class="comment">&lt;!-- 每次释放连接的最大数目 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;numTestsPerEvictionRun&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1024&quot;</span> /&gt;</span><span class="comment">&lt;!-- 释放连接的扫描间隔（毫秒） --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30000&quot;</span> /&gt;</span><span class="comment">&lt;!-- 连接最小空闲时间 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1800000&quot;</span> /&gt;</span><span class="comment">&lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;softMinEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span><span class="comment">&lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWaitMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1500&quot;</span> /&gt;</span><span class="comment">&lt;!-- 在获取连接的时候检查有效性, 默认false --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span><span class="comment">&lt;!-- 在空闲时检查有效性, 默认false --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span><span class="comment">&lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;blockWhenExhausted&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="comment">&lt;!-- redis单机 通过连接池 --&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisPool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisPool&quot;</span></span><span class="tag"><span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;poolConfig&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jedisPoolConfig&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;host&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.242.130&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;port&quot;</span> <span class="attr">value</span>=<span class="string">&quot;6379&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></code></pre><p>测试代码</p><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJedisPool</span><span class="params">()</span> &#123;<span class="type">JedisPool</span> <span class="variable">pool</span> <span class="operator">=</span> (JedisPool) applicationContext.getBean(<span class="string">&quot;jedisPool&quot;</span>);<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="keyword">try</span> &#123;jedis = pool.getResource();jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lisi&quot;</span>);<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);System.out.println(name);&#125; <span class="keyword">catch</span> (Exception ex) &#123;ex.printStackTrace();&#125; <span class="keyword">finally</span> &#123;<span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;<span class="comment">// 关闭连接</span>jedis.close();&#125;&#125;&#125;</code></pre><h2 id="redis数据类型"><a class="markdownIt-Anchor" href="#redis数据类型"></a> Redis数据类型</h2><p>官方命令大全网址：<u><a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></u></p><p>Redis中存储数据是通过<strong>key-value</strong>格式存储数据的，其中value可以定义五种数据类型：</p><ul><li><p><strong>String（字符类型）</strong></p></li><li><p><strong>Hash（散列类型）</strong></p></li><li><p><strong>List（列表类型）</strong></p></li><li><p><strong>Set（集合类型）</strong></p></li><li><p><strong>SortedSet（有序集合类型，简称zset）</strong></p></li></ul><blockquote><p>注意：在redis中的命令语句中，命令是忽略大小写的，而key是不忽略大小写的</p></blockquote><h3 id="string-字符串"><a class="markdownIt-Anchor" href="#string-字符串"></a> String 字符串</h3><table><thead><tr><th>代码</th><th>解释</th></tr></thead><tbody><tr><td><strong>SET key value</strong></td><td><strong>赋值</strong>，设置key=value</td></tr><tr><td><strong>GET key</strong></td><td><strong>取值</strong>，获得键key对应的值</td></tr><tr><td>GETRANGE key start end</td><td>得到字符串的子字符串存放在一个键</td></tr><tr><td><strong>GETSET key value</strong></td><td><strong>取值并赋值</strong>，设置键的字符串值，并返回旧值</td></tr><tr><td>GETBIT key offset</td><td>返回存储在键位值的字符串值的偏移</td></tr><tr><td><strong>MGET key1 [key2…]</strong></td><td><strong>同时获取多个键值</strong>，得到所有的给定键的值</td></tr><tr><td>SETBIT key offset value</td><td>设置或清除该位在存储在键的字符串值偏移</td></tr><tr><td>SETEX key seconds value</td><td>键到期时设置值</td></tr><tr><td><strong>SETNX key value</strong></td><td><strong>仅当不存在时赋值</strong>，设置键的值，只有当该键不存在，<strong>该命令可以实现分布式锁的功能</strong></td></tr><tr><td>SETRANGE key offset value</td><td>覆盖字符串的一部分从指定键的偏移</td></tr><tr><td><strong>STRLEN key</strong></td><td><strong>获取字符串长度</strong>，得到存储在键的值的长度</td></tr><tr><td><strong>MSET key value [key value…]</strong></td><td><strong>同时设置多个键值</strong>设置多个键和多个值</td></tr><tr><td>MSETNX key value [key value…]</td><td>设置多个键多个值，只有在当没有按键的存在时</td></tr><tr><td>PSETEX key milliseconds value</td><td>设置键的毫秒值和到期时间</td></tr><tr><td><strong>INCR key</strong></td><td><strong>递增数字</strong>，增加键的整数值一次</td></tr><tr><td><strong>INCRBY key increment</strong></td><td><strong>增加指定的整数</strong>，由给定的数量递增键的整数值</td></tr><tr><td>INCRBYFLOAT key increment</td><td>由给定的数量递增键的浮点值</td></tr><tr><td><strong>DECR key</strong></td><td><strong>递减数字</strong>，递减键一次的整数值</td></tr><tr><td><strong>DECRBY key decrement</strong></td><td><strong>减少指定整数</strong>，由给定数目递减键的整数值</td></tr><tr><td><strong>APPEND key value</strong></td><td><strong>向尾部追加值</strong>，追加值到一个键</td></tr><tr><td>DEL key</td><td>如果存在删除键</td></tr><tr><td>DUMP key</td><td>返回存储在指定键的值的序列化版本</td></tr><tr><td>EXISTS key</td><td>此命令检查该键是否存在</td></tr><tr><td>EXPIRE key seconds</td><td>指定键的过期时间</td></tr><tr><td>EXPIREAT key timestamp</td><td>指定的键过期时间。在这里，时间是在Unix时间戳格式</td></tr><tr><td>PEXPIRE key milliseconds</td><td>设置键以毫秒为单位到期</td></tr><tr><td>PEXPIREAT key milliseconds-timestemp</td><td>设置键在Unix时间戳指定为毫秒到期</td></tr><tr><td>KEYS pattern</td><td>查找与指定模式匹配的所有键</td></tr><tr><td>MOVE key db</td><td>移动键到另一个数据库</td></tr><tr><td>PERSIST key</td><td>移除过期的键</td></tr><tr><td>PTTL key</td><td>以毫秒为单位获取剩余时间的到期键。</td></tr><tr><td>TTL key</td><td>获取键到期的剩余时间。</td></tr><tr><td>RANDOMKEY</td><td>从Redis返回随机键</td></tr><tr><td>RENAME key newkey</td><td>更改键的名称</td></tr><tr><td>RENAMENX key newkey</td><td>重命名键，如果新的键不存在</td></tr><tr><td>TYPE key</td><td>返回存储在键的数据类型的值。</td></tr></tbody></table><ul><li><strong>使用示例</strong></li></ul><p><strong>赋值</strong><br />语法：SET key value</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; set test 123OK</code></pre><p><strong>取值</strong><br />语法：GET key</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; get test&quot;123“</code></pre><p><strong>取值并赋值</strong><br />语法：GETSET key value</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; getset s2 222&quot;111&quot;127.0.0.1:6379&gt; get s2&quot;222&quot;</code></pre><p><strong>数值增减</strong><br />注意实现：</p><ol><li>当value为<strong>整数数据</strong>时，才能使用以下命令操作数值的增减。</li><li>数值递增都是<strong>原子</strong>操作。</li></ol><pre><code class="highlight plaintext">非原子性操作示例：可能多个线程同时访问时会得到相同的i，但我们期望每次访问都+1int i = 1;i++;System.out.println(i)</code></pre><ul><li><strong>递增数字</strong><br />语法：INCR key</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; incr num(integer) 1127.0.0.1:6379&gt; incr num(integer) 2127.0.0.1:6379&gt; incr num(integer) 3</code></pre><ul><li><strong>增加指定的整数</strong><br />语法：INCRBY key increment</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; incrby num 2(integer) 5127.0.0.1:6379&gt; incrby num 2(integer) 7127.0.0.1:6379&gt; incrby num 2(integer) 9</code></pre><ul><li><strong>递减数值</strong><br />语法：DECR key</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; decr num(integer) 9127.0.0.1:6379&gt; decr num(integer) 8</code></pre><ul><li><strong>减少指定的整数</strong><br />语法：DECRBY key decrement</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; decr num(integer) 6127.0.0.1:6379&gt; decr num(integer) 5127.0.0.1:6379&gt; decrby num 3(integer) 2127.0.0.1:6379&gt; decrby num 3(integer) -1</code></pre><p><strong>仅当不存在时赋值</strong><br />语法：setnx key value</p><pre><code class="highlight plaintext">redis&gt; EXISTS job                # job 不存在(integer) 0redis&gt; SETNX job &quot;programmer&quot;    # job 设置成功(integer) 1redis&gt; SETNX job &quot;code-farmer&quot;   # 尝试覆盖 job ，失败(integer) 0redis&gt; GET job                   # 没有被覆盖&quot;programmer&quot;</code></pre><p><strong>向尾部追加值</strong><br />APPEND命令，向键值的末尾追加value。如果键不存在则将该键的值设置为value，即相当于 SET key value。返回值是追加后字符串的总长度。</p><p>语法：APPEND key value</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; set str helloOK127.0.0.1:6379&gt; append str &quot; world!&quot;(integer) 12127.0.0.1:6379&gt; get str &quot;hello world!&quot;</code></pre><p><strong>获取字符串长度</strong><br />STRLEN命令，返回键值的长度，如果键不存在则返回0。</p><p>语法：STRLEN key</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; strlen str (integer) 0127.0.0.1:6379&gt; set str helloOK127.0.0.1:6379&gt; strlen str (integer) 5</code></pre><p><strong>同时设置/获取多个键值</strong><br />语法：<br />MSET key value [key value …]<br />MGET key [key …]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3OK127.0.0.1:6379&gt; get k1&quot;v1&quot;127.0.0.1:6379&gt; mget k1 k31) &quot;v1&quot;2) &quot;v3&quot;</code></pre><p><strong>应用场景之自增主键</strong></p><ul><li>需求：商品编号、订单号采用INCR命令生成。</li><li>设计：key命名要有一定的设计</li><li>实现：定义商品编号key：items:id</li></ul><pre><code class="highlight plaintext">192.168.101.3:7003&gt; INCR items:id(integer) 2192.168.101.3:7003&gt; INCR items:id(integer) 3</code></pre><h3 id="list-列表"><a class="markdownIt-Anchor" href="#list-列表"></a> List 列表</h3><p><strong>ArrayList和LinkedList的区别</strong></p><p>ArrayList使用<strong>数组方式</strong>存储数据，所以根据索引查询数据速度快，而新增或者删除元素时需要设计到位移操作，所以比较慢。</p><p>LinkedList使用<strong>双向链表</strong>方式存储数据，每个元素都记录前后元素的指针，所以插入、删除数据时只是更改前后元素的指针指向即可，速度非常快。然后通过下标查询元素时需要从头开始索引，所以比较慢，但是如果查询前几个元素或后几个元素速度比较快</p><hr /><p>Redis的列表类型（list）可以存储一个有序的字符串列表，常用的操作是<strong>向列表两端添加元素，或者获得列表的某一个片段</strong>。</p><p>列表类型内部是使用<strong>双向链表（double linked list）实现</strong>的，所以向列表两端添加元素的时间复杂度为0(1)，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的</p><table><thead><tr><th>代码</th><th>解释</th></tr></thead><tbody><tr><td>BLPOP key1 [key2 ] timeout</td><td>取出并获取列表中的第一个元素，或阻塞，直到有可用</td></tr><tr><td>BRPOP key1 [key2 ] timeout</td><td>取出并获取列表中的最后一个元素，或阻塞，直到有可用</td></tr><tr><td><strong>BRPOPLPUSH source destination timeout</strong></td><td><strong>将元素从一个列表转移到另一个列表中</strong>，从列表中弹出一个值，它推到另一个列表并返回它;或阻塞，直到有可用</td></tr><tr><td><strong>LINDEX key index</strong></td><td><strong>获取指定索引的元素值</strong>从一个列表其索引获取对应的元素</td></tr><tr><td><strong>LINSERT key BEFORE/AFTER pivot value</strong></td><td><strong>向列表中插入元素</strong>，在列表中的其他元素之后或之前插入一个元素</td></tr><tr><td><strong>LLEN key</strong></td><td><strong>获取列表的长度</strong></td></tr><tr><td><strong>LPOP key</strong></td><td><strong>获取并取出列表中的第一个元素，弹出元素</strong></td></tr><tr><td><strong>LPUSH key value1 [value2]</strong></td><td><strong>向列表左边增加元素</strong>,在前面加上一个或多个值的列表</td></tr><tr><td>LPUSHX key value</td><td>在前面加上一个值列表，仅当列表中存在</td></tr><tr><td><strong>LRANGE key start stop</strong></td><td>从一个列表获取各种元素</td></tr><tr><td><strong>LREM key count value</strong></td><td><strong>LREM命令会删除列表中前count个值为value的元素，返回实际删除的元素个数</strong>从列表中删除元素</td></tr><tr><td><strong>LSET key index value</strong></td><td><strong>指定一个索引的元素值</strong>，在列表中的索引设置一个元素的值</td></tr><tr><td><strong>LTRIM key start stop</strong></td><td><strong>只保留列表的指定片段</strong>，修剪列表到指定的范围内</td></tr><tr><td><strong>RPOP key</strong></td><td><strong>取出并获取列表中的最后一个元素，弹出元素</strong></td></tr><tr><td>RPOPLPUSH source destination</td><td>删除最后一个元素的列表，将其附加到另一个列表并返回它</td></tr><tr><td><strong>RPUSH key value1 [value2]</strong></td><td><strong>向列表右边增加元素</strong>，添加一个或多个值到列表</td></tr><tr><td>RPUSHX key value</td><td>添加一个值列表，仅当列表中存在</td></tr></tbody></table><ul><li><strong>使用示例</strong></li></ul><p><strong>向列表两端增加元素</strong></p><ul><li><strong>向列表左边增加元素</strong><br />语法：LPUSH key value [value …]</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; lpush list:1 1 2 3(integer) 3</code></pre><ul><li><strong>向列表右边增加元素</strong><br />语法：RPUSH key value [value …]</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; rpush list:1 4 5 6(integer) 3</code></pre><p><strong>查看列表</strong><br />语法：LRANGE key start stop<br />LRANGE命令是列表类型最常用的命令之一，获取列表中的某一片段，将返回start、stop之间的所有元素（包含两端的元素），索引从0开始。索引可以是负数，如：“-1”代表最后边的一个元素。</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; lrange list:1 0 21) &quot;2&quot;2) &quot;1&quot;3) &quot;4&quot;</code></pre><p><strong>从列表两端弹出元素</strong><br />LPOP命令从列表左边弹出一个元素，会分两步完成：</p><ol><li>第一步是将列表左边的元素从列表中移除</li><li>第二步是返回被移除的元素值。</li></ol><p>语法：<br />LPOP key<br />RPOP key</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; lpop list:1&quot;3“127.0.0.1:6379&gt; rpop list:1&quot;6“</code></pre><p><strong>获取列表中元素的个数</strong><br />语法：LLEN key</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; llen list:1(integer) 2</code></pre><p><strong>删除列表中指定个数的值</strong><br />LREM命令会删除列表中前count个值为value的元素，返回实际删除的元素个数。根据count值的不同，该命令的执行方式会有所不同：</p><ol><li>当count&gt;0时， LREM会从列表左边开始删除。</li><li>当count&lt;0时， LREM会从列表后边开始删除。</li><li>当count=0时， LREM删除所有值为value的元素。</li></ol><p>语法：LREM key count value</p><p><strong>获得/设置指定索引的元素值</strong></p><ul><li><strong>获得指定索引的元素值</strong><br />语法：LINDEX key index</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; lindex l:list 2&quot;1&quot;</code></pre><ul><li><strong>设置指定索引的元素值</strong><br />语法：LSET key index value</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; lset l:list 2 2OK127.0.0.1:6379&gt; lrange l:list 0 -11) &quot;6&quot;2) &quot;5&quot;3) &quot;2&quot;4) &quot;2&quot;</code></pre><p><strong>只保留列表指定片段</strong><br />指定范围和LRANGE一致</p><p>语法：LTRIM key start stop</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; lrange l:list 0 -11) &quot;6&quot;2) &quot;5&quot;3) &quot;0&quot;4) &quot;2&quot;127.0.0.1:6379&gt; ltrim l:list 0 2OK127.0.0.1:6379&gt; lrange l:list 0 -11) &quot;6&quot;2) &quot;5&quot;3) &quot;0&quot;</code></pre><p><strong>向列表中插入元素</strong><br />该命令首先会在列表中从左到右查找值为pivot的元素，然后根据第二个参数是BEFORE还是AFTER来决定将value插入到该元素的前面还是后面。</p><p>语法：LINSERT key BEFORE|AFTER pivot value</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; lrange list 0 -11) &quot;3&quot;2) &quot;2&quot;3) &quot;1&quot;127.0.0.1:6379&gt; linsert list after 3 4(integer) 4127.0.0.1:6379&gt; lrange list 0 -11) &quot;3&quot;2) &quot;4&quot;3) &quot;2&quot;4) &quot;1&quot;</code></pre><p><strong>将元素从一个列表转移到另一个列表中</strong><br />语法：RPOPLPUSH source destination</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; rpoplpush list newlist &quot;1&quot;127.0.0.1:6379&gt; lrange newlist 0 -11) &quot;1&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;3&quot;2) &quot;4&quot;3) &quot;2&quot;</code></pre><p><strong>应用之商品评论列表</strong></p><ul><li>需求1：用户针对某一商品发布评论，一个商品会被不同的用户进行评论，存储商品评论时，要按时间顺序排序。</li><li>需求2：用户在前端页面查询该商品的评论，需要安装时间顺序降序排序。</li></ul><p>思路：</p><ol><li>使用list存储商品评论信息，KEY是该商品的ID，VALUE是商品评论信息列表</li><li>商品编号为1001的商品评论key【items: comment:1001】</li></ol><pre><code class="highlight plaintext">192.168.101.3:7001&gt; LPUSH items:comment:1001 &#x27;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;商品不错，很好！！&quot;,&quot;date&quot;:1430295077289&#125;&#x27;</code></pre><h3 id="hash-哈希表"><a class="markdownIt-Anchor" href="#hash-哈希表"></a> Hash 哈希表</h3><p>hash叫<strong>散列类型</strong>，它提供了字段和字段值的映射。字段值只能是字符串类型，不支持散列类型、集合类型等其它类型</p><table><thead><tr><th>代码</th><th>命令</th></tr></thead><tbody><tr><td><strong>HDEL key field[field…]</strong></td><td><strong>删除一个或多个字段，返回值是被删除的字段个数</strong>，删除对象的一个或几个属性域，不存在的属性将被忽略</td></tr><tr><td><strong>HEXISTS key field</strong></td><td><strong>判断字段是否存在</strong>，查看对象是否存在该属性域</td></tr><tr><td><strong>HGET key field</strong></td><td><strong>一次获取一个字段值</strong>，获取对象中该field属性域的值</td></tr><tr><td><strong>HGETALL key</strong></td><td><strong>获取所有字段的key和value</strong>，获取对象的所有属性域和值</td></tr><tr><td><strong>HINCRBY key field value increment</strong></td><td><strong>增加数字</strong>，将该对象中指定域的值增加给定的value，原子自增操作，只能是integer的属性值可以使用</td></tr><tr><td>HINCRBYFLOAT key field increment</td><td>将该对象中指定域的值增加给定的浮点数</td></tr><tr><td><strong>HKEYS key</strong></td><td><strong>只获取字段名</strong>，获取对象的所有属性字段</td></tr><tr><td><strong>HVALS key</strong></td><td><strong>只获取字段值</strong>，获取对象的所有属性值</td></tr><tr><td><strong>HLEN key</strong></td><td><strong>获取字段数量</strong>，获取对象的所有属性字段的总数</td></tr><tr><td><strong>HMGET key field[field…]</strong></td><td><strong>一次获取多个字段的值</strong>，获取对象的一个或多个指定字段的值</td></tr><tr><td><strong>HSET key field value</strong></td><td><strong>设置一个字段的值</strong>，设置对象指定字段的值</td></tr><tr><td><strong>HMSET key field value [field value …]</strong></td><td><strong>设置多个字段的值</strong>，同时设置对象中一个或多个字段的值</td></tr><tr><td><strong>HSETNX key field value</strong></td><td><strong>当字段不存在时赋值</strong>，只在对象不存在指定的字段时才设置字段的值</td></tr><tr><td>HSTRLEN key field</td><td>返回对象指定field的value的字符串长度，如果该对象或者field不存在，返回0.</td></tr><tr><td>HSCAN key cursor [MATCH pattern] [COUNT count]</td><td>类似SCAN命令</td></tr></tbody></table><ul><li><strong>使用示例</strong></li></ul><p><strong>赋值</strong><br />HSET命令不区分插入和更新操作，当执行插入操作时HSET命令返回1，当执行更新操作时返回0。</p><ul><li><strong>一次只能设置一个字段值</strong><br />语法：HSET key field value</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; hset user username zhangsan (integer) 1</code></pre><ul><li><strong>一次可以设置多个字段值</strong><br />语法：HMSET key field value [field value …]</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; hmset user age 20 username lisi OK</code></pre><ul><li><strong>当字段不存在时赋值</strong>，类似HSET，区别在于如果字段存在，该命令不执行任何操作<br />语法：HSETNX key field value</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; hsetnx user age 30如果user中没有age字段则设置age值为30，否则不做任何操作(integer) 0</code></pre><p><strong>取值</strong></p><ul><li><strong>一次只能获取一个字段值</strong><br />语法：HGET key field</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; hget user username&quot;zhangsan“</code></pre><ul><li><strong>一次可以获取多个字段值</strong><br />语法：HMGET key field [field …]</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; hmget user age username1) &quot;20&quot;2) &quot;lisi&quot;</code></pre><ul><li><strong>获取所有字段值</strong><br />语法：HGETALL key</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; hgetall user1) &quot;age&quot;2) &quot;20&quot;3) &quot;username&quot;4) &quot;lisi&quot;</code></pre><p><strong>删除字段</strong><br />可以删除一个或多个字段，返回值是被删除的字段个数</p><p>语法：HDEL key field [field …]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; hdel user age(integer) 1127.0.0.1:6379&gt; hdel user age name(integer) 0127.0.0.1:6379&gt; hdel user age username(integer) 1</code></pre><p><strong>增加数字</strong><br />语法：HINCRBY key field increment</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; hincrby user age 2将用户的年龄加2(integer) 22127.0.0.1:6379&gt; hget user age获取用户的年龄&quot;22“</code></pre><p><strong>判断字段是否存在</strong><br />语法：HEXISTS key field</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; hexists user age查看user中是否有age字段(integer) 1127.0.0.1:6379&gt; hexists user name查看user中是否有name字段(integer) 0</code></pre><p><strong>只获取字段名或字段值</strong><br />语法：<br />HKEYS key<br />HVALS key</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; hmset user age 20 name lisi OK127.0.0.1:6379&gt; hkeys user1) &quot;age&quot;2) &quot;name&quot;127.0.0.1:6379&gt; hvals user1) &quot;20&quot;2) &quot;lisi&quot;</code></pre><p><strong>获取字段数量</strong><br />语法：HLEN key</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; hlen user(integer) 2</code></pre><p><strong>获取所有字段</strong><br />作用：获得hash的所有信息，包括key和value<br />语法：hgetall key</p><p><strong>应用之存储商品信息</strong><br />注意事项：存储那些对象数据，特别是对象属性经常发生增删改操作的数据。</p><ul><li><p>商品信息字段<br />【商品id、商品名称、商品描述、商品库存、商品好评】</p></li><li><p>定义商品信息的key<br />商品ID为1001的信息在 Redis中的key为：[items:1001]</p></li></ul><p>存储商品信息</p><pre><code class="highlight plaintext">192.168.101.3:7003&gt; HMSET items:1001 id 3 name apple price 999.9OK</code></pre><p>获取商品信息</p><pre><code class="highlight plaintext">192.168.101.3:7003&gt; HGET items:1001 id&quot;3&quot;192.168.101.3:7003&gt; HGETALL items:10011) &quot;id&quot;2) &quot;3&quot;3) &quot;name&quot;4) &quot;apple&quot;5) &quot;price&quot;6) &quot;999.9&quot;</code></pre><h3 id="set-集合"><a class="markdownIt-Anchor" href="#set-集合"></a> set 集合</h3><p>set类型即<strong>集合类型</strong>，其中的数据是<strong>不重复且没有顺序</strong></p><p>集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型的Redis内部是使用值为空的散列表实现，所有这些操作的时间复杂度都为0(1)。</p><p>Redis还提供了多个集合之间的交集、并集、差集的运算。</p><table><thead><tr><th>代码</th><th>解释</th></tr></thead><tbody><tr><td><strong>SADD key member [member …]</strong></td><td><strong>增加元素</strong>，添加一个或者多个元素到集合(set)里，已存在的元素忽略</td></tr><tr><td><strong>SCARD key</strong></td><td><strong>获取集合里面的元素数量</strong></td></tr><tr><td><strong>SDIFF key [key …]</strong></td><td><strong>属于A并且不属于B的元素构成的集合</strong>，获得队列不存在的元素</td></tr><tr><td>SDIFFSTORE destination key [key …]</td><td>获得队列不存在的元素，并存储在一个关键的结果集</td></tr><tr><td><strong>SINTER key [key …]</strong></td><td><strong>获得两个集合的交集</strong></td></tr><tr><td>SINTERSTORE destination key [key …]</td><td>获得两个集合的交集，并存储在一个集合中</td></tr><tr><td><strong>SISMEMBER key member</strong></td><td><strong>判断元素是否再集合中</strong>，确定一个给定的值是一个集合的成员</td></tr><tr><td><strong>SMEMBERS key</strong></td><td><strong>获取集合里面的所有元素</strong></td></tr><tr><td>SMOVE source destination member</td><td>移动集合里面的一个key到另一个集合</td></tr><tr><td><strong>SPOP key [count]</strong></td><td><strong>从集合中弹出一个元素</strong>，获取并删除一个集合里面的元素，注意：由于集合是无序的，所有SPOP命令会从集合中随机选择一个元素弹出</td></tr><tr><td>SRANDMEMBER key [count]</td><td>从集合里面随机获取一个元素</td></tr><tr><td><strong>SREM key member [member …]</strong></td><td><strong>删除元素</strong>，从集合里删除一个或多个元素，不存在的元素会被忽略</td></tr><tr><td><strong>SUNION key [key …]</strong></td><td><strong>A和B的并集，属于A或者属于B的元素构成的集合</strong>，添加多个set元素</td></tr><tr><td>SUNIONSTORE destination key [key …]</td><td>合并set元素，并将结果存入新的set里面</td></tr><tr><td>SSCAN key cursor [MATCH pattern] [COUNT count]</td><td>迭代set里面的元素</td></tr></tbody></table><ul><li><strong>使用示例</strong></li></ul><p><strong>增加/删除元素</strong><br />语法：SADD key member [member …]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; sadd set a b c(integer) 3127.0.0.1:6379&gt; sadd set a(integer) 0</code></pre><p>语法：SREM key member [member …]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; srem set c d(integer) 1</code></pre><p><strong>获得集合中的所有元素</strong><br />语法：SMEMBERS key</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; smembers set1) &quot;b&quot;2) &quot;a”</code></pre><p><strong>判断元素是否在集合中</strong><br />语法：SISMEMBER key member</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; sismember set a(integer) 1127.0.0.1:6379&gt; sismember set h(integer) 0</code></pre><p><strong>集合运算命令</strong></p><ul><li><strong>集合的差集运算 A-B</strong><br />属于A并且不属于B的元素构成的集合。</li></ul><p>语法：SDIFF key [key …]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; sadd setA 1 2 3(integer) 3127.0.0.1:6379&gt; sadd setB 2 3 4(integer) 3127.0.0.1:6379&gt; sdiff setA setB 1) &quot;1&quot;127.0.0.1:6379&gt; sdiff setB setA 1) &quot;4&quot;</code></pre><ul><li><strong>集合的交集运算 A ∩ B</strong><br />属于A且属于B的元素构成的集合。</li></ul><p>语法：SINTER key [key …]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; sinter setA setB 1) &quot;2&quot;2) &quot;3&quot;</code></pre><ul><li><strong>集合的并集运算 A ∪ B</strong><br />属于A或者属于B的元素构成的集合（结果也无重复值）</li></ul><p>语法：SUNION key [key …]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; sunion setA setB1) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;4) &quot;4&quot;</code></pre><p><strong>获得集合中元素的个数</strong><br />语法：SCARD key</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; smembers setA 1) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;127.0.0.1:6379&gt; scard setA (integer) 3</code></pre><p><strong>从集合中弹出一个元素</strong><br />注意：由于集合是无序的，所有SPOP命令会从集合中随机选择一个元素弹出</p><p>语法：SPOP key</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; spop setA &quot;1“</code></pre><h3 id="zsetsorted-set有序集合"><a class="markdownIt-Anchor" href="#zsetsorted-set有序集合"></a> Zset(Sorted Set)有序集合</h3><p>在集合类型的基础上，有序集合类型为集合中的<strong>每个元素都关联一个分数</strong>，这使得我们不仅可以完成插入、删除和判断元素是否存在在集合中，还能够获得分数最高或最低的前N个元素、获取指定分数范围内的元素等与分数有关的操作。</p><p>在某些方面有序集合和列表类型有些<strong>相似</strong>。</p><ol><li><p>二者都是有序的。</p></li><li><p>二者都可以获得某一范围的元素。</p></li></ol><p>但是，二者有着很大<strong>区别</strong>：</p><ol><li><p>列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会变慢。</p></li><li><p>有序集合类型使用散列表实现，所有即使读取位于中间部分的数据也很快。</p></li><li><p>列表中不能简单的调整某个元素的位置，但是有序集合可以（通过更改分数实现）</p></li><li><p>有序集合要比列表类型更耗内存。</p></li></ol><table><thead><tr><th>代码</th><th>解释</th></tr></thead><tbody><tr><td><strong>ZADD key score1 member1 [score2 member2]</strong></td><td><strong>增加元素</strong>，添加一个或多个成员到有序集合，或者如果它已经存在更新其分数</td></tr><tr><td><strong>ZCARD key</strong></td><td><strong>得到的有序集合成员的数量</strong></td></tr><tr><td><strong>ZCOUNT key min max</strong></td><td><strong>获得指定分数范围内的元素个数</strong>，计算一个有序集合成员与给定值范围内的分数</td></tr><tr><td><strong>ZINCRBY key increment member</strong></td><td><strong>增加某个元素的分数</strong>，在有序集合增加成员的分数</td></tr><tr><td>ZINTERSTORE destination numkeys key [key …]</td><td>多重交叉排序集合，并存储生成一个新的键有序集合。</td></tr><tr><td>ZLEXCOUNT key min max</td><td>计算一个给定的字典范围之间的有序集合成员的数量</td></tr><tr><td><strong>ZRANGE key start stop [WITHSCORES]</strong></td><td><strong>获取排名再某个范围内的元素列表</strong>，由索引返回一个成员范围的有序集合（从低到高）</td></tr><tr><td>ZRANGEBYLEX key min max [LIMIT offset count]</td><td>返回一个成员范围的有序集合（由字典范围）</td></tr><tr><td><strong>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</strong></td><td><strong>获取指定分数范围内的元素</strong>，返回有序集key中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员，有序集成员按 score 值递增(从小到大)次序排列</td></tr><tr><td><strong>ZRANK key member</strong></td><td><strong>获取元素的排名（从小到大）</strong>，确定成员的索引中有序集合</td></tr><tr><td><strong>ZREM key member [member …]</strong></td><td><strong>删除元素</strong>，从有序集合中删除一个或多个成员，不存在的成员将被忽略</td></tr><tr><td>ZREMRANGEBYLEX key min max</td><td>删除所有成员在给定的字典范围之间的有序集合</td></tr><tr><td><strong>ZREMRANGEBYRANK key start stop</strong></td><td><strong>按照排名范围删除元素</strong>，在给定的索引之内删除所有成员的有序集合</td></tr><tr><td><strong>ZREMRANGEBYSCORE key min max</strong></td><td><strong>按照分数范围删除元素</strong>，在给定的分数之内删除所有成员的有序集合</td></tr><tr><td>ZREVRANGE key start stop [WITHSCORES]</td><td>返回一个成员范围的有序集合，通过索引，以分数排序，从高分到低分</td></tr><tr><td>ZREVRANGEBYSCORE key max min [WITHSCORES]</td><td>返回一个成员范围的有序集合，以socre排序从高到低</td></tr><tr><td><strong>ZREVRANK key member</strong></td><td><strong>获取元素的排名（）从大到小</strong>，确定一个有序集合成员的索引，以分数排序，从高分到低分</td></tr><tr><td><strong>ZSCORE key member</strong></td><td><strong>获取元素的分数</strong>，获取给定成员相关联的分数在一个有序集合</td></tr><tr><td>ZUNIONSTORE destination numkeys key [key …]</td><td>添加多个集排序，所得排序集合存储在一个新的键</td></tr><tr><td>ZSCAN key cursor [MATCH pattern] [COUNT count]</td><td>增量迭代排序元素集和相关的分数</td></tr></tbody></table><ul><li><strong>使用示例</strong></li></ul><p><strong>增加元素</strong><br />向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。</p><p>语法：ZADD key score member [score member …]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; zadd scoreboard 80 zhangsan 89 lisi 94 wangwu (integer) 3127.0.0.1:6379&gt; zadd scoreboard 97 lisi (integer) 0</code></pre><p><strong>获得排名在某个范围的元素列表</strong></p><ul><li>按照元素分数<strong>从小到大</strong>的顺序返回索引从start到stop之间的所有元素（包含两端的元素）</li></ul><p>语法：ZRANGE key start stop [WITHSCORES]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; zrange scoreboard 0 21) &quot;zhangsan&quot;2) &quot;wangwu&quot;3) &quot;lisi“</code></pre><ul><li>按照元素分数<strong>从大到小</strong>的顺序返回索引从start到stop之间的所有元素（包含两端的元素）</li></ul><p>语法：ZREVRANGE key start stop [WITHSCORES]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; zrevrange scoreboard 0 21) &quot; lisi &quot;2) &quot;wangwu&quot;3) &quot; zhangsan “</code></pre><blockquote><p>如果需要获得元素的分数的可以在命令尾部加上WITHSCORES参数</p></blockquote><pre><code class="highlight plaintext">127.0.0.1:6379&gt; zrange scoreboard 0 1 WITHSCORES1) &quot;zhangsan&quot;2) &quot;80&quot;3) &quot;wangwu&quot;4) &quot;94&quot;</code></pre><p><strong>获取元素的分数</strong><br />语法：ZSCORE key member</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; zscore scoreboard lisi &quot;97&quot;</code></pre><p><strong>删除元素</strong><br />移除有序集key中的一个或多个成员，不存在的成员将被忽略。<br />当key存在但不是有序集类型时，返回一个错误。</p><p>语法：ZREM key member [member …]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; zrem scoreboard lisi(integer) 1</code></pre><p><strong>获得指定分数范围的元素</strong><br />语法：ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 90 97 WITHSCORES1) &quot;wangwu&quot;2) &quot;94&quot;3) &quot;lisi&quot;4) &quot;97&quot;127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 70 100 limit 1 21) &quot;wangwu&quot;2) &quot;lisi&quot;</code></pre><p><strong>增加某个元素的分数</strong><br />返回值是更改后的分数</p><p>语法：ZINCRBY  key increment member</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; ZINCRBY scoreboard 4 lisi &quot;101“</code></pre><p><strong>获得集合中元素的数量</strong><br />语法：ZCARD key</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; ZCARD scoreboard(integer) 3</code></pre><p><strong>获得指定分数范围内的元素个数</strong><br />语法：ZCOUNT key min max</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; ZCOUNT scoreboard 80 90(integer) 1</code></pre><p><strong>按照排名范围删除元素</strong><br />语法：ZREMRANGEBYRANK key start stop</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; ZREMRANGEBYRANK scoreboard 0 1(integer) 2 127.0.0.1:6379&gt; ZRANGE scoreboard 0 -11) &quot;lisi&quot;</code></pre><p><strong>按照分数范围删除元素</strong><br />语法：ZREMRANGEBYSCORE key min max</p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; zadd scoreboard 84 zhangsan(integer) 1127.0.0.1:6379&gt; ZREMRANGEBYSCORE scoreboard 80 100(integer) 1</code></pre><p><strong>获取元素的排名</strong></p><ul><li><strong>从小到大</strong><br />语法：ZRANK key member</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; ZRANK scoreboard lisi (integer) 0</code></pre><ul><li><strong>从大到小</strong><br />语法：ZREVRANK key member</li></ul><pre><code class="highlight plaintext">127.0.0.1:6379&gt; ZREVRANK scoreboard zhangsan (integer) 1</code></pre><p><strong>应用之商品销售排行榜</strong></p><ul><li>需求：根据商品销售量对商品进行排行显示</li><li>思路：定义商品销售排行榜（sorted set集合），Key为items:sellsort，分数为商品销售量。</li></ul><p>写入商品销售量：</p><ul><li>商品编号1001的销量是9，商品编号1002的销量是10</li></ul><pre><code class="highlight plaintext">192.168.101.3:7007&gt; ZADD items:sellsort 9 1001 10 1002</code></pre><ul><li>商品编号1001的销量加1</li></ul><pre><code class="highlight plaintext">192.168.101.3:7001&gt; ZINCRBY items:sellsort 1 1001</code></pre><ul><li>商品销量前10名：</li></ul><pre><code class="highlight plaintext">192.168.101.3:7001&gt; ZRANGE items:sellsort 0 9 withscores</code></pre><h3 id="通用命令"><a class="markdownIt-Anchor" href="#通用命令"></a> 通用命令</h3><p><strong>keys pattern</strong></p><p>返回满足给定pattern的所有key</p><pre><code class="highlight redis">redis 127.0.0.1:6379&gt; keys mylist*1) &quot;mylist&quot;2) &quot;mylist5&quot;3) &quot;mylist6&quot;4) &quot;mylist7&quot;5) &quot;mylist8&quot;</code></pre><p><strong>DEL key</strong></p><pre><code class="highlight plaintext">127.0.0.1:6379&gt; del test(integer) 1</code></pre><p><strong>exists key</strong></p><p>确认一个key是否存在</p><pre><code class="highlight plaintext">redis 127.0.0.1:6379&gt; exists HongWan(integer) 0redis 127.0.0.1:6379&gt; exists age(integer) 1</code></pre><p><strong>expire</strong></p><p>Redis在实际使用过程中更多的用作缓存，然而缓存的数据一般都是需要设置生存时间的，即：到期后数据销毁</p><ul><li><strong>expire key seconds</strong> 设置key的生存实践（单位：秒）key再多少秒之后会自动删除</li><li><strong>ttl key</strong> 查看key剩余的生存时间</li><li><strong>persist key</strong> 清除生存时间</li><li><strong>pexpire key milliseconds</strong> 设置时间单位为毫秒</li></ul><pre><code class="highlight plaintext">192.168.101.3:7002&gt; set test 1             设置test的值为1OK192.168.101.3:7002&gt; get test                获取test的值&quot;1&quot;192.168.101.3:7002&gt; EXPIRE test 5     设置test的生存时间为5秒(integer) 1192.168.101.3:7002&gt; TTL test                     查看test的生于生成时间还有1秒删除(integer) 1192.168.101.3:7002&gt; TTL test(integer) -2192.168.101.3:7002&gt; get test                获取test的值，已经删除(nil)</code></pre><p><strong>rename oldkey  newkey</strong></p><p>重命名key</p><pre><code class="highlight plaintext">redis 127.0.0.1:6379[1]&gt; keys *1) &quot;age&quot;redis 127.0.0.1:6379[1]&gt; rename age age_newOKredis 127.0.0.1:6379[1]&gt; keys *1) &quot;age_new&quot;redis 127.0.0.1:6379[1]&gt;</code></pre><p><strong>type key</strong></p><p>显示指定key的数据类型</p><pre><code class="highlight plaintext">redis 127.0.0.1:6379&gt; type addrstringredis 127.0.0.1:6379&gt; type myzset2zsetredis 127.0.0.1:6379&gt; type mylistlist</code></pre><h2 id="redis-spring-集成"><a class="markdownIt-Anchor" href="#redis-spring-集成"></a> Redis Spring 集成</h2><h3 id="导入相关jar包"><a class="markdownIt-Anchor" href="#导入相关jar包"></a> 导入相关jar包</h3><ul><li>spring相关jar包</li><li>Jedis相关jar包</li></ul><h3 id="redisproperties"><a class="markdownIt-Anchor" href="#redisproperties"></a> redis.properties</h3><ul><li>指定连接Redis服务器的相关信息</li></ul><pre><code class="highlight properties"><span class="comment">#ip地址</span><span class="attr">redis.hostName</span>=<span class="string">127.0.0.1</span><span class="comment">#端口号</span><span class="attr">redis.port</span>=<span class="string">6379</span><span class="comment">#如果有密码</span><span class="attr">redis.password</span>=<span class="string"></span><span class="comment">#客户端超时时间单位是毫秒 默认是2000</span><span class="attr">redis.timeout</span>=<span class="string">2000</span><span class="comment"> </span><span class="comment">#最大空闲数</span><span class="attr">redis.maxIdle</span>=<span class="string">10</span><span class="comment">#连接池的最大数据库连接数。设为0表示无限制,如果是jedis 2.4以后用redis.maxTotal</span><span class="attr">redis.maxActive</span>=<span class="string">10</span><span class="comment">#控制一个pool可分配多少个jedis实例,用来替换上面的redis.maxActive,如果是jedis 2.4以后用该属性</span><span class="attr">redis.maxTotal</span>=<span class="string">10</span><span class="comment">#最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制。</span><span class="attr">redis.maxWaitMillis</span>=<span class="string">1000</span><span class="comment">#连接的最小空闲时间 默认1800000毫秒(30分钟)</span><span class="attr">redis.minEvictableIdleTimeMillis</span>=<span class="string">300000</span><span class="comment">#每次释放连接的最大数目,默认3</span><span class="attr">redis.numTestsPerEvictionRun</span>=<span class="string">1024</span><span class="comment">#逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1</span><span class="attr">redis.timeBetweenEvictionRunsMillis</span>=<span class="string">30000</span><span class="comment">#是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个</span><span class="attr">redis.testOnBorrow</span>=<span class="string">false</span><span class="comment">#在空闲时检查有效性, 默认false</span><span class="attr">redis.testWhileIdle</span>=<span class="string">false</span></code></pre><h3 id="applicationcontextxml"><a class="markdownIt-Anchor" href="#applicationcontextxml"></a> applicationContext.xml</h3><ul><li>配置连接池，连接工厂等，以上都是为了<br />RedisTemplate服务，这个类就是提供常用的Redis方法</li><li>然后又把这个 RedisTemplate 类的实例，注入到 RedisUtil 工具类里，方便调用</li></ul><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span> <span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>   </span><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span>   </span><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span>   </span><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span>   </span><span class="tag">    <span class="attr">xmlns:cache</span>=<span class="string">&quot;http://www.springframework.org/schema/cache&quot;</span> </span><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans     </span></span><span class="string"><span class="tag">                        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd     </span></span><span class="string"><span class="tag">                        http://www.springframework.org/schema/context     </span></span><span class="string"><span class="tag">                        http://www.springframework.org/schema/context/spring-context-4.2.xsd     </span></span><span class="string"><span class="tag">                        http://www.springframework.org/schema/mvc     </span></span><span class="string"><span class="tag">                        http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd </span></span><span class="string"><span class="tag">                        http://www.springframework.org/schema/cache  </span></span><span class="string"><span class="tag">                        http://www.springframework.org/schema/cache/spring-cache-4.2.xsd&quot;</span>&gt;</span>     <span class="comment">&lt;!-- 加载配置文件 --&gt;</span>    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:*.properties&quot;</span> /&gt;</span>    <span class="comment">&lt;!-- redis连接池配置--&gt;</span>     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisPoolConfig&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisPoolConfig&quot;</span> &gt;</span>         <span class="comment">&lt;!--最大空闲数--&gt;</span>         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.maxIdle&#125;&quot;</span> /&gt;</span>         <span class="comment">&lt;!--连接池的最大数据库连接数  --&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxTotal&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.maxTotal&#125;&quot;</span> /&gt;</span>        <span class="comment">&lt;!--最大建立连接等待时间--&gt;</span>         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWaitMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.maxWaitMillis&#125;&quot;</span> /&gt;</span>         <span class="comment">&lt;!--逐出连接的最小空闲时间 默认1800000毫秒(30分钟)--&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.minEvictableIdleTimeMillis&#125;&quot;</span> /&gt;</span>        <span class="comment">&lt;!--每次逐出检查时 逐出的最大数目 如果为负数就是 : 1/abs(n), 默认3--&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;numTestsPerEvictionRun&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.numTestsPerEvictionRun&#125;&quot;</span> /&gt;</span>        <span class="comment">&lt;!--逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1--&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.timeBetweenEvictionRunsMillis&#125;&quot;</span> /&gt;</span>        <span class="comment">&lt;!--是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个--&gt;</span>         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.testOnBorrow&#125;&quot;</span> /&gt;</span>         <span class="comment">&lt;!--在空闲时检查有效性, 默认false  --&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.testWhileIdle&#125;&quot;</span> /&gt;</span>     &lt;/bean &gt;         <span class="comment">&lt;!--redis连接工厂 --&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisConnectionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;poolConfig&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jedisPoolConfig&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="comment">&lt;!--IP地址 --&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hostName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.hostName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="comment">&lt;!--端口号  --&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;port&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.port&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="comment">&lt;!--如果Redis设置有密码  --&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.password&#125;&quot;</span> /&gt;</span>        <span class="comment">&lt;!--客户端超时时间单位是毫秒  --&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.timeout&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>          <span class="comment">&lt;!--redis操作模版,使用该对象可以操作redis  --&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;redisTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.core.RedisTemplate&quot;</span></span><span class="tag">        <span class="attr">p:connection-factory-ref</span>=<span class="string">&quot;jedisConnectionFactory&quot;</span> &gt;</span>         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;keySerializer&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">bean</span></span><span class="tag">                <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hashKeySerializer&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">bean</span></span><span class="tag">                <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;valueSerializer&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">bean</span></span><span class="tag">                <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.serializer.JdkSerializationRedisSerializer&quot;</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hashValueSerializer&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">bean</span></span><span class="tag">                <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.serializer.JdkSerializationRedisSerializer&quot;</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>    &lt;/bean &gt;          <span class="comment">&lt;!--自定义redis工具类,在需要缓存的地方注入此类  --&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;redisUtil&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.how2java.RedisUtil&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;redisTemplate&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;redisTemplate&quot;</span> /&gt;</span>    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>     <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></code></pre><h3 id="redisutil"><a class="markdownIt-Anchor" href="#redisutil"></a> RedisUtil</h3><ul><li>RedisUtil工具类，封装了Redis Template这个类，以提供更为便利的对于Redis的访问</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.how2java; <span class="keyword">import</span> java.util.List;<span class="keyword">import</span> java.util.Map;<span class="keyword">import</span> java.util.Set;<span class="keyword">import</span> java.util.concurrent.TimeUnit; <span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<span class="keyword">import</span> org.springframework.util.CollectionUtils; <span class="comment">/**</span><span class="comment"> * 基于spring和redis的redisTemplate工具类</span><span class="comment"> * 针对所有的hash 都是以h开头的方法</span><span class="comment"> * 针对所有的Set 都是以s开头的方法                    不含通用方法</span><span class="comment"> * 针对所有的List 都是以l开头的方法</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisUtil</span> &#123;    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRedisTemplate</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;        <span class="built_in">this</span>.redisTemplate = redisTemplate;    &#125;    <span class="comment">//=============================common============================</span>    <span class="comment">/**</span><span class="comment">     * 指定缓存失效时间</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">expire</span><span class="params">(String key,<span class="type">long</span> time)</span>&#123;        <span class="keyword">try</span> &#123;            <span class="keyword">if</span>(time&gt;<span class="number">0</span>)&#123;                redisTemplate.expire(key, time, TimeUnit.SECONDS);            &#125;            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 根据key 获取过期时间</span><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getExpire</span><span class="params">(String key)</span>&#123;        <span class="keyword">return</span> redisTemplate.getExpire(key,TimeUnit.SECONDS);    &#125;         <span class="comment">/**</span><span class="comment">     * 判断key是否存在</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKey</span><span class="params">(String key)</span>&#123;        <span class="keyword">try</span> &#123;            <span class="keyword">return</span> redisTemplate.hasKey(key);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 删除缓存</span><span class="comment">     * <span class="doctag">@param</span> key 可以传一个值 或多个</span><span class="comment">     */</span>    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(String ... key)</span>&#123;        <span class="keyword">if</span>(key!=<span class="literal">null</span>&amp;&amp;key.length&gt;<span class="number">0</span>)&#123;            <span class="keyword">if</span>(key.length==<span class="number">1</span>)&#123;                redisTemplate.delete(key[<span class="number">0</span>]);            &#125;<span class="keyword">else</span>&#123;                redisTemplate.delete(CollectionUtils.arrayToList(key));            &#125;        &#125;    &#125;         <span class="comment">//============================String=============================</span>    <span class="comment">/**</span><span class="comment">     * 普通缓存获取</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@return</span> 值</span><span class="comment">     */</span>    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span>&#123;        <span class="keyword">return</span> key==<span class="literal">null</span>?<span class="literal">null</span>:redisTemplate.opsForValue().get(key);    &#125;         <span class="comment">/**</span><span class="comment">     * 普通缓存放入</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> value 值</span><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key,Object value)</span> &#123;         <span class="keyword">try</span> &#123;            redisTemplate.opsForValue().set(key, value);            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;             &#125;         <span class="comment">/**</span><span class="comment">     * 普通缓存放入并设置时间</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> value 值</span><span class="comment">     * <span class="doctag">@param</span> time 时间(秒) time要大于0 如果time小于等于0 将设置无限期</span><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key,Object value,<span class="type">long</span> time)</span>&#123;        <span class="keyword">try</span> &#123;            <span class="keyword">if</span>(time&gt;<span class="number">0</span>)&#123;                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);            &#125;<span class="keyword">else</span>&#123;                set(key, value);            &#125;            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 递增</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> by 要增加几(大于0)</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">incr</span><span class="params">(String key, <span class="type">long</span> delta)</span>&#123;         <span class="keyword">if</span>(delta&lt;<span class="number">0</span>)&#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递增因子必须大于0&quot;</span>);        &#125;        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);    &#125;         <span class="comment">/**</span><span class="comment">     * 递减</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> by 要减少几(小于0)</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">decr</span><span class="params">(String key, <span class="type">long</span> delta)</span>&#123;         <span class="keyword">if</span>(delta&lt;<span class="number">0</span>)&#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递减因子必须大于0&quot;</span>);        &#125;        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);     &#125;          <span class="comment">//================================Map=================================</span>    <span class="comment">/**</span><span class="comment">     * HashGet</span><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span><span class="comment">     * <span class="doctag">@return</span> 值</span><span class="comment">     */</span>    <span class="keyword">public</span> Object <span class="title function_">hget</span><span class="params">(String key,String item)</span>&#123;        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);    &#125;         <span class="comment">/**</span><span class="comment">     * 获取hashKey对应的所有键值</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@return</span> 对应的多个键值</span><span class="comment">     */</span>    <span class="keyword">public</span> Map&lt;Object,Object&gt; <span class="title function_">hmget</span><span class="params">(String key)</span>&#123;        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);    &#125;         <span class="comment">/**</span><span class="comment">     * HashSet</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span><span class="comment">     * <span class="doctag">@return</span> true 成功 false 失败</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String,Object&gt; map)</span>&#123;         <span class="keyword">try</span> &#123;            redisTemplate.opsForHash().putAll(key, map);            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * HashSet 并设置时间</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String,Object&gt; map, <span class="type">long</span> time)</span>&#123;         <span class="keyword">try</span> &#123;            redisTemplate.opsForHash().putAll(key, map);            <span class="keyword">if</span>(time&gt;<span class="number">0</span>)&#123;                expire(key, time);            &#125;            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> item 项</span><span class="comment">     * <span class="doctag">@param</span> value 值</span><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key,String item,Object value)</span> &#123;         <span class="keyword">try</span> &#123;            redisTemplate.opsForHash().put(key, item, value);            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> item 项</span><span class="comment">     * <span class="doctag">@param</span> value 值</span><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)  注意:如果已存在的hash表有时间,这里将会替换原有的时间</span><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key,String item,Object value,<span class="type">long</span> time)</span> &#123;         <span class="keyword">try</span> &#123;            redisTemplate.opsForHash().put(key, item, value);            <span class="keyword">if</span>(time&gt;<span class="number">0</span>)&#123;                expire(key, time);            &#125;            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 删除hash表中的值</span><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span><span class="comment">     * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hdel</span><span class="params">(String key, Object... item)</span>&#123;         redisTemplate.opsForHash().delete(key,item);    &#125;         <span class="comment">/**</span><span class="comment">     * 判断hash表中是否有该项的值</span><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hHasKey</span><span class="params">(String key, String item)</span>&#123;        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);    &#125;         <span class="comment">/**</span><span class="comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> item 项</span><span class="comment">     * <span class="doctag">@param</span> by 要增加几(大于0)</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hincr</span><span class="params">(String key, String item,<span class="type">double</span> by)</span>&#123;         <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);    &#125;         <span class="comment">/**</span><span class="comment">     * hash递减</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> item 项</span><span class="comment">     * <span class="doctag">@param</span> by 要减少记(小于0)</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hdecr</span><span class="params">(String key, String item,<span class="type">double</span> by)</span>&#123;         <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item,-by);     &#125;          <span class="comment">//============================set=============================</span>    <span class="comment">/**</span><span class="comment">     * 根据key获取Set中的所有值</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sGet</span><span class="params">(String key)</span>&#123;        <span class="keyword">try</span> &#123;            <span class="keyword">return</span> redisTemplate.opsForSet().members(key);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">null</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 根据value从一个set中查询,是否存在</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> value 值</span><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sHasKey</span><span class="params">(String key,Object value)</span>&#123;        <span class="keyword">try</span> &#123;            <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 将数据放入set缓存</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span><span class="comment">     * <span class="doctag">@return</span> 成功个数</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSet</span><span class="params">(String key, Object...values)</span> &#123;        <span class="keyword">try</span> &#123;            <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="number">0</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 将set数据放入缓存</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span><span class="comment">     * <span class="doctag">@return</span> 成功个数</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSetAndTime</span><span class="params">(String key,<span class="type">long</span> time,Object...values)</span> &#123;        <span class="keyword">try</span> &#123;            <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().add(key, values);            <span class="keyword">if</span>(time&gt;<span class="number">0</span>) expire(key, time);            <span class="keyword">return</span> count;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="number">0</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 获取set缓存的长度</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sGetSetSize</span><span class="params">(String key)</span>&#123;        <span class="keyword">try</span> &#123;            <span class="keyword">return</span> redisTemplate.opsForSet().size(key);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="number">0</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 移除值为value的</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">setRemove</span><span class="params">(String key, Object ...values)</span> &#123;        <span class="keyword">try</span> &#123;            <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().remove(key, values);            <span class="keyword">return</span> count;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="number">0</span>;        &#125;    &#125;    <span class="comment">//===============================list=================================</span>         <span class="comment">/**</span><span class="comment">     * 获取list缓存的内容</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> start 开始</span><span class="comment">     * <span class="doctag">@param</span> end 结束  0 到 -1代表所有值</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">lGet</span><span class="params">(String key,<span class="type">long</span> start, <span class="type">long</span> end)</span>&#123;        <span class="keyword">try</span> &#123;            <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">null</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 获取list缓存的长度</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lGetListSize</span><span class="params">(String key)</span>&#123;        <span class="keyword">try</span> &#123;            <span class="keyword">return</span> redisTemplate.opsForList().size(key);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="number">0</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 通过索引 获取list中的值</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> index 索引  index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> Object <span class="title function_">lGetIndex</span><span class="params">(String key,<span class="type">long</span> index)</span>&#123;        <span class="keyword">try</span> &#123;            <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">null</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 将list放入缓存</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> value 值</span><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value)</span> &#123;        <span class="keyword">try</span> &#123;            redisTemplate.opsForList().rightPush(key, value);            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 将list放入缓存</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> value 值</span><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;        <span class="keyword">try</span> &#123;            redisTemplate.opsForList().rightPush(key, value);            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) expire(key, time);            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 将list放入缓存</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> value 值</span><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> &#123;        <span class="keyword">try</span> &#123;            redisTemplate.opsForList().rightPushAll(key, value);            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 将list放入缓存</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> value 值</span><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value, <span class="type">long</span> time)</span> &#123;        <span class="keyword">try</span> &#123;            redisTemplate.opsForList().rightPushAll(key, value);            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) expire(key, time);            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 根据索引修改list中的某条数据</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> index 索引</span><span class="comment">     * <span class="doctag">@param</span> value 值</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lUpdateIndex</span><span class="params">(String key, <span class="type">long</span> index,Object value)</span> &#123;        <span class="keyword">try</span> &#123;            redisTemplate.opsForList().set(key, index, value);            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;         <span class="comment">/**</span><span class="comment">     * 移除N个值为value</span><span class="comment">     * <span class="doctag">@param</span> key 键</span><span class="comment">     * <span class="doctag">@param</span> count 移除多少个</span><span class="comment">     * <span class="doctag">@param</span> value 值</span><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lRemove</span><span class="params">(String key,<span class="type">long</span> count,Object value)</span> &#123;        <span class="keyword">try</span> &#123;            <span class="type">Long</span> <span class="variable">remove</span> <span class="operator">=</span> redisTemplate.opsForList().remove(key, count, value);            <span class="keyword">return</span> remove;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="number">0</span>;        &#125;    &#125;     &#125;</code></pre><h3 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h3><pre><code class="highlight java"><span class="keyword">package</span> com.how2java; <span class="keyword">import</span> java.util.HashMap;<span class="keyword">import</span> java.util.Map; <span class="keyword">import</span> org.springframework.context.ApplicationContext;<span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext; <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRedis</span> &#123;         <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        ApplicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);         RedisUtil redisUtil=(RedisUtil) context.getBean(<span class="string">&quot;redisUtil&quot;</span>);                 <span class="comment">//=====================testString======================</span>        redisUtil.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;how2java&quot;</span>);        System.out.println(redisUtil.get(<span class="string">&quot;name&quot;</span>));        redisUtil.del(<span class="string">&quot;name&quot;</span>);        System.out.println(redisUtil.get(<span class="string">&quot;name&quot;</span>));                 <span class="comment">//=====================testNumber======================</span>        <span class="type">long</span> <span class="variable">incr</span> <span class="operator">=</span> redisUtil.incr(<span class="string">&quot;number&quot;</span>, <span class="number">1</span>);        System.out.println(incr);        incr =redisUtil.incr(<span class="string">&quot;number&quot;</span>, <span class="number">1</span>);        System.out.println(incr);                 <span class="comment">//=====================testMap======================       </span>        Map&lt;String,Object&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;meepo&quot;</span>);        map.put(<span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;password&quot;</span>);        redisUtil.hmset(<span class="string">&quot;user&quot;</span>, map);        System.out.println(redisUtil.hget(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;name&quot;</span>));    &#125;     &#125;</code></pre><h2 id="redis事务"><a class="markdownIt-Anchor" href="#redis事务"></a> Redis事务</h2><h3 id="redis事务介绍"><a class="markdownIt-Anchor" href="#redis事务介绍"></a> Redis事务介绍</h3><p>Redis的事务是通过<strong>MULTI，EXEC，DISCARD和WATCH</strong>这四个命令来完成的。</p><p>Redis的单个命令都是<strong>原子性</strong>的，所以这里确保事务性的对象是<strong>命令集合</strong>。</p><p>Redis将命令集合序列化并确保处于同一事务的<strong>命令集合连续且不被打断</strong>的执行</p><p>Redis<strong>不支持回滚</strong>操作</p><h3 id="相关命令"><a class="markdownIt-Anchor" href="#相关命令"></a> 相关命令</h3><p><strong>multi</strong></p><p>用于标记事务块的开始</p><p>Redis会将后续的命令逐个放入队列中，然后使用<u>EXEC命令</u>原子化的执行这个命令序列</p><p><strong>exec</strong></p><p><u>在一个事务中执行所有先前放入队列的命令</u>，然后恢复正常的连接状态</p><p><strong>discard</strong></p><p><u>清除所有先前在一个事务中放入队列的命令</u>，然后恢复正常的连接状态</p><p><strong>watch key [key…]</strong></p><p>当某个<strong>事务需要按条件执行时</strong>，就要使用这个命令将给定的<strong>键设置为受监控的状态</strong></p><p>注意事项：使用该命令可以实现redis的<strong>乐观锁</strong></p><p><strong>unwatch</strong></p><p>清除所有先前为一个事务监控的键</p><h3 id="事务失败处理"><a class="markdownIt-Anchor" href="#事务失败处理"></a> 事务失败处理</h3><p><strong>Redis语法错误</strong>（可以理解为编译期错误）</p><ul><li>整个事务都不会执行</li></ul><p><strong>Redis类型错误</strong>（可以理解为运行期错误）</p><ul><li>正确的命令执行</li></ul><p>Redis不支持事务回滚</p><ul><li>大多数事务失败是因为<strong>语法错误或者类型错误</strong>，这两种错误，在开发阶段都是可以预见的</li><li>redis为了<strong>性能方面</strong>就忽略了事务回滚</li></ul><h2 id="redis修改密码"><a class="markdownIt-Anchor" href="#redis修改密码"></a> Redis修改密码</h2><p><code>vim /redis-4.0.11/redis.conf</code>中修改下列代码即可</p><pre><code class="highlight plaintext">requirepass foobared</code></pre><p>保护模式</p><pre><code class="highlight plaintext">protected-mode yes</code></pre><p>端口</p><pre><code class="highlight plaintext">port 6379</code></pre><h2 id="redis实现分布式锁"><a class="markdownIt-Anchor" href="#redis实现分布式锁"></a> Redis实现分布式锁</h2><h3 id="锁的处理"><a class="markdownIt-Anchor" href="#锁的处理"></a> 锁的处理</h3><p>单应用中使用锁：单进程多线程</p><ul><li><strong>synchronize，lock</strong></li></ul><p>分布式应用中使用锁，多进程</p><h3 id="分布式锁的实现方式"><a class="markdownIt-Anchor" href="#分布式锁的实现方式"></a> 分布式锁的实现方式</h3><p>基于数据库的乐观锁实现分布式锁</p><p>基于zookeeper临时节点的分布式锁</p><p>基于redis的分布式锁</p><h3 id="分布式锁的注意事项"><a class="markdownIt-Anchor" href="#分布式锁的注意事项"></a> 分布式锁的注意事项</h3><p><strong>互斥性</strong></p><p>在任意时刻，只有一个客户端能持有锁</p><p><strong>同一性</strong></p><p>加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了</p><p><strong>可重入性</strong></p><p>即使有一个客户端在持有锁的期间奔溃而没有主动解锁，也能保证后续其他客户端能加锁</p><h3 id="实现分布式锁"><a class="markdownIt-Anchor" href="#实现分布式锁"></a> 实现分布式锁</h3><h4 id="组件依赖"><a class="markdownIt-Anchor" href="#组件依赖"></a> 组件依赖</h4><p>首先我们要通过Maven引入Jedis开源组件，在pom.xml文件加入下面的代码：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h4 id="获取锁"><a class="markdownIt-Anchor" href="#获取锁"></a> 获取锁</h4><p><strong>方式一：使用set命令实现</strong>（推荐）</p><p>这个set()方法一共有五个形参：</p><ul><li><strong>第一个为key</strong>，我们使用key来当锁，因为key是唯一的。</li><li><strong>第二个为value</strong>，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。</li><li><strong>第三个为nxxx</strong>，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li><li><strong>第四个为expx</strong>，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</li><li><strong>第五个为time</strong>，与第四个参数相呼应，代表key的过期时间。</li></ul><p>总的来说，执行上面的set()方法就只会导致两种结果：</p><ol><li>当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。</li><li>已有锁存在，不做任何操作。</li></ol><p>心细的童鞋就会发现了，我们的加锁代码满足我们可靠性里描述的三个条件。</p><ul><li>首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。</li><li>其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。</li><li>最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。</li></ul><blockquote><p>由于我们只考虑Redis单机部署的场景，所以容错性我们暂不考虑。</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 使用redis的set命令实现获取分布式锁</span><span class="comment"> * <span class="doctag">@param</span> lockKey   可以就是锁</span><span class="comment"> * <span class="doctag">@param</span> requestId请求ID，保证同一性</span><span class="comment"> * <span class="doctag">@param</span> expireTime过期时间，避免死锁</span><span class="comment"> * <span class="doctag">@return</span></span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">getLock</span><span class="params">(String lockKey,String requestId,<span class="type">int</span> expireTime)</span> &#123;<span class="comment">//NX:保证互斥性</span>    <span class="comment">//参数三：NX/XX  存在设置键/不存在设置建</span>    <span class="comment">//参数四：EX/PX  秒/毫秒</span>    <span class="comment">//参数五：毫秒时间</span><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, expireTime);<span class="keyword">if</span>(<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</code></pre><p><strong>方式二：使用setnx命令实现</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">getLock</span><span class="params">(String lockKey,String requestId,<span class="type">int</span> expireTime)</span> &#123;<span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> jedis.setnx(lockKey, requestId);<span class="keyword">if</span>(result == <span class="number">1</span>) &#123;        <span class="comment">//设置有效期</span>jedis.expire(lockKey, expireTime);<span class="keyword">return</span> <span class="literal">true</span>;&#125;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</code></pre><h4 id="释放锁"><a class="markdownIt-Anchor" href="#释放锁"></a> 释放锁</h4><p><strong>方式一：del命令实现</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 释放分布式锁</span><span class="comment"> * <span class="doctag">@param</span> lockKey</span><span class="comment"> * <span class="doctag">@param</span> requestId</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">(String lockKey,String requestId)</span> &#123;    <span class="keyword">if</span> (requestId.equals(jedis.get(lockKey))) &#123;jedis.del(lockKey);    &#125;&#125;</code></pre><p><strong>方式二：redis+lua脚本实现</strong>（推荐）</p><p>可以看到，我们解锁只需要两行代码就搞定了！</p><ul><li>第一行代码，我们写了一个简单的Lua脚本代码，上一次见到这个编程语言还是在《黑客与画家》里，没想到这次居然用上了。</li><li>第二行代码，我们将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。eval()方法是将Lua代码交给Redis服务端执行。</li></ul><p>那么这段Lua代码的功能是什么呢？</p><ul><li>其实很简单，首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。</li></ul><p>那么为什么要使用Lua语言来实现呢？</p><ul><li>因为要确保上述操作是原子性的。<br />那么为什么执行eval()方法可以确保原子性，源于Redis的特性，下面是官网对eval命令的部分解释：简单来说，就是在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。</li></ul><pre><code class="highlight java">   <span class="comment">/**</span><span class="comment">     * 释放分布式锁</span><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span><span class="comment">     */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">releaseLock</span><span class="params">(String lockKey, String requestId)</span> &#123;<span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));<span class="keyword">if</span> (result.equals(<span class="number">1L</span>)) &#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</code></pre><h2 id="redis持久化方案"><a class="markdownIt-Anchor" href="#redis持久化方案"></a> Redis持久化方案</h2><p>Redis是一个<strong>内存</strong>数据库，为了保证数据的持久新，它提供了两种持久化方案</p><ul><li>REB方式（默认）</li><li>AOF方式</li></ul><h3 id="rdb方式"><a class="markdownIt-Anchor" href="#rdb方式"></a> RDB方式</h3><p>RDB是Redis<strong>默认</strong>采用的持久化方式。</p><p>RDB方式是通过<strong>快照</strong>（snapshotting）完成的，当<strong>符合一定条件</strong>时Redis会自动将内存中的数据进行快照并持久化到硬盘</p><p>Redis会在<strong>指定的情况</strong>下触发快照</p><ul><li><strong>符合自定义配置的快照规则</strong></li><li><strong>执行save或者bgsave命令</strong></li><li><strong>执行flushall命令</strong></li><li><strong>执行主从复制操作</strong></li></ul><h4 id="配置步骤"><a class="markdownIt-Anchor" href="#配置步骤"></a> 配置步骤</h4><p>在<strong>redis.conf</strong>中设置自定义快照规则</p><p><strong>1.RDB持久化条件</strong></p><pre><code class="highlight plaintext">save &lt;seconds&gt; &lt;changes&gt;</code></pre><p>示例：</p><ul><li>save 900 1  ： 表示15分钟（900秒钟）内至少1个键被更改则进行快照。</li><li>save 300 10 ： 表示5分钟（300秒）内至少10个键被更改则进行快照。</li><li>save 60 10000 ：表示1分钟内至少10000个键被更改则进行快照</li></ul><blockquote><p>可以<strong>配置多个条件</strong>（每行配置一个条件），每个条件之间是“<strong>或</strong>”的关系</p></blockquote><p><strong>2.配置dir指定rdb快照文件的位置</strong></p><pre><code class="highlight plaintext"># Note that you must specify a directory here, not a file name.dir ./</code></pre><p><strong>3.配置dbfilename指定rdb快照文件的名称</strong></p><pre><code class="highlight plaintext"># The filename where to dump the DBdbfilename dump.rdb</code></pre><blockquote><p>Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。</p></blockquote><blockquote><p>根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟</p></blockquote><p><strong>关闭方式</strong></p><p>注释掉下面的三行代码即可</p><pre><code class="highlight plaintext">save 900 1save 300 10save 60 10000</code></pre><h4 id="快照的实现原理"><a class="markdownIt-Anchor" href="#快照的实现原理"></a> 快照的实现原理</h4><p><strong>快照过程</strong></p><p>redis使用fork函数<strong>复制</strong>一份当前进程的<strong>副本</strong>(子进程)</p><p><strong>父进程</strong>继续接收并处理客户端发来的命令，而<strong>子进程</strong>开始将内存中的数据写入硬盘中的临时文件。</p><p>当子进程写入完所有数据后会<strong>用该临时文件替换旧的RDB文件</strong>，至此，一次快照操作完成</p><p><strong>注意事项</strong></p><blockquote><p>redis在进行<strong>快照的过程中不会修改RDB文件</strong>，只有快照结束后才会将旧的文件替换成新的，也就是说任何时候RDB文件都是完整的。</p></blockquote><blockquote><p>这就使得我们可以通过定时备份RDB文件来实现redis数据库的备份，<strong>RDB文件是经过压缩的二进制文件</strong>，占用的空间会小于内存中的数据，更加利于传输</p></blockquote><h4 id="rdb的优缺点"><a class="markdownIt-Anchor" href="#rdb的优缺点"></a> RDB的优缺点</h4><p><strong>缺点</strong></p><p>使用RDB方式实现持久化，一旦Redis异常退出，就会<strong>丢失最后一次快照以后更改的所有数据</strong>。这个时候我们就需要根据具体的应用场景，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受范围。如果数据相对来说比较重要，希望将损失降到最小，则可以使用<strong>AOF</strong>方式进行持久化</p><p><strong>优点</strong></p><p>RDB可以最大化Redis的性能：父进程在保存RDB文件时唯一要做的就是fork出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无序执行任何磁盘I/O操作。同时这个也是一个缺点，如果数据集比较大的时候，fork可以能比较耗时，造成服务器在一段时间内停止处理客户端的请求</p><h3 id="aof方式"><a class="markdownIt-Anchor" href="#aof方式"></a> AOF方式</h3><p>默认情况下Redis没有开启AOF（append only file）方式的持久化</p><p>开启AOF持久化后每执行一条<strong>会更改Redis中的数据的命令</strong>，Redis就会将该命令写入硬盘中的AOF文件，这一过程显然会<strong>降低Redis的性能</strong>，但大部分情况下这个影响是能够接受的，另外使<strong>用较快的硬盘可以提高AOF的性能</strong></p><h4 id="开启方式"><a class="markdownIt-Anchor" href="#开启方式"></a> 开启方式</h4><p>可以通过修改<strong>redis.conf</strong>配置文件中的appendonly参数开启</p><pre><code class="highlight plaintext">appendonly yes</code></pre><p>AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的</p><pre><code class="highlight plaintext">dir ./</code></pre><p>默认的文件名是appendonly.aof，可以通过appendfilename参数修改</p><pre><code class="highlight plaintext">appendfilename appendonly.aof</code></pre><h4 id="aof重写原理优化aof文件"><a class="markdownIt-Anchor" href="#aof重写原理优化aof文件"></a> AOF重写原理（优化AOF文件）</h4><p>Redis 可以在 AOF<strong>文件体积变得过大</strong>时，自动地在后台对 AOF 进行<strong>重写</strong></p><p>重写后的新 AOF 文件包含了恢复当前数据集所需的<strong>最小命令集合</strong>。</p><p>整个重写操作是绝对安全的，因为 Redis 在创建<strong>新 AOF 文件的</strong>过程中，会继续将命令追加到<strong>现有的 AOF 文件</strong>里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦<strong>新 AOF 文件</strong>创建完毕，Redis 就会从旧 AOF 文件<strong>切换</strong>到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</p><p>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松</p><p><strong>参数说明</strong></p><p>表示当前aof文件大小超过上一次aof文件大小的百分之多少的时候会进行重写。如果之前没有重写过，以启动时aof文件大小为准</p><pre><code class="highlight plaintext"># auto-aof-rewrite-percentage 100</code></pre><p>限制允许重写最小aof文件大小，也就是文件大小小于64mb的时候，不需要进行优化</p><pre><code class="highlight plaintext"># auto-aof-rewrite-min-size 64mb</code></pre><h4 id="同步磁盘数据"><a class="markdownIt-Anchor" href="#同步磁盘数据"></a> 同步磁盘数据</h4><p>Redis每次更改数据的时候， aof机制都会将命令记录到aof文件，但是实际上由于操作系统的缓存机制，数据并没有实时写入到硬盘，而是进入硬盘缓存。再通过硬盘缓存机制去刷新到保存到文件</p><p><strong>参数说明</strong></p><p>每次执行写入都会进行同步  ， 这个是最安全但是是效率比较低的方式</p><pre><code class="highlight plaintext">appendfsync always</code></pre><p>每一秒执行（推荐）</p><pre><code class="highlight plaintext">appendfsync everysec</code></pre><p>不主动进行同步操作，由操作系统去执行，这个是最快但是最不安全的方式</p><pre><code class="highlight plaintext">appendfsync no</code></pre><h4 id="aof文件损坏后如何修复"><a class="markdownIt-Anchor" href="#aof文件损坏后如何修复"></a> AOF文件损坏后如何修复</h4><p>服务器可能在程序正在对 AOF 文件进行写入时停机， 如果停机造成了 AOF 文件出错（corrupt）， 那么 Redis 在重启时会拒绝载入这个 AOF 文件， 从而确保数据的一致性不会被破坏</p><p><strong>当发生这种情况时， 可以用以下方法来修复出错的 AOF 文件：</strong></p><ol><li><p>为现有的 AOF 文件创建一个备份。</p></li><li><p>使用 Redis 附带的 redis-check-aof 程序，对原来的 AOF 文件进行修复。</p></li></ol><pre><code class="highlight plaintext">redis-check-aof --fix readonly.aof</code></pre><ol start="3"><li>重启 Redis 服务器，等待服务器载入修复后的 AOF 文件，并进行数据恢复</li></ol><h3 id="如何选择rdb和aof"><a class="markdownIt-Anchor" href="#如何选择rdb和aof"></a> 如何选择RDB和AOF</h3><p>一般来说,如果对数据的安全性要求非常高的话，应该同时使用两种持久化功能。</p><p>如果可以承受数分钟以内的数据丢失，那么可以只使用 RDB 持久化。</p><p>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快 。</p><p>两种持久化策略可以同时使用，也可以使用其中一种。如果同时使用的话， 那么Redis重启时，会优先使用AOF文件来还原数据</p><h2 id="redis主从复制"><a class="markdownIt-Anchor" href="#redis主从复制"></a> Redis主从复制</h2><p><strong>从机 只可以读，不可以写</strong></p><p>持久化保证了即使redis服务重启也不会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，不过通过redis的主从复制机制就可以避免这种单点故障</p><p>说明：</p><ul><li><p>主redis中的数据有两个副本（replication）即从redis1和从redis2，即使一台redis服务器宕机其它两台redis服务也可以继续提供服务。</p></li><li><p>主redis中的数据和从redis上的数据保持实时同步，当<strong>主redis写入数据时通过主从复制机制会复制到两个从redis服务上</strong>。</p></li><li><p>只有一个主redis，可以有多个从redis。</p></li><li><p>主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求</p></li><li><p>一个redis可以即是主又是从，如下图：</p></li></ul><h3 id="主从配置"><a class="markdownIt-Anchor" href="#主从配置"></a> 主从配置</h3><p><strong>主redis配置</strong></p><p>无需特殊的配置</p><p><strong>从redis配置（从机只可读）</strong></p><p>修改从服务器上的redis.conf文件</p><pre><code class="highlight plaintext"># slaveof &lt;masterip&gt; &lt;masterport&gt;slaveof 192.168.101.3 6379</code></pre><blockquote><p>上边的配置说明当前【从服务器】对应的【主服务器】的IP是192.168.101.3，端口是6379</p></blockquote><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><ol><li><p>slave第一次或者重连到master上以后，会向master发送一个<strong>SYNC</strong>的命令</p></li><li><p>master收到SYNC的时候，会做两件事<br />a)    执行<strong>bgsave</strong>（rdb的快照文件）<br />b)    master会把新收到的修改命令存入到缓冲区</p></li></ol><blockquote><p>缺点：<strong>没有办法对master进行动态选举</strong>(使用哨兵实现)</p></blockquote><hr /><p>Redis的主从同步，分为<strong>全量同步</strong>和<strong>增量同步</strong>。</p><p>只有从机第一次连接上主机是全量同步</p><p>断线重连有可能触发全量同步也有可能是增量同步（master判断runid是否一致）</p><p>除此之外的情况都是增量同步</p><h4 id="全量同步"><a class="markdownIt-Anchor" href="#全量同步"></a> 全量同步</h4><p>Redis的全量同步过程主要分三个阶段：</p><ul><li><p>同步快照阶段：Master创建并发送<strong>快照</strong>给Slave,Slave载入并解析快照。Master同时将此阶段所产生的新的写命令存储到缓冲区。</p></li><li><p>同步写缓冲阶段：Master向Slave同步存储在缓冲区的写操作命令。</p></li><li><p>同步增量阶段：Master向Slave同步写操作命令。</p></li></ul><h4 id="增量同步"><a class="markdownIt-Anchor" href="#增量同步"></a> 增量同步</h4><ul><li><p>Redis增量同步主要指<strong>Slave完成初始化后开始正常工作</strong>时，<strong>Master发生的写操作同步到Slave的过程</strong>。</p></li><li><p>通常情况下，Master每执行一个写命令就会向Slave发送相同的<strong>写命令</strong>，然后Slave接收并执行。</p></li></ul><h2 id="redis-sentinel哨兵机制"><a class="markdownIt-Anchor" href="#redis-sentinel哨兵机制"></a> Redis Sentinel哨兵机制</h2><p><strong>Redis主从复制的缺点：没有办法对master进行动态选举，需要使用Sentinel机制完成动态选举</strong></p><p>Sentinel(哨兵)进程是用于<strong>监控redis集群中Master主服务器工作的状态</strong></p><p>在Master主服务器发生故障的时候，可以实现Master和Slave服务器的切换，保证系统的高可用（HA）</p><p>其已经被集成在redis2.6+的版本中，Redis的哨兵模式到了2.8版本之后就稳定了下来</p><h3 id="哨兵进程的作用"><a class="markdownIt-Anchor" href="#哨兵进程的作用"></a> 哨兵进程的作用</h3><p><strong>监控(Monitoring）</strong>: 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。</p><p><strong>提醒(Notification）</strong>： 当被监控的某个Redis节点出现问题时, 哨兵(sentinel) 可以通过API 向管理员或者其他应用程序发送通知。</p><p><strong>自动故障迁移(Automatic failover）</strong>：当一个Master不能正常工作时，哨兵(sentinel)<br />会开始一次自动故障迁移操作。</p><ul><li><p>它会将失效Master的其中一个Slave升级为新的Master, 并让失效Master的其他Slave改为复制新的Master；</p></li><li><p>当客户端试图连接失效的Master时，集群也会向客户端返回新Master的地址，使得集群可以使用现在的Master替换失效Master。</p></li><li><p>Master和Slave服务器切换后，Master的redis.conf、Slave的redis.conf和sentinel.conf的配置文件的内容都会发生相应的改变，即，Master主服务器的redis.conf配置文件中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换。</p></li></ul><h3 id="哨兵进程的工作原理"><a class="markdownIt-Anchor" href="#哨兵进程的工作原理"></a> 哨兵进程的工作原理</h3><ol><li><p>每个Sentinel（哨兵）进程以<strong>每秒钟一次</strong>的频率向整个集群中的<strong>Master主服务器</strong>，<strong>Slave从服务器以及其他Sentinel（哨兵）进程</strong>发送一个 <strong>PING</strong> 命令。</p></li><li><p>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过<br /><code>down-after-milliseconds</code> 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进<strong>程标记为主观下线（SDOWN）</strong>。</p></li><li><p>如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的<strong>所有 Sentinel（哨兵）<strong>进程要以每秒一次的频率</strong>确认Master主服务器</strong>的确<strong>进入了主观下线状态</strong>。</p></li><li><p>当<strong>有足够数量的 Sentinel（哨兵）进程</strong>（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为<strong>客观下线（ODOWN）</strong>。</p></li><li><p>在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。</p></li><li><p>当Master主服务器被 Sentinel（哨兵）进程标记为**客观下线（ODOWN）**时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</p></li><li><p>若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。</p></li></ol><h3 id="开启方式-2"><a class="markdownIt-Anchor" href="#开启方式-2"></a> 开启方式</h3><p><strong>修改从机(从机主机都可以)的sentinel.conf</strong></p><blockquote><p>sentinel.conf该文件需要从redis解压包中找到并拷贝到redis安装目录</p></blockquote><blockquote><p>哨兵的端口默认26379</p></blockquote><p><code>master ip</code>：主机的ip地址<br /><code>master-name</code>：reids的名字（非必须）<br /><code>quorum</code>：表示投票后，执行命令的最少人数</p><pre><code class="highlight shell"><span class="meta prompt_">#</span><span class="language-bash">sentinel monitor &lt;master-name&gt; &lt;master ip&gt; &lt;master port&gt; &lt;quorum&gt;</span>sentinel monitor mymaster 192.168.10.133 6379 1</code></pre><p>其他配置项说明</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">Example sentinel.conf</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">哨兵sentinel实例运行的端口 默认26379</span>port 26379<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">哨兵sentinel的工作目录</span>dir /tmp<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">哨兵sentinel监控的redis主节点的 ip port</span> <span class="meta prompt_"># </span><span class="language-bash">master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符<span class="string">&quot;.-_&quot;</span>组成。</span><span class="meta prompt_"># </span><span class="language-bash">quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span><span class="meta prompt_"># </span><span class="language-bash">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span>  sentinel monitor mymaster 127.0.0.1 6379 2<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span><span class="meta prompt_"># </span><span class="language-bash">设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span><span class="meta prompt_"># </span><span class="language-bash">sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span>sentinel auth-pass mymaster MySUPER--secret-0123passw0rd<span class="meta prompt_"></span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span><span class="meta prompt_"># </span><span class="language-bash">sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span>sentinel down-after-milliseconds mymaster 30000<span class="meta prompt_"> </span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><span class="meta prompt_"># </span><span class="language-bash">sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span>sentinel parallel-syncs mymaster 1<span class="meta prompt_"></span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span> <span class="meta prompt_">#</span><span class="language-bash">1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span><span class="meta prompt_">#</span><span class="language-bash">2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span><span class="meta prompt_">#</span><span class="language-bash">3.当想要取消一个正在进行的failover所需要的时间。</span>  <span class="meta prompt_">#</span><span class="language-bash">4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span><span class="meta prompt_"># </span><span class="language-bash">默认三分钟</span><span class="meta prompt_"># </span><span class="language-bash">sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span>sentinel failover-timeout mymaster 180000<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">SCRIPTS EXECUTION</span><span class="meta prompt_">#</span><span class="language-bash">配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span><span class="meta prompt_">#</span><span class="language-bash">对于脚本的运行结果有以下规则：</span><span class="meta prompt_">#</span><span class="language-bash">若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span><span class="meta prompt_">#</span><span class="language-bash">若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span><span class="meta prompt_">#</span><span class="language-bash">如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span><span class="meta prompt_">#</span><span class="language-bash">一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span><span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span><span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">通知脚本</span><span class="meta prompt_"># </span><span class="language-bash">sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span>  sentinel notification-script mymaster /var/redis/notify.sh<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">客户端重新配置主节点参数脚本</span><span class="meta prompt_"># </span><span class="language-bash">当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span><span class="meta prompt_"># </span><span class="language-bash">以下参数将会在调用脚本时传给脚本:</span><span class="meta prompt_"># </span><span class="language-bash">&lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><span class="meta prompt_"># </span><span class="language-bash">目前&lt;state&gt;总是“failover”,</span><span class="meta prompt_"># </span><span class="language-bash">&lt;role&gt;是“leader”或者“observer”中的一个。</span> <span class="meta prompt_"># </span><span class="language-bash">参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span><span class="meta prompt_"># </span><span class="language-bash">这个脚本应该是通用的，能被多次调用，不是针对性的。</span><span class="meta prompt_"># </span><span class="language-bash">sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span> sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</code></pre><p><strong>通过redis-sentinel启动</strong>哨兵服务</p><pre><code class="highlight plaintext">./redis-sentinel sentinel.conf</code></pre><blockquote><p>可以使用<code>info replication</code>命令查看当前主机redis的属性</p></blockquote><h2 id="redis-cluster集群"><a class="markdownIt-Anchor" href="#redis-cluster集群"></a> Redis Cluster集群</h2><p>redis3.0以后推出的redis cluster 集群方案，redis cluster集群保证了高可用、高性能、高可扩展性</p><p>redis cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份，当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点(<strong>Redis Cluster有内置复用哨兵的部分代码，不用单独开启哨兵进程</strong>)，从而保证集群不会挂掉</p><blockquote><p>Redis Cluster不用单独的配置主从，也不用单独的配置哨兵</p></blockquote><h3 id="redis-cluster架构图"><a class="markdownIt-Anchor" href="#redis-cluster架构图"></a> Redis Cluster架构图</h3><p>架构细节:<br />(1) 所有的redis节点彼此互联(<strong>PING-PONG机制</strong>),内部使用二进制协议优化传输速度和带宽.<br />(2) 节点的fail是通过集群中超过半数的节点检测失效时才生效.<br />(3) 客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可<br />(4) redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护<br /><strong>node &lt; -&gt; slot&lt;-&gt;value</strong><br />redis节点&lt;-&gt;槽&lt;-&gt;值</p><blockquote><p><strong>在创建redis cluster的时候，需要根据redis的节点数分配槽</strong></p></blockquote><blockquote><p>Redis 集群中内置了 <strong>16384 个哈希槽</strong>，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点</p></blockquote><h3 id="redis-cluster投票容错"><a class="markdownIt-Anchor" href="#redis-cluster投票容错"></a> Redis Cluster投票：容错</h3><p>最小节点数：<strong>3台</strong></p><p>(1)<strong>节点失效判断</strong>：集群中所有master参与投票,如果<u>半数以上master节点</u>与其中一个master节点通信超过(<u>cluster-node-timeout</u>超时时间    ),认为该master节点挂掉.<br />(2)<strong>集群失效判断</strong>:什么时候整个集群不可用(cluster_state:fail)?</p><ul><li>如果集群任意master挂掉,且当前master没有slave，则集群进入fail状态。也可以理解成集群的[0-16383]slot映射不完全时进入fail状态。</li><li>如果集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态</li></ul><h3 id="安装ruby环境"><a class="markdownIt-Anchor" href="#安装ruby环境"></a> 安装Ruby环境</h3><p>redis集群需要使用集群<strong>管理脚本redis-trib.rb</strong>，它的执行相应依赖ruby环境</p><ol><li>安装ruby</li></ol><pre><code class="highlight plaintext">yum install rubyyum install rubygems</code></pre><ol start="2"><li>安装ruby和redis的接口程序redis-3.2.2.gem</li></ol><pre><code class="highlight plaintext">gem install redis -V 3.2.2</code></pre><ol start="3"><li>复制redis-3.2.9/src/redis-trib.rb文件到/usr/local/redis目录</li></ol><pre><code class="highlight plaintext">cp redis-3.2.9/src/redis-trib.rb /usr/local/redis-cluster/ -r</code></pre><h3 id="安装redis集群"><a class="markdownIt-Anchor" href="#安装redis集群"></a> 安装Redis集群</h3><p>Redis集群最少需要<strong>三台主服务器，三台从服务器</strong>。</p><p><em>因为我们没有6太服务器，所以就是用一台机器的不同端口号来演示，实际上是6太机器，端口号相同，ip地址不同</em></p><p>端口号分别为：<strong>7001~7006</strong></p><blockquote><p><strong>注意事项</strong>：6个节点必须是空的，没有任何的数据</p></blockquote><p><strong>第一步</strong>：创建7001实例，并编辑redis.conf文件，修改port为7001。</p><blockquote><p>注意：创建实例，即拷贝单机版安装时，生成的bin目录，为7001目录</p></blockquote><p><strong>第二步</strong>：修改redis.conf配置文件，打开<code>Cluster-enable yes</code></p><p><strong>第三步</strong>：复制7001，创建7002~7006实例，<strong>注意端口修改</strong>。</p><p><strong>第四步</strong>：启动所有的实例</p><ul><li>可以写一个一键启动的脚本<code>start-all.sh</code></li></ul><p><strong>第五步</strong>：创建Redis集群（在redis-cluster<br />目录下）</p><ul><li>create表示创建集群</li><li>–replicas表示主从复制的副本数，1表示一主一从，2表示一主两从，3表示一主三从</li><li>该示例前边三个是主节点，后面三个是从节点</li><li>执行命令后<code>./redis-trib.rb create --replicas 1</code> 后续还需输入 <code>yes</code></li></ul><pre><code class="highlight plaintext">./redis-trib.rb create --replicas 1 192.168.10.133:7001 192.168.10.133:7002 192.168.10.133:7003 192.168.10.133:7004 192.168.10.133:7005  192.168.10.133:7006&gt;&gt;&gt; Creating clusterConnecting to node 192.168.10.133:7001: OKConnecting to node 192.168.10.133:7002: OKConnecting to node 192.168.10.133:7003: OKConnecting to node 192.168.10.133:7004: OKConnecting to node 192.168.10.133:7005: OKConnecting to node 192.168.10.133:7006: OK&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Using 3 masters:192.168.10.133:7001192.168.10.133:7002192.168.10.133:7003Adding replica 192.168.10.133:7004 to 192.168.10.133:7001Adding replica 192.168.10.133:7005 to 192.168.10.133:7002Adding replica 192.168.10.133:7006 to 192.168.10.133:7003M: d8f6a0e3192c905f0aad411946f3ef9305350420 192.168.10.133:7001   slots:0-5460 (5461 slots) masterM: 7a12bc730ddc939c84a156f276c446c28acf798c 192.168.10.133:7002   slots:5461-10922 (5462 slots) masterM: 93f73d2424a796657948c660928b71edd3db881f 192.168.10.133:7003   slots:10923-16383 (5461 slots) masterS: f79802d3da6b58ef6f9f30c903db7b2f79664e61 192.168.10.133:7004   replicates d8f6a0e3192c905f0aad411946f3ef9305350420S: 0bc78702413eb88eb6d7982833a6e040c6af05be 192.168.10.133:7005   replicates 7a12bc730ddc939c84a156f276c446c28acf798cS: 4170a68ba6b7757e914056e2857bb84c5e10950e 192.168.10.133:7006   replicates 93f73d2424a796657948c660928b71edd3db881fCan I set the above configuration? (type &#x27;yes&#x27; to accept): yes&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join....&gt;&gt;&gt; Performing Cluster Check (using node 192.168.10.133:7001)M: d8f6a0e3192c905f0aad411946f3ef9305350420 192.168.10.133:7001   slots:0-5460 (5461 slots) masterM: 7a12bc730ddc939c84a156f276c446c28acf798c 192.168.10.133:7002   slots:5461-10922 (5462 slots) masterM: 93f73d2424a796657948c660928b71edd3db881f 192.168.10.133:7003   slots:10923-16383 (5461 slots) masterM: f79802d3da6b58ef6f9f30c903db7b2f79664e61 192.168.10.133:7004   slots: (0 slots) master   replicates d8f6a0e3192c905f0aad411946f3ef9305350420M: 0bc78702413eb88eb6d7982833a6e040c6af05be 192.168.10.133:7005   slots: (0 slots) master   replicates 7a12bc730ddc939c84a156f276c446c28acf798cM: 4170a68ba6b7757e914056e2857bb84c5e10950e 192.168.10.133:7006   slots: (0 slots) master   replicates 93f73d2424a796657948c660928b71edd3db881f[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered.[root@localhost-0723 redis]#</code></pre><h3 id="命令客户端连接集群"><a class="markdownIt-Anchor" href="#命令客户端连接集群"></a> 命令客户端连接集群</h3><pre><code class="highlight plaintext">./redis-cli –h 127.0.0.1 –p 7001 –c</code></pre><blockquote><p>注意：-c 表示是以redis集群方式进行连接</p></blockquote><pre><code class="highlight shell">./redis-cli -p 7006 -c127.0.0.1:7006&gt; set key1 123<span class="meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [9189] located at 127.0.0.1:7002</span>OK127.0.0.1:7002&gt;</code></pre><h3 id="查看集群命令"><a class="markdownIt-Anchor" href="#查看集群命令"></a> 查看集群命令</h3><p>查看集群状态</p><pre><code class="highlight plaintext">127.0.0.1:7003&gt; cluster infocluster_state:okcluster_slots_assigned:16384cluster_slots_ok:16384cluster_slots_pfail:0cluster_slots_fail:0cluster_known_nodes:6cluster_size:3cluster_current_epoch:6cluster_my_epoch:3cluster_stats_messages_sent:926cluster_stats_messages_received:926</code></pre><p>查看集群中的节点</p><pre><code class="highlight plaintext">127.0.0.1:7003&gt; cluster nodes7a12bc730ddc939c84a156f276c446c28acf798c 127.0.0.1:7002 master - 0 1443601739754 2 connected 5461-1092293f73d2424a796657948c660928b71edd3db881f 127.0.0.1:7003 myself,master - 0 0 3 connected 10923-16383d8f6a0e3192c905f0aad411946f3ef9305350420 127.0.0.1:7001 master - 0 1443601741267 1 connected 0-54604170a68ba6b7757e914056e2857bb84c5e10950e 127.0.0.1:7006 slave 93f73d2424a796657948c660928b71edd3db881f 0 1443601739250 6 connectedf79802d3da6b58ef6f9f30c903db7b2f79664e61 127.0.0.1:7004 slave d8f6a0e3192c905f0aad411946f3ef9305350420 0 1443601742277 4 connected0bc78702413eb88eb6d7982833a6e040c6af05be 127.0.0.1:7005 slave 7a12bc730ddc939c84a156f276c446c28acf798c 0 1443601740259 5 connected127.0.0.1:7003&gt;</code></pre><h3 id="维护节点"><a class="markdownIt-Anchor" href="#维护节点"></a> 维护节点</h3><p>集群创建成功后可以继续向集群中添加节点</p><p><strong>添加主节点</strong></p><p>先创建7007节点，添加7007结点作为新节点</p><pre><code class="highlight plaintext">./redis-trib.rb add-node 127.0.0.1:7007 127.0.0.1:7001</code></pre><p>查看集群节点发现7007已经添加到集群中了</p><p><strong>hash槽重新分配（数据迁移）</strong></p><p>添加完主节点需要对主节点进行hash槽分配，这样该主节才可以存储数据</p><p>查看集群中槽占用情况</p><ul><li>redis集群有16384个槽，集群中的每个结点分配自已槽，通过查看集群结点可以看到槽占用情况</li></ul><p>给刚添加的7007节点分配槽</p><ol><li>连接上集群（连接集群中任意一个可用节点都行）</li></ol><pre><code class="highlight plaintext">./redis-trib.rb reshard 192.168.10.133:7001</code></pre><ol start="2"><li>输入要分配的槽数量</li></ol><blockquote><p>输入：3000，表示要给目标节点分配3000个槽</p></blockquote><ol start="3"><li>输入接受槽点的节点id</li></ol><blockquote><p>PS：这里准备给7007分配槽，通过cluster nodes查看7007结点id为：<code>15b809eadae88955e36bcdbb8144f61bbbaf38fb</code></p></blockquote><ol start="4"><li>输入源节点id</li></ol><pre><code class="highlight plaintext">输入：all</code></pre><ol start="5"><li>输入yes开始移动槽到目标节点</li></ol><p><strong>添加从节点</strong></p><p>语法：</p><pre><code class="highlight plaintext">./redis-trib.rb add-node --slave --master-id  主节点id   新节点的ip和端口   旧节点ip和端口（集群中任一节点都可以）</code></pre><p>添加7008从节点，将7008作为7007的从节点，执行如下命令</p><pre><code class="highlight plaintext">./redis-trib.rb add-node --slave --master-id  35da64607a02c9159334a19164e68dd95a3b943c 192.168.10.103:7008 192.168.10.103:7001</code></pre><blockquote><p><code>35da64607a02c9159334a19164e68dd95a3b943c</code>是7007结点的id，可通过<code>cluster nodes</code>查看</p></blockquote><blockquote><p>注意：如果原来该结点在集群中的配置信息已经生成到cluster-config-file指定的配置文件中（如果cluster-config-file没有指定则默认为nodes.conf），这时可能会报错：<code>[ERR] Node XXXXXX is not empty. Either the node already knows other nodes (check with  CLUSTER NODES) or contains some key in database 0</code></p></blockquote><blockquote><p>解决方法是删除生成的配置文件<code>nodes.conf</code>，删除后再执行<code>./redis-trib.rb add-node</code>指令</p></blockquote><p>查看集群中的结点，刚添加的7008为7007的从节点：</p><p><strong>删除节点</strong></p><pre><code class="highlight plaintext">./redis-trib.rb del-node 127.0.0.1:7005 4b45eb75c8b428fbd77ab979b85080146a9bc017</code></pre><p>删除已经占有hash槽的结点会失败，报错如下：</p><p><code>[ERR] Node 127.0.0.1:7005 is not empty! Reshard data away and try again.</code></p><p>需要将该结点占用的hash槽分配出去（参考hash槽重新分配章节）</p><h3 id="jedis连接集群"><a class="markdownIt-Anchor" href="#jedis连接集群"></a> Jedis连接集群</h3><p>需要开启防火墙，或者直接关闭防火墙</p><pre><code class="highlight plaintext">service iptables stop</code></pre><h4 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h4><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJedisCluster</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;<span class="comment">//创建一连接，JedisCluster对象,在系统中是单例存在</span>Set&lt;HostAndPort&gt; nodes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.10.133&quot;</span>, <span class="number">7001</span>));nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.10.133&quot;</span>, <span class="number">7002</span>));nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.10.133&quot;</span>, <span class="number">7003</span>));nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.10.133&quot;</span>, <span class="number">7004</span>));nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.10.133&quot;</span>, <span class="number">7005</span>));nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.10.133&quot;</span>, <span class="number">7006</span>));<span class="type">JedisCluster</span> <span class="variable">cluster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisCluster</span>(nodes);<span class="comment">//执行JedisCluster对象中的方法，方法和redis一一对应。</span>cluster.set(<span class="string">&quot;cluster-test&quot;</span>, <span class="string">&quot;my jedis cluster test&quot;</span>);<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> cluster.get(<span class="string">&quot;cluster-test&quot;</span>);System.out.println(result);<span class="comment">//程序结束时需要关闭JedisCluster对象</span>cluster.close();&#125;</code></pre><h4 id="使用spring"><a class="markdownIt-Anchor" href="#使用spring"></a> 使用spring</h4><p>配置applicationContext.xml</p><pre><code class="highlight xml"><span class="comment">&lt;!-- 连接池配置 --&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisPoolConfig&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisPoolConfig&quot;</span>&gt;</span><span class="comment">&lt;!-- 最大连接数 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxTotal&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span> /&gt;</span><span class="comment">&lt;!-- 最大空闲连接数 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span><span class="comment">&lt;!-- 每次释放连接的最大数目 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;numTestsPerEvictionRun&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1024&quot;</span> /&gt;</span><span class="comment">&lt;!-- 释放连接的扫描间隔（毫秒） --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30000&quot;</span> /&gt;</span><span class="comment">&lt;!-- 连接最小空闲时间 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1800000&quot;</span> /&gt;</span><span class="comment">&lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;softMinEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span><span class="comment">&lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWaitMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1500&quot;</span> /&gt;</span><span class="comment">&lt;!-- 在获取连接的时候检查有效性, 默认false --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span><span class="comment">&lt;!-- 在空闲时检查有效性, 默认false --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span><span class="comment">&lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;blockWhenExhausted&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="comment">&lt;!-- redis集群 --&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisCluster&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisCluster&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">set</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.101.3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7001&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.101.3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7002&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.101.3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7003&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.101.3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7004&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.101.3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7005&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.101.3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7006&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;/<span class="name">set</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jedisPoolConfig&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre><p>测试代码</p><pre><code class="highlight java"><span class="keyword">private</span> ApplicationContext applicationContext;<span class="meta">@Before</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;applicationContext = <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);&#125;<span class="comment">// redis集群</span><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJedisCluster</span><span class="params">()</span> &#123;<span class="type">JedisCluster</span> <span class="variable">jedisCluster</span> <span class="operator">=</span> (JedisCluster) applicationContext.getBean(<span class="string">&quot;jedisCluster&quot;</span>);jedisCluster.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> jedisCluster.get(<span class="string">&quot;name&quot;</span>);System.out.println(value);&#125;</code></pre><h2 id="redislua整合使用"><a class="markdownIt-Anchor" href="#redislua整合使用"></a> Redis+LUA整合使用</h2><p>Lua 是一种轻量小巧的<strong>脚本语言</strong>，用标准<strong>C语言</strong>编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能</p><h3 id="redis中使用lua的好处"><a class="markdownIt-Anchor" href="#redis中使用lua的好处"></a> Redis中使用LUA的好处</h3><ol><li><p><strong>减少网络开销</strong>，在Lua脚本中可以把多个命令放在同一个脚本中运行</p></li><li><p><strong>原子操作</strong>，redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。换句话说，编写脚本的过程中无需担心会出现竞态条件</p></li><li><p><strong>复用性</strong>，客户端发送的脚本会永远存储在redis中，这意味着其他客户端可以复用这一脚本来完成同样的逻辑</p></li></ol><h3 id="lua的安装学习lua时安装"><a class="markdownIt-Anchor" href="#lua的安装学习lua时安装"></a> <s>LUA的安装（学习lua时安装）</s></h3><p><strong>下载</strong></p><p>地址：<u><a href="http://www.lua.org/download.html">http://www.lua.org/download.html</a></u></p><p>可以本地下载上传到linux，也可以使用curl命令在linux系统中进行在线下载</p><pre><code class="highlight plaintext">curl -R -O http://www.lua.org/ftp/lua-5.3.5.tar.gz</code></pre><p><strong>安装</strong></p><pre><code class="highlight plaintext">yum -y install readline-devel ncurses-develtar -zxvf lua-5.3.5.tar.gzmake linuxmake install</code></pre><p>如果报错，说找不到readline/readline.h, 可以通过yum命令安装</p><pre><code class="highlight plaintext">yum -y install readline-devel ncurses-devel</code></pre><p>安装完以后再make linux  / make install</p><p>最后，直接输入 lua命令即可进入lua的控制台</p><h3 id="lua常见语法"><a class="markdownIt-Anchor" href="#lua常见语法"></a> LUA常见语法</h3><p>详见：<u><a href="http://www.runoob.com/lua/lua-tutorial.html">http://www.runoob.com/lua/lua-tutorial.html</a></u></p><h3 id="redis-lua整合使用"><a class="markdownIt-Anchor" href="#redis-lua整合使用"></a> Redis + LUA整合使用</h3><p><u><em>在redis中使用LUA不需要安装LUA，redis内置了</em></u></p><p>从Redis2.6.0版本开始，通过<strong>内置的Lua解释器</strong>，可以使用EVAL命令对Lua脚本进行求值</p><h4 id="相关命令-2"><a class="markdownIt-Anchor" href="#相关命令-2"></a> 相关命令</h4><p><strong>eval命令</strong></p><pre><code class="highlight plaintext">EVAL script numkeys key [key ...] arg [arg ...]</code></pre><p>命令说明：</p><ul><li><p><code>script参数</code>：是一段Lua脚本程序，它会被运行在Redis服务器上下文中，这段脚本不必(也不应该)定义为一个Lua函数。</p></li><li><p><code>numkeys参数</code>：用于指定键名参数的个数。</p></li><li><p><code>key [key ...]参数</code>： 从EVAL的第三个参数开始算起，使用了numkeys个键（key），表示在脚本中所用到的那些Redis键(key)，这些键名参数可以在Lua中通过全局变量KEYS数组，用1为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。</p></li><li><p><code>arg [arg ...]参数</code>：，可以在Lua中通过全局变量ARGV数组访问，访问的形式和KEYS变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。</p></li></ul><p>例如</p><pre><code class="highlight plaintext">&gt; eval &quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot; 2 key1 key2 first second1) &quot;key1&quot;2) &quot;key2&quot;3) &quot;first&quot;4) &quot;second&quot;</code></pre><p><strong>lua脚本中调用redis命令</strong></p><pre><code class="highlight plaintext">redis.call()：redis.pcall()：这两个函数的唯一区别在于它们使用不同的方式处理执行命令所产生的错误示例：&gt; eval &quot;return redis.call(&#x27;set&#x27;,KEYS[1],&#x27;bar&#x27;)&quot; 1 fooOK</code></pre><p><strong>evalsha</strong></p><ul><li><p>EVAL 命令要求你在<strong>每次执行脚本</strong>的时候都<strong>发送一次脚本主体</strong>(script body)。</p></li><li><p>Redis 有一个<strong>内部的缓存机制</strong>，因此它不会每次都重新编译脚本，不过在很多场合，付出无谓的带宽来传送脚本主体并不是最佳选择。</p></li><li><p>为了<strong>减少带宽的消耗</strong>， Redis 实现了 <strong>EVALSHA 命令</strong>，它的作用和 EVAL 一样，都用于对脚本求值，但它接受的第一个参数不是脚本，而是脚本的 SHA1 校验和(sum)</p></li></ul><p>EVALSHA 命令的表现如下</p><ul><li><p>如果服务器还记得给定的 SHA1 校验和所指定的脚本，那么执行这个脚本</p></li><li><p>如果服务器不记得给定的 SHA1 校验和所指定的脚本，那么它返回一个特殊的错误，提醒用户使用 EVAL 代替 EVALSHA</p></li></ul><pre><code class="highlight plaintext">&gt; evalsha 6b1bf486c81ceb7edf3c093f4c48582e38c0e791 0&quot;bar&quot;</code></pre><p><strong>script命令</strong></p><p><code>SCRIPT FLUSH</code> ：清除所有脚本缓存</p><p><code>SCRIPT EXISTS</code> ：根据给定的脚本校验和，检查指定的脚本是否存在于脚本缓存</p><p><code>SCRIPT LOAD</code> ：将一个脚本装入脚本缓存，<strong>返回SHA1摘要</strong>，但并不立即运行它</p><p><code>SCRIPT KILL</code> ：杀死当前正在运行的脚本</p><p><strong>redis-cli --eval</strong></p><p>可以使用redis-cli命令直接执行脚本</p><pre><code class="highlight plaintext">$ redis-cli --eval script KEYS[1] KEYS[2] , ARGV[1] ARGV[2] ...</code></pre><hr /><p>或者可以执行一个脚本文件</p><pre><code class="highlight plaintext">$ redis-cli --eval redis.lua</code></pre><p>redis.lua</p><pre><code class="highlight lua"><span class="keyword">local</span> value=redis.clal(<span class="string">&quot;get&quot;</span>,<span class="string">&quot;s2&quot;</span>)<span class="keyword">return</span> value</code></pre><h4 id="java种使用"><a class="markdownIt-Anchor" href="#java种使用"></a> Java种使用</h4><h2 id="redis消息模式"><a class="markdownIt-Anchor" href="#redis消息模式"></a> Redis消息模式</h2><h3 id="队列模式"><a class="markdownIt-Anchor" href="#队列模式"></a> 队列模式</h3><p>使用<strong>list类型</strong>的<code>lpush和rpop</code>实现消息队列(一般的抢购秒杀都使用该种技术)</p><p>注意事项：</p><ul><li><p>消息接收方如果不知道队列中是否有消息，会一直发送rpop命令，如果这样的话，会每一次都建立一次连接，这样显然不好。</p></li><li><p>可以使用<strong>brpop</strong>命令，它如果从队列中取不出来数据，会一直阻塞，在一定范围内没有取出则返回null、</p></li></ul><h3 id="发布订阅模式"><a class="markdownIt-Anchor" href="#发布订阅模式"></a> 发布订阅模式</h3><p><strong>订阅消息（<u>subscribe</u>）</strong></p><p>示例：</p><pre><code class="highlight plaintext">subscribe kkb-channel</code></pre><p><strong>发布消息（<u>publish</u>）</strong></p><p>示例：</p><pre><code class="highlight plaintext">publish kkb-channel “我是灭霸詹”</code></pre><p><strong>Redis发布订阅命令</strong></p><h2 id="缓存穿透缓存击穿缓存失效"><a class="markdownIt-Anchor" href="#缓存穿透缓存击穿缓存失效"></a> 缓存穿透,缓存击穿,缓存失效</h2><h3 id="缓存数据的步骤"><a class="markdownIt-Anchor" href="#缓存数据的步骤"></a> 缓存数据的步骤</h3><ol><li><p>查询缓存，如果没有数据，则查询数据库</p></li><li><p>查询数据库，如果数据不为空，将结果写入缓存</p></li></ol><h3 id="缓存穿透"><a class="markdownIt-Anchor" href="#缓存穿透"></a> 缓存穿透</h3><p><strong>什么叫缓存穿透？</strong></p><p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。如果key对应的value是一定不存在的，并且对该key并发请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p><p><strong>如何解决？</strong></p><p>1：<strong>对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存</strong>。</p><p>2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。（<strong>布隆表达式</strong>）</p><h3 id="缓存雪崩"><a class="markdownIt-Anchor" href="#缓存雪崩"></a> 缓存雪崩</h3><p><strong>什么叫缓存雪崩？</strong></p><p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。</p><p><strong>如何解决？</strong></p><p>1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p><p>2：<strong>不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀</strong>。</p><p>3：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期（此点为补充）</p><h3 id="缓存击穿"><a class="markdownIt-Anchor" href="#缓存击穿"></a> 缓存击穿</h3><p><strong>什么叫缓存击穿？</strong></p><ul><li><p>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。</p></li><li><p>缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p></li></ul><p><strong>如何解决？</strong></p><p>使用redis的setnx互斥锁先进行判断，这样其他线程就处于等待状态，保证不会有大并发操作去操作数据库。</p><pre><code class="highlight plaintext">if(redis.sexnx()==1)&#123;       //查询数据库       //加入线程&#125;</code></pre><h2 id="缓存淘汰策略之lru"><a class="markdownIt-Anchor" href="#缓存淘汰策略之lru"></a> 缓存淘汰策略之LRU</h2><h3 id="redis内置缓存淘汰策略"><a class="markdownIt-Anchor" href="#redis内置缓存淘汰策略"></a> redis内置缓存淘汰策略</h3><p><strong>最大缓存</strong></p><ul><li><p>在 redis 中，允许用户设置最大使用内存大小<u>maxmemory</u>，默认为0，没有指定最大缓存，如果有新的数据添加，超过最大内存，则会使redis崩溃，所以一定要设置。</p></li><li><p>redis 内存数据集大小上升到一定大小的时候，就会实行<u>数据淘汰策略</u>。</p></li></ul><p><strong>淘汰策略</strong></p><p>redis淘汰策略配置：maxmemory-policy voltile-lru，支持热配置</p><p><strong>redis 提供 6种数据淘汰策略：</strong></p><p>voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p><p>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p><p>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p><p>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</p><p>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</p><p>no-enviction（驱逐）：禁止驱逐数据</p><h3 id="lru原理"><a class="markdownIt-Anchor" href="#lru原理"></a> LRU原理</h3><p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”</p><h3 id="lru实现"><a class="markdownIt-Anchor" href="#lru实现"></a> LRU实现</h3><p>最常见的实现是使用一个链表保存缓存数据，详细算法实现如下：</p><p>1. 新数据插入到链表头部；</p><p>2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</p><p>3. 当链表满的时候，将链表尾部的数据丢弃。</p><blockquote><p>在Java中可以使用LinkHashMap去实现LRU</p></blockquote><h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3><p><strong>【命中率】</strong></p><p>当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。</p><p><strong>【复杂度】</strong></p><p>实现简单。</p><p><strong>【代价】</strong></p><p>命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部</p>]]>
    </content>
    <id>http://example.com/2023/01/04/Redis/</id>
    <link href="http://example.com/2023/01/04/Redis/"/>
    <published>2023-01-04T04:00:00.000Z</published>
    <summary>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value内存数据库。Redis安装，Spring集成，事务，分布式锁，持久化，主从，LUA。</summary>
    <title>Redis</title>
    <updated>2026-02-27T01:18:47.919Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="zookeeper" scheme="http://example.com/tags/zookeeper/"/>
    <content>
      <![CDATA[<h1 id="zookeeper"><a class="markdownIt-Anchor" href="#zookeeper"></a> zookeeper</h1><p>[toc]</p><h2 id="zookeeper概述"><a class="markdownIt-Anchor" href="#zookeeper概述"></a> Zookeeper概述</h2><h3 id="zookeeper简介"><a class="markdownIt-Anchor" href="#zookeeper简介"></a> Zookeeper简介</h3><p>zookeeper是一个开源的分布式应用程序协调服务器，其为分布式系统提供一致性服务。其一致性是通过基于Paxos算法的ZAB协议完成的，其主要功能包括：配置维护，域名服务，分布式同步，集群管理等。</p><h4 id="功能简介"><a class="markdownIt-Anchor" href="#功能简介"></a> 功能简介</h4><p><strong>配置维护</strong></p><p>分布式系统中，很多服务都是部署在集群中的，即多台服务器中部署着完全相同的应用，起着完全相同的作用，当然，集群中的这些服务器的配置文件是完全相同的。</p><p>若集群中服务器的配置文件需要进行更改，那么我们就需要逐台秀太这些服务器中的配置，数千台的服务器，手工维护的风险是很大的</p><p>这时候zookeeper就可以排上用场了，其对于配置文件的维护采用的是“发布/订阅模式”，发布者将修改好的集群的配置文件发布到zookeeper服务器的文件系统中，那么订阅者马上就可以接收到通知，并主动同步zookeeper里的配置文件，zookeeper具有同步操作的原子性，确保每个服务器的配置文件都可以被正确的修改</p><p><strong>域名服务</strong></p><p>在分布式应用中，一个项目包含多个工程，而这些工程中，有些工程是专门为其他工程提供服务的，一个项目中可能会存在多种提供不同服务的工程，而一种服务有可能存在多个提供者（服务器），所以，用于消费这些服务的客户端工程若要消费这些服务，就变得异常复杂</p><p>此时，zookeeper就可以上场了，为每个服务起个名称，将这些服务的名称与通过这些服务的主机地址注册都zookeeper中，形成一个服务映射表，服务消费者只需要通过服务名称即可享受到服务，而无需了解服务具体的提供者是谁，服务的减少，添加，变更，只需要改zookeeper中的服务映射表即可</p><p>阿里的Dobbo就是使用zookeeper作为服务域名服务器的</p><p><strong>分布式同步</strong></p><p>在分布式系统中，很多运算(对请求的处理)过程是由分布式机群中的若干服务器共同计算完成的，并且它们之间的运算还具有逻辑上的先后顺序。如何保证这些服务器运行期间的同步性呢? <br />      使用Zookeeper可以协调这些服务器间运算的过程。让这些服务器都同时监听Zookeeper上的同一个znode (Zookeeper文件系统中的一个数据存储节点)，一旦其中一个服务器Update了znode, 那么另一个相应服务器能够收到通知，并作出相应处理。</p><p><strong>集群管理</strong></p><p>集群管理中最麻烦的就是节点故障管理。Zookeeper可以让集群选出一个健康的节点作为Master, Master随时监控着当前集群中的每个节点的健康状况，一旦某个节点发生故障，Master会把这个情况立即通知给集群中的其它节点，使其它节点对于任务的分配做出相应调整。Zookeeper不仅可以发现故障，也会对故障进行甄别，如果该故障可以修复，Zookeeper可以自动修复，若不能修复则会告诉系统管理员错误的原因让管理员迅速定位问题。。<br />      但这里也有个问题: Master 故障了，那怎么办? Zookeeper内部有一个“选举算法”， 当Master故障出现时，Zookeeper 能马上选出新的Master对集群进行管理</p><h4 id="一致性要求"><a class="markdownIt-Anchor" href="#一致性要求"></a> 一致性要求</h4><p>什么是zk的一致性呢？就需要满足以下几点要求</p><p><strong>顺序一致性</strong></p><p>从同一个客户端发起的n多个事务请求（写请求），最终将会严格按照其发起顺序被应用到zookeeper中</p><p><strong>原子性</strong></p><p>所有事务请求的结果在集群中所有机器上的应用情况是一致的。也就是说要么整个集群所有主机都成功应用了某一个事务，要么都没有应用，不会出现集群中部分主机应用了该事务，而另外一部分没有应用的情况。</p><p><strong>单一视图</strong></p><p>无论客户端连接的是哪个ZooKeeper服务器，其看到的服务端数据模型都是一致的。</p><p><strong>可靠性</strong></p><p>一且服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来，除非有另一个事务又对其进行了变更。</p><p><strong>实时性</strong></p><p>通常人们看到实时性的第一反应是，一旦一个事务被成功应用，那么客户端能够立即从服务端上读取到这个事务变更后的最新数据状态。这里需要注意的是，ZooKeeper仅仅保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。</p><h3 id="zookeeper中的重要概念"><a class="markdownIt-Anchor" href="#zookeeper中的重要概念"></a> zookeeper中的重要概念</h3><h4 id="session"><a class="markdownIt-Anchor" href="#session"></a> Session</h4><p>Session是指客户端会话。</p><p>ZooKeeper 对外的服务端口<strong>默认是2181</strong>，客户端启动时，首先会与zk服务器建立一个TCP长连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个长连接，客户端能够通过心跳检测保持与服务器的有效会话，也能够向ZooKeeper服务器发送请求并接受响应，同时还能通过该连接接收来自服务器的Watcher事件通知。</p><p>Session的<strong>SessionTimeout值用来设置一个客户端会话的超时时间</strong>。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在SessionTimeout规定的时间内客户端能够重新连接上集群中任意台服务器，那么之前创建的会话仍然有效。</p><h4 id="znode"><a class="markdownIt-Anchor" href="#znode"></a> znode</h4><p>zookeeper的文件系统采用树形层次化的目录结构，与Unix文件系统非常相似。每个目录在zookeeper中叫做一个znode,每个znode拥有一个唯一的路径标识，即名称。Znode可以包含数据和子znode (临时节点不能有子znode)。Znode 中的数据可以有多个版本，所以查询某路径下的数据需带上版本号。客户端应用可以在znode上设置监视器(Watcher)</p><h4 id="watcher机制"><a class="markdownIt-Anchor" href="#watcher机制"></a> Watcher机制</h4><p>zk通过<strong>Watcher机制实现了发布/订阅模式</strong>。k提供了分布式数据的发布订阅功能，一个发布者能够让多个订阅者同时监听某一主题对象， 当这个主题对象状态发生变化时，会通知所有订阅者，使它们能够做出相应的处理。zk引入了watcher机制来实现这种分布式的通知功能。zk允许客户端向服务端注册一个Watcher监听，当服务端的一些指定事件触发这个Watcher,那么就会向指定客户端发送一个事件通知。而这个事件通知则是通过TCP长连接的Session完成的</p><h4 id="acl"><a class="markdownIt-Anchor" href="#acl"></a> ACL</h4><p>ACL全称为Access Control List (访问控制列表),<strong>用于控制资源的访问权限，是zk数据安全的保障</strong>。zk利用ACL策略控制znode节点的访问权限，如节点数据读写、节点创建、节点删除、读取子节点列表、设置节点权限等。</p><p>在传统的文件系统中，ACL分为两个维度:组与权限。一个属组可以包含多种权限，一个文件或目录拥有了某个组的权限即拥有了组里的所有权限。文件或子目录默认会继承其父目录的ACL。</p><p>而在Zookeeper中，znode的ACL是没有继承关系的，每个znode的权限都是独立控制的，只有客户端满足znode设置的权限要求时，才能完成相应的操作。Zookeeper 的ACL分为三个维度：<strong>授权策略scheme，用户id，用户权限permission</strong></p><h3 id="paxos算法"><a class="markdownIt-Anchor" href="#paxos算法"></a> Paxos算法</h3><h4 id="算法简介"><a class="markdownIt-Anchor" href="#算法简介"></a> 算法简介</h4><p>Paxos算法是莱斯利&quot;伯特(Leslie tamport)1990年提出的一种基于消息传递的、具有高容错性的一致性算法。Google Chubby (分布式锁服务)的作者Mike Burrows说过，世上只有一种一致性算法，那就是Paxos, 所有其他致性算法 都是Paxos算法的不完整版。Paxos算法是一种公认的晦涩难懂的算法，并且工程实现上也具有很大难度。较有名的Paxos工程实现有Google Chubby、ZAB、 微信的PhxPaxos等。，</p><p>Paxos算法是用于解决什么问题的呢? Paxos 算法要解决的问题是，在分布式系统中如何就某个决议达成一致。</p><h4 id="paxos与拜占庭将军问题"><a class="markdownIt-Anchor" href="#paxos与拜占庭将军问题"></a> Paxos与拜占庭将军问题</h4><p>拜占庭将军问题(Byzantine failures),是由Paxos算法作者莱斯利兰伯特提出的点对点通信中的基本问题。该问题要说明的含义是，在存在消息丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的。</p><p>Paxos算法的前提是不存在拜占庭将军问题，即信道是安全的、可靠的，集群节点间传  国中J递的消息是不会被篡改的。在实际工程实践中，大多数系统都是部署在一个局域网内，因此消息被篡改的情况很少:另一方面，由于硬件和网络原因而造成的消息不完整问题，现在已经不再是问题，只需要一套简单的校验算法即可，因此，在实际工程中各个服务器间传递过程可以认为不存在拜占庭将军问题</p><p>一般情况下，分布式系统中各个节点间采用两种通讯模型，共享内存（shared Memory）,消息传递（Messages Passing）。而Paxos是基于消息传递通讯模型的</p><h4 id="算法描述"><a class="markdownIt-Anchor" href="#算法描述"></a> 算法描述</h4><h5 id="三种角色"><a class="markdownIt-Anchor" href="#三种角色"></a> 三种角色</h5><p>在Paxos算法中有三种角色，分别具有三种不同的行为。但很多时候，一一个进程可能同时充当着多种角色。</p><ul><li>Proposer:提案(Proposal) 的提议者。</li><li>Acceptor:提案的表决者，即是否accept该提案。只有半数以上的Acceptor接受了某提案，那么该提案者被认定为“选定”。</li><li>Learners:提案的学习者。当提案被选定，其会同步并执行提案</li></ul><p>一个提案的表决者(Acceptor)会存在多个，但在一个集群中，提议者(Proposer)是可能存在多个的，不同的提议者（Proposer）会提出不同的提案。而一致性算法则可以保证如下几点：</p><ul><li>没有提案被提出则不会有提案被选定</li><li>每个提议者在提出提案时都会为该提案指定一个具有全局唯性的、 递增的提案编号 N,即在整个集群中是唯一的。</li><li>每个表决者在accept某提案后，会将该提案的编号N记录在本地，这样每个表决者中保存的已经被accept的提案中会存在一个编号最大的提案，其编号假设为maxN。每个表决者仅会accept编号大于自己本地maxN的提案。</li><li>在众多提案中最终只能有一个提案被选定。</li><li>一旦一个提案被选定，则其它服务器会主动同步(Learn)该是案到本地。</li></ul><h5 id="算法过程描述"><a class="markdownIt-Anchor" href="#算法过程描述"></a> 算法过程描述</h5><p>Paxos算法的执行过程划分为两个阶段：准备阶段prepare与接受阶段accept</p><ul><li><strong>prepare 阶段</strong></li></ul><p>提议者(Proposer)准备提交一个编号为 N的提议， 于是其 首先向所有表决者(Acceptor)发送prepare(N)请求，用于试探集群是否支持该编号的提议。</p><p>每个表决者(Acceptor)中 都保存着自己曾经accept过的提议中的最大编号maxN。当一个表决者接收到其它主机发送来的prepare(N)请求时，其会比较N与maxN的值。若N小于等于maxN,则说明该提议己过时，当勤表决者采取不回应或回应Error的方式来拒绝该prepare请求;若N大于maxN,则说明该提议是可以接受的，当前表决者会将其曾经已经accept的编号最大的提案Proposal(mid,maxN,value)反馈给提议者，以向提议者展示自己支持的提案意愿。其中第一个参数mid表示表决者Acceptor的标识id,第二个参数表示其曾接受的提案的最大编号maxN,第三个参数表示该提案的真正内容value.当然，若当前表决者还未曾accept过任何提议，则会将Propalimid,null,nul)反馈给提议者。</p><ul><li><strong>accept 阶段</strong></li></ul><p>当提议者(Proposer)发 出prepare(N)后，若收到了超过半数的表决者(Accepter)的反馈，那么该提议者就会将其真正的提案Proposal(N,value)发送给所有的表决者。</p><p>当表决者(Acceptor)接收到提议者发送的Proposal(N,value)提案后，会再次拿出自己曾经accept过的提议中的最大编号maxN,及曾经反馈过的prepare的最大编号，让N与它们进行比较，若N大于等于这两个编号，则当前表决者accept 该提案，并反馈给提议者。若N小于这两个编号，则表决者采取不回应或回应Error的方式来拒绝该提议</p><p>若提议者 没有接收到超过半数的表决者的accept反馈，则重新进入prepare阶段，递增提案号，重新提出prepare请求。若提议者接收到的反馈数量超过了半数，则其它的未向提议者发送accept反馈的表决者将成为Learner,主动同步提议者的该提案。</p><h5 id="算法过程举例"><a class="markdownIt-Anchor" href="#算法过程举例"></a> 算法过程举例</h5><p>假设有三台主机，它们要从中选出一个Leader。这三台主机在不同的时间分别充当关提案的提议者Proposer、表决者Acceptor及学习者Learnor 三种不同的角色。</p><p>这里首先介绍一下该举例的前提:每个提议者(Proposer)都想提议自己要当Leader,假设三个提议者Proposer-1、Proposer-2、Proposer-3 提议的提案初始编号依次为20、10、30。每个提议者都要将提案发送给所有的表决者(Acceptor),为了便于理解，假设都只有两个(超过半数)表决者收到消息: Accepter-2 与Acceptor-3 收到了Proposer-2 的消息: Accepter-1与Acceptor-2收到了Proposer-1 的消息; Accepter-2与Acceptor-3收到了Proposer-3 的消息。</p><h4 id="paxos算法优化"><a class="markdownIt-Anchor" href="#paxos算法优化"></a> Paxos算法优化</h4><p>前面所述的Paxos算法在实际工程应用过程中，根据不同的实际需求存在诸多不便之处，所以也就出现了很多对于基本Paxos算法的优化算法，例如，Multi Paxos、Fast Paxos、EPaxos.而<strong>Zookeeper的Leader选举算法</strong>FastLeaderElection则<strong>是Fast Paxos 算法的工程应用</strong></p><h3 id="zab协议"><a class="markdownIt-Anchor" href="#zab协议"></a> ZAB协议</h3><p>ZAB，Zookeeper Atomic Broadcast, zk原子消息广播协议，是<strong>专为ZooKeeper设计的一种支持崩溃恢复的原子广播协议</strong>，是<strong>一种Pasox协议的优化算法</strong>。在Zookeeper中， 主要依赖ZAB协议来实现分布式数据一致性。</p><p>Zookeeper使用一个单一主进程来接收并处理客户端的所有事务请求，即写请求。当服务器数据的状态发生变更后，集群采用ZAB原子广播协议，以事务提案Proposal的形式广播到所有的副本进程上。ZAB协议能够保证一个全局的变更序列,即可以为每一个事务 分配一一个全局的递增编号xid.。</p><p>当Zookeeper客户端连接到Zookeeper集群的一个节点后，若客户端提交的是读请求，那么当前节点就直接根据自己保存的数据对其进行响应;如果是写请求且当前节点不是Leader,那么节点就会将该写请求转发给Leader, Leader会以提案的方式广播该写操作，只要有超过半数节点同意该写操作，则该写操作请求就会被提交。 然后Leader 会再次广播给所有订阅者，即Learner,通知它们同步数据</p><h4 id="三类角色"><a class="markdownIt-Anchor" href="#三类角色"></a> 三类角色</h4><p>为了避免Zookeeper的单点问题，zk也是以集群的形式出现的。集群中的角色主要有以下三类:</p><ul><li><p>Leader: zk集群写请求的唯一处理者， 并负责进行投票的发起和决议，更新系统状态。Leader是很民主的，并不是说其在接收到写请求后马上就修改其中保存的数据，而是首先根据写请求提出一个提议，在大多数zkServer均同意时才会做出修改。</p></li><li><p>Follower: 接收客户端请求，处理读请求，并向客户端返回结果，将写请求转给Leader，在选主(选Leader)过程中参与投票。</p></li><li><p>Obsenver:可以理解为无选主投票权与写操作投票权的Flollower,其不属于法定人数范围，主要是为了协助Follower处理更多的读请求。如果Zookeeper集群的读请求负载质高时，劳必要增加处理读请求的服务器数量:若增加的这些服务器都是以Follower的身份出现。则会大大降低写操作的效率。因为Leader发出的所有写操作提议，均需要通过法定人数半数以上同意。过多的Follwer会增加Leader与Follower的通信压力，降低写操作效率。同样，过多的Follower会延长Leader的选举时长，降低整个集群的可用性。此时，可选择增加Observer服务器，既提高了处理读操作的吞吐量。又没有墙加法定人数。只要法定人数不变，无论是写操作投票还是选主投票，其都不会增加通信压力，都不会影响投票效率。</p></li></ul><h4 id="三种模式"><a class="markdownIt-Anchor" href="#三种模式"></a> 三种模式</h4><p>ZAB协议中对zkServer的状态描述有三种模式:恢复模式、同步模式和广播模式。</p><ul><li><p><strong>恢复模式</strong>：在服务重启过程中，或在Leader崩溃后，就进入了恢复模式，要恢复到zk集群正常的工作状态</p></li><li><p><strong>同步模式</strong>：在所有的zkServer启动完毕，或Leader崩溃后又被选举出来时，就进入了同步模式，各个Follower需要马上将Leader 中的数据同步到自己的主机中。当大多数zkServer完成了与Leader的状态同步以后，恢复模式就结束了。所以，同步模式包含在恢复模式过程中。</p></li><li><p><strong>广播模式</strong>：当Leader的提议被大多数zkServer同意后，Leader会修改自身数据，然后将修改后的数据广播给其他Follower</p></li></ul><h4 id="zxid"><a class="markdownIt-Anchor" href="#zxid"></a> zxid</h4><p>zxid为64位长度的Long类型，其中高32位表示<strong>纪元epoch</strong>,低32位表示<strong>事务标识xid</strong>.即zxid由两部分构成: epoch 与xid.。</p><p>每个Leader都会具有一个不同的epoch值，表示一个时期、时代。每一次新的选举开启时都会生成一个新的epoch,新的Leader产生,则会更新所有zkServer 的zxid中的epoch。</p><p>xid则为zk的事务id,每一个写操作都是一个事务，都会有一个xid. xid为一个依次递增的流水号。每一个写操作都需要由Leader发起一一个提案，由所有Follower表决是否同意本次写操作，而每个提案都具有一个zxid。</p><h4 id="消息广播算法"><a class="markdownIt-Anchor" href="#消息广播算法"></a> 消息广播算法</h4><p>当集群中已经有过半的Follower与Leader服务器完成了状态同步，那么整个zk集群就可以进入消息广播模式了。</p><p>如果集群中的其他节点收到客户端的事务请求，那么这些非Leader服务器会首先将这个事务请求转发给Leader服务器。Leader服务器会为其生成对应的事务提案Proposal, 并将其发送给集群中其余所有的主机，然后再分别收集它们的选票，在选票过半后进行事务提交。其具体过程如下:</p><ul><li><p>Leader接收到消息请求后，将消息赋予一个全局唯一的64位自增id, 即zxid,通过zxid的大小比较即可实现事务的有序性管理。</p></li><li><p>为了保证Leader向Follower发送提案的有序，Leader会为每个Follower创建一个 FIFO队列，并将提案副本写入到各个队列。然后再通过这些队列将提案发送给各个Follower.</p></li><li><p>当Follower接收到提案后，会先将提案的zxid与本地记录的事务日志中的最大的zxid进行比较。若当前提案的zxid大于最大zxid,则将当前提案记录到本地事务日志中，并向Leader返回一个ACK</p></li><li><p>当Leader接收到过半的ACKs后，对于之前回复过Leader的Follower, Leader 会向其发送COMMIT消息，批准这些Follower在本地执行该消息:对于之前未回复过Leader的Follower, Leader 会将这些Follower对应的队列中的提案发送给这些Follower,发送的同时会携带COMMIT消息。当Follower收到COMMIT消息后，就会执行该消息。</p></li></ul><h4 id="恢复模式两个原则"><a class="markdownIt-Anchor" href="#恢复模式两个原则"></a> 恢复模式两个原则</h4><p>当集群正在启动过程中，或Leader与超过半数的主机断连后，集群就进入了恢复模式。对于要恢复的数据状态需要遵循两个原则。</p><p><strong>已被处理过的消息不能丢</strong></p><p>当Leader收到超过半数Follower的ACKS后，就向各个Follower广播COMMIT 消息，批准各个Server执行该写操作事务。当各个Server在接收到Leader的COMMIT消息后就会在本地执行该写操作，然后会向客户端响应写操作成功。但是如果在非全部Follower 收到月  COMMIT消息之前Leader 就挂了，这将导致一种后果: 部分Server 已经执行了该事务，而部分Server尚未收到COMMIT消息，所以其并没有执行该事务。当新的Leader被选举出，集群经过恢复模式后需要保证所有Server上都执行了那些已经被部分Server执行过的事务。</p><p>为了保证“已被处理过的消息不能丢”的目的，ZAB的恢复模式使用了以下的策略:</p><ul><li>选举拥有proposal 最大值(即zxid 最大)的节点作为新的Leader: 由于所有提案被COMMIT之前必须有合法数量的Follower ACK,即必须有合法数量的服务器的事务日志上有该提案的proposal, 因此，只要有合法数量的节点正常工作，就必然有一个节点保  国中存了所有被COmMIT消息的proposal 状态。</li><li>新的Leader 先将自身拥有而并非所有Follower 都有的proposal 发送给Follower, 再将这些proposal的COMMIT命令发送给Follower,以保证所有的Follower 都保存并执行了所有的proposal.通过以上策略，能保证已经被处理的消息不会丢。</li></ul><p><strong>被丢弃的消息不能再现</strong></p><p>当Leader 接收到事务请求并生成了proposal,但还未向Follower发送时就挂了。由于其他Follower并没有收到此proposal,即并不知道该proposal的存在，因此在经过恢复模式重新选举产生了新的Leader后，这个事务被跳过。在整个集群尚未进入正常服务状态时，之前挂了的Leader主机重新启动并注册成为了Follower.但由于保留了被跳过的proposal,所以其与整个系统的状态是不一致的，需要将该proposal删除。</p><p>ZAB通过设计巧妙的zxid实现了这一目的。一个zxid是64位，高32是纪元epoch编号，每一次选举epoch的值都会增一。低32位是事务标识xid,每产生一个事务， 该xid值都会增一。这样设计的好处是旧的Leader挂了后重启，它不会被选举为新的Leader,因为此时它的zxid 肯定小于当前新的epoch。当旧的Leader作为Follower 接入新的Leader后，新的Leader会让其将所有旧的epoch 号的未被COMMIT的proposal 清除。</p><h4 id="leader选举算法paxos实现"><a class="markdownIt-Anchor" href="#leader选举算法paxos实现"></a> leader选举算法（paxos实现）</h4><p>当集群正在启动过程中，或Leader与超过半数的主机断连后，集群就进入了恢复模式。而恢复模式中最重要的阶段就是Leader 选举。</p><p>在集群 启动过程中的Leader选举过程(算法)与Leader断连后的Leader选举过程稍微有一些区别，基本相同</p><p><strong>集群启动中的 Leader 选举</strong></p><p>若进行Leader 选举，则至少需要两台主机，这里以三台主机组成的集群为例。。</p><p>在集群初始化阶段，当第台 服务器Server1启动时，其会给自己投票，然后发布自己的投票结果。投票包含所推举的服务器的myid和ZXID,使用(myid, ZXID)来表示，此时Server1的投票为(1，0)。由于其它机器还没有启动所以它收不到反馈信息，Server1 的状态一直属于Looking,即属于韭服务状态。。</p><p>当第二台服务器Server2启动时，此时两台机器可以相互通信，每台机器都试图找到Leader,选举过程如下:</p><ol><li><p>每个Server发出一个投票。此时Server1的投票为(1, 0), Server2的投票为(2,0),然后各自将这个投票发给集群中其他机器。，</p></li><li><p>接受来自各个服务器的投票。集群的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票、是否来自LOOKING状态的服务器。。</p></li><li><p>处理投票。针对每一个投票，服务器都需要将别人的投票和自己的投票进行PK, PK规则如下:。</p><ul><li>优先检查ZXID。ZXID 比较大的服务器优先作为Leader。。</li><li>如果ZXID相同，那么就比较myid。myid 较大的服务器作为Leader服务器。。对于Server1而言，它的投票是(1, 0),接收Server2的投票为(2, 0)。其首先会比较两者的ZXID,均为0，再比较myid,此时Server2的myid最大，于是Server1更新自己的投票为(2, 0),然后重新投票。对于Server2而言，其和须更新自己的投票，只是再次向集群中所有主机发出上一次投票信息即可。</li></ul></li><li><p>统计投票。每次投票后，每一台zkServer 都会统计投票信息，判断是否已经有过半机器接受到相同的投票信息。对于Server1、Server2而言，都统计出集群中已经有两台主机接受了(2, 0)的投票信息，此时便认为已经选出了新的Leader,即Server2。</p></li><li><p>改变服务器状态。一旦确定了Leader, 每个服务器就会更新自己的状态，如果是Follower,那么就变更为FOLLOWING,如果是Leader,就变更为LEADING。</p></li><li><p>添加主机。在新的Leader选举出来后Server3启动，其想发出新一轮的选举。但由于当前集群中各个主机的状态并不是LOOKING，而是各司其职的正常服务，所以其只能是以Follower的身份加入到集群中。</p></li></ol><p><strong>断连后的Leader选举</strong></p><p>在Zookeeper运行期间，Leader 与非Leader服务器各司其职，即便当有非Leader服务器宕机或新加入时也不会影响Leader。但是若Leader服务器挂了，那么整个集群将暂停对外服务，进入新轮的Leader选举，其过程和启动时期的Leader选举过程基本一致。</p><p>假设正在运行的有Server1、Server2、 Server3 三台服务器，当前Leader是Server2,若某一时刻Server2挂了，此时便开始新一轮的Leader选举了。选举过程如下:</p><ol><li>变更状态。Leader挂后，余下的非Observer服务器都会将自己的服务器状态由FOLLOWING变更为LOOKING,然后开始进入Leader 选举过程。</li><li>每个Server 会发出一个投票，仍然会首先投自己。不过，在运行期间每个服务器上的ZXID可能是不同，此时假定Server1的ZXID为111. Server3 的ZXID为333;在第一轮投票中，Server1和Server3都会投自己，产生投票(1,111)，(3,333)， 然后各自将投票发送给集群中所有机器。</li><li>接收来自各个服务器的投票。与启动时过程相同。集群的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票、是否来自LOOKING状态的服务器。</li><li>处理投票。与启动时过程相同，此时，Server1将会成为Leader。</li><li>统计投票。与启动时过程相同。针对每一个投票， 服务器都需要将别人的投票和自己的投票进行PK。对于Server1而言，它的投票是(1, 111)，接收Server3的投票为(3, 333)。其首先会比较两者的ZXID, Server3投票的zxid为333大于Server1 投票的zxid的111,于是Server1更新自己的投票为(3, 333),然后重新投票。对于Server3而言，其无须更新自己的投票，只是再次向集群中所有主机发出上一.次投票信息即可。经过票数统计，最终Server3当选新的Leader。</li><li>改变服务器的状态。与启动时过程相同。一旦确定 了Leader,每个服务器就会更新国英」自己的状态。Server1 变更为FOLLOWING, Server3 变更为LEADING.</li></ol><h4 id="恢复模式下的数据同步"><a class="markdownIt-Anchor" href="#恢复模式下的数据同步"></a> 恢复模式下的数据同步</h4><p>当完成Leader选举后，就要进入到恢复模式下的数据同步阶段。Leader 服务器会为每一个 Follower 服务器准备一个队列，并将那些没有被各个Follower服务器同步的事务以Proposal的形式逐条发给各个Follower服务器，并在每一个Proposal后都紧跟一个commit消息，表示该事务已经被提交，Follower可以直接接收并执行。当follower服务器将所有尚未同步的事务proposal都从leader服务器同步过来并成功执行后，会向准leader发送ACK信息。leader服务器在收到该ACK后就会将该follower加入到真正可用的follower列表。</p><h3 id="cap原则"><a class="markdownIt-Anchor" href="#cap原则"></a> CAP原则</h3><p>CAP原则又称CAP定理，指的是在一个分布式系统中, Consistency(<strong>一致性</strong>) Availability(<strong>可用性</strong>)、Partition tolerance (<strong>分区容错性</strong>),三者不可兼得。<br />      ●<strong>一致性</strong>©:分布式系统的所有主机中在同时刻是否可以保证具有完全相同的数据备份。若具有，则该分布式系统具有一致性。C<br />      ●  <strong>可用性</strong>(A):在集群中部分节点发生故障后，是否会影响对客户端读写请求的响应。注意，若在短时间内会影响，其也不具有这里所说的“可用性”。山<br />      ●  <strong>分区容错性</strong>(P):分布式系统中的一台主机称为一个分区。那么，什么是分布式系统的“错误”呢?分布式系统中各个主机无法保证数据的一致性是一 种错误; 分布式系统无法及时响应客户端请求，即不具有可用性也是一种错误。对于分布式系统，必须要具有对这些错误的“包容性”，即容错性，这是必须的。</p><h4 id="三二原则"><a class="markdownIt-Anchor" href="#三二原则"></a> 三二原则</h4><p>对于分布式系统，在CAP原则中分区容错性P是必须要保证的。但其并不能同时保证一致性与可用性。因为现在的分布式系统在满足了一致性的前提下，会牺牲可用性在满足了可用性的前提下，会牺牲一致性。所以，CAP原则对于一个分布式系统来说，只可能满足两项，即要么CP,要么AP。这就是CAP的三二原则。</p><p></p><h4 id="zk于cp"><a class="markdownIt-Anchor" href="#zk于cp"></a> zk于cp</h4><p>zk遵循的是CP原则，即保证了一致性，但牺牲了可用性。体现在哪里呢?。</p><p>当Leader宕机后，zk集群会马上进行新的Leader的选举。但选举时长在30-120秒间，整个选举期间zk集群是不接受客户端的读写操作的，即zk集群是处于瘫痪状态的。所以，其不满足可用性。</p><p>为什么Leader的选举需要这么长的时间呢?为了保证zk集群各个节点中数据的一致性，zk集群做了两类数据同步:初始化同步与更新同步。当新的Leader被选举出后，各个Follower需要将新Leader的数据同步到自己的缓存中，这是初始化同步;当Leader的数据被客户端修改后，其会向Follower发出广播，然后各个Follower会主动同步Leader的更新数据，这是更新同步。无论是初始化同步还是更新同步，zk 集群为了保证数据的一致性，若发现超过半数的Follower同步超时，则其会再次进行同步，而这个过程中zk集群是处于不可用状态的。</p><p>由于zk采用了CP原则，所以导致其可用性降低，这是其致命的问题。Spring Cloud的Eureka在分布式系统中所起的作用类似于zk，但其采用了AP原则，其牺牲了一致性，但保证了可用性</p><h2 id="zookeeper安装与集群搭建"><a class="markdownIt-Anchor" href="#zookeeper安装与集群搭建"></a> zookeeper安装与集群搭建</h2><h3 id="zookeeper环境准备"><a class="markdownIt-Anchor" href="#zookeeper环境准备"></a> zookeeper环境准备</h3><p><strong>下载</strong></p><p>下载完成后上传到Linux服务器</p><p><a href="http://mirrors.hust.edu.cn/apache/zookeeper/">http://mirrors.hust.edu.cn/apache/zookeeper/</a></p><p><strong>解压</strong>：解压到/usr/local目录</p><pre><code class="highlight plaintext">tar -zxvf /home/leeboer/leeftp/zookeeper-3.4.13.tar.gz -C /usr/local/</code></pre><p>可执行的命令在zookeeper根目录的bin目录下：</p><p><strong>注册path</strong></p><p>注册之前我们先建立一个软连接（防止以后更换zookeeper要重新注册path）</p><pre><code class="highlight plaintext">ln -s ./zookeeper-3.4.13 /usr/local/zookeeper</code></pre><p>将zookeeper的bin目录注册到path目录下：</p><pre><code class="highlight plaintext">vim /etc/profile</code></pre><p>在文档末尾写如下配置：</p><pre><code class="highlight plaintext">export ZK_HOME=/usr/local/zookeeperexport PATH=$ZK_HOME/bin:$PATH</code></pre><p>然后重新加载该文件</p><pre><code class="highlight plaintext">source /etc/profile</code></pre><h3 id="配置zookeeper"><a class="markdownIt-Anchor" href="#配置zookeeper"></a> 配置zookeeper</h3><p>该文件为zookeeper的样例<code>/zookeeper/conf/zoo_sample.cfg</code></p><p>拷贝一份：</p><pre><code class="highlight plaintext">cp zoo_sample.cfg zoo.cfg</code></pre><p>然后编辑<code>zoo.cfg</code></p><pre><code class="highlight plaintext"># The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial # synchronization phase can takeinitLimit=10# The number of ticks that can pass between # sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just # example sakes.# 快照存储的目录，(默认目录为/tmp/zookeeper)一定要更换！dataDir=/usr/data/zookeeper# the port at which the clients will connect# 端口clientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns=60## Be sure to read the maintenance section of the # administrator guide before turning on autopurge.## http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount=3# Purge task interval in hours# Set to &quot;0&quot; to disable auto purge feature#autopurge.purgeInterval=1 ~</code></pre><p><strong>启动zookeeper</strong></p><pre><code class="highlight plaintext">zkServer.sh start</code></pre><p><strong>重新启动</strong></p><pre><code class="highlight plaintext">zkServer.sh restart</code></pre><p><strong>关闭zookeeper</strong></p><pre><code class="highlight plaintext">zkServer.sh stop</code></pre><p><strong>查看zookeeper的状态</strong></p><pre><code class="highlight plaintext">zkServer.sh status</code></pre><p><strong>查看进程</strong></p><pre><code class="highlight plaintext">ps aux|grep aookeeper</code></pre><h2 id="zookeeper集群搭建"><a class="markdownIt-Anchor" href="#zookeeper集群搭建"></a> zookeeper集群搭建</h2><p>在刚才上面指定的zookeeper快照目录下<code>/usr/data/zookeeper</code></p><p>创建文件<code>myid</code>,内容写 1 就可以</p><pre><code class="highlight plaintext">echo 1 &gt; myid</code></pre><p><strong>配置zookeeper配置文件</strong></p><p><code>vim /usr/local/zookeeper/conf/zoo.cfg </code>加入：</p><ul><li>ip：连接端口号（数据同步时使用/随便写）：选举端口号（选举时使用/随便写）</li><li>如果需要指定observer，只需在最后加上 <code>:observer</code> 即可</li></ul><pre><code class="highlight plaintext">server.1=192.168.79.13:288:3888server.2=192.168.79.14:288:3888server.3=192.168.79.15:288:3888server.4=192.168.79.16:288:3888:observer</code></pre><blockquote><p>server.1/server.2/server.3每个zookeeper的配置文件都是上述这样即可</p></blockquote><blockquote><p>注意：server.4是observer，需要在配置文件中单独加一段配置</p></blockquote><pre><code class="highlight plaintext">peerType=observer</code></pre><p><strong>然后依次启动各个zookeeper即可</strong></p><pre><code class="highlight plaintext">zkServer.sh start</code></pre><blockquote><p>第一台启动时查看状态</p></blockquote><blockquote><p>第二台启动时查看状态</p></blockquote><blockquote><p>第三台启动时查看状态</p></blockquote><blockquote><p>当第二台挂掉后第三台自动选举为leader（因为myid大）</p></blockquote><h2 id="leader的选举机制"><a class="markdownIt-Anchor" href="#leader的选举机制"></a> leader的选举机制</h2><h3 id="myid"><a class="markdownIt-Anchor" href="#myid"></a> myid</h3><p>这是zk集群中服务器的唯一标识，称为myid。例如：有三个zk服务器，那么编号分别为1，2，3</p><h3 id="逻辑时钟"><a class="markdownIt-Anchor" href="#逻辑时钟"></a> 逻辑时钟</h3><p>逻辑时钟，Logicalock，是一个整型树，改概念在选举时称为logicalclock，而在zxid中则为epoch的值，即epoch和logicalclock是同一个值，在不同情况下的不同名称</p><h3 id="zk状态"><a class="markdownIt-Anchor" href="#zk状态"></a> zk状态</h3><ul><li><strong>LOOKING</strong>：选举状态（查找leader的状态）</li><li><strong>FOLLOWING</strong>：跟随状态，同步leader状态，处于该状态的服务器称为Follower。</li><li><strong>OBSERVING</strong>：观察状态，同步leader状态，处于该状态的服务器称为Observer</li><li><strong>LEADING</strong>：领导状态。处于该状态的服务器称为Leader</li></ul>]]>
    </content>
    <id>http://example.com/2022/12/29/zookeeper/</id>
    <link href="http://example.com/2022/12/29/zookeeper/"/>
    <published>2022-12-29T04:00:00.000Z</published>
    <summary>zookeeper是一个开源的分布式应用程序协调服务器，其为分布式系统提供一致性服务。其一致性是通过基于Paxos算法的ZAB协议完成的，其主要功能包括：配置维护，域名服务，分布式同步，集群管理等。</summary>
    <title>zookeeper</title>
    <updated>2026-02-27T01:41:21.403Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    <content>
      <![CDATA[<h1 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> $Linux</h1><h1 id="liunx"><a class="markdownIt-Anchor" href="#liunx"></a> Liunx</h1><ul><li><a href="">Liunx</a><ul><li><a href="">简介</a><ul><li><a href="">常见的Linux系统版本</a></li><li><a href="">应用领域</a></li><li><a href="">了解红帽认证</a></li></ul></li><li><a href="">系统目录结构</a></li><li><a href="">键盘操作技巧</a></li><li><a href="">使用命令</a><ul><li><a href="">识别命令</a><ul><li><a href="">type 显示命令的类型</a></li><li><a href="">which 显示一个可执行命令的位置</a></li></ul></li><li><a href="">得到帮助文档</a><ul><li><a href="">help 得到shell内部命令帮助文档</a></li><li><a href="">–help - 显示用法信息</a></li><li><a href="">whatis 显示非常简洁的命令说明</a></li></ul></li><li><a href="">alias 创建自己的命令</a></li><li><a href="">命令执行顺序</a></li></ul></li><li><a href="">命令展开</a><ul><li><a href="">路径名展开</a></li><li><a href="">波浪线展开</a></li><li><a href="">算数表达式展开</a></li><li><a href="">花括号展开</a></li><li><a href="">双引号</a></li><li><a href="">单引号</a></li><li><a href="">转义字符</a></li></ul></li><li><a href="">系统命令</a><ul><li><a href="">常用系统工作命令</a><ul><li><a href="">echo</a></li><li><a href="">date</a></li><li><a href="">reboot重启/poweroff关机</a></li><li><a href="">su/sudo</a></li><li><a href="">systemctl</a></li></ul></li><li><a href="">系统状态检测命令</a><ul><li><a href="">ifconfig命令</a></li><li><a href="">uname命令</a></li><li><a href="">uptime命令</a></li><li><a href="">free命令</a></li><li><a href="">who</a></li><li><a href="">last</a></li><li><a href="">history</a></li></ul></li><li><a href="">配置主机名称</a></li><li><a href="">配置网卡信息</a></li><li><a href="">Yum</a></li><li><a href="">计划任务服务程序</a><ul><li><a href="">一次性计划任务</a></li><li><a href="">长期性计划任务</a></li></ul></li></ul></li><li><a href="">文件权限</a><ul><li><a href="">文件属主和属组</a><ul><li><a href="">更改文件属组 chgrp</a></li><li><a href="">更改文件属主 chown</a></li></ul></li><li><a href="">文件权限 chmod</a></li><li><a href="">文件的特殊权限</a><ul><li><a href="">SUID</a></li><li><a href="">SGID</a></li><li><a href="">SBIT</a></li></ul></li><li><a href="">文件的隐藏属性</a><ul><li><a href="">chattr</a></li><li><a href="">lsattr</a></li></ul></li></ul></li><li><a href="">文件/目录</a><ul><li><a href="">处理目录常用命令</a><ul><li><a href="">ls(列出目录)</a></li><li><a href="">cd(切换目录)</a></li><li><a href="">pwd(显示目前所在的目录)</a></li><li><a href="">mkdir(创建新目录)</a></li><li><a href="">rmdir(删除空目录)</a></li><li><a href="">rm(移除文件或目录)</a></li><li><a href="">cp(复制文件或目录)</a></li><li><a href="">mv(移动文件与目录，或修改名称)</a></li><li><a href="">touch</a></li><li><a href="">dd</a></li><li><a href="">file(查看文件类型)</a></li></ul></li><li><a href="">软硬方式连接</a><ul><li><a href="">ln</a></li></ul></li><li><a href="">文件内容查看</a><ul><li><a href="">cat(由第一行开始显示文件内容)</a></li><li><a href="">tac(由最后一行开始显示文件内容)</a></li><li><a href="">nl(可以显示行号)</a></li><li><a href="">more(一页一页翻动)</a></li><li><a href="">less(一页一页翻动)</a></li><li><a href="">head(取出文件前几行)</a></li><li><a href="">tail(取出文件后几行)</a></li><li><a href="">tr(替换文本内容)</a></li><li><a href="">wc(统计行数)</a></li><li><a href="">stat(查看文件信息)</a></li><li><a href="">cut(提取列)</a></li><li><a href="">diff(比较)</a></li></ul></li><li><a href="">查找</a><ul><li><a href="">find</a></li><li><a href="">whereis</a></li><li><a href="">locate</a></li><li><a href="">which</a></li><li><a href="">grep</a></li></ul></li></ul></li><li><a href="">归档备份</a><ul><li><a href="">解压缩</a><ul><li><a href="">gzip</a></li><li><a href="">bzip2</a></li></ul></li><li><a href="">归档文件</a><ul><li><a href="">tar 打�</a>�</li><li><a href="">zip</a></li></ul></li></ul></li><li><a href="">用户/用户组管理</a><ul><li><a href="">用户账号的管理</a><ul><li><a href="">useradd(添加新用户)</a></li><li><a href="">userdel(删除账号)</a></li><li><a href="">usermod(修改账号)</a></li><li><a href="">passwd(用户口令的管理)</a></li></ul></li><li><a href="">用户组的管理</a><ul><li><a href="">group(增加用户组)</a></li><li><a href="">groupdel(删除用户组)</a></li><li><a href="">groupmod(修改用户组)</a></li><li><a href="">切换用户组</a></li></ul></li><li><a href="">与用户账号有关的系统文件</a><ul><li><a href="">/etc/passwd 用户信息</a></li><li><a href="">/etc/group 用户组</a></li><li><a href="">批量添加用户</a></li></ul></li></ul></li><li><a href="">管道符/重定向/环境变量</a><ul><li><a href="">输入输出重定向</a></li><li><a href="">管道命令符</a></li><li><a href="">命令行的通配符</a></li><li><a href="">常用的转义字符</a></li><li><a href="">重要的环境变量</a></li></ul></li><li><a href="">存储结构/磁盘划分</a><ul><li><a href="">物理设备的命名规则</a></li><li><a href="">挂载硬件设备</a><ul><li><a href="">mount</a></li><li><a href="">umount</a></li></ul></li><li><a href="">添加硬盘设备</a><ul><li><a href="">fdisk命令（分区）</a></li><li><a href="">mkfs（格式化）</a></li><li><a href="">du（查看文件数据占用量）</a></li></ul></li><li><a href="">添加交换分区</a></li></ul></li><li><a href="">vi/vim</a></li><li><a href="">进程</a><ul><li><a href="">ps 查看进程</a></li><li><a href="">top 显示任务</a></li><li><a href="">进程相关命令</a><ul><li><a href="">停止/暂停</a></li><li><a href="">放置到后台执行</a></li><li><a href="">jobs 显示活跃任务</a></li><li><a href="">fg/bg</a></li><li><a href="">pidof</a></li><li><a href="">kill /killall</a></li></ul></li></ul></li><li><a href="">shell环境变量</a><ul><li><a href="">查看环境变量</a></li><li><a href="">建立环境变量</a></li><li><a href="">export命令</a></li><li><a href="">修改shell环境</a></li></ul></li><li><a href="">软件包管理</a><ul><li><a href="">yum命令</a><ul><li><a href="">yum搜索软件�</a>�</li><li><a href="">yum安装软件�</a>�</li><li><a href="">yum卸载软件</a></li><li><a href="">yum更新软件�</a>�</li><li><a href="">配置阿里镜像</a></li><li><a href="">查找软件并删除</a></li></ul></li><li><a href="">rpm</a><ul><li><a href="">通过软件包文件来安装软件</a></li><li><a href="">经过软件包来升级软件</a></li><li><a href="">列出所安装的软件�</a>�</li><li><a href="">删除软件</a></li></ul></li></ul></li><li><a href="">网络系统</a><ul><li><a href="">检查和检测网络</a><ul><li><a href="">ping</a></li><li><a href="">netstat</a></li></ul></li><li><a href="">网络中传输文件</a><ul><li><a href="">ftp</a></li><li><a href="">wget 下载</a></li><li><a href="">scp远程拷贝</a></li></ul></li><li><a href="">SSH</a></li><li><a href="">防火墙</a><ul><li><a href="">打开防火墙</a></li><li><a href="">关闭防火墙</a></li><li><a href="">iptables</a><ul><li><a href="">策略与规则链</a></li><li><a href="">基本命令参数</a></li><li><a href="">允许某个ip某个端口访问</a></li><li><a href="">示例</a></li></ul></li><li><a href="">Firewalld</a><ul><li><a href="">终端管理工具</a></li><li><a href="">示例</a></li><li><a href="">图形管理工具</a></li></ul></li></ul></li><li><a href="">开放指定端口</a></li><li><a href="">服务的访问控制列表</a></li></ul></li><li><a href="">常用命令</a><ul><li><a href="">dirname/basename(截取路径)</a></li><li><a href="">w3m</a></li><li><a href="">split</a></li><li><a href="">cpulimit</a><ul><li><a href="">安�</a>�</li><li><a href="">使用</a></li></ul></li></ul></li></ul></li></ul><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><h3 id="常见的linux系统版本"><a class="markdownIt-Anchor" href="#常见的linux系统版本"></a> 常见的Linux系统版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、硬盘及文件系统控制及多任务功能的系统核心程序。而Linux发行套件系统是我们常说的Linux操作系统，也即是由Linux内核与各种常用软件的集合产品。全球大约有数百款的Linux系统版本，每个系统版本都有自己的特性和目标人群，下面将可以从用户的角度选出最热门的几款进行介绍。</p><ul><li>Linux的发行版<ul><li>指将Liunx内核与应用软件做一个打包</li><li>知名发行版有：Ubuntu，RedHat，CentOS，Debian，Fedora，SuSE，OpenSUSE，ArchLiunx，SolusOS</li></ul></li></ul><hr /><ul><li><strong>redhat</strong> 红帽企业系统（RedHatEnterpriseLinux,RHEL.）</li><li><img src="image/.png" alt=".png" /><ul><li>红帽公司是全球最大的开源技术厂商，RHEL是全世界内使用最广泛的Linux系统。</li><li>RHEL系统具有极强的性能与稳定性，并且在全球范围内拥有完善的技术支持。</li><li>RHEL系统也是本书、红帽认证以及众多生产环境中使用的系统。</li></ul></li></ul><hr /><ul><li><strong>CentOS</strong></li><li><img src="image/-1.png" alt="-1.png" /><ul><li>通过把RHEL系统重新编译并发布给用户免费使用的Linux系统，具有广泛的使用人群。CentOS当前已被红帽公司“收编”</li></ul></li></ul><hr /><ul><li><strong>Fedora</strong></li><li><img src="image/-2.png" alt="-2.png" /><ul><li>由红帽公司发布的桌面版系统套件（目前已经不限于桌面版）</li><li>用户可免费体验到最新的技术或工具，这些技术或工具在成熟后会被加入到RHEL系统中，因此Fedora也称为RHEL系统的“试验田”。</li><li>运维人员如果想时刻保持自己的技术领先，就应该多关注此类Linux系统的发展变化及新特性，不断改变自己的学习方向。</li></ul></li></ul><hr /><ul><li><strong>openSUSE</strong></li><li><img src="image/-3.png" alt="-3.png" /><ul><li>源自德国的一款著名的Linux系统，在全球范围内有着不错的声誉及市场占有率。</li></ul></li></ul><hr /><ul><li><strong>Gentoo</strong></li><li><img src="image/-4.png" alt="-4.png" /><ul><li>具有极高的自定制性，操作复杂，因此适合有经验的人员使用。读者可以在学习完本书后尝试一下该系统。</li></ul></li></ul><hr /><ul><li><strong>Debian</strong></li><li><img src="image/-5.png" alt="-5.png" /><ul><li>稳定性、安全性强，提供了免费的基础支持，可以良好地支持各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。</li></ul></li></ul><hr /><ul><li><strong>Ubuntu</strong></li><li><img src="image/-6.png" alt="-6.png" /><ul><li>是一款派生自Debian的操作系统，对新款硬件具有极强的兼容能力。Ubuntu与Fedora都是极其出色的Linux桌面系统，而且Ubuntu也可用于服务器领域。</li></ul></li></ul><p>现在国内大多数Linux相关的图书都是围绕CentOS系统编写的，作者大多也会给出围绕CentOS进行写作的一系列理由，但是很多理由都站不住脚，根本没有剖析到CentOS系统与RHEL系统的本质关系。CentOS系统是通过把RHEL系统释放出的程序源代码经过二次编译之后生成的一种Linux系统，其命令操作和服务配置方法与RHEL完全相同，但是去掉了很多收费的服务套件功能，而且还不提供任何形式的技术支持，出现问题后只能由运维人员自己解决。经过这般分析基本上可以判断出，选择CentOS的理由只剩下—免费！当人们大举免费、开源、正义的旗帜来宣扬CentOS系统的时候，殊不知CentOS系统其实早在2014年年初就已经被红帽公司“收编”，当前只是战略性的免费而已。再者说，根据GNU GPL许可协议，我们同样也可以免费使用RHEL系统，甚至是修改其代码创建衍生产品。开源系统在自由程度上没有任何差异，更无关道德问题。</p><h3 id="应用领域"><a class="markdownIt-Anchor" href="#应用领域"></a> 应用领域</h3><ul><li>Linux应用领域<ul><li>嵌入设备，超级计算机，服务器</li><li>通常服务器使用LAMP（Liunx+Apache+MySQL+PHP）或LNMP（Linux+Nginx+MySQL+PHP）组合</li></ul></li><li>Linux vs Windows</li></ul><table><thead><tr><th>比较</th><th>Windows</th><th>Linux</th></tr></thead><tbody><tr><td>界面</td><td>界面统一，外壳程序固定所有Windows程序菜单几乎一致，快捷键也几乎相同</td><td>图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux的终端机是从UNIX传承下来，基本命令和操作方法也几乎一致。</td></tr><tr><td>驱动程序</td><td>驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的Windows下的驱动，也会比较头痛</td><td>由志愿者开发，由Linux核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在Windows下很难支持的也容易找到驱动。HP、Intel、AMD等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解</td></tr><tr><td>使用</td><td>使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利</td><td>图形界面使用简单，容易入门。文字界面，需要学习才能掌握</td></tr><tr><td>学习</td><td>系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难</td><td>系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易</td></tr><tr><td>软件</td><td>每一种特定功能可能都需要商业软件的支持，需要购买相应的授权</td><td>大部分软件都可以自由获取，同样功能的软件选择较少</td></tr></tbody></table><h3 id="了解红帽认证"><a class="markdownIt-Anchor" href="#了解红帽认证"></a> 了解红帽认证</h3><p>红帽公司成立于1993年，是全球首家收入超10亿美元的开源公司，总部位于美国，分支机构遍布全球。红帽公司作为全球领先的开源和Linux系统提供商，其产品已被业界广泛认可并使用，尤其是RHEL系统在业内拥有超高的Linux系统市场占有率。红帽公司除了提供操作系统之外，还提供了虚拟化、中间件、应用程序、管理和面向服务架构的解决方案。</p><p>红帽认证是由红帽公司推出的Linux认证，该认证被认为是Linux行业乃至整个IT领域价值最高的认证之一。红帽认证考试全部采用上机形式，在考察学生基础理论能力的同时还考察了实践动手操作以及排错能力。红帽公司针对红帽认证制定了完善的专业评估与认证标准，其认证主要包括红帽认证系统管理员（RHCSA）、红帽认证工程师（RHCE）与红帽认证架构师（RHCA）。</p><p>2014年6月10日，红帽公司在发布新版红帽企业版系统（RHEL 7）的当天即在红帽英文官网更新了其对RHCSA与RHCE培训政策的调整，考生只有先通过红帽RHCSA认证后才能考取红帽RHCE认证。</p><p><img src="image/-7.png" alt="-7.png" /></p><h2 id="系统目录结构"><a class="markdownIt-Anchor" href="#系统目录结构"></a> 系统目录结构</h2><p>登录系统后，在当前命令窗口下输入命令：</p><pre><code class="highlight plaintext">ls /</code></pre><p>你会看到如下图所示:</p><p><img src="image/-8.png" alt="-8.png" /></p><p>树状目录结构：</p><p><img src="image/-9.png" alt="-9.png" /></p><p>系统启动必须：</p><ul><li><strong>/boot</strong>：这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li><li><strong>/etc</strong>：这个目录用来存放所有的系统管理所需要的配置文件和子目录，更改该目录下的文件可能导致系统无法启动。</li><li><strong>/lib</strong>：存放基本代码库（比如c++库），其作用类似于Windows的DDL文件，几乎所有的应用程序都需要用到这些共享库。</li><li><strong>/sys</strong>：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</li></ul><p>指令集合：</p><ul><li><strong>/bin</strong>：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li><li><strong>/sbin</strong>：s就是super user的意思，这里存放的是系统管理员使用的系统管理程序。</li></ul><p>外部文件管理：</p><ul><li><strong>/dev</strong> ：dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</li><li><strong>/media</strong>：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li><li><strong>/mnt</strong>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</li></ul><p>临时文件：</p><ul><li><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run</li><li><strong>/tmp</strong>：这个目录用来存放一些临时文件。</li><li><strong>/lost+found</strong>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li></ul><p>账户：</p><ul><li><strong>/root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。</li><li><strong>/home</strong>：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li><li><strong>/usr</strong>：这是一个很重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于Windows的program files目录。</li><li><strong>/usr/bin</strong>：系统用户使用的应用程序。</li><li><strong>/usr/sbin</strong>：超级用户使用的比较高级的管理程序和系统守护程序。</li><li><strong>usr/src</strong>：内核源代码默认的放置位置。</li></ul><p>运行过程中要用：</p><ul><li><strong>/var</strong>：这个目录中存放着不断扩充的东西，我们习惯将那些经常被修改的目录存放到这个目录下，包括各种日志文件。</li><li><strong>/proc</strong>：管理内存空间！虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。</li></ul><p>扩展用：</p><ul><li><strong>/opt</strong>：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</li><li><strong>/srv</strong>：该目录存放一些服务启动之后需要提取的数据。</li><li><strong>/selinux</strong>：这个目录是Redhat/CentOS所持有的目录，Selinux是一个安全机制，类似于Windows的防火墙，到那时这套机制比较复杂，这个目录就是存放selinux相关文件的。</li></ul><hr /><p>在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。</p><blockquote><p>/etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。</p></blockquote><blockquote><p>/bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在/bin/ls 目录下的。</p></blockquote><blockquote><p>值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给root使用的指令。</p></blockquote><blockquote><p>/var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在/var/log 目录下，另外mail的预设放置也是在这里。</p></blockquote><h2 id="键盘操作技巧"><a class="markdownIt-Anchor" href="#键盘操作技巧"></a> 键盘操作技巧</h2><p>开玩笑地说，我经常把 Unix 描述为“这个操作系统是为喜欢敲键盘的人们服务的。” 当然，Unix 甚至还有一个命令行，这个事实是个确凿的证据，证明了我所说的话。 但是命令行用户不喜欢敲入那么多字。那又为什么如此多的命令会有这样简短的命令名，像 cp，ls，mv，和 rm？事实上，命令行最为珍视的目标之一就是懒惰；用最少的击键次数 来完成最多的工作。另一个目标是你的手指永远不必离开键盘，永不触摸鼠标。在这一 章节，我们将看一下 bash 特性，这些特性使键盘使用起来更加迅速，更加高效。以下命令将会露面：</p><ul><li>clear － 清空屏幕</li><li>history － 显示历史列表内容</li></ul><p><strong>移动光标</strong></p><table><thead><tr><th>按键</th><th>行动</th></tr></thead><tbody><tr><td>Ctrl-a</td><td>移动光标到行首。</td></tr><tr><td>Ctrl-e</td><td>移动光标到行尾。</td></tr><tr><td>Ctrl-f</td><td>光标前移一个字符；和右箭头作用一样。</td></tr><tr><td>Ctrl-b</td><td>光标后移一个字符；和左箭头作用一样。</td></tr><tr><td>Alt-f</td><td>光标前移一个字。</td></tr><tr><td>Alt-b</td><td>光标后移一个字。</td></tr><tr><td>Ctrl-l</td><td>清空屏幕，移动光标到左上角。clear 命令完成同样的工作。</td></tr></tbody></table><p><strong>修改文本</strong></p><table><thead><tr><th>按键</th><th>行动</th></tr></thead><tbody><tr><td>Ctrl-d</td><td>删除光标位置的字符。</td></tr><tr><td>Ctrl-t</td><td>光标位置的字符和光标前面的字符互换位置。</td></tr><tr><td>Alt-t</td><td>光标位置的字和其前面的字互换位置。</td></tr><tr><td>Alt-l</td><td>把从光标位置到字尾的字符转换成小写字母。</td></tr><tr><td>Alt-u</td><td>把从光标位置到字尾的字符转换成大写字母。</td></tr></tbody></table><p><strong>剪切/粘贴文本</strong></p><table><thead><tr><th>按键</th><th>行动</th></tr></thead><tbody><tr><td>Ctrl-k</td><td>剪切从光标位置到行尾的文本。</td></tr><tr><td>Ctrl-u</td><td>剪切从光标位置到行首的文本。</td></tr><tr><td>Alt-d</td><td>剪切从光标位置到词尾的文本。</td></tr><tr><td>Alt-Backspace</td><td>剪切从光标位置到词头的文本。如果光标在一个单词的开头，剪切前一个单词。</td></tr><tr><td>Ctrl-y</td><td>把剪切环中的文本粘贴到光标位置。</td></tr></tbody></table><p><strong>搜索历史命令</strong></p><p>在任何时候，我们都可以浏览历史列表的内容，通过：</p><pre><code class="highlight plaintext">$ history | less</code></pre><p>在默认情况下，bash 会存储你所输入的最后 500 个命令。在随后的章节里，我们会知道 怎样调整这个数值。比方说我们想要找到列出目录 /usr/bin 内容的命令。一种方法，我们可以这样做：</p><pre><code class="highlight plaintext">$ history | grep /usr/bin</code></pre><p>比方说在我们的搜索结果之中，我们得到一行，包含了有趣的命令，像这样；</p><pre><code class="highlight plaintext">88  ls -l /usr/bin &gt; ls-output.txt</code></pre><p>数字 “88” 是这个命令在历史列表中的行号。随后在使用另一种展开类型时，叫做 历史命令展开，我们会用到这个数字。我们可以这样做，来使用我们所发现的行：</p><pre><code class="highlight plaintext">$ !88</code></pre><h2 id="使用命令"><a class="markdownIt-Anchor" href="#使用命令"></a> 使用命令</h2><p>命令可以是下面四种形式之一：</p><ul><li><strong>可执行程序</strong>，就像我们所看到的位于目录/usr/bin 中的文件一样。 属于这一类的程序，可以编译成二进制文件，诸如用 C 和 C++语言写成的程序, 也可以是由脚本语言写成的程序，比如说 shell，perl，python，ruby，等等。</li><li><strong>内建于 shell 自身的命令</strong>。bash 支持若干命令，内部叫做 shell 内部命令 (builtins)。例如，cd 命令，就是一个 shell 内部命令。</li><li><strong>shell 函数</strong>。这些是小规模的 shell 脚本，它们混合到环境变量中。 在后续的章节里，我们将讨论配置环境变量以及书写 shell 函数。但是现在， 仅仅意识到它们的存在就可以了。</li><li><strong>命令别名</strong>。我们可以定义自己的命令，建立在其它命令之上。</li></ul><h3 id="识别命令"><a class="markdownIt-Anchor" href="#识别命令"></a> 识别命令</h3><h4 id="type-显示命令的类型"><a class="markdownIt-Anchor" href="#type-显示命令的类型"></a> type 显示命令的类型</h4><p>type 命令是 shell 内部命令，它会显示命令的类别，给出一个特定的命令名（做为参数）。 它像这样工作：</p><pre><code class="highlight plaintext">type command</code></pre><p>例子：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ type typetype is a shell builtins[me@linuxbox ~]$ type lsls is aliased to `ls --color=tty`[me@linuxbox ~]$ type cpcp is /bin/cp</code></pre><p>我们看到这三个不同命令的检测结果。注意，ls 命令（在 Fedora 系统中）的检查结果，ls 命令实际上 是 ls 命令加上选项”–color=tty”的别名。现在我们知道为什么 ls 的输出结果是有颜色的！</p><h4 id="which-显示一个可执行命令的位置"><a class="markdownIt-Anchor" href="#which-显示一个可执行命令的位置"></a> which 显示一个可执行命令的位置</h4><p>有时候在一个操作系统中，不只安装了可执行程序的一个版本。然而在桌面系统中，这并不普遍， 但在大型服务器中，却很平常。为了确定所给定的执行程序的准确位置，使用 which 命令：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ which ls/bin/ls</code></pre><p>这个命令只对可执行程序有效，不包括内部命令和命令别名，别名是真正的可执行程序的替代物。 当我们试着使用 shell 内部命令时，例如，cd 命令，我们或者得不到回应，或者是个错误信息：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ which cd/usr/bin/which: no cd in(/opt/jre1.6.0_03/bin:/usr/lib/qt-3.3/bin:/usr/kerberos/bin:/opt/jre1.6.0_03/bin:/usr/lib/ccache:/usr/local/bin:/usr/bin:/bin:/home/me/bin)</code></pre><h3 id="得到帮助文档"><a class="markdownIt-Anchor" href="#得到帮助文档"></a> 得到帮助文档</h3><h4 id="help-得到shell内部命令帮助文档"><a class="markdownIt-Anchor" href="#help-得到shell内部命令帮助文档"></a> help 得到shell内部命令帮助文档</h4><p>bash 有一个内建的帮助工具，可供每一个 shell 内部命令使用。输入“help”，接着是 shell 内部命令名。例如：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ help cdcd: cd [-L|-P] [dir]Change ...</code></pre><p>注意表示法：出现在命令语法说明中的方括号，表示可选的项目。一个竖杠字符 表示互斥选项。在上面 cd 命令的例子中：</p><pre><code class="highlight plaintext">cd [-L|-P] [dir]</code></pre><p>这种表示法说明，cd 命令可能有一个“-L”选项或者“-P”选项，进一步，可能有参数“dir”。</p><h4 id="help-显示用法信息"><a class="markdownIt-Anchor" href="#help-显示用法信息"></a> –help - 显示用法信息</h4><p>许多可执行程序支持一个 --help 选项，这个选项是显示命令所支持的语法和选项说明。例如：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ mkdir --helpUsage: mkdir [OPTION] DIRECTORY...Create ...</code></pre><h4 id="whatis-显示非常简洁的命令说明"><a class="markdownIt-Anchor" href="#whatis-显示非常简洁的命令说明"></a> whatis 显示非常简洁的命令说明</h4><p>whatis 程序显示匹配特定关键字的手册页的名字和一行命令说明：</p><blockquote><p>最晦涩难懂的手册页</p><p>正如我们所看到的，Linux 和类 Unix 的系统提供的手册页，只是打算作为参考手册使用， 而不是教材。许多手册页都很难阅读，但是我认为由于阅读难度而能拿到特等奖的手册页应该是 bash 手册页。因为我正在为这本书做我的研究，所以我很仔细地浏览了整个 bash 手册，为的是确保我讲述了 大部分的 bash 主题。当把 bash 参考手册整个打印出来，其篇幅有八十多页且内容极其紧密， 但对于初学者来说，其结构安排毫无意义。</p><p>另一方面，bash 参考手册的内容非常简明精确，同时也非常完善。所以，如果你有胆量就查看一下， 并且期望有一天你能读懂它。</p></blockquote><h3 id="alias-创建自己的命令"><a class="markdownIt-Anchor" href="#alias-创建自己的命令"></a> alias 创建自己的命令</h3><p>现在是时候，感受第一次编程经历了！我们将用 alias 命令创建我们自己的命令。但在 开始之前，我们需要展示一个命令行小技巧。<strong>可以把多个命令放在同一行上，命令之间 用”;”分开</strong>。它像这样工作：</p><pre><code class="highlight plaintext">command1; command2; command3...</code></pre><p>我们会用到下面的例子：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ cd /usr; ls; cd -bin  games    kerberos  lib64    local  share  tmp...[me@linuxbox ~]$</code></pre><p>正如我们看到的，我们在一行上联合了三个命令。首先更改目录到/usr，然后列出目录 内容，最后回到原始目录（用命令”cd ~”）,结束在开始的地方。现在，通过 alia 命令 把这一串命令转变为一个命令。我们要做的第一件事就是为我们的新命令构想一个名字。 比方说”test”。在使用”test”之前，查明是否”test”命令名已经存在系统中，是个很不错 的主意。为了查清此事，可以使用 type 命令：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ type testtest is a shell builtin</code></pre><p>哦！”test”名字已经被使用了。试一下”foo”:</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ type foobash: type: foo: not found</code></pre><p>太棒了！”foo”还没被占用。创建命令别名：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ alias foo=&#x27;cd /usr; ls; cd -&#x27;</code></pre><p><strong>创建命令</strong> 注意命令结构：</p><pre><code class="highlight plaintext">alias name=&#x27;string&#x27;</code></pre><blockquote><p>在命令”alias”之后，输入“name”，紧接着（没有空格）是一个等号，等号之后是 一串用引号引起的字符串，字符串的内容要赋值给 name。我们定义了别名之后， 这个命令别名可以使用在任何地方。</p></blockquote><p><strong>删除别名</strong></p><pre><code class="highlight plaintext">[me@linuxbox ~]$ unalias foo[me@linuxbox ~]$ type foobash: type: foo: not found</code></pre><p><strong>查看所有的别名</strong></p><pre><code class="highlight plaintext">[me@linuxbox ~]$ aliasalias l.=&#x27;ls -d .* --color=tty&#x27;</code></pre><h3 id="命令执行顺序"><a class="markdownIt-Anchor" href="#命令执行顺序"></a> 命令执行顺序</h3><p>Linux顺序执行共有三种符号：</p><ul><li><strong>command1 &amp;&amp; command2</strong>: &amp;&amp;左边的command1执行成功(返回0表示成功)后，&amp;&amp;右边的command2才能被执行。</li><li><strong>command1 || command2</strong>: 如果||左边的command1执行失败(返回1表示失败)，就执行&amp;&amp;右边的command2。</li><li><strong>command1 ; command2</strong>: 命令顺序执行</li></ul><pre><code class="highlight plaintext">#第一个命令执行不成功,第二个命令才执行[tough@toughhou shell]cata||touchacat:a:Nosuchfileordirectory[tough@toughhoushell]  ls a  getpath.sh #第一个命令执行成功,第二个命令不执行[tough@toughhou shell]cata||touchb[tough@toughhoushell]  ls a  getpath.sh #只有第一个命令(touch a)执行成功,才执行第二个命令(touch b) [tough@toughhou shell]touch a &amp;&amp; touch b[tough@toughhou shell] ls a  b  getpath.sh #因为第一个命令执行不成功,所以第二个命令没执行[tough@toughhou shell]cat a1 &amp;&amp; touch c    cat: a1: No such file or directory    [tough@toughhou shell] ls a  b  getpath.sh #命令顺序执行[tough@toughhou shell]$ pwd;more a;date /home/tough/shell 123 Sun Oct 13 10:24:55 CST 2013 &lt;br&gt;&lt;br data-tomark-pass&gt;&lt;br data-tomark-pass&gt;</code></pre><h2 id="命令展开"><a class="markdownIt-Anchor" href="#命令展开"></a> 命令展开</h2><p>每一次你输入一个命令，然后按下 enter 键，在 bash 执行你的命令之前，bash 会对输入 的字符完成几个步骤处理。我们已经知道两三个案例，怎样一个简单的字符序列，例如<code>“*”</code>, 对 shell 来说，有很多的涵义。</p><p>使这个发生的过程叫做（字符）展开。通过展开， 你输入的字符，在 shell 对它起作用之前，会展开成为别的字符。</p><h3 id="路径名展开"><a class="markdownIt-Anchor" href="#路径名展开"></a> 路径名展开</h3><p>这种通配符工作机制叫做路径名展开。如果我们试一下在之前的章节中使用的技巧， 我们会看到它们真是要展开的字符。给出一个家目录，它看起来像这样：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ lsDesktop   ls-output.txt   Pictures   Templates....</code></pre><p>我们能够执行以下参数展开模式：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo D*Desktop  Documents</code></pre><p>和：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo *sDocuments Pictures Templates Videos</code></pre><p>甚至是：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo [[:upper:]]*Desktop Documents Music Pictures Public Templates Videos</code></pre><p>查看家目录之外的目录：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo /usr/*/share/usr/kerberos/share  /usr/local/share</code></pre><h3 id="波浪线展开"><a class="markdownIt-Anchor" href="#波浪线展开"></a> 波浪线展开</h3><p>可能你从我们对 cd 命令的介绍中回想起来，波浪线字符(“~”)有特殊的意思。当它用在 一个单词的开头时，它会展开成指定用户的家目录名，如果没有指定用户名，则是当前用户的家目录：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo ~/home/me</code></pre><p>如果有用户”foo”这个帐号，然后：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo ~foo/home/foo</code></pre><h3 id="算数表达式展开"><a class="markdownIt-Anchor" href="#算数表达式展开"></a> 算数表达式展开</h3><p>shell 允许算术表达式通过展开来执行。这允许我们把 shell 提示当作计算器来使用：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo $((2 + 2))4</code></pre><p>算术表达式展开使用这种格式：</p><pre><code class="highlight plaintext">$((expression))</code></pre><p>（以上括号中的）表达式是指算术表达式，它由数值和算术操作符组成。算术表达式只支持整数（全部是数字，不带小数点），但是能执行很多不同的操作。这里是 一些它支持的操作符：</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>/</td><td>除（但是记住，因为展开只是支持整数除法，所以结果是整数。）</td></tr><tr><td>%</td><td>取余，只是简单的意味着，“余数”</td></tr><tr><td>**</td><td>取幂</td></tr></tbody></table><p>在算术表达式中空格并不重要，并且表达式可以嵌套。例如，5的平方乘以3：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo $(($((5**2)) * 3))75</code></pre><p>一对括号可以用来把多个子表达式括起来。通过这个技术，我们可以重写上面的例子， 同时用一个展开代替两个，来得到一样的结果：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo $(((5**2) * 3))75</code></pre><p>这是一个使用除法和取余操作符的例子。注意整数除法的结果：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo Five divided by two equals $((5/2))Five divided by two equals 2[me@linuxbox ~]$ echo with $((5%2)) left over.with 1 left over.</code></pre><h3 id="花括号展开"><a class="markdownIt-Anchor" href="#花括号展开"></a> 花括号展开</h3><p>可能最奇怪的展开是花括号展开。通过它，你可以从一个包含花括号的模式中 创建多个文本字符串。这是一个例子：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo Front-&#123;A,B,C&#125;-BackFront-A-Back Front-B-Back Front-C-Back</code></pre><p>花括号展开模式可能包含一个开头部分叫做报头，一个结尾部分叫做附言。花括号表达式本身可 能包含一个由逗号分开的字符串列表，或者一系列整数，或者单个的字符串。这种模式不能 嵌入空白字符。这个例题使用了一系列整数：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo Number_&#123;1..5&#125;Number_1  Number_2  Number_3  Number_4  Number_5</code></pre><p>例如， 如果我们是摄影师，有大量的相片。我们想把这些相片按年月先后组织起来。首先， 我们要创建一系列以数值”年－月”形式命名的目录。通过这种方式，目录名按照 年代顺序排列。我们可以键入整个目录列表，但是工作量太大了，并且易于出错。 反而，我们可以这样做：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ mkdir Pics[me@linuxbox ~]$ cd Pics[me@linuxbox Pics]$ mkdir &#123;2007..2009&#125;-0&#123;1..9&#125; &#123;2007..2009&#125;-&#123;10..12&#125;[me@linuxbox Pics]$ ls2007-01 2007-07 2008-01 2008-07 2009-01 2009-072007-02 2007-08 2008-02 2008-08 2009-02 2009-082007-03 2007-09 2008-03 2008-09 2009-03 2009-092007-04 2007-10 2008-04 2008-10 2009-04 2009-102007-05 2007-11 2008-05 2008-11 2009-05 2009-112007-06 2007-12 2008-06 2008-12 2009-06 2009-12</code></pre><h3 id="双引号"><a class="markdownIt-Anchor" href="#双引号"></a> 双引号</h3><p>我们将要看一下引用的第一种类型，双引号。如果你把文本放在双引号中， shell 使用的特殊字符，除了 <code>$，\ (反斜杠），和 </code>（倒引号）之外`， 则失去它们的特殊含义，被当作普通字符来看待。这意味着单词分割，路径名展开， 波浪线展开，和花括号展开都被禁止，然而参数展开，算术展开，和命令替换 仍然执行。使用双引号，我们可以处理包含空格的文件名。比方说我们是不幸的 名为 two words.txt 文件的受害者。如果我们试图在命令行中使用这个 文件，单词分割机制会导致这个文件名被看作两个独自的参数，而不是所期望 的单个参数：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ ls -l two words.txtls: cannot access two: No such file or directoryls: cannot access words.txt: No such file or directory</code></pre><p>使用双引号，我们可以阻止单词分割，得到期望的结果；进一步，我们甚至可以修复 破损的文件名。</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ ls -l &quot;two words.txt&quot;-rw-rw-r-- 1 me   me   18 2008-02-20 13:03 two words.txt[me@linuxbox ~]$ mv &quot;two words.txt&quot; two_words.txt</code></pre><p>你瞧！现在我们不必一直输入那些讨厌的双引号了。记住，在双引号中，参数展开，算术表达式展开，和命令替换仍然有效：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo &quot;$USER $((2+2)) $(cal)&quot;me 4    February 2008Su Mo Tu We Th Fr Sa</code></pre><p>在默认情况下，单词分割机制会在单词中寻找空格，制表符，和换行符，并把它们看作 单词之间的界定符。它们只作为分隔符使用。因为它们把单词分为不同的参数，在范例中， 命令行包含一个带有四个不同参数的命令。如果我们加上双引号：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo this is a   testthis is a test[me@linuxbox ~]$ echo &quot;this is a    test&quot;this is a    test</code></pre><p>单词分割被禁止，内嵌的空格也不会被当作界定符，它们成为参数的一部分。 一旦加上双引号，我们的命令行就包含一个带有一个参数的命令。</p><h3 id="单引号"><a class="markdownIt-Anchor" href="#单引号"></a> 单引号</h3><p>如果需要禁止所有的展开，我们使用单引号。以下例子是无引用，双引号，和单引号的比较结果：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USERtext /home/me/ls-output.txt a b foo 4 me[me@linuxbox ~]$ echo &quot;text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER&quot;text ~/*.txt   &#123;a,b&#125; foo 4 me[me@linuxbox ~]$ echo &#x27;text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER&#x27;text ~/*.txt  &#123;a,b&#125; $(echo foo) $((2+2)) $USER</code></pre><blockquote><p>正如我们所看到的，随着引用程度加强，越来越多的展开被禁止。</p></blockquote><h3 id="转义字符"><a class="markdownIt-Anchor" href="#转义字符"></a> 转义字符</h3><p>有时候我们只想引用单个字符。我们可以在字符之前加上一个反斜杠，在这个上下文中叫做转义字符。 经常在双引号中使用转义字符，来有选择地阻止展开。</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo &quot;The balance for user $USER is: \$5.00&quot;The balance for user me is: $5.00</code></pre><p>使用转义字符来消除文件名中一个字符的特殊含义，是很普遍的。例如，在文件名中可能使用 一些对于 shell 来说，有特殊含义的字符。这些字符包括”$”, “!”, “ “等字符。在文件名 中包含特殊字符，你可以这样做：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ mv bad\&amp;filename good_filename</code></pre><blockquote><p>为了允许反斜杠字符出现，输入”\“来转义。注意在单引号中，反斜杠失去它的特殊含义，它 被看作普通字符。</p></blockquote><h2 id="系统命令"><a class="markdownIt-Anchor" href="#系统命令"></a> 系统命令</h2><h3 id="常用系统工作命令"><a class="markdownIt-Anchor" href="#常用系统工作命令"></a> 常用系统工作命令</h3><h4 id="echo"><a class="markdownIt-Anchor" href="#echo"></a> echo</h4><p>echo命令用于<strong>在终端输出字符串或变量提取后的值</strong>，格式为</p><pre><code class="highlight plaintext">echo [字符串 | $变量]</code></pre><p>例如，把指定字符串“<a href="http://Linuxprobe.com">Linuxprobe.com</a>”输出到终端屏幕的命令为：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# echo Linuxprobe.Com</code></pre><p>该命令会在终端屏幕上显示如下信息：</p><pre><code class="highlight plaintext">Linuxprobe.Com</code></pre><p>下面，我们使用$变量的方式提取变量SHELL的值，并将其输出到屏幕上：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# echo $SHELL/bin/bash</code></pre><h4 id="date"><a class="markdownIt-Anchor" href="#date"></a> date</h4><p>date命令用于<strong>显示及设置系统的时间或日期</strong>，格式为</p><pre><code class="highlight plaintext">date [选项] [+指定的格式]</code></pre><p>只需在强大的<strong>date命令中输入以“+”号开头的参数，即可按照指定格式来输出系统的时间或日期</strong>，这样在日常工作时便可以把备份数据的命令与指定格式输出的时间信息结合到一起。例如，把打包后的文件自动按照“年-月-日”的格式打包成“backup-2017-9-1.tar.gz”，用户只需要看一眼文件名称就能大概了解到每个文件的备份时间了。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>%t</td><td>跳格[Tab键]</td></tr><tr><td>%Y</td><td>年</td></tr><tr><td>%m</td><td>月</td></tr><tr><td>%d</td><td>日</td></tr><tr><td>%H</td><td>小时（00～23）</td></tr><tr><td>%I</td><td>小时（00～12）</td></tr><tr><td>%M</td><td>分钟（00～59）</td></tr><tr><td>%S</td><td>秒（00～59）</td></tr><tr><td>%j</td><td>今年中的第几天</td></tr></tbody></table><p>按照默认格式查看当前系统时间的date命令如下所示：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# dateMon Aug 24 16:11:23 CST 2017</code></pre><p>按照“年-月-日 小时:分钟:秒”的格式查看当前系统时间的date命令如下所示：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# date &quot;+%Y-%m-%d %H:%M:%S&quot;2017-08-24 16:29:12</code></pre><p>将<strong>系统的当前时间设置</strong>为2017年9月1日8点30分的date命令如下所示：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# date -s &quot;20170901 8:30:00&quot;Fri Sep 1 08:30:00 CST 2017</code></pre><p>date命令中的参数%j可用来查看今天是当年中的第几天。这个参数能够很好地区分备份时间的新旧，即数字越大，越靠近当前时间。该参数的使用方式以及显示结果如下所示。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# date &quot;+%j&quot;244</code></pre><p>设置系统时间命令：</p><pre><code class="highlight plaintext">#date –set（月/日/年 时：分：秒）例：#date –set “10/11/10 10:15”</code></pre><p>查看硬件时间的命令：</p><pre><code class="highlight plaintext"># hwclock</code></pre><p>设置硬件时间的命令：</p><pre><code class="highlight plaintext"># hwclock –set –date = （月/日/年 时：分：秒）</code></pre><blockquote><p>上述提到的是手动设置时间到一个时间点，可能与当前网络的时间有误差。下面介绍一下与时间服务器上的时间同步的方法</p></blockquote><p><strong>设置系统时间与网络时间同步</strong></p><ol><li>安装ntpdate工具</li></ol><pre><code class="highlight plaintext">yum -y install ntp ntpdate</code></pre><ol><li>设置系统时间与网络时间同步</li></ol><pre><code class="highlight plaintext">ntpdate cn.pool.ntp.orgor =&gt;   ntpdate -u ntp.api.bz</code></pre><ol><li>将系统时间写入硬件时间</li></ol><pre><code class="highlight plaintext">hwclock –w</code></pre><ol><li>查看硬件时</li></ol><pre><code class="highlight plaintext">hwclock -show</code></pre><h4 id="reboot重启poweroff关机"><a class="markdownIt-Anchor" href="#reboot重启poweroff关机"></a> reboot重启/poweroff关机</h4><p><strong>reboot命令</strong>用于<strong>重启系统</strong></p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此默认只能使用root管理员来重启，其命令如下：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# reboot</code></pre><hr /><p><strong>poweroff命令</strong>用于<strong>关闭系统</strong></p><p>该命令与reboot命令相同，都会涉及硬件资源的管理权限，因此默认只有root管理员才可以关闭电脑，其命令如下：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# poweroff</code></pre><h4 id="susudo"><a class="markdownIt-Anchor" href="#susudo"></a> su/sudo</h4><p><strong>su命令可以解决切换用户身份的需求</strong>，使得当前用户在不退出登录的情况下，顺畅地切换到其他用户，比如从root管理员切换至普通用户：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# id uid=0(root) gid=0(root) groups=0(root)[root@linuxprobe ~]# su - linuxprobeLast login: Wed Jan 4 01:17:25 EST 2017 on pts/0[linuxprobe@linuxprobe ~]$ id uid=1000(linuxprobe) gid=1000(linuxprobe) groups=1000(linuxprobe) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</code></pre><blockquote><p>su命令与用户名之间有一个<strong>减号</strong>（-），这意味着完全切换到新的用户，即<strong>把环境变量信息也变更为新用户的相应信息</strong>，而不是保留原始的信息。强烈建议在切换用户身份时添加这个减号（-）</p></blockquote><blockquote><p>当从root管理员切换到普通用户时是不需要密码验证的，而从普通用户切换成root管理员就需要进行密码验证了</p></blockquote><hr /><p><strong>使用sudo命令把特定命令的执行权限赋予给指定用户</strong>，这样既可保证普通用户能够完成特定的工作，也可以避免泄露root管理员密码。我们要做的就是合理配置sudo服务，以便兼顾系统的安全性和用户的便捷性。sudo服务的配置原则也很简单—在保证普通用户完成相应工作的前提下，尽可能少地赋予额外的权限。</p><p>sudo命令用于给普通用户提供额外的权限来完成原本root管理员才能完成的任务，格式为</p><pre><code class="highlight plaintext">sudo [参数] 命令名称</code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-h</td><td>列出帮助信息</td></tr><tr><td>-l</td><td>列出当前用户可执行的命令</td></tr><tr><td>-u</td><td>用户名或UID值 以指定的用户身份执行命令</td></tr><tr><td>-k</td><td>清空密码的有效时间，下次执行sudo时需要再次进行密码验证</td></tr><tr><td>-b</td><td>在后台执行指定的命令</td></tr><tr><td>-p</td><td>更改询问密码的提示语</td></tr></tbody></table><h4 id="systemctl"><a class="markdownIt-Anchor" href="#systemctl"></a> systemctl</h4><p>在RHEL 7系统中是使用systemctl命令来管理服务的。</p><p>管理服务RHEL6与RHEL7管理服务的差别：</p><table><thead><tr><th>System V init命令（RHEL 6系统）</th><th>systemctl命令（RHEL 7系统） 作用</th></tr></thead><tbody><tr><td>service foo start</td><td>systemctl startfoo.service 启动服务</td></tr><tr><td>service foo restart</td><td>systemctl restartfoo.service 重启服务</td></tr><tr><td>service foo stop</td><td>systemctl stop foo.service 停止服务</td></tr><tr><td>service foo reload</td><td>systemctl reload foo.service 重新加载配置文件（不终止服务）</td></tr><tr><td>service foo status</td><td>systemctl status foo.service 查看服务状态表</td></tr><tr><td>chkconfig foo on</td><td>systemctl enable foo.service 开机自动启动</td></tr><tr><td>chkconfig foo off</td><td>systemctl disable foo.service 开机不自动启动</td></tr><tr><td>chkconfig foo</td><td>systemctl is-enabled foo.service 查看特定服务是否为开机自启动</td></tr><tr><td>chkconfig —list</td><td>systemctl list-unit-files — type=service查看各个级别下服务的启动与禁用情况</td></tr></tbody></table><p><strong>自定义systemctl命令启动服务</strong></p><p>在/usr/lib/systemd/system路径中自定义一个以.service结尾的脚本。</p><ul><li>定义完成后即可使用systemctl start sdmclient/systemctl stop sdmclient等命令</li></ul><p>如 sdmclient.service：</p><pre><code class="highlight plaintext">[Unit]Description=sdmclientAfter=network.target[Service]Type=forkingExecStart=/bin/bash /opt/SDM/client/client-cmds/Common/Linux/sdmclient7 startExecReload=/bin/bash /opt/SDM/client/client-cmds/Common/Linux/sdmclient7 restartExecStop=/bin/bash /opt/SDM/client/client-cmds/Common/Linux/sdmclient7 stopUser=root[Install]WantedBy=multi-user.target</code></pre><h3 id="系统状态检测命令"><a class="markdownIt-Anchor" href="#系统状态检测命令"></a> 系统状态检测命令</h3><p>作为一名合格的运维人员，想要更快、更好地了解Linux服务器，必须具备快速查看Linux系统运行状态的能力，因此接下来会逐个讲解与网卡网络、系统内核、系统负载、内存使用情况、当前启用终端数量、历史登录记录、命令执行记录以及救援诊断等相关命令的使用方法。这些命令都超级实用，还请读者用心学习，加以掌握</p><h4 id="ifconfig命令"><a class="markdownIt-Anchor" href="#ifconfig命令"></a> ifconfig命令</h4><p>ifconfig命令用于<strong>获取网卡配置与网络状态等信息</strong>，格式为</p><pre><code class="highlight plaintext">ifconfig [网络设备] [参数]</code></pre><p>使用ifconfig命令来查看本机当前的网卡配置与网络状态等信息时，其实主要查看的就是网卡名称、inet参数后面的IP地址、ether参数后面的网卡物理地址（又称为MAC地址），以及RX、TX的接收数据包与发送数据包的个数及累计流量（即下面加粗的信息内容）：</p><p><img src="image/-10.png" alt="-10.png" /></p><h4 id="uname命令"><a class="markdownIt-Anchor" href="#uname命令"></a> uname命令</h4><p>uname命令用于<strong>查看系统内核与系统版本等信息</strong>，格式</p><pre><code class="highlight plaintext">uname [-a]</code></pre><p>在使用uname命令时，一般会固定搭配上-a参数来完整地查看当前系统的内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# uname -aLinux linuxprobe.com 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2017 x86_64 x86_64 x86_64 GNU/Linux</code></pre><p>顺带一提，如果要查看当前系统版本的详细信息，则需要查看redhat-release文件，其命令以及相应的结果如下：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# cat /etc/redhat-releaseRed Hat Enterprise Linux Server release 7.0 (Maipo)</code></pre><h4 id="uptime命令"><a class="markdownIt-Anchor" href="#uptime命令"></a> uptime命令</h4><p>uptime用于<strong>查看系统的负载信息</strong>，格式为</p><pre><code class="highlight plaintext">uptime</code></pre><p>uptime命令真的很棒，它可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息。平均负载值指的是系统在最近1分钟、5分钟、15分钟内的压力情况（下面加粗的信息部分）；负载值越低越好，尽量不要长期超过1，在生产环境中不要超过5。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# uptime22:49:55 up 10 min, 2 users, load average: 0.01, 0.19, 0.18</code></pre><h4 id="free命令"><a class="markdownIt-Anchor" href="#free命令"></a> free命令</h4><p>free用于<strong>显示当前系统中内存的使用量信息</strong>，格式为</p><pre><code class="highlight plaintext">free [-h]</code></pre><p>为了保证Linux系统不会因资源耗尽而突然宕机，运维人员需要时刻关注内存的使用量。在使用free命令时，可以结合使用-h参数以更人性化的方式输出当前内存的实时使用量信息。</p><p>执行free -h命令后的输出信息</p><table><thead><tr><th></th><th>内存总量</th><th>已用量</th><th>可用量</th><th>进程共享的内存量</th><th>磁盘缓存的内存量</th><th>缓存的内存量</th></tr></thead><tbody><tr><td></td><td>total</td><td>used</td><td>free</td><td>shared</td><td>buffers</td><td>cached</td></tr><tr><td>Mem:</td><td>1.8G</td><td>1.3G</td><td>542M</td><td>9.8M</td><td>1.6M</td><td>413M</td></tr><tr><td>Swap:</td><td>2.0G</td><td>0B</td><td>2.0G</td><td></td><td></td><td></td></tr></tbody></table><h4 id="who"><a class="markdownIt-Anchor" href="#who"></a> who</h4><p>who用于<strong>查看当前登入主机的用户终端信息</strong></p><pre><code class="highlight plaintext">who [参数]</code></pre><p>这三个简单的字母可以快速显示出所有正在登录本机的用户的名称以及他们正在开启的终端信息。</p><p>执行who命令的结果：</p><table><thead><tr><th>登陆的用户名</th><th>终端设备</th><th>登陆到系统的时间</th></tr></thead><tbody><tr><td>root</td><td>pts/0</td><td>2020-06-04 09:16 (192.168.212.156)</td></tr><tr><td>root</td><td>pts/1</td><td>2020-06-10 09:35 (192.168.212.165)</td></tr><tr><td>root</td><td>pts/2</td><td>2020-06-04 09:06 (192.168.212.156)</td></tr><tr><td>root</td><td>pts/4</td><td>2020-06-09 15:20 (192.168.212.156)</td></tr><tr><td>root</td><td>pts/8</td><td>2020-06-08 09:55 (192.168.212.189)</td></tr><tr><td>root</td><td>pts/9</td><td>2020-06-08 10:17 (192.168.212.189)</td></tr><tr><td>root</td><td>pts/10</td><td>2020-06-08 10:18 (192.168.212.189)</td></tr></tbody></table><h4 id="last"><a class="markdownIt-Anchor" href="#last"></a> last</h4><p>last命令用于<strong>查看所有系统的登录记录</strong>，格式为</p><pre><code class="highlight plaintext">last [参数]</code></pre><p>使用last命令可以查看本机的登录记录。但是，由于这些信息都是以日志文件的形式保存在系统中，因此黑客可以很容易地对内容进行篡改。千万不要单纯以该命令的输出信息而判断系统有无被恶意入侵！</p><p><img src="image/-11.png" alt="-11.png" /></p><h4 id="history"><a class="markdownIt-Anchor" href="#history"></a> history</h4><p>history命令用于<strong>显示历史执行过的命令</strong>，格式为</p><pre><code class="highlight plaintext">history [-c]</code></pre><p>history命令应该是作者最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，还可以自定义/etc/profile文件中的HISTSIZE变量值。在使用history命令时，如果使用-c参数则会清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><p><img src="image/-12.png" alt="-12.png" /></p><p>要<strong>清空当前用户在本机上执行的Linux命令历史记录信息</strong>，可执行如下命令：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# history -c</code></pre><h3 id="配置主机名称"><a class="markdownIt-Anchor" href="#配置主机名称"></a> 配置主机名称</h3><p>为了便于在局域网中查找某台特定的主机，或者对主机进行区分，除了要有IP地址外，还要为主机配置一个主机名，主机之间可以通过这个类似于域名的名称来相互访问。在Linux系统中，主机名大多保存在/etc/hostname文件中，接下来将/etc/hostname文件的内容修改为“<a href="http://linuxprobe.com">linuxprobe.com</a>”，步骤如下。</p><ul><li>第1步：使用Vim编辑器修改“/etc/hostname”主机名称文件。</li><li>第2步：把原始主机名称删除后追加“<a href="http://linuxprobe.com">linuxprobe.com</a>”。注意，使用Vim编辑器修改主机名称文件后，要在末行模式下执行:wq!命令才能保存并退出文档。</li><li>第3步：保存并退出文档，然后使用hostname命令检查是否修改成功。</li></ul><pre><code class="highlight plaintext">$ vim /etc/hostnamelinuxprobe.com</code></pre><p>hostname命令用于查看当前的主机名称，但有时主机名称的改变不会立即同步到系统中，所以如果发现修改完成后还显示原来的主机名称，可重启虚拟机后再行查看：</p><pre><code class="highlight plaintext">$ hostnamelinuxprobe.com</code></pre><h3 id="配置网卡信息"><a class="markdownIt-Anchor" href="#配置网卡信息"></a> 配置网卡信息</h3><p>网卡IP地址配置的是否正确是两台服务器是否可以相互通信的前提。在Linux系统中，一切都是文件，因此配置网络服务的工作其实就是在编辑网卡配置文件.</p><p>如果您具备一定的运维经验或者熟悉早期的Linux系统，则在学习本书时会遇到一些不容易接受的差异变化。在RHEL 5、RHEL 6中，网卡配置文件的前缀为eth，第1块网卡为eth0，第2块网卡为eth1；以此类推。而在RHEL 7中，网卡配置文件的前缀则以ifcfg开始，加上网卡名称共同组成了网卡配置文件的名字，例如ifcfg-eno16777736；好在除了文件名变化外也没有其他大的区别。</p><p>现在有一个名称为ifcfg-eno16777736的网卡设备，我们将其配置为开机自启动，并且IP地址、子网、网关等信息由人工指定，其步骤应该如下所示。</p><ul><li>第1步：首先<strong>切换到/etc/sysconfig/network-scripts目录</strong>中（存放着网卡的配置文件）。</li><li>第2步：使用Vim编辑器修改网卡文件ifcfg-eno16777736，逐项写入下面的配置参数并保存退出。由于每台设备的硬件及架构是不一样的，因此请读者使用ifconfig命令自行确认各自网卡的默认名称。</li></ul><pre><code class="highlight plaintext">设备类型：TYPE=Ethernet地址分配模式：BOOTPROTO=static网卡名称：NAME=eno16777736是否启动：ONBOOT=yesIP地址：IPADDR=192.168.10.10子网掩码：NETMASK=255.255.255.0网关地址：GATEWAY=192.168.10.1DNS地址：DNS1=192.168.10.1</code></pre><ul><li>第3步：重启网络服务并测试网络是否联通。</li></ul><p>进入到网卡配置文件所在的目录，然后编辑网卡配置文件，在其中填入下面的信息：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# cd /etc/sysconfig/network-scripts/[root@linuxprobe network-scripts]# vim ifcfg-eno16777736TYPE=EthernetBOOTPROTO=staticNAME=eno16777736ONBOOT=yesIPADDR=192.168.10.10NETMASK=255.255.255.0GATEWAY=192.168.10.1DNS1=192.168.10.1</code></pre><p>执行<strong>重启网卡设备的命令</strong>（在正常情况下不会有提示信息），然后通过ping命令测试网络能否联通。由于在Linux系统中ping命令不会自动终止，因此需要手动按下Ctrl-c键来强行结束进程。</p><pre><code class="highlight plaintext">[root@linuxprobe network-scripts]# systemctl restart network[root@linuxprobe network-scripts]# ping 192.168.10.10PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.64 bytes from 192.168.10.10: icmp_seq=1 ttl=64 time=0.081 ms64 bytes from 192.168.10.10: icmp_seq=2 ttl=64 time=0.083 ms64 bytes from 192.168.10.10: icmp_seq=3 ttl=64 time=0.059 ms64 bytes from 192.168.10.10: icmp_seq=4 ttl=64 time=0.097 ms^C--- 192.168.10.10 ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 2999msrtt min/avg/max/mdev = 0.059/0.080/0.097/0.013 ms</code></pre><h3 id="yum"><a class="markdownIt-Anchor" href="#yum"></a> Yum</h3><p>yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。</p><p>基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p><p>yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p><p>语法:</p><pre><code class="highlight plaintext">yum [options] [command] [package ...]</code></pre><ul><li>options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为&quot;yes&quot;），-q（不显示安装的过程）等等。</li><li>command：要进行的操作。</li><li>package操作的对象。</li></ul><hr /><ul><li>1.列出所有可更新的软件清单命令：yum check-update</li><li>2.更新所有软件命令：yum update</li><li>3.仅安装指定的软件命令：yum install &lt;package_name&gt;</li><li>4.仅更新指定的软件命令：yum update &lt;package_name&gt;</li><li>5.列出所有可安裝的软件清单命令：yum list</li><li>6.删除软件包命令：yum remove &lt;package_name&gt;</li><li>7.查找软件包 命令：yum search <keyword></li><li>8.清除缓存命令:<ul><li>yum clean packages: 清除缓存目录下的软件包</li><li>yum clean headers: 清除缓存目录下的 headers</li><li>yum clean oldheaders: 清除缓存目录下旧的 headers</li><li>yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers</li></ul></li></ul><h3 id="计划任务服务程序"><a class="markdownIt-Anchor" href="#计划任务服务程序"></a> 计划任务服务程序</h3><p>经验丰富的系统运维工程师可以使得Linux在无需人为介入的情况下，在指定的时间段自动启用或停止某些服务或命令，从而实现运维的自动化。尽管我们现在已经有了功能彪悍的脚本程序来执行一些批处理工作，但是，如果仍然需要在每天凌晨两点敲击键盘回车键来执行这个脚本程序，这简直太痛苦了（当然，也可以训练您的小猫在半夜按下回车键）。接下来，刘遄老师将向大家讲解如何设置服务器的计划任务服务，把周期性、规律性的工作交给系统自动完成</p><p>计划任务分为一次性计划任务与长期性计划任务，大家可以按照如下方式理解</p><ul><li><strong>一次性计划任务</strong>：今晚11点30分开启网站服务。</li><li><strong>长期性计划任务</strong>：每周一的凌晨3点25分把/home/wwwroot目录打包备份为backup.tar.gz。</li></ul><h4 id="一次性计划任务"><a class="markdownIt-Anchor" href="#一次性计划任务"></a> 一次性计划任务</h4><p>一次性计划任务只执行一次，一般用于满足临时的工作需求。我们可以用at命令实现这种功能，只需要写成“<strong>at 时间</strong>”的形式就可以。</p><p>如果想要<strong>查看</strong>已设置好但还未执行的一次性计划任务，可以使用“<strong>at -l</strong>”命令；要想将其<strong>删除</strong>，可以用“<strong>atrm</strong> 任务序号”</p><p>在使用at命令来设置一次性计划任务时，默认采用的是交互式方法。例如，使用下述命令将系统设置为在今晚23:30分自动重启网站服务。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# at 23:30at &gt; systemctl restart httpdat &gt; 此处请同时按下Ctrl+d来结束编写计划任务job 3 at Mon Apr 27 23:30:00 2015[root@linuxprobe ~]# at -l3 Mon Apr 27 23:30:00 2016 a root</code></pre><p>想挑战一下难度更大但简捷性更高的方式，可以把前面学习的管道符（任意门）放到两条命令之间，让at命令接收前面echo命令的输出信息，以达到通过非交互式的方式创建计划一次性任务的目的。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# echo &quot;systemctl restart httpd&quot; | at 23:30job 4 at Mon Apr 27 23:30:00 2015[root@linuxprobe ~]# at -l3 Mon Apr 27 23:30:00 2016 a root4 Mon Apr 27 23:30:00 2016 a root</code></pre><p>如果我们不小心设置了两个一次性计划任务，可以使用下面的命令轻松<strong>删除其中一个</strong>：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# atrm 3[root@linuxprobe ~]# at -l4 Mon Apr 27 23:30:00 2016 a root</code></pre><h4 id="长期性计划任务"><a class="markdownIt-Anchor" href="#长期性计划任务"></a> 长期性计划任务</h4><p>如果我们希望Linux系统能够周期性地、有规律地执行某些具体的任务，那么Linux系统中默认启用的crond服务简直再适合不过了。</p><ul><li>创建、编辑计划任务的命令为“<strong>crontab -e</strong>”</li><li>查看当前计划任务的命令为“<strong>crontab -l</strong>”</li><li>删除某条计划任务的命令为“<strong>crontab -r</strong>”</li></ul><p>另外，如果您是以管理员的身份登录的系统，还可以在crontab命令中加上-u参数来编辑他人的计划任务</p><p>在正式部署计划任务前，请先跟刘遄老师念一下口诀“分、时、日、月、星期 命令”。这是使用crond服务设置任务的参数格式（其格式见表4-6）。<strong>需要注意的是，如果有些字段没有设置，则需要使用星号<code>（*）</code>占位</strong>，如图所示。</p><p><img src="image/-13.png" alt="-13.png" /></p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>分钟</td><td>取值为0～59的整数</td></tr><tr><td>小时</td><td>取值为0～23的任意整数</td></tr><tr><td>日期</td><td>取值为1～31的任意整数</td></tr><tr><td>月份</td><td>取值为1～12的任意整数</td></tr><tr><td>星期</td><td>取值为0～7的任意整数，其中0与7均为星期日</td></tr><tr><td>命令</td><td>要执行的命令或程序脚本</td></tr></tbody></table><p>假设在每周一、三、五的凌晨3点25分，都需要使用tar命令把某个网站的数据目录进行打包处理，使其作为一个备份文件。我们可以使用crontab -e命令来创建计划任务。为自己创建计划任务无需使用-u参数，具体的实现效果的参数如crontab -l命令结果所示：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# crontab -eno crontab for root - using an empty onecrontab: installing new crontab</code></pre><blockquote><p>输入上述命令进入编辑器，键入下列语句即可</p></blockquote><pre><code class="highlight plaintext">[root@linuxprobe ~]# crontab -l25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar.gz /home/wwwroot</code></pre><p>需要说明的是，<strong>除了用逗号（,）来分别表示多个时间段</strong>，例如“8,9,12”表示8月、9月和12月。</p><p><strong>还可以用减号（-）来表示一段连续的时间周期</strong>（例如字段“日”的取值为“12-15”，则表示每月的12～15日）。</p><p><strong>以及用除号（/）表示执行任务的间隔时间</strong>（例如“*/2”表示每隔2分钟执行一次任务）。</p><p>如果在crond服务中需要同时包含多条计划任务的命令语句，应每行仅写一条。例如我们再添加一条计划任务，它的功能是每周一至周五的凌晨1点钟自动清空/tmp目录内的所有文件。尤其需要注意的是，在crond服务的计划任务参数中，所有命令一定要用绝对路径的方式来写，如果不知道绝对路径，请用whereis命令进行查询，rm命令路径为下面输出信息中加粗部分。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# whereis rmrm: /usr/bin/rm /usr/share/man/man1/rm.1.gz /usr/share/man/man1p/rm.1p.gz[root@linuxprobe ~]# crontab -ecrontab: installing new crontab[root@linuxprobe ~]# crontab -l25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar.gz /home/wwwroot0 1 * * 1-5 /usr/bin/rm -rf /tmp/*</code></pre><blockquote><p>在crond服务的配置参数中，可以像Shell脚本那样以#号开头写上注释信息，这样在日后回顾这段命令代码时可以快速了解其功能、需求以及编写人员等重要信息。</p></blockquote><blockquote><p><strong>计划任务中的“分”字段必须有数值</strong>，绝对不能为空或是<code>*</code>号，<strong>而“日”和“星期”字段不能同时使用</strong>，否则就会发生冲突</p></blockquote><h2 id="文件权限"><a class="markdownIt-Anchor" href="#文件权限"></a> 文件权限</h2><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><p>在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如：</p><pre><code class="highlight plaintext">[root@www /]# ls -ltotal 64dr-xr-xr-x   2 root root 4096 Dec 14  2012 bindr-xr-xr-x   4 root root 4096 Apr 19  2012 boot……</code></pre><p>实例中，bin文件的第一个属性用&quot;d&quot;表示。&quot;d&quot;在Linux中代表该文件是一个目录文件。</p><p>在Linux中<strong>第一个字符</strong>代表：</p><ul><li>当为[ d ]则是目录</li><li>当为[ - ]则是文件；</li><li>若是[ l ]则表示为链接文档(link file)；</li><li>若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li><li>若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li></ul><p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表<strong>可读</strong>(read)、[ w ]代表<strong>可写</strong>(write)、[ x ]代表<strong>可执行</strong>(execute)。</p><p>要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。每个文件的属性由左边第一部分的10个字符来确定（如下图）</p><p><img src="image/-14.png" alt="-14.png" /></p><p>从左至右用0-9这些数字来表示。</p><ul><li>第0位确定文件类型</li><li>第1-3位确定属主（该文件的所有者）拥有该文件的权限。</li><li>第4-6位确定属组（所有者的同组用户）拥有该文件的权限</li><li>第7-9位确定其他用户拥有该文件的权限。</li></ul><hr /><ul><li>第1、4、7位表示读权限，如果用&quot;r&quot;字符表示，则有读权限，如果用&quot;-&quot;字符表示，则没有读权限；</li><li>第2、5、8位表示写权限，如果用&quot;w&quot;字符表示，则有写权限，如果用&quot;-&quot;字符表示没有写权限；</li><li>第3、6、9位表示可执行权限，如果用&quot;x&quot;字符表示，则有执行权限，如果用&quot;-&quot;字符表示，则没有执行权限。</li></ul><h3 id="文件属主和属组"><a class="markdownIt-Anchor" href="#文件属主和属组"></a> 文件属主和属组</h3><pre><code class="highlight plaintext">[root@www /]# ls -ltotal 64drwxr-xr-x 2 root  root  4096 Feb 15 14:46 crondrwxr-xr-x 3 mysql mysql 4096 Apr 21  2014 mysql……</code></pre><p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p><p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p><p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p><p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p><p>在以上实例中，mysql 文件是一个目录文件，属主和属组都为 mysql，属主有可读、可写、可执行的权限；与属主同组的其他用户有可读和可执行的权限；其他用户也有可读和可执行的权限。</p><blockquote><p>对于 root 用户来说，一般情况下，文件的权限对其不起作用。</p></blockquote><h4 id="更改文件属组-chgrp"><a class="markdownIt-Anchor" href="#更改文件属组-chgrp"></a> 更改文件属组 chgrp</h4><p>语法：</p><pre><code class="highlight plaintext">chgrp [-R] 属组名 文件名</code></pre><p>参数选项</p><ul><li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li></ul><h4 id="更改文件属主-chown"><a class="markdownIt-Anchor" href="#更改文件属主-chown"></a> 更改文件属主 chown</h4><p>语法：</p><pre><code class="highlight plaintext">chown [–R] 属主名 文件名chown [-R] 属主名:属组名 文件名</code></pre><p>案例：</p><ul><li>进入 /root 目录（~）将install.log的拥有者改为bin这个账号：</li></ul><pre><code class="highlight plaintext">[root@www ~] cd ~[root@www ~]# chown bin install.log[root@www ~]# ls -l-rw-r--r--  1 bin  users 68495 Jun 25 08:53 install.log</code></pre><ul><li>将install.log的拥有者与群组改回为root：</li></ul><pre><code class="highlight plaintext">[root@www ~]# chown root:root install.log[root@www ~]# ls -l-rw-r--r--  1 root root 68495 Jun 25 08:53 install.log</code></pre><h3 id="文件权限-chmod"><a class="markdownIt-Anchor" href="#文件权限-chmod"></a> 文件权限 chmod</h3><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p><p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p><hr /><p><strong>数字类型更改文件权限</strong></p><p>语法：</p><pre><code class="highlight plaintext">chmod [-R] xyz 文件名 // -R 代表递归，即目录下所有文件都会更改属性// x 代表属主权限// y 代表属组权限// z 代表其他权限</code></pre><p>文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><ul><li>r ：4</li><li>w：2</li><li>x ：1</li></ul><p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：</p><ul><li>owner = rwx = 4+2+1 = 7</li><li>group = rwx = 4+2+1 = 7</li><li>others= — = 0+0+0 = 0</li></ul><p>所以等一下我们设定权限的变更时，该文件的权限数字就是770啦！变更权限的指令chmod的语法是这样的：</p><pre><code class="highlight plaintext">chmod [-R] xyz 文件或目录</code></pre><p>选项与参数：</p><ul><li>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。</li><li>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</li></ul><p>案例：</p><ul><li>举例来说，如果要将.bashrc这个文件所有的权限都设定启用，那么命令如下：</li></ul><pre><code class="highlight plaintext">[root@www ~]# ls -al .bashrc-rw-r--r--  1 root root 395 Jul  4 11:45 .bashrc[root@www ~]# chmod 777 .bashrc[root@www ~]# ls -al .bashrc-rwxrwxrwx  1 root root 395 Jul  4 11:45 .bashrc</code></pre><blockquote><p>那如果要将权限变成 -rwxr-xr-- 呢？那么权限的分数就成为 <code>[4+2+1][4+0+1][4+0+0]=754</code>。</p></blockquote><hr /><p><strong>符号类型更改文件权限</strong></p><p>语法:</p><pre><code class="highlight plaintext">chmod [-R] u=rwx,g=rwx,o-rwx 文件名// -R 代表递归，即目录下所有文件都会更改属性// u 代表属主// g 代表属组// o 代表其他</code></pre><p>还有一个改变权限的方法，从之前的介绍中我们可以发现，基本上就九个权限分别是：</p><ul><li>(1)user</li><li>(2)group</li><li>(3)others</li></ul><p>那么我们就可以使用 u, g, o 来代表三种身份的权限！</p><p>此外， a 则代表 all，即全部的身份。读写的权限可以写成 r, w, x，也就是可以使用下表的方式来看：</p><p><img src="image/-15.png" alt="-15.png" /></p><p>案例：</p><ul><li>如果我们需要将文件权限设置为 -rwxr-xr-- ，可以使用 <code>chmod u=rwx,g=rx,o=r</code> 文件名 来设定:</li></ul><pre><code class="highlight plaintext">#  touch test1    // 创建 test1 文件# ls -al test1    // 查看 test1 默认权限-rw-r--r-- 1 root root 0 Nov 15 10:32 test1# chmod u=rwx,g=rx,o=r  test1    // 修改 test1 权限# ls -al test1-rwxr-xr-- 1 root root 0 Nov 15 10:32 test1</code></pre><ul><li>而如果是要将权限去掉而不改变其他已存在的权限呢？例如要拿掉全部人的可执行权限，则：</li></ul><pre><code class="highlight plaintext">#  chmod  a-x test1# ls -al test1-rw-r--r-- 1 root root 0 Nov 15 10:32 test1</code></pre><h3 id="文件的特殊权限"><a class="markdownIt-Anchor" href="#文件的特殊权限"></a> 文件的特殊权限</h3><p>在复杂多变的生产环境中，单纯设置文件的rwx权限无法满足我们对安全和灵活性的需求，因此便有了SUID、SGID与SBIT的特殊权限位。这是一种对文件权限进行设置的特殊功能，可以与一般权限同时使用，以弥补一般权限不能实现的功能。下面具体解释这3个特殊权限位的功能以及用法。</p><h4 id="suid"><a class="markdownIt-Anchor" href="#suid"></a> SUID</h4><p>SUID是一种对二进制程序进行设置的特殊权限，可以让二进制程序的执行者临时拥有属主的权限（仅对拥有执行权限的二进制程序有效）。</p><p>例如，所有用户都可以执行passwd命令来修改自己的用户密码，而用户密码保存在/etc/shadow文件中。仔细查看这个文件就会发现它的默认权限是000，也就是说除了root管理员以外，所有用户都没有查看或编辑该文件的权限。但是，在使用passwd命令时如果加上SUID特殊权限位，就可让普通用户临时获得程序所有者的身份，把变更的密码信息写入到shadow文件中。这很像我们在古装剧中见到的手持尚方宝剑的钦差大臣，他手持的尚方宝剑代表的是皇上的权威，因此可以惩戒贪官，但这并不意味着他永久成为了皇上。因此这只是一种有条件的、临时的特殊权限授权方法。</p><p>查看passwd命令属性时发现所有者的权限由rwx变成了rws，其中x改变成s就意味着该文件被赋予了SUID权限。另外有读者会好奇，那么如果原本的权限是rw-呢？如果原先权限位上没有x执行权限，那么被赋予特殊权限后将变成大写的S。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# ls -l /etc/shadow----------. 1 root root 1004 Jan 3 06:23 /etc/shadow[root@linuxprobe ~]# ls -l /bin/passwd-rwsr-xr-x. 1 root root 27832 Jan 29 2017 /bin/passwd</code></pre><h4 id="sgid"><a class="markdownIt-Anchor" href="#sgid"></a> SGID</h4><p>SGID的第一种功能是参考SUID而设计的，不同点在于执行程序的用户获取的不再是文件所有者的临时权限，而是获取到文件所属组的权限。举例来说，在早期的Linux系统中，/dev/kmem是一个字符设备文件，用于存储内核程序要访问的数据，权限为：</p><ul><li>cr—r——- 1 root system 2, 1 Feb 11 2017 kmem</li></ul><p>大家看出问题了吗？除了root管理员或属于system组成员外，所有用户都没有读取该文件的权限。由于在平时我们需要查看系统的进程状态，为了能够获取到进程的状态信息，可在用于查看系统进程状态的ps命令文件上增加SGID特殊权限位。查看ps命令文件的属性信息：</p><pre><code class="highlight plaintext">-r-xr-sr-x 1 bin system 59346 Feb 11 2017 ps</code></pre><p>这样一来，由于ps命令被增加了SGID特殊权限位，所以当用户执行该命令时，也就临时获取到了system用户组的权限，从而可以顺利地读取设备文件了</p><p>前文提到，每个文件都有其归属的所有者和所属组，当创建或传送一个文件后，这个文件就会自动归属于执行这个操作的用户（即该用户是文件的所有者）。如果现在需要在一个部门内设置共享目录，让部门内的所有人员都能够读取目录中的内容，那么就可以创建部门共享目录后，在该目录上设置SGID特殊权限位。这样，部门内的任何人员在里面创建的任何文件都会归属于该目录的所属组，而不再是自己的基本用户组。此时，我们用到的就是SGID的第二个功能，即在某个目录中创建的文件自动继承该目录的用户组（只可以对目录进行设置）。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# cd /tmp[root@linuxprobe tmp]# mkdir testdir[root@linuxprobe tmp]# ls -ald testdir/drwxr-xr-x. 2 root root 6 Feb 11 11:50 testdir/[root@linuxprobe tmp]# chmod -Rf 777 testdir/[root@linuxprobe tmp]# chmod -Rf g+s testdir/[root@linuxprobe tmp]# ls -ald testdir/drwxrwsrwx. 2 root root 6 Feb 11 11:50 testdir/</code></pre><p>在使用上述命令设置好目录的777权限（确保普通用户可以向其中写入文件），并为该目录设置了SGID特殊权限位后，就可以切换至一个普通用户，然后尝试在该目录中创建文件，并查看新创建的文件是否会继承新创建的文件所在的目录的所属组名称：</p><pre><code class="highlight plaintext">[root@linuxprobe tmp]# su - linuxprobeLast login: Wed Feb 11 11:49:16 CST 2017 on pts/0[linuxprobe@linuxprobe ~]$ cd /tmp/testdir/[linuxprobe@linuxprobe testdir]$ echo &quot;linuxprobe.com&quot; &gt; test[linuxprobe@linuxprobe testdir]$ ls -al test-rw-rw-r--. 1 linuxprobe root 15 Feb 11 11:50 test</code></pre><h4 id="sbit"><a class="markdownIt-Anchor" href="#sbit"></a> SBIT</h4><p>现在，大学里的很多老师都要求学生将作业上传到服务器的特定共享目录中，但总是有几个“破坏分子”喜欢删除其他同学的作业，这时就要设置SBIT（Sticky Bit）特殊权限位了（也可以称之为特殊权限位之粘滞位）。SBIT特殊权限位可确保用户只能删除自己的文件，而不能删除其他用户的文件。换句话说，当对某个目录设置了SBIT粘滞位权限后，那么该目录中的文件就只能被其所有者执行删除操作了。</p><p>最初不知道是哪位非资深技术人员将Sticky Bit直译成了“粘滞位”，刘遄老师建议将其称为“保护位”，这既好记，又能立刻让人了解它的作用。RHEL 7系统中的/tmp作为一个共享文件的目录，默认已经设置了SBIT特殊权限位，因此除非是该目录的所有者，否则无法删除这里面的文件。</p><p>与前面所讲的SUID和SGID权限显示方法不同，当目录被设置SBIT特殊权限位后，文件的其他人权限部分的x执行权限就会被替换成t或者T，原本有x执行权限则会写成t，原本没有x执行权限则会被写成T。</p><pre><code class="highlight plaintext">[root@linuxprobe tmp]# su - linuxprobeLast login: Wed Feb 11 12:41:20 CST 2017 on pts/0[linuxprobe@linuxprobe tmp]$ ls -ald /tmpdrwxrwxrwt. 17 root root 4096 Feb 11 13:03 /tmp[linuxprobe@linuxprobe ~]$ cd /tmp[linuxprobe@linuxprobe tmp]$ ls -alddrwxrwxrwt. 17 root root 4096 Feb 11 13:03 .[linuxprobe@linuxprobe tmp]$ echo &quot;Welcome to linuxprobe.com&quot; &gt; test[linuxprobe@linuxprobe tmp]$ chmod 777 test[linuxprobe@linuxprobe tmp]$ ls -al test -rwxrwxrwx. 1 linuxprobe linuxprobe 10 Feb 11 12:59 test</code></pre><p>其实，文件能否被删除并不取决于自身的权限，而是看其所在目录是否有写入权限（其原理会在下个章节讲到）。为了避免现在很多读者不放心，所以上面的命令还是赋予了这个test文件最大的777权限（rwxrwxrwx）。我们切换到另外一个普通用户，然后尝试删除这个其他人创建的文件就会发现，即便读、写、执行权限全开，但是由于SBIT特殊权限位的缘故，依然无法删除该文件：</p><pre><code class="highlight plaintext">[root@linuxprobe tmp]# su - blackshieldLast login: Wed Feb 11 12:41:29 CST 2017 on pts/1[blackshield@linuxprobe ~]$ cd /tmp[blackshield@linuxprobe tmp]$ rm -f testrm: cannot remove ‘test’: Operation not permitted</code></pre><p>当然，要是也想对其他目录来设置SBIT特殊权限位，用chmod命令就可以了。对应的参数o+t代表设置SBIT粘滞位权限：</p><pre><code class="highlight plaintext">[blackshield@linuxprobe tmp]$ exitLogout[root@linuxprobe tmp]# cd ~[root@linuxprobe ~]# mkdir linux[root@linuxprobe ~]# chmod -R o+t linux/[root@linuxprobe ~]# ls -ld linux/drwxr-xr-t. 2 root root 6 Feb 11 19:34 linux/</code></pre><h3 id="文件的隐藏属性"><a class="markdownIt-Anchor" href="#文件的隐藏属性"></a> 文件的隐藏属性</h3><p>Linux系统中的文件除了具备一般权限和特殊权限之外，还有一种隐藏权限，即被隐藏起来的权限，默认情况下不能直接被用户发觉。有用户曾经在生产环境和RHCE考试题目中碰到过明明权限充足但却无法删除某个文件的情况，或者仅能在日志文件中追加内容而不能修改或删除内容，这在一定程度上阻止了黑客篡改系统日志的图谋，因此这种“奇怪”的文件也保障了Linux系统的安全性。</p><h4 id="chattr"><a class="markdownIt-Anchor" href="#chattr"></a> chattr</h4><p>chattr命令用于设置文件的隐藏权限，格式为</p><pre><code class="highlight plaintext">chattr [参数] 文件</code></pre><p>如果想要把某个隐藏功能添加到文件上，则需要在命令后面追加“+参数”，如果想要把某个隐藏功能移出文件，则需要追加“-参数”</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>i</td><td>无法对文件进行修改；若对目录设置了该参数，则仅能修改其中的子文件内容而不能新建或删除文件</td></tr><tr><td>a</td><td>仅允许补充（追加）内容，无法覆盖/删除内容（Append Only）</td></tr><tr><td>S</td><td>文件内容在变更后立即同步到硬盘（sync）</td></tr><tr><td>s</td><td>彻底从硬盘中删除，不可恢复（用0填充原文件所在硬盘区域）</td></tr><tr><td>A</td><td>不再修改这个文件或目录的最后访问时间（atime）</td></tr><tr><td>b</td><td>不再修改文件或目录的存取时间</td></tr><tr><td>D</td><td>检查压缩文件中的错误</td></tr><tr><td>d</td><td>使用dump命令备份时忽略本文件/目录</td></tr><tr><td>c</td><td>默认将文件或目录进行压缩</td></tr><tr><td>u</td><td>当删除该文件后依然保留其在硬盘中的数据，方便日后恢复</td></tr><tr><td>t</td><td>让文件系统支持尾部合并（tail-merging）</td></tr><tr><td>x</td><td>可以直接访问压缩文件中的内容</td></tr></tbody></table><p>实践是检验真理的唯一标准。如果您没有亲眼见证过隐藏权限强大功能的美妙，就一定不会相信原来Linux系统会如此安全。接下来我们再次新建一个普通文件，并为其设置不允许删除与覆盖（+a参数）权限，然后再尝试将这个文件删除：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# echo &quot;for Test&quot; &gt; linuxprobe[root@linuxprobe ~]# chattr +a linuxprobe[root@linuxprobe ~]# rm linuxproberm: remove regular file ‘linuxprobe’? yrm: cannot remove ‘linuxprobe’: Operation not permitted</code></pre><h4 id="lsattr"><a class="markdownIt-Anchor" href="#lsattr"></a> lsattr</h4><p>lsattr命令用于显示文件的隐藏权限，格式为</p><pre><code class="highlight plaintext">lsattr [参数] 文件</code></pre><p>在Linux系统中，文件的隐藏权限必须使用lsattr命令来查看，平时使用的ls之类的命令则看不出端倪：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# ls -al linuxprobe-rw-r--r--. 1 root root 9 Feb 12 11:42 linuxprobe</code></pre><p>一旦使用lsattr命令后，文件上被赋予的隐藏权限马上就会原形毕露。此时可以按照显示的隐藏权限的类型（字母），使用chattr命令将其去掉：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# lsattr linuxprobe-----a---------- linuxprobe[root@linuxprobe ~]# chattr -a linuxprobe[root@linuxprobe ~]# lsattr linuxprobe ---------------- linuxprobe[root@linuxprobe ~]# rm linuxprobe rm: remove regular file ‘linuxprobe’? y</code></pre><h2 id="文件目录"><a class="markdownIt-Anchor" href="#文件目录"></a> 文件/目录</h2><p>我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。</p><p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。在开始本教程前我们需要先知道什么是绝对路径与相对路径。</p><p><strong>绝对路径</strong>：</p><ul><li>路径的写法，由根目录 / 写起，例如： /usr/share/doc 这个目录。</li></ul><p><strong>相对路径</strong>：</p><ul><li>路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： cd …/man 这就是相对路径的写法啦！</li></ul><h3 id="处理目录常用命令"><a class="markdownIt-Anchor" href="#处理目录常用命令"></a> 处理目录常用命令</h3><ul><li>ls: 列出目录及文件名</li><li>cd：切换目录pwd：显示目前的目录</li><li>mkdir：创建一个新的目录</li><li>rmdir：删除一个空的目录</li><li>cp: 复制文件或目录</li><li>rm: 移除文件或目录</li><li>mv: 移动文件与目录，或修改文件与目录的名称</li></ul><h4 id="ls列出目录"><a class="markdownIt-Anchor" href="#ls列出目录"></a> ls(列出目录)</h4><p>在Linux系统当中， ls 命令可能是最常被运行的。</p><p>语法：</p><pre><code class="highlight plaintext">[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称[root@www ~]# ls [--color=&#123;never,auto,always&#125;] 目录名称[root@www ~]# ls [--full-time] 目录名称</code></pre><p>选项与参数：</p><ul><li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li><li>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</li><li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li></ul><p>案例：</p><ul><li>将家目录下的所有文件列出来(含属性与隐藏档)</li></ul><pre><code class="highlight plaintext">[root@www ~]# ls -al ~</code></pre><h4 id="cd切换目录"><a class="markdownIt-Anchor" href="#cd切换目录"></a> cd(切换目录)</h4><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p><p>语法：</p><pre><code class="highlight plaintext">cd [相对路径或绝对路径]</code></pre><blockquote><p>符号 “.” 指的是工作目录，”…” 指的是工作目录的父目录</p></blockquote><table><thead><tr><th>快捷键</th><th>运行结果</th></tr></thead><tbody><tr><td>cd</td><td>更改工作目录到你的家目录</td></tr><tr><td>cd -</td><td>更改工作目录到先前的工作目录</td></tr><tr><td>cd ~user_name</td><td>更改工作目录到用户家目录。例如, cd ~bob 会更改工作目录到用户“bob”的家目录。</td></tr></tbody></table><p>案例：</p><pre><code class="highlight plaintext">#使用 mkdir 命令创建 runoob 目录[root@www ~]# mkdir runoob#使用绝对路径切换到 runoob 目录[root@www ~]# cd /root/runoob/#使用相对路径切换到 runoob 目录[root@www ~]# cd ./runoob/# 表示回到自己的家目录，亦即是 /root 这个目录[root@www runoob]# cd ~# 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；[root@www ~]# cd ..</code></pre><h4 id="pwd显示目前所在的目录"><a class="markdownIt-Anchor" href="#pwd显示目前所在的目录"></a> pwd(显示目前所在的目录)</h4><p>pwd 是 Print Working Directory 的缩写，也就是显示目前所在目录的命令。</p><p>语法：</p><pre><code class="highlight plaintext">[root@www ~]# pwd [-P]</code></pre><p>选项与参数：</p><ul><li>-P ：显示出确实的路径，而非使用连结 (link) 路径。</li></ul><blockquote><p>当我们首次登录系统（或者启动终端仿真器会话）后，当前工作目录是我们的家目录。 每个用户都有他自己的家目录，当用户以普通用户的身份操控系统时，家目录是唯一 允许用户对文件进行写入的地方</p></blockquote><p>实例：</p><ul><li>单纯显示出目前的工作目录：</li></ul><pre><code class="highlight plaintext">[root@www ~]# pwd/root   &lt;== 显示出目录啦～</code></pre><ul><li>实例显示出实际的工作目录，而非连结档本身的目录名而已。</li></ul><pre><code class="highlight plaintext">[root@www ~]# cd /var/mail   &lt;==注意，/var/mail是一个连结档[root@www mail]# pwd/var/mail         &lt;==列出目前的工作目录[root@www mail]# pwd -P/var/spool/mail   &lt;==怎么回事？有没有加 -P 差很多～[root@www mail]# ls -ld /var/maillrwxrwxrwx 1 root root 10 Sep  4 17:54 /var/mail -&gt; spool/mail# 看到这里应该知道为啥了吧？因为 /var/mail 是连结档，连结到 /var/spool/mail # 所以，加上 pwd -P 的选项后，会不以连结档的数据显示，而是显示正确的完整路径啊！</code></pre><h4 id="mkdir创建新目录"><a class="markdownIt-Anchor" href="#mkdir创建新目录"></a> mkdir(创建新目录)</h4><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p><p>语法：</p><pre><code class="highlight plaintext">mkdir [-mp] 目录名称 . . .</code></pre><p>选项与参数：</p><ul><li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li><li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li></ul><p>实例：</p><ul><li>请到/tmp底下尝试创建数个新目录看看：</li></ul><pre><code class="highlight plaintext">[root@www ~]# cd /tmp[root@www tmp]# mkdir test    &lt;==创建一名为 test 的新目录[root@www tmp]# mkdir test1/test2/test3/test4mkdir: cannot create directory `test1/test2/test3/test4&#x27;: No such file or directory       &lt;== 没办法直接创建此目录啊！[root@www tmp]# mkdir -p test1/test2/test3/test4</code></pre><blockquote><p>加了这个 -p 的选项，可以自行帮你创建多层目录！</p></blockquote><ul><li>创建权限为 rwx–x–x 的目录。</li></ul><pre><code class="highlight plaintext">[root@www tmp]# mkdir -m 711 test2[root@www tmp]# ls -ldrwxr-xr-x  3 root  root 4096 Jul 18 12:50 testdrwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1drwx--x--x  2 root  root 4096 Jul 18 12:54 test2</code></pre><blockquote><p>上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx–x–x 的权限。</p></blockquote><blockquote><p><strong>注意表示法</strong>: 在描述一个命令时（如上所示），当有三个圆点跟在一个命令的参数后面， 这意味着那个参数可以重复</p></blockquote><pre><code class="highlight plaintext">mkdir dir1mkdir dir1 dir2 dir3</code></pre><h4 id="rmdir删除空目录"><a class="markdownIt-Anchor" href="#rmdir删除空目录"></a> rmdir(删除空目录)</h4><p>语法：</p><pre><code class="highlight plaintext">rmdir [-p] 目录名称</code></pre><p>选项与参数：</p><ul><li>-p ：连同上一级『空的』目录也一起删除</li></ul><p>案例：</p><ul><li>删除 runoob 目录</li></ul><pre><code class="highlight plaintext">[root@www tmp]# rmdir runoob/</code></pre><h4 id="rm移除文件或目录"><a class="markdownIt-Anchor" href="#rm移除文件或目录"></a> rm(移除文件或目录)</h4><p>语法：</p><pre><code class="highlight plaintext">rm [-fir] 文件或目录 . . .</code></pre><p>选项与参数：</p><table><thead><tr><th>选项</th><th>意义</th></tr></thead><tbody><tr><td>-i, --interactive</td><td>在删除已存在的文件前，提示用户确认信息。 如果不指定这个选项，rm 会默默地删除文件</td></tr><tr><td>-r, --recursive</td><td>递归地删除文件，这意味着，如果要删除一个目录，而此目录 又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。</td></tr><tr><td>-f, --force</td><td>忽视不存在的文件，不显示提示信息。这选项颠覆了“–interactive”选项。</td></tr><tr><td>-v, --verbose</td><td>在执行 rm 命令时，显示翔实的操作信息。</td></tr></tbody></table><p>案例：</p><p>将刚刚在 cp 的实例中创建的 bashrc 删除掉！</p><pre><code class="highlight plaintext">[root@www tmp]# rm -i bashrcrm: remove regular file `bashrc&#x27;? y</code></pre><blockquote><p>如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</p></blockquote><table><thead><tr><th>命令</th><th>运行结果</th></tr></thead><tbody><tr><td>rm file1</td><td>默默地删除文件</td></tr><tr><td>rm -i file1</td><td>除了在删除文件之前，提示用户确认信息之外，和上面的命令作用一样。</td></tr><tr><td>rm -r file1 dir1</td><td>删除文件 file1, 目录 dir1，及 dir1 中的内容。</td></tr><tr><td>rm -rf file1 dir1</td><td>同上，除了如果文件 file1，或目录 dir1 不存在的话，rm 仍会继续执行。</td></tr></tbody></table><blockquote><p>一定要小心rm命令，类 Unix 的操作系统，比如说 Linux，没有复原命令。一旦你用 rm 删除了一些东西， 它就消失了，<strong>尤其要小心通配符</strong></p></blockquote><blockquote><p>小贴士。 无论什么时候，rm 命令用到通配符（除了仔细检查输入的内容外！）， 用 ls 命令来测试通配符。这会让你看到要删除的文件列表。然后按下上箭头按键，重新调用 刚刚执行的命令，用 rm 替换 ls</p></blockquote><h4 id="cp复制文件或目录"><a class="markdownIt-Anchor" href="#cp复制文件或目录"></a> cp(复制文件或目录)</h4><p>cp即拷贝文件和目录</p><p>语法：</p><pre><code class="highlight plaintext">cp [-adfilprsu] 来源(source) 目标(destination)cp [options] source1 source2 source3 . . .  directory</code></pre><blockquote><p>如果目标文件是目录，则会把源文件复制到该目录中；</p></blockquote><blockquote><p>如果目标文件也是普通文件，则会询问是否要覆盖它；</p></blockquote><blockquote><p>如果目标文件不存在，则执行正常的复制操作。</p></blockquote><p>选项与参数：</p><table><thead><tr><th>选 项</th><th>意义</th></tr></thead><tbody><tr><td>-a, --archive</td><td>复制文件和目录，以及它们的属性，包括所有权和权限。 通常，复本具有用户所操作文件的默认属性。相当于-pdr</td></tr><tr><td>-i, --interactive</td><td>在重写已存在文件之前，提示用户确认。如果这个选项不指定， cp 命令会默认重写文件。</td></tr><tr><td>-r, --recursive</td><td>递归地复制目录及目录中的内容。当复制目录时， 需要这个选项（或者-a 选项）。</td></tr><tr><td>-u, --update</td><td>当把文件从一个目录复制到另一个目录时，仅复制 目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。</td></tr><tr><td>-v, --verbose</td><td>显示翔实的命令操作信息</td></tr><tr><td>-d</td><td>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身</td></tr><tr><td>-f</td><td>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</td></tr><tr><td>-l</td><td>进行硬式连结(hard link)的连结档创建，而非复制文件本身；</td></tr><tr><td>-p</td><td>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</td></tr><tr><td>-s</td><td>复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</td></tr></tbody></table><p>案例：</p><p>用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc</p><pre><code class="highlight plaintext">[root@www ~]# cp ~/.bashrc /tmp/bashrc[root@www ~]# cp -i ~/.bashrc /tmp/bashrccp: overwrite `/tmp/bashrc&#x27;? n  &lt;==n不覆盖，y为覆盖</code></pre><table><thead><tr><th>命令</th><th>运行结果</th></tr></thead><tbody><tr><td>cp file1 file2</td><td>复制文件 file1 内容到文件 file2。如果 file2 已经存在， file2 的内容会被 file1 的内容重写。如果 file2 不存在，则会创建 file2。</td></tr><tr><td>cp -i file1 file2</td><td>这条命令和上面的命令一样，除了如果文件 file2 存在的话，在文件 file2 被重写之前， 会提示用户确认信息。</td></tr><tr><td>cp file1 file2 dir1</td><td>复制文件 file1 和文件 file2 到目录 dir1。目录 dir1 必须存在。</td></tr><tr><td>cp dir1/* dir2</td><td>使用一个通配符，在目录 dir1 中的所有文件都被复制到目录 dir2 中。 dir2 必须已经存在。</td></tr><tr><td>cp -r dir1 dir2</td><td>复制目录 dir1 中的内容到目录 dir2。如果目录 dir2 不存在， 创建目录 dir2，操作完成后，目录 dir2 中的内容和 dir1 中的一样。 如果目录 dir2 存在，则目录 dir1 (和目录中的内容)将会被复制到 dir2 中。</td></tr></tbody></table><h4 id="mv移动文件与目录或修改名称"><a class="markdownIt-Anchor" href="#mv移动文件与目录或修改名称"></a> mv(移动文件与目录，或修改名称)</h4><p>语法：</p><pre><code class="highlight plaintext">mv [-fiu] source destinationmv [options] source1 source2 source3 .... directory</code></pre><p>选项与参数：</p><table><thead><tr><th>选项</th><th>意义</th></tr></thead><tbody><tr><td>-i --interactive</td><td>在重写一个已经存在的文件之前，提示用户确认信息。 <strong>如果不指定这个选项，mv 命令会默认重写文件内容</strong>。</td></tr><tr><td>-u --update</td><td>当把文件从一个目录移动另一个目录时，只是移动不存在的文件， 或者文件内容新于目标目录相对应文件的内容。</td></tr><tr><td>-f</td><td>force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</td></tr><tr><td>-v</td><td>显示详细的操作信息；</td></tr></tbody></table><p>案例：</p><p>复制一文件，创建一目录，将文件移动到目录中</p><pre><code class="highlight plaintext">[root@www ~]# cd /tmp[root@www tmp]# cp ~/.bashrc bashrc[root@www tmp]# mkdir mvtest[root@www tmp]# mv bashrc mvtest</code></pre><p>将某个文件移动到某个目录去，就是这样做！</p><p>将刚刚的目录名称更名为 mvtest2</p><pre><code class="highlight plaintext">[root@www tmp]# mv mvtest mvtest2</code></pre><table><thead><tr><th>命令</th><th>意义</th></tr></thead><tbody><tr><td>mv file1 file2</td><td>移动 file1 到 file2。如果 file2 存在，它的内容会被 file1 的内容重写。 如果 file2 不存在，则创建 file2。 每种情况下，file1 不再存在。</td></tr><tr><td>mv -i file1 file2</td><td>除了如果 file2 存在的话，在 file2 被重写之前，用户会得到 提示信息外，这个和上面的选项一样。</td></tr><tr><td>mv file1 file2 dir1</td><td>移动 file1 和 file2 到目录 dir1 中。dir1 必须已经存在。</td></tr><tr><td>mv dir1 dir2</td><td>如果目录 dir2 不存在，创建目录 dir2，并且移动目录 dir1 的内容到 目录 dir2 中，同时删除目录 dir1。如果目录 dir2 存在，移动目录 dir1（及它的内容）到目录 dir2。</td></tr></tbody></table><h4 id="touch"><a class="markdownIt-Anchor" href="#touch"></a> touch</h4><p>touch命令用于<strong>创建空白文件或设置文件的时间</strong>，格式为</p><pre><code class="highlight plaintext">touch [选项] [文件]</code></pre><p>在创建空白的文本文件方面，这个touch命令相当简捷，简捷到没有必要铺开去讲。比如，touch linuxprobe命令可以创建出一个名为linuxprobe的空白文本文件。对touch命令来讲，有难度的操作主要是体现在设置文件内容的修改时间（mtime）、文件权限或属性的更改时间（ctime）与文件的读取时间（atime）上面。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>仅修改“读取时间”（atime）</td></tr><tr><td>-m</td><td>仅修改“修改时间”（mtime）</td></tr><tr><td>-d</td><td>同时修改atime与mtime</td></tr></tbody></table><p>接下来，我们先使用ls命令查看一个文件的修改时间，然后修改这个文件，最后再通过touch命令把修改后的文件时间设置成修改之前的时间（很多黑客就是这样做的呢）：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# ls -l anaconda-ks.cfg -rw-------. 1 root root 1213 May  4 15:44 anaconda-ks.cfg[root@linuxprobe ~]# echo &quot;Visit the LinuxProbe.com to learn linux skills&quot; &gt;&gt; anaconda-ks.cfg[root@linuxprobe ~]# ls -l anaconda-ks.cfg-rw-------. 1 root root 1260 Aug  2 01:26 anaconda-ks.cfg[root@linuxprobe ~]# touch -d &quot;2017-05-04 15:44&quot; anaconda-ks.cfg [root@linuxprobe ~]# ls -l anaconda-ks.cfg -rw-------. 1 root root 1260 May  4 15:44 anaconda-ks.cfg</code></pre><h4 id="dd"><a class="markdownIt-Anchor" href="#dd"></a> dd</h4><p>dd命令用于<strong>按照指定大小和个数的数据块来复制文件或转换文件</strong>，格式为</p><pre><code class="highlight plaintext">dd [参数]</code></pre><p>dd命令是一个比较重要而且比较有特色的一个命令，它能够让用户按照指定大小和个数的数据块来复制文件的内容。当然如果愿意的话，还可以在复制过程中转换其中的数据。</p><p>Linux系统中有一个名为/dev/zero的设备文件，每次在课堂上解释它时都充满哲学理论的色彩。因为这个文件不会占用系统存储空间，但却可以提供无穷无尽的数据，因此可以使用它作为dd命令的输入文件，来生成一个指定大小的文件。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>if</td><td>输入的文件名称</td></tr><tr><td>of</td><td>输出的文件名称</td></tr><tr><td>bs</td><td>设置每个“块”的大小</td></tr><tr><td>count</td><td>设置要复制“块”的个数</td></tr></tbody></table><p>例如我们可以用dd命令从/dev/zero设备文件中取出一个大小为560MB的数据块，然后保存成名为560_file的文件。在理解了这个命令后，以后就能随意创建任意大小的文件了：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# dd if=/dev/zero of=560_file count=1 bs=560M1+0 records in1+0 records out587202560 bytes (587 MB) copied, 27.1755 s, 21.6 MB/s</code></pre><p>dd命令的功能也绝不仅限于复制文件这么简单。如果您想把光驱设备中的光盘制作成iso格式的镜像文件，在Windows系统中需要借助于第三方软件才能做到，但在Linux系统中可以直接使用dd命令来压制出光盘镜像文件，将它变成一个可立即使用的iso镜像：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# dd if=/dev/cdrom of=RHEL-server-7.0-x86_64-LinuxProbe.Com.iso7311360+0 records in7311360+0 records out3743416320 bytes (3.7 GB) copied, 370.758 s, 10.1 MB/s</code></pre><h4 id="file查看文件类型"><a class="markdownIt-Anchor" href="#file查看文件类型"></a> file(查看文件类型)</h4><p>file命令用于查看文件的类型，格式为</p><pre><code class="highlight plaintext">file 文件名</code></pre><p>在Linux系统中，由于文本、目录、设备等所有这些一切都统称为文件，而我们又不能单凭后缀就知道具体的文件类型，这时就需要使用file命令来查看文件类型了</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# file anaconda-ks.cfganaconda-ks.cfg: ASCII text[root@linuxprobe ~]# file /dev/sda/dev/sda: block special</code></pre><h3 id="软硬方式连接"><a class="markdownIt-Anchor" href="#软硬方式连接"></a> 软硬方式连接</h3><p>在Windows系统中，快捷方式就是指向原始文件的一个链接文件，可以让用户从不同的位置来访问原始的文件；原文件一旦被删除或剪切到其他地方后，会导致链接文件失效。但是，这个看似简单的东西在Linux系统中可不太一样。</p><p>在Linux系统中存在硬链接和软连接两种文件。</p><p><strong>硬链接</strong>（hard link）：可以将它理解为一个“指向原始文件inode的指针”，系统不为它分配独立的inode和文件。所以，硬链接文件与原始文件其实是同一个文件，只是名字不同。我们每添加一个硬链接，该文件的inode连接数就会增加1；而且只有当该文件的inode连接数为0时，才算彻底将它删除。换言之，由于硬链接实际上是指向原文件inode的指针，因此即便原始文件被删除，依然可以通过硬链接文件来访问。需要注意的是，由于技术的局限性，我们不能跨分区对目录文件进行链接。</p><p><strong>软链接</strong>（也称为符号链接[symbolic link]）：仅仅包含所链接文件的路径名，因此能链接目录文件，也可以跨越文件系统进行链接。但是，当原始文件被删除后，链接文件也将失效，从这一点上来说与Windows系统中的“快捷方式”具有一样的性质。<strong>如果链接目录，则更改软链接目录内文件和更改原始目录文件是相同的效果</strong></p><h4 id="ln"><a class="markdownIt-Anchor" href="#ln"></a> ln</h4><p>ln命令用于创建链接文件，格式为</p><pre><code class="highlight plaintext">ln [选项] 目标 软链接名</code></pre><p>其可用的参数以及作用如表6-6所示。在使用ln命令时，是否添加-s参数，将创建出性质不同的两种“快捷方式”。因此如果没有扎实的理论知识和实践经验做铺垫，尽管能够成功完成实验，但永远不会明白为什么会成功。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-s</td><td>创建“符号链接”（如果不带-s参数，则默认创建硬链接）</td></tr><tr><td>-f</td><td>强制创建文件或目录的链接</td></tr><tr><td>-i</td><td>覆盖前先询问</td></tr><tr><td>-v</td><td>显示创建链接的过程</td></tr></tbody></table><p>为了更好地理解软链接、硬链接的不同性质，接下来创建一个类似于Windows系统中快捷方式的软链接。这样，当原始文件被删除后，就无法读取新建的链接文件了。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# echo &quot;Welcome to linuxprobe.com&quot; &gt; readme.txt[root@linuxprobe ~]# ln -s readme.txt readit.txt[root@linuxprobe ~]# cat readme.txt Welcome to linuxprobe.com[root@linuxprobe ~]# cat readit.txt Welcome to linuxprobe.com[root@linuxprobe ~]# ls -l readme.txt -rw-r--r-- 1 root root 26 Jan 11 00:08 readme.txt[root@linuxprobe ~]# rm -f readme.txt [root@linuxprobe ~]# cat readit.txt cat: readit.txt: No such file or directory</code></pre><p>接下来针对一个原始文件创建一个硬链接，即相当于针对原始文件的硬盘存储位置创建了一个指针，这样一来，新创建的这个硬链接就不再依赖于原始文件的名称等信息，也不会因为原始文件的删除而导致无法读取。同时可以看到创建硬链接后，原始文件的硬盘链接数量增加到了2。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# echo &quot;Welcome to linuxprobe.com&quot; &gt; readme.txt[root@linuxprobe ~]# ln readme.txt readit.txt[root@linuxprobe ~]# cat readme.txt Welcome to linuxprobe.com[root@linuxprobe ~]# cat readit.txt Welcome to linuxprobe.com[root@linuxprobe ~]# ls -l readme.txt -rw-r--r-- 2 root root 26 Jan 11 00:13 readme.txt[root@linuxprobe ~]# rm -f readme.txt [root@linuxprobe ~]# cat readit.txt Welcome to linuxprobe.com</code></pre><p><strong>总结</strong></p><p>依此您可以做一些相关的测试，可以得到以下全部结论：</p><ul><li>1).删除符号连接f3,对f1,f2无影响；</li><li>2).删除硬连接f2，对f1,f3也无影响；</li><li>3).删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效；</li><li>4).同时删除原文件f1,硬连接f2，整个文件会真正的被删除。</li></ul><h3 id="文件内容查看"><a class="markdownIt-Anchor" href="#文件内容查看"></a> 文件内容查看</h3><p>Linux系统中使用以下命令来查看文件的内容：</p><ul><li>cat  由第一行开始显示文件内容</li><li>tac  从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li><li>nl   显示的时候，顺道输出行号！</li><li>more 一页一页的显示文件内容</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li><li>head 只看头几行</li><li>tail 只看尾巴几行</li></ul><p>你可以使用man [命令]来查看各个命令的使用文档，如 ：man cp。</p><h4 id="cat由第一行开始显示文件内容"><a class="markdownIt-Anchor" href="#cat由第一行开始显示文件内容"></a> cat(由第一行开始显示文件内容)</h4><p>cat命令用于查看纯文本文件（内容较少的）</p><p>语法：</p><pre><code class="highlight plaintext">cat [-AbEnTv]</code></pre><p>选项与参数：</p><ul><li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li><li>-b ：<strong>列出行号，仅针对非空白行做行号显示</strong>，空白行不标行号！</li><li>-E ：将结尾的断行字节 $ 显示出来；</li><li>-n ：<strong>列印出行号</strong>，连同空白行也会有行号，与 -b 的选项不同；</li><li>-T ：将 [tab] 按键以 ^I 显示出来；</li><li>-v ：列出一些看不出来的特殊字符</li></ul><p>案例：</p><ul><li>检看 /etc/issue 这个文件的内容：</li></ul><pre><code class="highlight plaintext">[root@www ~]# cat /etc/issueCentOS release 6.4 (Final)Kernel \r on an \m</code></pre><h4 id="tac由最后一行开始显示文件内容"><a class="markdownIt-Anchor" href="#tac由最后一行开始显示文件内容"></a> tac(由最后一行开始显示文件内容)</h4><p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p><pre><code class="highlight plaintext">[root@www ~]# tac /etc/issueKernel \r on an \mCentOS release 6.4 (Final)</code></pre><h4 id="nl可以显示行号"><a class="markdownIt-Anchor" href="#nl可以显示行号"></a> nl(可以显示行号)</h4><p>显示行号</p><p>语法：</p><pre><code class="highlight plaintext">nl [-bnw] 文件</code></pre><p>选项与参数：</p><ul><li>-b ：指定行号指定的方式，主要有两种：<ul><li>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；</li><li>-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li></ul></li><li>-n ：列出行号表示的方法，主要有三种：<ul><li>-n ln ：行号在荧幕的最左方显示；</li><li>-n rn ：行号在自己栏位的最右方显示，且不加 0 ；</li><li>-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li></ul></li><li>-w ：行号栏位的占用的位数。</li></ul><p>案例：</p><ul><li>用 nl 列出 /etc/issue 的内容</li></ul><pre><code class="highlight plaintext">[root@www ~]# nl /etc/issue     1  CentOS release 6.4 (Final)     2  Kernel \r on an \m</code></pre><h4 id="more一页一页翻动"><a class="markdownIt-Anchor" href="#more一页一页翻动"></a> more(一页一页翻动)</h4><p>more命令用于查看纯文本文件（内容较多的）</p><p>语法：</p><pre><code class="highlight plaintext">more /etc/man_db.config</code></pre><p>案例：</p><pre><code class="highlight plaintext">[root@www ~]# more /etc/man_db.config ## Generated automatically from man.conf.in by the# configure script.## man.conf from man-1.6d....(中间省略)....--More--(28%)  &lt;== 重点在这一行喔！你的光标也会在这里等待你的命令</code></pre><p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p><ul><li>空白键 (space)：代表向下翻一页；</li><li>Enter：代表向下翻『一行』；</li><li>/字串：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li><li>:f：立刻显示出档名以及目前显示的行数；</li><li>q：代表立刻离开 more ，不再显示该文件内容。</li><li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li></ul><h4 id="less一页一页翻动"><a class="markdownIt-Anchor" href="#less一页一页翻动"></a> less(一页一页翻动)</h4><p>语法：</p><pre><code class="highlight plaintext">less /etc/man.config</code></pre><p>案例：</p><ul><li>一页一页翻动，以下实例输出/etc/man.config文件的内容：</li></ul><pre><code class="highlight plaintext">[root@www ~]# less /etc/man.config## Generated automatically from man.conf.in by the# configure script.## man.conf from man-1.6d....(中间省略)....:   &lt;== 这里可以等待你输入命令！</code></pre><p>less运行时可以输入的命令有：</p><ul><li>空白键    ：向下翻动一页；</li><li>[pagedown]：向下翻动一页；</li><li>[pageup]  ：向上翻动一页；</li><li>/字串     ：向下搜寻『字串』的功能；</li><li>?字串     ：向上搜寻『字串』的功能；</li><li>n         ：重复前一个搜寻 (与 / 或 ? 有关！)</li><li>N         ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li><li>q         ：离开 less 这个程序；</li></ul><h4 id="head取出文件前几行"><a class="markdownIt-Anchor" href="#head取出文件前几行"></a> head(取出文件前几行)</h4><p>取出文件前面几行</p><p>语法：</p><pre><code class="highlight plaintext">head [-n number] 文件</code></pre><p>选项与参数：</p><ul><li>-n ：后面接数字，代表显示几行的意思</li></ul><p>案例：</p><pre><code class="highlight plaintext">[root@www ~]# head /etc/man.config</code></pre><p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p><pre><code class="highlight plaintext">[root@www ~]# head -n 20 /etc/man.config</code></pre><h4 id="tail取出文件后几行"><a class="markdownIt-Anchor" href="#tail取出文件后几行"></a> tail(取出文件后几行)</h4><p>取出文件后面几行</p><p>语法：</p><pre><code class="highlight plaintext">tail [-n number] 文件</code></pre><p>选项与参数：</p><ul><li>-n ：后面接数字，代表显示几行的意思</li><li>-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测</li></ul><pre><code class="highlight plaintext">[root@www ~]# tail /etc/man.config# 默认的情况中，显示最后的十行！若要显示最后的 20 行，就得要这样：[root@www ~]# tail -n 20 /etc/man.config</code></pre><h4 id="tr替换文本内容"><a class="markdownIt-Anchor" href="#tr替换文本内容"></a> tr(替换文本内容)</h4><p>tr命令用于替换文本文件中的字符，格式为</p><pre><code class="highlight plaintext">tr [原始字符] [目标字符]</code></pre><p>在很多时候，我们想要快速地替换文本中的一些词汇，又或者把整个文本内容都进行替换，如果进行手工替换，难免工作量太大，尤其是需要处理大批量的内容时，进行手工替换更是不现实。这时，就可以先使用cat命令读取待处理的文本，然后通过管道符（详见第3章）把这些文本内容传递给tr命令进行替换操作即可。例如，把某个文本内容中的英文全部替换为大写：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# cat anaconda-ks.txt | tr [a-z] [A-Z]</code></pre><h4 id="wc统计行数"><a class="markdownIt-Anchor" href="#wc统计行数"></a> wc(统计行数)</h4><p>wc命令用于统计指定文本的行数、字数、字节数，格式为</p><pre><code class="highlight plaintext">wc [参数] 文本</code></pre><p>每次我在课堂上讲到这个命令时，总有同学会联想到一种公共设施，其实这两者毫无关联。Linux系统中的wc命令用于统计文本的行数、字数、字节数等。如果为了方便自己记住这个命令的作用，也可以联想到上厕所时好无聊，无聊到数完了手中的如厕读物上有多少行字</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-l</td><td>只显示行数</td></tr><tr><td>-w</td><td>只显示单词数</td></tr><tr><td>-c</td><td>只显示字节数</td></tr></tbody></table><p>在Linux系统中，passwd是用于保存系统账户信息的文件，要统计当前系统中有多少个用户，可以使用下面的命令来进行查询，是不是很神奇：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# wc -l /etc/passwd38 /etc/passwd</code></pre><h4 id="stat查看文件信息"><a class="markdownIt-Anchor" href="#stat查看文件信息"></a> stat(查看文件信息)</h4><p>stat命令用于查看文件的具体存储信息和时间等信息，格式为</p><pre><code class="highlight plaintext">stat 文件名称</code></pre><p>stat命令可以用于查看文件的存储信息和时间等信息，命令stat anaconda-ks.cfg会显示出文件的三种时间状态（已加粗）：Access、Modify、Change。这三种时间的区别将在下面的touch命令中详细详解：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# stat anaconda-ks.cfgFile: ‘anaconda-ks.cfg’Size: 1213 Blocks: 8 IO Block: 4096 regular fileDevice: fd00h/64768d Inode: 68912908 Links: 1Access: (0600/-rw-------) Uid: ( 0/ root) Gid: ( 0/ root)Context: system_u:object_r:admin_home_t:s0Access: 2017-07-14 01:46:18.721255659 -0400Modify: 2017-05-04 15:44:36.916027026 -0400Change: 2017-05-04 15:44:36.916027026 -0400Birth: -</code></pre><h4 id="cut提取列"><a class="markdownIt-Anchor" href="#cut提取列"></a> cut(提取列)</h4><p>命令<strong>cut命令用于按“列”提取文本字符</strong>，格式为</p><pre><code class="highlight plaintext">cut [参数] 文本</code></pre><p>在Linux系统中，如何准确地提取出最想要的数据，这也是我们应该重点学习的内容。一般而言，按基于“行”的方式来提取数据是比较简单的，只需要设置好要搜索的关键词即可。但是如果按列搜索，不仅要使用-f参数来设置需要看的列数，还需要使用-d参数来设置间隔符号。</p><p>passwd在保存用户数据信息时，用户信息的每一项值之间是采用冒号来间隔的，接下来我们使用下述命令尝试提取出passwd文件中的用户名信息，即提取以冒号（：）为间隔符号的第一列内容：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# head -n 2 /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologin[root@linuxprobe ~]# cut -d: -f1 /etc/passwdrootbindaemonadmlpsyncshutdownhaltmailoperatorgamesftpnobodydbuspolkitdunboundcolordusbmuxdavahiavahi-autoipdlibstoragemgmtsaslauth</code></pre><h4 id="diff比较"><a class="markdownIt-Anchor" href="#diff比较"></a> diff(比较)</h4><p>diff命令用于比较多个文本文件的差异，格式为</p><pre><code class="highlight plaintext">diff [参数] 文件</code></pre><p>在使用diff命令时，不仅可以<strong>使用—brief参数来确认两个文件是否不同</strong>，还可以<strong>使用-c参数来详细比较出多个文件的差异之处</strong>，这绝对是判断文件是否被篡改的有力神器。</p><p>接下来使用diff —brief命令显示比较后的结果，判断文件是否相同：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# diff --brief diff_A.txt diff_B.txtFiles diff_A.txt and diff_B.txt differ</code></pre><p>最后使用带有-c参数的diff命令来描述文件内容具体的不同：</p><pre><code class="highlight plaintext"> [root@linuxprobe ~]# diff -c diff_A.txt diff_B.txt** diff_A.txt 2017-08-30 18:07:45.230864626 +0800--- diff_B.txt 2017-08-30 18:08:52.203860389 +0800********* 1,5 **! Welcome to linuxprobe.comRed Hat certified! Free Linux LessonsProfessional guidanceLinux Course--- 1,7 ----! Welcome tooo linuxprobe.com!Red Hat certified! Free Linux LeSSonS! ////////.....////////Professional guidanceLinux Course</code></pre><h3 id="查找"><a class="markdownIt-Anchor" href="#查找"></a> 查找</h3><ul><li><strong>which</strong>       查看可执行文件的位置</li><li><strong>whereis</strong>    查看文件的位置</li><li><strong>locate</strong>       配 合数据库查看文件位置</li><li><strong>find</strong>          实际搜寻硬盘查询文件名称</li></ul><h4 id="find"><a class="markdownIt-Anchor" href="#find"></a> find</h4><p>find是最常见和最强大的查找命令，你可以用它找到任何你想找的文件</p><p>语法：</p><ul><li>&lt;<strong>指定目录</strong>&gt;： 所要搜索的目录及其所有子目录。默认为当前目录。</li><li>&lt;<strong>指定条件</strong>&gt;： 所要搜索的文件的特征。</li><li>&lt;<strong>指定动作</strong>&gt;： 对搜索结果进行特定的处理。</li></ul><pre><code class="highlight plaintext">$ find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;</code></pre><p>参数：</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-<strong>name</strong></td><td>匹配名称（可以使用通配符）</td></tr><tr><td>-perm</td><td>匹配权限（mode为完全匹配，-mode为包含即可）</td></tr><tr><td>-user</td><td>匹配所有者</td></tr><tr><td>-group</td><td>匹配所有组</td></tr><tr><td>-mtime -n +n</td><td>匹配修改内容的时间（-n指n天以内，+n指n天以前）</td></tr><tr><td>-atime -n +n</td><td>匹配访问文件的时间（-n指n天以内，+n指n天以前）</td></tr><tr><td>-ctime -n +n</td><td>匹配修改文件权限的时间（-n指n天以内，+n指n天以前）</td></tr><tr><td>-nouser</td><td>匹配无所有者的文件</td></tr><tr><td>-nogroup</td><td>匹配无所有组的文件</td></tr><tr><td>-newer f1 !f2</td><td>匹配比文件f1新但比f2旧的文件</td></tr><tr><td>—type b/d/c/p/l/f</td><td>匹配文件类型（后面的字幕字母依次表示块设备、目录、字符设备、管道、链接文件、文本文件）</td></tr><tr><td>-size</td><td>匹配文件的大小（+50KB为查找超过50KB的文件，而-50KB为查找小于50KB的文件）</td></tr><tr><td>-prune</td><td>忽略某个目录</td></tr><tr><td>-exec …… {};</td><td>后面可跟用于进一步处理搜索结果的命令，{}表示find命令搜索出的每一个文件，并且命令的结尾必须是“;”</td></tr></tbody></table><p>示例：</p><ul><li>搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。</li></ul><pre><code class="highlight plaintext">$ find . -name &quot;my*&quot;</code></pre><ul><li>搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息</li></ul><pre><code class="highlight plaintext">$ find . -name &quot;my*&quot; -ls</code></pre><ul><li>在整个文件系统中找出所有归属于linuxprobe用户的文件并复制到/root/findresults目录</li></ul><pre><code class="highlight plaintext">$ find / -user linuxprobe -exec cp -a &#123;&#125; /root/findresults/ \;</code></pre><h4 id="whereis"><a class="markdownIt-Anchor" href="#whereis"></a> whereis</h4><p>whereis命令只能用于程序名的搜索</p><p>语法：</p><pre><code class="highlight plaintext">$ whereis [-bmsu] 文件或者目录名称</code></pre><p>参数：</p><ul><li>-b ： 只找二进制文件</li><li>-m： 只找在说明文件manual路径下的文件</li><li>-s ： 只找source源文件</li><li>-u ： 没有说明文档的文件</li></ul><blockquote><p>和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新</p></blockquote><p>实例：</p><pre><code class="highlight plaintext">$ whereis passwd passwd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz /usr/share/man/man5/passwd.5.gz #将和passwd文件相关的文件都查找出来 $ whereis -b passwd passwd: /usr/bin/passwd /etc/passwd #只将二进制文件 查找出来</code></pre><h4 id="locate"><a class="markdownIt-Anchor" href="#locate"></a> locate</h4><p>locate命令其实是“find -name”的另一种写法，但是要<strong>比后者快得多</strong>，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。</p><p>Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，<strong>可以在使用locate之前，先使用updatedb命令</strong>，手动更新数据库</p><p>语法：</p><pre><code class="highlight plaintext">$ locate 文件或者目录名称</code></pre><p>示例：</p><pre><code class="highlight plaintext">[root@redhat ~]# locate passwd</code></pre><h4 id="which"><a class="markdownIt-Anchor" href="#which"></a> which</h4><p>which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p><p>which是通过 PATH环境变量到该路径内查找可执行文件，所以基本的功能是寻找可执行文件</p><p>语法：</p><pre><code class="highlight plaintext">$ which 可执行文件名称</code></pre><p>示例：</p><pre><code class="highlight plaintext">$ which passwd /usr/bin/passwd</code></pre><h4 id="grep"><a class="markdownIt-Anchor" href="#grep"></a> grep</h4><p>grep（General Regular Expression Parser，通用规则表达式分析程序）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来</p><p>语法：</p><pre><code class="highlight plaintext">grep [选项] pattern [文件名]</code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>将可执行文件(binary)当作文本文件（text）来搜索</td></tr><tr><td>-c</td><td>仅显示找到的行数</td></tr><tr><td>-i</td><td>忽略大小写</td></tr><tr><td>-n</td><td><strong>显示搜索到信息的行号</strong></td></tr><tr><td>-v</td><td><strong>反选信息</strong>（即没有包含关键词的所有信息行）</td></tr><tr><td>-r</td><td>递归搜索文件夹</td></tr><tr><td>-l</td><td>只显示搜索出文件的文件名</td></tr><tr><td>–include</td><td>指定文件后缀名</td></tr></tbody></table><pre><code class="highlight plaintext">#递归搜索当前目录py结尾文件中是否包含xtrabackupgrep -lr &quot;xtrabackup&quot; --include=&quot;*.py&quot; ./</code></pre><p>在Linux系统中，/etc/passwd文件是保存着所有的用户信息，而一旦用户的登录终端被设置成/sbin/nologin，则不再允许登录系统，因此可以使用grep命令来查找出当前系统中不允许登录系统的所有用户信息：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# grep /sbin/nologin /etc/passwdbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologin………………省略部分输出过程信息………………</code></pre><p>为了更好的探究 grep 程序，让我们创建一些文本文件来搜寻：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ ls /bin &gt; dirlist-bin.txt[me@linuxbox ~]$ ls /usr/bin &gt; dirlist-usr-bin.txt[me@linuxbox ~]$ ls /sbin &gt; dirlist-sbin.txt[me@linuxbox ~]$ ls /usr/sbin &gt; dirlist-usr-sbin.txt[me@linuxbox ~]$ ls dirlist*.txtdirlist-bin.txt     dirlist-sbin.txt    dirlist-usr-sbin.txtdirlist-usr-bin.txt</code></pre><p>我们能够对我们的文件列表执行简单的搜索，像这样：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ grep bzip dirlist*.txtdirlist-bin.txt:bzip2dirlist-bin.txt:bzip2recover</code></pre><p><strong>正则匹配</strong></p><pre><code class="highlight plaintext">[me@linuxbox ~]$ grep -h &#x27;^zip&#x27; dirlist*.txtzipzipcloakzipgrepzipinfozipnotezipsplit[me@linuxbox ~]$ grep -h &#x27;zip$&#x27; dirlist*.txtgunzipgzipfunzipgpg-zippreunzipprezipunzipzip[me@linuxbox ~]$ grep -h &#x27;^zip$&#x27; dirlist*.txtzip[me@linuxbox ~]$ grep -i &#x27;^..j.r$&#x27; /usr/share/dict/wordsMajormajor[me@linuxbox ~]$ grep -h &#x27;[bg]zip&#x27; dirlist*.txtbzip2bzip2recovergzip</code></pre><h2 id="归档备份"><a class="markdownIt-Anchor" href="#归档备份"></a> 归档备份</h2><h3 id="解压缩"><a class="markdownIt-Anchor" href="#解压缩"></a> 解压缩</h3><h4 id="gzip"><a class="markdownIt-Anchor" href="#gzip"></a> gzip</h4><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>把输出写入到标准输出，并且保留原始文件。也有可能用–stdout 和–to-stdout 选项来指定。</td></tr><tr><td>-d</td><td>解压缩。正如 gunzip 命令一样。也可以用–decompress 或者–uncompress 选项来指定.</td></tr><tr><td>-f</td><td>强制压缩，即使原始文件的压缩文件已经存在了，也要执行。也可以用–force 选项来指定。</td></tr><tr><td>-h</td><td>显示用法信息。也可用–help 选项来指定。</td></tr><tr><td>-l</td><td>列出每个被压缩文件的压缩数据。也可用–list 选项。</td></tr><tr><td>-r</td><td>若命令的一个或多个参数是目录，则递归地压缩目录中的文件。也可用–recursive 选项来指定。</td></tr><tr><td>-t</td><td>测试压缩文件的完整性。也可用–test 选项来指定。</td></tr><tr><td>-v</td><td>显示压缩过程中的信息。也可用–verbose 选项来指定。</td></tr><tr><td>-number</td><td>设置压缩指数。number 是一个在1（最快，最小压缩）到9（最慢，最大压缩）之间的整数。 数值1和9也可以各自用–fast 和–best 选项来表示。默认值是整数6。</td></tr></tbody></table><p>这个 <strong>gzip</strong> 程序被用来压缩一个或多个文件。当执行 gzip 命令时，则原始文件的压缩版会替代原始文件。 相对应的 <strong>gunzip</strong> 程序被用来把压缩文件复原为没有被压缩的版本。这里有个例子：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ ls -l /etc &gt; foo.txt[me@linuxbox ~]$ ls -l foo.*-rw-r--r-- 1 me     me 15738 2008-10-14 07:15 foo.txt[me@linuxbox ~]$ gzip foo.txt[me@linuxbox ~]$ ls -l foo.*-rw-r--r-- 1 me     me 3230 2008-10-14 07:15 foo.txt.gz[me@linuxbox ~]$ gunzip foo.txt.gz[me@linuxbox ~]$ ls -l foo.*-rw-r--r-- 1 me     me 15738 2008-10-14 07:15 foo.txt</code></pre><h4 id="bzip2"><a class="markdownIt-Anchor" href="#bzip2"></a> bzip2</h4><p>这个 bzip2 程序，由 Julian Seward 开发，与 gzip 程序相似，但是使用了不同的压缩算法， 舍弃了压缩速度，而实现了更高的压缩级别。在大多数情况下，它的工作模式等同于 gzip。 由 bzip2 压缩的文件，用扩展名 .bz2 来表示：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ ls -l /etc &gt; foo.txt[me@linuxbox ~]$ ls -l foo.txt-rw-r--r-- 1 me     me      15738 2008-10-17 13:51 foo.txt[me@linuxbox ~]$ bzip2 foo.txt[me@linuxbox ~]$ ls -l foo.txt.bz2-rw-r--r-- 1 me     me      2792 2008-10-17 13:51 foo.txt.bz2[me@linuxbox ~]$ bunzip2 foo.txt.bz2</code></pre><p>正如我们所看到的，bzip2 程序使用起来和 gzip 程序一样。我们之前讨论的 gzip 程序的所有选项（除了-r） ，bzip2 程序同样也支持。注意，然而，压缩级别选项（-number）对于 bzip2 程序来说，有少许不同的含义。 伴随着 bzip2 程序，有 bunzip2 和 bzcat 程序来解压缩文件。bzip2 文件也带有 bzip2recover 程序，其会 试图恢复受损的 .bz2 文件。</p><h3 id="归档文件"><a class="markdownIt-Anchor" href="#归档文件"></a> 归档文件</h3><p>一个常见的，与文件压缩结合一块使用的文件管理任务是归档。归档就是收集许多文件，并把它们 捆绑成一个大文件的过程。归档经常作为系统备份的一部分来使用。当把旧数据从一个系统移到某 种类型的长期存储设备中时，也会用到归档程序。</p><h4 id="tar-打包"><a class="markdownIt-Anchor" href="#tar-打包"></a> tar 打包</h4><p>tar命令用于对文件进行打包压缩或解压，格式为</p><pre><code class="highlight plaintext">tar [选项] [文件]</code></pre><p>在Linux系统中，常见的文件格式比较多，其中主要使用的是.tar或.tar.gz或.tar.bz2格式，我们不用担心格式太多而记不住，其实这些格式大部分都是由tar命令来生成的。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>创建压缩文件</td></tr><tr><td>-x</td><td>解开压缩文件</td></tr><tr><td>-t</td><td>查看压缩包内有哪些文件</td></tr><tr><td>-z</td><td>用Gzip压缩或解压</td></tr><tr><td>-j</td><td>用bzip2压缩或解压</td></tr><tr><td>-v</td><td>显示压缩或解压的过程</td></tr><tr><td>-f</td><td>目标文件名<strong>必须放在最后</strong></td></tr><tr><td>-p</td><td>保留原始的权限与属性</td></tr><tr><td>-P</td><td>使用绝对路径来压缩</td></tr><tr><td>-C</td><td>指定解压到的目录</td></tr></tbody></table><blockquote><p>-c参数用于创建压缩文件，-x参数用于解压文件，因此这两个参数不能同时使用</p></blockquote><blockquote><p>-z参数指定使用Gzip格式来压缩或解压文件，-j参数指定使用bzip2格式来压缩或解压文件</p></blockquote><blockquote><p>使用-v参数向用户不断显示压缩或解压的过程</p></blockquote><blockquote><p>-C参数用于指定要解压到哪个指定的目录。</p></blockquote><blockquote><p>-f参数特别重要，它必须放到参数的最后一位，代表要压缩或解压的软件包名称</p></blockquote><p>一般使用压缩/解压命令组合：</p><pre><code class="highlight plaintext">tar -czvf 压缩包名称.tar.gz 要打包的目录tar -xzvf 压缩包名称.tar.gz -C 要解压到的目录</code></pre><p>案例：</p><ul><li>使用tar命令把/etc目录通过gzip格式进行打包压缩，并把文件命名为etc.tar.gz：</li></ul><pre><code class="highlight plaintext">[root@linuxprobe ~]# tar czvf etc.tar.gz /etctar: Removing leading `/&#x27; from member names/etc//etc/fstab/etc/crypttab/etc/mtab/etc/fonts//etc/fonts/conf.d//etc/fonts/conf.d/65-0-madan.conf/etc/fonts/conf.d/59-liberation-sans.conf/etc/fonts/conf.d/90-ttf-arphic-uming-embolden.conf/etc/fonts/conf.d/59-liberation-mono.conf/etc/fonts/conf.d/66-sil-nuosu.conf………………省略部分压缩过程信息………………</code></pre><ul><li>接下来将打包后的压缩包文件指定解压到/root/etc目录中（先使用mkdir命令来创建/root/etc目录）：</li></ul><pre><code class="highlight plaintext">[root@linuxprobe ~]# mkdir /root/etc[root@linuxprobe ~]# tar xzvf etc.tar.gz -C /root/etcetc/etc/fstabetc/crypttabetc/mtabetc/fonts/etc/fonts/conf.d/etc/fonts/conf.d/65-0-madan.confetc/fonts/conf.d/59-liberation-sans.confetc/fonts/conf.d/90-ttf-arphic-uming-embolden.confetc/fonts/conf.d/59-liberation-mono.confetc/fonts/conf.d/66-sil-nuosu.confetc/fonts/conf.d/65-1-vlgothic-gothic.confetc/fonts/conf.d/65-0-lohit-bengali.confetc/fonts/conf.d/20-unhint-small-dejavu-sans.conf………………省略部分解压过程信息………………</code></pre><h4 id="zip"><a class="markdownIt-Anchor" href="#zip"></a> zip</h4><p>这个 zip 程序既是压缩工具，也是一个打包工具。这程序使用的文件格式，Windows 用户比较熟悉， 因为它读取和写入.zip 文件。然而，在 Linux 中 gzip 是主要的压缩程序，而 bzip2则位居第二。</p><pre><code class="highlight plaintext">$ zip -r playground.zip playground</code></pre><p>使用 unzip 程序，来直接抽取一个 zip 文件的内容。</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ cd foo[me@linuxbox foo]$ unzip ../playground.zip</code></pre><h2 id="用户用户组管理"><a class="markdownIt-Anchor" href="#用户用户组管理"></a> 用户/用户组管理</h2><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p><p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p><p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p><ul><li>用户账号的添加、删除与修改。</li><li>用户口令的管理。</li><li>用户组的管理。</li></ul><h3 id="用户账号的管理"><a class="markdownIt-Anchor" href="#用户账号的管理"></a> 用户账号的管理</h3><p>用户账号的管理工作主要涉及到用户账号的添加、修改和删除。</p><p>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。</p><h4 id="useradd添加新用户"><a class="markdownIt-Anchor" href="#useradd添加新用户"></a> useradd(添加新用户)</h4><p>语法：</p><pre><code class="highlight plaintext">useradd 选项 用户名</code></pre><p>参数说明：</p><ul><li>-c comment 指定一段注释性描述。</li><li>-d 目录 指定用户主目录(默认为/home/username)，如果此目录不存在，则同时使用-m选项，可以创建主目录。</li><li>-g 用户组 指定用户所属的用户组。</li><li>-G 用户组，用户组 指定用户所属的附加组。</li><li>-s Shell文件 指定用户的登录Shell。</li><li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li><li>-e 账户的到期时间，格式为YYYY-MM-DD</li><li>-N 不创建与用户同名的基本用户组</li><li>用户名 : 指定新账号的登录名。</li></ul><p>案例：</p><ul><li>此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录 /home/sam（/home为默认的用户主目录所在的父目录）</li></ul><pre><code class="highlight plaintext"># useradd –d  /home/sam -m sam</code></pre><ul><li>此命令新建了一个用户gem，该用户的登录Shell是 /bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组</li></ul><pre><code class="highlight plaintext"># useradd -s /bin/sh -g group –G adm,root gem</code></pre><blockquote><p>增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。</p></blockquote><blockquote><p>Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理</p></blockquote><h4 id="userdel删除账号"><a class="markdownIt-Anchor" href="#userdel删除账号"></a> userdel(删除账号)</h4><p>如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录</p><p>删除一个已有的用户账号使用userdel命令，其格式如下：</p><p>语法：</p><pre><code class="highlight plaintext">userdel 选项 用户名</code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-f</td><td>强制删除用户</td></tr><tr><td>-r</td><td>同时删除用户及用户家目录</td></tr></tbody></table><blockquote><p>常用的选项是-r，作用是把主目录一起删除</p></blockquote><p>例如：</p><pre><code class="highlight plaintext"># userdel -r sam</code></pre><blockquote><p>此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录</p></blockquote><h4 id="usermod修改账号"><a class="markdownIt-Anchor" href="#usermod修改账号"></a> usermod(修改账号)</h4><p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。</p><p>修改已有用户的信息使用usermod命令，其格式如下：</p><pre><code class="highlight plaintext">usermod 选项 用户名</code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>填写用户账户的备注信息</td></tr><tr><td>-d</td><td>-m 参数-m与参数-d连用，可重新指定用户的家目录并自动把旧的数据转移过去</td></tr><tr><td>-e</td><td>账户的到期时间，格式为YYYY-MM-DD</td></tr><tr><td>-g</td><td>变更所属用户组</td></tr><tr><td>-G</td><td>变更扩展用户组</td></tr><tr><td>-L</td><td>锁定用户禁止其登录系统</td></tr><tr><td>-U</td><td>解锁用户，允许其登录系统</td></tr><tr><td>-s</td><td>变更默认终端</td></tr><tr><td>-u</td><td>修改用户的UID</td></tr></tbody></table><p>例子：</p><p>此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer</p><pre><code class="highlight plaintext"># usermod -s /bin/ksh -d /home/z –g developer sam</code></pre><h4 id="passwd用户口令的管理"><a class="markdownIt-Anchor" href="#passwd用户口令的管理"></a> passwd(用户口令的管理)</h4><p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p><p>指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：</p><pre><code class="highlight plaintext">passwd 选项 用户</code></pre><p>可使用的选项：</p><ul><li>-l 锁定口令，即禁用账号。</li><li>-u 口令解锁。</li><li>-d 使该用户可用空密码登录系统。</li><li>-e 强迫用户下次登录时修改口令。</li><li>-S 显示用户的密码是否可以被锁定，以及密码所采用的加密算法名称</li></ul><blockquote><p>如果默认用户名，则修改当前用户的口令。</p></blockquote><p>例子：</p><p>假设当前用户是sam，则下面的命令修改该用户自己的口令：</p><pre><code class="highlight plaintext">$ passwd Old password:****** New password:******* Re-enter new password:*******</code></pre><p>如果是超级用户，可以用下列形式指定任何用户的口令：</p><pre><code class="highlight plaintext"># passwd sam New password:******* Re-enter new password:*******</code></pre><blockquote><p>普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。</p></blockquote><p>为用户<strong>指定空口令</strong>时，执行下列形式的命令：</p><pre><code class="highlight plaintext"># passwd -d sam</code></pre><blockquote><p>此命令将用户 sam 的口令删除，这样用户 sam 下一次登录时，系统就不再允许该用户登录了</p></blockquote><p>passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如：</p><pre><code class="highlight plaintext"># pwsswd -l sam</code></pre><h3 id="用户组的管理"><a class="markdownIt-Anchor" href="#用户组的管理"></a> 用户组的管理</h3><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p><p>用户组的管理涉及用户组的添加、删除和修改。<strong>组的增加、删除和修改实际上就是对/etc/group文件的更新</strong>。</p><h4 id="group增加用户组"><a class="markdownIt-Anchor" href="#group增加用户组"></a> group(增加用户组)</h4><p>语法：</p><pre><code class="highlight plaintext">groupadd 选项 用户组</code></pre><p>可以使用的选项有：</p><ul><li>-g GID 指定新用户组的组标识号（GID）</li><li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同</li></ul><p>实例:</p><pre><code class="highlight plaintext"># groupadd group1</code></pre><blockquote><p>此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。</p></blockquote><p>实例2：</p><pre><code class="highlight plaintext"># groupadd -g 101 group2</code></pre><blockquote><p>此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101</p></blockquote><h4 id="groupdel删除用户组"><a class="markdownIt-Anchor" href="#groupdel删除用户组"></a> groupdel(删除用户组)</h4><p>语法：</p><pre><code class="highlight plaintext">groupdel 用户组</code></pre><p>例如：</p><p>从命令中删除用户组：</p><pre><code class="highlight plaintext"># groupdel group1</code></pre><h4 id="groupmod修改用户组"><a class="markdownIt-Anchor" href="#groupmod修改用户组"></a> groupmod(修改用户组)</h4><p>语法：</p><pre><code class="highlight plaintext">groupmod 选项 用户组</code></pre><p>常用选项：</p><ul><li>-g GID 为用户组指定新的组标识号。</li><li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li><li>-n新用户组 将用户组的名字改为新名字</li></ul><p>实例：</p><ul><li>此命令将组group2的组标识号修改为102</li></ul><pre><code class="highlight plaintext"># groupmod -g 102 group2</code></pre><ul><li>此命令将组group2的标识号改为10000，组名修改为group3</li></ul><pre><code class="highlight plaintext"># groupmod –g 10000 -n group3 group2</code></pre><h4 id="切换用户组"><a class="markdownIt-Anchor" href="#切换用户组"></a> 切换用户组</h4><p>用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：</p><pre><code class="highlight plaintext">$ newgrp root</code></pre><p>这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。</p><h3 id="与用户账号有关的系统文件"><a class="markdownIt-Anchor" href="#与用户账号有关的系统文件"></a> 与用户账号有关的系统文件</h3><p>完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。</p><p>与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。下面分别介绍这些文件的内容。</p><h4 id="etcpasswd-用户信息"><a class="markdownIt-Anchor" href="#etcpasswd-用户信息"></a> /etc/passwd 用户信息</h4><p>Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。这个文件对所有用户都是可读的。它的内容类似下面的例子：</p><pre><code class="highlight plaintext">＃ cat /etc/passwdroot:x:0:0:Superuser:/:daemon:x:1:1:System daemons:/etc:bin:x:2:2:Owner of system commands:/bin:sys:x:3:3:Owner of system files:/usr/sys:adm:x:4:4:System accounting:/usr/adm:uucp:x:5:5:UUCP administrator:/usr/lib/uucp:auth:x:7:21:Authentication administrator:/tcb/files/auth:cron:x:9:16:Cron daemon:/usr/spool/cron:listen:x:37:4:Network daemon:/usr/net/nls:lp:x:71:18:Printer administrator:/usr/spool/lp:sam:x:200:50:Sam san:/home/sam:/bin/sh</code></pre><p>含义如下：</p><ul><li>&quot;用户名&quot;是代表用户账号的字符串</li><li>“口令”一些系统中，存放着加密后的用户口令字</li><li>“用户标识号”是一个整数，系统内部用它来标识用户</li><li>“组标识号”字段记录的是用户所属的用户组</li><li>“注释性描述”字段记录着用户的一些个人情况</li><li>“主目录”，也就是用户的起始工作目录</li><li>用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell</li></ul><pre><code class="highlight plaintext">用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</code></pre><blockquote><p>由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件<strong>是/etc/shadow文件</strong>。 有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p></blockquote><blockquote><p>/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生</p></blockquote><hr /><p><strong>/etc/shadow文件格式</strong></p><ul><li>&quot;登录名&quot;是与/etc/passwd文件中的登录名相一致的用户账号</li><li>&quot;口令&quot;字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。</li><li>&quot;最后一次修改时间&quot;表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。</li><li>&quot;最小时间间隔&quot;指的是两次修改口令之间所需的最小天数。</li><li>&quot;最大时间间隔&quot;指的是口令保持有效的最大天数。</li><li>&quot;警告时间&quot;字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</li><li>&quot;不活动时间&quot;表示的是用户没有登录活动但账号仍能保持有效的最大天数。</li><li>&quot;失效时间&quot;字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</li></ul><pre><code class="highlight plaintext">登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</code></pre><h4 id="etcgroup-用户组"><a class="markdownIt-Anchor" href="#etcgroup-用户组"></a> /etc/group 用户组</h4><p>将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。</p><p>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。</p><p>当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。</p><p>用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。</p><p>用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：</p><pre><code class="highlight plaintext">组名:口令:组标识号:组内用户列表</code></pre><ul><li>&quot;组名&quot;是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。</li><li>&quot;口令&quot;字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*</li><li>&quot;组标识号&quot;与用户标识号类似，也是一个整数，被系统内部用来标识组。</li><li>&quot;组内用户列表&quot;是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</li></ul><p>例子：</p><pre><code class="highlight plaintext">root::0:rootbin::2:root,binsys::3:root,uucpadm::4:root,admdaemon::5:root,daemonlp::7:root,lpusers::20:root,sam</code></pre><h4 id="批量添加用户"><a class="markdownIt-Anchor" href="#批量添加用户"></a> 批量添加用户</h4><p>添加和删除用户对每位Linux系统管理员都是轻而易举的事，比较棘手的是如果要添加几十个、上百个甚至上千个用户时，我们不太可能还使用useradd一个一个地添加，必然要找一种简便的创建大量用户的方法。Linux系统提供了创建大量用户的工具，可以让您立即创建大量用户，方法如下：</p><ol><li><strong>先编辑一个文本用户文件</strong><br />每一列按照/etc/passwd密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。一个范例文件user.txt内容如下：</li></ol><pre><code class="highlight plaintext">user001::600:100:user:/home/user001:/bin/bashuser002::601:100:user:/home/user002:/bin/bashuser003::602:100:user:/home/user003:/bin/bashuser004::603:100:user:/home/user004:/bin/bashuser005::604:100:user:/home/user005:/bin/bashuser006::605:100:user:/home/user006:/bin/bash</code></pre><ol><li><strong>以root身份执行命令</strong> /usr/sbin/newusers，从刚创建的用户文件user.txt中导入数据，创建用户：</li></ol><pre><code class="highlight plaintext"># newusers &lt; user.txt</code></pre><ol><li><strong>执行命令</strong>/usr/sbin/pwunconv<br />将 /etc/shadow 产生的 shadow 密码解码，然后回写到 /etc/passwd 中，并将/etc/shadow的shadow密码栏删掉。这是为了方便下一步的密码转换工作，即先取消 shadow password 功能</li></ol><pre><code class="highlight plaintext"># pwunconv</code></pre><ol><li><strong>编辑每个用户的密码对照文件</strong></li></ol><pre><code class="highlight plaintext">user001:123456user002:123456user003:123456user004:123456user005:123456user006:123456</code></pre><ol><li>以root身份执行命令/usr/sbin/chpasswd<br />创建用户密码，chpasswd 会将经过 /usr/bin/passwd 命令编码过的密码写入 /etc/passwd 的密码栏</li></ol><pre><code class="highlight plaintext"># chpasswd &lt; passwd.txt</code></pre><ol><li>确定密码经编码写入/etc/passwd的密码栏后<br />执行命令 /usr/sbin/pwconv 将密码编码为 shadow password，并将结果写入 /etc/shadow。</li></ol><pre><code class="highlight plaintext"># pwconv</code></pre><blockquote><p>这样就完成了大量用户的创建了，之后您可以到/home下检查这些用户宿主目录的权限设置是否都正确，并登录验证用户密码是否正确。</p></blockquote><h2 id="管道符重定向环境变量"><a class="markdownIt-Anchor" href="#管道符重定向环境变量"></a> 管道符/重定向/环境变量</h2><p>既然我们已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><h3 id="输入输出重定向"><a class="markdownIt-Anchor" href="#输入输出重定向"></a> 输入输出重定向</h3><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。</p><p>相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及清空写入与追加写入两种模式</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>标准输入重定向（STDIN，文件描述符为0）</td><td>默认从键盘输入，也可从其他文件或命令中输入。</td></tr><tr><td>标准输出重定向（STDOUT，文件描述符为1）</td><td>默认输出到屏幕。</td></tr><tr><td>错误输出重定向（STDERR，文件描述符为2）</td><td>默认输出到屏幕。</td></tr></tbody></table><p>比如我们分别查看两个文件的属性信息，其中第二个文件是不存在的，虽然针对这两个文件的操作都分别会在屏幕上输出一些数据信息，但这两个操作的差异其实很大：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# touch linuxprobe[root@linuxprobe ~]# ls -l linuxprobe -rw-r--r--. 1 root root 0 Aug 5 05:35 linuxprobe[root@linuxprobe ~]# ls -l xxxxxxls: cannot access xxxxxx: No such file or directory</code></pre><p>在上述命令中，名为linuxprobe的文件是存在的，输出信息是该文件的一些相关权限、所有者、所属组、文件大小及修改时间等信息，这也是该命令的<strong>标准输出信息</strong>。</p><p>而名为xxxxxx的第二个文件是不存在的，因此在执行完ls命令之后显示的报错提示信息也是该命令的<strong>错误输出信息</strong>。</p><p>那么，要想把原本输出到屏幕上的数据转而写入到文件当中，就要区别对待这两种输出信息。</p><p><strong>输入重定向</strong>中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p><strong>输出重定向</strong>中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><blockquote><p><strong>对于重定向中的标准输出模式，可以省略文件描述符1不写，而错误输出模式的文件描述符2是必须要写的</strong>。</p></blockquote><p>通过标准输出重定向将man bash命令原本要输出到屏幕的信息写入到文件readme.txt中，然后显示readme.txt文件中的内容。具体命令如下：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# man bash &gt; readme.txt[root@linuxprobe ~]# cat readme.txt</code></pre><p><img src="image/-16.png" alt="-16.png" /></p><p>案例：</p><p>不同命令的标准输出和错误输出还是有区别的。例如查看当前目录中某个文件的信息，这里以linuxprobe文件为例。因为这个文件是真实存在的，<strong>因此使用标准输出即可将原本要输出到屏幕的信息写入到文件中，而错误的输出重定向则依然把信息输出到了屏幕上</strong>。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# ls -l linuxprobe -rw-r--r--. 1 root root 0 Mar  1 13:30 linuxprobe[root@linuxprobe ~]# ls -l linuxprobe &gt; /root/stderr.txt [root@linuxprobe ~]# ls -l linuxprobe 2&gt; /root/stderr.txt -rw-r--r--. 1 root root 0 Mar  1 13:30 linuxprobe</code></pre><p>如果想把命令的报错信息写入到文件，该怎么操作呢？当用户在执行一个自动化的Shell脚本时，这个操作会特别有用，而且特别实用，因为它可以把整个脚本执行过程中的报错信息都记录到文件中，便于安装后的排错工作。接下来我们以一个不存在的文件进行实验演示：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# ls -l xxxxxx cannot access xxxxxx: No such file or directory[root@linuxprobe ~]# ls -l xxxxxx &gt; /root/stderr.txtcannot access xxxxxx: No such file or directory[root@linuxprobe ~]# ls -l xxxxxx 2&gt; /root/stderr.txt[root@linuxprobe ~]# cat /root/stderr.txt ls: cannot access xxxxxx: No such file or directory</code></pre><p>输入重定向相对来说有些冷门，在工作中遇到的概率会小一点。输入重定向的作用是把文件直接导入到命令中。接下来使用输入重定向把readme.txt文件导入给wc -l命令，统计一下文件中的内容行数。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# wc -l &lt; readme.txt</code></pre><h3 id="管道命令符"><a class="markdownIt-Anchor" href="#管道命令符"></a> 管道命令符</h3><p>管道是Linux中的一种跨进程通信的机制，和重定向不同，管道用做进程与进程之间传送数据。做为Linux中默认的脚本语言，shell中也是可以使用管道的，在shell中，管道用|表示</p><p>格式：</p><pre><code class="highlight plaintext">命令A | 命令B | . . .</code></pre><p>（1）使用管道进行数据筛选内容中包含root的行</p><pre><code class="highlight plaintext">ls -l /|grep root</code></pre><p>这个例子中，ls命令输出的内容传给了grep命令进行筛选</p><p>（2）也可以同时用多个管道使用多个管道把数据筛选并统计</p><pre><code class="highlight plaintext">ls -l / | grep root | wc -l</code></pre><p>这个例子中，ls命令输出的内容传给了grep命令进行筛选，然后转给wc命令统计行数。</p><p>（3）用翻页的形式查看/etc目录中的文件列表及属性信息</p><pre><code class="highlight plaintext">ls -l /etc/ | more</code></pre><hr /><p>为了更好的理解管道，写两个脚本来体验一下：</p><p>in.sh文件</p><pre><code class="highlight plaintext">#! /bin/bashread msgecho &quot;Receive :$&#123;msg&#125;&quot;</code></pre><p>out.sh文件</p><pre><code class="highlight plaintext">#! /bin/bashecho &#x27;hello&#x27;</code></pre><p>执行：</p><pre><code class="highlight plaintext">./out.sh |./in.sh输出：Receive :hello</code></pre><blockquote><p>符合我们预期，<a href="http://xn--helloout-ue0mp4cm79e503f.xn--shin-rs5fy5a20ner8l.sh">字符串hello从out.sh传送到了in.sh</a></p></blockquote><h3 id="命令行的通配符"><a class="markdownIt-Anchor" href="#命令行的通配符"></a> 命令行的通配符</h3><p>在开始使用命令之前，我们需要介绍一个使命令行如此强大的 shell 特性。因为 shell 频繁地使用 文件名，shell 提供了特殊字符来帮助你快速指定一组文件名。这些特殊字符叫做通配符。 使用通配符（也以文件名代换著称）允许你依据字符类型来选择文件名。下表列出这些通配符 以及它们所选择的对象：</p><p><strong>通配符</strong></p><table><thead><tr><th>通配符</th><th>意义</th></tr></thead><tbody><tr><td>*</td><td>匹配任意多个字符（包括零个或一个）</td></tr><tr><td>？</td><td>匹配任意一个字符（不包括零个）</td></tr><tr><td>[characters]</td><td>匹配任意一个属于字符集中的字符</td></tr><tr><td>[!characters]</td><td>匹配任意一个不是字符集中的字符</td></tr><tr><td>[[:class:]]</td><td>匹配任意一个属于指定字符类中的字符</td></tr></tbody></table><p><strong>普遍使用的字符类</strong></p><table><thead><tr><th>字符类</th><th>意义</th></tr></thead><tbody><tr><td>[:alnum:]</td><td>匹配任意一个字母或数字</td></tr><tr><td>[:alpha:]</td><td>匹配任意一个字母</td></tr><tr><td>[:digit:]</td><td>匹配任意一个数字</td></tr><tr><td>[:lower:]</td><td>匹配任意一个小写字母</td></tr><tr><td>[:upper]</td><td>匹配任意一个大写字母</td></tr></tbody></table><p><strong>案例：</strong></p><table><thead><tr><th>模式</th><th>匹配对象</th></tr></thead><tbody><tr><td>*</td><td>所有文件</td></tr><tr><td>g*</td><td>文件名以“g”开头的文件</td></tr><tr><td>b*.txt</td><td>以&quot;b&quot;开头，中间有零个或任意多个字符，并以&quot;.txt&quot;结尾的文件</td></tr><tr><td>Data???</td><td>以“Data”开头，其后紧接着3个字符的文件</td></tr><tr><td>[abc]*</td><td>文件名以&quot;a&quot;,“b”,或&quot;c&quot;开头的文件</td></tr><tr><td>BACKUP.[0-9][0-9][0-9]</td><td>以&quot;BACKUP.&quot;开头，并紧接着3个数字的文件</td></tr><tr><td>[[:upper:]]*</td><td>以大写字母开头的文件</td></tr><tr><td>[![:digit:]]*</td><td>不以数字开头的文件</td></tr><tr><td><code>*[[:lower:]123]</code></td><td>文件名以小写字母结尾，或以 “1”，“2”，或 “3” 结尾的文件</td></tr></tbody></table><blockquote><p>接受文件名作为参数的任何命令，都可以使用通配符</p></blockquote><h3 id="常用的转义字符"><a class="markdownIt-Anchor" href="#常用的转义字符"></a> 常用的转义字符</h3><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>反斜杠（\）</td><td>使反斜杠后面的一个字符变为单纯的字符。</td></tr><tr><td>单引号（‘’）</td><td>单引号里的任何字符都会原样输出，单引号中的变量是无效的，单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</td></tr><tr><td>双引号（“”）</td><td>双引号中可以有变量，双引号中可以出现转义字符</td></tr><tr><td><code>反引号（``）</code></td><td>把其中的命令执行后返回结果。</td></tr></tbody></table><p>我们先定义一个名为PRICE的变量并赋值为5，然后输出以双引号括起来的字符串与变量信息：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# PRICE=5[root@linuxprobe ~]# echo &quot;Price is $PRICE&quot;Price is 5[root@linuxprobe ~]# echo &#x27;Price is $PRICE&#x27;Price is $PRICE</code></pre><p>要想让第一个“$”乖乖地作为美元符号，那么就需要使用反斜杠（\）来进行转义，将这个命令提取符转义成单纯的文本，去除其特殊功能。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# echo &quot;Price is $$PRICE&quot;Price is 3767PRICE[root@linuxprobe ~]# echo &quot;Price is \$$PRICE&quot;Price is $5</code></pre><p>如果只需要某个命令的输出值时，可以像命令这样，将命令用反引号括起来，达到预期的效果。例如，将反引号与uname -a命令结合，然后使用echo命令来查看本机的Linux版本和内核信息：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# echo `uname -a`Linux linuxprobe.com 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2017 x86_64 x86_64 x86_64 GNU/Linux</code></pre><h3 id="重要的环境变量"><a class="markdownIt-Anchor" href="#重要的环境变量"></a> 重要的环境变量</h3><p>变量是计算机系统用于保存可变值的数据类型。在Linux系统中，变量名称一般都是大写的，这是一种约定俗成的规范。我们可以直接通过变量名称来提取到对应的变量值。Linux系统中的环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录、邮件存放位置等。</p><p>为了通过环境变量帮助Linux系统构建起能够为用户提供服务的工作运行环境，需要数百个变量协同工作才能完成。</p><p>前文中曾经讲到，在Linux系统中一切都是文件，Linux命令也不例外。那么，在用户执行了一条命令之后，Linux系统中到底发生了什么事情呢？简单来说，命令在Linux中的执行分为4个步骤。</p><ul><li><strong>第1步</strong>：判断用户是否以绝对路径或相对路径的方式输入命令（如/bin/ls），如果是的话则直接执行。</li><li><strong>第2步</strong>：Linux系统检查用户输入的命令是否为“别名命令”，即用一个自定义的命令名称来替换原本的命令名称。可以<strong>用alias命令来创建一个属于自己的命令别名</strong>，格式为“<strong>alias 别名=命令</strong>”。若要取消一个命令别名，则是用unalias命令，格式为“<strong>unalias 别名</strong>”。我们之前在使用rm命令删除文件时，Linux系统都会要求我们再确认是否执行删除操作，其实这就是Linux系统为了防止用户误删除文件而特意设置的rm别名命令，接下来我们把它取消掉：</li></ul><pre><code class="highlight plaintext">[root@linuxprobe ~]# lsanaconda-ks.cfg Documents initial-setup-ks.cfg Pictures TemplatesDesktop Downloads Music Public Videos[root@linuxprobe ~]# rm anaconda-ks.cfg rm: remove regular file ‘anaconda-ks.cfg’? y[root@linuxprobe~]# alias rmalias rm=&#x27;rm -i&#x27;[root@linuxprobe ~]# unalias rm[root@linuxprobe ~]# rm initial-setup-ks.cfg [root@linuxprobe ~]#</code></pre><ul><li><strong>第3步</strong>：Bash解释器判断用户输入的是内部命令还是外部命令。内部命令是解释器内部的指令，会被直接执行；而用户在绝大部分时间输入的是外部命令，这些命令交由步骤4继续处理。可以使用“<strong>type命令名称</strong>”来判断用户输入的命令是内部命令还是外部命令。</li><li><strong>第4步</strong>：系统在多个路径中查找用户输入的命令文件，而定义这些路径的变量叫作PATH，可以简单地把它理解成是“解释器的小助手”，作用是告诉Bash解释器待执行的命令可能存放的位置，然后Bash解释器就会乖乖地在这些位置中逐个查找。PATH是由多个路径值组成的变量，每个路径值之间用<strong>冒号</strong>间隔，对这些路径的增加和删除操作将影响到Bash解释器对Linux命令的查找。</li></ul><pre><code class="highlight plaintext">[root@linuxprobe ~]# echo $PATH/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin[root@linuxprobe ~]# PATH=$PATH:/root/bin[root@linuxprobe ~]# echo $PATH/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/root/bin</code></pre><p>我们可以<strong>使用env命令</strong>来查看到Linux系统中<strong>所有的环境变量</strong>，而最重要的10个环境变量，如表所示：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><p>Linux作为一个多用户多任务的操作系统，能够为每个用户提供独立的、合适的工作运行环境，因此，<strong>一个相同的变量会因为用户身份的不同而具有不同的值</strong>。例如，我们使用下述命令来查看HOME变量在不同用户身份下都有哪些值</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# echo $HOME/root[root@linuxprobe ~]# su - linuxprobeLast login: Fri Feb 27 19:49:57 CST 2017 on pts/0[linuxprobe@linuxprobe ~]$ echo $HOME/home/linuxprobe</code></pre><p>其实变量是由固定的变量名与用户或系统设置的变量值两部分组成的，我们完全可以自行创建变量，来满足工作需求。例如设置一个名称为WORKDIR的变量，方便用户更轻松地进入一个层次较深的目录：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# mkdir /home/workdir[root@linuxprobe ~]# WORKDIR=/home/workdir[root@linuxprobe ~]# cd $WORKDIR [root@linuxprobe workdir]# pwd/home/workdir</code></pre><p>但是，这样的变量不具有全局性，作用范围也有限，默认情况下不能被其他用户使用。如果工作需要，<strong>可以使用export命令将其提升为全局变量</strong>，这样其他用户也就可以使用它了：</p><pre><code class="highlight plaintext">[root@linuxprobe workdir]# su linuxprobeLast login: Fri Mar 20 20:52:10 CST 2017 on pts/0[linuxprobe@linuxprobe ~]$ cd $WORKDIR[linuxprobe@linuxprobe ~]$ echo $WORKDIR[linuxprobe@linuxprobe ~]$ exit[root@linuxprobe ~]# export WORKDIR[root@linuxprobe ~]# su linuxprobeLast login: Fri Mar 20 21:52:10 CST 2017 on pts/0[linuxprobe@linuxprobe ~]$ cd $WORKDIR[linuxprobe@linuxprobe workdir]$ pwd/home/workdir</code></pre><h2 id="存储结构磁盘划分"><a class="markdownIt-Anchor" href="#存储结构磁盘划分"></a> 存储结构/磁盘划分</h2><table><thead><tr><th>目录名称</th><th>应放置文件的内容</th></tr></thead><tbody><tr><td>/boot</td><td>开机所需文件—内核、开机菜单以及所需配置文件等</td></tr><tr><td>/dev</td><td>以文件形式存放任何设备与接口</td></tr><tr><td>/etc</td><td>配置文件</td></tr><tr><td>/home</td><td>用户主目录</td></tr><tr><td>/bin</td><td>存放单用户模式下还可以操作的命令</td></tr><tr><td>/lib</td><td>开机时用到的函数库，以及/bin与/sbin下面的命令要调用的函数</td></tr><tr><td>/sbin</td><td>开机过程中需要的命令</td></tr><tr><td>/media</td><td>用于挂载设备文件的目录</td></tr><tr><td>/opt</td><td>放置第三方的软件</td></tr><tr><td>/root</td><td>系统管理员的家目录</td></tr><tr><td>/srv</td><td>一些网络服务的数据文件目录</td></tr><tr><td>/tmp</td><td>任何人均可使用的“共享”临时目录</td></tr><tr><td>/proc</td><td>虚拟文件系统，例如系统内核、进程、外部设备及网络状态等</td></tr><tr><td>/usr/local</td><td>用户自行安装的软件</td></tr><tr><td>/usr/sbin</td><td>Linux系统开机时不会使用到的软件/命令/脚本</td></tr><tr><td>/usr/share</td><td>帮助与说明文件，也可放置共享文件</td></tr><tr><td>/var</td><td>主要存放经常变化的文件，如日志</td></tr><tr><td>/lost+found</td><td>当文件系统发生错误时，将一些丢失的文件片段存放在这里</td></tr></tbody></table><h3 id="物理设备的命名规则"><a class="markdownIt-Anchor" href="#物理设备的命名规则"></a> 物理设备的命名规则</h3><p>在Linux系统中一切都是文件，硬件设备也不例外。既然是文件，就必须有文件名称。系统内核中的udev设备管理器会自动把硬件名称规范起来，目的是让用户通过设备文件的名字可以猜出设备大致的属性以及分区信息等；这对于陌生的设备来说特别方便。另外，udev设备管理器的服务会一直以守护进程的形式运行并侦听内核发出的信号来管理/dev目录下的设备文件。</p><p>Linux系统中常见的硬件设备的文件名称如表所示</p><table><thead><tr><th>硬件设备</th><th>文件名称</th></tr></thead><tbody><tr><td>IDE设备</td><td>/dev/hd[a-d]</td></tr><tr><td>SCSI/SATA/U盘</td><td>/dev/sd[a-p]</td></tr><tr><td>软驱</td><td>/dev/fd[0-1]</td></tr><tr><td>打印机</td><td>/dev/lp[0-15]</td></tr><tr><td>光驱</td><td>/dev/cdrom</td></tr><tr><td>鼠标</td><td>/dev/mouse</td></tr><tr><td>磁带机</td><td>/dev/st0或/dev/ht0</td></tr></tbody></table><p>由于现在的IDE设备已经很少见了，所以一般的硬盘设备都会是以“/dev/sd”开头的。而一台主机上可以有多块硬盘，因此系统采用a～p来代表16块不同的硬盘（默认从a开始分配），而且硬盘的分区编号也很有讲究：</p><ul><li>主分区或扩展分区的编号从1开始，到4结束；</li><li>逻辑分区从编号5开始。</li></ul><p><img src="image/-17.png" alt="-17.png" /></p><p>首先，/dev/目录中保存的应当是硬件设备文件；其次，sd表示是存储设备；然后，a表示系统中同类接口中第一个被识别到的设备，最后，5表示这个设备是一个逻辑分区。一言以蔽之，“/dev/sda5”表示的就是“<strong>这是系统中第一块被识别到的硬件设备中分区编号为5的逻辑分区的设备文件</strong>”</p><h3 id="挂载硬件设备"><a class="markdownIt-Anchor" href="#挂载硬件设备"></a> 挂载硬件设备</h3><h4 id="mount"><a class="markdownIt-Anchor" href="#mount"></a> mount</h4><p>我们在用惯了Windows系统后总觉得一切都是理所当然的，平时把U盘插入到电脑后也从来没有考虑过Windows系统做了哪些事情，才使得我们可以访问这个U盘的。接下来我们会逐一学习在Linux系统中挂载和卸载存储设备的方法，以便大家更好地了解Linux系统添加硬件设备的工作原理和流程。前面讲到，在拿到一块全新的硬盘存储设备后要先分区，然后格式化，最后才能挂载并正常使用。“分区”和“格式化”大家以前经常听到，但“挂载”又是什么呢？刘遄老师在这里给您一个最简单、最贴切的解释—<strong>当用户需要使用硬盘设备或分区中的数据时，需要先将其与一个已存在的目录文件进行关联，而这个关联动作就是“挂载”</strong>。</p><p><strong>mount命令</strong>用于挂载文件系统，格式为</p><pre><code class="highlight plaintext">mount 文件系统 挂载目录</code></pre><p>挂载是在使用硬件设备前所执行的最后一步操作。只需使用mount命令把硬盘设备或分区与一个目录文件进行关联，然后就能在这个目录中看到硬件设备中的数据了。对于比较新的Linux系统来讲，一般不需要使用-t参数来指定文件系统的类型，Linux系统会自动进行判断。而mount 中的-a参数则厉害了，它会在执行后自动检查/etc/fstab文件中有无疏漏被挂载的设备文件，如果有，则进行自动挂载操作。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>挂载所有在/etc/fstab中定义的文件系统</td></tr><tr><td>-t</td><td>指定文件系统的类型</td></tr></tbody></table><p>例如，要把设备/dev/sdb2挂载到/backup目录，只需要在mount命令中填写设备与挂载目录参数就行，系统会自动去判断要挂载文件的类型，因此只需要执行下述命令即可：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# mount /dev/sdb2 /backup</code></pre><hr /><p>虽然按照上面的方法执行mount命令后就能立即使用文件系统了，但系统在<strong>重启后挂载就会失效</strong>，也就是说我们需要每次开机后都手动挂载一下。这肯定不是我们想要的效果，如果想<strong>让硬件设备和目录永久地进行自动关联</strong>，就必须把挂载信息按照指定的填写格式“设备文件 挂载目录 格式类型 权限选项 是否备份 是否自检”写入<strong>到/etc/fstab文件中</strong></p><table><thead><tr><th>字段</th><th>意义</th></tr></thead><tbody><tr><td>设备文件</td><td>一般为设备的路径+设备名称，也可以写唯一识别码（UUID，Universally Unique Identifier）</td></tr><tr><td>挂载目录</td><td>指定要挂载到的目录，需在挂载前创建好</td></tr><tr><td>格式类型</td><td>指定文件系统的格式，比如Ext3、Ext4、XFS、SWAP、iso9660（此为光盘设备）等</td></tr><tr><td>权限选项</td><td>若设置为defaults，则默认权限为：rw, suid, dev, exec, auto, nouser, async</td></tr><tr><td>是否备份</td><td>若为1则开机后使用dump进行磁盘备份，为0则不备份</td></tr><tr><td>是否自检</td><td>若为1则开机后自动进行磁盘自检，为0则不自检</td></tr></tbody></table><p>如果想将文件系统为ext4的硬件设备/dev/sdb2在开机后自动挂载到/backup目录上，并保持默认权限且无需开机自检，就需要在/etc/fstab文件中写入下面的信息，这样在系统重启后也会成功挂载。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# vim /etc/fstab## /etc/fstab# Created by anaconda on Wed May 4 19:26:23 2017## Accessible filesystems, by reference, are maintained under &#x27;/dev/disk&#x27;# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info#/dev/mapper/rhel-root / xfs defaults 1 1UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b /boot xfs defaults 1 2/dev/mapper/rhel-swap swap swap defaults 0 0/dev/cdrom /media/cdrom iso9660 defaults 0 0 /dev/sdb2 /backup ext4 defaults 0 0</code></pre><hr /><h4 id="umount"><a class="markdownIt-Anchor" href="#umount"></a> umount</h4><p><strong>umount命令用于撤销已经挂载的设备文件</strong>，格式为</p><pre><code class="highlight plaintext">umount [挂载点/设备文件]</code></pre><p>我们挂载文件系统的目的是为了使用硬件资源，而卸载文件系统就意味不再使用硬件的设备资源；相对应地，挂载操作就是把硬件设备与目录进行关联的动作，因此卸载操作只需要说明想要取消关联的设备文件或挂载目录的其中一项即可，一般不需要加其他额外的参数。我们来尝试手动卸载掉/dev/sdb2设备文件：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# umount /dev/sdb2</code></pre><h3 id="添加硬盘设备"><a class="markdownIt-Anchor" href="#添加硬盘设备"></a> 添加硬盘设备</h3><ul><li>在虚拟机添加一个硬盘</li></ul><p><img src="image/-18.png" alt="-18.png" /></p><p>在虚拟机中模拟添加了硬盘设备后就应该能看到抽象成的硬盘设备文件了。按照前文讲解的udev服务命名规则，第二个被识别的SCSI设备应该会被保存为/dev/sdb，这个就是硬盘设备文件了。但在开始使用该硬盘之前还需要进行分区操作，例如从中取出一个2GB的分区设备以供后面的操作使用。</p><h4 id="fdisk命令分区"><a class="markdownIt-Anchor" href="#fdisk命令分区"></a> fdisk命令（分区）</h4><p>在Linux系统中，管理硬盘设备最常用的方法就当属fdisk命令了。fdisk命令用于管理磁盘分区，格式为</p><pre><code class="highlight plaintext">fdisk [磁盘名称]</code></pre><p>它提供了集添加、删除、转换分区等功能于一身的“一站式分区服务”。不过与前面讲解的直接写到命令后面的参数不同，这条命令的参数是交互式的，因此在管理硬盘设备时特别方便，可以根据需求动态调整。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>m</td><td>查看全部可用的参数</td></tr><tr><td>n</td><td>添加新的分区</td></tr><tr><td>d</td><td>删除某个分区信息</td></tr><tr><td>l</td><td>列出所有可用的分区类型</td></tr><tr><td>t</td><td>改变某个分区的类型</td></tr><tr><td>p</td><td>查看分区表信息</td></tr><tr><td>w</td><td>保存并退出</td></tr><tr><td>q</td><td>不保存直接退出</td></tr></tbody></table><ul><li>第1步：我们首先使用fdisk命令来尝试管理/dev/sdb硬盘设备<br /><img src="image/-19.png" alt="-19.png" /></li><li>第2步：输入参数n尝试添加新的分区。系统会要求您是选择继续输入参数p来创建主分区，还是输入参数e来创建扩展分区。这里输入参数p来创建一个主分区：<br /><img src="image/-20.png" alt="-20.png" /></li><li>第3步：在确认创建一个主分区后，系统要求您先输入主分区的编号。我们在前文得知，主分区的编号范围是1～4，因此这里输入默认的1就可以了。接下来系统会提示定义起始的扇区位置，这不需要改动，我们敲击回车键保留默认设置即可，系统会自动计算出最靠前的空闲扇区的位置。最后，系统会要求定义分区的结束扇区位置，这其实就是要去定义整个分区的大小是多少。我们不用去计算扇区的个数，只需要输入+2G即可创建出一个容量为2GB的硬盘分区。<br /><img src="image/-21.png" alt="-21.png" /></li><li>第4步：再次使用参数p来查看硬盘设备中的分区信息。果然就能看到一个名称为/dev/sdb1、起始扇区位置为2048、结束扇区位置为4196351的主分区了。这时候千万不要直接关闭窗口，而应该敲击参数w后回车，这样分区信息才是真正的写入成功啦。<br /><img src="image/-22.png" alt="-22.png" /></li><li>第5步：在上述步骤执行完毕之后，Linux系统会自动把这个硬盘主分区抽象成/dev/sdb1设备文件。我们可以使用file命令查看该文件的属性，但是刘遄老师在讲课和工作中发现，有些时候系统并没有自动把分区信息同步给Linux内核，而且这种情况似乎还比较常见（但不能算作是严重的bug）。我们可以输入partprobe命令手动将分区信息同步到内核，而且一般推荐连续两次执行该命令，效果会更好。如果使用这个命令都无法解决问题，那么就重启计算机吧，这个杀手锏百试百灵，一定会有用的。<br /><img src="image/-23.png" alt="-23.png" /></li></ul><h4 id="mkfs格式化"><a class="markdownIt-Anchor" href="#mkfs格式化"></a> mkfs（格式化）</h4><p>如果硬件存储设备没有进行格式化，则Linux系统无法得知怎么在其上写入数据。因此，在对存储设备进行分区后还需要进行格式化操作。在Linux系统中用于格式化操作的命令是mkfs。这条命令很有意思，因为在Shell终端中输入mkfs名后再敲击两下用于补齐命令的Tab键，会有如下所示的效果：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# mkfsmkfs mkfs.cramfs mkfs.ext3 mkfs.fat mkfs.msdos mkfs.xfsmkfs.btrfs mkfs.ext2 mkfs.ext4 mkfs.minix mkfs.vfat</code></pre><p>对！这个mkfs命令很贴心地把常用的文件系统名称用后缀的方式保存成了多个命令文件，用起来也非常简单—mkfs.文件类型名称。例如要格式分区为XFS的文件系统，则命令应为mkfs.xfs /dev/sdb1。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# mkfs.xfs /dev/sdb1meta-data=/dev/sdb1 isize=256 agcount=4, agsize=131072 blks = sectsz=512 attr=2, projid32bit=1 = crc=0data = bsize=4096 blocks=524288, imaxpct=25 = sunit=0 swidth=0 blksnaming =version 2 bsize=4096 ascii-ci=0 ftype=0log =internal log bsize=4096 blocks=2560, version=2 = sectsz=512 sunit=0 blks, lazy-count=1realtime =none extsz=4096 blocks=0, rtextents=0</code></pre><p>终于完成了存储设备的分区和格式化操作，接下来就是要来挂载并使用存储设备了。与之相关的步骤也非常简单：首先是创建一个用于挂载设备的挂载点目录；然后使用mount命令将存储设备与挂载点进行关联；最后使用df -h命令来查看挂载状态和硬盘使用量信息。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# mkdir /newFS[root@linuxprobe ~]# mount /dev/sdb1 /newFS/[root@linuxprobe ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/mapper/rhel-root 18G 3.5G 15G 20% /devtmpfs 905M 0 905M 0% /devtmpfs 914M 140K 914M 1% /dev/shmtmpfs 914M 8.8M 905M 1% /runtmpfs 914M 0 914M 0% /sys/fs/cgroup/dev/sr0 3.5G 3.5G 0 100% /media/cdrom/dev/sda1 497M 119M 379M 24% /boot/dev/sdb1 2.0G 33M 2.0G 2% /newFS</code></pre><h4 id="du查看文件数据占用量"><a class="markdownIt-Anchor" href="#du查看文件数据占用量"></a> du（查看文件数据占用量）</h4><p>既然存储设备已经顺利挂载，接下来就可以尝试通过挂载点目录向存储设备中写入文件了。在写入文件之前，先介绍一个用于查看文件数据占用量的du命令，其格式为</p><pre><code class="highlight plaintext">du [选项] [文件]</code></pre><p>简单来说，该命令就是用来查看一个或多个文件占用了多大的硬盘空间。我们还可以使用</p><pre><code class="highlight plaintext">du -sh /*</code></pre><p>命令来查看在Linux系统根目录下所有一级目录分别占用的空间大小。下面，我们先从某些目录中复制过来一批文件，然后查看这些文件总共占用了多大的容量：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# cp -rf /etc/* /newFS/[root@linuxprobe ~]# ls /newFS/abrt hosts pulseadjtime hosts.allow purplealiases hosts.deny qemu-gaaliases.db hp qemu-kvmalsa idmapd.conf radvd.confalternatives init.d rc0.danacrontab inittab rc1.d………………省略部分输入信息………………[root@linuxprobe ~]# du -sh /newFS/33M /newFS/</code></pre><blockquote><p>细心的读者一定还记得，前面在讲解mount命令时提到，使用mount命令挂载的设备文件会在系统下一次重启的时候失效。如果想让这个设备文件的挂载永久有效，则需要把挂载的信息写入到配置文件/etc/fstab中</p></blockquote><h3 id="添加交换分区"><a class="markdownIt-Anchor" href="#添加交换分区"></a> 添加交换分区</h3><p>SWAP（交换）分区是一种通过在硬盘中预先划分一定的空间，然后将把内存中暂时不常用的数据临时存放到硬盘中，以便腾出物理内存空间让更活跃的程序服务来使用的技术，其设计目的是为了解决真实物理内存不足的问题。但由于交换分区毕竟是通过硬盘设备读写数据的，速度肯定要比物理内存慢，所以只有当真实的物理内存耗尽后才会调用交换分区的资源。</p><p>交换分区的创建过程与前文讲到的挂载并使用存储设备的过程非常相似。在对/dev/sdb存储设备进行分区操作前，有必要先说一下交换分区的划分建议：在生产环境中，交换分区的大小一般为真实物理内存的1.5～2倍，为了让大家更明显地感受交换分区空间的变化，这里取出一个大小为5GB的主分区作为交换分区资源。在分区创建完毕后保存并退出即可：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# fdisk /dev/sdbWelcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Device does not contain a recognized partition tableBuilding a new DOS disklabel with disk identifier 0xb3d27ce1.Command (m for help): nPartition type:p primary (1 primary, 0 extended, 3 free)e extendedSelect (default p): pPartition number (2-4, default 2): First sector (4196352-41943039, default 4196352): 此处敲击回车Using default value 4196352Last sector, +sectors or +size&#123;K,M,G&#125; (4196352-41943039, default 41943039): +5GPartition 2 of type Linux and of size 5 GiB is setCommand (m for help): pDisk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0xb0ced57f Device Boot Start End Blocks Id System/dev/sdb1 2048 4196351 2097152 83 Linux/dev/sdb2 4196352 14682111 5242880 83 LinuxCommand (m for help): wThe partition table has been altered!Calling ioctl() to re-read partition table.WARNING: Re-reading the partition table failed with error 16: Device or resource busy.The kernel still uses the old table. The new table will be used atthe next reboot or after you run partprobe(8) or kpartx(8)Syncing disks.</code></pre><p>使用SWAP分区专用的格式化命令<strong>mkswap</strong>，对新建的主分区进行格式化操作：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# mkswap /dev/sdb2Setting up swapspace version 1, size = 5242876 KiBno label, UUID=2972f9cb-17f0-4113-84c6-c64b97c40c75</code></pre><p><strong>使用swapon命令把准备好的SWAP分区设备正式挂载到系统中</strong>。我们可以使用free -m命令查看交换分区的大小变化（由2047MB增加到7167MB）：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# free -mtotal used free shared buffers cachedMem: 1483 782 701 9 0 254-/+ buffers/cache: 526 957Swap: 2047 0 2047[root@linuxprobe ~]# swapon /dev/sdb2[root@linuxprobe ~]# free -mtotal used free shared buffers cachedMem: 1483 785 697 9 0 254-/+ buffers/cache: 530 953Swap: 7167 0 7167</code></pre><p>为了能够让新的交换分区设备在重启后依然生效，需要按照下面的格式将相关信息写入到配置文件中，并记得保存：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# vim /etc/fstab## /etc/fstab# Created by anaconda on Wed May 4 19:26:23 2017## Accessible filesystems, by reference, are maintained under &#x27;/dev/disk&#x27;# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info#/dev/mapper/rhel-root / xfs defaults 1 1UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b /boot xfs defaults 1 2/dev/mapper/rhel-swap swap swap defaults 0 0/dev/cdrom /media/cdrom iso9660 defaults 0 0 /dev/sdb1 /newFS xfs defaults 0 0 /dev/sdb2 swap swap defaults 0 0</code></pre><h2 id="vivim"><a class="markdownIt-Anchor" href="#vivim"></a> vi/vim</h2><p>Vim之所以能得到广大厂商与用户的认可，原因在于Vim编辑器中设置了三种模式—命令模式、末行模式和编辑模式，每种模式分别又支持多种不同的命令快捷键，这大大提高了工作效率，而且用户在习惯之后也会觉得相当顺手。要想高效率地操作文本，就必须先搞清这三种模式的操作区别以及模式之间的切换方法</p><ul><li><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</li><li><strong>输入模式</strong>：正常的文本录入。</li><li><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</li></ul><p><img src="image/-24.png" alt="-24.png" /></p><p>在每次运行Vim编辑器时，<strong>默认进入命令模式</strong>，此时需要先切换到输入模式后再进行文档编写工作，而每次在<strong>编写完文档后需要先返回命令模式，然后再进入末行模式，执行文档的保存或退出操作</strong>。</p><p><strong>命令模式</strong>中最常用的一些命令</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>dd</td><td>删除（剪切）光标所在整行</td></tr><tr><td>5dd</td><td>删除（剪切）从光标处开始的5行</td></tr><tr><td>yy</td><td>复制光标所在整行</td></tr><tr><td>5yy</td><td>复制从光标处开始的5行</td></tr><tr><td>n</td><td><strong>显示搜索命令定位到的下一个字符串</strong></td></tr><tr><td>N</td><td>显示搜索命令定位到的上一个字符串</td></tr><tr><td>u</td><td>撤销上一步的操作</td></tr><tr><td>p</td><td>将之前删除（dd）或复制（yy）过的数据粘贴到光标后面</td></tr><tr><td>i</td><td><strong>进入输入模式</strong></td></tr></tbody></table><p><strong>末行模式</strong>主要用于保存或退出文件，以及设置Vim编辑器的工作环境，还可以让用户执行外部的Linux命令或跳转到所编写文档的特定行数。要想切换到末行模式，在命令模式中输入一个冒号就可以了</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>:w</td><td>保存</td></tr><tr><td>:q</td><td>退出</td></tr><tr><td>:q!</td><td>强制退出（放弃对文档的修改内容）</td></tr><tr><td>:wq!</td><td>强制保存退出</td></tr><tr><td>:e!</td><td>放弃更改</td></tr><tr><td>:set nu</td><td>显示行号</td></tr><tr><td>:set nonu</td><td>不显示行号</td></tr><tr><td>:命令</td><td>执行该命令</td></tr><tr><td>:整数</td><td>跳转到该行</td></tr><tr><td>😒/one/two</td><td>将当前光标所在行的第一个one替换成two</td></tr><tr><td>😒/one/two/g</td><td>将当前光标所在行的所有one替换成two</td></tr><tr><td>:%s/one/two/g</td><td>将全文中的所有one替换成two</td></tr><tr><td>?字符串</td><td>在文本中从下至上搜索该字符串,按Enter后用n向下搜索</td></tr><tr><td>/字符串</td><td><strong>在文本中从上至下搜索该字符串，按Enter后用n向下搜索</strong></td></tr></tbody></table><h2 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h2><p>通常，现在的操作系统都支持多任务，意味着操作系统（给用户）造成了一种假象，(让用户觉得) 它同时能够做多件事情，事实上，它是快速地轮换执行这些任务的。Linux 内核通过使用进程，来 管理多任务。通过进程，Linux 安排不同的程序等待使用 CPU。</p><p>有时候，计算机变得呆滞，运行缓慢，或者一个应用程序停止响应。在这一章中，我们将看一些 可用的命令行工具，这些工具帮助我们查看程序的执行状态，以及怎样终止行为不当的进程。</p><p><strong>进程是怎样工作的</strong></p><ul><li>当系统启动的时候，内核先把一些它自己的程序初始化为进程，然后运行一个叫做 init 的程序。init， 依次地，再运行一系列的称为 init 脚本的 shell 脚本（位于/etc），它们可以启动所有的系统服务。 其中许多系统服务以守护（daemon）程序的形式实现，守护程序仅在后台运行，没有任何用户接口。 这样，即使我们没有登录系统，至少系统也在忙于执行一些例行事务。</li><li>一个程序可以发动另一个程序，这个事实在进程方案中，表述为一个父进程创建了一个子进程。</li><li>内核维护每个进程的信息，以此来保持事情有序。例如，系统分配给每个进程一个数字，这个数字叫做 进程 ID 或 PID。PID 号按升序分配，init 进程的 PID 总是1。内核也对分配给每个进程的内存进行跟踪。 像文件一样，进程也有所有者和用户 ID，有效用户 ID，等等。</li></ul><h3 id="ps-查看进程"><a class="markdownIt-Anchor" href="#ps-查看进程"></a> ps 查看进程</h3><p>ps命令用于<strong>查看系统中的进程状态</strong>，格式为</p><pre><code class="highlight plaintext">ps [参数]</code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中，有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该 状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><p>当执行ps aux命令后通常会看到如表所示的进程状态，表中只是列举了部分输出值，而且正常的输出值中不包括中文注释。</p><table><thead><tr><th>USER</th><th>PID</th><th>%CPU</th><th>%MEM</th><th>VSZ</th><th>RSS</th><th>TTY</th><th>STAT</th><th>START</th><th>TIME</th><th>COMMAND</th></tr></thead><tbody><tr><td>进程的所有者</td><td>进程ID号</td><td>运算器占用率</td><td>内存占用率</td><td>虚拟内存使用量(单位是KB)</td><td>占用的固定内存量(单位是KB)</td><td>所在终端</td><td>进程状态</td><td>被启动的时间</td><td>实际使用CPU的时间</td><td>命令名称与参数</td></tr><tr><td>root</td><td>1</td><td>0.0</td><td>0.4</td><td>53684</td><td>7628</td><td>?</td><td>Ss</td><td>07:22</td><td>0:02</td><td>/usr/lib/systemd/systemd</td></tr><tr><td>root</td><td>2</td><td>0.0</td><td>0.0</td><td>0</td><td>0</td><td>?</td><td>S</td><td>07:22</td><td>0:00</td><td>[kthreadd]</td></tr><tr><td>root</td><td>3</td><td>0.0</td><td>0.0</td><td>0</td><td>0</td><td>?</td><td>S</td><td>07:22</td><td>0:00</td><td>[ksoftirqd/0]</td></tr><tr><td>root</td><td>5</td><td>0.0</td><td>0.0</td><td>0</td><td>0</td><td>?</td><td>S&lt;</td><td>07:22</td><td>0:00</td><td>[kworker/0:0H]</td></tr><tr><td>root</td><td>7</td><td>0.0</td><td>0.0</td><td>0</td><td>0</td><td>?</td><td>S</td><td>07:22</td><td>0:00</td><td>[migration/0]</td></tr></tbody></table><blockquote><p>如前面所提到的，在Linux系统中的命令参数有长短格式之分，<strong>长格式和长格式之间不能合并</strong>，<strong>长格式和短格式之间也不能合并</strong>，但<strong>短格式和短格式之间是可以合并</strong>的，<strong>合并后仅保留一个-（减号）即可</strong>。另外ps命令可<strong>允许参数不加减号（-）</strong>，因此可直接写成ps aux的样子</p></blockquote><table><thead><tr><th>状态</th><th>意义</th></tr></thead><tbody><tr><td>R</td><td>运行。这意味着，进程正在运行或准备运行。</td></tr><tr><td>S</td><td>正在睡眠。 进程没有运行，而是，正在等待一个事件， 比如说，一个按键或者网络数据包。</td></tr><tr><td>D</td><td>不可中断睡眠。进程正在等待 I/O，比方说，一个磁盘驱动器的 I/O。</td></tr><tr><td>T</td><td>已停止. 已经指示进程停止运行。稍后介绍更多。</td></tr><tr><td>Z</td><td>一个死进程或“僵尸”进程。这是一个已经终止的子进程，但是它的父进程还没有清空它。 （父进程没有把子进程从进程表中删除）</td></tr><tr><td>&lt;</td><td>一个高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。 进程的这种属性叫做 niceness。具有高优先级的进程据说是不好的（less nice）， 因为它占用了比较多的 CPU 时间，这样就给其它进程留下很少时间。</td></tr><tr><td>N</td><td>低优先级进程。 一个低优先级进程（一个“好”进程）只有当其它高优先级进程执行之后，才会得到处理器时间。</td></tr></tbody></table><h3 id="top-显示任务"><a class="markdownIt-Anchor" href="#top-显示任务"></a> top 显示任务</h3><p>top命令用于<strong>动态地监视进程活动与系统负载等信息</strong>，其格式为</p><pre><code class="highlight plaintext">top</code></pre><ul><li>M：可以给进程占用内存大小排序</li><li>h：显示程序的帮助屏幕</li><li>q：退出top程序</li><li>x：高亮排序列</li><li>shift+&lt;或者&gt;：切换排序列</li><li>i：排除僵死和睡眠的进程</li></ul><p>top命令相当强大，能够动态地查看系统运维状态，完全将它看作Linux中的“强化版的Windows任务管理器”。top命令的运行界面如图所示</p><p><img src="image/-25.png" alt="-25.png" /></p><p>top命令执行结果的前5行为系统整体的统计信息，其所代表的含义如下</p><blockquote><p>第1行：系统时间、运行时间、登录终端数、系统负载（三个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低）。</p></blockquote><blockquote><p>第2行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。</p></blockquote><blockquote><p>第3行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。其中数据均为CPU数据并以百分比格式显示，例如“97.1 id”意味着有97.1%的CPU处理器资源处于空闲。</p></blockquote><blockquote><p>第4行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。</p></blockquote><blockquote><p>第5行：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、已被提前加载的内存量。</p></blockquote><table><thead><tr><th>行号</th><th>字段</th><th>意义</th></tr></thead><tbody><tr><td>1</td><td>top</td><td>程序名。</td></tr><tr><td></td><td>14:59:20</td><td>当前时间。</td></tr><tr><td></td><td>up 6:30</td><td>这是正常运行时间。它是计算机从上次启动到现在所运行的时间。 在这个例子里，系统已经运行了六个半小时。</td></tr><tr><td></td><td>2users</td><td>有两个用户登录系统。</td></tr><tr><td></td><td>load average:</td><td>加载平均值是指，等待运行的进程数目，也就是说，处于运行状态的进程个数， 这些进程共享 CPU。展示了三个数值，每个数值对应不同的时间周期。第一个是最后60秒的平均值， 下一个是前5分钟的平均值，最后一个是前15分钟的平均值。若平均值低于1.0，则指示计算机 工作不忙碌。</td></tr><tr><td>2</td><td>Tasks:</td><td>总结了进程数目和各种进程状态。</td></tr><tr><td>3</td><td>Cpu(s):</td><td>这一行描述了 CPU 正在执行的进程的特性。</td></tr><tr><td></td><td>0.7%us</td><td>0.7% of the CPU is being used for user processes. 这意味着进程在内核之外。</td></tr><tr><td></td><td>1.0%sy</td><td>1.0%的 CPU 时间被用于系统（内核）进程。</td></tr><tr><td></td><td>0.0%ni</td><td>0.0%的 CPU 时间被用于&quot;nice&quot;（低优先级）进程。</td></tr><tr><td></td><td>98.3%id</td><td>98.3%的 CPU 时间是空闲的。</td></tr><tr><td></td><td>0.0%wa</td><td>0.0%的 CPU 时间来等待 I/O。</td></tr><tr><td>4</td><td>Mem:</td><td>展示物理内存的使用情况。</td></tr><tr><td>5</td><td>Swap:</td><td>展示交换分区（虚拟内存）的使用情况。</td></tr></tbody></table><h3 id="进程相关命令"><a class="markdownIt-Anchor" href="#进程相关命令"></a> 进程相关命令</h3><h4 id="停止暂停"><a class="markdownIt-Anchor" href="#停止暂停"></a> 停止/暂停</h4><p>linux中我们正在运行的程序可以通过下列命令停止或暂停</p><ul><li>ctrl+c：中断/停止一个程序</li><li>ctrl+z：停止一个进程，而没有终止它。这样会把一个前台进程移到后台等待</li></ul><h4 id="放置到后台执行"><a class="markdownIt-Anchor" href="#放置到后台执行"></a> 放置到后台执行</h4><p>比方说，我们想让 shell 提示符返回，却没有终止 xlogo 程序。为达到这个目的，我们把 这个程序放到后台执行。把终端看作是一个有前台（表层放置可见的事物，像 shell 提示符） 和后台（表层之下放置隐藏的事物）（的设备）。</p><ul><li>启动一个程序，<strong>加上”&amp;”字符</strong>，让它<strong>立即在后台</strong> 运行：</li></ul><pre><code class="highlight plaintext">[me@linuxbox ~]$ xlogo &amp;[1] 28236[me@linuxbox ~]$</code></pre><ul><li>启动一个程序，也可以使用<strong>ctrl+z</strong>让其在后台运行：</li></ul><pre><code class="highlight plaintext">[me@linuxbox ~]$ xlogo[1]+ Stopped                 xlogo[me@linuxbox ~]$</code></pre><p>执行命令之后，这个 xlogo 窗口出现，并且 shell 提示符返回，同时打印一些有趣的数字。 这条信息是 shell 特性的一部分，叫做工作控制。通过这条信息，shell 告诉我们，已经启动了 工作号为1（“［1］”），PID 为28236的程序。如果我们运行 ps 命令，可以看到我们的进程：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ ps  PID TTY         TIME   CMD10603 pts/1   00:00:00   bash28236 pts/1   00:00:00   xlogo28239 pts/1   00:00:00   ps</code></pre><h4 id="jobs-显示活跃任务"><a class="markdownIt-Anchor" href="#jobs-显示活跃任务"></a> jobs 显示活跃任务</h4><p>工作控制，这个 shell 功能可以列出从终端中启动的任务。执行 jobs 命令，我们可以看到这个输出列表：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ jobs[1]+ Running            xlogo &amp;</code></pre><blockquote><p>结果显示我们有一个任务，编号为“1”，它正在运行，并且这个任务的命令是 xlogo ＆</p></blockquote><h4 id="fgbg"><a class="markdownIt-Anchor" href="#fgbg"></a> fg/bg</h4><p><strong>fg 把一个任务放到前台执行</strong></p><p>一个在后台运行的进程对一切来自键盘的输入都免疫，也不能用 Ctrl-c 来中断它。使用 fg 命令，让一个进程返回前台执行：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ jobs[1]+ Running        xlogo &amp;[me@linuxbox ~]$ fg %1xlogo</code></pre><p><strong>bg 把一个任务放到后台执行</strong></p><p>停止 xlogo 程序之后，通过调整 xlogo 的窗口大小，我们可以证实这个程序已经停止了。 它看起来像死掉了一样。使用 fg 命令，可以恢复程序到前台运行，或者用 bg 命令把程序移到后台。</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ bg %1[1]+ xlogo &amp;[me@linuxbox ~]$</code></pre><h4 id="pidof"><a class="markdownIt-Anchor" href="#pidof"></a> pidof</h4><p>pidof命令用于查询某个指定服务进程的PID值，格式为</p><pre><code class="highlight plaintext">pidof [参数] [服务名称]</code></pre><p>每个进程的进程号码值（PID）是唯一的，因此可以通过PID来区分不同的进程。例如，可以使用如下命令来查询本机上sshd服务程序的PID：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# pidof sshd2156</code></pre><h4 id="kill-killall"><a class="markdownIt-Anchor" href="#kill-killall"></a> kill /killall</h4><p><strong>kill命令</strong>用于终止某个指定PID的服务进程，格式为</p><pre><code class="highlight plaintext">kill [参数] [进程PID]</code></pre><p>参数：</p><table><thead><tr><th>编号</th><th>名字</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>HUP</td><td>挂起。这是美好往昔的痕迹，那时候终端机通过电话线和调制解调器连接到 远端的计算机。这个信号被用来告诉程序，控制的终端机已经“挂起”。 通过关闭一个终端会话，可以说明这个信号的作用。发送这个信号到终端机上的前台程序，程序会终止。许多守护进程也使用这个信号，来重新初始化。这意味着，当发送这个信号到一个守护进程后， 这个进程会重新启动，并且重新读取它的配置文件。Apache 网络服务器守护进程就是一个例子。</td></tr><tr><td>2</td><td>INT</td><td>中断。实现和 Ctrl-c 一样的功能，由终端发送。通常，它会终止一个程序。</td></tr><tr><td>3</td><td>QUIT</td><td>退出</td></tr><tr><td>9</td><td>KILL</td><td>杀死。这个信号很特别。鉴于进程可能会选择不同的方式，来处理发送给它的 信号，其中也包含忽略信号，这样呢，从不发送 Kill 信号到目标进程。而是内核立即终止 这个进程。当一个进程以这种方式终止的时候，它没有机会去做些“清理”工作，或者是保存劳动成果。 因为这个原因，把 KILL 信号看作杀手锏，当其它终止信号失败后，再使用它。</td></tr><tr><td>11</td><td>SEGV</td><td>段错误。如果一个程序非法使用内存，就会发送这个信号。也就是说， 程序试图写入内存，而这个内存空间是不允许此程序写入的。</td></tr><tr><td>15</td><td>TERM</td><td>终止。这是 kill 命令发送的默认信号。如果程序仍然“活着”，可以接受信号，那么 这个信号终止。</td></tr><tr><td>18</td><td>CONT</td><td>继续。在停止一段时间后，进程恢复运行。</td></tr><tr><td>19</td><td>STOP</td><td>停止。这个信号导致进程停止运行，而没有终止。像 KILL 信号，它不被 发送到目标进程，因此它不能被忽略。</td></tr><tr><td>20</td><td>TSTP</td><td>终端停止。当按下 Ctrl-z 组合键后，终端发送这个信号。不像 STOP 信号， TSTP 信号由目标进程接收，且可能被忽略。</td></tr><tr><td>28</td><td>WINCH</td><td>改变窗口大小。当改变窗口大小时，系统会发送这个信号。 一些程序，像 top 和 less 程序会响应这个信号，按照新窗口的尺寸，刷新显示的内容。</td></tr></tbody></table><blockquote><p>也可以用 jobspec（例如，“％1”）来代替 PID</p></blockquote><p>接下来，我们使用kill命令把上面用pidof命令查询到的PID所代表的进程终止掉，其命令如下所示。这种操作的效果等同于强制停止sshd服务</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# kill 2156</code></pre><hr /><p><strong>killall命令</strong>用于终止某个指定名称的服务所对应的全部进程，或者通过 killall 命令，给匹配特定程序或用户名的多个进程发送信号，格式为：</p><pre><code class="highlight plaintext">killall [参数] [服务名称]</code></pre><p>通常来讲，复杂软件的服务程序会有多个进程协同为用户提供服务，如果逐个去结束这些进程会比较麻烦，此时可以使用killall命令来批量结束某个服务程序带有的全部进程。下面以httpd服务程序为例，来结束其全部进程</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# pidof httpd13581 13580 13579 13578 13577 13576[root@linuxprobe ~]# killall httpd[root@linuxprobe ~]# pidof httpd[root@linuxprobe ~]#</code></pre><blockquote><p>如果我们在系统终端中执行一个命令后想立即停止它，可以同时<strong>按下Ctrl + C组合键</strong>（生产环境中比较常用的一个快捷键），这样将<strong>立即终止该命令的进程</strong>。或者，如果有些命令在执行时不断地在屏幕上输出信息，影响到后续命令的输入，则可以在执行命令时在末尾<strong>添加上一个&amp;符号</strong>，这样<strong>命令将进入系统后台</strong>来执行</p></blockquote><p>为了说明情况，我们将启动一对 xlogo 程序的实例，然后再终止它们：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ xlogo &amp;[1] 18801[me@linuxbox ~]$ xlogo &amp;[2] 18802[me@linuxbox ~]$ killall xlogo[1]- Terminated                xlogo[2]+ Terminated                xlogo</code></pre><h2 id="shell环境变量"><a class="markdownIt-Anchor" href="#shell环境变量"></a> shell环境变量</h2><p>正如我们之前所讨论到的，shell 在 shell 会话中维护着大量的信息，这些信息称为 (shell) 环境。 存储在 shell 环境中的数据被程序用来确定配置属性。然而大多数程序用配置文件来存储程序设置， 某些程序也会查找存储在 shell 环境中的数值来调整他们的行为。知道了这些，我们就可以用 shell 环境 来自定制 shell 经历。</p><p>shell 在环境中存储了两种基本类型的数据，虽然对于 bash 来说，很大程度上这些类型是不可 辨别的。它们是<strong>环境变量</strong>和 <strong>shell 变量</strong>。Shell 变量是由 bash 存放的少量数据，而剩下的基本上 都是环境变量。除了变量，shell 也存储了一些可编程的数据，命名为别名和 shell 函数。</p><h3 id="查看环境变量"><a class="markdownIt-Anchor" href="#查看环境变量"></a> 查看环境变量</h3><p>我们既可以<strong>用 bash 的内部命令 set</strong>，或者是 <strong>printenv 程序</strong>来查看什么存储在环境当中。set 命令可以 显示 shell 和环境变量两者，而 printenv 只是显示环境变量。</p><p>因为环境变量内容列表相当长，所以最好 把每个命令的输出结果管道到 less 命令：</p><pre><code class="highlight plaintext">$ printenv | less</code></pre><p>执行以上命令之后，我们应该能得到类似以下内容：</p><pre><code class="highlight plaintext">KDE_MULTIHEAD=falseSSH_AGENT_PID=6666HOSTNAME=linuxboxGPG_AGENT_INFO=/tmp/gpg-PdOt7g/S.gpg-agent:6689:1SHELL=/bin/bashTERM=xtermXDG_MENU_PREFIX=kde-HISTSIZE=1000XDG_SESSION_COOKIE=6d7b05c65846c3eaf3101b0046bd2b00-1208521990.996705-1177056199GTK2_RC_FILES=/etc/gtk-2.0/gtkrc:/home/me/.gtkrc-2.0:/home/me/.kde/share/config/gtkrc-2.0GTK_RC_FILES=/etc/gtk/gtkrc:/home/me/.gtkrc:/home/me/.kde/share/config/gtkrcGS_LIB=/home/me/.fontsWINDOWID=29360136QTDIR=/usr/lib/qt-3.3QTINC=/usr/lib/qt-3.3/includeKDE_FULL_SESSION=trueUSER=meLS_COLORS=no=00:fi=00:di=00;34:ln=00;36:pi=40;33:so=00;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=00;32:\*.cmd=00;32:\*.exe:</code></pre><p>我们所看到的是环境变量及其数值的列表。例如，我们看到一个叫做 USER 的变量，这个变量值是 “me”。printenv 命令也能够列出特定变量的数值：</p><pre><code class="highlight plaintext">$ printenv USERme</code></pre><p>当使用没有带选项和参数的 set 命令时，shell 和环境变量二者都会显示，同时也会显示定义的 shell 函数。不同于 printenv 命令，set 命令的输出结果很礼貌地按照字母顺序排列：</p><pre><code class="highlight plaintext">$ set | less</code></pre><p>也可以通过 echo 命令来查看一个变量的内容，像这样：</p><pre><code class="highlight plaintext">$ echo $HOME/home/me</code></pre><p>如果 shell 环境中的一个成员既不可用 set 命令也不可用 printenv 命令显示，则这个变量是别名。 输入不带参数的 alias 命令来查看它们:</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ aliasalias l.=&#x27;ls -d .* --color=tty&#x27;alias ll=&#x27;ls -l --color=tty&#x27;alias ls=&#x27;ls --color=tty&#x27;alias vi=&#x27;vim&#x27;alias which=&#x27;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&#x27;</code></pre><hr /><p><strong>一些常见的环境变量</strong></p><table><thead><tr><th>变量</th><th>内容</th></tr></thead><tbody><tr><td>DISPLAY</td><td>如果你正在运行图形界面环境，那么这个变量就是你显示器的名字。通常，它是 “:0”， 意思是由 X 产生的第一个显示器。</td></tr><tr><td>EDITOR</td><td>文本编辑器的名字。</td></tr><tr><td>SHELL</td><td>shell 程序的名字。</td></tr><tr><td>HOME</td><td>用户家目录。</td></tr><tr><td>LANG</td><td>定义了字符集以及语言编码方式。</td></tr><tr><td>OLD_PWD</td><td>先前的工作目录。</td></tr><tr><td>PAGER</td><td>页输出程序的名字。这经常设置为/usr/bin/less。</td></tr><tr><td>PATH</td><td>由冒号分开的目录列表，当你输入可执行程序名后，会搜索这个目录列表。</td></tr><tr><td>PS1</td><td>Prompt String 1. 这个定义了你的 shell 提示符的内容。随后我们可以看到，这个变量 内容可以全面地定制。</td></tr><tr><td>PWD</td><td>当前工作目录。</td></tr><tr><td>TERM</td><td>终端类型名。类 Unix 的系统支持许多终端协议；这个变量设置你的终端仿真器所用的协议。</td></tr><tr><td>TZ</td><td>指定你所在的时区。大多数类 Unix 的系统按照协调时间时 (UTC) 来维护计算机内部的时钟 ，然后应用一个由这个变量指定的偏差来显示本地时间。</td></tr><tr><td>USER</td><td>你的用户名</td></tr></tbody></table><h3 id="建立环境变量"><a class="markdownIt-Anchor" href="#建立环境变量"></a> 建立环境变量</h3><p>当我们登录系统后，启动 bash 程序，并且会读取一系列称为启动文件的配置脚本， 这些文件定义了默认的可供所有用户共享的 shell 环境。然后是读取更多位于我们自己家目录中 的启动文件，这些启动文件定义了用户个人的 shell 环境。精确的启动顺序依赖于要运行的 shell 会话 类型。有两种 shell 会话类型：一个是登录 shell 会话，另一个是非登录 shell 会话。登录 shell 会话会提示用户输入用户名和密码；例如，我们启动一个虚拟控制台会话。当我们在 GUI 模式下 运行终端会话时，非登录 shell 会话会出现。</p><p>登录 shell 会读取一个或多个启动文件，正如表所示：</p><table><thead><tr><th>文件</th><th>内容</th></tr></thead><tbody><tr><td>/etc/profile</td><td>应用于所有用户的全局配置脚本。</td></tr><tr><td>~/.bash_profile</td><td>用户私人的启动文件。可以用来扩展或重写全局配置脚本中的设置。</td></tr><tr><td>~/.bash_login</td><td>如果文件 ~/.bash_profile 没有找到，bash 会尝试读取这个脚本。</td></tr><tr><td>~/.profile</td><td>如果文件 ~/.bash_profile 或文件 ~/.bash_login 都没有找到，bash 会试图读取这个文件。 这是基于 Debian 发行版的默认设置，比方说 Ubuntu。</td></tr></tbody></table><p>非登录 shell 会话会读取以下启动文件：</p><table><thead><tr><th>文件</th><th>内容</th></tr></thead><tbody><tr><td>/etc/bash.bashrc</td><td>应用于所有用户的全局配置文件。</td></tr><tr><td>~/.bashrc</td><td>用户私有的启动文件。可以用来扩展或重写全局配置脚本中的设置。</td></tr></tbody></table><p>除了读取以上启动文件之外，非登录 shell 会话也会继承它们父进程的环境设置，通常是一个登录 shell。</p><p>在普通用户看来，文件 ~/.bashrc 可能是最重要的启动文件，因为它几乎总是被读取。非登录 shell 默认 会读取它，并且大多数登录 shell 的启动文件会以能读取 ~/.bashrc 文件的方式来书写。</p><hr /><p><strong>启动文件的内容</strong></p><p>如果我们看一下典型的 .bash_profile 文件（来自于 CentOS 4 系统），它看起来像这样：</p><pre><code class="highlight plaintext"># .bash_profile# Get the aliases and functions#下列if的意思是如果.bashrc文件存在，则读取该文件if [ -f ~/.bashrc ]; then. ~/.bashrcfi# User specific environment and startup programsPATH=$PATH:$HOME/binexport PATH</code></pre><pre><code class="highlight plaintext">If the file ~/.bashrc exists, thenread the ~/.bashrc file.</code></pre><p>我们可以看到这一小段代码就是一个登录 shell 得到 .bashrc 文件内容的方式。在我们启动文件中， 下一件有趣的事与 PATH 变量有关系。</p><p>曾经是否感到迷惑 shell 是怎样知道到哪里找到我们在命令行中输入的命令的？</p><p>例如，当我们输入 ls 后， shell 不会查找整个计算机系统，来找到 /bin/ls（ls 命令的绝对路径名），而是，它查找一个目录列表， <strong>这些目录包含在 PATH 变量中</strong>。</p><p>PATH 变量经常（但不总是，依赖于发行版）<strong>在 /etc/profile 启动文件中设置</strong>，通过这些代码：</p><pre><code class="highlight plaintext">PATH=$PATH:$HOME/bin</code></pre><p>修改 PATH 变量，添加目录 $HOME/bin 到目录列表的末尾。这是一个参数展开的实例， 参数展开我们在第八章中提到过。为了说明这是怎样工作的，试试下面的例子：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ foo=&quot;This is some&quot;[me@linuxbox ~]$ echo $fooThis is some[me@linuxbox ~]$ foo=&quot;$foo text.&quot;[me@linuxbox ~]$ echo $fooThis is some text.</code></pre><p>使用<strong>这种技巧，我们可以把文本附加到一个变量值的末尾</strong>。通过添加字符串 $HOME/bin 到 PATH 变量值 的末尾，则目录 $HOME/bin 就添加到了命令搜索目录列表中。这意味着当我们想要在自己的家目录下， 创建一个目录来存储我们自己的私人程序时，shell 已经给我们准备好了。我们所要做的事就是 把创建的目录叫做 bin，赶快行动吧。</p><blockquote><p>注意：很多发行版默认地提供了这个 PATH 设置。一些基于 Debian 的发行版，例如 Ubuntu，在登录 的时候，会检测目录 ~/bin 是否存在，若找到目录则把它动态地加到 PATH 变量中。</p></blockquote><p>最后，有下面一行代码：</p><pre><code class="highlight plaintext">export PATH</code></pre><p>这个 export 命令告诉 shell 让这个 shell 的子进程可以使用 PATH 变量的内容，即让PATH变量从仅为该用户使用变为全局使用。</p><h3 id="export命令"><a class="markdownIt-Anchor" href="#export命令"></a> export命令</h3><p>设置或显示环境变量。</p><pre><code class="highlight plaintext">export [-fnp][变量名称]=[变量设置值]</code></pre><p>参 数：</p><ul><li>-f 代表[变量名称]中为函数名称。</li><li>-n 删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。</li><li>-p 列出所有的shell赋予程序的环境变量。</li></ul><p>一个变量创建时，它不会自动地为在它之后创建的shell进程所知。而命令export可以向后面的shell传递变量的值。当一个shell脚本调用并执行时，它不会自动得到原来脚本（调用者）里定义的变量的访问权，除非这些变量已经被显式地设置为可用。export命令可以用于传递一个或多个变量的值到任何后继脚本。</p><p>登录到系统后，系统将启动一个用户shell。在这个shell中，可以使用shell命令或声明变量，也可以创建并运行shell脚本程序。运行shell脚本程序时，系统将创建一个子shell。此时，系统中将有两个shell，一个是登录时系统启动的shell，另一个是系统为运行脚本程序创建的shell。当一个脚本程序运行完毕，它的脚本shell将终止，可以返回到执行该脚本之前的shell。从这种意义上来说，用户可以有许多shell，每个shell都是由某个shell（称为父shell）派生的。</p><p>在<strong>子shell中定义的变量只在该子shell内有效</strong>。如果在一个shell脚本程序中定义了一个变量，当该脚本程序运行时，这个定义的变量只是该脚本程序内的一个局部变量，其他的shell不能引用它，要使<strong>某个变量的值可以在其他shell中被改变，可以使用export命令对已定义的变量进行输出</strong>。</p><p>export命令将使系统在创建每一个新的shell时定义这个变量的一个拷贝。这个过程称之为变量输出。</p><p>#echo $PKG_PATH 在任何时候建立的变量都只是当前shell的局部变量，所以不能被shell运行的其他命令或shell程序所利用。 export ,是把你设置的环境变量传给当前SHELL的子SHELL，使其在子SHELL中有效。</p><h3 id="修改shell环境"><a class="markdownIt-Anchor" href="#修改shell环境"></a> 修改shell环境</h3><p>按照通常的规则，添加目录到你的 PATH 变量或者是定义额外的环境变量，要把这些更改放置到 .bash_profile 文件中（或者其替代文件中，根据不同的发行版。例如，Ubuntu 使用 .profile 文件）。 对于其它的更改，要放到 .bashrc 文件中。除非你是系统管理员，需要为系统中的所有用户修改 默认设置，那么则限定你只能对自己家目录下的文件进行修改。当然，有可能会更改 /etc 目录中的 文件，比如说 profile 文件，而且在许多情况下，修改这些文件也是明智的，但是现在，我们要 安全起见。</p><p>修改之前我们先备份一份：</p><pre><code class="highlight plaintext">#该文件在用户的家目录[me@linuxbox ~]$ cp .bashrc .bashrc.bak</code></pre><p>然后我们编辑该文件：</p><pre><code class="highlight plaintext">vim .bashrc</code></pre><p>在最后面添加：</p><pre><code class="highlight plaintext">umask 0002export HISTCONTROL=ignoredupsexport HISTSIZE=1000alias l.=&#x27;ls -d .* --color=auto&#x27;alias ll=&#x27;ls -l --color=auto&#x27;</code></pre><blockquote><p>注意：你的发行版可能已经包含其中的一些行，但是复制没有任何伤害。</p></blockquote><table><thead><tr><th>按键</th><th>行动</th></tr></thead><tbody><tr><td>文本行</td><td>含义</td></tr><tr><td>umask 0002</td><td>设置掩码来解决共享目录的问题。</td></tr><tr><td>export HISTCONTROL=ignoredups</td><td>使得 shell 的历史记录功能忽略一个命令，如果相同的命令已被记录。</td></tr><tr><td>export HISTSIZE=1000</td><td>增加命令历史的大小，从默认的 500 行扩大到 1000 行。</td></tr><tr><td>alias l.=‘ls -d .* --color=auto’</td><td>创建一个新命令，叫做’l.'，这个命令会显示所有以点开头的目录项。</td></tr><tr><td>alias ll=‘ls -l --color=auto’</td><td>创建一个叫做’ll’的命令，这个命令会显示长格式目录列表。</td></tr></tbody></table><hr /><p><strong>激活我们的修改</strong></p><p>我们对于文件 .bashrc 的修改不会生效，直到我们关闭终端会话，再重新启动一个新的会话， 因为 .bashrc 文件只是在刚开始启动终端会话时读取。然而，我们可以强迫 bash 重新读取修改过的 .bashrc 文件，使用下面的命令：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ source .bashrc</code></pre><h2 id="软件包管理"><a class="markdownIt-Anchor" href="#软件包管理"></a> 软件包管理</h2><p><strong>打包系统</strong></p><p>不同的 Linux 发行版使用不同的打包系统，一般而言，大多数发行版分别属于两大包管理技术阵营： Debian 的”.deb”，和红帽的”.rpm”。也有一些重要的例外，比方说 Gentoo， Slackware，和 Foresight，但大多数会使用这两个基本系统中的一个。</p><table><thead><tr><th>包管理系统</th><th>发行版 (部分列表)</th></tr></thead><tbody><tr><td>Debian Style (.deb)</td><td>Debian, Ubuntu, Xandros, Linspire</td></tr><tr><td>Red Hat Style (.rpm)</td><td>Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS</td></tr></tbody></table><p><strong>软件包管理系统是怎样工作</strong></p><p>在专有软件产业中找到的软件发布方法通常需要买一张安装媒介，比方说”安装盘”，然后运行 “安装向导”，来在系统中安装新的应用程序。</p><p>Linux 不是这样。Linux 系统中几乎所有的软件都可以在互联网上找到。其中大多数软件由发行商以 包文件的形式提供，剩下的则以源码形式存在，可以手动安装。在后面章节里，我们将会谈谈怎样 通过编译源码来安装软件。</p><p><strong>包文件</strong></p><p>在包管理系统中软件的基本单元是包文件。包文件是一个构成软件包的文件压缩集合。一个软件包 可能由大量程序以及支持这些程序的数据文件组成。除了安装文件之外，软件包文件也包括 关于这个包的元数据，如软件包及其内容的文本说明。另外，许多软件包还包括预安装和安装后脚本， 这些脚本用来在软件安装之前和之后执行配置任务。</p><p>软件包文件是由软件包维护者创建的，他通常是（但不总是）一名软件发行商的雇员。软件维护者 从上游提供商（程序作者）那里得到软件源码，然后编辑源码，创建软件包元数据以及所需要的 安装脚本。通常，软件包维护者要把所做的修改应用到最初的源码当中，来提高此软件与 Linux 发行版其它部分的融合性。</p><p><strong>资源库</strong></p><p>虽然某些软件项目选择执行他们自己的打包和发布策略，但是现在大多数软件包是由发行商和感兴趣 的第三方创建的。系统发行版的用户可以在一个中心资源库中得到这些软件包，这个资源库可能 包含了成千上万个软件包，每一个软件包都是专门为这个系统发行版建立和维护的。</p><p>因软件开发生命周期不同阶段的需要，一个系统发行版可能维护着几个不同的资源库。例如，通常会 有一个”测试”资源库，其中包含刚刚建立的软件包，它们想要勇敢的用户来使用， 在这些软件包正式发布之前，让用户查找错误。系统发行版经常会有一个”开发”资源库， 这个资源库中保存着注定要包含到下一个主要版本中的半成品软件包。</p><p>一个系统发行版可能也会拥有相关第三方的资源库。这些资源库需要支持一些因法律原因， 比如说专利或者是 DRM 反规避问题，而不能被包含到发行版中的软件。可能最著名的案例就是 那个加密的 DVD 支持，在美国这是不合法的。第三方资源库在这些软件专利和反规避法案不 生效的国家中起作用。这些资源库通常完全地独立于它们所支持的资源库，要想使用它们， 你必须了解它们，手动地把它们包含到软件包管理系统的配置文件中。</p><p><strong>依赖性</strong></p><p>程序很少是”孤立的”，而是依赖于其它软件组件来完成它们的工作。常见活动，以 输入/输出为例，就是由共享程序例程来处理的。这些程序例程存储在共享库中，共享库不只 为一个程序提供基本服务。如果一个软件包需要共享资源，比如说共享库，据说就有一个依赖。 现代的软件包管理系统都提供了一些依赖项解析方法，以此来确保当安装软件包时，也安装了 其所有的依赖程序。</p><p><strong>上层和底层软件包工具</strong></p><p>软件包管理系统通常由两种工具类型组成：底层工具用来处理这些任务，比方说安装和删除软件包文件， 和上层工具，完成元数据搜索和依赖解析。在这一章中，我们将看一下由 Debian 风格的系统 （比如说 Ubuntu，还有许多其它系统）提供的工具，还有那些由 Red Hat 产品使用的工具。虽然所有基于 Red Hat 风格的发行版都依赖于相同的底层程序（rpm）, 但是它们却使用不同的上层工具。我们将研究上层程序 yum 供我们讨论，Fedora, Red Hat 企业版，和 CentOs 都是使用 yum。其它基于 Red Hat 风格的发行版提供了带有可比较特性的上层工具。</p><table><thead><tr><th>发行版</th><th>底层工具</th><th>上层工具</th></tr></thead><tbody><tr><td>Debian-Style</td><td>dpkg</td><td>apt-get, aptitude</td></tr><tr><td>Fedora, Red Hat Enterprise Linux, CentOS</td><td>rpm</td><td>yum</td></tr></tbody></table><h3 id="yum命令"><a class="markdownIt-Anchor" href="#yum命令"></a> yum命令</h3><h4 id="yum搜索软件"><a class="markdownIt-Anchor" href="#yum搜索软件"></a> <strong>yum搜索软件�</strong>�</h4><p>使用上层工具来搜索资源库元数据，可以根据软件包的名字和说明来定位它。</p><table><thead><tr><th>风格</th><th>命令</th></tr></thead><tbody><tr><td>Debian</td><td>apt-get update; apt-cache search search_string</td></tr><tr><td>Red Hat</td><td>yum search search_string</td></tr></tbody></table><p>例如：搜索一个 yum 资源库来查找 emacs 文本编辑器，使用以下命令：</p><pre><code class="highlight plaintext">yum search emacs</code></pre><hr /><h4 id="yum安装软件"><a class="markdownIt-Anchor" href="#yum安装软件"></a> <strong>yum安装软件�</strong>�</h4><p>上层工具允许从一个资源库中下载一个软件包，并经过完全依赖解析来安装它。</p><table><thead><tr><th>风格</th><th>命令</th></tr></thead><tbody><tr><td>Debian</td><td>apt-get update; apt-get install package_name</td></tr><tr><td>Red Ha</td><td>yum install package_name</td></tr></tbody></table><p>例如：从一个 apt 资源库来安装 emacs 文本编辑器：</p><pre><code class="highlight plaintext">yum install emacs</code></pre><hr /><h4 id="yum卸载软件"><a class="markdownIt-Anchor" href="#yum卸载软件"></a> <strong>yum卸载软件</strong></h4><p>可以使用上层或者底层工具来卸载软件。下面是可用的上层工具。</p><table><thead><tr><th>风格</th><th>命令</th></tr></thead><tbody><tr><td>Debian</td><td>apt-get remove package_name</td></tr><tr><td>Red Hat</td><td>yum erase package_name</td></tr></tbody></table><p>例如：从 Red Hat 风格的系统中卸载 emacs 软件包：</p><pre><code class="highlight plaintext">yum erase emacs</code></pre><h4 id="yum更新软件包"><a class="markdownIt-Anchor" href="#yum更新软件包"></a> yum更新软件包</h4><p>最常见的软件包管理任务是保持系统中的软件包都是最新的。上层工具仅需一步就能完成 这个至关重要的任务。</p><table><thead><tr><th>风格</th><th>命令</th></tr></thead><tbody><tr><td>Debian</td><td>apt-get update; apt-get upgrade</td></tr><tr><td>Red Hat</td><td>yum update</td></tr></tbody></table><p>示例：</p><pre><code class="highlight plaintext">yum updata java</code></pre><h4 id="配置阿里镜像"><a class="markdownIt-Anchor" href="#配置阿里镜像"></a> 配置阿里镜像</h4><ol><li>备份</li></ol><pre><code class="highlight plaintext">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code></pre><ol><li>下载新的CentOS-Base.repo</li></ol><pre><code class="highlight plaintext">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</code></pre><ol><li>生成缓存</li></ol><pre><code class="highlight plaintext">yum clean allyum makecache</code></pre><h4 id="查找软件并删除"><a class="markdownIt-Anchor" href="#查找软件并删除"></a> 查找软件并删除</h4><pre><code class="highlight plaintext">rpm -qa | grep jdkyum -y remove java-1.5.0-gcj-devel-1.5.0.0-29.1.el6.x86_64</code></pre><h3 id="rpm"><a class="markdownIt-Anchor" href="#rpm"></a> rpm</h3><hr /><h4 id="通过软件包文件来安装软件"><a class="markdownIt-Anchor" href="#通过软件包文件来安装软件"></a> <strong>通过软件包文件来安装软件</strong></h4><p>如果从某处而不是从资源库中下载了一个软件包文件，可以使用底层工具来直接（没有经过依赖解析）安装它。</p><table><thead><tr><th>风格</th><th>命令</th></tr></thead><tbody><tr><td>Debian</td><td>dpkg --install package_file</td></tr><tr><td>Red Hat</td><td>rpm -i package_file</td></tr></tbody></table><p>例如：如果已经从一个并非资源库的网站下载了软件包文件 emacs-22.1-7.fc7-i386.rpm， 则可以通过这种方法来安装它：</p><pre><code class="highlight plaintext">rpm -i emacs-22.1-7.fc7-i386.rpm</code></pre><p><strong>忽略依赖解析方式</strong>：</p><pre><code class="highlight plaintext">rpm -ivh MySQL-server-5.5.31-2.el6.i686.rpm --nodeps --force</code></pre><blockquote><p>注意：因为这项技术使用底层的 rpm 程序来执行安装任务，所以没有运行依赖解析。 如果 rpm 程序发现缺少了一个依赖，则会报错并退出。</p></blockquote><h4 id="经过软件包来升级软件"><a class="markdownIt-Anchor" href="#经过软件包来升级软件"></a> 经过软件包来升级软件</h4><p>如果已经从一个非资源库网站下载了一个软件包的最新版本，可以安装这个版本，用它来 替代先前的版本：</p><table><thead><tr><th>风格</th><th>命令</th></tr></thead><tbody><tr><td>Debian</td><td>dpkg --install package_file</td></tr><tr><td>Red Hat</td><td>rpm -U package_file</td></tr></tbody></table><p>例如：把 Red Hat 系统中所安装的 emacs 的版本更新到软件包文件 emacs-22.1-7.fc7-i386.rpmz 所包含的 emacs 版本。</p><pre><code class="highlight plaintext">rpm -U emacs-22.1-7.fc7-i386.rpm</code></pre><h4 id="列出所安装的软件包"><a class="markdownIt-Anchor" href="#列出所安装的软件包"></a> 列出所安装的软件包</h4><p>下表中的命令可以用来显示安装到系统中的所有软件包列表：</p><table><thead><tr><th>风格</th><th>命令</th></tr></thead><tbody><tr><td>Debian</td><td>dpkg --list</td></tr><tr><td>Red Hat</td><td>rpm -qa</td></tr></tbody></table><pre><code class="highlight plaintext">rpm -qa | grep mariadb</code></pre><h4 id="删除软件"><a class="markdownIt-Anchor" href="#删除软件"></a> 删除软件</h4><pre><code class="highlight plaintext">语句：rpm -e --nodeps 软件名实例：rpm -e --nodeps mariadb-libs-5.5.37-1.el7_0.x86_64批量删除：yum -y remove `rpm -qa | grep mariadb`rpm -e --nodeps `rpm -qa | grep mysql`</code></pre><h2 id="网络系统"><a class="markdownIt-Anchor" href="#网络系统"></a> 网络系统</h2><p>当谈及到网络系统层面，几乎任何东西都能由 Linux 来实现。Linux 被用来创建各式各样的网络系统和装置， 包括防火墙，路由器，名称服务器，网络连接式存储设备等等。</p><h3 id="检查和检测网络"><a class="markdownIt-Anchor" href="#检查和检测网络"></a> 检查和检测网络</h3><h4 id="ping"><a class="markdownIt-Anchor" href="#ping"></a> ping</h4><p>最基本的网络命令是 ping。这个 ping 命令发送一个特殊的网络数据包，叫做 IMCP ECHO_REQUEST，到 一台指定的主机。大多数接收这个包的网络设备将会回复它，来允许网络连接验证。</p><blockquote><p>注意：大多数网络设备（包括 Linux 主机）都可以被配置为忽略这些数据包。通常，这样做是出于网络安全 原因，部分地遮蔽一台主机免受一个潜在攻击者地侵袭。配置防火墙来阻塞 IMCP 流量也很普遍。</p></blockquote><p>一旦启动，ping 命令会持续在特定的时间间隔内（默认是一秒）发送数据包，直到它被中断：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ ping linuxcommand.orgPING linuxcommand.org (66.35.250.210) 56(84) bytes of data.64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=1ttl=43 time=107 ms64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=2ttl=43 time=108 ms64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=3ttl=43 time=106 ms64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=4ttl=43 time=106 ms64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=5ttl=43 time=105 ms...</code></pre><p>按下组合键 Ctrl-c，中断这个命令之后，ping 打印出运行统计信息。一个正常工作的网络会报告 零个数据包丢失。一个成功执行的“ping”命令会意味着网络的各个部件（网卡，电缆，路由，网关） 都处于正常的工作状态。</p><h4 id="netstat"><a class="markdownIt-Anchor" href="#netstat"></a> netstat</h4><p>netstat 程序被用来检查各种各样的网络设置和统计数据。通过此命令的许多选项，我们 可以看看网络设置中的各种特性。使用“-ie”选项，我们能够查看系统中的网络接口：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ netstat -ieeth0    Link encap:Ethernet HWaddr 00:1d:09:9b:99:67        inet addr:192.168.1.2 Bcast:192.168.1.255 Mask:255.255.255.0        inet6 addr: fe80::21d:9ff:fe9b:9967/64 Scope:Link        UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1        RX packets:238488 errors:0 dropped:0 overruns:0 frame:0        TX packets:403217 errors:0 dropped:0 overruns:0 carrier:0        collisions:0 txqueuelen:100 RX bytes:153098921 (146.0 MB) TX        bytes:261035246 (248.9 MB) Memory:fdfc0000-fdfe0000lo      Link encap:Local Loopback        inet addr:127.0.0.1 Mask:255.0.0.0...</code></pre><p>在上述实例中，我们看到我们的测试系统有两个网络接口。第一个，叫做 eth0，是 因特网接口，和第二个，叫做 lo，是内部回环网络接口，它是一个虚拟接口，系统用它来 “自言自语”。</p><hr /><p><strong>查看某端口</strong></p><pre><code class="highlight plaintext">netstat -ntlp   //查看当前所有tcp端口·netstat -ntulp |grep 1935   //查看所有1935端口使用情况·</code></pre><h3 id="网络中传输文件"><a class="markdownIt-Anchor" href="#网络中传输文件"></a> 网络中传输文件</h3><h4 id="ftp"><a class="markdownIt-Anchor" href="#ftp"></a> ftp</h4><p>ftp 命令属于真正的“经典”程序之一，它的名字来源于其所使用的协议，就是文件传输协议。 FTP 被广泛地用来从因特网上下载文件。大多数，并不是所有的，网络浏览器都支持 FTP， 你经常可以看到它们的 URI 以协议 <a href="ftp://%E5%BC%80%E5%A4%B4">ftp://开头</a>。在出现网络浏览器之前，ftp 程序已经存在了。 ftp 程序可用来与 FTP 服务器进行通信，FTP 服务器就是存储文件的计算机，这些文件能够通过 网络下载和上传。</p><p>FTP（它的原始形式）并不是安全的，因为它会以明码形式发送帐号的姓名和密码。这就意味着 这些数据没有加密，任何嗅探网络的人都能看到。由于此种原因，几乎因特网中所有 FTP 服务器 都是匿名的。一个匿名服务器能允许任何人使用注册名“anonymous”和无意义的密码登录系统。</p><p>在下面的例子中，我们将展示一个典型的会话，从匿名 FTP 服务器，其名字是 fileserver， 的/pub/images/Ubuntu-8.04的目录下，使用 ftp 程序下载一个 Ubuntu 系统映像文件。</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ ftp fileserverConnected to fileserver.localdomain.220 (vsFTPd 2.0.1)Name (fileserver:me): anonymous331 Please specify the password.Password:230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp&gt; cd pub/cd\_images/Ubuntu-8.04250 Directory successfully changed.ftp&gt; ls200 PORT command successful. Consider using PASV.150 Here comes the directory listing.-rw-rw-r-- 1 500 500 733079552 Apr 25 03:53 ubuntu-8.04- desktop-i386.iso226 Directory send OK.ftp&gt; lcd DesktopLocal directory now /home/me/Desktopftp&gt; get ubuntu-8.04-desktop-i386.isolocal: ubuntu-8.04-desktop-i386.iso remote: ubuntu-8.04-desktop-i386.iso200 PORT command successful. Consider using PASV.150 Opening BINARY mode data connection for ubuntu-8.04-desktop-i386.iso (733079552 bytes).226 File send OK.733079552 bytes received in 68.56 secs (10441.5 kB/s)ftp&gt; bye</code></pre><table><thead><tr><th>命令</th><th>意思</th></tr></thead><tbody><tr><td>ftp fileserver</td><td>唤醒 ftp 程序，让它连接到 FTP 服务器，fileserver。</td></tr><tr><td>anonymous</td><td>登录名。输入登录名后，将出现一个密码提示。一些服务器将会接受空密码， 其它一些则会要求一个邮件地址形式的密码。如果是这种情况，试着输入 “user@example.com”。</td></tr><tr><td>cd pub/cd_images/Ubuntu-8.04</td><td>跳转到远端系统中，要下载文件所在的目录下， 注意在大多数匿名的 FTP 服务器中，支持公共下载的文件都能在目录 pub 下找到</td></tr><tr><td>ls</td><td>列出远端系统中的目录。</td></tr><tr><td>lcd Desktop</td><td>跳转到本地系统中的 ~/Desktop 目录下。在实例中，ftp 程序在工作目录 ~ 下被唤醒。 这个命令把工作目录改为 ~/Desktop</td></tr><tr><td>get ubuntu-8.04-desktop-i386.iso</td><td>告诉远端系统传送文件到本地。因为本地系统的工作目录 已经更改到了 ~/Desktop，所以文件会被下载到此目录。</td></tr><tr><td>bye</td><td>退出远端服务器，结束 ftp 程序会话。也可以使用命令 quit 和 exit。</td></tr></tbody></table><h4 id="wget-下载"><a class="markdownIt-Anchor" href="#wget-下载"></a> wget 下载</h4><p>wget命令用于<strong>在终端中下载网络文件</strong>，格式</p><pre><code class="highlight plaintext">wget [参数] 下载地址</code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><p><strong>案例：</strong></p><p>尝试使用wget命令从本书的配套站点中下载本书的最新pdf格式电子文档，这个文件的完整路径为<a href="https://www.linuxprobe.com/docs/LinuxProbe.pdf%EF%BC%8C%E6%89%A7%E8%A1%8C%E8%AF%A5%E5%91%BD%E4%BB%A4%E5%90%8E%E7%9A%84%E4%B8%8B%E8%BD%BD%E6%95%88%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">https://www.linuxprobe.com/docs/LinuxProbe.pdf，执行该命令后的下载效果如下：</a></p><pre><code class="highlight plaintext">[root@linuxprobe ~]# wget https://www.linuxprobe.com/docs/LinuxProbe.pdf</code></pre><p>接下来，我们使用wget命令递归下载www.linuxprobe.com网站内的所有页面数据以及文件，下载完后会自动保存到当前路径下一个名为www.linuxprobe.com的目录中。执行该操作的命令为wget -r -p <a href="https://www.linuxprobe.com">https://www.linuxprobe.com</a>，该命令的执行结果如下。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# wget -r -p https://www.linuxprobe.com--2017-08-24 19:31:41-- https://www.linuxprobe.com/Resolving www.linuxprobe.com... 106.185.25.197Connecting to www.linuxprobe.com|106.185.25.197|:80... connected.HTTP request sent, awaiting response... 200 OKLength: unspecified [text/html]Saving to: &#x27;www.linuxprobe.com/index.html&#x27;</code></pre><h4 id="scp远程拷贝"><a class="markdownIt-Anchor" href="#scp远程拷贝"></a> scp远程拷贝</h4><p>Linux scp 命令用于 Linux 之间复制文件和目录。</p><p>语法：</p><pre><code class="highlight plaintext">scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file][-l limit] [-o ssh_option] [-P port] [-S program][[user@]host1:]file1 [...] [[user@]host2:]file2</code></pre><p>简易写法</p><pre><code class="highlight plaintext">:scp [可选参数] file_source file_target</code></pre><p>参数说明：</p><ul><li>-1： 强制scp命令使用协议ssh1</li><li>-2： 强制scp命令使用协议ssh2</li><li>-4： 强制scp命令只使用IPv4寻址</li><li>-6： 强制scp命令只使用IPv6寻址</li><li>-B： 使用批处理模式（传输过程中不询问传输口令或短语）</li><li>-C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</li><li>-p：保留原文件的修改时间，访问时间和访问权限。</li><li>-q： 不显示传输进度条。</li><li>-r： 递归复制整个目录。</li><li>-v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li><li>-c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</li><li>-F ssh_config： 指定一个替代的ssh配置文件，此参数直接传递给ssh。</li><li>-i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</li><li>-l limit： 限定用户所能使用的带宽，以Kbit/s为单位。</li><li>-o ssh_option： 如果习惯于使用ssh_config(5)中的参数传递方式，</li><li>-P port：<strong>注意是大写的P, port是指定数据传输用到的端口号</strong></li><li>-S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</li></ul><hr /><p><strong>本机-&gt;远程</strong></p><p>目前我们处在IP为“192.168.60.133”的Linux系统下，计划将系统下的/home/ixdba/etc.tar.gz文件拷贝到IP为“192.168.60</p><p>168”的远程Linux系统中root用户下的/tmp目录下：</p><pre><code class="highlight plaintext">scp /home/etc.tar root@192.168.60.168:/tmp</code></pre><p>命令输入完毕，会要求输入“192.168.60.168”服务器root的密码，然后开始远程拷贝数据。</p><p><strong>远程-&gt;本机</strong></p><p>如果我们处在“192.168.60.168”服务器上，也可以使用下面的命令传输数据：</p><pre><code class="highlight plaintext">scp root@192.168.60.133:/home/etc.tar /tmp</code></pre><p>命令输入完毕，此时会要求输入“192.168.60.133”服务器root的密码，然后开始远程拷贝数据。</p><h3 id="ssh"><a class="markdownIt-Anchor" href="#ssh"></a> SSH</h3><p>通过网络来远程操控类 Unix 的操作系统已经有很多年了。早些年，在因特网普遍推广之前，有 一些受欢迎的程序被用来登录远程主机。它们是 rlogin 和 telnet 程序。然而这些程序，拥有和 ftp 程序 一样的致命缺点；它们以明码形式来传输所有的交流信息（包括登录命令和密码）。这使它们完全不 适合使用在因特网时代。</p><p>为了解决这个问题，开发了一款新的协议，叫做 SSH（Secure Shell）。 SSH 解决了这两个基本的和远端主机安全交流的问题。首先，它要认证远端主机是否为它 所知道的那台主机（这样就阻止了所谓的“中间人”的攻击），其次，它加密了本地与远程主机之间 所有的通讯信息。</p><p>SSH 由两部分组成。SSH 服务器运行在远端主机上运行，在端口号22上监听将要到来的连接，而 SSH 客户端用在本地系统中，用来和远端服务器通信。</p><p>大多数 Linux 发行版自带一个提供 SSH 功能的软件包，叫做 OpenSSH，来自于 BSD 项目。一些发行版 默认包含客户端和服务器端两个软件包（例如，Red Hat）,而另一些（比方说 Ubuntu）则只是提供客户端服务。为了能让系统接受远端的连接，它必须 安装 OpenSSH-server 软件包，配置，运行它，并且（如果系统正在运行，或者是在防火墙之后） 它必须允许在 TCP 端口号上接收网络连接。</p><p><strong>建立连接</strong></p><p>试用下述命令，然后输入正确的密码，即可连接到目标主机。</p><p>成功地输入密码之后，我们会接收到远端系统的 shell 提示符：</p><pre><code class="highlight plaintext"># ssh root@172.172.30.71root@172.172.30.71&#x27;s password: Last login: Wed Nov  4 09:46:17 2020 from 192.168.211.182[root@linux71 ~]#</code></pre><blockquote><p>远端 shell 会话一直存在，直到用户输入 exit 命令后，则关闭了远程连接。这时候，本地的 shell 会话 恢复，本地 shell 提示符重新出现。</p></blockquote><p>每建立一个新的连接，都会在 ~/.ssh/known_hosts 文件生成如下的一行话：</p><pre><code class="highlight plaintext">192.168.211.182 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBAeprXVlg+94HN0SGnFuFl2GdEShQ9sZTD5sDtAKd1ZX6ERPVsHhjoWhZxToY8JDI9Ng02xlc7/kr4Mvbk/tZI4=</code></pre><p>ssh 验证远端主机的真实性。如果远端主机不能成功地通过验证，则会提示以下信息：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ ssh remote-sys@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middleattack)!...</code></pre><p>有两种可能的情形会提示这些信息。第一，某个攻击者企图制造“中间人”袭击。这很少见， 因为每个人都知道 ssh 会针对这种状况发出警告。最有可能的罪魁祸首是远端系统已经改变了； 例如，它的操作系统或者是 SSH 服务器重新安装了。然而，为了安全起见，第一个可能性不应该 被轻易否定。当这条消息出现时，总要与远端系统的管理员查对一下。当确定了这条消息归结为一个良性的原因之后，那么在客户端更正问题就很安全了。 使用文本编辑器（可能是 vim）从文件~/.ssh/known_hosts 中删除废弃的钥匙， 就解决了问题。在上面的例子里，我们看到这样一句话：</p><pre><code class="highlight plaintext">Offending key in /home/me/.ssh/known_hosts:1</code></pre><p>这意味着文件 known_hosts 里面某一行包含攻击型的钥匙。从文件中删除这一行，则 ssh 程序 就能够从远端系统接受新的身份验证凭据。</p><hr /><p><strong>在远端主机执行命令</strong></p><pre><code class="highlight plaintext">[me@linuxbox ~]$ ssh root@172.172.30.71 &#x27;ls \*&#x27; &gt; dirlist.txtme@twin4&#x27;s password:[me@linuxbox ~]$</code></pre><blockquote><p>注意，上面的例子中使用了单引号。这样做是因为我们不想路径名展开操作在本地执行 ；而希望 它在远端系统中被执行。同样地，如果我们想要把输出结果重定向到远端主机的文件中，我们可以 把重定向操作符和文件名都放到单引号里面</p></blockquote><pre><code class="highlight plaintext">[me@linuxbox ~]$ ssh remote-sys &#x27;ls * &gt; dirlist.txt&#x27;</code></pre><h3 id="防火墙"><a class="markdownIt-Anchor" href="#防火墙"></a> 防火墙</h3><p>在RHEL 7系统中，firewalld防火墙取代了iptables防火墙.</p><p>其实，iptables与firewalld都不是真正的防火墙，它们都只是用来定义防火墙策略的防火墙管理工具而已，或者说，它们只是一种服务。</p><p>iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。换句话说，当前在Linux系统中其实存在多个防火墙管理工具，旨在方便运维人员管理Linux系统中的防火墙策略，我们只需要配置妥当其中的一个就足够了。</p><h4 id="打开防火墙"><a class="markdownIt-Anchor" href="#打开防火墙"></a> 打开防火墙</h4><pre><code class="highlight plaintext">systemctl start firewalld或者systemctl start Iptables</code></pre><h4 id="关闭防火墙"><a class="markdownIt-Anchor" href="#关闭防火墙"></a> 关闭防火墙</h4><pre><code class="highlight plaintext">systemctl stop firewalld或者systemctl stop Iptables</code></pre><h4 id="iptables"><a class="markdownIt-Anchor" href="#iptables"></a> iptables</h4><p>在早期的Linux系统中，默认使用的是iptables防火墙管理服务来配置防火墙。尽管新型的firewalld防火墙管理服务已经被投入使用多年，但是大量的企业在生产环境中依然出于各种原因而继续使用iptables。</p><h5 id="策略与规则链"><a class="markdownIt-Anchor" href="#策略与规则链"></a> 策略与规则链</h5><p>防火墙会从上至下的顺序来读取配置的策略规则，在找到匹配项后就立即结束匹配工作并去执行匹配项中定义的行为（即放行或阻止）。如果在读取完所有的策略规则之后没有匹配项，就去执行默认的策略。</p><p>一般而言，防火墙策略规则的设置有两种：一种是“通”（即放行），一种是“堵”（即阻止）。当防火墙的默认策略为拒绝时（堵），就要设置允许规则（通），否则谁都进不来；如果防火墙的默认策略为允许时，就要设置拒绝规则，否则谁都能进来，防火墙也就失去了防范的作用。</p><p>iptables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链，而规则链则依据数据包处理位置的不同进行分类，具体如下：</p><ul><li>在进行路由选择前处理数据包（PREROUTING）</li><li>处理流入的数据包（INPUT）</li><li>处理流出的数据包（OUTPUT）</li><li>处理转发的数据包（FORWARD）</li><li>在进行路由选择后处理数据包（POSTROUTING）</li></ul><p>一般来说，从内网向外网发送的流量一般都是可控且良性的，因此我们使用最多的就是INPUT规则链，该规则链可以增大黑客人员从外网入侵内网的难度。</p><blockquote><p>比如在您居住的社区内，物业管理公司有两条规定：禁止小商小贩进入社区；各种车辆在进入社区时都要登记。显而易见，这两条规定应该是用于社区的正门的（流量必须经过的地方），而不是每家每户的防盗门上。根据前面提到的防火墙策略的匹配顺序，可能会存在多种情况。比如，来访人员是小商小贩，则直接会被物业公司的保安拒之门外，也就无需再对车辆进行登记。如果来访人员乘坐一辆汽车进入社区正门，则“禁止小商小贩进入社区”的第一条规则就没有被匹配到，因此按照顺序匹配第二条策略，即需要对车辆进行登记。如果是社区居民要进入正门，则这两条规定都不会匹配到，因此会执行默认的放行策略。</p></blockquote><p>但是，仅有策略规则还不能保证社区的安全，保安还应该知道采用什么样的动作来处理这些匹配的流量，比如“允许”、“拒绝”、“登记”、“不理它”。这些动作对应到iptables服务的术语中分别是<strong>ACCEPT</strong>（允许流量通过）、<strong>REJECT</strong>（拒绝流量通过）、<strong>LOG</strong>（记录日志信息）、<strong>DROP</strong>（拒绝流量通过）。“允许流量通过”和“记录日志信息”都比较好理解，这里需要着重讲解的是REJECT和DROP的不同点。就DROP来说，它是直接将流量丢弃而且不响应；REJECT则会在拒绝流量后再回复一条“您的信息已经收到，但是被扔掉了”信息，从而让流量发送方清晰地看到数据被拒绝的响应信息。</p><blockquote><p>我们来举一个例子，让各位读者更直观地理解这两个拒绝动作的不同之处。比如有一天您正在家里看电视，突然听到有人敲门，您透过防盗门的猫眼一看是推销商品的，便会在不需要的情况下开门并拒绝他们（REJECT）。但如果您看到的是债主带了十几个小弟来讨债，此时不仅要拒绝开门，还要默不作声，伪装成自己不在家的样子（DROP）</p></blockquote><p>当把Linux系统中的防火墙策略设置为REJECT拒绝动作后，流量发送方会看到端口不可达的响应：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# ping -c 4 192.168.10.10PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.From 192.168.10.10 icmp_seq=1 Destination Port UnreachableFrom 192.168.10.10 icmp_seq=2 Destination Port UnreachableFrom 192.168.10.10 icmp_seq=3 Destination Port UnreachableFrom 192.168.10.10 icmp_seq=4 Destination Port Unreachable--- 192.168.10.10 ping statistics ---4 packets transmitted, 0 received, +4 errors, 100% packet loss, time 3002ms</code></pre><p>而把Linux系统中的防火墙策略修改成DROP拒绝动作后，流量发送方会看到响应超时的提醒。但是流量发送方无法判断流量是被拒绝，还是接收方主机当前不在线：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# ping -c 4 192.168.10.10PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data. --- 192.168.10.10 ping statistics ---4 packets transmitted, 0 received, 100% packet loss, time 3000ms</code></pre><h5 id="基本命令参数"><a class="markdownIt-Anchor" href="#基本命令参数"></a> 基本命令参数</h5><p>iptables命令可以根据流量的源地址、目的地址、传输协议、服务类型等信息进行匹配，一旦匹配成功，iptables就会根据策略规则所预设的动作来处理这些流量。另外，再次提醒一下，防火墙策略规则的匹配顺序是从上至下的，因此要把较为严格、优先级较高的策略规则放到前面，以免发生错误</p><p>表总结归纳了常用的iptables命令参数。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-P</td><td>设置默认策略</td></tr><tr><td>-F</td><td>清空规则链</td></tr><tr><td>-L</td><td>查看规则链</td></tr><tr><td>-A</td><td>在规则链的末尾加入新规则</td></tr><tr><td>-I num</td><td>在规则链的头部加入新规则</td></tr><tr><td>-D num</td><td>删除某一条规则</td></tr><tr><td>-s</td><td>匹配来源地址IP/MASK，加叹号“!”表示除这个IP外</td></tr><tr><td>-d</td><td>匹配目标地址</td></tr><tr><td>-i</td><td>网卡名称 匹配从这块网卡流入的数据</td></tr><tr><td>-o</td><td>网卡名称 匹配从这块网卡流出的数据</td></tr><tr><td>-p</td><td>匹配协议，如TCP、UDP、ICMP</td></tr><tr><td>—dport num</td><td>匹配目标端口号</td></tr><tr><td>—sport num</td><td>匹配来源端口号</td></tr></tbody></table><p><strong>在iptables命令后添加-L参数查看已有的防火墙规则链：</strong></p><pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination ACCEPT all -- anywhere anywhere ctstate RELATED,ESTABLISHEDACCEPT all -- anywhere anywhere INPUT_direct all -- anywhere anywhere INPUT_ZONES_SOURCE all -- anywhere anywhere INPUT_ZONES all -- anywhere anywhere ACCEPT icmp -- anywhere anywhere REJECT all -- anywhere anywhere reject-with icmp-host-prohibited………………省略部分输出信息………………</code></pre><p>在iptables命令后添加-F参数清空已有的防火墙规则链：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -F[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination ………………省略部分输出信息………………</code></pre><p>把INPUT规则链的默认策略设置为拒绝：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -P INPUT DROP[root@linuxprobe ~]# iptables -LChain INPUT (policy DROP)target prot opt source destination …………省略部分输出信息………………</code></pre><p>如前面所提到的防火墙策略设置无非有两种方式，一种是“通”，一种是“堵”，当把INPUT链设置为默认拒绝后，就要往里面写入允许策略了，否则所有流入的数据包都会被默认拒绝掉，同学们需要留意规则链的默认策略拒绝动作只能是DROP，而不能是REJECT。</p><p><strong>向INPUT链中添加允许ICMP流量进入的策略规则：</strong></p><p>在日常运维工作中，经常会使用ping命令来检查对方主机是否在线，而向防火墙的INPUT规则链中添加一条允许ICMP流量进入的策略规则就默认允许了这种ping命令检测行为。</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -I INPUT -p icmp -j ACCEPT[root@linuxprobe ~]# ping -c 4 192.168.10.10PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.64 bytes from 192.168.10.10: icmp_seq=1 ttl=64 time=0.156 ms64 bytes from 192.168.10.10: icmp_seq=2 ttl=64 time=0.117 ms64 bytes from 192.168.10.10: icmp_seq=3 ttl=64 time=0.099 ms64 bytes from 192.168.10.10: icmp_seq=4 ttl=64 time=0.090 ms--- 192.168.10.10 ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 2999msrtt min/avg/max/mdev = 0.090/0.115/0.156/0.027 ms</code></pre><p><strong>删除INPUT规则链中刚刚加入的那条策略（允许ICMP流量），并把默认策略设置为允许：</strong></p><pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -D INPUT 1[root@linuxprobe ~]# iptables -P INPUT ACCEPT[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination………………省略部分输出信息………………</code></pre><p><strong>将INPUT规则链设置为只允许指定网段的主机访问本机的22端口，拒绝来自其他所有主机的流量：</strong></p><pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -I INPUT -s 192.168.10.0/24 -p tcp --dport 22 -j ACCEPT[root@linuxprobe ~]# iptables -A INPUT -p tcp --dport 22 -j REJECT[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:sshREJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable………………省略部分输出信息………………</code></pre><p><strong>向INPUT规则链中添加拒绝所有人访问本机12345端口的策略规则：</strong></p><pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -I INPUT -p tcp --dport 12345 -j REJECT[root@linuxprobe ~]# iptables -I INPUT -p udp --dport 12345 -j REJECT[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination REJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachableREJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachableACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:sshREJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable………………省略部分输出信息………………</code></pre><p><strong>向INPUT规则链中添加拒绝192.168.10.5主机访问本机80端口（Web服务）的策略规则：</strong></p><pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination REJECT tcp -- 192.168.10.5 anywhere tcp dpt:http reject-with icmp-port-unreachableREJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachableREJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachableACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:sshREJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable………………省略部分输出信息………………</code></pre><p><strong>向INPUT规则链中添加拒绝所有主机访问本机1000～1024端口的策略规则：</strong></p><pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -A INPUT -p tcp --dport 1000:1024 -j REJECT[root@linuxprobe ~]# iptables -A INPUT -p udp --dport 1000:1024 -j REJECT[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination REJECT tcp -- 192.168.10.5 anywhere tcp dpt:http reject-with icmp-port-unreachableREJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachableREJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachableACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:sshREJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachableREJECT tcp -- anywhere anywhere tcp dpts:cadlock2:1024 reject-with icmp-port-unreachableREJECT udp -- anywhere anywhere udp dpts:cadlock2:1024 reject-with icmp-port-unreachable</code></pre><h5 id="允许某个ip某个端口访问"><a class="markdownIt-Anchor" href="#允许某个ip某个端口访问"></a> 允许某个ip某个端口访问</h5><pre><code class="highlight plaintext">#拒绝所有iptables -I INPUT -p TCP --dport 80 -j DROP#允许46.166.150.22访问80端口iptables -I INPUT -s 46.166.150.22 -p TCP --dport 80 -j ACCEPT#--line-number参数会显示策略编号，该编号在删除策略时使用iptables -L -n --line-number#2是--line-number查到的，此句会删除第2条策略iptables -D INPUT 2</code></pre><h5 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h5><pre><code class="highlight plaintext">#增加，限制进iptables -A INPUT -p tcp -s 192.168.0.83 --sport 23 -j ACCEPT#增加，限制出iptables -A INPUT -p tcp -d 192.168.0.83 --dport 23 -j ACCEPT#删除iptables -D INPUT -p tcp -s 192.168.0.83 --sport 23 -j ACCEPT</code></pre><h4 id="firewalld"><a class="markdownIt-Anchor" href="#firewalld"></a> Firewalld</h4><p>RHEL 7系统中集成了多款防火墙管理工具，其中firewalld（Dynamic Firewall Manager of Linux systems，Linux系统的动态防火墙管理器）服务是默认的防火墙配置管理工具，它拥有基于CLI（命令行界面）和基于GUI（图形用户界面）的两种管理方式。</p><p>相较于传统的防火墙管理配置工具，firewalld支持动态更新技术并加入了区域（zone）的概念。简单来说，区域就是firewalld预先准备了几套防火墙策略集合（策略模板），用户可以根据生产场景的不同而选择合适的策略集合，从而实现防火墙策略之间的快速切换。例如，我们有一台笔记本电脑，每天都要在办公室、咖啡厅和家里使用。按常理来讲，这三者的安全性按照由高到低的顺序来排列，应该是家庭、公司办公室、咖啡厅。当前，我们希望为这台笔记本电脑指定如下防火墙策略规则：在家中允许访问所有服务；在办公室内仅允许访问文件共享服务；在咖啡厅仅允许上网浏览。在以往，我们需要频繁地手动设置防火墙策略规则，而现在只需要预设好区域集合，然后只需轻点鼠标就可以自动切换了，从而极大地提升了防火墙策略的应用效率。</p><p><strong>firewalld中常用的区域名称及策略规则</strong></p><table><thead><tr><th>区域</th><th>默认规则策略</th></tr></thead><tbody><tr><td>trusted</td><td>允许所有的数据包</td></tr><tr><td>home</td><td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关，则允许流量</td></tr><tr><td>internal</td><td>等同于home区域</td></tr><tr><td>work</td><td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、ipp-client与dhcpv6-client服务相关，则允许流量</td></tr><tr><td>public</td><td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、dhcpv6-client服务相关，则允许流量</td></tr><tr><td>external</td><td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td></tr><tr><td>dmz</td><td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td></tr><tr><td>block</td><td>拒绝流入的流量，除非与流出的流量相关</td></tr><tr><td>drop</td><td>拒绝流入的流量，除非与流出的流量相关</td></tr></tbody></table><h5 id="终端管理工具"><a class="markdownIt-Anchor" href="#终端管理工具"></a> 终端管理工具</h5><p>命令行终端是一种极富效率的工作方式，firewall-cmd是firewalld防火墙配置管理工具的CLI（命令行界面）版本。它的参数一般都是以“长格式”来提供的，大家不要一听到长格式就头大，因为RHEL 7系统支持部分命令的参数补齐，其中就包含这条命令（很酷吧）。也就是说，现在除了能用Tab键自动补齐命令或文件名等内容之外，还可以用Tab键来补齐表8-3中所示的长格式参数了。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>—get-default-zone</td><td>查询默认的区域名称</td></tr><tr><td>—set-default-zone=&lt;区域名称&gt;</td><td>设置默认的区域，使其永久生效</td></tr><tr><td>—get-zones</td><td>显示可用的区域</td></tr><tr><td>—get-services</td><td>显示预先定义的服务</td></tr><tr><td>—get-active-zones</td><td>显示当前正在使用的区域与网卡名称</td></tr><tr><td>—add-source=</td><td>将源自此IP或子网的流量导向指定的区域</td></tr><tr><td>—remove-source=</td><td>不再将源自此IP或子网的流量导向某个指定区域</td></tr><tr><td>—add-interface=&lt;网卡名称&gt;</td><td>将源自该网卡的所有流量都导向某个指定区域</td></tr><tr><td>—change-interface=&lt;网卡名称&gt;</td><td>将某个网卡与区域进行关联</td></tr><tr><td>—list-all</td><td>显示当前区域的网卡配置参数、资源、端口以及服务等信息</td></tr><tr><td>—list-all-zones</td><td>显示所有区域的网卡配置参数、资源、端口以及服务等信息</td></tr><tr><td>—add-service=&lt;服务名&gt;</td><td>设置默认区域允许该服务的流量</td></tr><tr><td>—add-port=&lt;端口号/协议&gt;</td><td>设置默认区域允许该端口的流量</td></tr><tr><td>—remove-service=&lt;服务名&gt;</td><td>设置默认区域不再允许该服务的流量</td></tr><tr><td>—remove-port=&lt;端口号/协议&gt;</td><td>设置默认区域不再允许该端口的流量</td></tr><tr><td>—reload</td><td>让“永久生效”的配置规则立即生效，并覆盖当前的配置规则</td></tr><tr><td>—panic-on</td><td>开启应急状况模式</td></tr><tr><td>—panic-off</td><td>关闭应急状况模式</td></tr></tbody></table><p>与Linux系统中其他的防火墙策略配置工具一样，使用firewalld配置的防火墙策略默认为运行时（Runtime）模式，又称为当前生效模式，而且随着系统的重启会失效。</p><p>如果想让配置策略一直存在，就需要使用永久（Permanent）模式了，方法就是在用firewall-cmd命令正常设置防火墙策略时添加—permanent参数，这样配置的防火墙策略就可以永久生效了。但是，永久生效模式有一个“不近人情”的特点，就是使用它设置的策略只有在系统重启之后才能自动生效。</p><p>如果想让配置的策略立即生效，需要手动执行firewall-cmd —reload命令。</p><p>查看firewalld服务当前所使用的区域：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --get-default-zonepublic</code></pre><p>查询eno16777728网卡在firewalld服务中的区域：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --get-zone-of-interface=eno16777728public</code></pre><p>把firewalld服务中eno16777728网卡的默认区域修改为external，并在系统重启后生效。分别查看当前与永久模式下的区域名称：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --permanent --zone=external --change-interface=eno16777728success[root@linuxprobe ~]# firewall-cmd --get-zone-of-interface=eno16777728public[root@linuxprobe ~]# firewall-cmd --permanent --get-zone-of-interface=eno16777728external</code></pre><p>把firewalld服务的当前默认区域设置为public：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --set-default-zone=publicsuccess[root@linuxprobe ~]# firewall-cmd --get-default-zonepublic</code></pre><p>启动/关闭firewalld防火墙服务的应急状况模式，阻断一切网络连接（当远程控制服务器时请慎用）：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --panic-onsuccess[root@linuxprobe ~]# firewall-cmd --panic-offsuccess</code></pre><p>查询public区域是否允许请求SSH和HTTPS协议的流量：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=sshyes[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=httpsno</code></pre><p>把firewalld服务中请求HTTPS协议的流量设置为永久允许，并立即生效：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --zone=public --add-service=httpssuccess[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-service=httpssuccess[root@linuxprobe ~]# firewall-cmd --reloadsuccess</code></pre><p>把firewalld服务中请求HTTP协议的流量设置为永久拒绝，并立即生效：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --remove-service=http success[root@linuxprobe ~]# firewall-cmd --reload success</code></pre><p>把在firewalld服务中访问8080和8081端口的流量策略设置为允许，但仅限当前生效：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --zone=public --add-port=8080-8081/tcpsuccess[root@linuxprobe ~]# firewall-cmd --zone=public --list-ports 8080-8081/tcp</code></pre><p><strong>把原本访问本机888端口的流量转发到22端口，要且求当前和长期均有效：</strong></p><ul><li>流量转发命令格式为firewall-cmd —permanent —zone=&lt;区域&gt; —add-forward-port=port=&lt;源端口号&gt;:proto=&lt;协议&gt;:toport=&lt;目标端口号&gt;:toaddr=&lt;目标IP地址&gt;</li></ul><pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-forward-port=port=888:proto=tcp:toport=22:toaddr=192.168.10.10success[root@linuxprobe ~]# firewall-cmd --reloadsuccess</code></pre><p>在客户端使用ssh命令尝试访问192.168.10.10主机的888端口：</p><pre><code class="highlight plaintext">[root@client A ~]# ssh -p 888 192.168.10.10The authenticity of host &#x27;[192.168.10.10]:888 ([192.168.10.10]:888)&#x27; can&#x27;t be established.ECDSA key fingerprint is b8:25:88:89:5c:05:b6:dd:ef:76:63:ff:1a:54:02:1a.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &#x27;[192.168.10.10]:888&#x27; (ECDSA) to the list of known hosts.root@192.168.10.10&#x27;s password:此处输入远程root管理员的密码Last login: Sun Jul 19 21:43:48 2017 from 192.168.10.10</code></pre><p>firewalld中的富规则表示更细致、更详细的防火墙策略配置，它可以针对系统服务、端口号、源地址和目标地址等诸多信息进行更有针对性的策略配置。它的优先级在所有的防火墙策略中也是最高的。比如，我们可以在firewalld服务中配置一条富规则，使其拒绝192.168.10.0/24网段的所有用户访问本机的ssh服务（22端口）：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.10.0/24&quot; service name=&quot;ssh&quot; reject&quot;success[root@linuxprobe ~]# firewall-cmd --reloadsuccess</code></pre><h5 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例</h5><pre><code class="highlight plaintext">#增加规则firewall-cmd --permanent --direct --add-rule ipv4/ipv6 filter OUTPUT 0 -p tcp --dport 1:65535 -d 0.0.0.0/0 -j DROPfirewall-cmd --permanent --direct --add-rule ipv4/ipv6 filter INPUT 0 -p tcp --sport 1:65535 -s 0.0.0.0/0 -j DROP#删除规则firewall-cmd --permanent --direct --remove-rule ipv4/ipv6 filter INPUT 0 -p tcp --sport 1:65535 -s 0.0.0.0/0 -j DROP</code></pre><h5 id="图形管理工具"><a class="markdownIt-Anchor" href="#图形管理工具"></a> 图形管理工具</h5><p><strong>firewall-config</strong>是firewalld防火墙配置管理工具的GUI（图形用户界面）版本，几乎可以实现所有以命令行来执行的操作。毫不夸张的说，即使读者没有扎实的Linux命令基础，也完全可以通过它来妥善配置RHEL 7中的防火墙策略。</p><pre><code class="highlight plaintext">$ firewall-config</code></pre><p><img src="image/-26.png" alt="-26.png" /></p><blockquote><p>在使用firewall-config工具配置完防火墙策略之后，无须进行二次确认，因为只要有修改内容，它就自动进行保存</p></blockquote><p>实例（配置8080-8088的http请求允许访问）：</p><ul><li>我们先将当前区域中请求http服务的流量设置为允许，但仅限当前生效<br /><img src="image/-27.png" alt="-27.png" /></li><li>尝试添加一条防火墙策略规则，使其放行访问8080～8088端口（TCP协议）的流量，并将其设置为永久生效，以达到系统重启后防火墙策略依然生效的目的<br /><img src="image/-28.png" alt="-28.png" /></li><li>配置完毕之后，还需要在Options菜单中单击Reload Firewalld命令，让配置的防火墙策略立即生效<br /><img src="image/-29.png" alt="-29.png" /></li></ul><p>实例2（使用SNAT技术处理过的网络）</p><ul><li>前面在讲解firewall-config工具的功能时，曾经提到了SNAT（Source Network Address Translation，源网络地址转换）技术。SNAT是一种为了解决IP地址匮乏而设计的技术，它可以使得多个内网中的用户通过同一个外网IP接入Internet。</li><li>大家可以看一下在网络中不使用SNAT技术（见图1）和使用SNAT技术（见图2）时的情况。<ul><li>在图1所示的局域网中有多台PC，如果网关服务器没有应用SNAT技术，则互联网中的网站服务器在收到PC的请求数据包，并回送响应数据包时，将无法在网络中找到这个私有网络的IP地址，所以PC也就收不到响应数据包了。</li><li>在图2所示的局域网中，由于网关服务器应用了SNAT技术，所以互联网中的网站服务器会将响应数据包发给网关服务器，再由后者转发给局域网中的PC。</li><li><img src="image/-30.png" alt="-30.png" /></li></ul></li><li>使用iptables命令实现SNAT技术是一件很麻烦的事情，但是在firewall-config中却是小菜一碟了。用户只需按照图8-8进行配置，并选中Masquerade zone复选框，就自动开启了SNAT技术。<img src="image/-31.png" alt="-31.png" /></li></ul><p>实例3：</p><ul><li>为了让大家直观查看不同工具在实现相同功能的区别，这里使用firewall-config工具重新演示了前面使用firewall-cmd来配置防火墙策略规则，将本机888端口的流量转发到22端口，且要求当前和长期均有效<img src="image/-32.png" alt="-32.png" /></li><li>让防火墙策略立即生效</li><li><img src="image/-33.png" alt="-33.png" /></li></ul><p>实例4：</p><ul><li>配置富规则，让192.168.10.20主机访问到本机的1234端口号<br /><img src="image/-34.png" alt="-34.png" /></li></ul><h3 id="开放指定端口"><a class="markdownIt-Anchor" href="#开放指定端口"></a> 开放指定端口</h3><pre><code class="highlight plaintext">1、开启防火墙 systemctl start firewalld2、开放指定端口firewall-cmd --zone=public --add-port=1935/tcp --permanent 命令含义：--zone #作用域--add-port=1935/tcp  #添加端口，格式为：端口/通讯协议--permanent  #永久生效，没有此参数重启后失效3、重启防火墙firewall-cmd --reload4、查看端口号netstat -ntlp   //查看当前所有tcp端口·netstat -ntulp |grep 1935   //查看所有1935端口使用情况·</code></pre><h3 id="服务的访问控制列表"><a class="markdownIt-Anchor" href="#服务的访问控制列表"></a> 服务的访问控制列表</h3><p>TCP Wrappers是RHEL 7系统中默认启用的一款流量监控程序，它能够根据来访主机的地址与本机的目标服务程序作出允许或拒绝的操作。换句话说，Linux系统中其实有两个层面的防火墙，第一种是前面讲到的基于TCP/IP协议的流量过滤工具，而TCP Wrappers服务则是能允许或禁止Linux系统提供服务的防火墙，从而在更高层面保护了Linux系统的安全运行。</p><p>TCP Wrappers服务的防火墙策略由两个控制列表文件所控制，用户可以编辑允许控制列表文件来放行对服务的请求流量，也可以编辑拒绝控制列表文件来阻止对服务的请求流量。控制列表文件修改后会立即生效，系统将会先检查<strong>允许控制列表文件（/etc/hosts.allow）</strong>，如果匹配到相应的允许策略则放行流量；如果没有匹配，则去进一步匹配<strong>拒绝控制列表文件（/etc/hosts.deny）</strong>，若找到匹配项则拒绝该流量。如果这两个文件全都没有匹配到，则默认放行流量。</p><table><thead><tr><th>客户端类型</th><th>示例</th><th>满足示例的客户端列表</th></tr></thead><tbody><tr><td>单一主机</td><td>192.168.10.10</td><td>IP地址为192.168.10.10的主机</td></tr><tr><td>指定网段</td><td>192.168.10.</td><td>IP段为192.168.10.0/24的主机</td></tr><tr><td>指定网段</td><td>192.168.10.0/255.255.255.0</td><td>IP段为192.168.10.0/24的主机</td></tr><tr><td>指定DNS后缀</td><td>.linuxprobe.com</td><td>所有DNS后缀为.linuxprobe.com的主机</td></tr><tr><td>指定主机名称</td><td><a href="http://www.linuxprobe.com">www.linuxprobe.com</a></td><td>主机名称为www.linuxprobe.com的主机</td></tr><tr><td>指定所有客户端</td><td>ALL</td><td>所有主机全部包括在内</td></tr></tbody></table><p>在配置TCP Wrappers服务时需要遵循两个原则：</p><ul><li>编写拒绝策略规则时，填写的是服务名称，而非协议名称；</li><li>建议先编写拒绝策略规则，再编写允许策略规则，以便直观地看到相应的效果。</li></ul><p>下面编写拒绝策略规则文件，禁止访问本机sshd服务的所有流量（无须/etc/hosts.deny文件中修改原有的注释信息）</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# vim /etc/hosts.deny## hosts.deny This file contains access rules which are used to# deny connections to network services that either use# the tcp_wrappers library or that have been# started through a tcp_wrappers-enabled xinetd.## The rules in this file can also be set up in# /etc/hosts.allow with a &#x27;deny&#x27; option instead.## See &#x27;man 5 hosts_options&#x27; and &#x27;man 5 hosts_access&#x27;# for information on rule syntax.# See &#x27;man tcpd&#x27; for information on tcp_wrapperssshd:*[root@linuxprobe ~]# ssh 192.168.10.10ssh_exchange_identification: read: Connection reset by peer</code></pre><p>接下来，在允许策略规则文件中添加一条规则，使其放行源自192.168.10.0/24网段，访问本机sshd服务的所有流量。可以看到，服务器立刻就放行了访问sshd服务的流量，效果非常直观：</p><pre><code class="highlight plaintext">[root@linuxprobe ~]# vim /etc/hosts.allow## hosts.allow This file contains access rules which are used to# allow or deny connections to network services that# either use the tcp_wrappers library or that have been# started through a tcp_wrappers-enabled xinetd.## See &#x27;man 5 hosts_options&#x27; and &#x27;man 5 hosts_access&#x27;# for information on rule syntax.# See &#x27;man tcpd&#x27; for information on tcp_wrapperssshd:192.168.10.[root@linuxprobe ~]# ssh 192.168.10.10The authenticity of host &#x27;192.168.10.10 (192.168.10.10)&#x27; can&#x27;t be established.ECDSA key fingerprint is 70:3b:5d:37:96:7b:2e:a5:28:0d:7e:dc:47:6a:fe:5c.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &#x27;192.168.10.10&#x27; (ECDSA) to the list of known hosts.root@192.168.10.10&#x27;s password: Last login: Wed May 4 07:56:29 2017[root@linuxprobe ~]#</code></pre><h2 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h2><h3 id="dirnamebasename截取路径"><a class="markdownIt-Anchor" href="#dirnamebasename截取路径"></a> dirname/basename(截取路径)</h3><p><strong>dirname</strong> 命令去除文件名中的非目录部分，删除最后一个“\”后面的路径，显示父目录。</p><p>语法：</p><pre><code class="highlight plaintext">dirname [选项] 参数</code></pre><p>实例：</p><pre><code class="highlight plaintext">[root@adm182 t3]# dirname /opt/data/files/outputfiles/libo/t3/SDM_TEST_NEW_SENSITIVE.txt/opt/data/files/outputfiles/libo/t3</code></pre><hr /><p><strong>basename</strong> 命令用于打印目录或者文件的基本名称，显示最后的目录名或文件名。</p><p>语法：</p><pre><code class="highlight plaintext">basename [选项] 参数</code></pre><p>实例：</p><pre><code class="highlight plaintext">[root@adm182 t3]# basename /opt/data/files/outputfiles/libo/t3/SDM_TEST_NEW_SENSITIVE.txtSDM_TEST_NEW_SENSITIVE.txt</code></pre><h3 id="w3m"><a class="markdownIt-Anchor" href="#w3m"></a> w3m</h3><p>安装：</p><pre><code class="highlight plaintext">yum -y install epel-releaseyum -y install w3m</code></pre><p>使用：</p><pre><code class="highlight plaintext">w3m www.baidu.com</code></pre><p><img src="image/-35.png" alt="-35.png" /></p><p>页面操作：</p><table><thead><tr><th>操作</th><th>快捷键</th></tr></thead><tbody><tr><td><strong>向下翻页</strong></td><td>Space,C-v</td></tr><tr><td>向上翻页</td><td>b,ESC v</td></tr><tr><td>焦点向右</td><td>l,C-f</td></tr><tr><td>焦点向左</td><td>h,C-b</td></tr><tr><td>焦点向下</td><td>j,C-n</td></tr><tr><td>焦点向上</td><td>k,C-p</td></tr><tr><td>向下滚动一行</td><td>J</td></tr><tr><td>向上滚动一行</td><td>K</td></tr><tr><td>到行首</td><td>^,C-a</td></tr><tr><td>到行尾</td><td>$,C-e</td></tr><tr><td>到下一个单词</td><td>w</td></tr><tr><td>到上一个单词</td><td>W</td></tr><tr><td>右移一屏</td><td>&gt;</td></tr><tr><td>左移一屏</td><td>&lt;</td></tr><tr><td>屏幕右移一列</td><td>.</td></tr><tr><td>屏幕左移一列</td><td>,</td></tr><tr><td>到首行</td><td>g,M-&lt;</td></tr><tr><td>到末行</td><td>G,M-&gt;</td></tr><tr><td>到指定行</td><td>ESC g</td></tr><tr><td>当前行居中</td><td>Z</td></tr><tr><td>当前列居中</td><td>z</td></tr><tr><td>转到下个超链接</td><td>TAB</td></tr><tr><td>到上个超链接</td><td>C-u,ESC TAB</td></tr><tr><td>到第一个超链接</td><td>[</td></tr><tr><td>到最后一个超链接</td><td>]</td></tr><tr><td>询问退出/直接退出</td><td>q/Q</td></tr></tbody></table><p>超链接操作：</p><table><thead><tr><th>操作</th><th>快捷键</th></tr></thead><tbody><tr><td>打开超链接</td><td>Enter</td></tr><tr><td>链接另存为</td><td>a, ESC Enter</td></tr><tr><td>查看链接</td><td>url u</td></tr><tr><td>查看图片</td><td>url i</td></tr><tr><td>查看图片</td><td>I</td></tr><tr><td>图片另存为</td><td>ESC I</td></tr><tr><td>标记字符串为锚点</td><td>:</td></tr><tr><td>查看当前页面的 URL</td><td>c</td></tr><tr><td>显示当前页面属性</td><td>=</td></tr><tr><td>查看当前行号</td><td>C-g</td></tr><tr><td>查看历史记录</td><td>C-h</td></tr><tr><td>提交表单</td><td>F</td></tr><tr><td>用外部浏览器打开当前页面</td><td>M</td></tr><tr><td>用外部浏览器打开链接</td><td>ESC M</td></tr><tr><td>标记 ID 串为锚点</td><td>ESC</td></tr></tbody></table><p>文件流操作</p><table><thead><tr><th>操作</th><th>快捷键</th></tr></thead><tbody><tr><td>打开 URL</td><td>U</td></tr><tr><td>打开文件</td><td>V</td></tr><tr><td>执行外部命令并导入</td><td>@</td></tr><tr><td>执行外部命令并浏览</td><td>#</td></tr></tbody></table><p>缓存操作</p><table><thead><tr><th>操作</th><th>快捷键</th></tr></thead><tbody><tr><td>返回</td><td>B</td></tr><tr><td>查看源代码</td><td>v</td></tr><tr><td>选择缓存</td><td>s</td></tr><tr><td>编辑缓存代码</td><td>E</td></tr><tr><td>重画屏幕</td><td>C-l</td></tr><tr><td>刷新</td><td>R</td></tr><tr><td>页面另存为</td><td>S</td></tr><tr><td>源码另存为</td><td>ESC s</td></tr><tr><td>编辑图片</td><td>ESC e</td></tr></tbody></table><p>标签操作</p><table><thead><tr><th>操作</th><th>快捷键</th></tr></thead><tbody><tr><td>在新标签页打开链接</td><td>Ctrl-t</td></tr><tr><td>关闭当前标签</td><td>Ctrl-q</td></tr><tr><td>跳到下一个标签</td><td>}</td></tr><tr><td>跳到前一个标签</td><td>{</td></tr></tbody></table><h3 id="split"><a class="markdownIt-Anchor" href="#split"></a> split</h3><p>Linux split命令用于将一个文件分割成数个。该指令将大文件分割成较小的文件，在默认情况下将按照每1000行切割成一个小文件。</p><p>语法：</p><pre><code class="highlight plaintext">split [--help][--version][-&lt;行数&gt;][-b &lt;字节&gt;][-C &lt;字节&gt;][-l &lt;行数&gt;][要切割的文件][输出文件名]</code></pre><p>参数：</p><ul><li>-&lt;行数&gt; : 指定每多少行切成一个小文件</li><li>-b&lt;字节&gt; : 指定每多少字节切成一个小文件</li><li>–help : 在线帮助</li><li>–version : 显示版本信息</li><li>-C&lt;字节&gt; : 与参数&quot;-b&quot;相似，但是在切 割时将尽量维持每行的完整性</li><li>[输出文件名] : 设置切割后文件的前置文件名， split会自动在前置文件名后再加上编号</li></ul><p>示例：</p><pre><code class="highlight plaintext">模式一：指定分割后文件行数对与txt文本文件，可以通过指定分割后文件的行数来进行文件分割。split -l 300 large_file.txt new_file_prefix模式二：指定分割后文件大小split -b 10m server.log waynelog</code></pre><p><strong>合并方式</strong></p><pre><code class="highlight plaintext">cat small_files* &gt; large_file</code></pre><h3 id="cpulimit"><a class="markdownIt-Anchor" href="#cpulimit"></a> cpulimit</h3><p>Cpulimit 是一个<strong>限制进程的CPU使用率</strong>的工具</p><h4 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h4><p><strong>网络安�</strong>�</p><p>CPULimit 并不是系统自带的工具，使用前要先安装。在 <strong>Debian 或 Ubuntu</strong> 系列的 Linux 中，可以使用 apt 来安装：</p><pre><code class="highlight plaintext">apt-get install cpulimit</code></pre><p>若在 <strong>CentOS、RHEL</strong> 或者是 Fedora Linux 中，可在启用 EPEL 套件库后，再以 yum 安装：</p><pre><code class="highlight plaintext">yum -y install cpulimit</code></pre><p><strong>编译安�</strong>�</p><pre><code class="highlight plaintext">wget -O cpulimit.zip https://github.com/opsengine/cpulimit/archive/master.zipunzip cpulimit.zipcd cpulimit-mastermakesudo cp src/cpulimit /usr/bin</code></pre><h4 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h4><pre><code class="highlight plaintext">#限制进程名cpulimit -e httpd -l 40 #限制httpd（进程名）的cpu使用率为40%#限制路径cpulimit -e /usr/local/bin/httpd -l 40#限制pidcpulimit -p 2960 -l 55 #限制pid为2960的进程的CPU占用为55%#直接使用cpulimit启动进程#md5sum /dev/urandom为测试程序，模拟cpu跑满的场景cpulimit --limit 50 -- md5sum /dev/urandomcpulimit --limit 50 -- /opt/adm/sdm/jdk/bin/java -jar /opt/adm/sdm/sdm_server-5.0.0.jar</code></pre><p><strong>后台运行</strong></p><p>cpulimit 在执行时也会占用一个终端机，若想让 cpulimit 在后台运行，可加上 --background 参数：</p><pre><code class="highlight plaintext">cpulimit --pid 21203 --limit 50 --background</code></pre><p><strong>过高关闭</strong></p><p>cpulimit 配合 --limit 参数可以限制进程的 CPU 用量上限值，如果进程超过这个上限值，预设会调节 CPU 用量，而如果想要在 CPU 用量过高时直接中止进程，可以加上 –-kill 参数：</p><pre><code class="highlight plaintext">cpulimit --pid 21203 --limit 50 --kill</code></pre><p><strong>自动离开</strong></p><p>在默认的状况下，cpulimit 在执行时若没有发现指定的进程（或是指定的进程已经中止了），它还是会持续等待并监控系统的进程，只要有发现符合条件的进程，就会继续进行 CPU 用量的控制。若想让 cpulimit 在找不到目标进程时自动离开，可以加上 --lazy 参数：</p><pre><code class="highlight plaintext">cpulimit --exe md5sum --limit 50 --lazy</code></pre><p><strong>使用例子</strong></p><p>在撰写 bash 脚本时，我们可以先执行一个进程，紧接着从 bash 的 $! 变量读取出前一个执行进程的 PID，这样就可以不需要手动查出进程的 PID 了：</p><pre><code class="highlight plaintext"># 运行进程md5sum /dev/urandom &amp;# 限制上一个进程的 CPU 用量cpulimit --pid $! --limit 50</code></pre>]]>
    </content>
    <id>http://example.com/2022/12/12/Linux/</id>
    <link href="http://example.com/2022/12/12/Linux/"/>
    <published>2022-12-12T05:00:00.000Z</published>
    <summary>本文详细介绍了Linux的核心概念、常用命令，权限，系统命令，归档备份，网络系统，vim，程序管理，环境变量，管道符，重定向，磁盘。</summary>
    <title>Linux</title>
    <updated>2026-02-26T08:53:45.746Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    <content>
      <![CDATA[<h1 id="jvm"><a class="markdownIt-Anchor" href="#jvm"></a> $JVM</h1><h1 id="jvm-2"><a class="markdownIt-Anchor" href="#jvm-2"></a> JVM</h1><ul><li><a href="">JVM</a><ul><li><a href="">JVM概述</a><ul><li><a href="">JVM常识</a></li><li><a href="">JVM分类</a></li><li><a href="">HotSpot</a></li><li><a href="">JVM架构理解</a></li><li><a href="">JIT即时编译器</a></li><li><a href="">JIT编译器优化</a></li></ul></li><li><a href="">CLASS文件</a><ul><li><a href="">class文件概述</a></li><li><a href="">class常量池理解</a></li><li><a href="">class文件中的应用和特殊字符串</a></li></ul></li><li><a href="">类加载子系统</a><ul><li><a href="">JVM程序执行流程</a></li><li><a href="">类加载过程</a></li><li><a href="">类加载的时机</a></li><li><a href="">类加载器</a></li><li><a href="">自定义类加载器</a></li><li><a href="">双亲委派模型</a></li><li><a href="">破坏双亲委派模型</a></li></ul></li><li><a href="">运行时数据区</a><ul><li><a href="">程序计数器</a></li><li><a href="">Java虚拟机栈</a><ul><li><a href="">栈帧</a></li><li><a href="">局部变量表</a></li><li><a href="">操作数栈</a></li><li><a href="">动态连接</a></li><li><a href="">方法返回</a></li><li><a href="">附加信息/栈异常</a></li></ul></li><li><a href="">本地方法栈</a><ul><li><a href="">介绍</a></li><li><a href="">使用流程</a></li></ul></li><li><a href="">Java内存模型</a></li><li><a href="">JVM调优</a><ul><li><a href="">取消伸缩区</a></li><li><a href="">GC处理流程</a></li><li><a href="">查看垃圾回收</a></li><li><a href="">内存回收算法</a></li></ul></li><li><a href="">Java堆</a><ul><li><a href="">堆分类</a></li><li><a href="">对象创建</a></li><li><a href="">内存分配</a></li><li><a href="">对象的访问</a></li><li><a href="">数组内存分析</a></li></ul></li><li><a href="">方法区</a><ul><li><a href="">永久代、方法区、元空间的关系</a></li><li><a href="">PermGen(永久代)</a></li><li><a href="">Metaspace(元空间)</a></li></ul></li><li><a href="">运行时常量池/字符串常量�</a>�</li></ul></li><li><a href="">JVM如何运行字节码</a></li><li><a href="">JVM堆溢出分析</a><ul><li><a href="">jconsole内存监控工具</a></li><li><a href="">jmap内存分析工具</a></li></ul></li><li><a href="">JVM远程debug</a></li></ul></li></ul><h2 id="jvm概述"><a class="markdownIt-Anchor" href="#jvm概述"></a> JVM概述</h2><h3 id="jvm常识"><a class="markdownIt-Anchor" href="#jvm常识"></a> JVM常识</h3><p><strong>程序的执行方式有哪些？</strong></p><ul><li>主要有三种：<strong>静态编译执行</strong>、<strong>动态编译执行</strong>和<strong>动态解释执行</strong></li></ul><blockquote><p>注意：此处所说的编译指的是编译成可让操作系统直接执行的机器码</p></blockquote><hr /><p><strong>字节码和机器码的区别？</strong></p><p>机器码是电脑CPU直接读取运行的机器指令，运行速度最快，但是非常晦涩难懂，也比较难编写，一般从业人员接触不到。</p><p>字节码是一种中间状态（中间码）的二进制代码（文件）。需要直译器转译后才能成为机器码</p><hr /><p><strong>JDK,JRE与JVM的关系是？</strong></p><hr /><p><strong>OracleJDK和openJDK的关系是？</strong></p><p>查看JDK的版本</p><pre><code class="highlight plaintext">java -version</code></pre><ul><li>如果是SUN/OracleJDK，显示信息为</li></ul><blockquote><p><code>Java HotSpot(TM) 64-Bit Server VM</code>表明，此JDK的JVM是Oracle的64位的HotSpot虚拟机；运行在Server模式下(虚拟机有Server和Client两种运行模式).</p></blockquote><blockquote><p><code>Java(TM) SE Runtime Environment (build 1.8.0_162-b12)</code> 是Java运行时环境(即JRE)的版本信息.</p></blockquote><ul><li>如果是OpenJDK，显示信息为：</li></ul><pre><code class="highlight plaintext">[root@localhost ~]# java -versionopenjdk version &quot;1.8.0_144&quot;OpenJDK Runtime Environment (build 1.8.0_144-b01)OpenJDK 64-Bit Server VM (build 25.144-b01, mixed mode)</code></pre><hr /><p><strong>什么是OpenJDK</strong></p><p>Sun发布的OpenJDK是一款只能运行在i386和AMD-64机器上的软件</p><ul><li><strong>OpenJDK 的来历</strong></li></ul><p>Java由SUN公司(Sun Microsystems, 发起于美国斯坦福大学, SUN是Stanford University Network的缩写)发明, 2006年SUN公司将Java开源, 此时的JDK即为OpenJDK.</p><p>也就是说, OpenJDK是Java SE的开源实现, 它由SUN和Java社区提供支持, 2009年Oracle收购了Sun公司,自此Java的维护方之一的SUN也变成了Oracle</p><p>大多数JDK都是在OpenJDK的基础上编写实现的, 比如IBM J9, Azul Zulu, Azul Zing和Oracle JDK. 几乎所有的所有JDK都派生自OpenJDK, 它们之间不同的是许可证:</p><blockquote><p>OpenJDK根据许可证GPL v2发布;</p></blockquote><blockquote><p>Oracle JDK根据Oracle二进制代码许可协议获得许可.</p></blockquote><ul><li><strong>OracleJDK的来历</strong></li></ul><p>Oracle JDK之前被称为SUN JDK, 这是在2009年Oracle收购SUN公司之前, 收购后被命名为Oracle JDK.</p><p>实际上, Oracle JDK是基于OpenJDK源代码构建的, 因此Oracle JDK和OpenJDK之间没有重大的技术差异.</p><p>Oracle的项目发布经理Joe Darcy在OSCON 2011 上对两者关系的介绍也证实了OpenJDK 7和Oracle JDK 7在程序上是非常接近的, 两者共用了大量相同的代码(如下图), 注意: 图中提示了两者共同代码的占比要远高于图形上看到的比例, 所以我们编译的OpenJDK基本上可以认为性能、功能和执行逻辑上都和官方的Oracle JDK是一致的.</p><ul><li><strong>Oracle JDK与OpenJDK的区别</strong></li></ul><blockquote><p>OpenJDK使用的是开源免费的FreeType, 可以按照GPL v2许可证使用.GPL V2允许在商业上使用;</p></blockquote><blockquote><p>Oracle JDK则采用JRL(Java Research License, Java研究授权协议) 放出.JRL只允许个人研究使用,要获得Oracle JDK的商业许可证, 需要联系Oracle的销售人员进行购买</p></blockquote><hr /><p><strong>JRockit是Oracle的JVM, 从Java SE 7开始, HotSpot和JRockit合并为一个JVM</strong>.</p><ul><li><strong>JVM和Hotspot的关系是什么？</strong></li></ul><p>JVM是《JVM虚拟机规范》中提出来的规范</p><p>Hotspot是使用JVM规范的商用产品，除此之外还有Oracle JRockit、IBM的J9也是JVM产品</p><ul><li><p><strong>JVM和Java的关系是什么？</strong></p></li><li><p><strong>JVM的client运行模式和server运行模式的区别是什么？</strong></p></li></ul><p>JVM有两种运行模式<strong>Server</strong>与<strong>Client</strong>。</p><p>两种模式的区别在于，Client模式启动速度较快，Server模式启动较慢；但是启动进入稳定期长期运行之后Server模式的程序运行速度比Client要快很多。这是因为Server模式启动的JVM采用的是重量级的虚拟机，对程序采用了更多的优化；而Client模式启动的JVM采用的是轻量级的虚拟机。所以Server启动慢，但稳定后速度比Client远远要快。</p><h3 id="jvm分类"><a class="markdownIt-Anchor" href="#jvm分类"></a> JVM分类</h3><ul><li>Java是直接通过指针进行的程序访问，所以他没有采用句柄的形式操作，这样使得程序的性能更高。</li><li>传统意义来讲，JVM一共分为三类（虚拟机是一个公共标准）<ul><li>SUN：从JDK1.2开始使用了HotSpot虚拟机标准（06年开源，利用C++实现，一些JNI部分使用的是系统提供的C程序实现的，JIT即使编译器）</li><li>BEA：使用了JRockit虚拟机标准，例如：WebLogic</li><li>IBM：开发了JVM’s(J9)虚拟机</li></ul></li><li>Oracle后来通过收购得到了：SUN与BEA，那么Oracle有了两个虚拟机标准</li></ul><h3 id="hotspot"><a class="markdownIt-Anchor" href="#hotspot"></a> HotSpot</h3><pre><code class="highlight plaintext">java -version</code></pre><p>获取信息：</p><pre><code class="highlight plaintext">java version &quot;1.8.0_201&quot;Java(TM) SE Runtime Environment (build 1.8.0_201-b09)Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)</code></pre><p><strong>虚拟机提供有三种处理模式：</strong></p><ul><li>混合模式：Java -version</li><li>[禁用JIT]纯解释模式：java Xint -version</li><li>纯编译模式：java -Xcomp -version</li></ul><p><strong>运行模式：</strong></p><ul><li>[client]客户端运行：启动速度快，但是中间程序的执行慢，占用内存小</li><li>[server]服务器端运行：启动速度慢，占用内存多，执行效率高</li></ul><p>修改路径：</p><pre><code class="highlight plaintext">D:\java1.8\jdk1.8.0_201\lib\jvm.cfg</code></pre><h3 id="jvm架构理解"><a class="markdownIt-Anchor" href="#jvm架构理解"></a> JVM架构理解</h3><p><strong>解析器与JIT即时编译器</strong></p><p>在部分商用虚拟机中（如HotSpot），Java程序最初是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为<strong>即时编译器</strong>（Just In Time Compiler，下文统称JIT编译器）</p><p>由于Java虚拟机规范并没有具体的约束规则去限制即使编译器应该如何实现，所以这部分功能完全是与虚拟机具体实现相关的内容，如无特殊说明，我们提到的编译器、即时编译器都是指Hotspot虚拟机内的即时编译器，虚拟机也是特指HotSpot虚拟机</p><p>我们的JIT是属于动态编译方式的，<strong>动态编译</strong>（dynamic compilation）指的是“在运行时进行编译”；与之相对的是事前编译（ahead-of-time compilation，简称AOT），也叫<strong>静态编译</strong>（staticcompilation）。</p><p>JIT编译（just-in-time compilation）狭义来说是当某段代码即将第一次被执行时进行编译，因而叫“即时编译”。<strong>JIT编译是动态编译的一种特例</strong>。JIT编译一词后来被泛化，时常与动态编译等价；但要注意广义与狭义的JIT编译所指的区别</p><hr /><p><strong>Java编译成字节码、动态编译和解释为机器码的过程分析：</strong></p><p><strong>编译器和解释器的协调工作流程：</strong></p><h3 id="jit即时编译器"><a class="markdownIt-Anchor" href="#jit即时编译器"></a> JIT即时编译器</h3><p><strong>为什么HotSpot虚拟机要使用解释器与编译器并存的架构？</strong></p><p>尽管并不是所有的Java虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚拟机（如HotSpot），都同时包含解释器和编译器。</p><hr /><p><strong>解释器与编译器两者各有优势：</strong></p><p>当程序需要<strong>迅速启动和执行</strong>的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取<strong>更高的执行效率</strong>。</p><p>当程序运行环境中<strong>内存资源限制较大</strong>（如部分嵌入式系统中），可以<strong>使用解释器执行节约内存</strong>，反之可以使用<strong>编译执行来提升效率</strong>。</p><hr /><p><strong>编译的时间开销</strong></p><p>解释器的执行，抽象的看是这样的：</p><ul><li>输入的代码 -&gt; [ 解释器 解释执行 ] -&gt; 执行结果</li></ul><p>而要JIT编译然后再执行的话，抽象的看则是：</p><ul><li>输入的代码 -&gt; [ 编译器 编译 ] -&gt; 编译后的代码 -&gt; [ 执行 ] -&gt; 执行结果</li></ul><blockquote><p>说JIT比解释快，其实说的是“执行编译后的代码”比“解释器解释执行”要快，并不是说“编译”这个动作比“解释”这个动作快。JIT编译再怎么快，至少也比解释执行一次略慢一些，而要得到最后的执行结果还得再经过一个“执行编译后的代码”的过程。所以，<strong>对“只执行一次”的代码而言，解释执行其实总是比JIT编译执行要快</strong></p></blockquote><hr /><p><strong>怎么算是“只执行一次的代码”呢？</strong></p><p>粗略说，下面两个条件同时满足时就是严格的“只执行一次”</p><p>1、只被调用一次，例如类的构造器（class initializer，()）</p><p>2、没有循环</p><p>对只执行一次的代码做JIT编译再执行，可以说是得不偿失。</p><p>对只执行少量次数的代码，JIT编译带来的执行速度的提升也未必能抵消掉最初编译带来的开销</p><blockquote><p><strong>只有对频繁执行的代码，JIT编译才能保证有正面的收益</strong></p></blockquote><hr /><p><strong>编译的空间开销</strong></p><p>对一般的Java方法而言，编译后代码的大小相对于class字节码的大小，膨胀比达到10x是很正常的。同上面说的时间开销一样，这里的空间开销也是，只有对执行频繁的代码才值得编译，如果把所有代码都编译则会显著增加代码所占空间，导致“代码爆炸”</p><blockquote><p><strong>这也就解释了为什么有些JVM会选择不总是做JIT编译，而是选择用解释器+JIT编译器的混合执行引擎</strong></p></blockquote><hr /><p><strong>为何HotSpot虚拟机要实现两个不同的即时编译器？</strong></p><p>HotSpot虚拟机中内置了两个即时编译器：<strong>Client Complier和Server Complier</strong>，简称为C1、C2编译器，分别用在客户端和服务端。</p><p>目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。<strong>程序使用哪个编译器，取决于虚拟机运行的模式</strong>。HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用</p><pre><code class="highlight plaintext">“-client”或“-server”</code></pre><p>参数去强制指定虚拟机运行在Client模式或Server模式。</p><p>用Client Complier获取更高的<strong>编译速度</strong>，用Server Complier 来获取更好的<strong>编译质量</strong>。为什么提供多个即时编译器与为什么提供多个垃圾收集器类似，都是为了适应不同的应用场景。</p><hr /><p><strong>哪些程序代码会被编译？</strong></p><p>程序中的代码只有是热点代码时，才会编译为本地代码，那么什么是热点代码呢？</p><p>运行过程中会被即时编译器编译的“热点代码”有两类：</p><ol><li>被多次调用的方法。</li><li>被多次执行的循环体。</li></ol><p>两种情况，编译器都是以<strong>整个方法</strong>作为编译对象。 这种编译方法因为编译发生在方法执行过程之中，因此形象的称之为栈上替换（On Stack Replacement，OSR），即方法栈帧还在栈上，方法就被替换了</p><hr /><p><strong>如何判断热点代码呢？</strong></p><p>要知道方法或一段代码是不是热点代码，是不是需要触发即时编译，需要进行Hot Spot Detection（热点探测）</p><p>目前主要的热点探测方式有以下两种：</p><p><strong>基于采样的热点探测</strong></p><ul><li><strong>采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这个方法就是“热点方法”</strong>。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可），缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li></ul><p><strong>基于计数器的热点探测</strong></p><ul><li><strong>采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”</strong>。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨。</li></ul><hr /><p><strong>HotSpot虚拟机中使用的是哪种热点检测方式呢？</strong></p><p>在HotSpot虚拟机中使用的是第二种,基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：<strong>方法调用计数器和回边计数器</strong>。在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译</p><p><strong>方法调用计数器</strong></p><p>顾名思义，这个计数器用于统计方法被调用的次数</p><p><strong>回边计数器</strong></p><p>它的作用就是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”。</p><hr /><p><strong>如何编译为本地代码？</strong></p><p>Server Compiler和Client Compiler两个编译器的编译过程是不一样的。</p><p>对Client Compiler来说，它是一个简单快速的编译器，主要关注点在于<strong>局部优化</strong>，而放弃许多耗时较长的全局优化手段。</p><p>而Server Compiler则是专门面向服务器端的，并为服务端的性能配置特别调整过的编译器，是一个<strong>充分优化</strong>过的高级编译器。</p><h3 id="jit编译器优化"><a class="markdownIt-Anchor" href="#jit编译器优化"></a> JIT编译器优化</h3><p>HotSpot 虚拟机使用了很多种优化技术，这里只简单介绍其中的几种，完整的优化技术介绍可以参考官网内容</p><p><strong>公共子表达式的消除</strong></p><p>公共子表达式消除是一个普遍应用于各种编译器的经典优化技术，他的含义是：如果一个表达式E已经计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成为了公共子表达式。对于这种表达式，没有必要花时间再对他进行计算，只需要直接用前面计算过的表达式结果代替E就可以了。如果这种优化仅限于程序的基本块内，便称为局部公共子表达式消除（Local Common Subexpression Elimination），如果这种优化范围涵盖了多个基本块，那就称为全局公共子表达式消除（Global Common Subexpression Elimination）。举个简单的例子来说明他的优化过程，假设存在如下代码：</p><pre><code class="highlight plaintext">int d = (c*b)*12+a+(a+b*c)</code></pre><p>如果这段代码交给Javac编译器则不会进行任何优化，那生成的代码如下所示，是完全遵照Java源码的写法直译而成的</p><pre><code class="highlight plaintext">iload_2 // bimul // 计算b*c bipush 12 // 推入12 imul // 计算(c*b)*12 iload_1 // aiadd // 计算(c*b)*12+a iload_1 // aiload_2 // biload_3 // cimul // 计算b*ciadd // 计算a+b*ciadd // 计算(c*b)*12+a+(a+b*c) istore 4</code></pre><p>当这段代码进入到虚拟机即时编译器后，他将进行如下优化：编译器检测到”cb“与”bc“是一样的表达式，而且在计算期间b与c的值是不变的。因此，这条表达式就可能被视</p><pre><code class="highlight plaintext">int d = E*12+a+(a+E);</code></pre><p>这时，编译器还可能（取决于哪种虚拟机的编译器以及具体的上下文而定）进行另外一种优化：代数化简（Algebraic Simpliﬁcation），把表达式变为：</p><pre><code class="highlight plaintext">int d = E*13+a*2;</code></pre><p>表达式进行变换之后，再计算起来就可以节省一些时间了</p><hr /><p><strong>方法内联</strong></p><p>在使用JIT进行即时编译时，将方法调用直接使用方法体中的代码进行替换，这就是方法内联，减少了方法调用过程中<strong>压栈与入栈</strong>的开销。同时为之后的一些优化手段提供条件。</p><p>如果JVM监测到一些小方法被频繁的执行，它会把方法的调用替换成方法体本身。比如说下面这个：</p><pre><code class="highlight plaintext">private int add4(int x1, int x2, int x3, int x4) &#123;    return add2(x1, x2) + add2(x3, x4);&#125;private int add2(int x1, int x2) &#123;    return x1 + x2;&#125;</code></pre><p>可以肯定的是运行一段时间后JVM会把add2方法去掉，并把你的代码翻译成：</p><pre><code class="highlight plaintext">private int add4(int x1, int x2, int x3, int x4) &#123;    return x1 + x2 + x3 + x4;&#125;</code></pre><hr /><p><strong>逃逸分析</strong></p><p>逃逸分析(Escape Analysis)是目前Java虚拟机中比较前沿的优化技术。这是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p><p><strong>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸</strong></p><p>逃逸分析包括：</p><ul><li>全局变量赋值逃逸</li><li>方法返回值逃逸</li><li>实例引用发生逃逸</li><li>线程逃逸:赋值给类变量或可以在其他线程中访问的实例变量</li></ul><pre><code class="highlight plaintext">public class EscapeAnalysis &#123;    public static Object object;    public void globalVariableEscape()&#123;//全局变量赋值逃逸       object =new Object();    &#125;    public Object methodEscape()&#123; //方法返回值逃逸       return new Object();    &#125;    public void instancePassEscape()&#123; //实例引用发生逃逸       this.speak(this);    &#125;    public void speak(EscapeAnalysis escapeAnalysis)&#123;       System.out.println(&quot;Escape Hello&quot;);    &#125;&#125;</code></pre><p>使用方法逃逸的案例进行分析：</p><pre><code class="highlight plaintext">public static StringBuffer craeteStringBuffer(String s1, String s2) &#123;    StringBuffer sb = new StringBuffer();    sb.append(s1);    sb.append(s2);    return sb;&#125;</code></pre><blockquote><p>StringBuffer sb是一个方法内部变量，上述代码中直接将sb返回，这样这个StringBuffer有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为<strong>线程逃逸</strong>。</p></blockquote><p>上述代码如果想要StringBuffer sb不逃出方法，可以这样写：</p><pre><code class="highlight plaintext">public static String createStringBuffer(String s1, String s2) &#123;    StringBuffer sb = new StringBuffer();    sb.append(s1);    sb.append(s2);    return sb.toString();&#125;</code></pre><blockquote><p>不直接返回 StringBuffer，那么StringBuffer将不会逃逸出方法</p></blockquote><p>使用逃逸分析，编译器可以对代码做如下优化：</p><blockquote><p>一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p></blockquote><blockquote><p>二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p></blockquote><blockquote><p>三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中</p></blockquote><p><strong>在Java代码运行时，通过JVM参数可指定是否开启逃逸分析</strong></p><pre><code class="highlight plaintext">-XX:+DoEscapeAnalysis ： 表示开启逃逸分析-XX:-DoEscapeAnalysis ： 表示关闭逃逸分析</code></pre><blockquote><p>从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis</p></blockquote><hr /><p><strong>对象的栈上内存分配</strong></p><p>我们知道，在<strong>一般情况下，对象和数组元素的内存分配是在堆内存上进行的</strong>。但是随着JIT编译器的日渐成熟，很多优化使这种分配策略并不绝对。JIT编译器就可以在编译期间根据逃逸分析的结果，来决定是否可以将对象的内存分配从堆转化为栈</p><pre><code class="highlight plaintext">public class EscapeAnalysisTest &#123;    public static void main(String[] args) &#123;        long a1 = System.currentTimeMillis();        for (int i = 0; i &lt; 1000000; i++) &#123;            alloc();        &#125;        // 查看执行时间        long a2 = System.currentTimeMillis();        System.out.println(&quot;cost &quot; + (a2 - a1) + &quot; ms&quot;);        // 为了方便查看堆内存中对象个数，线程sleep        try &#123;           Thread.sleep(100000);        &#125; catch (InterruptedException e1) &#123;            e1.printStackTrace();        &#125;    &#125;    private static void alloc() &#123;     User user = new User();    &#125;    static class User &#123;    &#125;&#125;</code></pre><blockquote><p>其实代码内容很简单，就是使用for循环，在代码中创建100万个User对象</p></blockquote><blockquote><p>我们在alloc方法中定义了User对象，但是并没有在方法外部引用他。也就是说，这个对象并不会逃逸到alloc外部。经过JIT的逃逸分析之后，就可以对其内存分配进行优化</p></blockquote><p>我们指定以下JVM参数并运行：</p><pre><code class="highlight plaintext">-Xmx4G -Xms4G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError</code></pre><p>在程序打印出 <code>cost XX ms</code> 后，代码运行结束之前，我们使用<code>[jmap][1]</code> 命令，来查看下当前堆内存中有多少个User对象：</p><pre><code class="highlight plaintext">~ jps2809 StackAllocTest2810 Jps~ jmap -histo 2809num #instances #bytes class name.----------------------------------------------1: 524 87282184 [I2: 1000000 16000000 StackAllocTest$User3: 6806 2093136 [B4: 8006 1320872 [C5: 4188 100512 java.lang.String6: 581 66304 java.lang.Class</code></pre><p>从上面的jmap执行结果中我们可以看到，堆中共创建了100万个StackAllocTest$User 实例。</p><p>在关闭逃避分析的情况下（<code>-XX:-DoEscapeAnalysis</code>），虽然在alloc方法中创建的User对象并没有逃逸到方法外部，但是还是被分配在堆内存中。也就说，如果没有JIT编译器优化，没有逃逸分析技术，正常情况下就应该是这样的。即所有对象都分配到堆内存中。</p><p>接下来，我们开启逃逸分析，再来执行下以上代码</p><pre><code class="highlight plaintext">-Xmx4G -Xms4G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError</code></pre><p>在程序打印出 cost XX ms 后，代码运行结束之前，我们使用jmap 命令，来查看下当前堆内存中有多少个User对象：</p><p>从以上打印结果中可以发现，开启了逃逸分析之后（-XX:+DoEscapeAnalysis），在堆内存中只有12万多个StackAllocTest$User 对象。也就是说在经过JIT优化之后，堆内存中分配的对象数量，从100万降到了12万。</p><p>除了以上通过jmap验证对象个数的方法以外，读者还可以尝试将堆内存调小，然后执行以上代码，根据GC的次数来分析，也能发现，开启了逃逸分析之后，在运行期间，GC次数会明显减少。正是因为很多堆上分配被优化成了栈上分配，所以GC次数有了明显的减少</p><p><strong>总结</strong></p><p>所以，如果以后再有人问你：是不是所有的对象和数组都会在堆内存分配空间？</p><p>那么你可以告诉他：不一定，随着JIT编译器的发展，在编译期间，如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。但是这也并不是绝对的。就像我们前面看到的一样，在开启逃逸分析之后，也并不是所有User对象都没有在堆上分配</p><hr /><p><strong>标量替换</strong></p><p>标量（Scalar）是指一个无法再分解成更小的数据的数据 。</p><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替</p><pre><code class="highlight plaintext">//有一个类Apublic class A&#123;    public int a=1;    public int b=2&#125;//方法getAB使用类A里面的a,bprivate void getAB()&#123;    A x = new A();    x.a;    x.b;&#125;//JVM在编译的时候会直接编译成private void getAB()&#123;    a = 1;    b = 2;&#125;//这就是标量替换</code></pre><hr /><p><strong>同步锁消除</strong></p><p>同样基于逃逸分析，当加锁的变量不会发生逃逸，是线程私有的完全没有必要加锁。 在jit编译时期就可以将同步锁去掉，以减少加锁与解锁造成的资源开销</p><pre><code class="highlight plaintext">public class TestLockEliminate &#123;    public static String getString(String s1, String s2) &#123;        StringBuffer sb = new StringBuffer();        sb.append(s1);        sb.append(s2);        return sb.toString();    &#125;    public static void main(String[] args) &#123;        long tsStart = System.currentTimeMillis();        for (int i = 0; i &lt; 1000000; i++) &#123;         getString(&quot;TestLockEliminate &quot;, &quot;Suffix&quot;);        &#125;        System.out.println(&quot;一共耗费：&quot; + (System.currentTimeMillis() - tsStart) + &quot; ms&quot;);    &#125;&#125;</code></pre><p>getString()方法中的StringBuffer数以函数内部的局部变量，进作用于方法内部，不可能逃逸出该方法，因此他就不可能被多个线程同时访问，也就没有资源的竞争，但是StringBuffer的append操作却需要执行同步操作:</p><pre><code class="highlight plaintext">@Overridepublic synchronized StringBuffer append(String str) &#123;    toStringCache = null;    super.append(str);    return this;&#125;</code></pre><p>逃逸分析和锁消除分别可以使用参数<code>-XX:+DoEscapeAnalysis</code>和<code>-XX:+EliminateLocks</code>(锁消除必须在-server模式下)开启。使用如下参数运行上面的程序：</p><pre><code class="highlight plaintext">-XX:+DoEscapeAnalysis -XX:-EliminateLocks</code></pre><p>得到如下结果：</p><p>使用如下命令</p><pre><code class="highlight plaintext">-XX:+DoEscapeAnalysis -XX:+EliminateLocks</code></pre><p>得到如下结果：</p><h2 id="class文件"><a class="markdownIt-Anchor" href="#class文件"></a> CLASS文件</h2><h3 id="class文件概述"><a class="markdownIt-Anchor" href="#class文件概述"></a> class文件概述</h3><p>我们可任意打开一个Class文件（使用Hex Editor等工具打开），内容如下（内容是16进制）：</p><p><strong>魔数</strong></p><p>所有的由Java编译器编译而成的class文件的前4个字节都是“0xCAFEBABE”。</p><p>它的作用在于：当JVM在尝试加载某个文件到内存中来的时候，会首先判断此class文件有没有JVM认为可以接受的“签名”，即JVM会首先读取文件的前4个字节，判断该4个字节是否是“0xCAFEBABE”，如果是，则JVM会认为可以将此文件当作class文件来加载并使用。</p><p><strong>版本号</strong></p><p>随着Java本身的发展，Java语言特性和JVM虚拟机也会有相应的更新和增强。目前我们能够用到的JDK版本如：1.5，1.6，1.7，还有现如今的1.8及更高的版本。发布新版本的目的在于：在原有的版本上增加新特性和相应的JVM虚拟机的优化。而随着主版本发布的次版本，则是修改相应主版本上出现的bug。我们平时只需要关注主版本就可以了。</p><p>主版本号和次版本号在class文件中各占两个字节，副版本号占用第5、6两个字节，而主版本号则占用第7，8两个字节。JDK1.0的主版本号为45，以后的每个新主版本都会在原先版本的基础上加1。若现在使用的是JDK1.7编译出来的class文件，则相应的主版本号应该是51,对应的7，8个字节的十六进制的值应该是 0x33。</p><p>一个 JVM实例只能支持特定范围内的主版本号 （Mi 至Mj） 和 0 至特定范围内 （0 至 m） 的副版本号。假设一个 Class 文件的格式版本号为 V， 仅当Mi.0 ≤ v ≤ Mj.m成立时，这个 Class 文件才可以被此 Java 虚拟机支持。不同版本的 Java 虚拟机实现支持的版本号也不同，高版本号的 Java 虚拟机实现可以支持低版本号的 Class 文件，反之则不成立。</p><p>JVM在加载class文件的时候，会读取出主版本号，然后比较这个class文件的主版本号和JVM本身的版本号，如果JVM本身的版本号 &lt; class文件的版本号，JVM会认为加载不了这个class文件，会抛出我们经常见到的&quot; java.lang.UnsupportedClassVersionError: Bad version number in .class file &quot; Error 错误；反之，JVM会认为可以加载此class文件，继续加载此class文件</p><blockquote><ol><li>有时候我们在运行程序时会抛出这个Error 错误：“java.lang.UnsupportedClassVersionError: Bad version number in .class ﬁle”。上面已经揭示了出现这个问题的原因，就是在于当前尝试加载class文件的JVM虚拟机的版本 低于class文件的版本。解决方法：1.重新使用当前jvm编译源代码，然后再运行代码；2.将当前JVM虚拟机更新到class文件的版本。</li><li>怎样查看class文件的版本号？可以借助于文本编辑工具，直接查看该文件的7，8个字节的值，确定class文件是什么版本的。</li></ol></blockquote><p>当然快捷的方式使用JDK自带的javap工具，如当前有Math.class 文件，进入此文件所在的目录，然后执行 ”javap -v Math“,结果会类似如下所示：</p><p><strong>常量池计数器</strong></p><p>常量池是class文件中非常重要的结构，它描述着整个class文件的字面量信息。常量池是由一组constant_pool结构体数组组成的，而数组的大小则由常量池计数器指定。常量池计数器</p><p>constant_pool_count 的值 =constant_pool表中的成员数+ 1。constant_pool表的索引值只有在大于 0 且小于constant_pool_count时才会被认为是有效的。</p><blockquote><p>注意事项</p></blockquote><p>常量池计数器默认从1开始而不是从0开始：</p><ul><li>当constant_pool_count = 1时，常量池中的cp_info个数为0；当constant_pool_count为n时，常量池中的cp_info个数为n-1。</li></ul><p>原因：</p><ul><li>在指定class文件规范的时候，将索引#0项常量空出来是有特殊考虑的，这样当：某些数据在特定的情况下想表达“不引用任何一个常量池项”的意思时，就可以将其引用的常量的索引值设置为#0来表示</li></ul><p><strong>常量池数据区</strong></p><p><strong>访问标志</strong></p><p>访问标志，access_flags 是一种掩码标志，用于表示某个类或者接口的访问权限及基础属性。</p><p><strong>类索引</strong></p><p>类索引，this_class的值必须是对constant_pool表中项目的一个有效索引值。constant_pool表在这个索引处的项必须为CONSTANT_Class_info 类型常量，表示这个 Class 文件所定义的类或接口</p><p><strong>父类索引</strong></p><p>父类索引，对于类来说，super_class 的值必须为 0 或者是对constant_pool 表中项目的一个有效索引值。</p><p>如果它的值不为 0，那 constant_pool 表在这个索引处的项必须为CONSTANT_Class_info 类型常量，表示这个 Class 文件所定义的类的直接父类。当前类的直接父类，以及它所有间接父类的access_flag 中都不能带有ACC_FINAL 标记。对于接口来说，它的Class文件的super_class项的值必须是对constant_pool表中项目的一个有效索引值。constant_pool表在这个索引处的项必须为代表 java.lang.Object 的 CONSTANT_Class_info 类型常量 。</p><p>如果 Class 文件的 super_class的值为 0，那这个Class文件只可能是定义的是java.lang.Object类，只有它是唯一没有父类的类。</p><p><strong>接口计数器</strong></p><p>接口计数器，interfaces_count的值表示当前类或接口的【直接父接口数量】。</p><p><strong>接口信息数据区</strong></p><p>接口表，interfaces[]数组中的每个成员的值必须是一个对constant_pool表中项目的一个有效索引值， 它的长度为 interfaces_count。每个成员interfaces[i] 必须为</p><p>CONSTANT_Class_info类型常量，其中 【0 ≤ i &lt;interfaces_count】。在interfaces[]数组中，成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即interfaces[0]对应的是源代码中最左边的接口。</p><p><strong>字段计数器</strong></p><p>字段计数器，fields_count的值表示当前 Class 文件 fields[]数组的成员个数。 fields[]数组中每一项都是一个field_info结构的数据项，它用于表示该类或接口声明的类字段或者实例字段。</p><p><strong>字段信息数据区</strong></p><p>字段表，fields[]数组中的每个成员都必须是一个fields_info结构的数据项，用于表示当前类或接口中某个字段的完整描述。 fields[]数组描述当前类或接口声明的所有字段，但不包括从父类或父接口继承的部分。</p><p><strong>方法计数器</strong></p><p>方法计数器， methods_count的值表示当前Class 文件 methods[]数组的成员个数。Methods[]数组中每一项都是一个 method_info 结构的数据项。</p><p><strong>方法信息数据区</strong></p><p>方法表，methods[] 数组中的每个成员都必须是一个 method_info 结构的数据项，用于表示当前类或接口中某个方法的完整描述。</p><p>如果某个method_info 结构的access_flags 项既没有设置 ACC_NATIVE 标志也没有设置</p><p>ACC_ABSTRACT 标志，那么它所对应的方法体就应当可以被 Java 虚拟机直接从当前类加载，而不需要引用其它类。</p><p>method_info结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法 。</p><p>【methods[]数组只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法】。</p><p><strong>属性计数器</strong></p><p>属性计数器，attributes_count的值表示当前 Class 文件attributes表的成员个数。 attributes表中每一项都是一个attribute_info 结构的数据项。</p><p><strong>属性信息数据区</strong></p><p>属性表，attributes 表的每个项的值必须是attribute_info结构。</p><p>在Java 7 规范里，Class文件结构中的attributes表的项包括下列定义的属性： InnerClasses 、 EnclosingMethod 、 Synthetic 、Signature、SourceFile，SourceDebugExtension 、Deprecated、RuntimeVisibleAnnotations 、RuntimeInvisibleAnnotations以及BootstrapMethods属性。</p><p>对于支持 Class 文件格式版本号为 49.0 或更高的 Java 虚拟机实现，必须正确识别并读取attributes表中的Signature、RuntimeVisibleAnnotations和RuntimeInvisibleAnnotations属性。对于支持Class文件格式版本号为 51.0 或更高的 Java 虚拟机实现，必须正确识别并读取 attributes表中的BootstrapMethods属性。Java 7 规范 要求任一 Java 虚拟机实现可以自动忽略 Class 文件的 attributes表中的若干 （甚至全部） 它不可识别的属性项。任何本规范未定义的属性不能影响Class文件的语义，只能提供附加的描述信息 。</p><h3 id="class常量池理解"><a class="markdownIt-Anchor" href="#class常量池理解"></a> class常量池理解</h3><p><strong>1.常量池在class文件的什么位置？</strong></p><p><strong>2.常量池的里面是怎么组织的？</strong></p><p>cp_info：常量池项</p><p>constant_pool_count：常量池计算器</p><p><strong>3.常量池项 (cp_info) 的结构是什么？</strong></p><p>JVM虚拟机规定了不同的tag值和不同类型的字面量对应关系如下：</p><p>所以根据cp_info中的tag 不同的值，可以将cp_info 更细化为以下结构体：</p><p>现在让我们看一下细化了的常量池的结构会是类似下图所示的样子：</p><p><strong>4. int和ﬂoat数据类型的常量在常量池中是怎样表示和存储的？</strong></p><p>Java语言规范规定了 int类型和Float 类型的数据类型占用 4 个字节的空间。那么存在于class字节码文件中的该类型的常量是如何存储的呢？</p><p>举例：建下面的类 IntAndFloatTest.java，在这个类中，我们声明了五个变量，但是取值就两种int类型的10 和Float类型的11f。</p><pre><code class="highlight plaintext">package com.kkb.jvm;   public class IntAndFloatTest &#123;     private final int a = 10;       private final int b = 10;       private float c = 11f;      private float d = 11f;       private float e = 11f;  &#125;</code></pre><p>然后用编译器编译成IntAndFloatTest.class字节码文件，我们通过javap -v IntAndFloatTest 指令来看一下其常量池中的信息，可以看到虽然我们在代码中写了两次10 和三次11f，但是常量池中，就只有一个常量10 和一个常量11f,如下图所示:</p><p>从结果上可以看到常量池第#8 个常量池项(cp_info) 就是CONSTANT_Integer_info,值为10；第#23个常量池项(cp_info) 就是CONSTANT_Float_info,值为11f。</p><p>代码中所有用到 int 类型 10 的地方，会使用指向常量池的指针值#8 定位到第#8 个常量池项</p><p>(cp_info)，即值为 10的结构体CONSTANT_Integer_info，而用到ﬂoat类型的11f时，也会指向常量池的指针值#23来定位到第#23个常量池项(cp_info) 即值为11f的结构体CONSTANT_Float_info。如下图所示：</p><p><strong>5. long和 double数据类型的常量在常量池中是怎样表示和存储的？</strong></p><p>Java语言规范规定了 long 类型和 double类型的数据类型占用8 个字节的空间。那么存在于class 字节码文件中的该类型的常量是如何存储的呢？</p><p>举例：建下面的类 LongAndDoubleTest.java，在这个类中，我们声明了六个变量，但是取值就两种Long 类型的-6076574518398440533L 和Double 类型的10.1234567890D。</p><pre><code class="highlight plaintext">public class LongAndDoubleTest &#123;    private long a = -6076574518398440533L;      private long b = -6076574518398440533L;      private long c = -6076574518398440533L;      private double d = 10.1234567890D;      private double e = 10.1234567890D;     private double f = 10.1234567890D; &#125;</code></pre><p>然后用编译器编译成 LongAndDoubleTest.class 字节码文件，我们通过javap -v LongAndDoubleTest指令来看一下其常量池中的信息，可以看到虽然我们在代码中写了三次-6076574518398440533L 和三次10.1234567890D，但是常量池中，就只有一个常</p><p>量-6076574518398440533L 和一个常量10.1234567890D,如下图所示:</p><p>从结果上可以看到常量池第 #18 个常量池项(cp_info) 就是CONSTANT_Long_info,值</p><p>为-6076574518398440533L ；第 #26个常量池项(cp_info) 就是CONSTANT_Double_info,值为10.1234567890D。</p><p>代码中所有用到 long 类型-6076574518398440533L 的地方，会使用指向常量池的指针值#18 定位到第 #18 个常量池项(cp_info)，即值为-6076574518398440533L 的结构体CONSTANT_Long_info，而用到double类型的10.1234567890D时，也会指向常量池的指针值#26来定位到第 #26 个常量池项</p><p>(cp_info) 即值为10.1234567890D的结构体CONSTANT_Double_info。如下图所示：</p><p><strong>6. String类型的字符串常量在常量池中是怎样表示和存储的？</strong></p><p>对于字符串而言，JVM会将字符串类型的字面量以UTF-8 编码格式存储到在class字节码文件中。这么说可能有点摸不着北，我们先从直观的Java源码中中出现的用双引号&quot;&quot; 括起来的字符串来看，在编译器编译的时候，都会将这些字符串转换成CONSTANT_String_info结构体，然后放置于常量池中。其结构如下所示：</p><p>如上图所示的结构体，CONSTANT_String_info结构体中的string_index的值指向了CONSTANT_Utf8_info结构体，而字符串的utf-8编码数据就在这个结构体之中。如下图所示：</p><p>请看一例，定义一个简单的StringTest.java类，然后在这个类里加一个&quot;JVM原理&quot; 字符串，然后，我们来看看它在class文件中是怎样组织的。</p><pre><code class="highlight plaintext">public class StringTest &#123;    private String s1 = &quot;JVM原理&quot;;     private String s2 = &quot;JVM原理&quot;;     private String s3 = &quot;JVM原理&quot;;     private String s4 = &quot;JVM原理&quot;;&#125;</code></pre><p>将Java源码编译成StringTest.class文件后，在此文件的目录下执行 javap -v StringTest 命令，会看到如下的常量池信息的轮廓：</p><p>(PS :使用javap -v 指令能看到易于我们阅读的信息，查看真正的字节码文件可以使用HEXWin、 NOTEPAD++、UtraEdit 等工具。)</p><p>在面的图中，我们可以看到CONSTANT_String_info结构体位于常量池的第#15个索引位置。而存</p><p>放&quot;Java虚拟机原理&quot; 字符串的 UTF-8编码格式的字节数组被放到CONSTANT_Utf8_info结构体中，该结构体位于常量池的第#16个索引位置。上面的图只是看了个轮廓，让我们再深入地看一下它们的组织吧。请看下图：</p><p>由上图可见：“JVM原理”的UTF-8编码的数组是：4A564D E5 8E 9FE7 90 86，并且存入了CONSTANT_Utf8_info结构体中</p><p><strong>7. 类文件中定义的类名和类中使用到的类在常量池中是怎样被组织和存储的？</strong></p><p>JVM会将某个Java 类中所有使用到了的类的完全限定名 以二进制形式的完全限定名 封装成CONSTANT_Class_info结构体中，然后将其放置到常量池里。CONSTANT_Class_info 的tag值为 7 。其结构如下：</p><blockquote><p>Tips：类的完全限定名和二进制形式的完全限定名</p></blockquote><blockquote><p>在某个Java源码中，我们会使用很多个类，比如我们定义了一个 ClassTest的类，并把它放到com.kkb.jvm 包下，则 ClassTest类的完全限定名为com.kkb.jvm.ClassTest，将JVM编译器将类编译成class文件后，此完全限定名在class文件中，是以二进制形式的完全限定名存储的，即它会把完全限定符的&quot;.“换成”/&quot; ，即在class文件中存储的 ClassTest类的完全限定名称</p><p>是&quot;com/kkb/jvm/ClassTest&quot;。因为这种形式的完全限定名是放在了class二进制形式的字节码文件中，所以就称之为 二进制形式的完全限定名。</p></blockquote><p>举例，我们定义一个很简单的ClassTest类，来看一下常量池是怎么对类的完全限定名进行存储的。</p><pre><code class="highlight plaintext"> import  java.util.Date;    public class ClassTest &#123;    private Date date =new Date();&#125;</code></pre><p>将Java源码编译成ClassTest.class文件后，在此文件的目录下执行 javap -v ClassTest 命令，会看到如下的常量池信息的轮廓：</p><p>如上图所示，在ClassTest.class文件的常量池中，共有 3 个CONSTANT_Class_info结构体，分别表示ClassTest 中用到的Class信息。 我们就看其中一个表示com/jvm.ClassTest的</p><p>CONSTANT_Class_info 结构体。它在常量池中的位置是#1，它的name_index值为#2，它指向了常量池的第2 个常量池项，如下所示:</p><p>注意：</p><blockquote><p>对于某个类而言，其class文件中至少要有两个CONSTANT_Class_info常量池项，用来表示自己的类信息和其父类信息。(除了java.lang.Object类除外，其他的任何类都会默认继承自</p><p>java.lang.Object）如果类声明实现了某些接口，那么接口的信息也会生成对应的</p><p>CONSTANT_Class_info常量池项。</p></blockquote><p>除此之外，如果在类中使用到了其他的类，只有真正使用到了相应的类，JDK编译器才会将类的信息组成CONSTANT_Class_info常量池项放置到常量池中。如下图：</p><pre><code class="highlight plaintext">import java.util.Date; public  class Other&#123;     private Date date;      public Other()  &#123;         Date da;    &#125;&#125;</code></pre><p>上述的Other的类，在JDK将其编译成class文件时，常量池中并没有java.util.Date对应的CONSTANT_Class_info常量池项，为什么呢?</p><p>在Other类中虽然定义了Date类型的两个变量date、da，但是JDK编译的时候，认为你只是声明</p><p>了“Ljava/util/Date”类型的变量，并没有实际使用到Ljava/util/Date类。将类信息放置到常量池中的目的，是为了在后续的代码中有可能会反复用到它。很显然，JDK在编译Other类的时候，会解析到Date类有没有用到，发现该类在代码中就没有用到过，所以就认为没有必要将它的信息放置到常量池中了。</p><hr /><p>将上述的Other类改写一下，仅使用new Date()，如下图所示：</p><pre><code class="highlight plaintext">import java.util.Date; public  class Other&#123;     private Date date;      public Other()  &#123;         new Date();;    &#125;&#125;</code></pre><p>这时候使用javap -v Other ，可以查看到常量池中有表示java/util/Date的常量池项：</p><hr /><p><strong>总结</strong></p><p>对于某个类或接口而言，其自身、父类和继承或实现的接口的信息会被直接组装成</p><p>CONSTANT_Class_info常量池项放置到常量池中；</p><p>类中或接口中使用到了其他的类，只有在类中实际使用到了该类时，该类的信息才会在常量池中有对应的CONSTANT_Class_info常量池项；</p><p>类中或接口中仅仅定义某种类型的变量，JDK只会将变量的类型描述信息以UTF-8字符串组成CONSTANT_Utf8_info常量池项放置到常量池中，上面在类中的private Date date;JDK编译器只会将表示date的数据类型的“Ljava/util/Date”字符串放置到常量池中。</p><hr /><p><strong>8.哪些字面量会进入常量池中？</strong></p><ol><li>final类型的8种基本类型的值会进入常量池。</li><li>非final类型（包括static的）的8种基本类型的值，只有double、float、long的值会进入常量池。</li><li>常量池中包含的字符串类型字面量（双引号引起来的字符串值）。</li></ol><p>测试代码：</p><pre><code class="highlight plaintext">public class Test&#123;     private int int_num = 110;     private char char_num = &#x27;a&#x27;;     private short short_num = 120;     private float float_num = 130.0f;      private double double_num = 140.0;       private byte byte_num = 111;    private long long_num = 3333L;     private long long_delay_num;    private boolean boolean_flage = true;        public void init()&#123;        this.long_delay_num = 5555L;    &#125;&#125;</code></pre><p>使用javap命令打印的结果如下：</p><h3 id="class文件中的应用和特殊字符串"><a class="markdownIt-Anchor" href="#class文件中的应用和特殊字符串"></a> class文件中的应用和特殊字符串</h3><p><strong>符号引用</strong></p><p>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。</p><p>例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、</p><p>CONSTANT_Methodref_info等类型的常量出现</p><p>符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中</p><p>在[Java]中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p><hr /><p><strong>直接引用</strong></p><ol><li>直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）</li><li>相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）</li><li>一个能间接定位到目标的句柄</li></ol><p>直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。</p><hr /><p><strong>符号引用替换为直接引用的时机</strong></p><p>符号引用替换为直接引用的操作发生在类加载过程(加载 -&gt; 连接(验证、准备、解析) -&gt; 初始化)中的解析阶段，会将符号引用转换(替换)为对应的直接引用，放入运行时常量池中</p><blockquote><p>注：直接引用可以是指向目标内存的指针，也可以是偏移量，也可以是一个能定位到目标内存的句柄。</p></blockquote><p>特殊字符串包括三种： 类的全限定名， 字段和方法的描述符， 特殊方法的方法名。 下面我们就分别介绍这三种特殊字符串。</p><hr /><p><strong>类的全限定名</strong></p><p>Object类，在源文件中的全限定名是 java.lang.Object。而class文件中的全限定名是将点号替换成“/” 。</p><p>Object类在class文件中的全限定名是 java/lang/Object 。 源文件中一个类的名字， 在class文件中是用全限定名表述的。</p><hr /><p><strong>描述符</strong></p><ul><li><strong>各类型的描述符</strong></li></ul><p>对于字段的数据类型，其描述符主要有以下几种</p><ul><li><p>基本数据类型（byte、char、double、ﬂoat、int、long、short、boolean）：除 long 和 boolean，其他基本数据类型的描述符用对应单词的大写首字母表示。long 用 J 表示，boolean 用 Z 表示。</p></li><li><p>void：描述符是 V。</p></li><li><p>对象类型：描述符用字符 L加上对象的全限定名表示，如 String 类型的描述符为 Ljava/lang/String。</p></li><li><p>数组类型：每增加一个维度则在对应的字段描述符前增加一个<code>[ ，如一维数组 int[] 的描述符为 [I，二维数组 String[][] 的描述符为 [[Ljava/lang/String 。</code></p></li><li><p><strong>字段描述符</strong></p></li></ul><p>字段的描述符就是字段的类型所对应的字符或字符串。</p><pre><code class="highlight plaintext">int i 中， 字段i的描述符就是 IObject o中， 字段o的描述符就是 Ljava/lang/Object;double[][] d中， 字段d的描述符就是 [[D</code></pre><ul><li><strong>方法描述符</strong></li></ul><p>方法的描述符比较复杂， 包括所有参数的类型列表和方法返回值。 它的格式是这样的：</p><pre><code class="highlight plaintext">(参数1类型 参数2类型 参数3类型 ...)返回值类型</code></pre><blockquote><p>不管是参数的类型还是返回值类型， 都是使用对应字符和对应字符串来表示的， 并且参数列表使用小括号括起来， 并且各个参数类型之间没有空格， 参数列表和返回值类型之间也没有空格。</p></blockquote><p>方法描述符举例说明如下：</p><p>特殊方法的方法名</p><p>首先要明确一下， 这里的特殊方法是指的类的构造方法和类型初始化方法。</p><p>构造方法就不用多说了， 至于类型的初始化方法， 对应到源码中就是静态初始化块。 也就是说， 静态初始化块， 在class文件中是以一个方法表述的， 这个方法同样有方法描述符和方法名，具体如下:</p><ul><li>类的构造方法的方法名使用字符串 表示</li><li>静态初始化方法的方法名使用字符串 表示。</li><li>除了这两种特殊的方法外， 其他普通方法的方法名， 和源文件中的方法名相同</li></ul><hr /><p><strong>总结</strong></p><ol><li>方法和字段的描述符中， 不包括字段名和方法名， 字段描述符中只包括字段类型， 方法描述符中只包括参数列表和返回值类型。</li><li>无论method()是静态方法还是实例方法，它的方法描述符都是相同的。尽管实例方法除了传递自身定义的参数，还需要额外传递参数this，但是这一点不是由方法描述符来表达的。参数this的传递，是由Java虚拟机实现在调用实例方法所使用的指令中实现的隐式传递。</li></ol><h2 id="类加载子系统"><a class="markdownIt-Anchor" href="#类加载子系统"></a> 类加载子系统</h2><h3 id="jvm程序执行流程"><a class="markdownIt-Anchor" href="#jvm程序执行流程"></a> JVM程序执行流程</h3><p><strong>Bootstrap：系统类加载器</strong></p><p>如示例：String是系统类加载的，我们无法看到其类加载器</p><pre><code class="highlight plaintext">package com.lee.configserver;public class testMain &#123;    public static void main(String[] args) &#123;        //String是一个系统类，系统类里面的类加载器是不同的        String str = &quot;hello&quot;; //静态常量池定义        System.out.println(str.getClass().getClassLoader());    &#125;&#125;</code></pre><p>输出：</p><p><strong>App类加载器</strong></p><pre><code class="highlight plaintext">package com.lee.configserver;class People&#123;&#125;public class testMain &#123;    public static void main(String[] args) &#123;        People people = new People();   //实例化了一个自定义类对象        System.out.println(people.getClass().getClassLoader());    &#125;&#125;</code></pre><p>输出：</p><p><strong>平台类加载器</strong></p><pre><code class="highlight plaintext">package com.lee.configserver;class People&#123;&#125;public class testMain &#123;    public static void main(String[] args) &#123;        People people = new People();   //实例化了一个自定义类对象        System.out.println(people.getClass().getClassLoader());        System.out.println(people.getClass().getClassLoader().getParent());        System.out.println(people.getClass().getClassLoader().getParent().getParent());    &#125;&#125;</code></pre><h3 id="类加载过程"><a class="markdownIt-Anchor" href="#类加载过程"></a> 类加载过程</h3><p><strong>加载</strong></p><p>“加载”是“类加载”(Class Loading)过程的第一步。这个加载过程主要就是靠<strong>类加载器</strong>实现的，包括用户自定义类加载器。</p><p><strong>加载的过程</strong></p><p>在加载的过程中,JVM主要做3件事情</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流(class文件)在程序运行过程中,当要访问一个类时,若发现这个类尚未被加载,并满足类初始化的条件时，就根据要被初始化的这个类的全限定名找到该类的二进制字节流,开始加载过程</li><li>将这个字节流的<strong>静态存储结构</strong>转化为<strong>方法区的运行时数据结构</strong></li><li><strong>在内存中创建一个该类的java.lang.Class对象</strong>,作为方法区该类的各种数据的访问入口</li></ul><blockquote><p>程序在运行中所有对该类的访问都通过这个类对象,也就是这个Class对象是提供给外界访问该类的接口。</p></blockquote><hr /><p><strong>加载源</strong></p><p>JVM规范对于加载过程给予了较大的宽松度.一般二进制字节流都从已经编译好的本地class文件中读取,此外还可以从以下地方读取。</p><ul><li><strong>zip�</strong>�<br />Jar、War、Ear等</li><li><strong>其它文件生成</strong><br />由JSP文件中生成对应的Class类.</li><li><strong>数据库中</strong><br />将二进制字节流存储至数据库中,然后在加载时从数据库中读取.有些中间件会这么做,用来实现代码在集群间分发</li><li><strong>网络</strong><br />从网络中获取二进制字节流.典型就是Applet.</li><li><strong>运行时计算生成</strong><br />动态代理技术,用ProxyGenerator.generateProxyClass为特定接口生成形式为<code>&quot;*$Proxy&quot;</code>的代理类的二进制字节流.</li></ul><p><strong>类和数组加载的区别</strong></p><p>数组也有类型,称为“数组类型”.如:</p><pre><code class="highlight plaintext">String[] str = new String[10];</code></pre><blockquote><p>这个数组的数组类型是[Ljava.lang.String ,而String只是这个数组的元素类型</p></blockquote><p>数组类和非数组类的类加载是不同的，具体情况如下：</p><ul><li><strong>非数组类</strong>：是由类加载器来完成。</li><li><strong>数组类</strong>：数组类本身不通过类加载器创建，它是由java虚拟机直接创建，但数组类与类加载器有很密切的关系，因为数组类的元素类型最终要靠类加载器创建</li></ul><hr /><p><strong>加载过程的注意点</strong></p><ul><li><strong>JVM规范并未给出类在方法区中存放的数据结构</strong></li></ul><p>类完成加载后,二进制字节流就以特定的数据结构存储在方法区中,但存储的数据结构是由虚拟机自己定义的,虚拟机规范并没有指定。</p><ul><li><strong>JVM规范并没有指定Class对象存放的位置</strong></li></ul><p>在二进制字节流以特定格式存储在方法区后,JVM会创建一个java.lang.Class类的对象,作为本类的外部访问接口。</p><p>既然是对象就应该存放在Java堆中,不过JVM规范并没有给出限制,不同的虚拟机根据自己的需求存放这个对象。</p><p>HotSpot将Class对象存放在方法区。</p><ul><li><strong>加载阶段和链接阶段是交叉的</strong></li></ul><p>类加载的过程中每个步骤的开始顺序都有严格限制,但每个步骤的结束顺序没有限制。也就是说,类加载过程中,必须按照如下顺序开始:</p><blockquote><p>加载 -&gt; 链接 -&gt; 初始化</p></blockquote><p>但结束顺序无所谓,因此由于每个步骤处理时间的长短不一就会导致有些步骤会出现交叉</p><hr /><p><strong>验证</strong></p><p>验证阶段比较耗时,它非常重要但不一定必要(因为对程序运行期没有影响)<strong>,如果所运行的代码已经被反复使用和验证过,那么可以使用参数关闭,以缩短类加载时间</strong></p><pre><code class="highlight plaintext">-Xverify:none</code></pre><ul><li><strong>验证的目的</strong></li></ul><p>保证二进制字节流中的信息符合虚拟机规范,并没有安全问题</p><ul><li><strong>验证的必要性</strong></li></ul><p>虽然Java语言是一门安全的语言,它能确保程序猿无法访问数组边界以外的内存、避免让一个对象转换成任意类型、避免跳转到不存在的代码行.也就是说,Java语言的安全性是通过编译器来保证的.</p><p>但是我们知道,编译器和虚拟机是两个独立的东西,虚拟机只认二进制字节流,它不会管所获得的二进制字节流是哪来的，当然，如果是编译器给它的，那么就相对安全，但如果是从其它途径获得的，那么无法确保该二进制字节流是安全的。</p><p>通过上文可知，虚拟机规范中没有限制二进制字节流的来源，在字节码层面上,上述Java代码无法做到的都是可以实现的,至少语义上是可以表达出来的,为了防止字节流中有安全问题，需要验证！</p><ul><li><p><strong>验证的过程</strong></p></li><li><p><strong>文件格式验证</strong></p></li></ul><p>验证字节流是否符合Class文件格式的规范,并且能被当前的虚拟机处理.</p><p>本验证阶段是基于二进制字节流进行的,<strong>只有通过本阶段验证,才被允许存到方法区</strong></p><p>后面的三个验证阶段都是基于方法区的存储结构进行,不会再直接操作字节流</p><p>印证【加载和验证】是交叉进行的：</p><ol><li>加载开始前，二进制字节流还没进方法区，而加载完成后，二进制字节流已经存入方法区</li><li>而在文件格式验证前，二进制字节流尚未进入方法区，文件格式验证通过之后才进入方法区，也就是说，加载开始后，立即启动了文件格式验证，本阶段验证通过后，二进制字节流被转换成特定数据结构存储至方法区中，继而开始下阶段的验证和创建Class对象等操作</li></ol><ul><li><strong>元数据验证</strong></li></ul><p>对字节码描述信息进行语义分析,确保符合Java语法规范</p><ul><li><strong>字节码验证</strong></li></ul><p>本阶段是验证过程的最复杂的一个阶段。</p><p>本阶段对方法体进行语义分析,保证方法在运行时不会出现危害虚拟机的事件。</p><p>字节码验证将对类的方法进行校验分析，保证被校验的方法在运行时不会做出危害虚拟机的事，一个类方法体的字节码没有通过字节码验证，那一定有问题，但若一个方法通过了验证，也不能说明它一定安全</p><ul><li><strong>符号引用验证</strong></li></ul><p>发生在JVM将符号引用转化为直接引用的时候,这个转化动作发生在解析阶段,对类自身以外的信息进行匹配校验,确保解析能正常执行</p><hr /><p><strong>准备</strong></p><p>仅仅为类变量（即static修饰的字段变量）分配内存并且设置该类变量的初始值即零值，这里不包含用final修饰的static，因为final在编译的时候就会分配了（编译器的优化），同时这里也不会为实例变量分配初始化。类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</p><p>准备阶段主要完成两件事情：</p><ul><li>为已在方法区中的类的静态成员变量分配内存</li><li>为静态成员变量设置初始值，初始值为0、false、null等</li></ul><p>比如：</p><pre><code class="highlight plaintext">public static int x = 1000;</code></pre><blockquote><p>实际上变量x在准备阶段过后的初始值为0而不是1000</p></blockquote><blockquote><p>将x赋值为1000的putstatic指令是程序被编译后，存放于类构造器<client>方法之中</p></blockquote><p>但是如果声明为</p><pre><code class="highlight plaintext">public static final int x = 1000;</code></pre><blockquote><p>在编译阶段会为x生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将x赋值为1000</p></blockquote><hr /><p><strong>解析</strong></p><p>解析是虚拟机将常量池的符号引用替换为直接引用的过程</p><p>解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info 、CONSTANT_Fieldref_info 、CONSTANT_Methodref_info 、CONSTANT_InterfaceMethodref_info 四种常量类型</p><ol><li><strong>类或接口的解析</strong>：</li></ol><p>判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。</p><ol><li><strong>字段解析</strong>：</li></ol><p>对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束(优先从接口来，然后是继承的父类.理论上是按照上述顺序进行搜索解析，但在实际应用中，虚拟机的编译器实现可能要比上述规范要求的更严格一些。如果有一个同名字段同时出现在该类的接口和父类中，或同时在自己或父类的接口中出现，编译器可能会拒绝编译）.</p><ol><li><strong>类方法解析</strong>：</li></ol><p>对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。</p><ol><li><strong>接口方法解析</strong>：</li></ol><p>与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行了。</p><hr /><p><strong>初始化</strong></p><p>初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码(初始化成为代码设定的默认值)。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源</p><p>其实初始化过程就是调用类初始化方法的过程，完成<strong>对static修饰的类变量的手动赋值</strong>还有<strong>主动调用静态代码块</strong>。</p><p><strong>初始化过程的注意点</strong></p><ul><li>方法是编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的,编译器收集的顺序是由语句在源文件中出现的顺序所决定的.</li><li>静态代码块只能访问到出现在静态代码块之前的变量,定义在它之后的变量,在前面的静态语句块可以赋值,但是不能访问.</li></ul><pre><code class="highlight plaintext">public class Test &#123;    static &#123;        i=0;        System.out.println(i);//编译失败:&quot;非法向前引用&quot;    &#125;    static int i = 1;&#125;</code></pre><ul><li>实例构造器需要显式调用父类构造函数,而类的不需要调用父类的类构造函数,虚拟机会确保子类的方法执行前已经执行完毕父类的方法.因此在JVM中第一个被执行的方法的类肯定是java.lang.Object.</li><li>如果一个类/接口中没有静态代码块,也没有静态成员变量的赋值操作,那么编译器就不会为此类生成方法.</li><li>接口也需要通过方法为接口中定义的静态成员变量显示初始化。接口中不能使用静态代码块,但仍然有变量初始化的赋值操作,因此接口与类一样都会生成方法.不同的是,执行接口的方法不需要先执行父接口的方法.只有当父接口中的静态成员变量被使用到时才会执行父接口的方法.</li><li>虚拟机会保证在多线程环境中一个类的方法别正确地加锁,同步.当多条线程同时去初始化一个类时，只会有一个线程去执行该类的方法,其它线程都被阻塞等待,直到活动线程执行方法完毕.其他线程虽会被阻塞,只要有一个方法执行完,其它线程唤醒后不会再进入方法.<strong>同一个类加载器下,一个类型只会初始化一次</strong>.</li></ul><p><strong>使用静态内部类的单例实现：</strong></p><pre><code class="highlight plaintext">public class Student &#123;private Student() &#123;&#125;/** 此处使用一个内部类来维护单例 JVM在类加载的时候，是互斥的，所以可以由此保证线程安全问题*/private static class SingletonFactory &#123;private static Student student = new Student();&#125;/* 获取实例 */public static Student getSingletonInstance() &#123;return SingletonFactory.student;&#125;&#125;</code></pre><h3 id="类加载的时机"><a class="markdownIt-Anchor" href="#类加载的时机"></a> 类加载的时机</h3><p>什么时候开始加载，虚拟机规范并没有强制性的约束，对于其它大部分阶段究竟何时开始虚拟机规范也都没有进行规范，这些都是交由虚拟机的具体实现来把握。所以不同的虚拟机它们开始的时机可能是不同的。但是对于初始化却严格的规定了有且只有四种情况必须先对类进行“初始化”(加载，验证，准备自然需要在初始化之前完成)：</p><ol><li>遇到new 、getstatic 、putstatic 和invokestatic 这四条指令时，如果对应的类没有初始化，则要对对应的类先进行初始化。</li></ol><ul><li>这四个指令对应到我们java代码中的场景分别是：<ul><li>new关键字实例化对象的时候；</li><li>读取或设置一个类的静态字段（读取被final修饰，已在编译器把结果放入常量池的静态字段除外） ；</li><li>调用类的静态方法时。</li></ul></li></ul><ol><li>使用java.lang.reflect 包方法时对类进行反射调用的时候。</li><li>初始化一个类的时候发现其父类还没初始化，要先初始化其父类。</li><li>当虚拟机开始启动时，用户需要指定一个主类，虚拟机会先执行这个主类的初始化</li></ol><h3 id="类加载器"><a class="markdownIt-Anchor" href="#类加载器"></a> 类加载器</h3><p><strong>启动类加载器</strong>(Bootstrap ClassLoader)：</p><ul><li>负责加载 JAVA_HOME\lib 目录中的，</li><li>或通过-Xbootclasspath参数指定路径中的，</li><li>且被虚拟机认可（按文件名识别，如rt.jar）的类。</li><li>由C++实现，不是ClassLoader子类</li></ul><p><strong>扩展类加载器</strong>(Extension ClassLoader)：</p><ul><li>负责加载 JAVA_HOME\lib\ext 目录中的，</li><li>或通过java.ext.dirs系统变量指定路径中的类库。</li></ul><p><strong>应用程序类加载器</strong>(Application ClassLoader)：</p><ul><li>负责加载用户路径（classpath）上的类</li></ul><p><strong>JVM的类加载是通过ClassLoader及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：</strong></p><p>加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</p><h3 id="自定义类加载器"><a class="markdownIt-Anchor" href="#自定义类加载器"></a> 自定义类加载器</h3><p><strong>自定义类加载器步骤</strong></p><ul><li>继承ClassLoader</li><li>重写findClass（）方法</li><li>调用defineClass（）方法</li></ul><p><strong>实践</strong></p><p>下面写一个自定义类加载器：指定类加载路径在D盘下的lib文件夹下。</p><p>（1）在本地磁盘新建一个Test.java 类，代码如下：</p><pre><code class="highlight plaintext">package jvm.classloader;public class Test &#123;    public void say()&#123;        System.out.println(&quot;Hello MyClassLoader&quot;);    &#125;&#125;</code></pre><p>（2）使用javac -d . Test.java 命令，将生成的Test.class 文件放到D:/lib/jvm/classloader文件夹下</p><p>（3）在Eclipse中自定义类加载器，代码如下：</p><pre><code class="highlight plaintext">package com.lee.configserver;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;public class MyClassLoader extends ClassLoader &#123;    private String classpath;    public MyClassLoader(String classpath) &#123;        this.classpath = classpath;    &#125;    @Override    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;        try &#123;            byte[] classDate = getData(name);            if (classDate == null) &#123;            &#125; else &#123;//defineClass方法将字节码转化为类                return defineClass(name, classDate, 0, classDate.length);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return super.findClass(name);    &#125;    //返回类的字节码    private byte[] getData(String className) throws IOException &#123;        InputStream in = null;        ByteArrayOutputStream out = null;        String path = classpath + File.separatorChar +                className.replace(&#x27;.&#x27;, File.separatorChar) + &quot;.class&quot;;        try &#123;            in = new FileInputStream(path);            out = new ByteArrayOutputStream();            byte[] buffer = new byte[2048];            int len = 0;            while ((len = in.read(buffer)) != -1) &#123;                out.write(buffer, 0, len);            &#125;            return out.toByteArray();        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; finally &#123;            in.close();            out.close();        &#125;        return null;    &#125;&#125;</code></pre><p>测试运行：</p><pre><code class="highlight plaintext">package com.lee.configserver;import java.lang.reflect.Method;public class TestMyClassLoader &#123;    public static void main(String[] args) throws Exception &#123;        //自定义类加载器的加载路径        MyClassLoader myClassLoader = new MyClassLoader(&quot;D:\\lib&quot;);        //包名+类名        Class c = myClassLoader.loadClass(&quot;jvm.classloader.Test&quot;);        if (c != null) &#123;            Object obj = c.newInstance();            Method method = c.getMethod(&quot;say&quot;, null);            method.invoke(obj, null);            System.out.println(c.getClassLoader().toString());        &#125;    &#125;&#125;</code></pre><p><strong>自定义类加载器的作用：</strong></p><p>JVM自带的三个加载器只能加载指定路径下的类字节码。</p><p>如果某个情况下，我们需要加载应用程序之外的类文件呢？比如本地D盘下的，或者去加载网络上的某个类文件，这种情况就可以使用自定义加载器了</p><h3 id="双亲委派模型"><a class="markdownIt-Anchor" href="#双亲委派模型"></a> 双亲委派模型</h3><p>JVM通过双亲委派模型进行类的加载，当然我们也可以通过继承java.lang.ClassLoader实现自定义的类加载器。</p><ul><li>当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，</li><li>只有当父类加载器无法完成加载任务时，才会尝试执行加载任务。</li></ul><p>采用双亲委派的一个好处是：</p><ul><li>比如加载位于rt.jar包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个Object对象。</li></ul><p><strong>为什么要使用双亲委托这种模型呢？</strong></p><p>因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。</p><p>考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，<strong>因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法</strong></p><hr /><p><strong>但是JVM在搜索类的时候，又是如何判定两个class是相同的呢？</strong></p><p>JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。</p><p>只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class</p><p><strong>既然JVM已经提供了默认的类加载器，为什么还要定义自已的类加载器呢？</strong></p><p>因为Java中提供的默认ClassLoader，只加载指定目录下的jar和class，如果我们想加载其它位置的类或jar时。</p><p>比如：我要加载网络上的一个class文件，通过动态加载到内存之后，要调用这个类中的方法实现我的业务逻辑。在这样的情况下，默认的ClassLoader就不能满足我们的需求了，所以需要定义自己的ClassLoader</p><h3 id="破坏双亲委派模型"><a class="markdownIt-Anchor" href="#破坏双亲委派模型"></a> 破坏双亲委派模型</h3><p>因为在某些情况下父类加载器需要委托子类加载器去加载class文件（双亲委派模式的话，是子类委托父类加载器去加载class文件）。因为受到加载范围的限制，父类加载器无法加载到需要的文件。</p><p>以Driver接口为例，由于Driver接口定义在jdk当中的，而其实现由各个数据库的服务商来提供，比如mysql的就写了MySQL Connector ，那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接口的实现类，然后进行管理，但是DriverManager由启动类加载器加载，只能记载JAVA_HOME的lib下文件，而其实现是由服务商提供的，由系统类加载器加载，这个时候就需要启动类加载器来委托子类来加载Driver实现，从而破坏了双亲委派，这里仅仅是举了破坏双亲委派的其中一个情况。</p><pre><code class="highlight plaintext">package com.lee.configserver;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import org.junit.Test;public class TestJdbc &#123;    @Test    public void testJdbc() &#123;        Connection connection = null;        PreparedStatement preparedStatement = null;        ResultSet rs = null;        try &#123;            // 加载数据库驱动            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);            // 通过驱动管理类获取数据库链接connection = DriverManager            connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/ssm?characterEncoding=utf-8&quot;, &quot; root&quot;, &quot;root&quot;);            // 定义sql语句 ?表示占位符            String sql = &quot;select * from user where id = ?&quot;;            // 获取预处理 statement            preparedStatement = connection.prepareStatement(sql);            // 设置参数，第一个参数为 sql 语句中参数的序号（从 1 开始），第二个参数为            preparedStatement.setInt(1, 1);            // 向数据库发出 sql 执行查询，查询出结果集            rs = preparedStatement.executeQuery();            // 遍历查询结果集        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;// 释放资源            if (rs != null) &#123;                try &#123;                    rs.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (preparedStatement != null) &#123;                try &#123;                    preparedStatement.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (connection != null) &#123;                try &#123;                    connection.close();                &#125; catch (SQLException e) &#123;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="运行时数据区"><a class="markdownIt-Anchor" href="#运行时数据区"></a> 运行时数据区</h2><ul><li>方法区：最重要的内存区域，多线程共享，保存了类的信息（名称，成员，接口，父类），反射机制时重要的组成部分，动态进行类操作的实现；</li><li><strong>堆内存</strong>（Heap）:保存对象的真实信息，该内存牵扯到释放问题（GC）</li><li><strong>栈内存</strong>（Stack）:线程的私有空间，在每一次进行方法调用的时候都会存在有栈帧，采用先进后出的设计原则<ul><li>本地变量表：局部参数或者形参，允许保存有32位的插槽（Salt）,如果超过了32位的长度就需要开辟两个连续性的插槽（long，double）</li><li>操作数栈：执行所有得方法计算操作</li><li>常量长引用：String类型，Integer类示例</li><li>返回地址：方法执行完毕后的恢复执行的点</li></ul></li><li>程序计数器：执行指令的一个顺序编码，该区域的所占比例几乎可以忽略</li><li>本地方法栈：与栈内存的功能类似，区别在于是为本地方法服务的</li></ul><h3 id="程序计数器"><a class="markdownIt-Anchor" href="#程序计数器"></a> 程序计数器</h3><p><strong>程序计数器</strong>（Program Counter Register），也叫<strong>PC寄存器</strong>，是一块较小的内存空间，它可以看作是当前线程所执行的字节码指令的行号指示器。字节码解释器的工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支，循环，跳转，异常处理，线程回复等都需要依赖这个计数器来完成。</p><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（针对多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，<strong>每条线程都需要有一个独立的程序计数器</strong>，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>如果一个线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；</p><p>如果正在执行的是一个Native方法，这个计数器的值则为空。</p><p>此内存区域是唯一一个在Java的虚拟机规范中没有规定任何OutOfMemoryError异常情况的区域</p><h3 id="java虚拟机栈"><a class="markdownIt-Anchor" href="#java虚拟机栈"></a> Java虚拟机栈</h3><p>虚拟机栈也是线程私有，而且生命周期与线程相同，每个Java方法在执行的时候都会创建一个栈帧（Stack Frame）</p><h4 id="栈帧"><a class="markdownIt-Anchor" href="#栈帧"></a> 栈帧</h4><p><strong>栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用至执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程</strong>。</p><p>栈帧溢出：</p><pre><code class="highlight plaintext">package com.lee.configserver;public class testMain &#123;    public static void main(String[] args) &#123;        fun();    &#125;    public static void fun() &#123;        fun();//死循环    &#125;&#125;</code></pre><p>输出：</p><p>一个线程中方法的调用链可能会很长，很多方法都同时处于执行状态。对于JVM执行引擎来说，在在活动线程中，只有位于JVM虚拟机栈<strong>栈顶</strong>的元素才是有效的，即称为当前栈帧，与这个栈帧相关连的方法称为<strong>当前方法</strong>，定义这个方法的类叫做当前类。</p><p>执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。如果当前方法调用了其他方法，或者当前方法执行结束，那这个方法的栈帧就不再是当前栈帧了。</p><p>调用新的方法时，新的栈帧也会随之创建。并且随着程序控制权转移到新方法，新的栈帧成为了当前栈帧。方法返回之际，原栈帧会返回方法的执行结果给之前的栈帧(返回给方法调用者)，随后虚拟机将会丢弃此栈帧。</p><p>关于「栈帧」，我们在看看《Java虚拟机规范》中的描述：</p><blockquote><p>栈帧是用来存储数据和部分过程结果的数据结构，同时也用来处理动态连接、方法返回值和异常分派。</p></blockquote><blockquote><p>栈帧随着方法调用而创建，随着方法结束而销毁——无论方法正常完成还是异常完成都算作方法结束。</p></blockquote><blockquote><p>栈帧的存储空间由创建它的线程分配在Java虚拟机栈之中，每一个栈帧都有自己的本地变量表(局部变量表)、操作数栈和指向当前方法所属的类的运行时常量池的引用</p></blockquote><p>接下来，详细讲解一下栈帧中的局部变量表、操作数栈、动态连接、方法返回地址等各个部分的数据结构和作用。</p><h4 id="局部变量表"><a class="markdownIt-Anchor" href="#局部变量表"></a> 局部变量表</h4><p><strong>局部变量表</strong>(Local Variable Table)是一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。局部变量表的容量以变量槽(Variable Slot)为最小单位，Java虚拟机规范并没有定义一个槽所应该占用内存空间的大小，但是规定了一个槽应该可以存放一个32位以内的数据类型</p><blockquote><p>在Java程序编译为Class文件时,就在方法的Code属性中的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。(最大Slot数量)</p></blockquote><p>一个局部变量可以保存一个类型为boolean、byte、char、short、int、float、reference和returnAddress类型的数据。reference类型表示对一个对象实例的引用。returnAddress类型是为jsr、jsr_w和ret指令服务的，目前已经很少使用了</p><p>虚拟机通过索引定位的方法查找相应的局部变量，索引的范围是从0~局部变量表最大容量。如果Slot是32位的，则遇到一个64位数据类型的变量(如long或double型)，则会连续使用两个连续的Slot来存储</p><h4 id="操作数栈"><a class="markdownIt-Anchor" href="#操作数栈"></a> 操作数栈</h4><p><strong>操作数栈</strong>(Operand Stack)也常称为操作栈，它是一个后入先出栈(LIFO)。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到方法的Code属性的max_stacks数据项中。</p><p>操作数栈的每一个元素可以是任意Java数据类型，32位的数据类型占一个栈容量，64位的数据类型占2个栈容量,且在方法执行的任意时刻，操作数栈的深度都不会超过max_stacks中设置的最大值。</p><p>当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。</p><h4 id="动态连接"><a class="markdownIt-Anchor" href="#动态连接"></a> 动态连接</h4><p>在一个class文件中，一个方法要调用其他方法，需要将这些方法的<strong>符号引用</strong>转化为其在内存地址中的<strong>直接引用</strong>，而符号引用存在于方法区中的运行时常量池。</p><p>Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的<strong>动态连接</strong>(Dynamic Linking)。</p><p>这些符号引用一部分会在类加载阶段或者第一次使用时就直接转化为直接引用，这类转化称为静态解析。另一部分将在每次运行期间转化为直接引用，这类转化称为动态连接。</p><h4 id="方法返回"><a class="markdownIt-Anchor" href="#方法返回"></a> 方法返回</h4><p><strong>当一个方法开始执行时，可能有两种方式退出该方法</strong>：</p><ul><li>正常完成出口</li><li>异常完成出口</li></ul><p><strong>正常完成出口</strong>是指方法正常完成并退出，没有抛出任何异常(包括Java虚拟机异常以及执行时通过throw语句显示抛出的异常)。如果当前方法正常完成，则根据当前方法返回的字节码指令，这时有可能会有返回值传递给方法调用者(调用它的方法)，或者无返回值。具体是否有返回值以及返回值的数据类型将根据该方法返回的字节码指令确定</p><p><strong>异常完成出口</strong>是指方法执行过程中遇到异常，并且这个异常在方法体内部没有得到处理，导致方法退出。</p><blockquote><p>无论是Java虚拟机抛出的异常还是代码中使用athrow指令产生的异常，只要在本方法的异常表中没有搜索到相应的异常处理器，就会导致方法退出</p></blockquote><p>无论方法采用何种方式退出，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在当前栈帧中保存一些信息，用来帮他恢复它的上层方法执行状态</p><blockquote><p>方法退出过程实际上就等同于把当前栈帧出栈，因此退出可以执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压如调用者的操作数栈中，调整PC计数器的值以指向方法调用指令后的下一条指令</p></blockquote><p>一般来说，方法正常退出时，调用者的PC计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过异常处理器表确定的，栈帧中一般不会保存此部分信息</p><h4 id="附加信息栈异常"><a class="markdownIt-Anchor" href="#附加信息栈异常"></a> 附加信息/栈异常</h4><p><strong>附加信息</strong></p><p>虚拟机规范允许具体的虚拟机实现增加一些规范中没有描述的信息到栈帧之中，例如和调试相关的信息，这部分信息完全取决于不同的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其</p><p>他附加信息一起归为一类，称为栈帧信息</p><p><strong>栈异常</strong></p><p>Java虚拟机规范中，对该区域规定了这两种异常情况：</p><ol><li>如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出StackOverflowError异常；</li><li>虚拟机栈可以动态拓展，当扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常</li></ol><h3 id="本地方法栈"><a class="markdownIt-Anchor" href="#本地方法栈"></a> 本地方法栈</h3><p>本地方法栈和虚拟机栈相似，区别就是虚拟机栈为虚拟机执行<strong>Java服务（字节码服务）</strong>，而本地方法栈为虚拟机使用到的<strong>Native方法（比如C++方法）服务</strong></p><h4 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h4><p>简单地讲，一个Native Method就是一个java调用非java代码的接口</p><pre><code class="highlight plaintext">&quot;A native method is a Java method whose implementation is provided by nonjava code.&quot;</code></pre><p>一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C</p><p>在定义一个native method时，并不提供实现体（有些像定义一个java interface），因为其实现体是由非java语言在外面实现的。，下面给了一个示例：</p><pre><code class="highlight plaintext">public class IHaveNatives&#123;    native public void Native1( int x ) ;    native static public long Native2() ;    native synchronized private float Native3( Object o ) ;    native void Native4( int[] ary ) throws Exception ;&#125;</code></pre><p>这些方法的声明描述了一些非java代码在这些java代码里看起来像什么样子</p><p><strong>标识符native可以与所有其它的java标识符连用，但是abstract除外</strong>。这是合理的，因为native暗示这些方法是有实现体的，只不过这些实现体是非java的，但是abstract却显然的指明这些方法无实现体。</p><p><strong>native与其它java标识符连用时，其意义同非Native Method并无差别</strong>，比如native static表明这个方法可以在不产生类的实例时直接调用，这非常方便，比如当你想用一个native method去调用一个C的类库时。上面的第三个方法用到了native synchronized，JVM在进入这个方法的实现体之前会执行同步锁机制（就像java的多线程。）</p><p><strong>一个native method方法可以返回任何java类型</strong>，<strong>包括非基本类型，而且同样可以进行异常控制</strong>。这些方法的实现体可以制一个异常并且将其抛出，这一点与java的方法非常相似。</p><p><strong>当一个native method接收到一些非基本类型时如Object或一个整型数组时，这个方法可以访问这些非基本型的内部，但是这将使这个native方法依赖于你所访问的java类的实现</strong>。有一点要牢牢记住：我们可以在一个native method的本地实现中访问所有的java特性，但是这要依赖于你所访问的java特性的实现，而且这样做远远不如在java语言中使用那些特性方便和容易</p><p><strong>native method的存在并不会对其他类调用这些本地方法产生任何影响，实际上调用这些方法的其他类甚至不知道它所调用的是一个本地方法。JVM将控制调用本地方法的所有细节</strong>。需要注意当我们将一个本地方法声明为final的情况。用java实现的方法体在被编译时可能会因为内联而产生效率上的提升。但是一个native final方法是否也能获得这样的好处却是值得怀疑的，但是这只是一个代码优化方面的问题，对功能实现没有影响</p><p><strong>如果一个含有本地方法的类被继承，子类会继承这个本地方法并且可以用java语言重写这个方法（这个似乎看起来有些奇怪），同样的如果一个本地方法被fianl标识，它被继承后不能被重写</strong>。</p><p><strong>本地方法非常有用，因为它有效地扩充了jvm</strong>。事实上，我们所写的java代码已经用到了本地方法，在sun的java的并发（多线程）的机制实现中，许多与操作系统的接触点都用到了本地方法，这使得java程序能够超越java运行时的界限。有了本地方法，java程序可以做任何应用层次的任务</p><hr /><p><strong>为什么要用本地方法？</strong></p><p>java使用起来非常方便，然而有些层次的任务用java实现起来不容易，或者我们对程序的效率很在意时，问题就来了</p><p><strong>有时java应用需要与java外面的环境交互。这是本地方法存在的主要原因，你可以想想java需要与一些底层系统如操作系统或某些硬件交换信息时的情况</strong>。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐的细节</p><p>JVM支持着java语言本身和运行时库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎 样，它毕竟不是一个完整的系统，它经常依赖于一些底层（underneath在下面的）系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的，还有，如果我们要使用一些java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法</p><hr /><p><strong>JVM怎样使本地方法跑起来</strong></p><p>我们知道，当一个类第一次被使用到时，这个类的字节码会被加载到内存，并且只会回载一次。在这个被加载的字节码的入口维持着一个该类所有方法描述符的list，这些方法描述符包含这样一些信息：方法代码存于何处，它有哪些参数，方法的描述符（public之类）等等。</p><p>如果一个方法描述符内有native，这个描述符块将有一个指向该方法的实现的指针。这些实现在一些DLL文件内，但是它们会被操作系统加载到java程序的地址空间。当一个带有本地方法的类被加载时，其相关的DLL并未被加载，因此指向方法实现的指针并不会被设置。当本地方法被调用之前，这些DLL才会被加载，这是通过调用java.system.loadLibrary()实现的。</p><p>最后需要提示的是，使用本地方法是有开销的，它丧失了java的很多好处。如果别无选择，我们可以选择使用本地方法。</p><h4 id="使用流程"><a class="markdownIt-Anchor" href="#使用流程"></a> 使用流程</h4><p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。本地方法可以通过本地方法接口来访问虚拟机的运行时数据区，但不止如此，它还可以做任何它想做的事情。</p><p>本地方法本质上时依赖于实现的，虚拟机实现的设计者们可以自由地决定使用怎样的机制来让Java程序调用本地方法。</p><p>任何本地方法接口都会使用某种本地方法栈。当线程调用Java方法时，虚拟机会创建一个新的栈帧并压入Java栈。<strong>然而当它调用的是本地方法时，虚拟机会保持Java栈不变，不再在线程的Java栈中压入新的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法</strong>。</p><p>如果某个虚拟机实现的本地方法接口是使用C连接模型的话，那么它的本地方法栈就是C栈。当C程序调用一个C函数时，其栈操作都是确定的。传递给该函数的参数以某个确定的顺序压入栈，它的返回值也以确定的方式传回调用者。同样，这就是虚拟机实现中本地方法栈的行为。</p><p>很可能本地方法接口需要回调Java虚拟机中的Java方法，在这种情况下，该线程会保存本地方法栈的状态并进入到另一个Java栈</p><hr /><p><strong>下图描绘了这样一个情景，就是当一个线程调用一个本地方法时，本地方法又回调虚拟机中的另一个Java方法</strong></p><p>这幅图展示了JAVA虚拟机内部线程运行的全景图。一个线程可能在整个生命周期中都执行Java方法，操作它的Java栈；或者它可能毫无障碍地在Java栈和本地方法栈之间跳转</p><p>该线程首先调用了两个Java方法，而第二个Java方法又调用了一个本地方法，这样导致虚拟机使用了一个本地方法栈。假设这是一个C语言栈，其间有两个C函数，第一个C函数被第二个Java方法当做本地方法调用，而这个C函数又调用了第二个C函数。之后第二个C函数又通过本地方法接口回调了一个Java方法（第三个Java方法），最终这个Java方法又调用了一个Java方法（它成为图中的当前方法</p><h3 id="java内存模型"><a class="markdownIt-Anchor" href="#java内存模型"></a> Java内存模型</h3><p>合理的内存模型可以使GC的性能更加强大，不必太大的浪费服务器的性能，从而减少阻塞所带来的程序的性能影响</p><ul><li>例：你现在收拾屋子，基本上我们会有两类收拾方法<ul><li>方式一：简单的进行物品的码放以及打扫卫生，时间短</li><li>方式二：房屋装修与改造，时间长</li></ul></li></ul><p>Java中数据报错的内存位置：堆内存（调优，原理）：</p><ul><li>最需要强调的就是JDK1.8之后所带来的内存结构改变以及GC策略提升</li></ul><p><strong>jdk1.8之前</strong></p><p><strong>jdk1.8之后</strong></p><ul><li>当内存不足的时候需要堆伸缩区进行控制，当内存充足的时候就要考虑将伸缩区的内存释放掉，来回的计算伸缩必会造成额外的计算机性能的影响，导致程序的整体性能下降</li></ul><p><strong>用RunTime类获取当前运行环境的最大内存和最小内存</strong></p><p>RunTime类常用方法：</p><ul><li>getRuntime()：该方法用于返回当前应用程序的运行环境对象</li><li>exec(String command)：该方法用于根据指定的路径执行对应的可执行文件。</li><li>freeMemory()：该方法用于返回Java虚拟机中的空闲内存量，以字节为单位。</li><li>maxMemory()：该方法用于返回Java虚拟机试图使用的最大内存量</li><li>totalMemory()：该方法用于返回Java虚拟机中的内存总量。</li></ul><pre><code class="highlight plaintext">package com.lee.configserver;public class testMain &#123;    public static void main(String[] args) &#123;        //RunTime类主要代表了应用程序的运行环境。一个RunTime就代表一个运行环境        System.out.println(&quot;MAX_MEMORY:&quot;+byteToM(Runtime.getRuntime().maxMemory())+&quot;M&quot;);        System.out.println(&quot;TOTAL_MEMORY:&quot;+byteToM(Runtime.getRuntime().totalMemory())+&quot;M&quot;);    &#125;    public static double round(double num,int scale)&#123;        //Math.pow求次方        //Math.round取整        return Math.round(Math.pow(10, scale) * num) / Math.pow(10, scale);    &#125;    public static double byteToM(long num)&#123;        return round(num/1024/1024,2);    &#125;&#125;</code></pre><blockquote><p>我先自的内存为8G，所以会发现默认的内容：</p><p>MaxMemory：整体电脑内存的1/4</p><p>TotalMemory：整体电脑内存的1/64</p></blockquote><blockquote><p>伸缩区的空间：MaxMemory - TotalMemory = 可变的伸缩区空间极大</p></blockquote><h3 id="jvm调优"><a class="markdownIt-Anchor" href="#jvm调优"></a> JVM调优</h3><p>JVM可以调优的点重要的就是这三点:</p><ul><li>取消伸缩区</li><li>GC执行分析（算法）</li><li>垃圾回收策略</li></ul><h4 id="取消伸缩区"><a class="markdownIt-Anchor" href="#取消伸缩区"></a> 取消伸缩区</h4><p><strong>当伸缩区空间较小的时候那么JVM的性能必然会得到提升</strong></p><p>所以我们程序执行的设置有相应的执行参数：</p><ul><li><code>-Xmx</code>：分配最大的初始化内存</li><li><code>-Xms</code>：最大的分配内存</li></ul><p>执行jar程序的时候就可以加执行参数：</p><pre><code class="highlight plaintext">java -Xmx大小单位 -Xms大小单位 类文件示例：java -Xmx1000M -Xms3G</code></pre><p>示例：</p><p>现在idea中设置jvm启动参数：</p><p>然后执行程序：</p><pre><code class="highlight plaintext">package com.lee.configserver;public class testMain &#123;    public static void main(String[] args) &#123;        //RunTime类主要代表了应用程序的运行环境。一个RunTime就代表一个运行环境        System.out.println(&quot;MAX_MEMORY:&quot;+byteToM(Runtime.getRuntime().maxMemory())+&quot;M&quot;);        System.out.println(&quot;TOTAL_MEMORY:&quot;+byteToM(Runtime.getRuntime().totalMemory())+&quot;M&quot;);    &#125;    public static double round(double num,int scale)&#123;        //Math.pow求次方        //Math.round取整        return Math.round(Math.pow(10, scale) * num) / Math.pow(10, scale);    &#125;    public static double byteToM(long num)&#123;        return round(num/1024/1024,2);    &#125;&#125;</code></pre><p>结果：</p><ul><li>我们发现，加了启动参数后，jvm的运行时空间内存发生了改变</li></ul><h4 id="gc处理流程"><a class="markdownIt-Anchor" href="#gc处理流程"></a> GC处理流程</h4><ol><li>对象实例化需要依据关键字new完成，所有的新对象都会在伊甸园开辟，如果伊甸园的内存空间不足会发生MinorGc<ul><li>Member mem = new Member(); 很小，直接保存在伊甸园；</li></ul></li><li>伊甸园不是无限大的，所以肯定有些对象执行了N次的MinorGC后还会存在，那么这些对象将进入到存货区（存货区有两个，一个负责保存存活对象，一个负责晋升，永远都有一个空内存）</li><li>如果经历过若干次的MinorGC回收处理之后发现空间依然不够使用的，那么则进行老年代的GC回收，执行了一个MajorGC(Full GC，性能很差)，如果可以回收空间，则继续进行MinorGC</li><li>如果MajorGC失败，则继续内存已经占满，则抛出OOM异常</li><li>如果新创建的对象的空间占用过大将直接保存到老年代之中</li></ol><p>让内存溢出：</p><pre><code class="highlight plaintext">package com.lee.configserver;public class testMain &#123;    public static void main(String[] args) &#123;        String str = &quot;hello&quot;;        for(int x = 0;x&lt;Integer.MAX_VALUE;x++)&#123;            //str.intern()返回一个字符串，内容与此字符串相同，但一定取自具有唯一字符串的池            str += str.intern();        &#125;    &#125;&#125;</code></pre><h4 id="查看垃圾回收"><a class="markdownIt-Anchor" href="#查看垃圾回收"></a> 查看垃圾回收</h4><pre><code class="highlight plaintext">-Xmx20M -Xms20M -XX:+PrintGCDetails     //JDK1.9之后使用-XX:+PrintGCDetails查看垃圾回收详情-Xmx2M -Xms2M -Xlog:gc*    //JDK1.9之后使用-Xlog:gc* 查看垃圾回收详情</code></pre><blockquote><p>JDK1.8的时候默认会根据系统的不同而选择不同的GC回收策略</p><p>JDK1.9之后，使用的默认GC操作就是G1</p></blockquote><p><strong>JDK1.8</strong></p><pre><code class="highlight plaintext">package com.lee.configserver;public class testMain &#123;    public static void main(String[] args) &#123;        String str = &quot;hello&quot;;        for(int x = 0;x&lt;Integer.MAX_VALUE;x++)&#123;            //str.intern()返回一个字符串，内容与此字符串相同，但一定取自具有唯一字符串的池            str += str.intern();        &#125;    &#125;&#125;</code></pre><p>给上述代码加上启动参数：</p><pre><code class="highlight plaintext">-Xmx20M -Xms20M -XX:+PrintGCDetails</code></pre><p>输出：</p><p><strong>JDK1.9之后</strong></p><pre><code class="highlight plaintext">package com.lee.configserver;public class testMain &#123;    public static void main(String[] args) &#123;        String str = &quot;hello&quot;;        for(int x = 0;x&lt;Integer.MAX_VALUE;x++)&#123;            //str.intern()返回一个字符串，内容与此字符串相同，但一定取自具有唯一字符串的池            str += str.intern();        &#125;    &#125;&#125;</code></pre><p>给上述代码加上启动参数：</p><pre><code class="highlight plaintext">-Xmx2M -Xms2M -Xlog:gc*</code></pre><p>运行：</p><h4 id="内存回收算法"><a class="markdownIt-Anchor" href="#内存回收算法"></a> 内存回收算法</h4><p>年轻代回收算法：</p><ul><li>“复制”清理算法：将保留的对象复制到存货区之中，存货区的内容或保存到老年代之中</li><li>伊甸园区总是会有大量的新对象产生，所以HotSpot虚拟机使用了BTP（单核CPU的试带所有的对象依次保存，相当于队列），TLAB（多核CPU，吧队列拆分为不同的块，依据CPU的核心个数拆分）两种技术形式的处理</li></ul><p>老年代回收算法：</p><ul><li>“标记-清除”算法：先进性对象的第一次标记，在这段时间之内会暂停程序的执行（如果标记的时间过程或者对象的内容过多），这个暂停的时间就会长<ul><li>串行GC</li><li>并行回收GC</li><li>并行GC</li></ul></li><li>“标记-压缩”算法：基于“标记-清除”算法，将零散的内存空间进重新整理在进行分配<ul><li>串行GC</li><li>并行回收GC</li><li>CMS(挂起)<ul><li>STW(Stop-The-World)设计问题，暂时挂起所有的程序的执行线程，进行无用的对象标记</li></ul></li></ul></li></ul><blockquote><p>没有任何一项合适的GC回收操作能完美的解决完美回收，从JDK1.8开始提供了G1收集器，在JDK11之后提供了ZGC</p></blockquote><p><strong>G1算法</strong></p><ul><li>支持大内存（4G-64G），支持有多CPU，减少STW停顿时间，可以保证并发状态下的程序执行</li><li>G1算法实际就是把Java内存给分了一堆块，每一个块都包含完整的老年代，年轻代，都是相对独立的内存空间，所以只是单个块的垃圾回收，那么内存不会特别大，对象也不会特别多，只会影响一小部分用户，其他用户不会受到影响</li></ul><p>jdk1.8之前可以手动的更改为G1算法回收</p><pre><code class="highlight plaintext">-XX:+UseG1GC</code></pre><blockquote><p>jdk11之后默认就是G1回收器，对于其他的回收算法实际上可以忽略掉</p></blockquote><h3 id="java堆"><a class="markdownIt-Anchor" href="#java堆"></a> Java堆</h3><p>Java堆被所有线程共享，在Java虚拟机启动时创建。是虚拟机管理最大的一块内存。</p><p><strong>唯一目的是存放对象实例，Java虚拟机规范的描是：所有的对象实例以及数组都要在堆上分配</strong></p><p>随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”</p><ul><li>内存空间在物理上可以不连续，逻辑上连续即可。</li><li>Java堆是垃圾回收的主要区域，主要采用分代回收算法。</li><li>堆进一步划分主要是为了更好的回收内存或更快的分配内存</li></ul><h4 id="堆分类"><a class="markdownIt-Anchor" href="#堆分类"></a> 堆分类</h4><p><strong>1.8之前</strong></p><ul><li>新生代（Eden空间[伊甸园]，From Survivor空间，To Survivor空间）</li><li>老年代</li><li>永久代</li></ul><p><strong>1.8之后(含1.8)</strong></p><ul><li>新生代（Eden空间[伊甸园]，From Survivor空间，To Survivor空间）、</li><li>老年代</li><li>Meta Space</li></ul><p>在 JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）</p><hr /><p><strong>堆内存划分：</strong></p><ul><li>堆大小 = 新生代 + 老年代。堆的大小可通过参数–Xms（堆的初始容量）、-Xmx（堆的最大容量） 来指定。</li></ul><pre><code class="highlight plaintext">java -Xmx大小单位 -Xms大小单位 类文件示例：java -Xmx1000M -Xms3G</code></pre><ul><li>其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。默认的，Edem : from : to = 8 : 1 : 1 。(可以通过参数 –XX:SurvivorRatio 来设定 。</li></ul><blockquote><p>即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。</p></blockquote><pre><code class="highlight plaintext">–XX:SurvivorRatio大小单位</code></pre><ul><li>JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。</li><li>新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间</li></ul><h4 id="对象创建"><a class="markdownIt-Anchor" href="#对象创建"></a> 对象创建</h4><pre><code class="highlight plaintext">Student stu = new Student();</code></pre><h4 id="内存分配"><a class="markdownIt-Anchor" href="#内存分配"></a> 内存分配</h4><p><strong>内存分配原则</strong></p><table><thead><tr><th>序号</th><th>介绍</th></tr></thead><tbody><tr><td>1</td><td>优先在Eden分配,如果Eden空间不足虚拟机则会进行一次MinorGC</td></tr><tr><td>2</td><td>大对象直接接入老年代,大对象一般指的是很长的字符串或数组</td></tr><tr><td>3</td><td>长期存活的对象进入老年代，每个对象都有一个age，当age到达设定的年龄的时候就会进入老年代，默认是15岁</td></tr></tbody></table><p><strong>内存分配</strong></p><p>内存分配的方法有两种:指针碰撞(Bump the Pointer)和空闲列表(Free List)</p><table><thead><tr><th>分配方法</th><th>说明</th><th>收集器</th></tr></thead><tbody><tr><td>指针碰撞</td><td>内存地址是连续的</td><td>Serial和ParNew收集器</td></tr><tr><td>空闲列表</td><td>内存地址不连续</td><td>CMS收集器和Mark-Sweep收集器</td></tr></tbody></table><hr /><p><strong>内存分配安全问题</strong></p><p>在分配内存的同时，存在线程安全的问题，即虚拟机给A线程分配内存过程中，指针未修改，B线程可能同时使用了同样一块内存。</p><p>在JVM中有两种解决办法：</p><ol><li>**CAS，比较和交换（**Compare And Swap）： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</li><li><strong>TLAB，本地线程分配缓冲</strong>(Thread Local Allocation Buffer即TLAB)： 为每一个线程预先分配一块内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配。</li></ol><h4 id="对象的访问"><a class="markdownIt-Anchor" href="#对象的访问"></a> 对象的访问</h4><table><thead><tr><th>方式</th><th>优点</th></tr></thead><tbody><tr><td>句柄</td><td>稳定，对象被移动只要修改句柄中的地址</td></tr><tr><td>直接指针</td><td>访问速度快，节省了一次指针定位的开销</td></tr></tbody></table><h4 id="数组内存分析"><a class="markdownIt-Anchor" href="#数组内存分析"></a> 数组内存分析</h4><p><strong>一维数组</strong></p><pre><code class="highlight plaintext">int[] arr1 = new int[3];</code></pre><p>先把 arr1 压进栈，然后在堆空间中开辟一个空间，并把值初始化为0（arr1为引用变量，但是内部数据是int类型，默认值为 0）,最后把 开辟的堆空间地址 赋值给arr1</p><pre><code class="highlight plaintext">int[] arr2 = arr1;</code></pre><p>把 arr1 中的 地址 赋值给 arr2，此时 arr2 和 arr1 指向同一块空间</p><pre><code class="highlight plaintext">arr2[0] = 20;</code></pre><p>此时，arr1[0] 值为 20</p><hr /><p><strong>二维数组</strong></p><pre><code class="highlight plaintext">int[][] array = new int[3][];</code></pre><p>这条语句会先把 array 压栈，然后在堆中开辟一个空间，初始值为 null（array为引用变量，第一维同样是引用类型），最后把开辟的堆空间地址赋值给 array</p><pre><code class="highlight plaintext">array[0][] = new int[1]</code></pre><p>这条语句会在堆空间中开辟一个 只有一个 int 类型大小的空间，并初始化为 0 ，然后把自己的地址赋值给array<code>[0][]</code></p><pre><code class="highlight plaintext">array[1][] = new int[2];array[2][] = new int[3];</code></pre><h3 id="方法区"><a class="markdownIt-Anchor" href="#方法区"></a> 方法区</h3><h4 id="永久代-方法区-元空间的关系"><a class="markdownIt-Anchor" href="#永久代-方法区-元空间的关系"></a> 永久代、方法区、元空间的关系</h4><p><strong>jdk1.8之前</strong></p><p><strong>jdk1.8之后</strong></p><ul><li>当内存不足的时候需要堆伸缩区进行控制，当内存充足的时候就要考虑将伸缩区的内存释放掉，来回的计算伸缩必会造成额外的计算机性能的影响，导致程序的整体性能下降</li></ul><p>涉及到JVM内存结构时，往往会提到永久代，那么它和方法区又是什么关系呢？</p><p><strong>《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它</strong>。</p><p>那么，在不同的 JVM 上方法区的实现肯定是不同的了。 同时大多数用的JVM都是Sun公司的HotSpot。在HotSpot上把GC分代收集扩展至方法区，或者说<strong>使用永久代来实现方法区</strong>。</p><p>因此，我们得到了结论，永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现。而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。</p><ul><li>在1.7之前在(JDK1.2 ~ JDK7)的实现中，HotSpot 使用永久代实现方法区，HotSpot 使用 GC分代来实现方法区内存回收，可以使用如下参数来调节方法区的大小:</li></ul><pre><code class="highlight plaintext">-XX:PermSize：方法区初始大小-XX:MaxPermSize：方法区最大大小超过这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: PermGen</code></pre><ul><li>对于Java8， HotSpots取消了永久代，那么是不是也就没有方法区了呢？当然不是，方法区是一个规范，规范没变，它就一直在。那么取代永久代的就是元空间</li></ul><p><strong>元空间和永久代有什么不同的？</strong></p><p>存储位置不同，永久代物理是是堆的一部分，和新生代，老年代地址是连续的，而元空间属于本地内存；</p><p>存储内容不同，元空间存储类的元信息，[静态变量]和[常量池]等并入堆中。相当于永久代的数据被分到了堆和元空间中</p><hr /><p>通过上面分析，大家应该大致了解了 JVM 的内存划分，也清楚了 JDK 8 中永久代向元空间的转换。不过大家应该都有一个疑问，就是为什么要做这个转换？带着这个疑问，最后给大家总结以下几点原因：</p><ol><li>字符串存在永久代中，容易出现性能问题和内存溢出。</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢</li></ol><p>出，太大则容易导致老年代溢出。</p><ol><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li><li>Oracle 可能会将HotSpot 与 JRockit 合二为一。</li></ol><h4 id="permgen永久代"><a class="markdownIt-Anchor" href="#permgen永久代"></a> PermGen(永久代)</h4><p>绝大部分 Java 程序员应该都见过 &quot;java.lang.OutOfMemoryError: PermGen space &quot;这个异常。这里的 “PermGen space”其实指的就是方法区。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出</p><p>我们现在通过动态生成类来模拟永久代的内存溢出(本例中使用的 JDK 版本是 1.7，指定的 PermGen区的大小为 8M)：</p><pre><code class="highlight plaintext">package com.kkb.test.memory;public class Test &#123;&#125;</code></pre><pre><code class="highlight plaintext">package com.kkb.test.memory;import java.io.File;import java.net.URL;import java.net.URLClassLoader;import java.util.ArrayList;import java.util.List;public class PermGenOomMock&#123;    public static void main(String[] args) &#123;        URL url = null;        List&lt;ClassLoader&gt; classLoaderList = new ArrayList&lt;ClassLoader&gt;();        try &#123;             url = new File(&quot;/tmp&quot;).toURI().toURL();             URL[] urls = &#123;url&#125;;        while (true)&#123;            ClassLoader loader = new URLClassLoader(urls);            classLoaderList.add(loader);            loader.loadClass(&quot;com.kkb.test.memory.Test&quot;);        &#125;        &#125; catch (Exception e) &#123;           e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>通过每次生成不同URLClassLoader对象来加载Test类，从而生成不同的类对象，这样就能看到我们熟</p><p>悉的 &quot;java.lang.OutOfMemoryError: PermGen space &quot; 异常了。这里之所以采用 JDK 1.7，是因为在JDK 1.8 中， HotSpot 已经没有 “PermGen space”这个区间了，取而代之是一个叫做 Metaspace（元空间） 的东西。下面我们就来看看 Metaspace 与 PermGen space 的区别</p><h4 id="metaspace元空间"><a class="markdownIt-Anchor" href="#metaspace元空间"></a> Metaspace(元空间)</h4><p>方法区也是所有线程共享。主要用于存储类的信息、常量池、方法数据、方法代码等。</p><p><strong>方法区是JVM 的规范，永久代（PermGen space）是HotSpot对这种规范的实现</strong></p><p>其实，移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了JavaHeap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。我们可以通过一段程序来比较 JDK 1.6 与 JDK 1.7及 JDK 1.8 的区别，以字符串常量为例：</p><pre><code class="highlight plaintext">package com.kkb.test.memory;import java.util.ArrayList;import java.util.List;public class StringOomMock &#123;static String base = &quot;string&quot;;public static void main(String[] args) &#123;List&lt;String&gt; list = new ArrayList&lt;String&gt;();for (int i=0;i&lt; Integer.MAX_VALUE;i++)&#123;String str = base + base;base = str;list.add(str.intern());&#125;&#125;&#125;</code></pre><p>这段程序以2的指数级不断的生成新的字符串，这样可以比较快速的消耗内存。我们通过 JDK 1.6、JDK1.7 和 JDK 1.8 分别运行：</p><p>从上述结果可以看出，JDK 1.6下，会出现“PermGen Space”的内存溢出，而在 JDK 1.7和 JDK 1.8 中，会出现堆内存溢出，并且 JDK 1.8中 PermSize 和 MaxPermGen 已经无效。因此，可以大致验证 JDK1.7 和 1.8 将字符串常量由永久代转移到堆中，并且 JDK 1.8 中已经不存在永久代的结论。</p><hr /><p><strong>现在我们看看元空间到底是一个什么东西？</strong></p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：<strong>元空间并不在虚拟机中，而是使用本地内存</strong>。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</p><pre><code class="highlight plaintext">-XX:MetaspaceSize：初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。-XX:MaxMetaspaceSize：最大空间，默认是没有限制的。除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：-XX:MinMetaspaceFreeRatio：在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集-XX:MaxMetaspaceFreeRatio：在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</code></pre><p>现在我们在 JDK 8下重新运行一下代码段 4，不过这次不再指定 PermSize 和 MaxPermSize。而是指定MetaSpaceSize 和 MaxMetaSpaceSize的大小。输出结果如下：</p><blockquote><p>从输出结果，我们可以看出，这次不再出现永久代溢出，而是出现了元空间的溢出。</p></blockquote><h3 id="运行时常量池字符串常量池"><a class="markdownIt-Anchor" href="#运行时常量池字符串常量池"></a> 运行时常量池/字符串常量池</h3><p>运行时常量池存储在哪？</p><ul><li><strong>&lt;=JDK1.6</strong>，运行时常量池是方法区的一部分。</li><li><strong>&gt;=JDK1.7</strong>，运行时常量池在Java 堆（Heap）中</li></ul><p>class常量池存放编译期生成的字面量和符号引用，这部分将在类加载后放到运行时常量池中。<strong>运行时常量池也是每个类都有一个</strong></p><hr /><p><strong>运行时常量池中存储的内容是什么？</strong></p><p><strong>class常量池与运行时常量池区别</strong></p><p>运行时常量池具有动态性，java运行期间也可能将新的常量放入池中</p><p>它的字面量可以动态的添加(String#intern()),符号引用可以被解析为直接引用</p><p><strong>字符串常量池存储在哪？</strong></p><p>在JDK6.0及之前版本，字符串常量池是放在Perm Gen区(也就是方法区)中；</p><p>在JDK7.0版本，被移到了堆中。大概是由于方法区的内存空间太小了。</p><p><strong>String Pool是什么？</strong></p><p>在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个Hash表，默认值大小长度是1009；这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。字符串常量由一个一个字符组成，放在了StringTable上。</p><p>在JDK6.0中，StringTable的长度是固定的，长度就是1009，因此如果放入String Pool中的String非常多，就会造成hash冲突，导致链表过长，当调用String.intern()时会需要到链表上一个一个找，从而导致性能大幅度下降；</p><p>在JDK7.0中，StringTable的长度可以通过参数指定：</p><pre><code class="highlight plaintext">-XX:StringTableSize=66666</code></pre><p><strong>字符串常量池中存储的是值还是引用？</strong></p><p>在JDK6.0及之前版本中，String Pool里放的都是字符串常量</p><p>在JDK7.0中，由于String.intern()发生改变，因此也可存放放于堆内的字符串对象的引用</p><blockquote><p>需要说明的是：字符串常量池中的字符串只存在一份！</p></blockquote><pre><code class="highlight plaintext">String s1 = &quot;hello,world!&quot;;String s2 = &quot;hello,world!&quot;;s1 == s2 // true</code></pre><hr /><p><strong>String和String Pool的关系</strong></p><p>1、<strong>不可变的String</strong></p><p>String的底层实际上是使用private final char[] value来实现字符串的存储的，就是说String对象一旦创建之后，就不能再修改这个对象存储的字符串内容。正因为如此，也说String类是不可改变的</p><p>2、<strong>什么是String Pool</strong></p><p>在JVM中存放着一个字符串池，其中保存着很多String对象，这些对象可以被共享使用。当以字符串直接创建String对象时，会首先在字符串池中查找是否存在该常量。如果不存在，则在String</p><p>Pool中创建一个，然后将其地址返回。如果在String Pool中查询到已经存在该常量，则不创建对象，直接返回这个对象地址。</p><p>3、<strong>String的创建</strong></p><p>有了以上两个概念，就可以说说String的创建了。String主要有两种创建方式，如下：</p><pre><code class="highlight plaintext">String str1 = new String(“abc”);String str2 = “abc”;</code></pre><p>虽然两个语句都是返回一个String对象的引用，但是JVM对这两种创建的方式是不一样的。对于第一种，JVM会在内部维护的String Pool中存放一个”abc”的对象，并且在heap中创建一个String对象，然后将该heap中的对象的引用返回给用户。第二种，JVM首先会在String Pool中查找是否存在”abc”对象，如果已经有则不创建，没有的话则在String Pool中创建一个对象</p><hr /><p>有了以上概念，列一个经常考的面试题：</p><pre><code class="highlight plaintext">String s1 = new String(“abc”);String s2 = new String(“abc”);</code></pre><p>上面创建了几个String对象？（3个）</p><hr /><p><strong>String的Intern方法详解</strong></p><p><strong>引言</strong></p><p>String 类型的常量池比较特殊。它的主要使用方法有两种：</p><ul><li>直接使用双引号声明出来的String 对象会直接存储在常量池中。</li><li>如果不是用双引号声明的String 对象，可以使用String 提供的intern 方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中</li></ul><p><strong>intern 的实现原理</strong></p><p>String#intern 方法中看到，这个方法是一个 native 的方法，但注释写的非常明了。“如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回”。</p><p>它的大体实现结构就是:JAVA 使用 jni 调用c++实现的StringTable 的intern 方法, StringTable的intern 方法跟Java中的HashMap 的实现是差不多的, 只是不能自动扩容。默认大小是1009。</p><p>要注意的是，String的String Pool是一个固定大小的Hashtable ，默认值大小长度是1009，如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern 时性能会大幅下降</p><ul><li>在jdk6中StringTable 是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。</li><li>在jdk7中， StringTable 的长度可以通过一个参数指定：</li></ul><pre><code class="highlight plaintext">-XX:StringTableSize=99991</code></pre><hr /><p><strong>jdk6 和 jdk7 下 intern 的区别</strong></p><p>相信很多 JAVA 程序员都做做类似 String s = new String(“abc”) 这个语句创建了几个对象的题目。 这种题目主要就是为了考察程序员对字符串对象的常量池掌握与否。</p><p>上述的语句中是创建了2个对象，第一个对象是”abc”字符串存储在常量池中，第二个对象在JAVA Heap中的 String 对象</p><pre><code class="highlight plaintext">public static void main(String[] args) &#123;    String s = new String(&quot;1&quot;);    s.intern();    String s2 = &quot;1&quot;;    System.out.println(s == s2);    String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);    s3.intern();    String s4 = &quot;11&quot;;    System.out.println(s3 == s4);&#125;</code></pre><p>输出：</p><ul><li>jdk6 下 <code>false false</code></li><li>jdk7 下 <code>false true</code></li></ul><p>具体为什么稍后再解释，然后将s3.intern(); 语句下调一行，放到String s4 = “11”; 后面。将s.intern(); 放到String s2 = “1”; 后面。是什么结果呢</p><pre><code class="highlight plaintext">public static void main(String[] args) &#123;    String s = new String(&quot;1&quot;);    String s2 = &quot;1&quot;;    s.intern();    System.out.println(s == s2);    String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);    String s4 = &quot;11&quot;;    s3.intern();    System.out.println(s3 == s4);&#125;</code></pre><p>打印结果为：</p><ul><li>jdk6 下<code>false false</code></li><li>jdk7 下<code>false false</code></li></ul><p><strong>1.jdk6中的解释</strong></p><blockquote><p>注：图中绿色线条代表 string 对象的内容指向。 黑色线条代表地址指向。</p></blockquote><p>如上图所示。首先说一下 jdk6中的情况，在 jdk6中上述的所有打印都是 false 的，因为 jdk6中的常量池是放在 Perm 区中的，Perm区和正常的 JAVA Heap 区域是完全分开的。上面说过如果是使用引号声明的字符串都是会直接在字符串常量池中生成，而 new 出来的 String 对象是放在 JAVA Heap 区域。所以拿一个 JAVA Heap 区域的对象地址和字符串常量池的对象地址进行比较肯定是不相同的，即使调用String.intern 方法也是没有任何关系的</p><p><strong>2.jdk7中的解释</strong></p><p>在 Jdk6 以及以前的版本中，字符串的常量池是放在堆的Perm区的，Perm区是一个类静态的区域，主要存储一些加载类的信息，常量池，方法片段等内容，默认大小只有4m，一旦常量池中大量使用intern 是会直接产生java.lang.OutOfMemoryError:PermGen space 错误的。在 jdk7 的版本中，字符串常量池已经从Perm区移到正常的Java Heap区域了。为什么要移动，Perm 区域太小是一个主要原因，当然据消息称jdk8已经直接取消了Perm区域，而新建立了一个元区域。应该是jdk开发者认为Perm区域已经不适合现在 JAVA 的发展了。正式因为字符串常量池移动到JAVA Heap区域后，再来解释为什么会有上述的打印结果。</p><ul><li><p>在第一段代码中，先看 s3和s4字符串。String s3 = new String(“1”) + new String(“1”); ，这句代码中现在生成了2最终个对象，是字符串常量池中的“1” 和 JAVA Heap中的s3引用指向的对象。中间还有2个匿名的new String(“1”) 我们不去讨论它们。此时s3引用对象内容是”11″，但此时常量池中是没有 “11”对象的。</p></li><li><p>接下来s3.intern(); 这一句代码，是将 s3中的&quot;11&quot;字符串放入String 常量池中，因为此时常量池中不存在&quot;11&quot;字符串，因此常规做法是跟 jdk6 图中表示的那样，在常量池中生成一个&quot;11&quot;的对象，关键点是 jdk7 中常量池不在Perm区域了，这块做了调整。常量池中不需要再存储一份对象了，可以直接存储堆中的引用。这份引用指向s3引用的对象。 也就是说引用地址是相同的。</p></li><li><p>最后String s4 = “11”; 这句代码中”11″是显示声明的，因此会直接去常量池中创建，创建的时候发现已经有这个对象了，此时也就是指向s3引用对象的一个引用。所以s4引用就指向和s3一样了。因此最后的比较 s3 == s4 是 true。</p></li><li><p>再看s和 s2 对象。String s = new String(“1”); 第一句代码，生成了2个对象。常量池中的“1”和 JAVA Heap 中的字符串对象。s.intern(); 这一句是 s 对象去常量池中寻找后发现 “1” 已经在常量池里了。</p></li><li><p>接下来String s2 = “1”; 这句代码是生成一个 s2的引用指向常量池中的“1”对象。 结果就是 s 和s2 的引用地址明显不同。图中画的很清晰。</p></li><li><p>来看第二段代码，从上边第二幅图中观察。第一段代码和第二段代码的改变就是 s3.intern();的顺序是放在String s4 = “11”; 后了。这样，首先执行String s4 = “11”; 声明 s4 的时候常量池中是不存在“11”对象的，执行完毕后，“11“对象是 s4 声明产生的新对象。然后再执行s3.intern(); 时，常量池中“11”对象已经存在了，因此 s3 和 s4 的引用是不同的。</p></li><li><p>第二段代码中的 s 和 s2 代码中， s.intern(); ，这一句往后放也不会有什么影响了，因为对象池中在执行第一句代码String s = new String(“1”); 的时候已经生成“1”对象了。下边的s2声明都是直接从常量池中取地址引用的。 s 和 s2 的引用地址是不会相等的</p></li></ul><p><strong>小结</strong></p><p>从上述的例子代码可以看出 jdk7 版本对 intern 操作和常量池都做了一定的修改。主要包括2点：</p><ul><li>将String常量池从Perm区移动到了Java Heap区</li><li>String#intern 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象</li></ul><h2 id="jvm如何运行字节码"><a class="markdownIt-Anchor" href="#jvm如何运行字节码"></a> JVM如何运行字节码</h2><h2 id="jvm堆溢出分析"><a class="markdownIt-Anchor" href="#jvm堆溢出分析"></a> JVM堆溢出分析</h2><h3 id="jconsole内存监控工具"><a class="markdownIt-Anchor" href="#jconsole内存监控工具"></a> jconsole内存监控工具</h3><p>该工具可以实时监控正在运行的java程序的一些内存使用情况</p><p>工具在java home安装目录的bin目录下，直接双击运行</p><h3 id="jmap内存分析工具"><a class="markdownIt-Anchor" href="#jmap内存分析工具"></a> jmap内存分析工具</h3><p>jdk自带的jvm内存分析的工具可以查看当前堆内对象的使用情况</p><h2 id="jvm远程debug"><a class="markdownIt-Anchor" href="#jvm远程debug"></a> JVM远程debug</h2><p><strong>java启动jar包时加入参数</strong></p><ul><li>指定运行的被调试应用和调试者之间的通信协议，(ie: transport=dt_socket)</li><li>远程被调试应用开通的端口，(ie: address=1043)， 可定义其他端口，比如9999</li><li>server=y 表示这个 JVM 即将被调试</li><li>suspend=n 用来告知 JVM 立即执行，不要等待未来将要附着上/连上（attached）的调试者。如果设成 y, 则应用将暂停不运行，直到有调试者连接上</li></ul><pre><code class="highlight plaintext">-agentlib:jdwp=transport=dt_socket,address=1043,server=y,suspend=n</code></pre><p><s>或者(旧版方式)：</s></p><pre><code class="highlight plaintext">-Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=1043,suspend=n</code></pre><p><strong>Remote JVM debug</strong></p><p>idea配置remote jvm debug即可：</p><p><strong>远程JVM调试怎么工作的</strong></p><p>一切源于被称作 Agents 的东西。运行着各种编译过的 .class 文件的JVM， 有一种特性，可以允许外部的库（Java或C++写的libraries）在运行时注入到 JVM 中。这些外部的库就称作 Agents, 他们有能力修改运行中 .class 文件的内容。</p><p>这些 Agents 拥有的这些 JVM 的功能权限， 是在 JVM 内运行的 Java Code 所无法获取的， 他们能用来做一些有趣的事情，比如修改运行中的源码， 性能分析等。 像 JRebel 工具就是用了这些功能达到魔术般的效果。</p><p>传递一个 Agent Lib 给 JVM, 通过添加 agentlib:libname[=options] 格式的启动参数即可办到。像上面的远程调试我们用的就是 **-agentlib:jdwp=… **来引入 jdwp 这个 Agent 的。</p><p>jdwp 是一个 JVM 特定的 JDWP（Java Debug Wire Protocol） 可选实现，用来定义调试者与运行JVM之间的通讯，它的是通过 JVM 本地库的 <a href="http://jdwp.so">jdwp.so</a> 或者 jdwp.dll 支持实现的。</p><p><strong>它到底是怎么工作的呢？</strong></p><p>简单来说， jdwp agent 会建立运行应用的 JVM 和调试者（本地或者远程）之间的桥梁。既然他是一个Agent Library, 它就有能力拦截运行的代码。</p><p>在 JVM 架构里， debugging 功能在 JVM 本身的内部是找不到的，它是一种抽象到外部工具的方式（也称作调试者 debugger）。这些调试工具或者运行在 JVM 的本地 或者在远程。这是一种解耦，模块化的架构。</p>]]>
    </content>
    <id>http://example.com/2022/11/01/JVM/</id>
    <link href="http://example.com/2022/11/01/JVM/"/>
    <published>2022-11-01T05:00:00.000Z</published>
    <summary>本文详细介绍了Jvm的核心概念，CLASS文件，类加载子系统，运行时数据区，Java虚拟机栈，本地方法栈，Java内存模型，JVM调优，JVM堆溢出分析，JVM远程debug。</summary>
    <title>Jvm</title>
    <updated>2026-02-26T08:50:16.672Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    <category term="Mybatis" scheme="http://example.com/tags/Mybatis/"/>
    <content>
      <![CDATA[<p>[toc]</p><h1 id="mybatis源码"><a class="markdownIt-Anchor" href="#mybatis源码"></a> Mybatis源码</h1><h2 id="mybatis工作原理和工作流程"><a class="markdownIt-Anchor" href="#mybatis工作原理和工作流程"></a> MyBatis工作原理和工作流程</h2><h3 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h3><p><strong>我们使用mybatis来执行sql语句，实际mybaits底层封装的还是JDBC相关代码</strong></p><p><em>mybatis启动的时候不会创建connection连接而是在真正使用connection的时候才会创建</em></p><ol><li>将sql语句和数据库配置信息保存在配置文件，加载到流中</li></ol><ul><li>Resources.getResourceAsStream()该方法用来加载工程根目录的配置文件</li></ul><pre><code class="highlight java"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</code></pre><ol start="2"><li>然后使用<strong>SqlSessionFactoryBuilder</strong>对象使用build()方法构建<strong>SqlSessionFactory</strong>对象(实际是DefaultSqlSessionFactory对象)，build()方法会调用XMLConfigBuilder对象的parse()方法生成<strong>Configuration</strong>对象(该对象的<strong>Environment对象</strong>解析存储xml文件中的配置信息</li></ol><ul><li><strong>build()方法就会将mybatis-config.xml配置文件中的相关信息加载到Configuration对象中，然后创建sqlsessionFacotry对象</strong></li></ul><pre><code class="highlight java"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</code></pre><ol start="3"><li>SqlSessionFactory对象根据Environment对象中的datasource来创建<strong>connect连接（连接交给Excutor执行器）</strong>，生成<strong>Executor执行器</strong>和autoCommit(自动提交)用来创建<strong>SqlSession对象</strong>(实际是DefaultSqlSession对象)</li></ol><ul><li><strong>sqlSession对象本身没有什么用处，只是暴露给开发人员的接口，主要执行语句的是Executor执行器对象</strong></li></ul><pre><code class="highlight java"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> factory.openSession();</code></pre><ol start="4"><li><p>在创建SqlSession对象提供属性<br />1） Configuration对象：存储mybatis-config.xml配置信息<br />2） Executor执行器对象：<br />创建Statement对象，在创建过程中<br />依靠MapperStatement对象将赋值内容与sql占位符<br />进行绑定<br />3） AutoCommit对象：是否自动提交</p></li><li><p>SqlSession.commit(): 根据此时dirty属性决定提交和回滚</p></li><li><p>SqlSession.close();</p></li></ol><blockquote><p>SqlSessionFacoty中的Configuration对象：该对象用来从配置文件中解析加载配置信息</p></blockquote><blockquote><p>SqlSession中的Executor对象：该对象封装了JDBC中的PreparedStatement等相关执行sql语句</p></blockquote><pre><code class="highlight java"><span class="keyword">package</span> com.lee.beans;<span class="keyword">import</span> org.apache.ibatis.io.Resources;<span class="keyword">import</span> org.apache.ibatis.session.SqlSession;<span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<span class="keyword">import</span> java.io.IOException;<span class="keyword">import</span> java.io.InputStream;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMain</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;        <span class="type">Dept</span> <span class="variable">dept</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dept</span>();        dept.setDeptno(<span class="number">1</span>);        dept.setDname(<span class="string">&quot;金融事业部&quot;</span>);        dept.setLoc(<span class="string">&quot;北京&quot;</span>);        <span class="comment">//首先将mybaits-config.xml配置文件加载到数据流当中</span>        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);        <span class="comment">//使用SqlSessionFactoryBuilder对象给Configuration对象赋值，然后构建SqlSessionFactory对象</span>        <span class="comment">//</span>        <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);        <span class="comment">//SqlSessionFactory对象生成生成Executor(执行器)对象，创建sqlSession对象</span>        <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> factory.openSession();        session.insert(<span class="string">&quot;insertOne&quot;</span>,dept);        session.commit();        session.close();    &#125;&#125;</code></pre><h3 id="详解"><a class="markdownIt-Anchor" href="#详解"></a> 详解</h3><h4 id="sqlsessionfactory-与-sqlsession"><a class="markdownIt-Anchor" href="#sqlsessionfactory-与-sqlsession"></a> SqlSessionFactory 与 SqlSession</h4><p>（1）首先，SqlSessionFactoryBuilder去读取mybatis的配置文件，然后build一个DefaultSqlSessionFactory。源码如下：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">   * 一系列的构造方法最终都会调用本方法（配置文件为Reader时会调用本方法，还有一个InputStream方法与此对应）</span><span class="comment">   * <span class="doctag">@param</span> reader</span><span class="comment">   * <span class="doctag">@param</span> environment</span><span class="comment">   * <span class="doctag">@param</span> properties</span><span class="comment">   * <span class="doctag">@return</span></span><span class="comment">   */</span>  <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Reader reader, String environment, Properties properties)</span> &#123;    <span class="keyword">try</span> &#123;        <span class="comment">//该类的主要作用是对核心xml配置文件进行相关读取</span>      <span class="comment">//通过XMLConfigBuilder解析配置文件，解析的配置相关信息都会封装为一个Configuration对象</span>      <span class="type">XMLConfigBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLConfigBuilder</span>(reader, environment, properties);      <span class="comment">//这儿创建DefaultSessionFactory对象</span>      <span class="keyword">return</span> build(parser.parse());    &#125; <span class="keyword">catch</span> (Exception e) &#123;      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error building SqlSession.&quot;</span>, e);    &#125; <span class="keyword">finally</span> &#123;      ErrorContext.instance().reset();      <span class="keyword">try</span> &#123;        reader.close();      &#125; <span class="keyword">catch</span> (IOException e) &#123;        <span class="comment">// Intentionally ignore. Prefer previous error.</span>      &#125;    &#125;  &#125;  <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Configuration config)</span> &#123;    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSessionFactory</span>(config);  &#125;</code></pre><p>我们可以进入XMLConfigBuilder类去查看配置文件相关的解析过程</p><pre><code class="highlight java"><span class="keyword">public</span> Configuration <span class="title function_">parse</span><span class="params">()</span> &#123;       <span class="keyword">if</span> (<span class="built_in">this</span>.parsed) &#123;           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Each XMLConfigBuilder can only be used once.&quot;</span>);       &#125; <span class="keyword">else</span> &#123;           <span class="built_in">this</span>.parsed = <span class="literal">true</span>;           <span class="comment">//节点定位，定位配置文件根目录标签&lt;configuration&gt;</span>           <span class="comment">//然后依次读取相关标签</span>           <span class="built_in">this</span>.parseConfiguration(<span class="built_in">this</span>.parser.evalNode(<span class="string">&quot;/configuration&quot;</span>));           <span class="keyword">return</span> <span class="built_in">this</span>.configuration;       &#125;   &#125;   <span class="comment">//读取其他相关子标签，依次将下列子标签读取到管理对象中</span>   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseConfiguration</span><span class="params">(XNode root)</span> &#123;       <span class="keyword">try</span> &#123;           <span class="comment">//属性标签</span>           <span class="built_in">this</span>.propertiesElement(root.evalNode(<span class="string">&quot;properties&quot;</span>));           <span class="comment">//设置标签</span>           <span class="type">Properties</span> <span class="variable">settings</span> <span class="operator">=</span> <span class="built_in">this</span>.settingsAsProperties(root.evalNode(<span class="string">&quot;settings&quot;</span>));           <span class="built_in">this</span>.loadCustomVfs(settings);           <span class="comment">//别名标签</span>           <span class="built_in">this</span>.typeAliasesElement(root.evalNode(<span class="string">&quot;typeAliases&quot;</span>));           <span class="comment">//拦截器标签</span>           <span class="built_in">this</span>.pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));           <span class="comment">//对象工厂标签</span>           <span class="built_in">this</span>.objectFactoryElement(root.evalNode(<span class="string">&quot;objectFactory&quot;</span>));           <span class="comment">//对象封装标签</span>           <span class="built_in">this</span>.objectWrapperFactoryElement(root.evalNode(<span class="string">&quot;objectWrapperFactory&quot;</span>));           <span class="comment">//反射标签</span>           <span class="built_in">this</span>.reflectorFactoryElement(root.evalNode(<span class="string">&quot;reflectorFactory&quot;</span>));           <span class="built_in">this</span>.settingsElement(settings);           <span class="comment">//环境标签</span>           <span class="built_in">this</span>.environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>));           <span class="comment">//数据源标签</span>           <span class="built_in">this</span>.databaseIdProviderElement(root.evalNode(<span class="string">&quot;databaseIdProvider&quot;</span>));           <span class="comment">//类型转换标签</span>           <span class="built_in">this</span>.typeHandlerElement(root.evalNode(<span class="string">&quot;typeHandlers&quot;</span>));           <span class="comment">//mapper标签</span>           <span class="built_in">this</span>.mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));       &#125; <span class="keyword">catch</span> (Exception var3) &#123;           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + var3, var3);       &#125;   &#125;</code></pre><blockquote><p>mapper内部的解析过程这里不再概述，详见源代码</p></blockquote><p>（2）当我们获取到SqlSessionFactory之后，就可以通过SqlSessionFactory去获取SqlSession对象</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">   * 通常一系列openSession方法最终都会调用本方法</span><span class="comment">   * <span class="doctag">@param</span> execType </span><span class="comment">   * <span class="doctag">@param</span> level</span><span class="comment">   * <span class="doctag">@param</span> autoCommit</span><span class="comment">   * <span class="doctag">@return</span></span><span class="comment">   */</span>  <span class="keyword">private</span> SqlSession <span class="title function_">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="type">boolean</span> autoCommit)</span> &#123;    <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="keyword">try</span> &#123;      <span class="comment">//通过Confuguration对象去获取Mybatis相关配置信息, Environment对象包含了数据源和事务的配置</span>      <span class="keyword">final</span> <span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> configuration.getEnvironment();      <span class="keyword">final</span> <span class="type">TransactionFactory</span> <span class="variable">transactionFactory</span> <span class="operator">=</span> getTransactionFactoryFromEnvironment(environment);      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);      <span class="comment">//之前说了，从表面上来看，咱们是用sqlSession在执行sql语句， 实际呢，其实是通过excutor执行， excutor是对于Statement的封装</span>      <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> configuration.newExecutor(tx, execType);      <span class="comment">//关键看这儿，创建了一个DefaultSqlSession对象</span>      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSession</span>(configuration, executor, autoCommit);    &#125; <span class="keyword">catch</span> (Exception e) &#123;      closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span>      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error opening session.  Cause: &quot;</span> + e, e);    &#125; <span class="keyword">finally</span> &#123;      ErrorContext.instance().reset();    &#125;  &#125;</code></pre><p>（3）通过上述步骤，我们就可以用sqlSession进行增删该查了</p><h4 id="mapperproxy"><a class="markdownIt-Anchor" href="#mapperproxy"></a> MapperProxy</h4><p>在mybatis中，通过MapperProxy动态代理咱们的dao， 也就是说， 当咱们执行自己写的dao里面的方法的时候，其实是对应的mapperProxy在代理。那么，咱们就看看怎么获取MapperProxy对象吧：</p><p>（1）通过SqlSession从Configuration中获取。源码如下：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">   * 什么都不做，直接去configuration中找， 哥就是这么任性</span><span class="comment">   */</span>  <span class="meta">@Override</span>  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> &#123;    <span class="keyword">return</span> configuration.&lt;T&gt;getMapper(type, <span class="built_in">this</span>);  &#125;</code></pre><p>（2）SqlSession把包袱甩给了Configuration, 接下来就看看Configuration。源码如下：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">   * 烫手的山芋，俺不要，你找mapperRegistry去要</span><span class="comment">   * <span class="doctag">@param</span> type</span><span class="comment">   * <span class="doctag">@param</span> sqlSession</span><span class="comment">   * <span class="doctag">@return</span></span><span class="comment">   */</span>  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;    <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);  &#125;</code></pre><p>（3）Configuration不要这烫手的山芋，接着甩给了MapperRegistry， 那咱看看MapperRegistry。 源码如下：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">   * 烂活净让我来做了，没法了，下面没人了，我不做谁来做</span><span class="comment">   * <span class="doctag">@param</span> type</span><span class="comment">   * <span class="doctag">@param</span> sqlSession</span><span class="comment">   * <span class="doctag">@return</span></span><span class="comment">   */</span>  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;    <span class="comment">//能偷懒的就偷懒，俺把粗活交给MapperProxyFactory去做</span>    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);    <span class="keyword">if</span> (mapperProxyFactory == <span class="literal">null</span>) &#123;      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);    &#125;    <span class="keyword">try</span> &#123;      <span class="comment">//关键在这儿</span>      <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);    &#125; <span class="keyword">catch</span> (Exception e) &#123;      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);    &#125;  &#125;</code></pre><p>(4)MapperProxyFactory是个苦B的人，粗活最终交给它去做了。咱们看看源码：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">   * 别人虐我千百遍，我待别人如初恋</span><span class="comment">   * <span class="doctag">@param</span> mapperProxy</span><span class="comment">   * <span class="doctag">@return</span></span><span class="comment">   */</span>  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>  <span class="keyword">protected</span> T <span class="title function_">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> &#123;    <span class="comment">//动态代理我们写的dao接口</span>    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; mapperInterface &#125;, mapperProxy);  &#125;    <span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">(SqlSession sqlSession)</span> &#123;    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> <span class="title class_">MapperProxy</span>&lt;T&gt;(sqlSession, mapperInterface, methodCache);    <span class="keyword">return</span> newInstance(mapperProxy);  &#125;</code></pre><p>通过以上的动态代理，咱们就可以方便地使用dao接口啦， 就像之前咱们写的demo那样：</p><pre><code class="highlight java"><span class="type">UserDao</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserDao.class);  <span class="type">User</span> <span class="variable">insertUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</code></pre><h4 id="excutor"><a class="markdownIt-Anchor" href="#excutor"></a> Excutor</h4><p>接下来，咱们才要真正去看sql的执行过程了。上面，咱们拿到了MapperProxy, 每个MapperProxy对应一个dao接口， 那么咱们在使用的时候，MapperProxy是怎么做的呢？ 源码奉上：MapperProxy:</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">   * MapperProxy在执行时会触发此方法</span><span class="comment">   */</span>  <span class="meta">@Override</span>  <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;      <span class="keyword">try</span> &#123;        <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);      &#125; <span class="keyword">catch</span> (Throwable t) &#123;        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);      &#125;    &#125;    <span class="keyword">final</span> <span class="type">MapperMethod</span> <span class="variable">mapperMethod</span> <span class="operator">=</span> cachedMapperMethod(method);    <span class="comment">//二话不说，主要交给MapperMethod自己去管</span>    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);  &#125;</code></pre><p>MapperMethod:</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">   * 看着代码不少，不过其实就是先判断CRUD类型，然后根据类型去选择到底执行sqlSession中的哪个方法，绕了一圈，又转回sqlSession了</span><span class="comment">   * <span class="doctag">@param</span> sqlSession</span><span class="comment">   * <span class="doctag">@param</span> args</span><span class="comment">   * <span class="doctag">@return</span></span><span class="comment">   */</span>  <span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> &#123;    Object result;    <span class="keyword">if</span> (SqlCommandType.INSERT == command.getType()) &#123;      <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);      result = rowCountResult(sqlSession.insert(command.getName(), param));    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SqlCommandType.UPDATE == command.getType()) &#123;      <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);      result = rowCountResult(sqlSession.update(command.getName(), param));    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SqlCommandType.DELETE == command.getType()) &#123;      <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);      result = rowCountResult(sqlSession.delete(command.getName(), param));    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SqlCommandType.SELECT == command.getType()) &#123;      <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;        executeWithResultHandler(sqlSession, args);        result = <span class="literal">null</span>;      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;        result = executeForMany(sqlSession, args);      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;        result = executeForMap(sqlSession, args);      &#125; <span class="keyword">else</span> &#123;        <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);        result = sqlSession.selectOne(command.getName(), param);      &#125;    &#125; <span class="keyword">else</span> &#123;      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Unknown execution method for: &quot;</span> + command.getName());    &#125;    <span class="keyword">if</span> (result == <span class="literal">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Mapper method &#x27;&quot;</span> + command.getName()           + <span class="string">&quot; attempted to return null from a method with a primitive return type (&quot;</span> + method.getReturnType() + <span class="string">&quot;).&quot;</span>);    &#125;    <span class="keyword">return</span> result;  &#125;</code></pre><p>既然又回到SqlSession了， 那么咱们就看看SqlSession的CRUD方法了，为了省事，还是就选择其中的一个方法来做分析吧。这儿，咱们选择了selectList方法：</p><pre><code class="highlight java"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> &#123;    <span class="keyword">try</span> &#123;      <span class="type">MappedStatement</span> <span class="variable">ms</span> <span class="operator">=</span> configuration.getMappedStatement(statement);      <span class="comment">//CRUD实际上是交给Excetor去处理， excutor其实也只是穿了个马甲而已，小样，别以为穿个马甲我就不认识你嘞！</span>      <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);    &#125; <span class="keyword">catch</span> (Exception e) &#123;      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + e, e);    &#125; <span class="keyword">finally</span> &#123;      ErrorContext.instance().reset();    &#125;  &#125;</code></pre><p>然后，通过一层一层的调用，最终会来到doQuery方法， 这儿咱们就随便找个Excutor看看doQuery方法的实现吧，我这儿选择了SimpleExecutor:</p><pre><code class="highlight java"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="keyword">try</span> &#123;      <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> ms.getConfiguration();      <span class="type">StatementHandler</span> <span class="variable">handler</span> <span class="operator">=</span> configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);      stmt = prepareStatement(handler, ms.getStatementLog());      <span class="comment">//StatementHandler封装了Statement, 让 StatementHandler 去处理</span>      <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);    &#125; <span class="keyword">finally</span> &#123;      closeStatement(stmt);    &#125;  &#125;</code></pre><p>接下来，咱们看看StatementHandler 的一个实现类 PreparedStatementHandler（这也是我们最常用的，封装的是PreparedStatement）, 看看它使怎么去处理的：</p><pre><code class="highlight java"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;     <span class="comment">//到此，原形毕露， PreparedStatement, 这个大家都已经滚瓜烂熟了吧</span>    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> (PreparedStatement) statement;    ps.execute();    <span class="comment">//结果交给了ResultSetHandler 去处理</span>    <span class="keyword">return</span> resultSetHandler.&lt;E&gt; handleResultSets(ps);  &#125;</code></pre><h2 id="result自动赋值实体类原理"><a class="markdownIt-Anchor" href="#result自动赋值实体类原理"></a> result自动赋值实体类原理</h2><pre><code class="highlight java">ResultSet =query();         <span class="keyword">while</span>(ResultSet.next)&#123;            Employee emp=  employee.class.newInstance();            Field fieldArray[]=employee.class.getDeclaredFields();            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;fieldArray.length;i++)&#123;                  <span class="type">Field</span> <span class="variable">fieldObj</span> <span class="operator">=</span> fieldArray[i];                  String fieldName= fieldObj.getName();                  String value=ResultSet.getString(fieldName);                  Class fieldType= fieldObj.getType();                  <span class="keyword">if</span>(Integer.class == fieldType)&#123;                   fieldObj.set(emp,Integer.valueOf(value));<span class="comment">//之前类型转换</span>                  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Boolean.class == fieldType)&#123;                                       fieldObj.set(emp,Boolean.valueOf(value));                  &#125;                                   column :d_name = dName                                  Dept类： dName            &#125;         &#125;</code></pre><h1 id="mybatis配置文件核心标签"><a class="markdownIt-Anchor" href="#mybatis配置文件核心标签"></a> MyBatis配置文件核心标签</h1><h2 id="typehandlers自定义类型转换器"><a class="markdownIt-Anchor" href="#typehandlers自定义类型转换器"></a> typeHandlers（自定义类型转换器）</h2><p>每当MyBatis 设置参数到PreparedStatement 或者从ResultSet 结果集中取得值时，就会使用TypeHandler 来处理数据库类型与java 类型之间转换。下表描述了默认TypeHandlers</p><p>假设表中字段是int类型,而实体类与之对应的属性是boolean类型,此时可以采用自定义类型转换器进行对应</p><p><strong>实体类</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dept</span> &#123;    <span class="keyword">private</span>  <span class="type">int</span> deptno;    <span class="keyword">private</span> String dname;    <span class="keyword">private</span> String loc;    <span class="keyword">private</span> Boolean flag;        ... ...    &#125;</code></pre><p><strong>数据库表</strong></p><h3 id="开发自定义类型转换器"><a class="markdownIt-Anchor" href="#开发自定义类型转换器"></a> 开发自定义类型转换器</h3><pre><code class="highlight java"><span class="keyword">package</span> com.lee.util;<span class="keyword">import</span> org.apache.ibatis.type.JdbcType;<span class="keyword">import</span> org.apache.ibatis.type.TypeHandler;<span class="keyword">import</span> java.sql.CallableStatement;<span class="keyword">import</span> java.sql.PreparedStatement;<span class="keyword">import</span> java.sql.ResultSet;<span class="keyword">import</span> java.sql.SQLException;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTypeHandler</span> <span class="keyword">implements</span> <span class="title class_">TypeHandler</span> &#123;    <span class="comment">//在生成sql语句时被调用</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParameter</span><span class="params">(PreparedStatement preparedStatement, <span class="type">int</span> i, Object o, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException &#123;        <span class="keyword">if</span> (o==<span class="literal">null</span>)&#123;            preparedStatement.setInt(i,<span class="number">0</span>);            <span class="keyword">return</span>;        &#125;        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> (Boolean) o;        <span class="keyword">if</span> (flag == <span class="literal">true</span>)&#123;            preparedStatement.setInt(i,<span class="number">1</span>);        &#125;<span class="keyword">else</span> &#123;            preparedStatement.setInt(i,<span class="number">0</span>);        &#125;    &#125;    <span class="comment">//查询结束后，在将ResultSet数据行转换为实体类对象时，通知TypeHandler将当前数据行某个字段转换为何种类型</span>    <span class="keyword">public</span> Object <span class="title function_">getResult</span><span class="params">(ResultSet resultSet, String s)</span> <span class="keyword">throws</span> SQLException &#123;        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> resultSet.getInt(s);        <span class="type">Boolean</span> <span class="variable">myFlag</span> <span class="operator">=</span> Boolean.FALSE;        <span class="keyword">if</span> (flag == <span class="number">1</span>)&#123;            myFlag=Boolean.TRUE;        &#125;        <span class="keyword">return</span> myFlag;    &#125;    <span class="keyword">public</span> Object <span class="title function_">getResult</span><span class="params">(ResultSet resultSet, <span class="type">int</span> i)</span> <span class="keyword">throws</span> SQLException &#123;        <span class="keyword">return</span> <span class="literal">null</span>;    &#125;    <span class="keyword">public</span> Object <span class="title function_">getResult</span><span class="params">(CallableStatement callableStatement, <span class="type">int</span> i)</span> <span class="keyword">throws</span> SQLException &#123;        <span class="keyword">return</span> <span class="literal">null</span>;    &#125;&#125;</code></pre><h3 id="在mybatis配置文件中配置"><a class="markdownIt-Anchor" href="#在mybatis配置文件中配置"></a> 在mybatis配置文件中配置</h3><p>mybatis配置文件</p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><span class="comment">&lt;!--mybatis配置文件核心根标签--&gt;</span><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>    <span class="comment">&lt;!--属性--&gt;</span>    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;config.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="comment">&lt;!--配置实体类的别名，配置这个后，在mapper.xml中的result中就不用写全名了--&gt;</span>    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span>        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.lee.entity&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span>    <span class="comment">&lt;!--配置自定义Java实体类类型与数据库类型转换--&gt;</span>    <span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span>        <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;com.lee.util.MyTypeHandler&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Boolean&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;NUMERIC&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span>    <span class="comment">&lt;!--环境--&gt;</span>    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span>            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span>            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span>    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span>    <span class="comment">&lt;!--映射,定位当前项目中所有映射文件的位置--&gt;</span>    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span>        <span class="comment">&lt;!--两种方法二选一--&gt;</span>        <span class="comment">&lt;!--mapper中可以通过class,resource,url来定义一个具体的映射文件--&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/DeptMapper.xml&quot;</span>/&gt;</span>        <span class="comment">&lt;!--可以指向具体的包路径,该路径的所有映射文件和接口将产生对应的连接关系--&gt;</span><span class="comment">&lt;!--        &lt;package name=&quot;mapper&quot;/&gt;--&gt;</span>    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></code></pre><p>datasource相关配置值</p><pre><code class="highlight properties"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/leetest?characterEncoding=UTF-8</span><span class="attr">jdbc.username</span>=<span class="string">root</span><span class="attr">jdbc.password</span>=<span class="string">123456</span></code></pre><h3 id="mapperxml"><a class="markdownIt-Anchor" href="#mapperxml"></a> mapper.xml</h3><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;DeptMapper&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertOne&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span>    insert into dept values (#&#123;deptno&#125;,#&#123;dname&#125;,#&#123;loc&#125;,#&#123;flag&#125;)    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span>    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span>        select * from dept    <span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></code></pre><h3 id="测试使用"><a class="markdownIt-Anchor" href="#测试使用"></a> 测试使用</h3><pre><code class="highlight java"><span class="keyword">package</span> com.lee.beans;<span class="keyword">import</span> com.lee.entity.Dept;<span class="keyword">import</span> org.apache.ibatis.io.Resources;<span class="keyword">import</span> org.apache.ibatis.session.SqlSession;<span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<span class="keyword">import</span> java.io.IOException;<span class="keyword">import</span> java.io.InputStream;<span class="keyword">import</span> java.util.List;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMain</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;        <span class="type">Dept</span> <span class="variable">dept</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dept</span>();        dept.setDeptno(<span class="number">1</span>);        dept.setDname(<span class="string">&quot;金融事业部&quot;</span>);        dept.setLoc(<span class="string">&quot;北京222&quot;</span>);        dept.setFlag(<span class="literal">true</span>);        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);        <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);        <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> factory.openSession();        session.insert(<span class="string">&quot;DeptMapper.insertOne&quot;</span>,dept);        List&lt;Dept&gt; list = session.selectList(<span class="string">&quot;selectAll&quot;</span>);        <span class="keyword">for</span> (Dept d : list)&#123;            System.out.println(d.getDeptno()+<span class="string">&quot;##&quot;</span>+d.getFlag()+<span class="string">&quot;##&quot;</span>+d.getDname());        &#125;        session.commit();        session.close();    &#125;&#125;</code></pre><blockquote><p><strong>经过上述转换，即可将数据库中的int类型和Java中的Boolean类型进行关联，实现自定义转换</strong></p></blockquote><h3 id="非全局配置"><a class="markdownIt-Anchor" href="#非全局配置"></a> 非全局配置</h3><p>上述的自定义类型转换时全局的，如果不想全局使用，只想使某一个查询结果或者更新语句使用自定义类型转换，可以使用下述方法</p><h4 id="在mapperxml文件中指定使用自定义类型转换器场合"><a class="markdownIt-Anchor" href="#在mapperxml文件中指定使用自定义类型转换器场合"></a> 在Mapper.xml文件中指定使用自定义类型转换器场合</h4><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">id</span>=<span class="string">&quot;DeptResultMap&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;flag&quot;</span> <span class="attr">property</span>=<span class="string">&quot;flag&quot;</span> <span class="attr">typeHandler</span>=<span class="string">&quot;com.lee.util.MyTypeHandler&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;DeptResultMap&quot;</span>&gt;</span>    select * from dept<span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><h2 id="objectfactory创建对象工厂"><a class="markdownIt-Anchor" href="#objectfactory创建对象工厂"></a> objectFactory（创建对象工厂）</h2><p>MyBatis每次创建结果对象的新实例时，他都会使用一个对象工厂（ObjectFactory）实例完成，默认的对象工厂需要做的是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化</p><p><strong>如果我们想覆盖对象工厂的默认行为，则可以创建自己的对象工厂来实现</strong></p><h3 id="自定义对象工厂"><a class="markdownIt-Anchor" href="#自定义对象工厂"></a> 自定义对象工厂</h3><h4 id="继承defaultobjectfactory"><a class="markdownIt-Anchor" href="#继承defaultobjectfactory"></a> 继承DefaultObjectFactory</h4><p><strong>注意</strong>：使用过程中要注意两点</p><ol><li>必须要判断我们要改变创建规则的类</li><li>这里赋值后如果数据库查询到值会覆盖</li></ol><pre><code class="highlight java"><span class="keyword">package</span> com.lee.util;<span class="keyword">import</span> com.lee.entity.Dept;<span class="keyword">import</span> org.apache.ibatis.reflection.factory.DefaultObjectFactory;<span class="comment">/**</span><span class="comment"> * 自定义工厂对象</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObjectFactory</span> <span class="keyword">extends</span> <span class="title class_">DefaultObjectFactory</span> &#123;    <span class="comment">//重新定义Dept实例对象创建规则，其他类实例对象创建规则不改变</span>    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">create</span><span class="params">(Class&lt;T&gt; type)</span> &#123;        <span class="comment">//判断是否是我们要自己创建的dept类</span>        <span class="keyword">if</span> (type == Dept.class)&#123;            <span class="comment">//用父类提供的方法创建该类，实际就是用反射调用改类默认的构造器创建该方法</span>            <span class="type">Dept</span> <span class="variable">dept</span> <span class="operator">=</span> (Dept) <span class="built_in">super</span>.create(type);            <span class="comment">//设置自定义的规矩，让每一个部门的国家变为china</span>            dept.setCountry(<span class="string">&quot;China&quot;</span>);            <span class="comment">//注意，这里创建的dept是一个空对象，在这进行赋值后，如果后续在数据库中查到字段相关数据，则会覆盖这里的赋值</span>            <span class="comment">//否则则沿用这里的赋值</span>            <span class="keyword">return</span> (T) dept;        &#125;<span class="keyword">else</span>&#123;            <span class="keyword">return</span> <span class="built_in">super</span>.create(type);        &#125;    &#125;&#125;</code></pre><h4 id="配置文件"><a class="markdownIt-Anchor" href="#配置文件"></a> 配置文件</h4><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><span class="comment">&lt;!--mybatis配置文件核心根标签--&gt;</span><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>    <span class="comment">&lt;!--属性--&gt;</span>    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;config.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="comment">&lt;!--配置实体类的别名，配置这个后，在mapper.xml中的result中就不用写全名了--&gt;</span>    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span>        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.lee.entity&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span>    <span class="comment">&lt;!--配置自定义Java实体类类型与数据库类型转换--&gt;</span>    <span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span>        <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;com.lee.util.MyTypeHandler&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Boolean&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;NUMERIC&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span>    <span class="comment">&lt;!--配置自定义对象工厂--&gt;</span>    <span class="tag">&lt;<span class="name">objectFactory</span> <span class="attr">type</span>=<span class="string">&quot;com.lee.util.MyObjectFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">objectFactory</span>&gt;</span>    <span class="comment">&lt;!--环境--&gt;</span>    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span>            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span>            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span>    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span>    <span class="comment">&lt;!--映射,定位当前项目中所有映射文件的位置--&gt;</span>    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span>        <span class="comment">&lt;!--两种方法二选一--&gt;</span>        <span class="comment">&lt;!--mapper中可以通过class,resource,url来定义一个具体的映射文件--&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/DeptMapper.xml&quot;</span>/&gt;</span>        <span class="comment">&lt;!--可以指向具体的包路径,该路径的所有映射文件和接口将产生对应的连接关系--&gt;</span><span class="comment">&lt;!--        &lt;package name=&quot;mapper&quot;/&gt;--&gt;</span>    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></code></pre><h4 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h4><ul><li>数据库中没有country相关字段</li></ul><p>运行结果：</p><ul><li>所有的country都已经赋值成功</li></ul><h2 id="plugins拦截器"><a class="markdownIt-Anchor" href="#plugins拦截器"></a> Plugins（拦截器）</h2><p><strong>拦截器/插件</strong> 实际就是 <strong>代理模式</strong></p><p>拦截器的一个作用就是我们可以拦截某些方法的调用，我们可以选择在这些被拦截的方法<strong>执行前后加上某些逻辑</strong>，也可以在执行这些拦截的方法时<strong>执行自己的方法</strong>而不使用mybatis定义的方法</p><p>Mybatis拦截器的设计的一个初衷就是为了提供用户在某些时候可以实现自己的逻辑而不必去改变mybatis固有的逻辑</p><ul><li>比如：对于Executor（执行器），mybatis中有几个实现：BatchExecutor，ReuseExecutor，SimpleExecutor和CachingExecutor。</li><li>这个时候如果你觉得这几种实现对于Executor接口的query方法都不能满足你的要求，我们也不用改变源码，我们可以建立一个mybatis拦截器用于拦截Executor接口的query方法，在拦截之后实现自己的query方法逻辑，之后可以选择是否继续执行原来的query方法</li></ul><p>对于拦截器mybatis为我们提供了一个interceptor接口，通过实现该接口就可以定义我们自己的拦截器</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interceptor</span> &#123;    Object <span class="title function_">intercept</span><span class="params">(Invocation var1)</span> <span class="keyword">throws</span> Throwable;    Object <span class="title function_">plugin</span><span class="params">(Object var1)</span>;    <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties var1)</span>;&#125;</code></pre><p>我们可以看到该接口中一共定义了三个方法，intercept，plugin和setProperties。</p><p><strong>plugin方法</strong>是拦截器用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理。当返回的是代理的时候我们可以对其中的方法进行<strong>拦截调用intercept方法</strong>，当然也可以调用其他方法</p><p><strong>setProperties方法</strong>用于在mybatis配置文件中制定一些属性</p><p>定义自己的interceptor最重要的实现plugin方法和intercept方法，在plugin方法中我们可以决定是否要进行拦截而决定要返回一个什么样的目标对象，而intercept方法就是要进行拦截的时候要执行的方法。</p><p>对于plugin方法而言，其他mybatis已经为我们提供了一个实现，mybatis中有一个叫做<strong>plugin的类</strong>，里面有一个静态方法<code>wrap(Object target,Interceptor interceptor)</code>，<strong>通过该方法</strong>可以<strong>决定要返回的对象是目标对象还是对应的代理</strong></p><hr /><h3 id="实现自己的拦截器"><a class="markdownIt-Anchor" href="#实现自己的拦截器"></a> 实现自己的拦截器</h3><h4 id="定义拦截器"><a class="markdownIt-Anchor" href="#定义拦截器"></a> 定义拦截器</h4><p>对于实现自己的Interceptor而言有两个很重要的注解，一个是@<strong>Intercepts</strong>，其值是一个@Signature数据。@Intercepts用于表明当前的对象是一个Interceptor，而@<strong>Signature</strong>则表明要拦截的接口，方法以及对应的参数类型，来看一个自定义的简单的Interceptor</p><pre><code class="highlight java"><span class="keyword">import</span> org.apache.ibatis.executor.Executor;<span class="keyword">import</span> org.apache.ibatis.mapping.MappedStatement;<span class="keyword">import</span> org.apache.ibatis.plugin.*;<span class="keyword">import</span> org.apache.ibatis.session.ResultHandler;<span class="keyword">import</span> org.apache.ibatis.session.RowBounds;<span class="keyword">import</span> java.util.Properties;<span class="comment">/**</span><span class="comment"> * 实现拦截器</span><span class="comment"> */</span><span class="meta">@Intercepts(&#123;</span><span class="meta">        @Signature(</span><span class="meta">                type=Executor.class,    //要拦截的接口</span><span class="meta">                method=&quot;query&quot;,   //要拦截接口的哪个方法</span><span class="meta">                args=&#123;MappedStatement.class,Object.class, RowBounds.class, ResultHandler.class&#125;)    //哪个重载方法（参数类型）</span><span class="meta">&#125;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;    <span class="comment">//拦截方法</span>    <span class="comment">//invocation表示被拦截的对象及方法  ，参数：Invocation&#123;代理对象，被监控的方法，当前被监控的实参运行时需要的实参&#125;</span>    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;        System.out.println(<span class="string">&quot;方法拦截之前...............&quot;</span>);        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> invocation.proceed();<span class="comment">//执行拦截方法</span>        System.out.println(<span class="string">&quot;方法拦截之后...............&quot;</span>);        <span class="keyword">return</span> obj;    &#125;    <span class="comment">/*</span><span class="comment">        参数：o 表示被拦截的对象，本案例是Executor接口的实例对象</span><span class="comment">        作用：如果被拦截的对象所在的类有实现接口，就为当前拦截对象生成一个代理对象【$Proxy】</span><span class="comment">              如果被拦截的对象所在的类没有指定的接口，这个对象之后行为就不会被代理操作</span><span class="comment">     */</span>    <span class="keyword">public</span> Object <span class="title function_">plugin</span><span class="params">(Object o)</span> &#123;        <span class="comment">//该方法用来判断被代理对象是否有接口，如果没有接口则原样返回，有接口则返回代理对象（该代理对象的InvocationHandler实现就是Plugin）</span>        <span class="keyword">return</span> Plugin.wrap(o, <span class="built_in">this</span>);    &#125;    <span class="comment">//读取配置文件的属性信息</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;    &#125;&#125;</code></pre><h4 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h4><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><span class="comment">&lt;!--mybatis配置文件核心根标签--&gt;</span><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>    <span class="comment">&lt;!--属性--&gt;</span>    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;config.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="comment">&lt;!--配置实体类的别名，配置这个后，在mapper.xml中的result中就不用写全名了--&gt;</span>    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span>        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.lee.entity&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span>    <span class="comment">&lt;!--配置自定义Java实体类类型与数据库类型转换--&gt;</span>    <span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span>        <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;com.lee.util.MyTypeHandler&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Boolean&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;NUMERIC&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span>    <span class="comment">&lt;!--配置自定义对象工厂--&gt;</span>    <span class="tag">&lt;<span class="name">objectFactory</span> <span class="attr">type</span>=<span class="string">&quot;com.lee.util.MyObjectFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">objectFactory</span>&gt;</span>    <span class="comment">&lt;!--拦截器--&gt;</span>    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.lee.util.SimpleInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="comment">&lt;!--环境--&gt;</span>    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span>            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span>            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span>    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span>    <span class="comment">&lt;!--映射,定位当前项目中所有映射文件的位置--&gt;</span>    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span>        <span class="comment">&lt;!--两种方法二选一--&gt;</span>        <span class="comment">&lt;!--mapper中可以通过class,resource,url来定义一个具体的映射文件--&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/DeptMapper.xml&quot;</span>/&gt;</span>        <span class="comment">&lt;!--可以指向具体的包路径,该路径的所有映射文件和接口将产生对应的连接关系--&gt;</span><span class="comment">&lt;!--        &lt;package name=&quot;mapper&quot;/&gt;--&gt;</span>    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></code></pre><h4 id="运行结果"><a class="markdownIt-Anchor" href="#运行结果"></a> 运行结果</h4><p>测试代码</p><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;    <span class="type">Dept</span> <span class="variable">dept</span> <span class="operator">=</span> session.selectOne(<span class="string">&quot;selectOne&quot;</span>);    System.out.println(dept.toString());&#125;</code></pre><blockquote><p><strong>注意</strong>：mybaits中自定义的拦截器，可以拦截的接口只有四种：<br /><code>Executor</code> 执行器<br /><code>StatementHandler</code> 语句处理器<br /><code>ParameterHandler</code> 参数处理器<br /><code>ResultSetHandler</code> 结果集处理器</p></blockquote><h2 id="和的区别"><a class="markdownIt-Anchor" href="#和的区别"></a> #{}和${}的区别</h2><h3 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> #{}案例</h3><h4 id="实体类"><a class="markdownIt-Anchor" href="#实体类"></a> 实体类</h4><pre><code class="highlight java"><span class="keyword">package</span> com.lee.entity;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dept</span> &#123;    <span class="keyword">private</span>  <span class="type">int</span> deptno;    <span class="keyword">private</span> String dname;    <span class="keyword">private</span> String loc;    <span class="keyword">private</span> Boolean flag;    <span class="keyword">private</span> String country;    <span class="keyword">public</span> Boolean <span class="title function_">getFlag</span><span class="params">()</span> &#123;        <span class="keyword">return</span> flag;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlag</span><span class="params">(Boolean flag)</span> &#123;        <span class="built_in">this</span>.flag = flag;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDeptno</span><span class="params">()</span> &#123;        <span class="keyword">return</span> deptno;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDeptno</span><span class="params">(<span class="type">int</span> deptno)</span> &#123;        <span class="built_in">this</span>.deptno = deptno;    &#125;    <span class="keyword">public</span> String <span class="title function_">getDname</span><span class="params">()</span> &#123;        <span class="keyword">return</span> dname;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDname</span><span class="params">(String dname)</span> &#123;        <span class="built_in">this</span>.dname = dname;    &#125;    <span class="keyword">public</span> String <span class="title function_">getLoc</span><span class="params">()</span> &#123;        <span class="keyword">return</span> loc;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoc</span><span class="params">(String loc)</span> &#123;        <span class="built_in">this</span>.loc = loc;    &#125;    <span class="keyword">public</span> String <span class="title function_">getCountry</span><span class="params">()</span> &#123;        <span class="keyword">return</span> country;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCountry</span><span class="params">(String country)</span> &#123;        <span class="built_in">this</span>.country = country;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Dept&#123;&quot;</span> +                <span class="string">&quot;deptno=&quot;</span> + deptno +                <span class="string">&quot;, dname=&#x27;&quot;</span> + dname + <span class="string">&#x27;\&#x27;&#x27;</span> +                <span class="string">&quot;, loc=&#x27;&quot;</span> + loc + <span class="string">&#x27;\&#x27;&#x27;</span> +                <span class="string">&quot;, flag=&quot;</span> + flag +                <span class="string">&quot;, country=&#x27;&quot;</span> + country + <span class="string">&#x27;\&#x27;&#x27;</span> +                <span class="string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre><h4 id="mapper接口和xml文件"><a class="markdownIt-Anchor" href="#mapper接口和xml文件"></a> Mapper接口和xml文件</h4><pre><code class="highlight java"><span class="keyword">package</span> com.lee.Mapper;<span class="keyword">import</span> com.lee.entity.Dept;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptMapper</span> &#123;    <span class="keyword">public</span> Dept <span class="title function_">selectOne</span><span class="params">(String param)</span>;&#125;</code></pre><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.lee.Mapper.DeptMapper&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOne&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span>        select * from dept where dname=#&#123;dname&#125;    <span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></code></pre><h4 id="测试运行"><a class="markdownIt-Anchor" href="#测试运行"></a> 测试运行</h4><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;    <span class="type">DeptMapper</span> <span class="variable">deptMapper</span> <span class="operator">=</span> session.getMapper(DeptMapper.class);    <span class="type">Dept</span> <span class="variable">dept</span> <span class="operator">=</span> deptMapper.selectOne(<span class="string">&quot;金融事业部&quot;</span>);    System.out.println(dept.toString());&#125;</code></pre><h3 id="案例-2"><a class="markdownIt-Anchor" href="#案例-2"></a> ${}案例</h3><p><strong>默认使用方式为：${value}</strong></p><p>现在把xml文件中的#{}改为${}符号</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOne&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span>    select * from dept where dname=&#x27;$&#123;value&#125;&#x27;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><p><strong>这里有个细节，用$符号需要单引号，而#不需要</strong></p><p>运行结果</p><p><strong>${}会有特殊的用法</strong></p><pre><code class="highlight java"><span class="meta">@Select(&quot;select * from user where $&#123;column&#125; = #&#123;value&#125;&quot;)</span>User <span class="title function_">findByColumn</span><span class="params">(<span class="meta">@Param(&quot;column&quot;)</span> String column, <span class="meta">@Param(&quot;value&quot;)</span> String value)</span>;</code></pre><p>其中 ${column} 会被直接替换，而 #{value} 会被使用 ? 预处理</p><p>这个想法也同样适用于<strong>用来替换表名的情况</strong></p><p>比如：<br />有两张表，分别为emp_2017和emp_2018，如果想在查询语句中动态指定表明，就只能使用${}</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span>&gt;</span>    select * from emp_$&#123;year&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><p>或者动态指定排序字段：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span>&gt;</span>    select * from emp order by $&#123;name&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><blockquote><p>用这种方式接受用户的输入，并将其用于语句中的参数是不安全的，会导致潜在的 SQL 注入攻击，因此要么不允许用户输入这些字段，要么自行转义并检验</p></blockquote><h3 id="区别"><a class="markdownIt-Anchor" href="#区别"></a> 区别</h3><p><strong>#{}</strong> ：会被当做占位符来处理，安全</p><p>默认情况下,使用 #{} 格式的语法会导致 MyBatis 创建 PreparedStatement 参数占位符并安全地设置参数（就像使用 ? 一样）。 这样做更安全，更迅速，通常也是首选做法</p><p><strong>${}</strong> ：会直接替换，有SQL注入的风险</p><p>不过有时你就是想直接在 SQL 语句中插入一个不转义的字符串</p><p><strong>简单来说不支持使用#的地方都可以使用$符号，但是要防止sql注入的风险</strong></p><h1 id="mybatis-xml映射文件补充"><a class="markdownIt-Anchor" href="#mybatis-xml映射文件补充"></a> mybatis xml映射文件补充</h1><h2 id="resultmap"><a class="markdownIt-Anchor" href="#resultmap"></a> resultMap</h2><p>当实体类中部分字段在数据库中没有，而是需要构造函数赋值<strong>或</strong>者需要数据库查询出的字段通过构造函数计算得出，则需要resultMap的相关功能</p><h3 id="实体类-2"><a class="markdownIt-Anchor" href="#实体类-2"></a> 实体类</h3><pre><code class="highlight java"><span class="keyword">import</span> java.text.SimpleDateFormat;<span class="keyword">import</span> java.util.Date;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;       <span class="keyword">private</span> Integer empNo;       <span class="keyword">private</span> String  ename;       <span class="keyword">private</span> String  job;       <span class="keyword">private</span> Double  sal;       <span class="keyword">private</span> Date    hireDate;       <span class="comment">//职员工作年限</span>       <span class="keyword">private</span> <span class="type">int</span> workAge;              <span class="comment">//构造函数</span>       <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(Date tempDate)</span>&#123;        <span class="built_in">this</span>.hireDate = tempDate;        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy&quot;</span>);        <span class="built_in">this</span>.workAge = Integer.valueOf(sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>())) -  Integer.valueOf(sdf.format(tempDate));               &#125;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWorkAge</span><span class="params">()</span> &#123;<span class="keyword">return</span> workAge;&#125;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWorkAge</span><span class="params">(<span class="type">int</span> workAge)</span> &#123;<span class="built_in">this</span>.workAge = workAge;&#125;<span class="keyword">public</span> Integer <span class="title function_">getEmpNo</span><span class="params">()</span> &#123;<span class="keyword">return</span> empNo;&#125;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmpNo</span><span class="params">(Integer empNo)</span> &#123;<span class="built_in">this</span>.empNo = empNo;&#125;<span class="keyword">public</span> String <span class="title function_">getEname</span><span class="params">()</span> &#123;<span class="keyword">return</span> ename;&#125;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEname</span><span class="params">(String ename)</span> &#123;<span class="built_in">this</span>.ename = ename;&#125;<span class="keyword">public</span> String <span class="title function_">getJob</span><span class="params">()</span> &#123;<span class="keyword">return</span> job;&#125;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setJob</span><span class="params">(String job)</span> &#123;<span class="built_in">this</span>.job = job;&#125;<span class="keyword">public</span> Double <span class="title function_">getSal</span><span class="params">()</span> &#123;<span class="keyword">return</span> sal;&#125;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSal</span><span class="params">(Double sal)</span> &#123;<span class="built_in">this</span>.sal = sal;&#125;<span class="keyword">public</span> Date <span class="title function_">getHireDate</span><span class="params">()</span> &#123;<span class="keyword">return</span> hireDate;&#125;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHireDate</span><span class="params">(Date hireDate)</span> &#123;<span class="built_in">this</span>.hireDate = hireDate;&#125;&#125;</code></pre><h3 id="xml映射文件"><a class="markdownIt-Anchor" href="#xml映射文件"></a> xml映射文件</h3><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.kaikeba.dao.EmpMapper&quot;</span>&gt;</span>   <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;employee&quot;</span> <span class="attr">id</span>=<span class="string">&quot;empMap&quot;</span>&gt;</span>  <span class="comment">&lt;!--在查询结果返回的时候，会自动调用emp对象的带参构造函数，并把hireDate查询出来传递给构造函数--&gt;</span>    <span class="tag">&lt;<span class="name">constructor</span>&gt;</span>     <span class="tag">&lt;<span class="name">arg</span> <span class="attr">column</span>=<span class="string">&quot;hireDate&quot;</span>  <span class="attr">javaType</span>=<span class="string">&quot;java.util.Date&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span>  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span>   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;empFind&quot;</span>  <span class="attr">resultType</span>=<span class="string">&quot;emploee&quot;</span>&gt;</span>      select * from emp2   <span class="tag">&lt;/<span class="name">select</span>&gt;</span> <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></code></pre><h3 id="数据库表"><a class="markdownIt-Anchor" href="#数据库表"></a> 数据库表</h3><h4 id="mapper接口"><a class="markdownIt-Anchor" href="#mapper接口"></a> mapper接口</h4><pre><code class="highlight java"><span class="keyword">import</span> java.util.List;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123; <span class="keyword">public</span>  List <span class="title function_">empFind</span><span class="params">()</span>;&#125;</code></pre><h3 id="测试运行-2"><a class="markdownIt-Anchor" href="#测试运行-2"></a> 测试运行</h3><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;EmpMapper dao=session.getMapper(EmpMapper.class);List&lt;Employee&gt; list = dao.empFind();System.out.println();&#125;</code></pre><h1 id="mybatis原理-代理模式"><a class="markdownIt-Anchor" href="#mybatis原理-代理模式"></a> mybatis原理-代理模式</h1><h2 id="业务分析"><a class="markdownIt-Anchor" href="#业务分析"></a> 业务分析</h2><p>JDBC开发步骤</p><ol><li>加载驱动</li><li>建立连接通道</li><li>建立PreparedStament</li><li>输送sql命令到数据库中执行，并带回运行结果</li><li>销毁链接通道，PreparedStament</li></ol><p>JDBC主要业务与次要业务分析</p><ol><li>加载驱动【次要业务】</li><li>建立连接通道【次要业务】</li><li>建立PreparedStament【次要业务】</li><li>输送sql命令到数据库中执行，并带回运行结果【主要业务】</li><li>销毁链接通道， PreparedStament【次要业务】</li></ol><h2 id="自写一个简单的mybaits"><a class="markdownIt-Anchor" href="#自写一个简单的mybaits"></a> 自写一个简单的mybaits</h2><h4 id="行为接口"><a class="markdownIt-Anchor" href="#行为接口"></a> 行为/接口</h4><pre><code class="highlight java"><span class="keyword">package</span> com.proxymodel.service;<span class="keyword">import</span> java.sql.SQLException;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SqlSession</span> &#123;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">save</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException;&#125;</code></pre><h4 id="真实实例对象"><a class="markdownIt-Anchor" href="#真实实例对象"></a> 真实实例对象</h4><pre><code class="highlight java"><span class="keyword">package</span> com.proxymodel.serviceImpl;<span class="keyword">import</span> com.proxymodel.service.SqlSession;<span class="keyword">import</span> java.sql.PreparedStatement;<span class="keyword">import</span> java.sql.SQLException;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptMapper</span> <span class="keyword">implements</span> <span class="title class_">SqlSession</span> &#123;    PreparedStatement ps;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">save</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException &#123;        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> ps.executeUpdate(sql);        <span class="keyword">return</span> num;    &#125;&#125;</code></pre><h4 id="通知类"><a class="markdownIt-Anchor" href="#通知类"></a> 通知类</h4><p>这里绑定要执行的其他次要方法</p><pre><code class="highlight java"><span class="keyword">package</span> com.proxymodel.util;<span class="keyword">import</span> com.proxymodel.service.SqlSession;<span class="keyword">import</span> com.proxymodel.serviceImpl.DeptMapper;<span class="keyword">import</span> java.lang.reflect.Field;<span class="keyword">import</span> java.lang.reflect.InvocationHandler;<span class="keyword">import</span> java.lang.reflect.Method;<span class="keyword">import</span> java.sql.Connection;<span class="keyword">import</span> java.sql.DriverManager;<span class="keyword">import</span> java.sql.PreparedStatement;<span class="keyword">import</span> java.sql.SQLException;<span class="keyword">class</span> <span class="title class_">Invocation</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;    <span class="keyword">private</span> SqlSession obj;  <span class="comment">//具体的要被代理的实际对象</span>    <span class="keyword">private</span> Connection con;    <span class="keyword">private</span> PreparedStatement preparedStatement;    <span class="keyword">public</span> <span class="title function_">Invocation</span><span class="params">(SqlSession obj)</span>&#123;        <span class="built_in">this</span>.obj = obj;    &#125;    <span class="comment">/*</span><span class="comment">     * invoke方法参数：</span><span class="comment">     *      proxy:没用</span><span class="comment">     *      method:实际对象的方法封装为Method类型对象</span><span class="comment">     *      args:实际对象的方法实参</span><span class="comment">     */</span>    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;        Object value;        <span class="comment">//1.执行jdbc初始次要业务</span>        init();        <span class="comment">//2.执行jdbc主要业务</span>        <span class="type">Field</span> <span class="variable">filed</span> <span class="operator">=</span> obj.getClass().getDeclaredField(<span class="string">&quot;ps&quot;</span>);        filed.setAccessible(<span class="literal">true</span>);        filed.set(obj,preparedStatement);        value = method.invoke(obj,args);        <span class="comment">//3.执行jdbc结束次要业务</span>        close();        <span class="keyword">return</span> value;    &#125;    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);        con = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/leetest?characterEncoding=UTF-8&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);        preparedStatement = con.prepareStatement(<span class="string">&quot;&quot;</span>);    &#125;    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;        con.close();        preparedStatement.close();    &#125;&#125;</code></pre><h4 id="代理角色生成工厂"><a class="markdownIt-Anchor" href="#代理角色生成工厂"></a> 代理角色生成工厂</h4><pre><code class="highlight java"><span class="keyword">package</span> com.proxymodel.util;<span class="keyword">import</span> com.proxymodel.service.SqlSession;<span class="keyword">import</span> java.lang.reflect.InvocationHandler;<span class="keyword">import</span> java.lang.reflect.Proxy;<span class="comment">/**</span><span class="comment"> * JDK动态代理模式下，代理对象的数据类型应该由监控行为来描述</span><span class="comment"> * 参数：Class文件，监控类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactory</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title function_">Builder</span><span class="params">(Class classFile)</span> <span class="keyword">throws</span> Exception&#123;        <span class="comment">//1.创建被监控实例对象</span>        <span class="type">SqlSession</span> <span class="variable">baseService</span> <span class="operator">=</span> (SqlSession) classFile.newInstance();        <span class="comment">//2.创建一个通知对象</span>        <span class="type">InvocationHandler</span> <span class="variable">invocation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Invocation</span>(baseService);        <span class="comment">//3.生成代理对象</span>        <span class="comment">/*</span><span class="comment">            loader:被监控对象隶属的类文件在内存中的真实地址</span><span class="comment">            interfacees:被监控对象隶属的类文件实现接口</span><span class="comment">            handler:监控对象发现小明要执行被监控行为，应该由哪一个通知对象进行辅助</span><span class="comment">         */</span>        <span class="type">SqlSession</span> <span class="variable">$proxy</span> <span class="operator">=</span> (SqlSession) Proxy.newProxyInstance(baseService.getClass().getClassLoader(), baseService.getClass().getInterfaces(), invocation);        <span class="keyword">return</span> $proxy;    &#125;&#125;</code></pre><h4 id="测试使用-2"><a class="markdownIt-Anchor" href="#测试使用-2"></a> 测试使用</h4><p>Mybatis实现代理模式实现原理与之基本类似</p><pre><code class="highlight java"><span class="keyword">package</span> com.proxymodel;<span class="keyword">import</span> com.proxymodel.service.SqlSession;<span class="keyword">import</span> com.proxymodel.serviceImpl.DeptMapper;<span class="keyword">import</span> com.proxymodel.util.SqlSessionFactory;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//获取的实际是代理角色</span>        <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> SqlSessionFactory.Builder(DeptMapper.class);        session.save(<span class="string">&quot;insert into values(&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,)&quot;</span>);    &#125;&#125;</code></pre>]]>
    </content>
    <id>http://example.com/2022/08/01/Mybatis%E8%BF%9B%E9%98%B6/</id>
    <link href="http://example.com/2022/08/01/Mybatis%E8%BF%9B%E9%98%B6/"/>
    <published>2022-08-01T04:00:00.000Z</published>
    <summary>MyBatis工作原理和工作流程,MyBatis配置文件核心标签,typeHandlers（自定义类型转换器）,Plugins（拦截器）,mybatis xml映射文件补充,mybatis原理-代理模式</summary>
    <title>Mybatis高级特性</title>
    <updated>2026-02-26T09:54:20.755Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    <content>
      <![CDATA[<h1 id="mysql"><a class="markdownIt-Anchor" href="#mysql"></a> MySQL</h1><p>[TOC]</p><h2 id="mysql入门"><a class="markdownIt-Anchor" href="#mysql入门"></a> MySQL入门</h2><h3 id="数据库概述"><a class="markdownIt-Anchor" href="#数据库概述"></a> 数据库概述</h3><p><strong>MySQL是什么？</strong></p><ul><li>MySQL 是最流行的<u>关系型数据库管理系统</u>，在WEB应用方面 MySQL 是最好的RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。</li></ul><p><strong>什么是数据库</strong></p><ul><li>数据库就是<u>存储数据的仓库</u>，其本质是一个<u>文件系统</u>，数据按照特定的格式将数据存储起来，用户可以通过SQL对数据库中的数据进行增加，修改，删除及查询操作。</li></ul><p><strong>什么是关系型数据库</strong></p><ul><li>数据库中的<u>记录是有行有列的数据库</u>就是关系型数据库，与之相反的就是NoSQL数据库了。</li></ul><p><strong>数据库和表</strong></p><ul><li>数据库管理系统（DataBase Management System，<strong>DBMS</strong>）：指一种<strong>操作和管理数据库的大型软件</strong>，用于建立、使用和维护数据库，对数据库进行统一管理和控制，以保证数据库的安全性和完整性。用户通过数据库管理系统访问<strong>数据库中表内的数据</strong>。(记录)</li></ul><p><strong>常见的数据库管理系统</strong></p><ul><li><p><strong>MYSQL</strong> ：开源免费的数据库，小型的数据库.已经被Oracle收购了.MySQL5.5版本之后都是由Oracle发布的版本。</p></li><li><p><strong>Oracle</strong>：收费的大型数据库，Oracle公司的产品。Oracle收购SUN公司，收购MYSQL。</p></li><li><p><strong>DB2</strong>：IBM公司的数据库产品,收费的。常应用在银行系统中.   在中国的互联网公司，要求去IOE（IBM小型机、Oracle数据库、EMC存储设备）</p></li><li><p><strong>SQLServer</strong>：MicroSoft 公司收费的中型的数据库。C#、.net等语言常使用。</p></li><li><p><strong>SyBase</strong>  ：已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner。</p></li><li><p><strong>SQLite</strong>   : 嵌入式的小型数据库，应用在手机端。</p></li></ul><h3 id="mysql发展历程"><a class="markdownIt-Anchor" href="#mysql发展历程"></a> MySQL发展历程</h3><p>MySQL的历史可以追溯到1979年，一个名为Monty Widenius的程序员在为TcX的小公司打工，并且用BASIC设计了一个报表工具，使其可以在4MHz主频和16KB内存的计算机上运行。当时，这只是一个很底层的且仅面向报表的存储引擎，名叫Unireg。</p><p>1990年，TcX公司的客户中开始有人要求为他的API提供SQL支持。Monty直接借助于mSQL的代码，将它集成到自己的存储引擎中。令人失望的是，效果并不太令人满意，决心自己重写一个SQL支持。</p><p>1996年，MySQL 1.0发布，它只面向一小拨人，相当于内部发布。</p><p>到了1996年10月，MySQL 3.11.1发布(MySQL没有2.x版本)，最开始只提供Solaris下的二进制版本。一个月后，Linux版本出现了。在接下来的两年里，MySQL被依次移植到各个平台。</p><p>1999～2000年，MySQL AB公司在瑞典成立。Monty雇了几个人与Sleepycat合作，开发出了Berkeley DB引擎, 由于BDB支持事务处理，因此MySQL从此开始支持事务处理了。</p><p>2000，MySQL不仅公布自己的源代码，并采用GPL(GNU General Public License)许可协议，正式进入开源世界。同年4月，MySQL对旧的存储引擎ISAM进行了整理，将其命名为MyISAM。</p><p>2001年，集成Heikki Tuuri的存储引擎InnoDB，这个引擎不仅能持事务处理，并且支持行级锁。后来该引擎被证明是最为成功的MySQL事务存储引擎。MySQL与InnoDB的正式结合版本是4.0</p><p>2003年12月，MySQL 5.0版本发布，提供了视图、存储过程等功能。</p><p>2008年1月，MySQL AB公司被Sun公司以10亿美金收购，MySQL数据库进入Sun时代。在Sun时代，Sun公司对其进行了大量的推广、优化、Bug修复等工作。</p><p>2008年11月，MySQL 5.1发布，它提供了分区、事件管理，以及基于行的复制和基于磁盘的NDB集群系统，同时修复了大量的Bug。</p><p>2009年4月，Oracle公司以74亿美元收购Sun公司，自此MySQL数据库进入Oracle时代，而其第三方的存储引擎InnoDB早在2005年就被Oracle公司收购。</p><p>2010年12月，MySQL 5.5发布，其主要新特性包括半同步的复制及对SIGNAL/RESIGNAL的异常处理功能的支持，最重要的是InnoDB存储引擎终于变为当前MySQL的默认存储引擎。MySQL 5.5不是时隔两年后的一次简单的版本更新，而是加强了MySQL各个方面在企业级的特性。Oracle公司同时也承诺MySQL 5.5和未来版本仍是采用GPL授权的开源产品。</p><h3 id="linux安装过程"><a class="markdownIt-Anchor" href="#linux安装过程"></a> linux安装过程</h3><p>查看本机是否安装了MySQL</p><pre><code class="highlight shell">rpm -qa|grep mysql</code></pre><h4 id="安装mysql"><a class="markdownIt-Anchor" href="#安装mysql"></a> 安装MySQL</h4><p><strong>国内镜像列表</strong><br /><a href="http://mirrors.sohu.com/mysql/MySQL-8.0/">http://mirrors.sohu.com/mysql/MySQL-8.0/</a></p><p><strong>安装仓库列表</strong></p><ol><li><p>要使用<strong>yum安装MySQL</strong>，要使用MySQL的yum仓库，先从官网下载适合你系统的仓库（即你要告诉yum你要安装哪个版本的MySQL）<br /><u><code>http://dev.mysql.com/downloads/repo/yun/</code></u></p></li><li><p>我们centos6.4对应的rpm包为：<u>mysql-community-release-el6-5.noarch.rpm</u></p></li><li><p>然后将<u>mysql-community-release-el6-5.noarch.rpm</u>上传到Linux系统</p></li><li><p>在上传的MySQL的rpm包当前目录下，执行以下命令：</p></li></ol><pre><code class="highlight plaintext">yum localinstall mysql-community-release-el6-5.noarch.rpm</code></pre><p><strong>安装MySQL</strong></p><pre><code class="highlight plaintext">yum install mysql-community-server</code></pre><h4 id="启动mysql"><a class="markdownIt-Anchor" href="#启动mysql"></a> 启动MySql</h4><p><strong>启动MySQL</strong></p><pre><code class="highlight plaintext">service mysqld start或者systemctl start  mysqld.service</code></pre><p><strong>重启MySQL</strong></p><pre><code class="highlight plaintext">service mysqld restart或者systemctl restart mysqld.service</code></pre><p><strong>关闭MySql</strong></p><pre><code class="highlight plaintext">service mysqld stop或者systemctl stop mysqld.service</code></pre><p><strong>查看mysql启动状态</strong></p><pre><code class="highlight plaintext">service mysqld status或者systemctl status mysqld.service</code></pre><h4 id="设置root用户密码"><a class="markdownIt-Anchor" href="#设置root用户密码"></a> 设置root用户密码</h4><p><strong>设置root密码</strong></p><p>MySQL数据库安装完成以后只会有一个root管理员账号，但是此时的root账号还并没有为其设置密码，在第一次启动MySQL服务时，会进行数据库的一些初始化工作，在输出的信息中，会出现下面这行信息：</p><pre><code class="highlight plaintext">grep &quot;password&quot; /var/log/mysqld.log</code></pre><p>该信息即为MySQL的root初始密码:</p><p>如下命令进入数据库（输入上一步查出的密码）：</p><pre><code class="highlight plaintext">mysql -uroot -p</code></pre><hr /><p>（Mysql5.x）在开始修改密码前，我们可以取消MySQL对密码难度的限制：</p><pre><code class="highlight plaintext">mysql&gt; set global validate_password_policy=0;mysql&gt; set global validate_password_length=1;</code></pre><p>（Mysql8.x）在开始修改密码前，我们可以取消MySQL对密码难度的限制：</p><pre><code class="highlight plaintext">mysql&gt; set global validate_password.policy=0;mysql&gt; set global validate_password.length=1;</code></pre><p>输入初始密码，此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库：</p><pre><code class="highlight plaintext">mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;new password&#x27;;</code></pre><hr /><p><s>运行下列命令即可设置root用户密码</s>：</p><pre><code class="highlight plaintext">/usr/bin/mysqladmin -u root password &#x27;new-password&#x27;         //运行此行命令为root账号设置密码</code></pre><h4 id="命令行连接mysql"><a class="markdownIt-Anchor" href="#命令行连接mysql"></a> 命令行连接mysql</h4><pre><code class="highlight plaintext">mysql -uroot -p123456</code></pre><h4 id="mysql远程连接授权"><a class="markdownIt-Anchor" href="#mysql远程连接授权"></a> MySQL远程连接授权</h4><p>正常情况下Windows客户端是无法远程连接Linux系统的MySQL的，需要远程连接授权才可以</p><pre><code class="highlight plaintext">mysql&gt;GRANT ALL PRIVILEGES ON *.* TO &#x27;myuser&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;mypassword&#x27; WITH GRANT OPTION</code></pre><blockquote><p>注意：‘myuser’，'mypassword’需要替换成实际的用户名和密码</p></blockquote><h4 id="关闭linux防火墙"><a class="markdownIt-Anchor" href="#关闭linux防火墙"></a> 关闭Linux防火墙</h4><p>如果是阿里云服务器，只需配置相应的安全组即可。</p><blockquote><p>防火墙主要目的是阻止端口用的，能ping通不代表能连接（ping主要是ping连接，ping并不涉及端口）</p></blockquote><pre><code class="highlight plaintext">service iptables stop</code></pre><h4 id="设置大小写不敏感"><a class="markdownIt-Anchor" href="#设置大小写不敏感"></a> 设置大小写不敏感</h4><ol><li><p>Linux下mysql安装完后是默认：区分表名的大小写，不区分列名的大小写</p></li><li><p>用root账号登陆后，在/etc/my.cnf中的[mysqld]后添加</p></li></ol><pre><code class="highlight plaintext">lower_case_table_names=1     //0：区分大小写    //1：不区分大小写</code></pre><ol start="3"><li>重启MySQL服务，这样就设置成功不区分表名大小写</li></ol><h4 id="卸载"><a class="markdownIt-Anchor" href="#卸载"></a> 卸载</h4><p>运行以下命令即可</p><pre><code class="highlight plaintext">yum remove mysql mysql-server mysql-libs mysql-commonrm -rf /var/lib/mysqlrm /etc/my.cnf</code></pre><blockquote><p>软件卸载完毕后如果需要可以删除MySQL的数据库</p></blockquote><pre><code class="highlight plaintext">/var/lib/mysql</code></pre><h3 id="windows安装过程"><a class="markdownIt-Anchor" href="#windows安装过程"></a> windows安装过程</h3><ul><li>开始安装<br />*</li><li>选择compelete，完整安装<br />*</li><li>自动弹出配置界面<br />*</li><li>选择标准配置<br />*</li><li>设置root密码<ul><li>root是MySQL默认的管理员账号</li><li></li></ul></li><li>成功界面<br />*</li></ul><h4 id="完全卸载windows"><a class="markdownIt-Anchor" href="#完全卸载windows"></a> 完全卸载(windows)</h4><p><strong>mysql 卸载</strong></p><ul><li>运行安装程序，点击Remove进行卸载。</li><li></li></ul><p><strong>删除mysql安装目录</strong></p><ul><li>删除mysql目录</li></ul><pre><code class="highlight plaintext">C:\Program Files\MySQL</code></pre><p><strong>删除my.ini</strong></p><ul><li>检查C:\WINDOWS目录下是否有my.ini文件,将其删除</li><li>这个文件不一定存在</li></ul><p><strong>删除注册表</strong></p><ul><li><p><code>win+r</code> 弹出窗口输入 <code>regedit</code></p></li><li><p>删除key1</p></li></ul><pre><code class="highlight plaintext">HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application\MySQL</code></pre><ul><li></li><li>删除key2<ul><li>如下两个key不一定有，没有就不理了</li></ul></li></ul><pre><code class="highlight plaintext">HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Eventlog\Application \MySQL</code></pre><pre><code class="highlight plaintext">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application\MySQL</code></pre><p><strong>删除ProgramData目录下的文件</strong></p><ul><li>如果是win10,则删除</li></ul><pre><code class="highlight plaintext">C:\ProgramData\MySQL Server 5.5</code></pre><blockquote><p>这个目录默认是隐藏的，需要在文件夹选项中显示出来</p></blockquote><ul><li>如果是win7以下，删除</li></ul><pre><code class="highlight plaintext">C:\Documents and Settings\All Users\Application Data\MySQL</code></pre><p><strong>重新安装</strong></p><h4 id="windows启动"><a class="markdownIt-Anchor" href="#windows启动"></a> Windows启动</h4><p>启动服务：</p><pre><code class="highlight plaintext">mysqld --console　　或　　net start mysql</code></pre><p>关闭服务：</p><pre><code class="highlight plaintext">mysqladmin -uroot shudown　　或　　net stop mysql</code></pre><h3 id="sqlyog-安装与使用"><a class="markdownIt-Anchor" href="#sqlyog-安装与使用"></a> SQLyog 安装与使用</h3><p>输入用户名、密码，点击连接按钮，进行访问MySQL数据库进行操作</p><p>在Query窗口中，输入SQL代码，选中要执行的SQL代码，按F8键运行，或按执行按钮运行</p><h3 id="cmd命令"><a class="markdownIt-Anchor" href="#cmd命令"></a> CMD命令</h3><blockquote><p>MySQL配置文件：在MySQL目录下的  “my.ini”  文件中（可以修改端口号，字符集等）</p></blockquote><p><strong>cmd命令</strong></p><p>启动MySQL服务：</p><pre><code class="highlight plaintext">net start mysql</code></pre><p>关闭MySQL服务：</p><pre><code class="highlight plaintext">net stop mysql</code></pre><p>启动MySQL：</p><pre><code class="highlight plaintext">mysql -hlocalhost -uroot -p           (-h本机链接或远程链接域名    -u指定用户名 -p密码)</code></pre><p>关闭MySQL：</p><pre><code class="highlight plaintext">exit</code></pre><p>查看状态：</p><pre><code class="highlight plaintext">\s</code></pre><p>查看所有默认配置变量：</p><pre><code class="highlight plaintext">show variables;</code></pre><p>查看所有数据库：</p><pre><code class="highlight plaintext">show databases;</code></pre><p>帮助文档：</p><pre><code class="highlight plaintext">? contents</code></pre><h3 id="cmd中文乱码"><a class="markdownIt-Anchor" href="#cmd中文乱码"></a> CMD中文乱码</h3><p>修改my.ini文件，然后重启mysql服务器</p><h2 id="sql语句"><a class="markdownIt-Anchor" href="#sql语句"></a> SQL语句</h2><p><strong>什么是SQL？</strong></p><ul><li><p>全称Structured Query Language，简称SQL，中文叫结构化查询语言。</p></li><li><p>关系数据库语言的国际标准。SQL92、SQL99</p></li><li><p>不只是mysql还有其他数据库，在SQL92或者SQL99这些国际SQL标准基础之上，它们还扩展了自己的一些SQL语句，比如MySQL中的limit关键字</p></li></ul><p><strong>SQL分类：</strong></p><ul><li><p>数据定义语言：简称<strong>DDL</strong>(Data Definition Language)，用来定义数据库对象：数据库，表，列等。关键字：create，alter，drop等</p></li><li><p>数据操作语言：简称<strong>DML</strong>(Data Manipulation Language)，用来对数据库中表的记录进行更新。关键字：insert，delete，update等</p></li><li><p>数据控制语言：简称<strong>DCL</strong>(Data Control Language)，用来定义数据库的访问权限和安全级别，及创建用户；关键字：grant等</p></li><li><p>数据查询语言：简称<strong>DQL</strong>(Data Query Language)，用来查询数据库中表的记录。关键字：select，from，where等</p></li></ul><h3 id="数据库操作"><a class="markdownIt-Anchor" href="#数据库操作"></a> 数据库操作</h3><h4 id="创建数据库"><a class="markdownIt-Anchor" href="#创建数据库"></a> 创建数据库</h4><p>语法：</p><ul><li>&lt;数据库名&gt;：创建数据库的名称。MySQL 的数据存储区将以目录方式表示 MySQL 数据库，因此数据库名称必须符合操作系统的文件夹命名规则，注意在 MySQL 中不区分大小写。</li><li>IF NOT EXISTS：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。此选项可以用来避免数据库已经存在而重复创建的错误。</li><li>[DEFAULT] CHARACTER SET：指定数据库的默认字符集。</li><li>[DEFAULT] COLLATE：指定字符集的默认校对规则。</li></ul><pre><code class="highlight sql"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] <span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span>[[<span class="keyword">DEFAULT</span>] <span class="keyword">CHARACTER SET</span> <span class="operator">&lt;</span>字符集名<span class="operator">&gt;</span>] [[<span class="keyword">DEFAULT</span>] <span class="keyword">COLLATE</span> <span class="operator">&lt;</span>校对规则名<span class="operator">&gt;</span>];</code></pre><blockquote><p>MySQL 的字符集（CHARACTER）和校对规则（COLLATION）两个不同的概念：字符集是用来定义 MySQL 存储字符串的方式，校对规则定义了比较字符串的方式，解决排序和字符分组的问题</p></blockquote><blockquote><p>字符集和校对规则是一对多的关系，每个字符集至少对应一个校对规则，MySQL 支持 39 种字符集的将近 200 种校对规则</p></blockquote><p>案例：</p><pre><code class="highlight sql"><span class="keyword">create</span> database leeTest <span class="keyword">character set</span> 字符集;<span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> test_db_char <span class="keyword">DEFAULT</span> <span class="keyword">CHARACTER SET</span> utf8 <span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> utf8_chinese_ci;</code></pre><h4 id="查看数据库"><a class="markdownIt-Anchor" href="#查看数据库"></a> 查看数据库</h4><ul><li>查看数据库服务器中的所有的数据库:</li></ul><pre><code class="highlight sql"><span class="keyword">show</span> databases;<span class="keyword">SHOW</span> DATABASES [<span class="keyword">LIKE</span> <span class="string">&#x27;数据库名&#x27;</span>];</code></pre><ul><li>查看某个数据库的定义的信息:</li></ul><pre><code class="highlight sql"><span class="keyword">show</span> <span class="keyword">create</span> database 数据库名;</code></pre><p><strong>查看正在使用的数据库:</strong></p><pre><code class="highlight sql"><span class="keyword">select</span> database();</code></pre><h4 id="修改数据库"><a class="markdownIt-Anchor" href="#修改数据库"></a> 修改数据库</h4><p>语法：</p><ul><li>ALTER DATABASE 用于更改数据库的全局特性。这些特性存储在数据库目录的 db.opt 文件中。</li><li>使用 ALTER DATABASE 需要获得数据库 ALTER 权限。</li><li>数据库名称可以忽略，此时语句对应于默认数据库。</li><li>CHARACTER SET 子句用于更改默认的数据库字符集。</li></ul><pre><code class="highlight sql"><span class="keyword">ALTER</span> DATABASE [数据库名] &#123; [ <span class="keyword">DEFAULT</span> ] <span class="keyword">CHARACTER SET</span> <span class="operator">&lt;</span>字符集名<span class="operator">&gt;</span> <span class="operator">|</span>[ <span class="keyword">DEFAULT</span> ] <span class="keyword">COLLATE</span> <span class="operator">&lt;</span>校对规则名<span class="operator">&gt;</span>&#125;</code></pre><h4 id="删除数据库"><a class="markdownIt-Anchor" href="#删除数据库"></a> 删除数据库</h4><pre><code class="highlight sql"><span class="keyword">drop</span> database 数据库名称;<span class="keyword">DROP</span> DATABASE [ IF <span class="keyword">EXISTS</span> ] <span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span></code></pre><h4 id="切换数据库"><a class="markdownIt-Anchor" href="#切换数据库"></a> 切换数据库</h4><pre><code class="highlight sql">use 数据库名;</code></pre><h3 id="字段类型"><a class="markdownIt-Anchor" href="#字段类型"></a> 字段类型</h3><h4 id="整数型"><a class="markdownIt-Anchor" href="#整数型"></a> <strong>整数型</strong></h4><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th><th>有符号数</th><th>无符号数</th></tr></thead><tbody><tr><td>TINYINT</td><td>很小的整数</td><td>1个字节</td><td>-128〜127</td><td>0〜255</td></tr><tr><td>SMALLINT</td><td>小的整数</td><td>2个宇节</td><td>-32768〜32767</td><td>0〜65535</td></tr><tr><td>MEDIUMINT</td><td>中等大小的整数</td><td>3个字节</td><td>-8388608〜8388607</td><td>0〜16777215</td></tr><tr><td><strong>INT</strong></td><td>普通大小的整数</td><td>4个字节</td><td>-2147483648〜2147483647</td><td>0〜4294967295</td></tr><tr><td>BIGINT</td><td>大整数</td><td>8个字节</td><td>-9223372036854775808〜9223372036854775807</td><td>0〜18446744073709551615</td></tr></tbody></table><blockquote><p>该属性字段可以添加 AUTO_INCREMENT 自增约束条件</p></blockquote><blockquote><p><strong>指定字段unsigned，只能储存正数</strong></p></blockquote><hr /><h4 id="浮点型"><a class="markdownIt-Anchor" href="#浮点型"></a> <strong>浮点型</strong></h4><p>浮点类型和定点类型都可以用(M, D)来表示，其中M称为精度，表示总共的位数；D称为标度，表示小数的位数</p><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>FLOAT</td><td>单精度浮点数</td><td>4 个字节</td></tr><tr><td>DOUBLE</td><td>双精度浮点数</td><td>8 个字节</td></tr><tr><td><strong>DECIMAL</strong> (M, D)，DEC</td><td>压缩的“严格”定点数</td><td>M+2 个字节</td></tr></tbody></table><p>DECIMAL 类型不同于 FLOAT 和 DOUBLE。DOUBLE 实际上是以字符串的形式存放的，DECIMAL 可能的最大取值范围与 DOUBLE 相同，但是有效的取值范围由 M 和 D 决定。如果改变 M 而固定 D，则取值范围将随 M 的变大而变大</p><blockquote><p>提示：不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理</p></blockquote><blockquote><p>FLOAT 和 DOUBLE 在不指定精度时，默认会按照实际的精度（由计算机硬件和操作系统决定），DECIMAL 如果不指定精度，默认为（10，0）</p></blockquote><blockquote><p>在 MySQL 中，定点数以字符串形式存储，在对<strong>精度要求比较高的时候</strong>（如货币、科学数据），<strong>使用 DECIMAL 的类型比较好</strong>，另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较</p></blockquote><hr /><h4 id="字符型"><a class="markdownIt-Anchor" href="#字符型"></a> <strong>字符型</strong></h4><ul><li><p>VARCHAR(M) 是长度可变的字符串，M 表示最大列的长度，M 的范围是 0～65535。VARCHAR 的最大实际长度由最长的行的大小和使用的字符集确定，而实际占用的空间为字符串的实际长度加 1</p></li><li><p>CHAR(M) 为固定长度字符串，在定义时指定字符串列长。当保存时，在右侧填充空格以达到指定的长度。M 表示列的长度，范围是 0～255 个字符</p></li><li><p>TEXT 列保存非二进制字符串，如文章内容、评论等</p></li></ul><blockquote><p>VARCHAR 和 TEXT 类型是变长类型，其存储需求取决于列值的实际长度（在前面的表格中用 L 表示），而不是取决于类型的最大可能尺寸</p></blockquote><ul><li>ENUM 是一个字符串对象，值为表创建时列规定中枚举的一列值</li></ul><pre><code class="highlight sql"><span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> ENUM( <span class="string">&#x27;值1&#x27;</span>, <span class="string">&#x27;值1&#x27;</span>, …, <span class="string">&#x27;值n&#x27;</span> )</code></pre><blockquote><p>提示：ENUM 列总有一个默认值。如果将 ENUM 列声明为 NULL，NULL 值则为该列的一个有效值，并且默认值为 NULL。如果 ENUM 列被声明为 NOT NULL，其默认值为允许的值列表的第 1 个元素。</p></blockquote><ul><li>SET 是一个字符串的对象，可以有零或多个值，SET 列最多可以有 64 个成员，值为表创建时规定的一列值。指定包括多个 SET 成员的 SET 列值时，各成员之间用逗号,隔开，语法格式如下：</li></ul><pre><code class="highlight sql"><span class="keyword">SET</span>( <span class="string">&#x27;值1&#x27;</span>, <span class="string">&#x27;值2&#x27;</span>, …, <span class="string">&#x27;值n&#x27;</span> )</code></pre><blockquote><p>但与 ENUM 类型不同的是，ENUM 类型的字段只能从定义的列值中选择一个值插入，而 SET 类型的列可从定义的列值中选择多个字符的联合。</p></blockquote><blockquote><p>提示：如果插入 SET 字段中的列值有重复，则 MySQL 自动删除重复的值；插入 SET 字段的值的顺序并不重要，MySQL 会在存入数据库时，按照定义的顺序显示；如果插入了不正确的值，默认情况下，MySQL 将忽视这些值，给出警告。</p></blockquote><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度非二进制字符串</td><td>M 字节，1&lt;=M&lt;=255</td></tr><tr><td><strong>VARCHAR</strong>(M)</td><td><strong>变长</strong>非二进制字符串</td><td>L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255</td></tr><tr><td>TINYTEXT</td><td>非常小的非二进制字符串</td><td>L+1字节，在此，L&lt;2^8</td></tr><tr><td>TEXT</td><td>小的非二进制字符串</td><td>L+2字节，在此，L&lt;2^16</td></tr><tr><td>MEDIUMTEXT</td><td>中等大小的非二进制字符串</td><td>L+3字节，在此，L&lt;2^24</td></tr><tr><td>LONGTEXT</td><td>大的非二进制字符串</td><td>L+4字节，在此，L&lt;2^32</td></tr><tr><td>ENUM</td><td>枚举类型，只能有一个枚举字符串值</td><td>1或2个字节，取决于枚举值的数目 (最大值为65535)</td></tr><tr><td>SET</td><td>一个设置，字符串对象可以有零个或 多个SET成员</td><td>1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）</td></tr></tbody></table><hr /><h4 id="日期类型"><a class="markdownIt-Anchor" href="#日期类型"></a> <strong>日期类型</strong></h4><table><thead><tr><th>类型名称</th><th>日期格式</th><th>日期范围</th><th>存储需求</th></tr></thead><tbody><tr><td>YEAR</td><td>YYYY</td><td>1901 ~ 2155</td><td>1 个字节</td></tr><tr><td>TIME</td><td>HH:MM:SS</td><td>-838:59:59 ~ 838:59:59</td><td>3 个字节</td></tr><tr><td><strong>DATE</strong></td><td>YYYY-MM-DD</td><td>1000-01-01 ~ 9999-12-3</td><td>3 个字节</td></tr><tr><td><strong>DATETIME</strong></td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td><td>8 个字节</td></tr><tr><td>TIMESTAMP</td><td>YYYY-MM-DD HH:MM:SS</td><td>1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC</td><td>4 个字节</td></tr></tbody></table><hr /><h4 id="二进制类型"><a class="markdownIt-Anchor" href="#二进制类型"></a> <strong>二进制类型</strong></h4><table><thead><tr><th>BIT(M)</th><th>位字段类型</th><th>大约 (M+7)/8 字节</th></tr></thead><tbody><tr><td>BINARY(M)</td><td>固定长度二进制字符串</td><td>M 字节</td></tr><tr><td>VARBINARY (M)</td><td>可变长度二进制字符串</td><td>M+1 字节</td></tr><tr><td>TINYBLOB (M)</td><td>非常小的BLOB</td><td>L+1 字节，在此，L&lt;2^8</td></tr><tr><td>BLOB (M)</td><td>小 BLOB</td><td>L+2 字节，在此，L&lt;2^16</td></tr><tr><td>MEDIUMBLOB (M)</td><td>中等大小的BLOB</td><td>L+3 字节，在此，L&lt;2^24</td></tr><tr><td>LONGBLOB (M)</td><td>非常大的BLOB</td><td>L+4 字节，在此，L&lt;2^32(4GB)</td></tr></tbody></table><p>boolean类型：不支持</p><h3 id="表操作"><a class="markdownIt-Anchor" href="#表操作"></a> 表操作</h3><h4 id="创建表create"><a class="markdownIt-Anchor" href="#创建表create"></a> 创建表create</h4><p><strong>语法：</strong></p><p>单表约束：</p><ul><li>主键约束：<code>primary key</code></li><li>复合主键：<code>primary key[字段1，字段2...]</code></li><li>唯一约束：<code>unique</code></li><li>非空约束：<code>not null</code></li><li>检查约束：<code>check &lt;表达式&gt;</code></li><li>默认值约束：<code>default '默认值'</code></li></ul><blockquote><p>注意：主键约束 = 唯一约束 + 非空约束</p></blockquote><pre><code class="highlight sql"><span class="keyword">create table</span> 表名(   字段名 类型(长度) 约束,   字段名 类型(长度) 约束,   <span class="keyword">check</span> <span class="operator">&lt;</span>表达式<span class="operator">&gt;</span>);</code></pre><p>示例：</p><pre><code class="highlight sql"><span class="keyword">CREATE TABLE</span> hero (  id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT ,  name <span class="type">varchar</span>(<span class="number">30</span>) ,  hp <span class="type">float</span> ,  damage <span class="type">int</span>(<span class="number">11</span>),  <span class="keyword">group</span> <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="string">&#x27;金融事业部&#x27;</span>,  createdate datetime,  salary <span class="type">float</span>,  <span class="keyword">check</span>(salary<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">and</span> salary<span class="operator">&lt;</span><span class="number">1000</span>))  <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</code></pre><h4 id="查看删除修改表"><a class="markdownIt-Anchor" href="#查看删除修改表"></a> 查看/删除/修改表</h4><hr /><p><strong>查看表</strong></p><p>查看数据库中的所有表：</p><pre><code class="highlight sql"><span class="keyword">show</span> tables;</code></pre><p>查看表结构：</p><pre><code class="highlight sql"><span class="keyword">desc</span> 表名;</code></pre><hr /><p><strong>删除表</strong></p><ul><li>&lt;表名&gt;：被删除的表名。DROP TABLE 语句可以同时删除多个表，用户必须拥有该命令的权限。</li><li>表被删除时，所有的表数据和表定义会被取消，所以使用本语句要小心。</li><li>表被删除时，用户在该表上的权限并不会自动被删除。</li><li>参数IF EXISTS用于在删除前判断删除的表是否存在，加上该参数后，在删除表的时候，如果表不存在，SQL 语句可以顺利执行，但会发出警告（warning）。</li></ul><pre><code class="highlight sql"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;<span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [ , <span class="operator">&lt;</span>表名<span class="number">1</span><span class="operator">&gt;</span> , <span class="operator">&lt;</span>表名<span class="number">2</span><span class="operator">&gt;</span>] …;</code></pre><hr /><p><strong>修改表</strong></p><pre><code class="highlight sql"><span class="keyword">alter table</span> 表名 <span class="keyword">add</span> 列名 类型(长度) 约束; <span class="comment">--修改表 添加列. </span><span class="keyword">alter table</span> 表名 modify 列名 类型(长度) 约束;<span class="comment">--修改表 修改列的类型长度及约束.</span><span class="keyword">alter table</span> 表名 change 旧列名 新列名 类型(长度) 约束;<span class="comment">--修改表 修改列名.</span><span class="keyword">alter table</span> 表名 <span class="keyword">drop</span> 列名;<span class="comment">--修改表 删除列.</span>rename <span class="keyword">table</span> 表名 <span class="keyword">to</span> 新表名;<span class="comment">--修改表名</span><span class="keyword">alter table</span> 表名 <span class="keyword">character set</span> 字符集;<span class="comment">--修改表的字符集</span></code></pre><p>案例：</p><pre><code class="highlight sql"><span class="comment">--修改字段数据类型</span><span class="keyword">ALTER TABLE</span> tb_emp1 MODIFY name <span class="type">VARCHAR</span>(<span class="number">30</span>); <span class="comment">--删除字段</span><span class="keyword">ALTER TABLE</span> tb_emp1 <span class="keyword">DROP</span> col2;<span class="comment">--修改字段名</span><span class="keyword">ALTER TABLE</span> tb_emp1 CHANGE col1 col3 <span class="type">CHAR</span>(<span class="number">30</span>);<span class="comment">--修改表名</span><span class="keyword">ALTER TABLE</span> tb_emp1 RENAME <span class="keyword">TO</span> tb_emp2;<span class="comment">--添加主键</span><span class="keyword">ALTER TABLE</span> <span class="operator">&lt;</span>数据表名<span class="operator">&gt;</span> <span class="keyword">ADD</span> <span class="keyword">PRIMARY KEY</span>(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>);<span class="comment">--添加唯一约束</span><span class="keyword">ALTER TABLE</span> <span class="operator">&lt;</span>数据表名<span class="operator">&gt;</span> <span class="keyword">ADD CONSTRAINT</span> <span class="operator">&lt;</span>唯一约束名<span class="operator">&gt;</span> <span class="keyword">UNIQUE</span>(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>);<span class="comment">--删除唯一约束</span><span class="keyword">ALTER TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">DROP</span> INDEX <span class="operator">&lt;</span>唯一约束名<span class="operator">&gt;</span>;<span class="comment">---添加检查约束</span><span class="keyword">ALTER TABLE</span> tb_emp7 <span class="keyword">ADD CONSTRAINT</span> <span class="operator">&lt;</span>检查约束名<span class="operator">&gt;</span> <span class="keyword">CHECK</span>(<span class="operator">&lt;</span>检查约束<span class="operator">&gt;</span>)<span class="comment">--删除检查约束</span><span class="keyword">ALTER TABLE</span> <span class="operator">&lt;</span>数据表名<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>检查约束名<span class="operator">&gt;</span>;<span class="comment">--删除默认值约束</span><span class="keyword">ALTER TABLE</span> <span class="operator">&lt;</span>数据表名<span class="operator">&gt;</span>CHANGE <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>;<span class="comment">--添加默认值约束</span><span class="keyword">ALTER TABLE</span> <span class="operator">&lt;</span>数据表名<span class="operator">&gt;</span>CHANGE <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> <span class="keyword">DEFAULT</span> <span class="operator">&lt;</span>默认值<span class="operator">&gt;</span>;<span class="comment">--添加非空约束</span><span class="keyword">ALTER TABLE</span> <span class="operator">&lt;</span>数据表名<span class="operator">&gt;</span>CHANGE <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span><span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> <span class="keyword">NOT NULL</span>;<span class="comment">--删除非空约束</span><span class="keyword">ALTER TABLE</span> <span class="operator">&lt;</span>数据表名<span class="operator">&gt;</span>CHANGE <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> <span class="keyword">NULL</span>;</code></pre><h4 id="插入数据insert"><a class="markdownIt-Anchor" href="#插入数据insert"></a> 插入数据insert</h4><p>语法：</p><ol><li>列名数与values后面的值的个数相等</li><li>列的顺序与插入的值得顺序一致</li><li>列名的类型与插入的值要一致.</li><li>插入值得时候不能超过最大长度.</li><li>值如果是字符串或者日期需要加引号’’ （一般是单引号）</li></ol><pre><code class="highlight sql"><span class="keyword">insert into</span> 表 (列名<span class="number">1</span>,列名<span class="number">2</span>,列名<span class="number">3.</span>.) <span class="keyword">values</span>  (值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3.</span>.); <span class="comment">-- 向表中插入某些列</span><span class="keyword">insert into</span> 表 <span class="keyword">values</span> (值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3.</span>.); <span class="comment">--向表中插入所有列</span><span class="keyword">insert into</span> 表 (列名<span class="number">1</span>,列名<span class="number">2</span>,列名<span class="number">3.</span>.) <span class="keyword">values</span> <span class="keyword">select</span> (列名<span class="number">1</span>,列名<span class="number">2</span>,列名<span class="number">3.</span>.) <span class="keyword">from</span> 表<span class="keyword">insert into</span> 表 <span class="keyword">values</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表</code></pre><p>示例：</p><pre><code class="highlight sql"><span class="keyword">insert into</span> sort(sid,sname) <span class="keyword">values</span>(<span class="string">&#x27;s002&#x27;</span>, <span class="string">&#x27;服饰&#x27;</span>);<span class="keyword">insert into</span> hero <span class="keyword">values</span> (<span class="keyword">null</span>, <span class="string">&#x27;盖伦&#x27;</span>, <span class="number">616</span>, <span class="number">100</span>)</code></pre><h4 id="修改数据update"><a class="markdownIt-Anchor" href="#修改数据update"></a> 修改数据update</h4><p>语法：</p><ol><li>列名的类型与修改的值要一致.</li><li>修改值得时候不能超过最大长度.</li><li>值如果是字符串或者日期需要加’’</li></ol><pre><code class="highlight sql"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段名<span class="operator">=</span>值,字段名<span class="operator">=</span>值;<span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段名<span class="operator">=</span>值,字段名<span class="operator">=</span>值 <span class="keyword">where</span> 条件;</code></pre><p>示例：</p><pre><code class="highlight sql"><span class="keyword">update</span> hero <span class="keyword">set</span> hp <span class="operator">=</span> <span class="number">818</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></code></pre><h4 id="删除数据delete"><a class="markdownIt-Anchor" href="#删除数据delete"></a> 删除数据delete</h4><p>语法：</p><pre><code class="highlight sql"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件];</code></pre><p>示例：</p><pre><code class="highlight sql"><span class="keyword">delete</span> <span class="keyword">from</span> hero <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></code></pre><blockquote><p><strong>delete</strong> 一条一条删除，不清空<code>auto_increment</code>记录数</p></blockquote><blockquote><p><strong>truncate</strong> 直接将表删除，重新建表，<code>auto_increment</code>将置为零，从新开始</p></blockquote><h3 id="sql查询"><a class="markdownIt-Anchor" href="#sql查询"></a> SQL查询</h3><p>查询语句，在开发中使用的次数最多，此处使用“products”商品表。</p><ul><li><p>主键类型，本案例采用int类型，实际案例采用是varchar类型</p></li><li><p>时间类型，本案例采用date类型，实际案例采用datetime类型</p></li></ul><h4 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h4><pre><code class="highlight sql">创建商品表：<span class="keyword">CREATE TABLE</span> products (  pid <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT, #自增加 AUTO_INCREMENT  pname <span class="type">VARCHAR</span>(<span class="number">20</span>),#商品名称  price <span class="keyword">DOUBLE</span>, #商品价格  pdate <span class="type">DATE</span>, # 日期  sid <span class="type">VARCHAR</span>(<span class="number">20</span>) #分类ID);<span class="keyword">INSERT INTO</span> products <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;泰国大榴莲&#x27;</span>, <span class="number">98</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;s001&#x27;</span>);<span class="keyword">INSERT INTO</span> products <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;新疆大枣&#x27;</span>, <span class="number">38</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;s002&#x27;</span>);<span class="keyword">INSERT INTO</span> products <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;新疆切糕&#x27;</span>, <span class="number">68</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;s001&#x27;</span>);<span class="keyword">INSERT INTO</span> products <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;十三香&#x27;</span>, <span class="number">10</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;s002&#x27;</span>);<span class="keyword">INSERT INTO</span> products <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;老干妈&#x27;</span>, <span class="number">20</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;s002&#x27;</span>);</code></pre><h4 id="简单查询"><a class="markdownIt-Anchor" href="#简单查询"></a> 简单查询</h4><p>语法：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>]<span class="operator">*</span>[列名,列名] <span class="keyword">FROM</span>  表 [<span class="keyword">WHERE</span> 条件].</code></pre><p>案例：</p><pre><code class="highlight sql"><span class="comment">--1.查询所有的商品.</span><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product;<span class="comment">--2.查询商品名和商品价格.</span><span class="keyword">select</span> pname,price <span class="keyword">from</span> product;<span class="comment">--3.别名查询，使用的as关键字，as可以省略的.</span><span class="comment">--   3.1表别名: </span>   <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">as</span> p;<span class="comment">--   3.2列别名：</span>   <span class="keyword">select</span> pname <span class="keyword">as</span> pn <span class="keyword">from</span> product;   <span class="comment">--4.去掉重复值.</span><span class="keyword">select</span> <span class="keyword">distinct</span> price <span class="keyword">from</span> product;<span class="comment">--5.查询结果是表达式（运算查询）：将所有商品的价格+10元进行显示.</span><span class="keyword">select</span> pname,price<span class="operator">+</span><span class="number">10</span> <span class="keyword">from</span> product;</code></pre><h4 id="去重"><a class="markdownIt-Anchor" href="#去重"></a> 去重</h4><p>有时出于对数据分析的要求，需要消除重复的记录值。这时候就需要用到 DISTINCT 关键字指示 MySQL 消除重复的记录值，语法格式为：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>;</code></pre><h4 id="条件查询"><a class="markdownIt-Anchor" href="#条件查询"></a> 条件查询</h4><p><strong>where</strong>后的条件写法：</p><ul><li><code>&gt; ,&lt;,=,&gt;=,&lt;=,&lt;&gt;</code></li><li><strong>like</strong> 使用占位符 <strong>_ 和 %</strong>  _代表一个字符 %代表任意个字符.</li></ul><pre><code class="highlight sql"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> pname <span class="keyword">like</span> <span class="string">&#x27;%新%&#x27;</span>;</code></pre><ul><li>in在某个范围中获得值（<strong>exists</strong>）.</li></ul><pre><code class="highlight sql"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> pid <span class="keyword">in</span> (<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>);</code></pre><p>案例：</p><pre><code class="highlight sql"><span class="comment">--1.查询商品名称为十三香的商品所有信息：</span><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> pname <span class="operator">=</span> <span class="string">&#x27;十三香&#x27;</span>;<span class="comment">--2.查询商品价格&gt;60元的所有的商品信息:</span><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="operator">&gt;</span> <span class="number">60</span>;</code></pre><h4 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h4><p>SQL语法关键字：</p><ul><li><strong>ORDER BY</strong></li><li><strong>ASC（升序） DESC（降序）</strong></li></ul><p>案例：</p><pre><code class="highlight sql"><span class="comment">--1.查询所有的商品，按价格进行排序.(asc-升序,desc-降序)</span><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">order</span> <span class="keyword">by</span> price;<span class="comment">--2.查询名称有新的商品的信息并且按价格降序排序.</span><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> pname <span class="keyword">like</span> <span class="string">&#x27;%新%&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">desc</span>;</code></pre><h4 id="聚合函数"><a class="markdownIt-Anchor" href="#聚合函数"></a> 聚合函数</h4><p>特点：<strong>只对单列进行操作</strong><br />常用的聚合函数：</p><ul><li><strong>sum</strong>()：求某一列的和</li><li><strong>avg</strong>()：求某一列的平均值</li><li><strong>max</strong>()：求某一列的最大值</li><li><strong>min</strong>()：求某一列的最小值</li><li><strong>count</strong>()：求某一列的元素个数<br />案例</li></ul><pre><code class="highlight sql"><span class="comment">--1.获得所有商品的价格的总和：</span><span class="keyword">select</span> <span class="built_in">sum</span>(price) <span class="keyword">from</span> product;<span class="comment">--2.获得所有商品的平均价格：</span><span class="keyword">select</span> <span class="built_in">avg</span>(price) <span class="keyword">from</span> product;<span class="comment">--3.获得所有商品的个数：</span><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> product;</code></pre><h4 id="分组"><a class="markdownIt-Anchor" href="#分组"></a> 分组</h4><p>SQL语法关键字：</p><ul><li><strong>GROUP BY</strong></li><li><strong>HAVING</strong></li></ul><p><strong>注意事项</strong>：</p><ol><li>select语句中的列（非聚合函数列），必须出现在group by子句中</li><li>group by子句中的列，不一定要出现在select语句中</li><li>聚合函数只能出现select语句中或者having语句中，一定不能出现在where语句中</li></ol><p>案例：</p><pre><code class="highlight sql"><span class="comment">--1.根据cno字段分组，分组后统计商品的个数.</span><span class="keyword">select</span> cid,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> product <span class="keyword">group</span> <span class="keyword">by</span> cid;<span class="comment">--2.根据cno分组，分组统计每组商品的平均价格，并且平均价格&gt; 60;</span><span class="keyword">select</span> cid,<span class="built_in">avg</span>(price) <span class="keyword">from</span> product <span class="keyword">group</span> <span class="keyword">by</span> cid <span class="keyword">having</span> <span class="built_in">avg</span>(price)<span class="operator">&gt;</span><span class="number">60</span>;</code></pre><h4 id="分页查询"><a class="markdownIt-Anchor" href="#分页查询"></a> 分页查询</h4><p>LIMIT关键字不是SQL92标准提出的关键字，它是<strong>MySQL独有</strong>的语法。</p><p>通过Limit关键字，MySQL实现了<strong>物理分页</strong>。</p><p>分页分为逻辑分页和物理分页</p><ul><li>逻辑分页：将数据库中的数据查询到内存之后再进行分页。</li><li>物理分页：通过LIMIT关键字，直接在数据库中进行分页，最终返回的数据，只是分页后的数据。</li></ul><p>语法：</p><ul><li>offset：偏移量</li><li>rows：每页多少行记录</li></ul><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> LIMIT [<span class="keyword">offset</span>,] <span class="keyword">rows</span></code></pre><p>显示前五条数据：</p><pre><code class="highlight sql"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> hero limit <span class="number">0</span>,<span class="number">5</span></code></pre><h4 id="其他语句"><a class="markdownIt-Anchor" href="#其他语句"></a> 其他语句</h4><p>union 集合的并集（不包含重复记录）</p><p>unionall集合的并集（包含重复记录）</p><h4 id="语法顺序和执行顺序重要"><a class="markdownIt-Anchor" href="#语法顺序和执行顺序重要"></a> 语法顺序和执行顺序（重要）</h4><p><strong>MySQL查询语法顺序</strong></p><ol><li>SELECT</li><li>FROM</li><li>LEFT JOIN</li><li>ON</li><li>WHERE</li><li>GROUP BY</li><li>HAVING</li><li>ORDER BY</li><li>LIMIT</li></ol><p>示例：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">order</span> <span class="keyword">ON</span> user.id <span class="operator">=</span> order.uid <span class="keyword">WHERE</span> order.price <span class="operator">&gt;</span> <span class="number">1000</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> user.name <span class="keyword">HAVING</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="operator">&gt;</span> <span class="number">5</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> user.name LIMIT <span class="number">0</span>,<span class="number">10</span></code></pre><p><strong>执行顺序</strong>（VT-virtual table表示虚拟表）：</p><ol><li>FROM（将最近的两张表，进行笛卡尔积）—VT1</li><li>ON（将VT1按照它的条件进行过滤）—VT2</li><li>LEFT JOIN（保留左表的记录）—VT3</li><li>WHERE（过滤VT3中的记录,每次过滤都会生成一张虚拟表）–VT4…VTn</li><li>GROUP BY（对VT4的记录进行分组）—VT5</li><li>HAVING（对VT5中的记录进行过滤）—VT6</li><li>SELECT（对VT6中的记录，选取指定的列）–VT7</li><li>ORDER BY（对VT7的记录进行排序）–游标</li><li>LIMIT（对排序之后的值进行分页）</li></ol><p>where条件执行顺序（影响性能）</p><ol><li>MYSQL：从左往右去执行WHERE条件的。</li><li>Oracle：从右往左去执行WHERE条件的。</li></ol><p><strong>结论</strong>：写WHERE条件的时候，优先级高的部分要去编写过滤力度最大的条件语句</p><h3 id="用户操作"><a class="markdownIt-Anchor" href="#用户操作"></a> 用户操作</h3><h4 id="创建用户"><a class="markdownIt-Anchor" href="#创建用户"></a> 创建用户</h4><p>语法说明如下：</p><ol><li>&lt;用户名&gt;<br />指定创建用户账号，格式为 ‘user_name’@‘host_name’。这里user_name是用户名，host_name为主机名，即用户连接 MySQL 时所在主机的名字。若在创建的过程中，只给出了账户的用户名，而没指定主机名，则主机名默认为“%”，表示一组主机。</li><li>PASSWORD<br />可选项，用于指定散列口令，即若使用明文设置口令，则需忽略PASSWORD关键字；若不想以明文设置口令，且知道 PASSWORD() 函数返回给密码的散列值，则可以在口令设置语句中指定此散列值，但需要加上关键字PASSWORD。</li><li>IDENTIFIED BY子句<br />用于指定用户账号对应的口令，若该用户账号无口令，则可省略此子句。</li><li>&lt;口令&gt;<br />指定用户账号的口令，在IDENTIFIED BY关键字或PASSWOED关键字之后。给定的口令值可以是只由字母和数字组成的明文，也可以是通过 PASSWORD() 函数得到的散列值。</li></ol><pre><code class="highlight sql"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="operator">&lt;</span>用户名<span class="operator">&gt;</span> [ IDENTIFIED ] <span class="keyword">BY</span> [ PASSWORD ] <span class="operator">&lt;</span>口令<span class="operator">&gt;</span></code></pre><p>使用 CREATE USER 语句应该注意以下几点：</p><ul><li>如果使用 CREATE USER 语句时没有为用户指定口令，那么 MySQL 允许该用户可以不使用口令登录系统，然而从安全的角度而言，不推荐这种做法。</li><li>使用 CREATE USER 语句必须拥有 MySQL 中 MySQL 数据库的 INSERT 权限或全局 CREATE USER 权限。</li><li>使用 CREATE USER 语句创建一个用户账号后，会在系统自身的 MySQL 数据库的 user 表中添加一条新记录。若创建的账户已经存在，则语句执行时会出现错误。</li><li>新创建的用户拥有的权限很少。他们可以登录 MySQL，只允许进行不需要权限的操作，如使用 SHOW 语句查询所有存储引擎和字符集的列表等。</li><li>如果两个用户具有相同的用户名和不同的主机名，MySQL 会将他们视为不同的用户，并允许为这两个用户分配不同的权限集合</li></ul><p>案例：</p><pre><code class="highlight sql"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;admin&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</code></pre><h4 id="修改用户"><a class="markdownIt-Anchor" href="#修改用户"></a> 修改用户</h4><p><strong>修改用户</strong></p><p>语法格式：</p><ul><li>&lt;旧用户&gt;：系统中已经存在的 MySQL 用户账号。</li><li>&lt;新用户&gt;：新的 MySQL 用户账号。</li></ul><pre><code class="highlight sql">RENAME <span class="keyword">USER</span> <span class="operator">&lt;</span>旧用户<span class="operator">&gt;</span> <span class="keyword">TO</span> <span class="operator">&lt;</span>新用户<span class="operator">&gt;</span></code></pre><p>使用 RENAME USER 语句时应该注意以下几点：</p><ul><li>RENAME USER 语句用于对原有的 MySQL 账户进行重命名。</li><li>若系统中旧账户不存在或者新账户已存在，则该语句执行时会出现错误。</li><li>要使用 RENAME USER 语句，必须拥有 MySQL 中的 MySQL 数据库的 UPDATE 权限或全局 CREATE USER 权限</li></ul><pre><code class="highlight sql">RENAME <span class="keyword">USER</span> james@<span class="string">&#x27;localhost&#x27;</span> <span class="keyword">TO</span> jack@<span class="string">&#x27;localhost&#x27;</span>;</code></pre><hr /><p><strong>修改用户口令</strong></p><ul><li>FOR 子句：可选项。指定欲修改口令的用户。</li><li>PASSWORD(‘新明文口令’)：表示使用函数 PASSWORD() 设置新口令，即新口令必须传递到函数 PASSWORD() 中进行加密。</li><li>加密口令值：表示已被函数 PASSWORD() 加密的口令值。</li></ul><blockquote><p>注意：PASSWORD() 函数为单向加密函数，一旦加密后不能解密出原明文。</p></blockquote><pre><code class="highlight sql"><span class="keyword">SET</span> PASSWORD [ <span class="keyword">FOR</span> <span class="operator">&lt;</span>用户名<span class="operator">&gt;</span> ] <span class="operator">=</span>&#123;    PASSWORD(<span class="string">&#x27;新明文口令&#x27;</span>)    <span class="operator">|</span> OLD_PASSWORD(<span class="string">&#x27;旧明文口令&#x27;</span>)    <span class="operator">|</span> <span class="string">&#x27;加密口令值&#x27;</span>&#125;</code></pre><p>使用 SET PASSWORD 语句应注意以下几点：</p><ul><li>在 SET PASSWORD 语句中，若不加上 FOR 子句，表示修改当前用户的口令。若加上 FOR 子句，表示修改账户为 user 的用户口令。</li><li>user 必须以 ‘user_name’@‘host_name’ 的格式给定，user_name 为账户的用户名，host_name 为账户的主机名。</li><li>该账户必须在系统中存在，否则语句执行时会出现错误。</li><li>在 SET PASSWORD 语句中，只能使用选项 PASSWORD(‘新明文口令’) 和加密口令值中的一项，且必须使用其中的一项。</li></ul><p>案例：</p><pre><code class="highlight sql"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> <span class="string">&#x27;jack&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span><span class="operator">=</span>PASSWORD(<span class="string">&#x27;lion&#x27;</span>);</code></pre><h4 id="删除用户"><a class="markdownIt-Anchor" href="#删除用户"></a> 删除用户</h4><p>使用 DROP USER 语句应该注意以下几点：</p><ul><li>DROP USER 语句可用于删除一个或多个 MySQL 账户，并撤销其原有权限。</li><li>使用 DROP USER 语句必须拥有 MySQL 中的 MySQL 数据库的 DELETE 权限或全局 CREATE USER 权限。</li><li>在 DROP USER 语句的使用中，若没有明确地给出账户的主机名，则该主机名默认为“%”。</li></ul><blockquote><p>注意：用户的删除不会影响他们之前所创建的表、索引或其他数据库对象，因为 MySQL 并不会记录是谁创建了这些对象。</p></blockquote><pre><code class="highlight sql"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="operator">&lt;</span>用户名<span class="number">1</span><span class="operator">&gt;</span> [ , <span class="operator">&lt;</span>用户名<span class="number">2</span><span class="operator">&gt;</span> ]…</code></pre><p>案例：</p><pre><code class="highlight sql"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;jack&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</code></pre><h4 id="用户授权"><a class="markdownIt-Anchor" href="#用户授权"></a> 用户授权</h4><p><strong>权限查看</strong><br />当成功创建用户账户后，还不能执行任何操作，需要为该用户分配适当的访问权限。可以使用下列语句来查询用户的权限。</p><pre><code class="highlight sql"><span class="keyword">SHOW</span> <span class="keyword">GRANT</span> <span class="keyword">FOR</span></code></pre><blockquote><p>注意：新创建的用户只有登录 MySQL 服务器的权限，没有任何其他权限，不能进行其他操作。</p></blockquote><hr /><p><strong>用户授权</strong></p><pre><code class="highlight sql"><span class="keyword">GRANT</span><span class="operator">&lt;</span>权限类型<span class="operator">&gt;</span> [ ( <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> ) ] [ , <span class="operator">&lt;</span>权限类型<span class="operator">&gt;</span> [ ( <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> ) ] ]<span class="keyword">ON</span> <span class="operator">&lt;</span>对象<span class="operator">&gt;</span> <span class="operator">&lt;</span>权限级别<span class="operator">&gt;</span> <span class="keyword">TO</span> <span class="operator">&lt;</span>用户<span class="operator">&gt;</span>其中<span class="operator">&lt;</span>用户<span class="operator">&gt;</span>的格式：<span class="operator">&lt;</span>用户名<span class="operator">&gt;</span> [ IDENTIFIED ] <span class="keyword">BY</span> [ PASSWORD ] <span class="operator">&lt;</span>口令<span class="operator">&gt;</span>[ <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION]<span class="operator">|</span> MAX_QUERIES_PER_HOUR <span class="operator">&lt;</span>次数<span class="operator">&gt;</span><span class="operator">|</span> MAX_UPDATES_PER_HOUR <span class="operator">&lt;</span>次数<span class="operator">&gt;</span><span class="operator">|</span> MAX_CONNECTIONS_PER_HOUR <span class="operator">&lt;</span>次数<span class="operator">&gt;</span><span class="operator">|</span> MAX_USER_CONNECTIONS <span class="operator">&lt;</span>次数<span class="operator">&gt;</span></code></pre><ul><li>&lt;列名&gt;：可选项。用于指定权限要授予给表中哪些具体的列。</li><li>ON 子句：用于指定权限授予的对象和级别，如在 ON 关键字后面给出要授予权限的数据库名或表名等。</li><li>&lt;权限级别&gt;：用于指定权限的级别。可以授予的权限有如下几组：<ul><li>列权限，和表中的一个具体列相关。例如，可以使用 UPDATE 语句更新表 students 中 student_name 列的值的权限。</li><li>表权限，和一个具体表中的所有数据相关。例如，可以使用 SELECT 语句查询表 students 的所有数据的权限。</li><li>数据库权限，和一个具体的数据库中的所有表相关。例如，可以在已有的数据库 mytest 中创建新表的权限。</li><li>用户权限，和 MySQL 中所有的数据库相关。例如，可以删除已有的数据库或者创建一个新的数据库的权限。</li></ul></li></ul><p>对应地，在 GRANT 语句中可用于指定<strong>权限级别</strong>的值有以下几类格式：</p><ul><li>*：表示当前数据库中的所有表。</li><li>*.*：表示所有数据库中的所有表。</li><li>db_name.*：表示某个数据库中的所有表，db_name 指定数据库名。</li><li>db_name.tbl_name：表示某个数据库中的某个表或视图，db_name 指定数据库名，tbl_name 指定表名或视图名。</li><li>tbl_name：表示某个表或视图，tbl_name 指定表名或视图名。</li><li>db_name.routine_name：表示某个数据库中的某个存储过程或函数，routine_name 指定存储过程名或函数名。</li><li>TO 子句：用来设定用户口令，以及指定被赋予权限的用户 user。若在 TO 子句中给系统中存在的用户指定口令，则新密码会将原密码覆盖；如果权限被授予给一个不存在的用户，MySQL 会自动执行一条 CREATE USER 语句来创建这个用户，但同时必须为该用户指定口令。</li></ul><p>GRANT语句中的&lt;<strong>权限类型</strong>&gt;的使用说明如下：</p><p>1.授予数据库权限时，&lt;权限类型&gt;可以指定为以下值：</p><ul><li>SELECT：表示授予用户可以使用 SELECT 语句访问特定数据库中所有表和视图的权限。</li><li>INSERT：表示授予用户可以使用 INSERT 语句向特定数据库中所有表添加数据行的权限。</li><li>DELETE：表示授予用户可以使用 DELETE 语句删除特定数据库中所有表的数据行的权限。</li><li>UPDATE：表示授予用户可以使用 UPDATE 语句更新特定数据库中所有数据表的值的权限。</li><li>REFERENCES：表示授予用户可以创建指向特定的数据库中的表外键的权限。</li><li>CREATE：表示授权用户可以使用 CREATE TABLE 语句在特定数据库中创建新表的权限。</li><li>ALTER：表示授予用户可以使用 ALTER TABLE 语句修改特定数据库中所有数据表的权限。</li><li>SHOW VIEW：表示授予用户可以查看特定数据库中已有视图的视图定义的权限。</li><li>CREATE ROUTINE：表示授予用户可以为特定的数据库创建存储过程和存储函数的权限。</li><li>ALTER ROUTINE：表示授予用户可以更新和删除数据库中已有的存储过程和存储函数的权限。</li><li>INDEX：表示授予用户可以在特定数据库中的所有数据表上定义和删除索引的权限。</li><li>DROP：表示授予用户可以删除特定数据库中所有表和视图的权限。</li><li>CREATE TEMPORARY TABLES：表示授予用户可以在特定数据库中创建临时表的权限。</li><li>CREATE VIEW：表示授予用户可以在特定数据库中创建新的视图的权限。</li><li>EXECUTE ROUTINE：表示授予用户可以调用特定数据库的存储过程和存储函数的权限。</li><li>LOCK TABLES：表示授予用户可以锁定特定数据库的已有数据表的权限。</li><li>ALL 或 ALL PRIVILEGES：表示以上所有权限。</li></ul><p>2.授予表权限时，&lt;权限类型&gt;可以指定为以下值：</p><ul><li>SELECT：授予用户可以使用 SELECT 语句进行访问特定表的权限。</li><li>INSERT：授予用户可以使用 INSERT 语句向一个特定表中添加数据行的权限。</li><li>DELETE：授予用户可以使用 DELETE 语句从一个特定表中删除数据行的权限。</li><li>DROP：授予用户可以删除数据表的权限。UPDATE：授予用户可以使用</li><li>UPDATE 语句更新特定数据表的权限。</li><li>ALTER：授予用户可以使用 ALTER TABLE 语句修改数据表的权限。</li><li>REFERENCES：授予用户可以创建一个外键来参照特定数据表的权限。</li><li>CREATE：授予用户可以使用特定的名字创建一个数据表的权限。</li><li>INDEX：授予用户可以在表上定义索引的权限。</li><li>ALL 或 ALL PRIVILEGES：所有的权限名。</li></ul><p>3.授予列权限时，&lt;权限类型&gt;的值只能指定为 SELECT、INSERT 和 UPDATE，同时权限的后面需要加上列名列表 column-list。</p><p>4.最有效率的权限是用户权限。</p><p>授予用户权限时，&lt;权限类型&gt;除了可以指定为授予数据库权限时的所有值之外，还可以是下面这些值：</p><ul><li>CREATE USER：表示授予用户可以创建和删除新用户的权限。</li><li>SHOW DATABASES：表示授予用户可以使用 SHOW DATABASES 语句查看所有已有的数据库的定义的权限。</li></ul><p><strong>案例：</strong></p><pre><code class="highlight sql"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;testUser&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;testPwd&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;<span class="comment">--使用 SELECT 语句查询用户 testUser 的权限，如下所示。</span><span class="keyword">SELECT</span> Host,<span class="keyword">User</span>,Select_priv,Grant_priv <span class="keyword">FROM</span> mysql.user <span class="keyword">WHERE</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">&#x27;testUser&#x27;</span>;</code></pre><h4 id="删除用户授权"><a class="markdownIt-Anchor" href="#删除用户授权"></a> 删除用户授权</h4><p>第一种方式：</p><pre><code class="highlight sql"><span class="keyword">REVOKE</span> <span class="operator">&lt;</span>权限类型<span class="operator">&gt;</span> [ ( <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> ) ] [ , <span class="operator">&lt;</span>权限类型<span class="operator">&gt;</span> [ ( <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> ) ] ]…<span class="keyword">ON</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span> <span class="operator">&lt;</span>权限名<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>用户<span class="number">1</span><span class="operator">&gt;</span> [ , <span class="operator">&lt;</span>用户<span class="number">2</span><span class="operator">&gt;</span> ]…</code></pre><p>第二种方式：</p><pre><code class="highlight sql"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES, <span class="keyword">GRANT</span> OPTION<span class="keyword">FROM</span> <span class="keyword">user</span> <span class="operator">&lt;</span>用户<span class="number">1</span><span class="operator">&gt;</span> [ , <span class="operator">&lt;</span>用户<span class="number">2</span><span class="operator">&gt;</span> ]…</code></pre><p>语法说明如下：</p><ul><li>REVOKE 语法和 GRANT 语句的语法格式相似，但具有相反的效果。</li><li>第一种语法格式用于回收某些特定的权限。</li><li>第二种语法格式用于回收特定用户的所有权限。</li><li>要使用 REVOKE 语句，必须拥有 MySQL 数据库的全局 CREATE USER 权限或 UPDATE 权限。</li></ul><p>案例：</p><pre><code class="highlight sql"><span class="keyword">REVOKE</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;testUser&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</code></pre><h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h3><h4 id="case"><a class="markdownIt-Anchor" href="#case"></a> case</h4><p>CASE 表示函数开始，END 表示函数结束。如果 condition1 成立，则返回 result1, 如果 condition2 成立，则返回 result2，当全部不成立则返回 result，而当有一个成立之后，后面的就不执行了</p><pre><code class="highlight sql"><span class="keyword">CASE</span> expression    <span class="keyword">WHEN</span> condition1 <span class="keyword">THEN</span> result1    <span class="keyword">WHEN</span> condition2 <span class="keyword">THEN</span> result2   ...    <span class="keyword">WHEN</span> conditionN <span class="keyword">THEN</span> resultN    <span class="keyword">ELSE</span> <span class="keyword">result</span><span class="keyword">END</span></code></pre><p>示例：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span>&quot;name&quot;,        <span class="keyword">CASE</span>            <span class="keyword">WHEN</span> &quot;age&quot; <span class="operator">&gt;</span> <span class="number">15</span> <span class="keyword">THEN</span>            <span class="string">&#x27;15&#x27;</span>             <span class="keyword">WHEN</span> &quot;age&quot; <span class="operator">&lt;</span> <span class="number">10</span> <span class="keyword">THEN</span>            <span class="string">&#x27;10&#x27;</span> <span class="keyword">ELSE</span> <span class="string">&#x27;0&#x27;</span>         <span class="keyword">END</span> <span class="keyword">FROM</span>LBTEST.&quot;student&quot;</code></pre><h4 id="if"><a class="markdownIt-Anchor" href="#if"></a> if</h4><p>如果表达式 expr 成立，返回结果 v1；否则，返回结果 v2。</p><pre><code class="highlight sql">IF(expr,v1,v2)</code></pre><p>示例：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> IF(<span class="number">1</span> <span class="operator">&gt;</span> <span class="number">0</span>,<span class="string">&#x27;正确&#x27;</span>,<span class="string">&#x27;错误&#x27;</span>)</code></pre><h4 id="ifnull"><a class="markdownIt-Anchor" href="#ifnull"></a> ifnull</h4><p>如果 v1 的值不为 NULL，则返回 v1，否则返回 v2。</p><pre><code class="highlight sql">IFNULL(v1,v2)</code></pre><p>示例：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> IFNULL(<span class="keyword">null</span>,<span class="string">&#x27;Hello Word&#x27;</span>)</code></pre><h4 id="isnull"><a class="markdownIt-Anchor" href="#isnull"></a> isnull</h4><p>判断表达式是否为 NULL</p><pre><code class="highlight sql">ISNULL(expression)</code></pre><p>示例：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> ISNULL(<span class="keyword">NULL</span>);</code></pre><h3 id="存储过程"><a class="markdownIt-Anchor" href="#存储过程"></a> 存储过程</h3><h4 id="循环"><a class="markdownIt-Anchor" href="#循环"></a> 循环</h4><p><strong>while</strong></p><pre><code class="highlight sql"><span class="comment">-- 设置mysql分隔符为//，也就意味着，当遇到下一个//时，整体执行SQL语句</span>DELIMITER <span class="operator">/</span><span class="operator">/</span> <span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> if <span class="keyword">EXISTS</span> ‘test’;    # 如果存在test存储过程则删除<span class="keyword">CREATE</span> <span class="keyword">procedure</span> test() # 创建无参存储过程，名称为test<span class="keyword">BEGIN</span><span class="keyword">DECLARE</span> i <span class="type">INT</span>;  # 申明变量<span class="keyword">SET</span> i <span class="operator">=</span> <span class="number">0</span>;  # 变量赋值WHILE i<span class="operator">&lt;</span><span class="number">5</span> DO # 结束循环的条件: 当i大于<span class="number">5</span>时跳出while循环<span class="keyword">INSERT INTO</span> test <span class="keyword">VALUES</span>(i<span class="operator">+</span><span class="number">11</span>,<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;20&#x27;</span>);  # 往test表添加数据<span class="keyword">SET</span> i <span class="operator">=</span> i<span class="operator">+</span><span class="number">1</span>;    # 循环一次,i加<span class="number">1</span><span class="keyword">END</span> WHILE;  # 结束while循环<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test; # 查看test表数据<span class="keyword">END</span><span class="operator">/</span><span class="operator">/</span>  # 结束定义语句<span class="keyword">CALL</span> test();    # 调用存储过程DELIMITER ; # 重新将分隔符设置为;</code></pre><p><strong>loop</strong></p><pre><code class="highlight sql">DELIMITER <span class="operator">/</span><span class="operator">/</span><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> IF <span class="keyword">EXISTS</span> test;<span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test()<span class="keyword">BEGIN</span>  <span class="keyword">DECLARE</span> i <span class="type">INT</span>;  <span class="keyword">SET</span> i <span class="operator">=</span> <span class="number">0</span>;    lp : LOOP                               　　　　# lp为循环体名,可随意 loop为关键字        <span class="keyword">INSERT INTO</span> test <span class="keyword">VALUES</span>(i<span class="operator">+</span><span class="number">11</span>,<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;20&#x27;</span>);　　　# 往test表添加数据        <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;                      　　　　# 循环一次,i加一        IF i <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">THEN</span>                   　　　　# 结束循环的条件: 当i大于<span class="number">10</span>时跳出loop循环                    LEAVE lp;            <span class="keyword">END</span> IF;    <span class="keyword">END</span> LOOP;    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test;<span class="keyword">END</span><span class="operator">/</span><span class="operator">/</span><span class="keyword">CALL</span> test();DELIMITER ;</code></pre><p><strong>repeat</strong></p><pre><code class="highlight sql">DELIMITER <span class="operator">/</span><span class="operator">/</span><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> IF <span class="keyword">EXISTS</span> test;<span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test()<span class="keyword">BEGIN</span>  <span class="keyword">DECLARE</span> i <span class="type">INT</span>;  <span class="keyword">SET</span> i <span class="operator">=</span> <span class="number">0</span>;  REPEAT    <span class="keyword">INSERT INTO</span> test <span class="keyword">VALUES</span>(i<span class="operator">+</span><span class="number">11</span>,<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;20&#x27;</span>);  　　　　　　　　　# 往test表添加数据    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;                              　　　　# 循环一次,i加一  UNTIL i <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">END</span> REPEAT;                       　　　　# 结束循环的条件: 当i大于<span class="number">10</span>时跳出repeat循环  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test;<span class="keyword">END</span><span class="operator">/</span><span class="operator">/</span><span class="keyword">CALL</span> test();DELIMITER ;</code></pre><h4 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例</h4><pre><code class="highlight sql">delimiter $$<span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> sdm_update_random; <span class="keyword">create</span> <span class="keyword">procedure</span> sdm_update_random()<span class="keyword">begin</span><span class="keyword">declare</span> icount <span class="type">int</span>;<span class="keyword">declare</span> i <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;<span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">into</span> icount <span class="keyword">from</span> t_sdm_extract_task;while i <span class="operator">&lt;</span> icount do <span class="keyword">select</span> extract_task_id,random_flag,random_seed <span class="keyword">into</span> <span class="variable">@taskId</span>,<span class="variable">@randomFlag</span>,<span class="variable">@randomSeed</span> <span class="keyword">from</span> t_sdm_extract_task limit i,<span class="number">1</span>;<span class="keyword">update</span> t_sdm_extract_monitor <span class="keyword">set</span> random_flag<span class="operator">=</span><span class="variable">@randomFlag</span>,random_seed<span class="operator">=</span><span class="variable">@randomSeed</span> <span class="keyword">where</span> extract_task_id<span class="operator">=</span><span class="variable">@taskId</span>;<span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;<span class="keyword">end</span> while; <span class="keyword">set</span> i<span class="operator">=</span><span class="number">0</span>;<span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">into</span> icount <span class="keyword">from</span> t_sdm_masking_task;    while i <span class="operator">&lt;</span> icount do <span class="keyword">select</span> masking_task_id,random_flag,random_seed <span class="keyword">into</span> <span class="variable">@taskId</span>,<span class="variable">@randomFlag</span>,<span class="variable">@randomSeed</span> <span class="keyword">from</span> t_sdm_masking_task limit i,<span class="number">1</span>;<span class="keyword">update</span> t_sdm_masking_monitor <span class="keyword">set</span> random_flag<span class="operator">=</span><span class="variable">@randomFlag</span>,random_seed<span class="operator">=</span><span class="variable">@randomSeed</span> <span class="keyword">where</span> masking_task_id<span class="operator">=</span><span class="variable">@taskId</span>;<span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;<span class="keyword">end</span> while;                      <span class="keyword">end</span>$$delimiter;<span class="keyword">call</span> sdm_update_random();</code></pre><h2 id="多表之间的关系"><a class="markdownIt-Anchor" href="#多表之间的关系"></a> 多表之间的关系</h2><p>如上图所示，实际业务数据库中的表之间都是有关系的，我们接下来主要要学习的就是如何分析表关系及建立表关系</p><pre><code class="highlight sql"><span class="number">1.</span>分类表<span class="keyword">create table</span> category(cid <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">primary key</span>,cname <span class="type">varchar</span>(<span class="number">100</span>));<span class="number">2.</span>商品表<span class="keyword">create table</span> product(pid <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">primary key</span>,pname <span class="type">varchar</span>(<span class="number">40</span>),price <span class="keyword">double</span>);<span class="number">3.</span>订单表<span class="keyword">create table</span> orders(oid <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">primary key</span>,totalprice <span class="keyword">double</span>);<span class="number">4.</span>订单项表<span class="keyword">create table</span> orderitem(oid <span class="type">varchar</span>(<span class="number">50</span>),pid <span class="type">varchar</span>(<span class="number">50</span>));</code></pre><h3 id="表与表之间的关系"><a class="markdownIt-Anchor" href="#表与表之间的关系"></a> 表与表之间的关系</h3><p><strong>表与表之间的关系，说的就是表与表之间数据的关系</strong>。<br />一对一关系</p><ul><li>常见实例：一夫一妻</li></ul><p>一对多关系</p><ul><li>常见实例：会员和订单</li></ul><p>多对多关系（需要中间表实现）</p><ul><li>常见实例：商品和订单</li></ul><h3 id="外键"><a class="markdownIt-Anchor" href="#外键"></a> 外键</h3><p>主表添加外键的格式：</p><pre><code class="highlight sql"><span class="keyword">alter table</span> 表名 <span class="keyword">add</span> [<span class="keyword">constraint</span>][约束名称] <span class="keyword">foreign key</span> (主表外键字段) <span class="keyword">references</span> 从表(从表主键)</code></pre><p>主表删除外键的格式：</p><pre><code class="highlight sql"><span class="keyword">alter table</span> 表名 <span class="keyword">drop</span> <span class="keyword">foreign key</span> 外键约束名称</code></pre><p>使用外键目的：</p><ul><li>保证数据完整性（数据保存在多张表中的时候）</li><li>在互联网项目中，一般情况下，<strong>不建议建立外键关系</strong>。</li></ul><h3 id="一对一关系"><a class="markdownIt-Anchor" href="#一对一关系"></a> 一对一关系</h3><p>在实际工作中，一对一在开发中应用不多，因为一对一完全可以创建成一张表</p><p>案例：一个丈夫只能有一个妻子</p><pre><code class="highlight sql"><span class="keyword">CREATE TABLE</span> wife(id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> ,wname<span class="type">VARCHAR</span>(<span class="number">20</span>),sex<span class="type">CHAR</span>(<span class="number">1</span>));<span class="keyword">CREATE TABLE</span> husband(id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> ,hname<span class="type">VARCHAR</span>(<span class="number">20</span>),sex<span class="type">CHAR</span>(<span class="number">1</span>));</code></pre><p>一对一关系创建方式1之外键唯一：</p><ul><li>添加外键列wid，指定该列的约束为唯一（不加唯一约束就是一对多关系）</li></ul><pre><code class="highlight sql"><span class="keyword">ALTER TABLE</span> husband <span class="keyword">ADD</span> wid <span class="type">INT</span> <span class="keyword">UNIQUE</span>;</code></pre><ul><li>添加外键约束</li></ul><pre><code class="highlight sql"><span class="keyword">alter table</span> husband <span class="keyword">add</span> <span class="keyword">foreign key</span> (wid) <span class="keyword">references</span> wife(id);</code></pre><h3 id="一对多关系"><a class="markdownIt-Anchor" href="#一对多关系"></a> 一对多关系</h3><p>案例：一个分类对应多个商品</p><p>注意事项：</p><ul><li>一对多关系和一对一关系的创建很类似，唯一区别就是外键不唯一</li></ul><p>一对多关系创建：</p><ul><li>添加外键列</li><li>添加外键约束</li></ul><h3 id="多对多关系"><a class="markdownIt-Anchor" href="#多对多关系"></a> 多对多关系</h3><p>案例：同一个商品对应多个订单，一个订单对应多个商品</p><p>注意事项：</p><ul><li><p>需要中间表去完成多对多关系的创建</p></li><li><p>多对多关系其实就是两个一对多关系的组合</p></li></ul><p>多对多关系创建：</p><ul><li>创建中间表，并在其中创建多对多关系中两张表的外键列</li><li>在中间表中添加外键约束</li><li>在中间表中添加联合主键约束</li></ul><h2 id="多表关联查询"><a class="markdownIt-Anchor" href="#多表关联查询"></a> 多表关联查询</h2><p>可以在 <code>SELECT</code>, <code>UPDATE</code> 和 <code>DELETE</code> 语句中使用 MySQL 的 <strong>JOIN</strong> 来联合多表查询</p><p>JOIN 按照<strong>功能</strong>大致分为如下三类：</p><ul><li><code>CROSS JOIN</code>（交叉连接）</li><li><code>INNER JOIN</code>（内连接或等值连接）。</li><li><code>OUTER JOIN</code>（外连接）</li></ul><h3 id="前置条件"><a class="markdownIt-Anchor" href="#前置条件"></a> 前置条件</h3><pre><code class="highlight sql"><span class="keyword">insert into</span> category (cid,cname) <span class="keyword">values</span> (<span class="string">&#x27;c001&#x27;</span>,<span class="string">&#x27;家电&#x27;</span>);<span class="keyword">insert into</span> category (cid,cname) <span class="keyword">values</span> (<span class="string">&#x27;c002&#x27;</span>,<span class="string">&#x27;服饰&#x27;</span>);<span class="keyword">insert into</span> category (cid,cname) <span class="keyword">values</span> (<span class="string">&#x27;c003&#x27;</span>,<span class="string">&#x27;化妆品&#x27;</span>);<span class="keyword">insert into</span> product(pid,pname,price,cid) <span class="keyword">values</span> (<span class="string">&#x27;p001&#x27;</span>,<span class="string">&#x27;联想&#x27;</span>,<span class="number">5000</span>,<span class="string">&#x27;c001&#x27;</span>);<span class="keyword">insert into</span> product(pid,pname,price,cid) <span class="keyword">values</span> (<span class="string">&#x27;p002&#x27;</span>,<span class="string">&#x27;海尔&#x27;</span>,<span class="number">3000</span>,<span class="string">&#x27;c001&#x27;</span>);<span class="keyword">insert into</span> product(pid,pname,price,cid) <span class="keyword">values</span> (<span class="string">&#x27;p003&#x27;</span>,<span class="string">&#x27;雷神&#x27;</span>,<span class="number">5000</span>,<span class="string">&#x27;c001&#x27;</span>);<span class="keyword">insert into</span> product(pid,pname,price,cid) <span class="keyword">values</span> (<span class="string">&#x27;p004&#x27;</span>,<span class="string">&#x27;阿迪&#x27;</span>,<span class="number">1000</span>,<span class="string">&#x27;c002&#x27;</span>);<span class="keyword">insert into</span> product(pid,pname,price,cid) <span class="keyword">values</span> (<span class="string">&#x27;p005&#x27;</span>,<span class="string">&#x27;耐克&#x27;</span>,<span class="number">1200</span>,<span class="string">&#x27;c002&#x27;</span>);<span class="keyword">insert into</span> product(pid,pname,price,cid) <span class="keyword">values</span> (<span class="string">&#x27;p006&#x27;</span>,<span class="string">&#x27;NB&#x27;</span>,<span class="number">800</span>,<span class="string">&#x27;c002&#x27;</span>);<span class="keyword">insert into</span> product(pid,pname,price,cid) <span class="keyword">values</span> (<span class="string">&#x27;p007&#x27;</span>,<span class="string">&#x27;彪马&#x27;</span>,<span class="number">600</span>,<span class="string">&#x27;c002&#x27;</span>);<span class="keyword">insert into</span> product(pid,pname,price,cid) <span class="keyword">values</span> (<span class="string">&#x27;p008&#x27;</span>,<span class="string">&#x27;雪花秀&#x27;</span>,<span class="number">1500</span>,<span class="string">&#x27;c003&#x27;</span>);<span class="keyword">insert into</span> product(pid,pname,price,cid) <span class="keyword">values</span> (<span class="string">&#x27;p009&#x27;</span>,<span class="string">&#x27;悦诗风吟&#x27;</span>,<span class="number">1100</span>,<span class="string">&#x27;c003&#x27;</span>);</code></pre><h3 id="交叉连接"><a class="markdownIt-Anchor" href="#交叉连接"></a> 交叉连接</h3><p>交叉连接的关键字：<strong>CROSS JOIN</strong></p><p><em>交叉连接也叫笛卡尔积连接</em></p><ul><li>笛卡尔积是指在数学中，两个集合X和Y的笛卡尓积（Cartesian product），又称直积，表示为X×Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员</li></ul><blockquote><p>行数相乘，列数相加</p></blockquote><p>隐式交叉连接</p><pre><code class="highlight sql"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a,b</code></pre><p>显式交叉连接</p><pre><code class="highlight sql"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">cross</span> <span class="keyword">join</span> b</code></pre><p>案例：查询商品表和分类表的笛卡尔积。</p><h3 id="内连接"><a class="markdownIt-Anchor" href="#内连接"></a> 内连接</h3><p>内连接的关键字：<strong>INNER JOIN</strong></p><p>内连接也叫等值连接，内联接使用比较运算符根据每个表共有的列的值匹配两个表中的行</p><p>隐式内连接</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A,B <span class="keyword">WHERE</span> A.id <span class="operator">=</span> B.id</code></pre><p>显式内连接</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id <span class="operator">=</span> B.id</code></pre><h3 id="外连接"><a class="markdownIt-Anchor" href="#外连接"></a> 外连接</h3><p>也就是说外连接又分为：<strong>左外连接、右外连接、全外连接</strong></p><blockquote><p>如果使用LEFT JOIN，则主表在它左边</p></blockquote><blockquote><p>如果使用RIGHT JOIN，则主表在它右边</p></blockquote><blockquote><p>查询结果以主表为主，从表记录匹配不到，则补null</p></blockquote><p><strong>左外连接</strong>：<code>LEFT JOIN</code> 或者 <code>LEFT OUTER JOIN</code></p><pre><code class="highlight sql"><span class="keyword">SELECT</span>  <span class="operator">*</span>  <span class="keyword">FROM</span>  A  <span class="keyword">LEFT</span>  <span class="keyword">JOIN</span>  B <span class="keyword">ON</span> A.id <span class="operator">=</span> B.id</code></pre><blockquote><p>多个连续的left join连接，a left join b on 条件1 left join c on 条件2 执行顺序是：先a和b进行连接，生成一张中间表d，然后再和c进行条件连接生成最后的表的数据</p></blockquote><p><strong>右外连接</strong>:：<code>RIGHT JOIN</code> 或者 <code>RIGHT OUTER JOIN</code></p><pre><code class="highlight sql"><span class="keyword">SELECT</span>  <span class="operator">*</span>  <span class="keyword">FROM</span>  A  <span class="keyword">RIGHT</span>  <span class="keyword">JOIN</span>  B <span class="keyword">ON</span> A.id <span class="operator">=</span> B.id</code></pre><p><strong>全外连接</strong>（MySQL不支持）：<code>FULL  JOIN 或 FULL OUTER JOIN</code></p><pre><code class="highlight sql"><span class="keyword">SELECT</span>  <span class="operator">*</span>  <span class="keyword">FROM</span>  A  <span class="keyword">FULL</span> <span class="keyword">JOIN</span>  B <span class="keyword">ON</span> A.id <span class="operator">=</span> B.id</code></pre><h3 id="子查询"><a class="markdownIt-Anchor" href="#子查询"></a> 子查询</h3><p>子查询允许<strong>把一个查询嵌套在另一个查询当中</strong>。</p><p>子查询，又叫内部查询，相对于<strong>内部查询</strong>，包含内部查询的就称为<strong>外部查询</strong>。</p><p>子查询可以包含普通select可以包括的任何子句，比如：distinct、 group by、order<br />by、limit、join和union等；</p><p>但是对应的外部查询必须是以下语句之一：select、insert、update、delete</p><blockquote><p><strong>select 中、from 后、where 中.</strong></p></blockquote><blockquote><p>group by 和order by 中无实用意义</p></blockquote><h3 id="查询原理"><a class="markdownIt-Anchor" href="#查询原理"></a> 查询原理</h3><p><strong>单表查询</strong>：根据WHERE条件过滤表中的记录，形成中间表（这个中间表对用户是不可见的）；然后根据SELECT的选择列选择相应的列进行返回最终结果。</p><p><strong>两表连接查询</strong>：对两表求积（笛卡尔积）并用ON条件和连接连接类型进行过滤形成中间表；然后根据WHERE条件过滤中间表的记录，并根据SELECT指定的列返回查询结果。</p><p><strong>多表连接查询</strong>：先对第一个和第二个表按照两表连接做查询，然后用查询结果和第三个表做连接查询，以此类推，直到所有的表都连接上为止，最终形成一个中间的结果表，然后根据WHERE条件过滤中间表的记录，并根据SELECT指定的列返回查询结果。</p><blockquote><p>理解SQL查询的过程是进行SQL优化的理论依据。</p></blockquote><h2 id="mysql架构"><a class="markdownIt-Anchor" href="#mysql架构"></a> MySQL架构</h2><p><strong>Connectors</strong></p><p>指的是不同语言中与sql的交互</p><p><strong>Management Serveices &amp; Utilities</strong>：</p><p>系统管理和控制工具</p><p><strong>Connection Pool: 连接池</strong></p><p>管理缓冲<u>用户连接</u>，<u>线程处理</u>等需要缓存的需求。</p><p>负责监听对 MySQL Server 的各种请求，接收连接请求，转发所有连接请求到<u>线程管理模块</u>。每一个连接上 MySQL Server 的客户端请求都会被分配（或创建）一个连接线程为其单独服务。</p><p>而连接线程的主要工作就是负责 MySQL Server 与客户端的通信，接受客户端的命令请求，传递 Server 端的结果信息等。线程管理模块则负责管理维护这些连接线程。包括线程的创建，线程的 cache 等。</p><p><strong>SQL Interface: SQL接口</strong></p><p>接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface</p><p><strong>Parser: 解析器</strong></p><p>SQL命令传递到解析器的时候会被解析器<u>验证和解析</u>。<br />主要功能：</p><ol><li>将SQL语句进行语义和语法的分析，分解成数据结构，然后按照<u>不同的操作类型进行分类</u>，然后做出针对性的转发到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。</li><li>如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的</li></ol><p><strong>Optimizer: 查询优化器</strong><br />SQL语句在查询之前会<u>使用查询优化器对查询进行优化</u>。</p><p>它使用的是“<u>选取-投影-联接</u>”策略进行查询。</p><ul><li>用一个例子就可以理解： select uid,name from user where gender = 1;<ul><li>这个select 查询先根据where 语句进行<strong>选取</strong>，而不是先将表全部查询出来以后再进行过滤</li><li>这个select查询先根据uid和name进行属性<strong>投影</strong>，而不是将属性全部取出以后再进行过滤</li><li>将这两个查询条件<strong>联接</strong>起来生成最终查询结果</li></ul></li></ul><p><strong>Cache和Buffer： 查询缓存</strong></p><p>他的主要功能是将客户端提交给MySQL的 select请求的返回结果集 cache 到内存中，与该 query 的一个 hash 值 做一个对应。该 Query 所取数据的基表发生任何数据的变化之后， MySQL 会自动使该 query 的Cache 失效。在读写比例非常高的应用系统中， Query Cache 对性能的提高是非常显著的。当然它对内存的消耗也是非常大的。</p><p>如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等</p><p><strong>存储引擎接口</strong><br />存储引擎接口模块可以说是 MySQL 数据库中最有特色的一点了。目前各种数据库产品中，基本上只有 MySQL 可以实现其底层数据存储引擎的插件式管理。这个模块实际上只是 一个抽象类，但正是因为它成功地将各种数据处理高度抽象化，才成就了今天 MySQL 可插拔存储引擎的特色。</p><p>从图还可以看出，MySQL区别于其他数据库的最重要的特点就是<strong>其插件式的表存储引擎</strong>。MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者都可以按照自己的意愿来进行开发。</p><blockquote><p>注意：存储引擎是基于表的，而不是数据库。</p></blockquote><h3 id="执行流程图"><a class="markdownIt-Anchor" href="#执行流程图"></a> 执行流程图</h3><h3 id="存储引擎"><a class="markdownIt-Anchor" href="#存储引擎"></a> 存储引擎</h3><p>数据库存储引擎是数据库底层软件组件，数据库管理系统使用数据引擎进行创建、查询、更新和删除数据操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎还可以获得特定的功能。</p><p>现在许多数据库管理系统都支持多种不同的存储引擎。MySQL 的核心就是存储引擎</p><ul><li>多存储引擎是mysql有别于其他数据库的一大特性;</li><li>存储引擎是针对表的</li><li>MySQL 5.5之后，默认的存储引擎由<strong>MyISAM</strong>变为<strong>InnoDB</strong>。</li><li>MyISAM 是基于 ISAM 的存储引擎，并对其进行扩展，是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事务</li></ul><blockquote><p>提示：InnoDB 事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL 5.5.5 之后，InnoDB 作为默认存储引擎</p></blockquote><hr /><p><strong>查看存储引擎：</strong></p><pre><code class="highlight sql"><span class="keyword">show</span> engines;</code></pre><p><strong>临时修改默认存储引擎</strong></p><pre><code class="highlight sql"><span class="keyword">SET</span> default_storage_engine<span class="operator">=</span><span class="operator">&lt;</span> 存储引擎名 <span class="operator">&gt;</span></code></pre><blockquote><p>但是当再次重启客户端时，默认存储引擎仍然是 InnoDB</p></blockquote><hr /><p><strong>如何选择存储引擎</strong></p><ul><li>如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 是一个很好的选择。</li><li>如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。</li><li>如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MEMORY 引擎中，MySQL 中使用该引擎作为临时表，存放查询的中间结果。</li><li>如果只有 INSERT 和 SELECT 操作，可以选择Archive 引擎，Archive 存储引擎支持高并发的插入操作，但是本身并不是事务安全的。Archive 存储引擎非常适合存储归档数据，如记录日志信息可以使用 Archive 引擎。</li></ul><table><thead><tr><th></th><th>InnoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td>存储文件</td><td>.frm表定义文件/.ibd数据文件</td><td>.frm表定义文件/.myd数据文件/.myi索引文件</td></tr><tr><td>锁</td><td>表锁、<strong>行锁</strong></td><td>表锁</td></tr><tr><td>事务</td><td>ACID</td><td>不支持</td></tr><tr><td>CRDU</td><td>读、写</td><td>读多</td></tr><tr><td>count</td><td>扫表</td><td>专门存储的地方</td></tr><tr><td>索引结构</td><td>B+ Tree</td><td>B+ Tree</td></tr><tr><td>存储限制</td><td>256TB</td><td>64TB</td></tr><tr><td>全文索引</td><td>No</td><td>Yes</td></tr><tr><td>树索引</td><td>Yes</td><td>Yes</td></tr><tr><td>哈希索引</td><td>No</td><td>No</td></tr><tr><td>数据缓存</td><td>Yes</td><td>No</td></tr><tr><td>支持外键</td><td>Yes</td><td>No</td></tr></tbody></table><blockquote><p>提示：使用哪一种引擎要根据需要灵活选择，一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎将会提高整个数据库的性能</p></blockquote><h3 id="mysql物理结构"><a class="markdownIt-Anchor" href="#mysql物理结构"></a> MySQL物理结构</h3><p>MySQL是通过文件系统对数据进行存储和管理的。</p><p>MySQL从物理结构上可以分为日志文件和数据文件</p><h4 id="日志文件"><a class="markdownIt-Anchor" href="#日志文件"></a> 日志文件</h4><p>MySQL通过日志记录了数据库操作信息和错误信息。常用的日志文件包括<strong>错误日志、二进制日志、查询日志、慢查询日志和 InnoDB 引擎在线 Redo 日志、中继日志等</strong></p><p><strong>错误日志（err log）</strong>：</p><ul><li>默认是<strong>开启</strong>的，而且从5.5.7以后无法关闭错误日志</li><li>记录了运行过程中遇到的<strong>所有严重的错误信息</strong>,以及 MySQL每次<strong>启动和关闭的详细信息</strong>。</li><li>默认的错误日志名称：hostname.err，该名字可以通过命令<code>system hostname;</code>查询获得</li><li>错误日志所记录的信息是可以通过<strong>log-error和log-warnings</strong>来定义的，其中log-err是定义是否启用错误日志的功能和错误日志的存储位置，log-warnings是定义是否将警告信息也定义至错误日志中。</li><li>log_error可以直接定义为文件路径，也可以为ON|OFF；log_warings只能使用<strong>1|0</strong>来定义开关启动</li></ul><blockquote><p>在<code>vim /etc/my.cnf</code>中存储了log-error的存储位置</p></blockquote><p><strong>二进制日志（bin log）</strong>：（重要）</p><ul><li>默认是关闭的，需要通过<code>vim /etc/my.cnf</code>配置：进行开启</li></ul><pre><code class="highlight plaintext">log-bin=mysql-bin</code></pre><ul><li>其中mysql-bin是binlog日志文件的basename，binlog日志文件的名称：<code>mysql-bin-000001.log</code></li><li>binlog记录了数据库所有的<strong>ddl语句和dml语句</strong>，但不包括select语句内容，语句以事件的形式保存，描述了数据的变更顺序，binlog还包括了每个更新语句的执行时间信息，binlog主要作用是用于恢复数据，因此binlog对于灾难恢复和备份恢复来说至关重要。</li><li>如果是DDL语句，则直接记录到binlog日志，而DML语句，必须通过事务提交才能记录到binlog日志中。</li><li>binlog还用于实现<strong>mysql主从复制</strong>。</li><li>binlog<strong>还用于数据恢复</strong>。</li></ul><p><strong>通用查询日志（general query log）</strong>：</p><ul><li>默认情况下通用查询日志是<strong>关闭</strong>的。</li><li>由于通用查询日志会记录用户的所有操作，其中还包含增删查改等信息，在并发操作大的环境下会产生大量的信息从而导致不必要的磁盘IO，会影响mysql的性能的。如若不是为了调试数据库的目的<strong>建议不要开启查询日志</strong>。</li></ul><p><strong>慢查询日志（slow query log）</strong>：</p><ul><li>默认是<strong>关闭</strong>的。需要通过在<code>vim /etc/my.cnf</code>设置进行开启</li></ul><pre><code class="highlight plaintext">slow_query_log=ON</code></pre><ul><li>记录执行时间超过<strong>long_query_time</strong>(默认10秒钟)秒的所有查询，便于收集查询时间比较长的SQL语句</li></ul><p><strong>事务日志</strong>：</p><ul><li>事务日志（InnoDB特有的日志）也叫redo日志。</li><li>文件名为&quot;ib_logfile0&quot;和“ib_logfile1”，默认存放在表空间所在目录。</li><li>还有一个日志文件叫undo 日志，默认存储在ib_data目录下。</li></ul><p><strong>中继日志</strong>：</p><ul><li>是在主从复制环境中产生的日志。</li><li>主要作用是为了从机可以从中继日志中获取到主机同步过来的SQL语句，然后执行到从机中。</li></ul><h4 id="数据文件"><a class="markdownIt-Anchor" href="#数据文件"></a> 数据文件</h4><p>查看MySQL数据文件存储地址：</p><pre><code class="highlight sql">use lee_home;<span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%datadir%&#x27;</span>;</code></pre><ul><li>.<strong>frm文件</strong>：主要存放与表相关的数据信息,主要包括表结构的定义信息</li><li><strong>.ibd和.ibdata文件</strong>：用来存储<strong>InnoDB</strong>存储引擎的表数据和索引信息</li><li><strong>.myd文件</strong>：主要用来存储使用<strong>MyISAM</strong>存储引擎的表数据信息。</li><li><strong>.myi文件</strong>：主要用来存储使用<strong>MyISAM</strong>存储引擎的表数据文件中任何索引的数据树</li></ul><blockquote><p>一张表对应一套</p></blockquote><h2 id="mysql索引"><a class="markdownIt-Anchor" href="#mysql索引"></a> MySQL索引</h2><h3 id="为什么使用索引"><a class="markdownIt-Anchor" href="#为什么使用索引"></a> 为什么使用索引</h3><p>使用索引的主要目的是为了<strong>优化查询速度</strong></p><p>索引是一种<strong>特殊的文件或者叫数据结构</strong>(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。更通俗的说，数据库索引好比是一本书前面的目录，能<strong>加快数据库的查询速度</strong>。</p><p>索引是 MySQL 中一种十分重要的数据库对象。它是数据库性能调优技术的基础，常用于实现数据的快速检索。</p><p>索引就是根据表中的一列或若干列按照一定顺序建立的列值与记录行之间的对应关系表，实质上是一张描述索引列的列值与原表中记录行之间一一对应关系的有序表。</p><p>在 MySQL 中，通常有以下两种方式访问数据库表的行数据：</p><p><strong>1) 顺序访问</strong></p><p>顺序访问是在表中实行全表扫描，从头到尾逐行遍历，直到在无序的行数据中找到符合条件的目标数据。这种方式实现比较简单，但是当表中有大量数据的时候，效率非常低下。例如，在几千万条数据中查找少量的数据时，使用顺序访问方式将会遍历所有的数据，花费大量的时间，显然会影响数据库的处理性能。</p><p><strong>2) 索引访问</strong></p><p>索引访问是通过遍历索引来直接访问表中记录行的方式。使用这种方式的前提是对表建立一个索引，在列上创建了索引之后，查找数据时可以直接根据该列上的索引找到对应记录行的位置，从而快捷地查找到数据。索引存储了指定列数据值的指针，根据指定的排序顺序对这些指针排序。<br />例如，在学生基本信息表 students 中，如果基于 student_id 建立了索引，系统就建立了一张索引列到实际记录的映射表，当用户需要查找 student_id 为 12022 的数据的时候，系统先在 student_id 索引上找到该记录，然后通过映射表直接找到数据行，并且返回该行数据。因为扫描索引的速度一般远远大于扫描实际数据行的速度，所以采用索引的方式可以大大提高数据库的工作效率。</p><h3 id="索引的分类"><a class="markdownIt-Anchor" href="#索引的分类"></a> 索引的分类</h3><p>索引是在存储引擎中实现的，也就是说不同的存储引擎，会使用不同的索引</p><ul><li>MyISAM和InnoDB存储引擎：只支持<strong>BTREE索引</strong>， 也就是说<strong>默认</strong>使用BTREE，<strong>不能够更换</strong></li><li>MEMORY/HEAP存储引擎：支持HASH和BTREE索引</li></ul><hr /><p>MySQL 中常用的索引在物理上分为以下两类。</p><p><strong>1) B-树索引</strong></p><p>B-树索引又称为 BTREE 索引，目前大部分的索引都是采用 B-树索引来存储的。B-树索引是一个典型的数据结构，其包含的组件主要有以下几个：</p><ul><li>叶子节点：包含的条目直接指向表里的数据行。叶子节点之间彼此相连，一个叶子节点有一个指向下一个叶子节点的指针。</li><li>分支节点：包含的条目指向索引里其他的分支节点或者叶子节点。</li><li>根节点：一个 B-树索引只有一个根节点，实际上就是位于树的最顶端的分支节点。</li></ul><p>基于这种树形数据结构，表中的每一行都会在索引上有一个对应值。因此，在表中进行数据查询时，可以根据索引值一步一步定位到数据所在的行。</p><p>B-树索引可以进行全键值、键值范围和键值前缀查询，也可以对查询结果进行 ORDER BY 排序。但 B-树索引必须遵循左边前缀原则，要考虑以下几点约束：</p><ul><li>查询必须从索引的最左边的列开始。</li><li>查询不能跳过某一索引列，必须按照从左到右的顺序进行匹配。</li><li>存储引擎不能使用索引中范围条件右边的列。</li></ul><p><strong>2) 哈希索引</strong></p><p>哈希（Hash）一般翻译为“散列”，也有直接音译成“哈希”的，就是把任意长度的输入（又叫作预映射，pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。</p><p>哈希索引也称为散列索引或 HASH 索引。MySQL 目前仅有 MEMORY 存储引擎和 HEAP 存储引擎支持这类索引。其中，MEMORY 存储引擎可以支持 B- 树索引和 HASH 索引，且将 HASH 当成默认索引。</p><p>HASH 索引不是基于树形的数据结构查找数据，而是根据索引列对应的哈希值的方法获取表的记录行。哈希索引的最大特点是访问速度快，但也存在下面的一些缺点：</p><ul><li>MySQL 需要读取表中索引列的值来参与散列计算，散列计算是一个比较耗时的操作。也就是说，相对于 B- 树索引来说，建立哈希索引会耗费更多的时间。</li><li>不能使用 HASH 索引排序。</li><li>HASH 索引只支持等值比较，如“=”“IN()”或“&lt;=&gt;”。</li><li>HASH 索引不支持键的部分匹配，因为在计算 HASH 值的时候是通过整个索引值来计算的。</li></ul><hr /><p>根据索引的具体用途，MySQL 中的索引在逻辑上分为以下 5 类：</p><ul><li><p><strong>单列索引</strong></p><ul><li><strong>普通索引</strong>：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。</li><li><strong>唯一索引</strong>：索引列中的值必须是唯一的，但是允许为空值，</li><li><strong>主键索引</strong>：是一种特殊的唯一索引，不允许有空值。</li></ul></li><li><p><strong>组合索引</strong></p><ul><li>在表中的<strong>多个字段组合上创建的索引</strong>，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循<strong>最左前缀集合</strong>。</li></ul></li><li><p><strong>全文索引</strong></p><ul><li>全文索引，只有在<strong>MyISAM</strong>引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引。</li></ul></li></ul><p><strong>空间索引</strong></p><ul><li>不做介绍，一般使用不到</li></ul><h3 id="索引使用原则注意事项"><a class="markdownIt-Anchor" href="#索引使用原则注意事项"></a> 索引使用原则/注意事项</h3><p>虽然索引可以加快查询速度，提高 MySQL 的处理性能，但是过多地使用索引也会造成以下弊端：</p><ul><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>除了数据表占数据空间之外，每一个索引还要占一定的物理空间。如果要建立聚簇索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</li></ul><blockquote><p>注意：索引可以在一些情况下加速查询，但是在某些情况下，会降低效率。</p></blockquote><p>索引只是提高效率的一个因素，因此在建立索引的时候应该遵循以下原则：</p><ul><li>在经常需要搜索的列上建立索引，可以加快搜索的速度。</li><li>在作为主键的列上创建索引，强制该列的唯一性，并组织表中数据的排列结构。</li><li>在经常使用表连接的列上创建索引，这些列主要是一些外键，可以加快表连接的速度。</li><li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，所以其指定的范围是连续的。</li><li>在经常需要排序的列上创建索引，因为索引已经排序，所以查询时可以利用索引的排序，加快排序查询。</li><li>在经常使用 WHERE 子句的列上创建索引，加快条件的判断速度。</li></ul><p>与此对应，在某些应用场合下建立索引不能提高 MySQL 的工作效率，甚至在一定程度上还带来负面效应，降低了数据库的工作效率，一般来说不适合创建索引的环境如下：</p><ul><li>对于那些在查询中很少使用或参考的列不应该创建索引。因为这些列很少使用到，所以有索引或者无索引并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度，并增大了空间要求。</li><li>对于那些只有很少数据值的列也不应该创建索引。因为这些列的取值很少，例如人事表的性别列。查询结果集的数据行占了表中数据行的很大比例，增加索引并不能明显加快检索速度。</li><li>对于那些定义为 TEXT、IMAGE 和 BIT 数据类型的列不应该创建索引。因为这些列的数据量要么相当大，要么取值很少。当修改性能远远大于检索性能时，不应该创建索引。因为修改性能和检索性能是互相矛盾的。</li><li>当创建索引时，会提高检索性能，降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li></ul><h3 id="索引的使用"><a class="markdownIt-Anchor" href="#索引的使用"></a> 索引的使用</h3><p><strong>单列索引</strong></p><ul><li>普通索引</li></ul><pre><code class="highlight sql"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> <span class="keyword">table</span>(<span class="keyword">column</span>(length)) <span class="keyword">ALTER TABLE</span> table_name <span class="keyword">ADD</span> INDEX index_name <span class="keyword">ON</span> (<span class="keyword">column</span>(length))案例：<span class="keyword">create</span> index idx_name <span class="keyword">on</span> <span class="keyword">user</span>(name);<span class="keyword">CREATE TABLE</span> tb_stu_info(     id <span class="type">INT</span> <span class="keyword">NOT NULL</span>,     name <span class="type">CHAR</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,     dept_id <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,     age <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,     height <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,     INDEX(height)     );</code></pre><ul><li>唯一索引</li></ul><pre><code class="highlight sql"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name <span class="keyword">ON</span> <span class="keyword">table</span>(<span class="keyword">column</span>(length))</code></pre><ul><li>全文索引</li></ul><pre><code class="highlight sql"><span class="keyword">CREATE</span> FULLTEXT INDEX index_name <span class="keyword">ON</span> <span class="keyword">table</span>(<span class="keyword">column</span>(length))</code></pre><p><strong>联合索引</strong></p><pre><code class="highlight sql"><span class="keyword">ALTER TABLE</span> article <span class="keyword">ADD</span> INDEX index_titme_time (title(<span class="number">50</span>),<span class="type">time</span>(<span class="number">10</span>))</code></pre><hr /><p><strong>删除索引</strong></p><pre><code class="highlight sql"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> <span class="keyword">table</span></code></pre><hr /><p><strong>查看索引</strong></p><pre><code class="highlight sql"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [ <span class="keyword">FROM</span> <span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span>]</code></pre><p>该语句会返回一张结果表，该表有如下几个字段，每个字段所显示的内容说明如下。</p><ul><li>Table：表的名称。</li><li>Non_unique：用于显示该索引是否是唯一索引。若不是唯一索引，则该列的值显示为 1；若是唯一索引，则该列的值显示为 0。</li><li>Key_name：索引的名称。Seq_in_index：索引中的列序列号，从 1 开始计数。</li><li>Column_name：列名称。</li><li>Collation：显示列以何种顺序存储在索引中。在 MySQL 中，升序显示值“A”（升序），若显示为 NULL，则表示无分类。</li><li>Cardinality：显示索引中唯一值数目的估计值。基数根据被存储为整数的统计数据计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL 使用该索引的机会就越大。</li><li>Sub_part：若列只是被部分编入索引，则为被编入索引的字符的数目。若整列被编入索引，则为 NULL。</li><li>Packed：指示关键字如何被压缩。若没有被压缩，则为 NULL。</li><li>Null：用于显示索引列中是否包含 NULL。若列含有 NULL，则显示为 YES。若没有，则该列显示为 NO。</li><li>Index_type：显示索引使用的类型和方法（BTREE、FULLTEXT、HASH、RTREE）。</li><li>Comment：显示评注。</li></ul><h3 id="索引的存储结构"><a class="markdownIt-Anchor" href="#索引的存储结构"></a> 索引的存储结构</h3><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">数据结构查看https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p><p><strong>B Tree和B+ Tree的特点与区别</strong></p><ul><li>树的高度一般都是在2-4这个高度，树的高度直接影响IO读写的次数。</li><li>如果是三层树结构—支撑的数据可以达到20G，如果是四层树结构—支撑的数据可以达到几十T</li><li>B Tree和B+ Tree的最大区别在于非叶子节点是否存储数据的问题。B Tree是非叶子节点和叶子节点都会存储数据。而B+ Tree只有叶子节点才会存储数据，而且存储的数据都是在一行上，而且这些数据都是<strong>有指针指向</strong>的，也就是有<strong>顺序</strong>的。</li></ul><p><strong>非聚集索引</strong></p><ul><li>叶子节点只会存储数据行的指针，简单来说数据和索引不在一起，就是非聚集索引。</li><li>主键索引和辅助索引都会存储指针的值</li></ul><p><strong>聚集索引（InnoDB）</strong></p><ul><li>主键索引（聚集索引）的叶子节点会存储<strong>数据行</strong>，也就是说数据和索引是在一起，这就是聚集索引。</li><li>辅助索引只会存储主键值</li><li>如果没有没有主键，则使用唯一索引建立聚集索引；如果没有唯一索引，MySQL会按照一定规则创建聚集索引。</li></ul><blockquote><p>myISAM索引和数据是分开的，叶子节点只存了数据的引用（myd文件的指针），并没有存值</p></blockquote><blockquote><p>innodb中只有为主键索引的b+树叶子节点才会挂在完整的数据，其他列的索引的b+树的叶子节点只会挂载主键值，先找主键节点，然后从主键节点中找到要取的值</p></blockquote><blockquote><p>一个索引对应一个b+树</p></blockquote><h3 id="索引的注意事项"><a class="markdownIt-Anchor" href="#索引的注意事项"></a> 索引的注意事项</h3><p>尽量创建组合索引（组合索引其实会默认按照最左前缀原则帮我们创建多组索引）组合索引（id,name,sex）</p><p>索引<strong>最左前缀原则</strong></p><p>索引覆盖：<strong>要查询的列，也要使用索引覆盖住</strong></p><h2 id="mysql性能优化"><a class="markdownIt-Anchor" href="#mysql性能优化"></a> MySQL性能优化</h2><h3 id="查看执行计划explain"><a class="markdownIt-Anchor" href="#查看执行计划explain"></a> 查看执行计划explain</h3><p>MySQL 提供了一个<strong>EXPLAIN 命令</strong>, 它可以<strong>对 SELECT 语句进行分析</strong>, 并输出<br />SELECT 执行的详细信息, 以供开发人员针对性优化.</p><p>使用explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看。</p><p>可以通过explain命令深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。</p><p>EXPLAIN 命令用法十分简单, 在 <strong>SELECT 语句前加上 explain 就可以了</strong>, 例如:</p><pre><code class="highlight sql">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>;</code></pre><p><strong>参数说明</strong><br />expain出来的信息有10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra,下面对这些字段进行解释：</p><ul><li>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符，也<strong>相当于执行顺序</strong>.</li><li><strong>select_type</strong>: SELECT 查询的类型.<ul><li><code>SIMPLE</code>, 表示此查询不包含 UNION 查询或子查询</li><li><code>PRIMARY</code>, 表示此查询是最外层的查询</li><li><code>UNION</code>, 表示此查询是 UNION 的第二或随后的查询</li><li><code>DEPENDENT UNION</code>, UNION 中的第二个或后面的查询语句, 取决于外面的查询</li><li><code>UNION RESULT</code>, UNION 的结果</li><li><code>SUBQUERY</code>, 子查询中的第一个 SELECT</li><li><code>DEPENDENT SUBQUERY</code>: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li></ul></li><li>table: 查询的是哪个表</li><li>partitions: 匹配的分区</li><li><strong>type</strong>: 使用索引类型</li><li>possible_keys: 此次查询中可能选用的索引</li><li><strong>key</strong>: 此次查询中确切使用到的索引.</li><li><strong>ref</strong>: 哪个字段或常数与 key 一起被使用</li><li><strong>rows</strong>: 显示此查询一共扫描了多少行. 这个是一个估计值.</li><li>key_len：索引列的长度（太长了也不好）</li><li>filtered: 表示此查询条件所过滤的数据的百分比</li><li>extra: 额外的信息</li></ul><p><strong>type列说明</strong></p><p>通常来说, 不同的 type 类型的性能关系如下:<br /><code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code></p><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>system</td><td>表只有一行</td></tr><tr><td>const</td><td>表最多只有一行匹配，通用用于主键或者唯一索引比较时</td></tr><tr><td>eq_ref</td><td>每次与之前的表合并行都只在该表读取一行，这是除了system，const之外最好的一种，特点是使用=，而且索引的所有部分都参与join且索引是主键或非空唯一键的索引</td></tr><tr><td>ref</td><td>如果每次只匹配少数行，那就是比较好的一种，使用=或&lt;=&gt;，可以是左覆盖索引或非主键或非唯一键</td></tr><tr><td>fulltext</td><td>全文搜索</td></tr><tr><td>ref_or_null</td><td>与ref类似，但包括NULL</td></tr><tr><td>index_merge</td><td>表示出现了索引合并优化(包括交集，并集以及交集之间的并集)，但不包括跨表和全文索引。这个比较复杂，目前的理解是合并单表的范围索引扫描（如果成本估算比普通的range要更优的话</td></tr><tr><td>unique_subquery</td><td>在in子查询中，就是value in (select…)把形如“select unique_key_column”的子查询替换。PS：</td></tr><tr><td>index_subquery</td><td>同上，但把形如”select non_unique_key_column“的子查询替换</td></tr><tr><td>range</td><td>常数值的范围</td></tr><tr><td>index</td><td>a.当查询是索引覆盖的，即所有数据均可从索引树获取的时候（Extra中有Using Index）；b.以索引顺序从索引中查找数据行的全表扫描（无 Using Index）；c.如果Extra中Using Index与Using Where同时出现的话，则是利用索引查找键值的意思；d.如单独出现，则是用读索引来代替读行，但不用于查找</td></tr><tr><td>all</td><td>全表扫描</td></tr></tbody></table><p>参考网址：<br /><a href="https://segmentfault.com/a/1190000008131735">https://segmentfault.com/a/1190000008131735</a></p><p><a href="https://blog.csdn.net/rewiner120/article/details/70598797">https://blog.csdn.net/rewiner120/article/details/70598797</a></p><h3 id="慢查询"><a class="markdownIt-Anchor" href="#慢查询"></a> 慢查询</h3><h4 id="优化思路"><a class="markdownIt-Anchor" href="#优化思路"></a> 优化思路</h4><ol><li><p>首先需要使用<strong>慢查询</strong>功能，去获取所有查询时间比较长的SQL语句</p></li><li><p>其次使用<strong>explain</strong>命令去查看有问题的SQL的执行计划</p></li><li><p>最后可以使用<strong>show profile</strong>[s] 查看有问题的SQL的性能使用情况（底层的资源使用情况）</p></li></ol><h4 id="慢查询介绍"><a class="markdownIt-Anchor" href="#慢查询介绍"></a> 慢查询介绍</h4><p>数据库查询快慢是影响项目性能的一大因素，对于数据库，我们除了要优化 SQL，更重要的是得<strong>先找到需要优化的 SQL</strong>。</p><p>MySQL 数据库有一个“<strong>慢查询日志</strong>”功能，用来<strong>记录</strong>查询时间超过<strong>某个设定值的SQL</strong>，这将极大程度帮助我们<strong>快速定位到症结所在</strong>，以便对症下药。</p><ul><li>至于查询时间的多少才算慢，每个项目、业务都有不同的要求。</li><li>传统企业的软件允许查询时间高于某个值，但是把这个标准放在互联网项目或者访问量大的网站上，估计就是一个bug，甚至可能升级为一个功能性缺陷。</li></ul><p>MySQL的慢查询日志功能，<strong>默认是关闭的，需要手动开启</strong></p><h4 id="开启慢查询功能"><a class="markdownIt-Anchor" href="#开启慢查询功能"></a> 开启慢查询功能</h4><p><strong>查看是否开启慢查询功能</strong></p><p><strong>参数说明：</strong></p><ul><li><strong>slow_query_log</strong>    ：是否开启慢查询日志，ON 为开启，OFF 为关闭，如果为关闭可以开启。</li><li>log-slow-queries  ：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</li><li><strong>slow-query-log-file</strong>：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</li><li><strong>long_query_time</strong> ：慢查询阈值，当查询时间多于设定的阈值时，记录日志，单位为秒。</li></ul><p><strong>临时开启慢查询功能</strong></p><p>在MySQL执行sql语句设置，但是如果重启MySQL会失效</p><pre><code class="highlight sql"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log <span class="operator">=</span> <span class="keyword">ON</span>;<span class="keyword">set</span> <span class="keyword">global</span> long_query_time <span class="operator">=</span> <span class="number">1</span>;</code></pre><p><strong>永久开启慢查询功能</strong></p><p>修改<code>/etc/my.cnf</code>配置文件，重启 MySQL, 这种永久生效.</p><pre><code class="highlight plaintext">[mysqld]slow_query_log = ONslow_query_log_file = /var/log/mysql/slow.loglong_query_time = 1</code></pre><p><strong>慢查询日志的格式</strong></p><pre><code class="highlight sql"><span class="comment">--让select睡眠3秒钟，模拟要优化的sql，为了查看慢查询日志</span><span class="keyword">select</span> sleep(<span class="number">3</span>);</code></pre><p><strong>格式说明</strong></p><ul><li>第一行,SQL查询执行的时间</li><li>第二行,执行SQL查询的连接信息，用户和连接IP</li><li>第三行,记录了一些我们比较有用的信息，如下解析<ul><li>Query_time,这条SQL执行的时间,越长则越慢</li><li>Lock_time,在MySQL服务器阶段(不是在存储引擎阶段)等待表锁时间</li><li>Rows_sent,查询返回的行数</li><li>Rows_examined,查询检查的行数，越长就当然越费时间</li></ul></li><li>第四行,设置时间戳，没有实际意义，只是和第一行对应执行时间。</li><li>第五行及后面所有行（第二个# Time:之前）,执行的sql语句记录信息，因为sql可能会很长。</li></ul><h4 id="分析慢查询日志"><a class="markdownIt-Anchor" href="#分析慢查询日志"></a> 分析慢查询日志</h4><p><strong>MySQL自带的mysqldumpslow</strong></p><pre><code class="highlight bash">[root@localhost mysql]# mysqldumpslow /var/lib/mysql/localhost-slow.log</code></pre><p><strong>常用参数说明</strong></p><ul><li>-s：表示按照何种方式排序<br />*</li><li>-t：是top n的意思，即为返回前面多少条的数据</li><li>-g：后边可以写一个正则匹配模式，大小写不敏感的</li></ul><p><strong>示例:</strong></p><p>得到按照时间排序的前10条里面含有左连接的查询语句</p><pre><code class="highlight bash">mysqldumpslow -s t -t 10 -g “left <span class="built_in">join</span>” /var/lib/mysql/localhost_slow.log</code></pre><p><strong>使用mysqlsla 工具</strong></p><ul><li><p>mysqlsla工具，功能非常强大。数据报表，非常有利于分析慢查询的原因，包括执行频率，数据量，查询消耗等。</p></li><li><p>不过此工具已停止维护，项目 github 介绍页面推荐使用 percona-toolkit，下面有介绍。</p></li></ul><pre><code class="highlight plaintext">mysqlsla -lt /var/log/mysql/slow.log</code></pre><p><strong>使用percona-toolkit工具</strong></p><p>percona-toolkit是一组高级命令行工具的集合，可以查看当前服务的摘要信息，磁盘检测，分析慢查询日志，查找重复索引，实现表同步等等</p><p><a href="https://www.percona.com/downloads/percona-toolkit/3.0.11/binary/tarball/percona-toolkit-3.0.11_x86_64.tar.gz">percona-toolkit工具 下载</a></p><p>安装：</p><pre><code class="highlight bash">tar -xf percona-toolkit-3.0.11_x86_64.tar.gz<span class="built_in">cd</span> percona-toolkit-3.0.11perl Makefile.PLmakemake install</code></pre><p>调错：</p><pre><code class="highlight plaintext">Can&#x27;t locate ExtUtils/MakeMaker.pm in @INC 错误的解决方式:* yum install -y perl-ExtUtils-CBuilder perl-ExtUtils-MakeMakerCan&#x27;t locate Time/HiRes.pm in @INC* yum install -y perl-Time-HiRes</code></pre><p>使用pt-query-digest查看慢查询日志</p><pre><code class="highlight plaintext">pt-query-digest /var/lib/mysql/localhost-slow.log</code></pre><h3 id="性能分析语句show-profile"><a class="markdownIt-Anchor" href="#性能分析语句show-profile"></a> 性能分析语句show profile</h3><p>Query Profiler是MYSQL自带的一种<strong>query诊断分析工具</strong>，通过它可以分析出一条SQL语句的<strong>性能瓶颈</strong>在什么地方。</p><p>通常我们是使用的explain,以及slow query log都无法做到精确分析，但是Query<br />Profiler却可以<strong>定位出一条SQL语句执行的各种资源消耗情况</strong>，比如CPU，IO等，以及该SQL执行所耗费的时间等。不过该工具只有在MYSQL 5.0.37以及以上版本中才有实现。</p><p>默认的情况下，MYSQL的该功能没有打开，<strong>需要自己手动启动</strong>。</p><h4 id="语句使用"><a class="markdownIt-Anchor" href="#语句使用"></a> 语句使用</h4><p><strong>show profile</strong> 和 <strong>show profiles</strong> 语句可以展示<strong>当前会话</strong>(<u>退出session后,profiling重置为0</u>) 中执行语句的资源使用情况.</p><ul><li><strong>show profiles</strong> :以列表形式显示最近发送到服务器上执行的语句的资源使用情况.显示的记录数由变量:profiling_history_size 控制,默认15条</li></ul><pre><code class="highlight sql"><span class="keyword">show</span> profiles;</code></pre><ul><li><strong>show profile</strong>: 展示<u>最近一条</u>语句执行的详细资源占用信息,默认显示 Status和Duration（时间）两列；</li></ul><pre><code class="highlight sql"><span class="keyword">show</span> profile;</code></pre><ul><li><strong>show profile</strong>还可根据 show profiles 列表中的 Query_ID ,选择显示某条记录的性能分析信息</li></ul><p>案例：</p><pre><code class="highlight sql"><span class="keyword">show</span> profile <span class="keyword">all</span> forquery <span class="number">2</span>;</code></pre><h4 id="开启profile功能"><a class="markdownIt-Anchor" href="#开启profile功能"></a> 开启profile功能</h4><p>Profile 功能由MySQL会话变量 : <strong>profiling</strong>控制,默认是<strong>OFF</strong>关闭状态。</p><p>查看是否开启了Profile功能:</p><pre><code class="highlight sql"><span class="keyword">select</span> @<span class="variable">@profiling</span>;<span class="keyword">show</span> variables <span class="keyword">like</span> ‘<span class="operator">%</span>profil<span class="operator">%</span>’;</code></pre><p><strong>开启profile功能</strong></p><pre><code class="highlight sql"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>; <span class="comment">--1是开启、0是关闭</span></code></pre><h4 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h4><ol><li><p>开启profiling功能</p></li><li><p>执行sql语句</p></li><li><p>执行 show profiles 查看分析列表</p></li><li><p>查询第二条语句的执行情况</p></li></ol><pre><code class="highlight sql"><span class="keyword">show</span> profile <span class="keyword">for</span> query <span class="number">2</span>;</code></pre><ol start="5"><li>可指定资源类型查询</li></ol><pre><code class="highlight sql"><span class="keyword">show</span> profile cpu,swaps <span class="keyword">for</span> query <span class="number">2</span>;</code></pre><h3 id="性能优化细节"><a class="markdownIt-Anchor" href="#性能优化细节"></a> 性能优化细节</h3><ul><li>合理的创建及使用索引（考虑数据的增删情况）</li><li>合理的冗余字段（尽量建一些大表，考虑数据库的三范式和业务设计的取舍）</li><li>使用SQL要注意一些细节：select语句中尽量不要使用*、count(*)，WHERE语句中尽量不要使用1=1、in语句（建议使用exists）、注意组合索引的创建顺序按照顺序组着查询条件、尽量查询粒度大的SQL放到最左边、尽量建立组合索引</li><li>合理利用慢查询日志、explain执行计划查询、show profile查看SQL执行时的资源使用情况。</li></ul><h2 id="mysql事务处理"><a class="markdownIt-Anchor" href="#mysql事务处理"></a> MySQL事务处理</h2><h3 id="事务概述"><a class="markdownIt-Anchor" href="#事务概述"></a> 事务概述</h3><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p><ul><li><p>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</p></li><li><p>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</p></li><li><p>事务用来管理DML操作，比如 insert,update,delete 语句</p></li></ul><p>一般来说，事务是必须满足4个条件（ACID）：</p><ul><li><p><strong>Atomicity</strong>（原子性）：事务必须是原子工作单元，事务中的操作要么全部执行，要么全都不执行，不能只完成部分操作。原子性在数据库系统中，由恢复机制来实现</p></li><li><p><strong>Consistency</strong>（一致性）：事务开始之前，数据库处于一致性的状态；事务结束后，数据库必须仍处于一致性状态。数据库一致性的定义是由用户负责的。例如，在银行转账中，用户可以定义转账前后两个账户金额之和保持不变。</p></li><li><p><strong>Isolation</strong>（隔离性）：系统必须保证事务不受其他并发执行事务的影响，即当多个事务同时运行时，各事务之间相互隔离，不可互相干扰。事务查看数据时所处的状态，要么是另一个并发事务修改它之前的状态，要么是另一个并发事务修改它之后的状态，事务不会查看中间状态的数据。隔离性通过系统的并发控制机制实现。</p></li><li><p><strong>Durability</strong>（持久性）：一个已完成的事务对数据所做的任何变动在系统中是永久有效的，即使该事务产生的修改不正确，错误也将一直保持。持久性通过恢复机制实现，发生故障时，可以通过日志等手段恢复数据库信息。</p></li></ul><h3 id="mysql事务支持"><a class="markdownIt-Anchor" href="#mysql事务支持"></a> MySQL事务支持</h3><p>常见的操作有一下三个：</p><ul><li><p><strong>BEGIN</strong>或START TRANSACTION；显式地开启一个事务；</p></li><li><p><strong>COMMIT</strong>；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的；</p></li><li><p><strong>ROLLBACK</strong>；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</p></li></ul><p>在 MySQL 命令行的<strong>默认</strong>设置下，事务都是<strong>自动提交</strong>的，即执行 SQL 语句后就会马上执行COMMIT 操作。因此要<strong>显式地开启一个事务务</strong>须使用命令<strong>BEGIN</strong> 或 START TRANSACTION，或者执行命令 <strong>SET AUTOCOMMIT=0</strong>，用来禁止使用当前会话的自动提交。</p><h4 id="事务并发问题"><a class="markdownIt-Anchor" href="#事务并发问题"></a> 事务并发问题</h4><p><strong>丢失更新</strong>：一个事务更新之后，另一个事务也更新了，但是第二个事务回滚了，则第一个事务也被回滚了。</p><p><strong>脏读</strong>：一个事务读取到另一个事务未提交的数据。（行锁：<em>我写的时候其他人不可读</em> ）</p><p><strong>不可重复读</strong>：一个事务因读取到另一个事务已提交的数据。导致对同一条记录读取两次以上的结果不一致。update操作（行锁：<em>只要我读了其他人就不能写</em> ）</p><p><strong>幻读</strong>：一个事务因读取到另一个事务已提交的数据。导致对同一张表读取两次以上的结果不一致。insert、delete操作（表锁：<em>读表的同时锁掉写表的权限</em>）</p><h4 id="事务隔离级别"><a class="markdownIt-Anchor" href="#事务隔离级别"></a> 事务隔离级别</h4><p>为了避免上面出现的几种情况，在标准SQL规范中，定义了<strong>4个事务隔离级别（由低到高）</strong>，不同的隔离级别对事务的处理不同</p><ul><li><strong>Read uncommitted</strong> (读未提交)：最低级别，任何情况都无法保证。</li><li><strong>Read committed</strong> (读已提交)：可避免脏读的发生，<code>使用排他写锁实现</code>。</li><li><strong>Repeatable read</strong> (可重复读)：可避免脏读、不可重复读的发生。<code>排他写锁+本事务查询了某条记录，就会保留备份，即使其他事务修改了这条记录，本事务依然查到是第一次查出的值</code></li><li><strong>Serializable</strong> (串行化)：可避免脏读、不可重复读、幻读的发生。</li></ul><p><strong>默认级别</strong></p><p>大多数数据库的默认隔离级别是Read committed，比如Oracle、DB2等。</p><p>MySQL数据库的默认隔离级别是<strong>Repeatable read</strong>。<code>排他写锁+本事务查询了某条记录，就会保留备份，即使其他事务修改了这条记录，本事务依然查到是第一次查出的值</code></p><p><strong>如何查看和设置隔离级别：</strong></p><ul><li>在MySQL数据库中查看当前事务的隔离级别：</li></ul><pre><code class="highlight sql"><span class="keyword">select</span> @<span class="variable">@tx_isolation</span>;</code></pre><ul><li>在MySQL数据库中设置事务的隔离 级别：</li></ul><pre><code class="highlight sql"><span class="comment">-- -glogal表示全局的</span><span class="comment">-- -session表示当前会话</span><span class="keyword">set</span>  [glogal <span class="operator">|</span> session]  transaction isolation level 隔离级别名称;<span class="keyword">set</span> tx_isolation<span class="operator">=</span>’隔离级别名称;’</code></pre><p><strong>注意事项</strong></p><ul><li><p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。</p></li><li><p>对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制</p></li></ul><h3 id="事务使用"><a class="markdownIt-Anchor" href="#事务使用"></a> 事务使用</h3><p><strong>开始事务</strong><br />事务以 BEGIN TRANSACTION 开始。</p><p>语法格式如下：</p><pre><code class="highlight sql"><span class="keyword">BEGIN</span> TRANSACTION <span class="operator">&lt;</span>事务名称<span class="operator">&gt;</span> <span class="operator">|</span>@<span class="operator">&lt;</span>事务变量名称<span class="operator">&gt;</span></code></pre><p>语法说明如下：</p><ul><li>@&lt;事务变量名称&gt;是由用户定义的变量，必须用 char、varchar、nchar 或 nvarchar数据类型来声明该变量。</li><li>BEGIN TRANSACTION 语句的执行使全局变量 @@TRANCOUNT 的值加 1。</li></ul><hr /><p><strong>提交事务</strong></p><p>COMMIT 表示提交事务，即提交事务的所有操作。具体地说，就是将事务中所有对数据库的更新写回到磁盘上的物理数据库中，事务正常结束。</p><p>提交事务，意味着将事务开始以来所执行的所有数据修改成为数据库的永久部分，因此也标志着一个事务的结束。一旦执行了该命令，将不能回滚事务。只有在所有修改都准备好提交给数据库时，才执行这一操作。</p><p>语法格式如下：</p><pre><code class="highlight sql"><span class="keyword">COMMIT</span> TRANSACTION <span class="operator">&lt;</span>事务名称<span class="operator">&gt;</span> <span class="operator">|</span>@<span class="operator">&lt;</span>事务变量名称<span class="operator">&gt;</span></code></pre><blockquote><p>其中：COMMIT TRANSACTION语句的执行使全局变量 @@TRANCOUNT 的值减 1。</p></blockquote><hr /><p><strong>撤销事务</strong></p><p>ROLLBACK 表示撤销事务，即在事务运行的过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成的操作全部撤销，回滚到事务开始时的状态。这里的操作指对数据库的更新操作。</p><p>当事务执行过程中遇到错误时，使用 ROLLBACK TRANSACTION 语句使事务回滚到起点或指定的保持点处。同时，系统将清除自事务起点或到某个保存点所做的所有的数据修改，并且释放由事务控制的资源。因此，这条语句也标志着事务的结束。</p><p>语法格式如下：</p><pre><code class="highlight sql"><span class="keyword">ROLLBACK</span> [TRANSACTION][<span class="operator">&lt;</span>事务名称<span class="operator">&gt;</span><span class="operator">|</span> @<span class="operator">&lt;</span>事务变量名称<span class="operator">&gt;</span> <span class="operator">|</span> <span class="operator">&lt;</span>存储点名称<span class="operator">&gt;</span><span class="operator">|</span> @ <span class="operator">&lt;</span>含有存储点名称的变量名<span class="operator">&gt;</span></code></pre><p>语法说明如下：</p><ul><li>当条件回滚只影响事务的一部分时，事务不需要全部撤销已执行的操作。可以让事务回滚到指定位置，此时，需要在事务中设定保存点（SAVEPOINT）。保存点所在位置之前的事务语句不用回滚，即保存点之前的操作被视为有效的。保存点的创建通过“SAVING TRANSACTION&lt;保存点名称&gt;”语句来实现，再执行“ROLLBACK TRANSACTION&lt;保存点名称&gt;”语句回滚到该保存点。</li><li>若事务回滚到起点，则全局变量 @@TRANCOUNT 的值减 1；若事务回滚到指定的保存点，则全局变量 @@TRANCOUNT 的值不变。</li></ul><h2 id="mysql锁"><a class="markdownIt-Anchor" href="#mysql锁"></a> MySQL锁</h2><h3 id="锁介绍"><a class="markdownIt-Anchor" href="#锁介绍"></a> 锁介绍</h3><p>数据库锁定机制简单来说就是数据库为了保证数据的一致性而使各种共享资源在被并发访问访问变得有序所设计的一种规则。</p><p>对于任何一种数据库来说都需要有相应的锁定机制，所以MySQL自然也不能例外。</p><p>MySQL数据库由于其自身架构的特点，存在多种数据存储引擎，每种存储引擎所针对的应用场景特点都不太一样，为了满足各自特定应用场景的需求，<strong>每种存储引擎的锁定机制都是为各自所面对的特定场景而优化设计，所以各存储引擎的锁定机制也有较大区别</strong>。</p><p>总的来说，MySQL各存储引擎使用了三种类型（级别）的锁定机制：<strong>行级锁定，页级锁定和表级锁定</strong>。下面我们先分析一下MySQL这三种锁定的特点和各自的优劣所在。</p><ul><li>按照锁的粒度来分：行级锁和表级锁</li><li>按照锁的功能来分：共享读锁和排他写锁</li></ul><p>悲观锁（排他写锁）和乐观锁（使用某一版本列或者唯一列进行逻辑控制）</p><p>MySQL的InnoDB和MyISAM存储引擎最大的区别：事务的支持、行级锁的支持。</p><p><strong>行级锁定（row-level）</strong></p><p>行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。</p><p>虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。</p><p><strong>表级锁定（table-level）</strong></p><p>和行级锁定相反，表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。</p><p>当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并发度大打折扣。</p><p><strong>页级锁定（page-level）</strong></p><p>页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁</p><p><strong>总的来说，MySQL这3种锁的特性可大致归纳如下：</strong></p><ul><li><strong>表级锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；</li><li><strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；</li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li></ul><h3 id="表级锁"><a class="markdownIt-Anchor" href="#表级锁"></a> 表级锁</h3><p>MySQL的表级锁定有两种模式：<strong>表共享读锁</strong>（Table Read Lock<em>我可读不可写，其他可读写等待</em>）和<strong>表独占写锁</strong>（Table Write Lock<em>只有我可以读写，别人都不可以干</em>）。</p><p>MySQL 实现的表级锁定的争用状态变量：</p><pre><code class="highlight sql"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;table%&#x27;</span>;</code></pre><blockquote><p><code>table_locks_immediate</code>：产生表级锁定的次数；</p></blockquote><blockquote><p><code>table_locks_waited</code>：出现表级锁定争用而发生等待的次数；</p></blockquote><p><strong>手动增加（获取）表锁</strong></p><pre><code class="highlight sql">lock <span class="keyword">table</span> 表名称 read(write),表名称<span class="number">2</span> read(write)，其他;</code></pre><p><strong>查看表锁情况</strong></p><pre><code class="highlight sql"><span class="keyword">show</span> <span class="keyword">open</span> tables;</code></pre><p><strong>（释放）删除表锁</strong></p><pre><code class="highlight sql">unlock tables;</code></pre><h3 id="表锁演示"><a class="markdownIt-Anchor" href="#表锁演示"></a> 表锁演示</h3><p><strong>前提准备</strong></p><pre><code class="highlight sql">建表语句<span class="keyword">CREATE TABLE</span> `mylock` (   `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT,   `NAME` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,   <span class="keyword">PRIMARY KEY</span> (`id`) );添加记录<span class="keyword">INSERT INTO</span> mylock (id,NAME) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);<span class="keyword">INSERT INTO</span> mylock (id,NAME) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>);<span class="keyword">INSERT INTO</span> mylock (id,NAME) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>);<span class="keyword">INSERT INTO</span> mylock (id,NAME) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;d&#x27;</span>);</code></pre><p><strong>读锁演示</strong></p><p><strong>写锁演示</strong></p><h3 id="innodb引擎的锁机制"><a class="markdownIt-Anchor" href="#innodb引擎的锁机制"></a> InnoDB引擎的锁机制</h3><p><strong>共享锁</strong>（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</p><p><strong>排他锁</strong>（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</p><p><strong>意向共享锁</strong>（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</p><p><strong>意向排他锁</strong>（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</p><p>1）共享锁和排他锁都是行锁，意向锁都是表锁，应用中我们只会使用到共享锁和排他锁，意向锁是mysql内部使用的，不需要用户干预。</p><p>2）对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁，事务可以通过以下语句显示给记录集加共享锁或排他锁。</p><p>共享锁（S）：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... LOCK <span class="keyword">IN</span> SHARE MODE</code></pre><p>排他锁（X)：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></code></pre><p>3）<strong>InnoDB行锁</strong>是通过给<strong>索引上的索引项加锁来实现的</strong>，因此InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</p><p><strong>Innodb的锁定是通过在指向数据记录的第一个索引键之前和最后一个索引键之后的空域空间上标记锁定信息而实现的</strong>。Innodb的这种锁定实现方式被称为“NEXT-KEYlocking”（间隙锁），因为Query执行过程中通过过范围查找的华，他会锁定整个范围内所有的索引键值，即使这个键值并不存在</p><p><strong>Innodb所使用的行级锁定争用状态查看：</strong></p><pre><code class="highlight sql"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;innodb_row_lock%&#x27;</span>;</code></pre><ul><li><p><code>Innodb_row_lock_current_waits</code>：当前正在等待锁定的数量；</p></li><li><p><code>Innodb_row_lock_time</code>：从系统启动到现在锁定总时间长度；</p></li><li><p><code>Innodb_row_lock_time_avg</code>：每次等待所花平均时间；</p></li><li><p><code>Innodb_row_lock_time_max</code>：从系统启动到现在等待最常的一次所花的时间；</p></li><li><p><code>Innodb_row_lock_waits</code>：系统启动后到现在总共等待的次数；</p></li></ul><hr /><blockquote><p>对于这5个状态变量，比较重要的是:</p></blockquote><blockquote><p><code>Innodb_row_lock_time_avg</code>（等待平均时长）<br /><code>Innodb_row_lock_waits</code>（等待总次数）<br /><code>Innodb_row_lock_time</code>（等待总时长）这三项。</p></blockquote><blockquote><p>尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划</p></blockquote><h3 id="innodb行锁演示"><a class="markdownIt-Anchor" href="#innodb行锁演示"></a> InnoDB行锁演示</h3><pre><code class="highlight sql"><span class="keyword">create table</span> test_innodb_lock (a <span class="type">int</span>(<span class="number">11</span>),b <span class="type">varchar</span>(<span class="number">16</span>)) engine<span class="operator">=</span>innodb;Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec) <span class="keyword">create</span> index test_innodb_a_idx <span class="keyword">on</span> test_innodb_lock(a);Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.05</span> sec)Records: <span class="number">0</span> Duplicates: <span class="number">0</span> Warnings: <span class="number">0</span><span class="keyword">create</span> index test_innodb_lock_b_idx <span class="keyword">on</span> test_innodb_lock(b);Query OK, <span class="number">11</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)Records: <span class="number">11</span> Duplicates: <span class="number">0</span> Warnings: <span class="number">0</span></code></pre><h2 id="集群搭建"><a class="markdownIt-Anchor" href="#集群搭建"></a> 集群搭建</h2><h3 id="主从复制"><a class="markdownIt-Anchor" href="#主从复制"></a> 主从复制</h3><h4 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h4><p>主从复制原理：</p><blockquote><p>可以一主多从</p></blockquote><p>查看binlog日志：</p><pre><code class="highlight sql">mysqlbinlog 文件名称</code></pre><h4 id="主从复制配置"><a class="markdownIt-Anchor" href="#主从复制配置"></a> 主从复制配置</h4><p><strong>主服务器配置</strong></p><blockquote><p>先关闭防火墙</p></blockquote><p>第一步：修改<code>my.conf</code>文件：在[mysqld]段下添加：</p><pre><code class="highlight plaintext">#启用二进制日志log-bin=mysql-bin#服务器唯一ID，一般取IP最后一段server-id=133</code></pre><p>第二步：重启mysql服务</p><pre><code class="highlight sql">service mysqld restart</code></pre><p>第三步：建立帐户并授权slave从机（登录到MySQL）</p><ul><li><code>grant</code>：关键字表示授权</li><li><code>FILE</code>：让从机有文件读写的能力</li><li><code>REPLICATION SLAVE</code> ：从机复制权限</li><li><code>REPLICATION CLIENT</code>：复制客户端权限</li><li><code>ALL</code>：表示所有权限</li><li><code>%</code>：可以换成IP地址，表示哪个ip地址可以访问我</li><li><code>root/123456</code>：是主机的账号的密码</li></ul><pre><code class="highlight sql"><span class="keyword">GRANT</span> FILE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;<span class="keyword">GRANT</span> REPLICATION SLAVE, REPLICATION CLIENT <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>; <span class="comment">--只设置下面这一个权限也是可以的</span><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;root&#x27;</span>;</code></pre><blockquote><p>一般不用root帐号，“%”表示所有客户端都可能连，只要帐号，密码正确，此处可用具体客户端IP代替，如192.168.145.226，加强安全</p></blockquote><p>执行完上述命令需要刷新，使在缓冲区的权限生效：</p><pre><code class="highlight sql">mysql<span class="operator">&gt;</span> FLUSH PRIVILEGES;</code></pre><p>查看mysql现在有哪些用户</p><pre><code class="highlight sql">mysql<span class="operator">&gt;</span><span class="keyword">select</span> <span class="keyword">user</span>,host <span class="keyword">from</span> mysql.user;</code></pre><p>第四步：查询master的状态</p><pre><code class="highlight plaintext">mysql&gt; show master status;</code></pre><p><strong>从服务器配置</strong></p><blockquote><p>从机默认也是可以写操作的，最好是关闭掉，从机增删改是不会同步到主机的</p></blockquote><blockquote><p>只能是从机同步主机的数据</p></blockquote><blockquote><p>先关闭防火墙</p></blockquote><p>第一步：修改<code>my.conf</code>文件</p><pre><code class="highlight plaintext">[mysqld]#服务器唯一ID，一般取IP最后一段server-id=135</code></pre><p>第二步：删除UUID文件</p><pre><code class="highlight plaintext">错误处理：如果出现此错误：Fatal error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work.因为是mysql是克隆的系统所以mysql的uuid是一样的，所以需要修改。解决方法：删除/var/lib/mysql/auto.cnf文件，重新启动服务。</code></pre><p>第三步：重启 并 登录 到MySQL进行配置从服务器</p><ul><li><code>change master to</code>：改变主机信息</li><li><code>master_log_file</code>：二进制文件名</li><li><code>master_log_pos</code>：偏移量（填Position的值）</li></ul><pre><code class="highlight sql">mysql<span class="operator">&gt;</span>change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;192.168.10.133&#x27;</span>,master_port<span class="operator">=</span><span class="number">3306</span>,master_user<span class="operator">=</span><span class="string">&#x27;root&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;root&#x27;</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;mysql-bin.000001&#x27;</span>,master_log_pos<span class="operator">=</span><span class="number">120</span></code></pre><blockquote><p>注意语句中间不要断开，master_port为mysql服务器端口号(无引号)，master_user为执行同步操作的数据库账户，“120”无单引号(此处的120就是show master status 中看到的position的值，这里的mysql-bin.000001就是file对应的值)</p></blockquote><p>第四步：启动从服务器复制功能</p><pre><code class="highlight plaintext">mysql&gt;start slave;</code></pre><p>第五步：检查从服务器复制功能状态：</p><pre><code class="highlight plaintext">mysql&gt; show slave status</code></pre><pre><code class="highlight plaintext">……………………(省略部分)Slave_IO_Running: Yes //此状态必须YESSlave_SQL_Running: Yes //此状态必须YES……………………(省略部分)</code></pre><blockquote><p>Slave_IO及Slave_SQL进程必须正常运行，即YES状态，否则都是错误的状态(如：其中一个NO均属错误)</p></blockquote><p>第六步：设置只读</p><pre><code class="highlight sql"><span class="keyword">set</span> <span class="keyword">global</span> read_only<span class="operator">=</span><span class="number">1</span>;    #<span class="number">1</span>是只读，<span class="number">0</span>是读写<span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> &quot;%read_only%&quot;;</code></pre><h3 id="读写分离"><a class="markdownIt-Anchor" href="#读写分离"></a> 读写分离</h3><p>HAC：High Availability Cluster 高可用集群</p><p>MySQL的主从复制，只会保证主机对外提供服务，而从机是不对外提供服务的，只是在后台为主机进行备份，所以可以用从机来<strong>只读</strong></p><p>要实现读写分离有两种办法：</p><ol><li>使用MySQL-Proxy</li><li>使用Mycat</li></ol><p><strong>MySQL-Proxy下载</strong></p><p><strong>MySQL-Proxy安装</strong></p><ul><li><p>准备一台机器作为MySQL Proxy</p></li><li><p>上传压缩包</p></li><li><p>解压缩</p></li></ul><pre><code class="highlight plaintext">tar -xf mysql-proxy-0.8.5-linux-el6-x86-64bit.tar.gz -C /kkb</code></pre><p><strong>MySQL-Proxy配置</strong></p><ul><li>创建mysql-proxy.cnf文件（放在MySQL-proxy根目录即可）</li></ul><pre><code class="highlight plaintext">[mysql-proxy]user=rootadmin-username=rootadmin-password=111#代理机器的root密码proxy-address=OSmysqlProxy:4040#代理机器的ip,4040为MySQL-proxy默认端口proxy-backend-addresses=OSmysqlMaster:3306#主机的ipproxy-read-only-backend-addresses=OSmysqlSlave:3306#从机的ipproxy-lua-script=/leeboer/mysql-proxy/share/doc/mysql-proxy/rw-splitting.lua#这个地址要更改为MySQL-proxy目录的真实地址log-file=/leeboer/mysql-proxy/logs/mysql-proxy.log#自己更改日志文件的存储地址log-level=debug#日志级别keepalive=true#心跳检测daemon=true#后台守护</code></pre><ul><li>修改mysql-proxy.cnf文件的权限</li></ul><pre><code class="highlight plaintext">chmod g+w,o-r mysql-proxy.cnf</code></pre><ul><li>修改<code>vim /leeboer/mysql-proxy/share/doc/mysql-proxy/rw-splitting.lua</code>脚本<ul><li>这两个参数为读写分离的条件</li><li>这个可改可不改，这里只为测试用，所以改小了</li></ul></li></ul><p><strong>MySQL-Proxy启动域测试</strong></p><p>启动命令</p><pre><code class="highlight plaintext">./mysql-proxy  --defaults-file=mysql-proxy.cnf配置文件的地址</code></pre><p>在其他客户端，通过mysql命令去连接MySQL Proxy机器</p><pre><code class="highlight plaintext">mysql -uroot -proot -h192.168.10.134 -P4040</code></pre><blockquote><p>代理服务器默认地址是4040</p></blockquote><h2 id="mycat分库分表"><a class="markdownIt-Anchor" href="#mycat分库分表"></a> MyCat（分库分表）</h2><p>其他的分布式数据库中间件还有：<code>sharding-jdbc，mycat，drds</code></p><h3 id="分库分表"><a class="markdownIt-Anchor" href="#分库分表"></a> 分库分表</h3><p>前提：当你们的数据库表数据特别大时，比如说上亿的记录，数据库本身的优化基本上无法解决性能问题了，根本原因是数据库本身的io读写到了一个瓶颈，这个时候，需要海量数据的存储和查询问题。此时我们需要利用分库分表的思想去进行数据库的架构优化。</p><p>随着微服务这种架构的兴起，我们应用从一个完整的大的应用，切分为很多可以独立提供服务的小应用。每个应用都有独立的数据库</p><p>数据的切分分为两种：</p><ul><li><p><strong>垂直切分</strong>：按照业务模块进行切分，将不同模块的表切分到不同的数据库中。<br />*</p></li><li><p><strong>水平切分</strong>：将一张大表按照一定的切分规则，按照行切分到不同的表或者不同的库中。<br />*</p></li></ul><h3 id="mycat"><a class="markdownIt-Anchor" href="#mycat"></a> MyCat</h3><p>官方网站：<a href="http://www.mycat.org.cn/">http://www.mycat.org.cn/</a></p><p>简单的说，MyCAT就是：</p><ul><li>一个彻底开源的，面向企业应用开发的“大数据库集群”</li><li>支持事务、ACID、可以替代Mysql的加强版数据库</li><li>一个可以视为“Mysql”集群的企业级数据库，用来替代昂贵的Oracle集群</li><li>一个融合内存缓存技术、Nosql技术、HDFS大数据的新型SQL Server</li><li>结合传统数据库和新型分布式数据仓库的新一代企业级数据库产品</li><li>一个新颖的数据库中间件产品</li></ul><p>MyCAT的目标是：低成本的将现有的单机数据库和应用平滑迁移到“云”端，解决数据存储和业务规模迅速增长情况下的数据瓶颈问题。</p><p><strong>MyCAT的关键特性</strong></p><ul><li>支持 SQL 92标准</li><li>支持Mysql集群，可以作为Proxy使用</li><li>支持JDBC连接ORACLE、DB2、SQL Server，将其模拟为MySQL  Server使用</li><li>支持galera for mysql集群，percona-cluster或者mariadb cluster，提供高可用性数据分片集群</li><li>自动故障切换，高可用性</li><li>支持读写分离，支持Mysql双主多从，以及一主多从的模式</li><li>支持全局表，数据自动分片到多个节点，用于高效表关联查询</li><li>支持独有的基于E-R 关系的分片策略，实现了高效的表关联查询</li><li>多平台支持，部署和实施简单</li></ul><p><strong>MyCat架构</strong></p><p><strong>核心概念</strong></p><ul><li><p>Schema：由它指定逻辑数据库</p></li><li><p>Table： 逻辑表</p></li><li><p>DataNode：真正存储节点</p></li><li><p>DataHost：真正的数据库主机</p></li></ul><p>MyCAT使用Mysql的通讯协议模拟成了一个Mysql服务器，并建立了完整的<strong>Schema</strong>（数据库）、<strong>Table</strong> （数据表）、<strong>User</strong>(用户)的逻辑模型，并将这套逻辑模型映射到后端的存储节点<strong>DataNode</strong>（MySQL Instance）上的真实物理库中，这样一来，所有能使用Mysql的客户端以及编程语言都能将MyCAT当成是Mysql Server来使用，不必开发新的客户端协议</p><p><strong>mycat存在的问题</strong></p><p>跨库join问题(即多表关联查询)</p><ul><li>通过业务分析，将不同库的join查询拆分成多个select</li><li>建立全局表（每个库都有一个相同的表）</li><li>冗余字段（不符合数据库三范式）</li><li>E-R分片（将有关系的记录都存储到一个库中）</li><li>最多支持跨两张表跨库的join</li></ul><p>分布式事务（弱事务）</p><ul><li>强一致性事务（同步）</li><li>最终一致性事务（异步思想）</li></ul><p>分布式主键（即水平切分多库主键生成问题）</p><ul><li><u>redis incr命令</u></li><li>数据库（生成主键）</li><li>UUID</li><li><u>snowflake算法（分布式主键算法）</u></li></ul><p><strong>Mycat解决的问题</strong></p><ul><li>海量数据存储</li><li>查询优化</li></ul><p><strong>MyCat对多数据库的支持</strong></p><h3 id="分片策略"><a class="markdownIt-Anchor" href="#分片策略"></a> 分片策略</h3><p>MyCAT支持水平分片与垂直分片：</p><ul><li>水平分片：一个表格的数据分割到多个节点上，按照行分隔。</li><li>垂直分片：一个数据库中多个表格A，B，C，A存储到节点1上，B存储到节点2上，C存储到节点3上</li></ul><p>MyCAT通过定义表的分片规则来实现分片，每个表格可以捆绑一个分片规则，每个分片规则指定一个分片字段并绑定一个函数，来实现动态分片算法。</p><ol><li><strong>Schema</strong>：逻辑库，与MySQL中的Database（数据库）对应，一个逻辑库中定义了所包括的Table。</li><li><strong>Table</strong>：表，即物理数据库中存储的某一张表，与传统数据库不同，这里的表格需要声明其所存储的逻辑数据节点DataNode。在此可以指定表的分片规则。</li><li><strong>DataNode</strong>：MyCAT的逻辑数据节点，是存放table的具体物理节点，也称之为分片节点，通过DataSource来关联到后端某个具体数据库上</li><li><strong>DataSource</strong>：定义某个物理库的访问地址，用于捆绑到Datanode上</li></ol><h3 id="mycat下载安装"><a class="markdownIt-Anchor" href="#mycat下载安装"></a> MyCat下载安装</h3><p><strong>下载mycat</strong></p><p>github地址：<a href="https://github.com/MyCATApache">https://github.com/MyCATApache</a></p><p><strong>Mycat安装</strong></p><p>安装rz上传文件工具</p><pre><code class="highlight plaintext">yum install -y lrzsz</code></pre><p>第一步：把MyCat的压缩包上传到linux服务器</p><p>第二步：解压缩，得到mycat目录</p><pre><code class="highlight plaintext">tar -zxvf Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz</code></pre><p>第三步：进入mycat/bin，启动MyCat</p><pre><code class="highlight plaintext">启动命令：./mycat start停止命令：./mycat stop重启命令：./mycat restart</code></pre><blockquote><p>注意：可以使用mysql的客户端直接连接mycat服务。<strong>默认服务端口为8066</strong></p></blockquote><h3 id="mycat分片"><a class="markdownIt-Anchor" href="#mycat分片"></a> MyCat分片</h3><p><strong>需求</strong></p><p>把商品表分片存储到三个数据节点上</p><p><strong>安装环境</strong></p><p>mysql节点1环境</p><ul><li>操作系统版本 : centos6.5</li><li>数据库版本 : mysql-5.6</li><li>mycat版本 ：1.6 release</li><li>数据库名 : db1、db2、db3</li><li>ip：192.168.10.133</li></ul><p>MyCat安装到节点192.168.10.134上（需要安装jdk）</p><h4 id="配置schemaxml"><a class="markdownIt-Anchor" href="#配置schemaxml"></a> 配置Schema.xml</h4><p><strong>Schema.xml介绍</strong></p><p>Schema.xml作为MyCat中重要的配置文件之一，<em>管理着MyCat的逻辑库、表、分片规则、DataNode以及DataSource</em>。弄懂这些配置，是正确使用MyCat的前提。这里就一层层对该文件进行解析。</p><p>schema 标签用于定义MyCat实例中的逻辑库</p><p>Table 标签定义了MyCat中的逻辑表</p><p>dataNode 标签定义了MyCat中的数据节点，也就是我们通常说所的数据分片。</p><p>dataHost标签在mycat逻辑库中也是作为最底层的标签存在，直接定义了具体的数据库实例、读写分离配置和心跳语句</p><blockquote><p>注意：若是LINUX版本的MYSQL，则需要设置为Mysql大小写不敏感，否则可能会发生表找不到的问题。</p></blockquote><pre><code class="highlight plaintext">在MySQL的配置文件中my.ini [mysqld] 中增加一行ower_case_table_names = 1</code></pre><p><strong>Schema.xml配置</strong></p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">mycat</span>:schema <span class="keyword">SYSTEM</span> <span class="string">&quot;schema.dtd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://org.opencloudb/&quot;</span>&gt;</span><span class="comment">&lt;!--schema name相当于数据库名--&gt;</span><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;TESTDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="comment">&lt;!-- auto sharding by id (long) --&gt;</span><span class="comment">&lt;!-- </span><span class="comment">name:定义表名</span><span class="comment">dataNode:表示把该表分配到dn1/dn2/dn3三个节点上</span><span class="comment">rule：表示切片规则,切片规则在rule.xml中配置--&gt;</span><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;item&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-long&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;TB_USER&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;ID&quot;</span> <span class="attr">type</span>=<span class="string">&quot;global&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">schema</span>&gt;</span><span class="comment">&lt;!-- </span><span class="comment">配置节点在哪个主机dataHost上</span><span class="comment">database:表示真正的数据库名</span><span class="comment">--&gt;</span><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db1&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localhost2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db2&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db3&quot;</span> /&gt;</span><span class="comment">&lt;!--配置主机dataHost--&gt;</span><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span><span class="tag"><span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="comment">&lt;!--心跳检测语法--&gt;</span><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span><span class="comment">&lt;!-- can have multi write hosts --&gt;</span><span class="comment">&lt;!-- 读写分离的配置方法 --&gt;</span><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.25.134:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span><span class="tag"><span class="attr">password</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="comment">&lt;!-- can have multi read hosts --&gt;</span><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;hostS2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.1.200:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;xxx&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span><span class="comment">&lt;!-- 普通分片配置方法 --&gt;</span><span class="comment">&lt;!--mycat真正要连的数据库--&gt;</span><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.10.133:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span><span class="tag"><span class="attr">password</span>=<span class="string">&quot;root&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;localhost2&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span><span class="tag"><span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span><span class="comment">&lt;!-- can have multi write hosts --&gt;</span><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.25.166:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span><span class="tag"><span class="attr">password</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="comment">&lt;!-- can have multi read hosts --&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></code></pre><h4 id="配置serverxml"><a class="markdownIt-Anchor" href="#配置serverxml"></a> 配置Server.xml</h4><p><strong>Server.xml配置</strong></p><p>server.xml几乎保存了所有mycat需要的系统配置信息。最常用的是在此配置用户名、密码及权限。</p><ul><li>指定别人连接mycat用的用户名和密码</li><li>schemas：需要和schema.xml中的schema name一致</li></ul><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;readOnly&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></code></pre><h4 id="配置rulexml"><a class="markdownIt-Anchor" href="#配置rulexml"></a> 配置rule.xml</h4><p><strong>rule.xml配置</strong></p><p>rule.xml里面就定义了我们对表进行拆分所涉及到的规则定义。我们可以灵活的对表使用不同的分片算法，或者对表使用相同的算法但具体的参数不同。这个文件里面主要有tableRule和function这两个标签。在具体使用过程中可以按照需求添加tableRule和function。</p><p><u>此配置文件可以不用修改，使用默认即可</u>。</p><blockquote><p>最好保证规则里的columns中的字段名和数据库主键的字段名一致</p></blockquote><h4 id="测试分片"><a class="markdownIt-Anchor" href="#测试分片"></a> 测试分片</h4><p><strong>测试分片</strong></p><p>配置完毕后，重新启动mycat。使用mysql客户端连接mycat，创建表</p><pre><code class="highlight sql"><span class="comment">-- ----------------------------</span><span class="comment">-- Table structure for tb_item</span><span class="comment">-- ----------------------------</span><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `tb_item`;<span class="keyword">CREATE TABLE</span> `tb_item` (  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;商品id，同时也是商品编号&#x27;</span>,  `title` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;商品标题&#x27;</span>,  `sell_point` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品卖点&#x27;</span>,  `price` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;商品价格，单位为：分&#x27;</span>,  `num` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;库存数量&#x27;</span>,  `barcode` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品条形码&#x27;</span>,  `image` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品图片&#x27;</span>,  `cid` <span class="type">bigint</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;所属类目，叶子类目&#x27;</span>,  `status` tinyint(<span class="number">4</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;商品状态，1-正常，2-下架，3-删除&#x27;</span>,  `created` datetime <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,  `updated` datetime <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,  <span class="keyword">PRIMARY KEY</span> (`id`),  KEY `cid` (`cid`),  KEY `status` (`status`),  KEY `updated` (`updated`)) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;商品表&#x27;</span>;<span class="comment">-- ----------------------------</span><span class="comment">-- Table structure for tb_user</span><span class="comment">-- ----------------------------</span><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `tb_user`;<span class="keyword">CREATE TABLE</span> `tb_user` (  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT,  `username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,  `password` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;密码，加密存储&#x27;</span>,  `phone` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;注册手机号&#x27;</span>,  `email` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;注册邮箱&#x27;</span>,  `created` datetime <span class="keyword">NOT NULL</span>,  `updated` datetime <span class="keyword">NOT NULL</span>,  <span class="keyword">PRIMARY KEY</span> (`id`),  <span class="keyword">UNIQUE</span> KEY `username` (`username`) <span class="keyword">USING</span> BTREE,  <span class="keyword">UNIQUE</span> KEY `phone` (`phone`) <span class="keyword">USING</span> BTREE,  <span class="keyword">UNIQUE</span> KEY `email` (`email`) <span class="keyword">USING</span> BTREE) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">37</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</code></pre><p>插入数据</p><pre><code class="highlight sql"><span class="comment">/*</span><span class="comment">Navicat MySQL Data Transfer</span><span class="comment"></span><span class="comment">Source Server         : localhost_3306</span><span class="comment">Source Server Version : 50521</span><span class="comment">Source Host           : localhost:3306</span><span class="comment">Source Database       : taotao</span><span class="comment"></span><span class="comment">Target Server Type    : MYSQL</span><span class="comment">Target Server Version : 50521</span><span class="comment">File Encoding         : 65001</span><span class="comment"></span><span class="comment">Date: 2015-12-20 15:56:27</span><span class="comment">*/</span><span class="comment">-- ----------------------------</span><span class="comment">-- Records of tb_item</span><span class="comment">-- ----------------------------</span><span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;536563&#x27;</span>, <span class="string">&#x27;new2 - 阿尔卡特 (OT-927) 炭黑 联通3G手机 双卡双待&#x27;</span>, <span class="string">&#x27;清仓！仅北京，武汉仓有货！&#x27;</span>, <span class="string">&#x27;29900000&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;http://image.taotao.com/jd/4ef8861cf6854de9889f3db9b24dc371.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:33:18&#x27;</span>, <span class="string">&#x27;2015-04-11 20:38:38&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;562379&#x27;</span>, <span class="string">&#x27;new8- 三星 W999 黑色 电信3G手机 双卡双待双通&#x27;</span>, <span class="string">&#x27;下单送12000毫安移动电源！双3.5英寸魔焕炫屏，以非凡视野纵观天下时局，尊崇翻盖设计，张弛中，尽显从容气度！&#x27;</span>, <span class="string">&#x27;1100&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;http://image.taotao.com/jd/d2ac340e728d4c6181e763e772a9944a.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:54&#x27;</span>, <span class="string">&#x27;2015-04-12 17:10:43&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;605616&#x27;</span>, <span class="string">&#x27;阿尔卡特 (OT-979) 冰川白 联通3G手机&#x27;</span>, <span class="string">&#x27;清仓！仅上海仓有货！&#x27;</span>, <span class="string">&#x27;30900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/a69d0d09a1a04164969c2d0369659b1a.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:33:18&#x27;</span>, <span class="string">&#x27;2015-03-08 21:33:18&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;635906&#x27;</span>, <span class="string">&#x27;阿尔卡特 (OT-927) 单电版 炭黑 联通3G手机 双卡双待&#x27;</span>, <span class="string">&#x27;清仓！仅北京，武汉仓有货！&#x27;</span>, <span class="string">&#x27;24900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/9c1fcdf2bf20450788195c707da00a87.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:33:18&#x27;</span>, <span class="string">&#x27;2015-03-08 21:33:18&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;679532&#x27;</span>, <span class="string">&#x27;阿尔卡特 (OT-986+) 玫红 AK47 加强版 联通3G手机&#x27;</span>, <span class="string">&#x27;仅上海，广州，沈阳仓有货！预购从速！&#x27;</span>, <span class="string">&#x27;49900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/65e2007d41dc4e3cb308833a1a910f8d.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:32:31&#x27;</span>, <span class="string">&#x27;2015-03-08 21:32:31&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;679533&#x27;</span>, <span class="string">&#x27;阿尔卡特 (OT-986+) 曜石黑 AK47 加强版 联通3G手机&#x27;</span>, <span class="string">&#x27;少量库存，抢完即止！&lt;a  target=\&quot;blank\&quot;  href=\&quot;http://sale.jd.com/act/bxYeI1346g.html?erpad_source=erpad\&quot;&gt;“领券更优惠！”&lt;/a&gt;&#x27;</span>, <span class="string">&#x27;49900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/b3251c85da8e4302b7389f3371dd0a68.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:31:36&#x27;</span>, <span class="string">&#x27;2015-03-08 21:31:36&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;691300&#x27;</span>, <span class="string">&#x27;三星 B9120 钛灰色 联通3G手机 双卡双待双通&#x27;</span>, <span class="string">&#x27;下单即送10400毫安移动电源！再赠手机魔法盒！&#x27;</span>, <span class="string">&#x27;439900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/c1775819c7e44b1c903f27514e70b998.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:29:27&#x27;</span>, <span class="string">&#x27;2015-03-08 21:29:27&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;738388&#x27;</span>, <span class="string">&#x27;三星 Note II (N7100) 云石白 联通3G手机&#x27;</span>, <span class="string">&#x27;经典回顾！超值价格值得拥有。&#x27;</span>, <span class="string">&#x27;169900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/089b79cbe19f454dab24cce65f2e9602.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:16&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:16&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;741524&#x27;</span>, <span class="string">&#x27;三星 Note II (N7100) 钛金灰 联通3G手机&#x27;</span>, <span class="string">&#x27;下单赠12000毫安移动电源&#x27;</span>, <span class="string">&#x27;169900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/29e1b92dc7e146489ce46a2262479a0f.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:30&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:30&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;816448&#x27;</span>, <span class="string">&#x27;三星 Note II (N7100) 钻石粉 联通3G手机&#x27;</span>, <span class="string">&#x27;经典回顾！超值特惠！&#x27;</span>, <span class="string">&#x27;169900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/5a45e88aeca046ec88d7b7ffbc47092a.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:44&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:44&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;816753&#x27;</span>, <span class="string">&#x27;夏普（SHARP）LCD-46DS40A 46英寸 日本原装液晶面板 智能全高清液晶电视&#x27;</span>, <span class="string">&#x27;要好屏，选夏普！日本原装面板，智能电视，高画质高音质！&lt;a  target=\&quot;blank\&quot;  href=\&quot;http://item.jd.com/1278686.html\&quot;&gt;还有升级版安卓智能新机46DS52供您选择！&lt;/a&gt;&#x27;</span>, <span class="string">&#x27;379900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/2e45ff47f2e7424cb6d95fb9f05151bd.jpg&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:39&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:39&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;830972&#x27;</span>, <span class="string">&#x27;飞利浦 老人手机 (X2560) 深情蓝 移动联通2G手机 双卡双待&#x27;</span>, <span class="string">&#x27;赠：九安血压计+8G内存！超长待机，关爱无限，更好用！飞利浦简单健康老人手机！外观圆滑，手感极佳！&#x27;</span>, <span class="string">&#x27;48900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/4f1d41baa6c84219a622f20a4f1c32bb.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:30&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:30&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;832739&#x27;</span>, <span class="string">&#x27;中兴 U288 珠光白 移动3G手机&#x27;</span>, <span class="string">&#x27;好评过万！超大彩屏，超大字体，超大按键，超大音量，一键SOS紧急呼叫 ！&#x27;</span>, <span class="string">&#x27;19900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/4021f8a1ffcc4ae2a313c2012d9f35c8.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:44&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:44&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;844022&#x27;</span>, <span class="string">&#x27;三星 SCH-W899 亮金色 电信3G手机 双卡双待双通&#x27;</span>, <span class="string">&#x27;双3.3英寸魔焕炫屏，CG双网双待，臻尊体验，心系天下！&#x27;</span>, <span class="string">&#x27;299900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/e638243d8341474293be09ad157546b8.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:01&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:01&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;847276&#x27;</span>, <span class="string">&#x27;飞利浦 老人手机 (X2560) 喜庆红 移动联通2G手机 双卡双待&#x27;</span>, <span class="string">&#x27;超长待机，关爱无限，更好用！飞利浦简单健康老人手机！外观圆滑，手感极佳！&#x27;</span>, <span class="string">&#x27;48900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/657c61e5018043f89d9fe0f9a1519884.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:30&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:30&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;847278&#x27;</span>, <span class="string">&#x27;飞利浦 老人手机 (X2560) 硬朗黑 移动联通2G手机 双卡双待&#x27;</span>, <span class="string">&#x27;超长待机，关爱无限，更好用！飞利浦简单健康老人手机！外观圆滑，手感极佳！&#x27;</span>, <span class="string">&#x27;46900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/306b2287ce1c4b3bb541f37984d67929.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:09&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:09&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;855739&#x27;</span>, <span class="string">&#x27;三星 Galaxy S4 (I9500)16G版 皓月白 联通3G手机&#x27;</span>, <span class="string">&#x27;三星经典旗舰机！5英寸1080P高清屏+1300万像素主摄像头！&#x27;</span>, <span class="string">&#x27;188800&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/c687f304b5164b1b84736b9a4d34a37c.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:42&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:42&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;856645&#x27;</span>, <span class="string">&#x27;三星 Galaxy S4 (I9500) 16G版 星空黑 联通3G手机&#x27;</span>, <span class="string">&#x27;年货特价来袭！三星经典旗舰机！&#x27;</span>, <span class="string">&#x27;188800&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/2cd67c806e054435bce4c931a731493a.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:54&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:54&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;858025&#x27;</span>, <span class="string">&#x27;三星 I8552 白色 联通3G手机 双卡双待&#x27;</span>, <span class="string">&#x27;经济实惠机器~~开春入手好时机~&#x27;</span>, <span class="string">&#x27;79900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/d958a21cec814fdeab934d43b4fb2e06.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:49&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:49&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;860275&#x27;</span>, <span class="string">&#x27;长虹（CHANGHONG） 3D51C1080i 51英寸 快门式3D智能Android 电视（黑色）&#x27;</span>, <span class="string">&#x27;智能安卓系统 可自由安装应用程序 &lt;a  target=\&quot;blank\&quot;  href=\&quot;http://sale.jd.com/act/Kt0aHzbU7uR1M.html\&quot;&gt;“点击进入长虹新年专场”&lt;/a&gt;&#x27;</span>, <span class="string">&#x27;269900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/08dabc37342943ffb717632f9ee40685.jpg&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:35&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:35&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;868462&#x27;</span>, <span class="string">&#x27;LG 47LA6800-CA 47英寸 全高清智能3D液晶电视 （红色）&#x27;</span>, <span class="string">&#x27;【疯狂清仓】无边框硬屏，不闪式3D技术，动感应遥控器，“船”型底座设计！仅北京、沈阳、深圳有货！&#x27;</span>, <span class="string">&#x27;999900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/914ba6a287044e0d897a6cded583c8ac.jpg&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:29:12&#x27;</span>, <span class="string">&#x27;2015-03-08 21:29:12&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;875722&#x27;</span>, <span class="string">&#x27;诺基亚(NOKIA) 1050 (RM-908) 黑色 移动联通2G手机&#x27;</span>, <span class="string">&#x27;经典神器，简单实用,超长待机，更多色彩！&#x27;</span>, <span class="string">&#x27;14900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/902958f543874a4caed08045c96dcf30.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:49&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:49&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;875724&#x27;</span>, <span class="string">&#x27;诺基亚(NOKIA) 1050 (RM-908) 蓝色 移动联通2G手机&#x27;</span>, <span class="string">&#x27;经典神器，简单实用,超长待机，更多色彩！&#x27;</span>, <span class="string">&#x27;14900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/625735ae97524f77bc9e0ab39e0d2a2b.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:54&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:54&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;883893&#x27;</span>, <span class="string">&#x27;联想 MA388 老人手机 星夜黑 移动联通2G手机 双卡双待&#x27;</span>, <span class="string">&#x27;孝敬爸妈首选，好评超22000条，大按键 大喇叭 大翻盖，配置1900mAh大容量电池，带来超长续航体验！&#x27;</span>, <span class="string">&#x27;28700&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/ee56ceae4466431cb5c1bed035203a4b.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:49&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:49&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;907012&#x27;</span>, <span class="string">&#x27;海信（Hisense）LED42EC260JD 42英寸 窄边网络 LED电视（黑色）&#x27;</span>, <span class="string">&#x27;&lt;a  target=\&quot;blank\&quot;  href=\&quot;http://sale.jd.com/act/YykdEtrMRaSsT.html\&quot;&gt;“春宵一刻值千金”&lt;/a&gt;&#x27;</span>, <span class="string">&#x27;229900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/38406d85be2e4e3eb81b934df63e5ced.jpg&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:35&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:35&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;909245&#x27;</span>, <span class="string">&#x27;酷派 8076D 咖啡棕 移动3G手机 双卡双待&#x27;</span>, <span class="string">&#x27;4.0英寸屏幕，双核处理器！移动用户无需换号，直接尊享3G网络！&#x27;</span>, <span class="string">&#x27;19900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/a1df8eaa64774b498a2ba9457fd60190.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:29:19&#x27;</span>, <span class="string">&#x27;2015-03-08 21:29:19&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;912107&#x27;</span>, <span class="string">&#x27;创维(Skyworth)LED 42E5DHR 42英寸 海量影视资源智能网络平板液晶电视二代升级版(黑色)&#x27;</span>, <span class="string">&#x27;二代新品！！智能双系统，正版影视随心看，丰富安卓应用，多屏互动！&lt;a  target=\&quot;blank\&quot;  href=\&quot;http://jmall.jd.com/p117514.html\&quot;&gt;“猛戳这里，更多惊喜”&lt;/a&gt;&#x27;</span>, <span class="string">&#x27;249900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/ff78fea47d20439a8e2bb837caed7384.jpg&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:39&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:39&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;915676&#x27;</span>, <span class="string">&#x27;联想 P780 极速版 深邃黑 联通3G手机 双卡双待&#x27;</span>, <span class="string">&#x27;待机王，5吋HD高清炫屏，9.9mm锐薄机身，背壳全金属材质，独创智恒省电技术！&#x27;</span>, <span class="string">&#x27;69900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/8886d8cac9204d34beee17de09a94124.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:09&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:09&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;917460&#x27;</span>, <span class="string">&#x27;华为 P6 (P6-C00) 黑 电信3G手机 双卡双待双通&#x27;</span>, <span class="string">&#x27;经典旗舰！雅然天成纤薄之美，强悍四核，前置500万美颜自拍,，2GB RAM+16GB ROM大内存！&lt;a  target=\&quot;blank\&quot;  href=\&quot;http://sale.jd.com/act/0akd8u5vomz.html\&quot;&gt;【买卡上京东，省钱又轻松】点击有惊喜！&lt;/a&gt;&#x27;</span>, <span class="string">&#x27;128800&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/e6fa8fe64cad49ff93fe0af67ac52055.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:42&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:42&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;917461&#x27;</span>, <span class="string">&#x27;华为 P6 (P6-C00) 白 电信3G手机 双卡双待双通&#x27;</span>, <span class="string">&#x27;经典旗舰，万人好评！强悍四核，前置500万美颜自拍,，2GB RAM+16GB ROM大内存！&#x27;</span>, <span class="string">&#x27;129900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/a898d6b93e124a6bb26d58254a112250.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:37&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:37&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;917770&#x27;</span>, <span class="string">&#x27;华为 P6-C00 电信3G手机（粉色） CDMA2000/GSM 双模双待双通&#x27;</span>, <span class="string">&#x27;情人节神器！粉色机身，女神必备！数量有限前置500万美颜自拍，后置800万，非常适合喜欢拍照的你！&#x27;</span>, <span class="string">&#x27;134900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/ced8afd1b8d64134aa211aceb85fb3c5.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:54&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:54&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;919669&#x27;</span>, <span class="string">&#x27;华为 Ascend P6 (P6-T00) 黑色 移动3G手机&#x27;</span>, <span class="string">&#x27;限时特价！好评过万条优秀产品！浑然天成纤薄机身，前置500w摄像头，2GB RAM,1.5GHz四核cpu！ &lt;a  target=\&quot;blank\&quot;  href=\&quot;http://sale.jd.com/act/ZovfiDKYagBQJ.html\&quot;&gt;更多推荐请点击！&lt;/a&gt;&#x27;</span>, <span class="string">&#x27;128900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/a4585c63d2de4c22b7fab8e57bfb4b63.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:37&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:37&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;925237&#x27;</span>, <span class="string">&#x27;三星 Galaxy S4 (I9502) 16G版 蓝色 联通3G手机 双卡双待双通&#x27;</span>, <span class="string">&#x27;三星经典旗舰机！5英寸1080P高清屏+双四核分时CUP+2GB RAM+1300万像素主摄像头&#x27;</span>, <span class="string">&#x27;189900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/c2b4eb2e623a415091a0e1fafac80aad.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:01&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:01&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;927779&#x27;</span>, <span class="string">&#x27;海尔统帅（Leader）LE39MUF5 39英寸 MHL传屏 LED平板电视（黑色）&#x27;</span>, <span class="string">&#x27;好评率96%！MHL传屏，内附价值99元的MHL传屏线哦~独家免费带货安装调试一步到位！&#x27;</span>, <span class="string">&#x27;199900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/dc3bb2ceefed4eb48bef05226005e7a6.jpg&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:29:12&#x27;</span>, <span class="string">&#x27;2015-03-08 21:29:12&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;929734&#x27;</span>, <span class="string">&#x27;三星 I8558 白色 移动3G手机 双卡双待&#x27;</span>, <span class="string">&#x27;4.7英寸屏，四核，500万像素！移动用户无需换号，直接享3G网络！&#x27;</span>, <span class="string">&#x27;75900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/13bb5a74d03642a3a043a8ec33baa6e6.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:16&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:16&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;931849&#x27;</span>, <span class="string">&#x27;飞利浦 (X1560) 黑色+香槟色 移动联通2G手机 双卡双待&#x27;</span>, <span class="string">&#x27;畅销！智能机的好伴侣，可以充电的手机！最长可达100天！键盘金属工艺，移动电源功能！&#x27;</span>, <span class="string">&#x27;36900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/691c77d0ed13417da7cf59b8bd1e3bab.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:16&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:16&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;936920&#x27;</span>, <span class="string">&#x27;夏普（SHARP）LCD-52DS70A 52英寸 日本原装液晶面板 3D Android操作系统智能液晶电视&#x27;</span>, <span class="string">&#x27;安卓体感3D超强机！日本原装液晶屏 安卓智能 体感遥控器 智能语音 无线上网！&lt;a  target=\&quot;blank\&quot;  href=\&quot;http://item.jd.com/1134535.html\&quot;&gt;还有外观炫酷的50英寸50DS60供您选择！&lt;/a&gt;&#x27;</span>, <span class="string">&#x27;699900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/c3ada90aec234ac9bc2589fbd40c9918.jpg&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:00&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:00&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;941189&#x27;</span>, <span class="string">&#x27;TCL L32F3301B 32英寸 窄边蓝光USB播放LED电视(黑色）&#x27;</span>, <span class="string">&#x27;【0元献礼】好评过万，销量传奇！经典蓝光电视，独有自然光技术专利，过大年带最好的回家！&lt;a  target=\&quot;blank\&quot;  href=\&quot;http://sale.jd.com/act/6MqRytIYKfn.html\&quot;&gt;【0元白条试用，1001个拜年计划】&lt;/a&gt;&#x27;</span>, <span class="string">&#x27;139800&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/cda1219a38504f798b0413816d785d08.jpg&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:35&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:35&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;951305&#x27;</span>, <span class="string">&#x27;三星 Galaxy S4 (I9502) 16G版 粉色 联通3G手机 双卡双待双通&#x27;</span>, <span class="string">&#x27;三星经典旗舰机！5英寸1080P高清屏+双四核分时CUP+2GB RAM+1300万像素主摄像头&#x27;</span>, <span class="string">&#x27;179900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/11146d519c4c4f1bbc3f2e8fd0d5beaf.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:01&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:01&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;960138&#x27;</span>, <span class="string">&#x27;三星 I8558 灰色 移动3G手机 双卡双待&#x27;</span>, <span class="string">&#x27;4.7英寸屏，四核，500万像素！移动用户无需换号，直接享3G网络!&#x27;</span>, <span class="string">&#x27;75900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/8f3550c928d64484accf4c74d606a93e.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:55&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:55&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;967021&#x27;</span>, <span class="string">&#x27;TCL 老人手机 (i310) 暗夜黑 移动联通2G手机&#x27;</span>, <span class="string">&#x27;爸妈满意才最好，大字体，大按键，大声音，简单易用的老人手机！&#x27;</span>, <span class="string">&#x27;19900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/67eb54bcdbc949ecaa32cbd725a223b6.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:49&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:49&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;968097&#x27;</span>, <span class="string">&#x27;长虹（CHANGHONG） LED32C2JDi 32英寸 安卓智能LED液晶电视（黑色）&#x27;</span>, <span class="string">&#x27;智能安卓系统！内置WiFi!遥控器一键直达京东！&lt;a  target=\&quot;blank\&quot;  href=\&quot;http://sale.jd.com/act/Kt0aHzbU7uR1M.html\&quot;&gt;“点击进入长虹新年专场”&lt;/a&gt;&#x27;</span>, <span class="string">&#x27;149900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/7d2563f664a54aaf8e7fe0b7af52a118.jpg&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:35&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:35&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;968184&#x27;</span>, <span class="string">&#x27;索尼(SONY) Xperia Z1 (L39h) 黑色 联通3G手机&#x27;</span>, <span class="string">&#x27;特价抢购！骁龙800四核CPU，2070万像素G镜头，特丽魅彩显像技术，IP55/IP58精密防尘、防水！&#x27;</span>, <span class="string">&#x27;193800&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/368d56e845074ed1803cfcfa8751cc4f.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:49&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:49&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;968185&#x27;</span>, <span class="string">&#x27;索尼(SONY) Xperia Z1 (L39h) 白色 联通3G手机&#x27;</span>, <span class="string">&#x27;特价抢购！骁龙800四核CPU，2070万像素G镜头，特丽魅彩显像技术，IP55/IP58精密防尘、防水！&#x27;</span>, <span class="string">&#x27;193800&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/7668edd983f1486ab87eee9c471f82cc.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:54&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:54&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;968188&#x27;</span>, <span class="string">&#x27;索尼(SONY) Xperia Z1 (L39h) 紫色 联通3G手机&#x27;</span>, <span class="string">&#x27;特价抢购！骁龙800四核CPU，2070万像素G镜头，特丽魅彩显像技术，IP55/IP58精密防尘、防水！&#x27;</span>, <span class="string">&#x27;192800&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/6a03dd6a019c4f4ea897ab7050955b17.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:49&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:49&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;968189&#x27;</span>, <span class="string">&#x27;索尼(SONY) Xperia Z Ultra (XL39h) 黑色 联通3G手机&#x27;</span>, <span class="string">&#x27;手机看视频首选跨界神器，巨屏+四核强芯，超薄防水机身！我的世界又大又轻巧！&#x27;</span>, <span class="string">&#x27;169800&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/b525167a86c944fe9dbdacb07f0e86df.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:49&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:49&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;968191&#x27;</span>, <span class="string">&#x27;索尼(SONY) Xperia Z Ultra (XL39h) 紫色 联通3G手机&#x27;</span>, <span class="string">&#x27;清仓！手机看视频首选跨界神器，巨屏+四核强芯，超薄防水机身！我的世界又大又轻巧！&lt;a  target=\&quot;blank\&quot;  href=\&quot;http://sale.jd.com/act/VQgfU7HPk5jAD.html\&quot;&gt;更多选择！请点击》&lt;/a&gt;&#x27;</span>, <span class="string">&#x27;177800&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/e93eac74e90a49098266078c23136459.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:31:50&#x27;</span>, <span class="string">&#x27;2015-03-08 21:31:50&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;971047&#x27;</span>, <span class="string">&#x27;联想 S820e 红色 电信3G手机 双卡双待&#x27;</span>, <span class="string">&#x27;4.7英寸1280*720高清大屏，四核强劲处理器，800万+160万摄像头，尽显时尚气质！&#x27;</span>, <span class="string">&#x27;49800&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/746ac093280c4e9ea200a63e81df435a.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:09&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:09&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;971050&#x27;</span>, <span class="string">&#x27;联想 S820e 白色 电信3G手机 双卡双待&#x27;</span>, <span class="string">&#x27;4.7英寸1280*720高清大屏，四核强劲处理器，800万主摄像头，丝绒质感涂层机身！&#x27;</span>, <span class="string">&#x27;49800&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/89a67b97915e4e93b14b201e360fe105.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:01&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:01&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;972627&#x27;</span>, <span class="string">&#x27;金立 商务翻盖 (A809) 绅士黑 联通移动2G手机 双卡双待单通&#x27;</span>, <span class="string">&#x27;时尚翻盖，精美工艺品质~&#x27;</span>, <span class="string">&#x27;59900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/73c7b6eee30a459583c5cf107c2f829b.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:16&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:16&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;973267&#x27;</span>, <span class="string">&#x27;优快（U&amp;K） U97 四防对讲手机&#x27;</span>, <span class="string">&#x27;返100元！四防手机对讲，企业通讯必备；电信天翼、深度定制、一键通全国！&#x27;</span>, <span class="string">&#x27;198000&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/82cdd90503aa4dabb2bb4e5984d6d8b4.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:33:18&#x27;</span>, <span class="string">&#x27;2015-03-08 21:33:18&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;973825&#x27;</span>, <span class="string">&#x27;飞利浦 (X5500) 奢华黑 移动联通2G手机 双卡双待&#x27;</span>, <span class="string">&#x27;超长待机！手写键盘双输入，硬朗金属设计，专属私人电台，双卡双待，奢华品质！&#x27;</span>, <span class="string">&#x27;79900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/26e4ddc64000497dbc15be0da4aab5bc.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:55&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:55&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;973862&#x27;</span>, <span class="string">&#x27;三星 Galaxy Note3 (N9009) 16G版 炫酷黑 电信3G手机 双卡双待双通&#x27;</span>, <span class="string">&#x27;京东给您发年终奖~下单即送10400毫安移动电源！&#x27;</span>, <span class="string">&#x27;309900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/c4a2e255bc954125a5d83283320a9c85.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:49&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:49&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;974401&#x27;</span>, <span class="string">&#x27;苹果(Apple) iPhone 5s (A1533) 16GB 银色 电信3G手机&#x27;</span>, <span class="string">&#x27;A7芯片，首开64位智能手机先河，Touch ID指纹识别功能！货源在途，放心订购！&lt;a  target=\&quot;blank\&quot;  href=\&quot;http://sale.jd.com/act/IvM8aG1BdW5.html\&quot;&gt;电信苹果专场！&lt;/a&gt;&#x27;</span>, <span class="string">&#x27;409900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/35c54c88f6f147aa88e788042b70e7c4.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:49&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:49&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;975023&#x27;</span>, <span class="string">&#x27;三星 Galaxy Note 3 (N9002) 简约白 联通3G手机 双卡双待双通&#x27;</span>, <span class="string">&#x27;5.7英寸高清屏 带S Pen功能 手写编辑快速简单 支持多窗口多任务&#x27;</span>, <span class="string">&#x27;279900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/41e9ad9c568a4dbc92b545e88788451f.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:37&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:37&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;975024&#x27;</span>, <span class="string">&#x27;三星 Galaxy Note 3 (N9002) 炫酷黑 联通3G手机 双卡双待双通&#x27;</span>, <span class="string">&#x27;5.7英寸高清屏 带S Pen功能 手写编辑快速简单 支持多窗口多任务&#x27;</span>, <span class="string">&#x27;279900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/e6b313f1ded44b0a9ab217cc6faf382d.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:49&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:49&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;975101&#x27;</span>, <span class="string">&#x27;长虹（CHANGHONG） LED42C2JDi 42英寸 安卓智能LED液晶电视（黑色）&#x27;</span>, <span class="string">&#x27;京东独家，操作简单，一键直达京东，海量影视！&lt;a  target=\&quot;blank\&quot;  href=\&quot;http://sale.jd.com/act/Kt0aHzbU7uR1M.html\&quot;&gt;“点击进入长虹新年专场”&lt;/a&gt;&#x27;</span>, <span class="string">&#x27;239900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/3471d33f448340c0aa5d5a11e7f0d068.jpg&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:35&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:35&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;975641&#x27;</span>, <span class="string">&#x27;苹果(Apple) iPhone 5s (A1533) 16GB 金色 电信3G手机&#x27;</span>, <span class="string">&#x27;特价抢购！A7芯片，64位智能手机，Touch ID指纹识别功能！&lt;a  target=\&quot;blank\&quot;  href=\&quot;http://sale.jd.com/act/IvM8aG1BdW5.html\&quot;&gt;电信苹果专场！&lt;/a&gt;&#x27;</span>, <span class="string">&#x27;409900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/images/6e844025-47df-4b0e-b7f3-8aea1dca24a2.jpg,http://image.taotao.com/images/82df85b6-f7ce-4ad0-88c5-45848c60c1f8.jpg,http://image.taotao.com/images/3b5ce7d0-49f7-4dcb-a934-0112f91c573d.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:42&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:42&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;976898&#x27;</span>, <span class="string">&#x27;苹果 iPhone 4S 8G 白色 联通3G手机&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;199900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/12241d5b7c044fccbc88ee6c191fd949.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:33:18&#x27;</span>, <span class="string">&#x27;2015-03-08 21:33:18&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;979072&#x27;</span>, <span class="string">&#x27;康佳（KONKA） LED42J39AW 42英寸 超薄安卓智能液晶电视（黑色）&#x27;</span>, <span class="string">&#x27;【洋洋得意抢神机】 超薄安卓智能,海量视频应用，任你拓展！&lt;a  target=\&quot;blank\&quot;  href=\&quot;http://sale.jd.com/act/IrXe3ywoUE.html\&quot;&gt;【机不可失！49英寸巨屏4K智能仅2999！】&lt;/a&gt;&#x27;</span>, <span class="string">&#x27;259800&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/527275cba3684863b6621ad33df97948.jpg&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:08&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:08&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;979281&#x27;</span>, <span class="string">&#x27;三星 W789 奢华金 电信3G手机 双卡双待双通&#x27;</span>, <span class="string">&#x27;下单送12000毫安移动电源！时尚翻盖设计，双3.3英寸触屏，四核处理器，双网双待，张弛自若，双赢人生！&#x27;</span>, <span class="string">&#x27;299900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/ebe230a9e4ff47caa32243cc5c80088a.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:01&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:01&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;981123&#x27;</span>, <span class="string">&#x27;联想 A516 荧光粉 联通3G手机 双卡双待&#x27;</span>, <span class="string">&#x27;9.9毫米轻薄机身！为女生量身打造！&#x27;</span>, <span class="string">&#x27;39900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/1166c37afdf24439a1465da589d20a4b.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:30&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:30&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;981821&#x27;</span>, <span class="string">&#x27;苹果(Apple) iPhone 4s 8GB 白色 联通3G手机&#x27;</span>, <span class="string">&#x27;iPhone中的经典，值得拥有！支持联通3G、移动/联通2G 系统版本随机&lt;a  target=\&quot;blank\&quot;  href=\&quot;http://sale.jd.com/act/1bPmvZ3nVf.html\&quot;&gt;先领券，后下单，苹果4s专享东券万张齐发&lt;/a&gt;&#x27;</span>, <span class="string">&#x27;199900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/13a8213124d4489aa411bca04ec3e68f.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:37&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:37&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;981822&#x27;</span>, <span class="string">&#x27;苹果(Apple) iPhone 4s 8GB 黑色 联通3G手机&#x27;</span>, <span class="string">&#x27;iPhone中的经典，值得拥有！支持联通3G、移动/联通2G 系统版本随机&lt;a  target=\&quot;blank\&quot;  href=\&quot;http://sale.jd.com/act/1bPmvZ3nVf.html\&quot;&gt;先领券，后下单，苹果4s专享东券万张齐发&lt;/a&gt;&#x27;</span>, <span class="string">&#x27;199900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/cb465f68fb9844cbb62cce45837848ba.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:37&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:37&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;983248&#x27;</span>, <span class="string">&#x27;诺基亚(NOKIA) 107 (RM-961) 红色 移动联通2G手机 双卡双待&#x27;</span>, <span class="string">&#x27;超值特价！诺记品质，辉煌延续！支持手电筒功能，包装内含原装耳机！&#x27;</span>, <span class="string">&#x27;16800&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/2ff73a5b4c534c1aaf392c81b4e823af.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:16&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:16&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;983252&#x27;</span>, <span class="string">&#x27;诺基亚(NOKIA) 107 (RM-961) 白色 移动联通2G手机 双卡双待&#x27;</span>, <span class="string">&#x27;超值特价！诺记品质，辉煌延续！支持手电筒功能，包装内含原装耳机！&#x27;</span>, <span class="string">&#x27;16800&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/b462a185f262461e8037c9418b39193a.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:44&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:44&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;983253&#x27;</span>, <span class="string">&#x27;诺基亚(NOKIA) 107 (RM-961) 黑色 移动联通2G手机 双卡双待&#x27;</span>, <span class="string">&#x27;超值特价！诺记品质，辉煌延续！支持手电筒功能，包装内含原装耳机！&#x27;</span>, <span class="string">&#x27;16800&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/76c67dd46faa4ccd9db8540cae48e3b3.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:09&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:09&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;983521&#x27;</span>, <span class="string">&#x27;联想 VIBE X (S960)铂雅银 联通3G手机&#x27;</span>, <span class="string">&#x27;5吋FHD炫丽高清大屏，超薄机身，1300万超强拍照配置！&#x27;</span>, <span class="string">&#x27;69900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/b47d242135dc471a8c699cf26114e691.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:01&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:01&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;985058&#x27;</span>, <span class="string">&#x27;派信（PISIN） WO1 NanoSmart 智能手表手机（蓝色）&#x27;</span>, <span class="string">&#x27;京东自营，新款可插SIM卡智能手表，原装LG屏，雅马哈解码芯片、4G内存、支持和安卓、IOS手机配对！&#x27;</span>, <span class="string">&#x27;35000&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/bbde56f5ccaf489eb24e1760a4b22756.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:31:27&#x27;</span>, <span class="string">&#x27;2015-03-08 21:31:27&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;985059&#x27;</span>, <span class="string">&#x27;派信（PISIN） WO1 NanoSmart 智能手表手机（红色）&#x27;</span>, <span class="string">&#x27;京东自营，新款可插SIM卡智能手表，原装LG屏，雅马哈解码芯片、4G内存、支持和安卓、IOS手机配对！&#x27;</span>, <span class="string">&#x27;35000&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/22ae33eb4dd24f0bb0c8f467367647d6.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:31:27&#x27;</span>, <span class="string">&#x27;2015-03-08 21:31:27&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;988634&#x27;</span>, <span class="string">&#x27;长虹（CHANGHONG）LED39C2080i 39英寸智能安卓LED液晶电视（黑色）&#x27;</span>, <span class="string">&#x27;无线WiFi,强劲机芯，海量应用!&lt;a  target=\&quot;blank\&quot;  href=\&quot;http://sale.jd.com/act/Kt0aHzbU7uR1M.html\&quot;&gt;“点击进入长虹新年专场”&lt;/a&gt;&#x27;</span>, <span class="string">&#x27;199900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/3c3f9a9346294ab280f26b8b9a6e5cc2.jpg&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:39&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:39&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;988753&#x27;</span>, <span class="string">&#x27;联想 A516 白色 联通3G手机 双卡双待&#x27;</span>, <span class="string">&#x27;9.9毫米轻薄机身，双卡双待，为女生量身打造！&#x27;</span>, <span class="string">&#x27;39900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/d70ba3808ad541b9a0ddcea47cc62ea6.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:09&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:09&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;988833&#x27;</span>, <span class="string">&#x27;诺基亚(NOKIA) 108 (RM-944) 黑色 移动联通2G手机 双卡双待&#x27;</span>, <span class="string">&#x27;小机器，大能耐！防尘键盘，超长待机！诺记品质，辉煌延续！诺基亚最便宜的拍照功能机！&#x27;</span>, <span class="string">&#x27;18900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/d41b3a3ab0dd496dac807c803e04171e.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:55&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:55&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;988834&#x27;</span>, <span class="string">&#x27;诺基亚(NOKIA) 108 (RM-944) 红色 移动联通2G手机 双卡双待&#x27;</span>, <span class="string">&#x27;小机器，大能耐！防尘键盘，超长待机！诺记品质，辉煌延续！诺基亚最便宜的拍照功能机！&#x27;</span>, <span class="string">&#x27;18900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/46240ac1fb794c3989c2fc60d734504d.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:29:19&#x27;</span>, <span class="string">&#x27;2015-03-08 21:29:19&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;989026&#x27;</span>, <span class="string">&#x27;酷派 7231 黑色 联通3G手机 双卡双待&#x27;</span>, <span class="string">&#x27;4.0英寸高清大屏，双核1.3GHz高速CPU，畅享21M极速上网！&#x27;</span>, <span class="string">&#x27;25900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/481be30882144a82a2db7a2a905d1496.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:29:11&#x27;</span>, <span class="string">&#x27;2015-03-08 21:29:11&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;990723&#x27;</span>, <span class="string">&#x27;TCL LE50D59 50英寸 超窄边内置WIFI安卓智能液晶电视（黑色）&#x27;</span>, <span class="string">&#x27;【0元献礼】抢！抢！抢！50英寸大板安卓神机，库存倒计时，性价比首选，买到就赚！！&lt;a  target=\&quot;blank\&quot;  href=\&quot;http://sale.jd.com/act/6MqRytIYKfn.html\&quot;&gt;【0元白条试用，1001个拜年计划】&lt;/a&gt;&#x27;</span>, <span class="string">&#x27;329900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/b81e05f917464c67879d3f893175c133.jpg&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:08&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:08&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;990724&#x27;</span>, <span class="string">&#x27;TCL LE32D59 32英寸 安卓4.0 超窄边智能LED液晶电视（黑色）&#x27;</span>, <span class="string">&#x27;【0元献礼】爆！爆！爆！开放式安卓神器。云端影视，尽享不停。客厅新宠，“潮”我看齐！&lt;a  target=\&quot;blank\&quot;  href=\&quot;http://sale.jd.com/act/6MqRytIYKfn.html\&quot;&gt;【0元白条试用，1001个拜年计划】&lt;/a&gt;&#x27;</span>, <span class="string">&#x27;159800&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/7c5d6ba2251f4b75817b708536dffc17.jpg&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:39&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:39&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;997643&#x27;</span>, <span class="string">&#x27;长虹（CHANGHONG）LED50C2080i 50英寸智能安卓LED液晶电视（黑色）&#x27;</span>, <span class="string">&#x27;智能安卓系统，可自由安装应用程序，让您的电视无所不能！&lt;a  target=\&quot;blank\&quot;  href=\&quot;http://sale.jd.com/act/Kt0aHzbU7uR1M.html\&quot;&gt;“点击进入长虹新年专场”&lt;/a&gt;&#x27;</span>, <span class="string">&#x27;339900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/4055ccf141a143c99a6d51e9107f96c1.jpg&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:39&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:39&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;997966&#x27;</span>, <span class="string">&#x27;诺基亚(NOKIA) 106 (RM-962) 红色 移动联通2G手机&#x27;</span>, <span class="string">&#x27;小机器，大能耐！防尘键盘，超长待机！支持FM收音机，手电筒功能！&#x27;</span>, <span class="string">&#x27;14900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/28085e4542e6433f80e69338327423be.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:30&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:30&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;997967&#x27;</span>, <span class="string">&#x27;诺基亚(NOKIA) 106 (RM-962) 黑色 移动联通2G手机&#x27;</span>, <span class="string">&#x27;小机器，大能耐！防尘键盘，超长待机！支持FM收音机，手电筒功能！&#x27;</span>, <span class="string">&#x27;14900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/f22fd70d7d26492e88e3368e6d528779.jpg&#x27;</span>, <span class="string">&#x27;560&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:16&#x27;</span>, <span class="string">&#x27;2015-03-08 21:28:16&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_ITEM(ID,TITLE,SELL_POINT,PRICE,NUM,BARCODE,IMAGE,CID,STATUS,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;998692&#x27;</span>, <span class="string">&#x27;夏普（SHARP）LCD-52DS51A 52英寸 日本原装液晶面板 内置WIFI智能全高清液晶电视&#x27;</span>, <span class="string">&#x27;要好屏，选夏普！日本原装面板，智能电视，高画质高音质！&lt;a  target=\&quot;blank\&quot;  href=\&quot;http://item.jd.com/1278664.html\&quot;&gt;还有升级版安卓智能新机52DS52供您选择！&lt;/a&gt;&#x27;</span>, <span class="string">&#x27;549900&#x27;</span>, <span class="string">&#x27;99999&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;http://image.taotao.com/jd/63af01c37a18454ab2fef4670046272e.jpg&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:45&#x27;</span>, <span class="string">&#x27;2015-03-08 21:27:45&#x27;</span>);<span class="comment">-- ----------------------------</span><span class="comment">-- Records of tb_user</span><span class="comment">-- ----------------------------</span><span class="keyword">INSERT INTO</span> TB_USER(ID,USERNAME,PASSWORD,PHONE,EMAIL,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>, <span class="string">&#x27;13488888888&#x27;</span>, <span class="string">&#x27;aa@a&#x27;</span>, <span class="string">&#x27;2015-04-06 17:03:55&#x27;</span>, <span class="string">&#x27;2015-04-06 17:03:55&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_USER(ID,USERNAME,PASSWORD,PHONE,EMAIL,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;zhangsan1&#x27;</span>, <span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>, <span class="string">&#x27;13333333333&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;2015-04-07 10:32:08&#x27;</span>, <span class="string">&#x27;2015-04-07 10:32:08&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_USER(ID,USERNAME,PASSWORD,PHONE,EMAIL,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;zhangsan2&#x27;</span>, <span class="string">&#x27;195d91be1e3ba6f1c857d46f24c5a454&#x27;</span>, <span class="string">&#x27;13333333334&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;2015-04-07 10:33:37&#x27;</span>, <span class="string">&#x27;2015-04-07 10:33:37&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_USER(ID,USERNAME,PASSWORD,PHONE,EMAIL,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;zhangsan3&#x27;</span>, <span class="string">&#x27;195d91be1e3ba6f1c857d46f24c5a454&#x27;</span>, <span class="string">&#x27;13333333335&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;2015-04-07 10:35:57&#x27;</span>, <span class="string">&#x27;2015-04-07 10:35:57&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_USER(ID,USERNAME,PASSWORD,PHONE,EMAIL,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;zhangsan5&#x27;</span>, <span class="string">&#x27;195d91be1e3ba6f1c857d46f24c5a454&#x27;</span>, <span class="string">&#x27;13333333336&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;2015-04-07 10:46:19&#x27;</span>, <span class="string">&#x27;2015-04-07 10:46:19&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_USER(ID,USERNAME,PASSWORD,PHONE,EMAIL,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;14&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;202cb962ac59075b964b07152d234b70&#x27;</span>, <span class="string">&#x27;12344444444&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;2015-06-19 10:02:11&#x27;</span>, <span class="string">&#x27;2015-06-19 10:02:11&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_USER(ID,USERNAME,PASSWORD,PHONE,EMAIL,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;16&#x27;</span>, <span class="string">&#x27;lisi1&#x27;</span>, <span class="string">&#x27;202cb962ac59075b964b07152d234b70&#x27;</span>, <span class="string">&#x27;12344444442&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;2015-06-19 10:24:27&#x27;</span>, <span class="string">&#x27;2015-06-19 10:24:27&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_USER(ID,USERNAME,PASSWORD,PHONE,EMAIL,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;17&#x27;</span>, <span class="string">&#x27;jd_gogogo&#x27;</span>, <span class="string">&#x27;745404feaba9fb037e01b4a91c6ddbeb&#x27;</span>, <span class="string">&#x27;18800888888&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;2015-06-19 10:25:46&#x27;</span>, <span class="string">&#x27;2015-06-19 10:25:46&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_USER(ID,USERNAME,PASSWORD,PHONE,EMAIL,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;18&#x27;</span>, <span class="string">&#x27;tidy&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;13600112243&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;2015-07-30 17:26:25&#x27;</span>, <span class="string">&#x27;2015-07-30 17:26:25&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_USER(ID,USERNAME,PASSWORD,PHONE,EMAIL,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;22&#x27;</span>, <span class="string">&#x27;tidy1&#x27;</span>, <span class="string">&#x27;202cb962ac59075b964b07152d234b70&#x27;</span>, <span class="string">&#x27;13600112244&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;2015-07-30 17:48:33&#x27;</span>, <span class="string">&#x27;2015-07-30 17:48:33&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_USER(ID,USERNAME,PASSWORD,PHONE,EMAIL,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;23&#x27;</span>, <span class="string">&#x27;niuniu&#x27;</span>, <span class="string">&#x27;202cb962ac59075b964b07152d234b70&#x27;</span>, <span class="string">&#x27;15866777744&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;2015-08-01 11:48:42&#x27;</span>, <span class="string">&#x27;2015-08-01 11:48:42&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_USER(ID,USERNAME,PASSWORD,PHONE,EMAIL,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;32&#x27;</span>, <span class="string">&#x27;niuniu2&#x27;</span>, <span class="string">&#x27;202cb962ac59075b964b07152d234b70&#x27;</span>, <span class="string">&#x27;14322334455&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;2015-08-01 12:04:50&#x27;</span>, <span class="string">&#x27;2015-08-01 12:04:50&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_USER(ID,USERNAME,PASSWORD,PHONE,EMAIL,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;33&#x27;</span>, <span class="string">&#x27;niuniu3&#x27;</span>, <span class="string">&#x27;202cb962ac59075b964b07152d234b70&#x27;</span>, <span class="string">&#x27;14322334456&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;2015-08-01 12:08:26&#x27;</span>, <span class="string">&#x27;2015-08-01 12:08:26&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_USER(ID,USERNAME,PASSWORD,PHONE,EMAIL,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;34&#x27;</span>, <span class="string">&#x27;niuniu4&#x27;</span>, <span class="string">&#x27;202cb962ac59075b964b07152d234b70&#x27;</span>, <span class="string">&#x27;15877680983&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;2015-08-01 12:13:41&#x27;</span>, <span class="string">&#x27;2015-08-01 12:13:41&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_USER(ID,USERNAME,PASSWORD,PHONE,EMAIL,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;35&#x27;</span>, <span class="string">&#x27;test01&#x27;</span>, <span class="string">&#x27;202cb962ac59075b964b07152d234b70&#x27;</span>, <span class="string">&#x27;15600876321&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;2015-08-01 12:21:53&#x27;</span>, <span class="string">&#x27;2015-08-01 12:21:53&#x27;</span>);<span class="keyword">INSERT INTO</span> TB_USER(ID,USERNAME,PASSWORD,PHONE,EMAIL,CREATED,UPDATED) <span class="keyword">VALUES</span> (<span class="string">&#x27;36&#x27;</span>, <span class="string">&#x27;test02&#x27;</span>, <span class="string">&#x27;202cb962ac59075b964b07152d234b70&#x27;</span>, <span class="string">&#x27;1370348890&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;2015-08-01 12:28:39&#x27;</span>, <span class="string">&#x27;2015-08-01 12:28:39&#x27;</span>);</code></pre><p>分片测试：</p><ul><li><p>由于配置的分片规则为“auto-sharding-long”，所以mycat会根据此规则自动分片。</p></li><li><p>每个datanode中保存一定数量的数据。根据id进行分片</p></li><li><p>经测试id范围为：</p></li></ul><pre><code class="highlight plaintext">Datanode1：1~5000000Datanode2：5000000~10000000Datanode3：10000001~15000000</code></pre><ul><li>当15000000以上的id插入时报错：<br />此时需要添加节点了。</li></ul><pre><code class="highlight plaintext">[Err] 1064 - can&#x27;t find any valid datanode :TB_ITEM -&gt; ID -&gt; 15000001</code></pre><h3 id="mycat读写分离"><a class="markdownIt-Anchor" href="#mycat读写分离"></a> MyCat读写分离</h3><p>MyCat的读写分离是建立在MySQL主从复制基础之上实现的。</p><p>数据库读写分离对于大型系统或者访问量很高的互联网应用来说，是必不可少的一个重要功能。对于MySQL来说，标准的读写分离是主从模式，一个写节点Master后面跟着多个读节点，读节点的数量取决于系统的压力，通常是1-3个读节点的配置</p><blockquote><p>Mycat读写分离和自动切换机制，需要mysql的主从复制机制配合</p></blockquote><h4 id="mycat配置"><a class="markdownIt-Anchor" href="#mycat配置"></a> Mycat配置</h4><p>Mycat 1.4 支持MySQL主从复制状态绑定的读写分离机制，让读更加安全可靠，配置如下：</p><ol><li><p>设置 <code>balance=&quot;1&quot;</code>与<code>writeType=&quot;0&quot;</code></p></li><li><p>设置 <code>switchType=&quot;2&quot;</code> 与<code>slaveThreshold=&quot;100&quot;</code></p></li><li><p><strong>配置之前一定要保证已经配置了主从复制</strong></p></li></ol><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db1&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db2&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db3&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span></span><span class="tag"><span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;2&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>show slave status<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.25.134:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span><span class="tag"><span class="attr">password</span>=<span class="string">&quot;root&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;hostS&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.25.166:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span><span class="tag"><span class="attr">password</span>=<span class="string">&quot;root&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></code></pre><p><strong>Balance参数设置：</strong></p><ol><li><p>balance=“0”, 所有读操作都发送到当前可用的writeHost上。</p></li><li><p>balance=“1”，所有读操作都随机的发送到readHost。</p></li><li><p>balance=“2”，所有读操作都随机的在writeHost、readhost上分发</p></li></ol><p><strong>WriteType参数设置：</strong></p><ol><li><p>writeType=“0”, 所有写操作都发送到可用的writeHost上。</p></li><li><p>writeType=“1”，所有写操作都随机的发送到readHost。</p></li><li><p>writeType=“2”，所有写操作都随机的在writeHost、readhost分上发。</p></li></ol><p>“readHost是从属于writeHost的，即意味着它从那个writeHost获取同步数据，因此，当它所属的writeHost宕机了，则它也不会再参与到读写分离中来，即“不工作了”，这是因为此时，它的数据已经“不可靠”了。基于这个考虑，目前mycat 1.3和1.4版本中，若想支持MySQL一主一从的标准配置，并且在主节点宕机的情况下，从节点还能读取数据，则需要在Mycat里配置为两个writeHost并设置banlance=1。”</p><p><strong>switchType 目前有三种选择：</strong></p><ul><li><p>-1：表示不自动切换</p></li><li><p>1 ：默认值，自动切换</p></li><li><p>2 ：基于MySQL主从同步的状态决定是否切换</p></li></ul><p>“Mycat心跳检查语句配置为 show slave status ，dataHost 上定义两个新属性：<br />switchType=“2” 与slaveThreshold=“100”，此时意味着开启MySQL主从复制状态绑定的读写分离与切换机制。Mycat心跳机制通过检测 show slave status 中的<br />“Seconds_Behind_Master”, “Slave_IO_Running”, “Slave_SQL_Running” 三个字段来确定当前主从同步的状态以及Seconds_Behind_Master主从复制时延。“</p><h2 id="实战技巧"><a class="markdownIt-Anchor" href="#实战技巧"></a> 实战技巧</h2><h3 id="备份数据库"><a class="markdownIt-Anchor" href="#备份数据库"></a> 备份数据库</h3><p><strong>使用客户端导出sql文件</strong></p><ul><li>右键点击数据库</li><li>选择导出SQL文件</li></ul><p><strong>使用sql自带命令行</strong></p><ul><li>假定mysql安装在D:/software/MySQL Server 5.1/</li><li>那么其bin目录下有一个mysqldump.exe文件</li><li>账号是root</li><li>密码是admin</li><li>备份的数据库名是 test</li><li>备份后的文件是 d:\test.sql</li></ul><pre><code class="highlight shell">&quot;D:/software/MySQL Server 5.1/bin/mysqldump.exe&quot; -uroot -padmin -hlocalhost -P3306 test -r d:\test.sql</code></pre><h3 id="还原数据库"><a class="markdownIt-Anchor" href="#还原数据库"></a> 还原数据库</h3><p><strong>使用客户端还原</strong></p><ul><li>右键点击数据库</li><li>输入SQL文件</li><li></li></ul><p><strong>使用MySQL自带命令</strong></p><ul><li>假定mysql安装在D:/software/MySQL Server 5.1/</li><li>那么其bin目录下有一个mysql.exe文件</li><li>账号是root</li><li>密码是admin</li><li>还原的数据库名是 test</li><li>还原的文件是 d:\test.sql</li></ul><pre><code class="highlight shell">&quot;D:/software/MySQL Server 5.1/bin/mysql.exe&quot; -u root -padmin test &lt; d:/test.sql</code></pre><h3 id="开启innodb"><a class="markdownIt-Anchor" href="#开启innodb"></a> 开启InnoDB</h3><p><strong>检查InnoDb是否开启</strong></p><pre><code class="highlight plaintext">SHOW variables like &#x27;have_%&#x27;;</code></pre><ul><li>在结果中的have_innodb，如果显示为YES，即表示启动了。 如果是NO或者DISABLED表示未启动。<br />如果不存在也表示未启动。</li></ul><p><strong>停止mysql</strong></p><pre><code class="highlight plaintext">net stop mysql</code></pre><p><strong>删除三个文件</strong></p><ul><li>定位到D:\tools\MYSQL\mysql-5.1.57-win32\data 目录下，找到这3个文件<ul><li>ib_logfile0</li><li>ib_logfile1</li><li>ibdata1</li></ul></li><li>备份后，删除掉</li></ul><blockquote><p>注： D:\tools\MYSQL\mysql-5.1.57-win32 是我的安装目录，请自行调整</p></blockquote><p><strong>修改配置文件</strong></p><ul><li>打开文件：D:\tools\MYSQL\mysql-5.1.57-win32\my.ini</li><li>添加</li></ul><pre><code class="highlight plaintext">default-storage-engine=InnoDB</code></pre><blockquote><p>如果存在 <code>default-storage-engine=MyISAM</code>，注掉即可</p></blockquote><p><strong>启动mysql</strong></p><pre><code class="highlight plaintext">net start mysql</code></pre><h3 id="修改root密码"><a class="markdownIt-Anchor" href="#修改root密码"></a> 修改root密码</h3><p><strong>使用当前密码进入mysql</strong></p><ul><li>执行如下命令，进入mysql命令环境</li></ul><pre><code class="highlight plaintext">&quot;D:\tools\MYSQL\mysql-5.1.57-win32\bin\mysql.exe&quot; -u root -padmin</code></pre><blockquote><p>注： 我的mysql.exe文件位于D:\tools\MYSQL\mysql-5.1.57-win32\bin，请根据自己的情况，做相应的修改<br />注： 我的密码是 admin, 请做相应调整。</p></blockquote><p><strong>修改密码</strong></p><ul><li>执行如下命令，把root密码改为123456</li></ul><pre><code class="highlight sql"><span class="keyword">set</span> password <span class="keyword">for</span> root<span class="variable">@localhost</span> <span class="operator">=</span> password(<span class="string">&#x27;123456&#x27;</span>);</code></pre><h3 id="查询区分大小写-binary"><a class="markdownIt-Anchor" href="#查询区分大小写-binary"></a> 查询区分大小写 binary</h3><p>Mysql默认查询是不分大小写的，可以在SQL语句中加入 binary来区分大小写；</p><ul><li>BINARY不是函数，是类型转换运算符，它用来强制它后面的字符串为一个二进制字符串，可以理解为在字符串比较的时候区分大小写</li></ul><pre><code class="highlight sql"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `test` <span class="keyword">where</span> <span class="type">binary</span> `name` <span class="operator">=</span> &quot;Test&quot;</code></pre><h3 id="导入导出sql"><a class="markdownIt-Anchor" href="#导入导出sql"></a> 导入导出sql</h3><pre><code class="highlight sh">mysqldump -uroot -pdSadm@34e% --databases adm_dbmodel --single_transaction --skip-lock-tables --set-gtid-purged=OFF &gt; mysql_backup.sqlmysql -P 13507 -u <span class="string">&#x27;adm_admin&#x27;</span> -p<span class="string">&#x27;dSadm@34e%&#x27;</span> -e <span class="string">&#x27;source /xxx/mysql_backup.sql&#x27;</span> adm_dbmodel</code></pre>]]>
    </content>
    <id>http://example.com/2022/07/09/Mysql/</id>
    <link href="http://example.com/2022/07/09/Mysql/"/>
    <published>2022-07-09T04:00:00.000Z</published>
    <summary>Mysql安装，常用sql，索引，性能优化，事务处理，锁，集群搭建，备份还原，binlog，慢查询</summary>
    <title>MySQL</title>
    <updated>2026-02-26T09:59:22.366Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Nginx" scheme="http://example.com/tags/Nginx/"/>
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    <content>
      <![CDATA[<h1 id="nginx反向代理服务器"><a class="markdownIt-Anchor" href="#nginx反向代理服务器"></a> Nginx反向代理服务器</h1><p>[toc]</p><h2 id="nginx概述"><a class="markdownIt-Anchor" href="#nginx概述"></a> Nginx概述</h2><p><a href="http://nginx.org">http://nginx.org</a></p><p>Nginx是一个轻量级，高性能的基于HTTP的反向代理服务器，同时还是一个电子邮件服务器</p><p>Nginx是由俄罗斯人lgor Sysoev使用c语言写的一款服务器</p><h3 id="代理服务器"><a class="markdownIt-Anchor" href="#代理服务器"></a> 代理服务器</h3><p><strong>代理服务器</strong></p><p>代理服务器根据其代理对象的不同，可以分为正向代理服务器与反向代理服务器，这里的“正”“反”是站在客户端角度来说的</p><p><strong>正向代理</strong></p><p>翻墙就是一个典型的正向代理（我们访问Google，通过vpn，Google知道vpn的存在，但是并不知道我们的存在）</p><p>正向代理是对客户端的代理。客户端C想要从服务端S获取资源，但由于某些原因不能直接访问服务端，而是通过另外一台主机P向服务端发送请求。当服务端处理完毕请求后，将响应发送给主机P,主机P在接收到来自服务端的响应后，将响应又转给了客户端C.此时的主机P,就称为客户端C的正向代理服务器。</p><p>客户端在使用正向代理服务器时是知道其要访问的目标服务器的地址等信息的。</p><p>正向代理服务器是服务器的用户(客户端)架设的主机，与服务端无关，正向代理服务器的出现，使服务端根本就不知道真正客户端的存在。</p><h3 id="nginx的特点"><a class="markdownIt-Anchor" href="#nginx的特点"></a> Nginx的特点</h3><ul><li>高并发，默认1000，经过配置可以达到5-10W（tomcat默认150）<ul><li><code>高并发就是指宏观上了并行，微观上的串行</code></li></ul></li><li>低消耗<ul><li><code>1W个非活跃的长连接，nginx占的内存只有2.5M</code></li></ul></li><li>热部署<ul><li><code>修改了配置文件，重启nginx，服务并不会停止，不会间断</code></li></ul></li><li>高扩展</li><li>高可用<ul><li><code>因为nginx内部有两类进程，master和worker，即更换配置文件时只会停掉部分worker</code></li></ul></li></ul><h3 id="nginx的web请求处理"><a class="markdownIt-Anchor" href="#nginx的web请求处理"></a> nginx的web请求处理</h3><p>Nginx结合多进程机制和异步机制对外提供服务，异步机制使用的是异步非阻塞方式。Nginx的master进程会生成多个worker进程，  master. 进程负责管理这些worker进程的生命周期、接受外部命令、解析perl脚本等。而worker进程则用于接收和处理客户端请求</p><p>每个worker进程能够使用异步非阻塞方式处理多个客户端请求。当某个worker进程按收到客户端的请求以后，其会调用I0进行处理，如果不能立即得到结果，worker进程就去处理其他的请求。当1O返回结果后，就会通知worker进程，而worker进程得到通知后，就会挂起当前正在处理的事务,拿10返回结果去响应客户端请求.worker进程采用的是epoll事件驱动模型与10进行通信的。epoll 模型底层采用的是“回调callback替代了轮询，使效率要高于select模型</p><h2 id="下载安装windows"><a class="markdownIt-Anchor" href="#下载安装windows"></a> 下载/安装（windows）</h2><h3 id="启动方式"><a class="markdownIt-Anchor" href="#启动方式"></a> 启动方式</h3><ul><li>下载好nginx.rar并解压</li><li><strong>启动方式有两种</strong></li><li><strong>方式一：直接双击</strong><ul><li>直接双击nginx.exe会有一个屏幕一闪而过，就表示启动成功</li><li>只需要打开访问地址，就可以看到如图所示的效果</li><li>关闭方式，用任务管理器关闭</li></ul></li></ul><pre><code class="highlight plaintext">http://127.0.0.1</code></pre><blockquote><p>nginx启动后，在任务管理器有两个nginx进程，这个是正常的，一个是守护进程，一个是工作进程，分别手动关闭即可</p></blockquote><ul><li><strong>方式二：命令行方式</strong><ul><li>假设nginx在d:/nginx目录下</li></ul></li></ul><pre><code class="highlight plaintext">cmdcd d:/software/nginxd:  start nginx关闭方式nginx -s stop</code></pre><h3 id="端口号修改"><a class="markdownIt-Anchor" href="#端口号修改"></a> 端口号修改</h3><ul><li>可以修改为其他的端口号，打开nginx目录的conf/nginx.conf文件，然后找到listen 80，修改为9090，重启</li></ul><pre><code class="highlight plaintext">http://127.0.0.1:9090/</code></pre><ul><li><strong>重启命令</strong></li></ul><pre><code class="highlight plaintext">nginx -s reload</code></pre><h3 id="nginxconf配置文件"><a class="markdownIt-Anchor" href="#nginxconf配置文件"></a> nginx.conf配置文件</h3><ul><li><p>nginx.conf是nginx的核心配置文件</p></li><li><p><strong>端口号</strong></p><ul><li>访问的端口号</li></ul></li><li><p><strong>页面存放位置</strong></p><ul><li>表示所有页面都存放在nginx的html目录下</li></ul></li><li><p><strong>欢迎页面</strong></p><ul><li>默认会访问index.html或者index.htm文件</li></ul></li></ul><h2 id="下载安装linux"><a class="markdownIt-Anchor" href="#下载安装linux"></a> 下载/安装（Linux）</h2><p><a href="http://nginx.org">http://nginx.org</a></p><h3 id="nginx的下载"><a class="markdownIt-Anchor" href="#nginx的下载"></a> Nginx的下载</h3><p>下载完毕后把包上传到Linux服务器</p><h3 id="源码安装"><a class="markdownIt-Anchor" href="#源码安装"></a> 源码安装</h3><p><strong>先安装c++编译环境</strong></p><pre><code class="highlight plaintext">yum -y install gcc</code></pre><p><strong>安装依赖的其他库：</strong></p><ul><li><code>pcre-devel</code>：perl脚本语言兼容正则表达式，为Nginx提供正则表达式</li><li><code>openssl-devel</code>：为nginx提供ssl(安全套接字层)密码库，主要包含主要的密码算法，常用的密钥和证书封装管理功能及ssl协议，并提供丰富的应用程序供册数或其他目的使用</li></ul><pre><code class="highlight plaintext">yum -y install zlib zlib-devel pcre-devel openssl openssl-devel</code></pre><blockquote><p>在安装之前需要注意，很多库具有devel 库与非devel库两种。devel库表示development开发库，比非devel库会多出一些头文件、静态库、源码包等。而这些包在运行时不可能用到，但在开发时有可能用到。所以对于程序员来说，一般都是需要安装devel库的。不过，在yum安装devel库时，由于其依赖于非devel库，所以其会先自动安装非devel库，而后再安装devel库。所以真正在安装时，只需显示的安装devel库即可</p></blockquote><blockquote><p>通过以下命令可以查看到，非devel库也被安装了</p></blockquote><p><strong>解压nginx包：</strong></p><pre><code class="highlight plaintext">tar -zxvf nginx-1.14.0.tar.gz -C /usr/local/</code></pre><p>进入解压目录<code>/usr/local/nginx-1.14.0</code></p><p>运行下列语句可以看到一些配置信息：</p><pre><code class="highlight plaintext">./configure --help</code></pre><pre><code class="highlight plaintext">--prefix=PATH   表示安装路径--sbin-path=PATH  命令路径--modules-path =PATH   模块路径--conf-path=PATH  配置文件路径--error-loh-path=PATH  日志文件路径--with   表示未安装插件，可用该语句选安装--without  表示已安装插件，可用改语句选删除</code></pre><p>该语句表示给nginx加入https的功能：</p><pre><code class="highlight plaintext">--with-http_ssl_module             enable ngx_http_ssl_module</code></pre><p><strong>生成Makefile文件</strong></p><pre><code class="highlight plaintext">./configure \--prefix=/usr/local/nginx --with-http_ssl_module</code></pre><pre><code class="highlight plaintext">nginx path prefix: &quot;/usr/local/nginxNew&quot;      nginx安装目录   nginx binary file: &quot;/usr/local/nginxNew/sbin/nginx&quot;       nginx命令文件nginx modules path: &quot;/usr/local/nginxNew/modules&quot;     nginx模块存放路径nginx configuration prefix: &quot;/usr/local/nginxNew/conf&quot;        nginx配置文件存放路径nginx configuration file: &quot;/usr/local/nginxNew/conf/nginx.conf&quot;       nginx配置文件名nginx pid file: &quot;/usr/local/nginxNew/logs/nginx.pid&quot;      nginx的进程id文件nginx error log file: &quot;/usr/local/nginxNew/logs/error.log&quot;        错误日志文件nginx http access log file: &quot;/usr/local/nginxNew/logs/access.log&quot;     http访问日志文件nginx http client request body temporary files: &quot;client_body_temp&quot;nginx http proxy temporary files: &quot;proxy_temp&quot;nginx http fastcgi temporary files: &quot;fastcgi_temp&quot;nginx http uwsgi temporary files: &quot;uwsgi_temp&quot;nginx http scgi temporary files: &quot;scgi_temp&quot;</code></pre><blockquote><p>配置成功后，再次查看nginx解压目录，发现其中多出了一个文件Makefile，后面的编译就是依靠该文件进行的</p></blockquote><blockquote><p>注意：刚才指定的安装目录在make后 nake install才会安装到刚才指定的安装目录</p></blockquote><p><strong>make编译</strong></p><pre><code class="highlight plaintext">make</code></pre><p><strong>安装</strong></p><pre><code class="highlight plaintext">make install</code></pre><blockquote><p>安装成功</p></blockquote><p>进入nginx安装目录</p><pre><code class="highlight plaintext">cd /usr/local/nginxNew/</code></pre><p>然后进入命令路径<code>cd sbin/</code>路径：</p><blockquote><p>该路径的 nginx就是可执行文件</p></blockquote><p><strong>nginx命令全局使用</strong></p><ul><li>一种是修改profile文件,怎加</li></ul><pre><code class="highlight plaintext">vim /etc/profile</code></pre><ul><li>一种是运行命令</li></ul><pre><code class="highlight plaintext">ln -n /usr/local/nginx/sbin/nginx /usr/local/sbin</code></pre><h3 id="nginx命令"><a class="markdownIt-Anchor" href="#nginx命令"></a> Nginx命令</h3><p>查看命令帮助：</p><pre><code class="highlight plaintext">nginx -h</code></pre><pre><code class="highlight plaintext">nginx -p prefix   启动命令+nginx安装目录nginx -c file   启动命令+conf文件nginx -t      测试配置文件是否正确，默认只测试默认的配置文件conf/nginx.confnginx -T      测试配置文件是否正确，并显示配置文件内容nginx -tq      (修改完配置信息后，使用该命令检测)在配置文件测试过程中，静止显示非错误信息，即只显示错误信息nginx -s [...]  停止选项：stop/quit/reopen/reload   强制关闭/平滑关闭/重新打开/平滑重启</code></pre><p><strong>启动nginx</strong></p><pre><code class="highlight plaintext">nginx</code></pre><p>查看nginx的进程</p><pre><code class="highlight plaintext">ps aux|grep nginx</code></pre><p>查看系统端口占用：</p><pre><code class="highlight plaintext">netstat -tunlp</code></pre><blockquote><p>默认端口是80，80端口也是浏览器的默认访问端口</p></blockquote><h3 id="nginx访问测试"><a class="markdownIt-Anchor" href="#nginx访问测试"></a> nginx访问测试</h3><pre><code class="highlight plaintext">localhost:80</code></pre><h3 id="nginx配置"><a class="markdownIt-Anchor" href="#nginx配置"></a> nginx配置</h3><p><strong>nginx配置文件</strong></p><p>目录：</p><pre><code class="highlight plaintext">vim /usr/local/nginx/conf/nginx.conf</code></pre><pre><code class="highlight plaintext">:set nu 可以让vim显示行号</code></pre><p>配置文件：</p><ul><li><strong>worker_processes</strong>：工作进程worker数量，一般为cpu内核的整数倍，或者填auto</li></ul><pre><code class="highlight properties"><span class="comment">#user  nobody;</span><span class="comment">#工作进程</span><span class="attr">worker_processes</span>  <span class="string">1;</span><span class="comment"></span><span class="comment">#error_log  logs/error.log;</span><span class="comment">#error_log  logs/error.log  notice;</span><span class="comment">#error_log  logs/error.log  info;</span><span class="comment"></span><span class="comment">#pid        logs/nginx.pid;</span><span class="attr">events</span> <span class="string">&#123;</span>    <span class="attr">worker_connections</span>  <span class="string">1024;</span><span class="attr">&#125;</span><span class="attr">http</span> <span class="string">&#123;</span>    <span class="attr">include</span>       <span class="string">mime.types;</span>    <span class="attr">default_type</span>  <span class="string">application/octet-stream;</span><span class="comment"></span><span class="comment">    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><span class="comment">    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><span class="comment">    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><span class="comment"></span><span class="comment">    #access_log  logs/access.log  main;</span>    <span class="attr">sendfile</span>        <span class="string">on;</span><span class="comment">    #tcp_nopush     on;</span><span class="comment"></span><span class="comment">    #keepalive_timeout  0;</span>    <span class="attr">keepalive_timeout</span>  <span class="string">65;</span><span class="comment"></span><span class="comment">    #gzip  on;</span>    <span class="attr">server</span> <span class="string">&#123;</span>        <span class="attr">listen</span>       <span class="string">80;</span>        <span class="attr">server_name</span>  <span class="string">localhost;</span><span class="comment"></span><span class="comment">        #charset koi8-r;</span><span class="comment"></span><span class="comment">        #access_log  logs/host.access.log  main;</span><span class="comment">        #默认访问目录</span><span class="comment">        #表示默认访问html目录下的index.html，html表示相对路径，可以写绝对路径</span><span class="comment">        #如果写成location /usr&#123; &#125; 就表示访问localhost/usr默认访问html目录下usr目录下的index.html</span>        <span class="attr">location</span> <span class="string">/ &#123;</span>            <span class="attr">root</span>   <span class="string">html;</span>            <span class="attr">index</span>  <span class="string">index.html index.htm;</span>        <span class="attr">&#125;</span><span class="comment"></span><span class="comment">        #error_page  404              /404.html;</span><span class="comment"></span><span class="comment">        # redirect server error pages to the static page /50x.html</span><span class="comment">        #</span>        <span class="attr">error_page</span>   <span class="string">500 502 503 504  /50x.html;</span>        <span class="attr">location</span> = <span class="string">/50x.html &#123;</span>            <span class="attr">root</span>   <span class="string">html;</span>        <span class="attr">&#125;</span><span class="comment"></span><span class="comment">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><span class="comment">        #</span><span class="comment">        #location ~ \.php$ &#123;</span><span class="comment">        #    proxy_pass   http://127.0.0.1;</span><span class="comment">        #&#125;</span><span class="comment"></span><span class="comment">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><span class="comment">        #</span><span class="comment">        #location ~ \.php$ &#123;</span><span class="comment">        #    root           html;</span><span class="comment">        #    fastcgi_pass   127.0.0.1:9000;</span><span class="comment">        #    fastcgi_index  index.php;</span><span class="comment">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><span class="comment">        #    include        fastcgi_params;</span><span class="comment">        #&#125;</span><span class="comment"></span><span class="comment">        # deny access to .htaccess files, if Apache&#x27;s document root</span><span class="comment">        # concurs with nginx&#x27;s one</span><span class="comment">        #</span><span class="comment">        #location ~ /\.ht &#123;</span><span class="comment">        #    deny  all;</span><span class="comment">        #&#125;</span>    <span class="attr">&#125;</span><span class="comment"></span><span class="comment"></span><span class="comment">    # another virtual host using mix of IP-, name-, and port-based configuration</span><span class="comment">    #</span><span class="comment">    #server &#123;</span><span class="comment">    #    listen       8000;</span><span class="comment">    #    listen       somename:8080;</span><span class="comment">    #    server_name  somename  alias  another.alias;</span><span class="comment"></span><span class="comment">    #    location / &#123;</span><span class="comment">    #        root   html;</span><span class="comment">    #        index  index.html index.htm;</span><span class="comment">    #    &#125;</span><span class="comment">    #&#125;</span><span class="comment"></span><span class="comment"></span><span class="comment">    # HTTPS server</span><span class="comment">    #</span><span class="comment">    #server &#123;</span><span class="comment">    #    listen       443 ssl;</span><span class="comment">    #    server_name  localhost;</span><span class="comment"></span><span class="comment">    #    ssl_certificate      cert.pem;</span><span class="comment">    #    ssl_certificate_key  cert.key;</span><span class="comment"></span><span class="comment">    #    ssl_session_cache    shared:SSL:1m;</span><span class="comment">    #    ssl_session_timeout  5m;</span><span class="comment"></span><span class="comment">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><span class="comment">    #    ssl_prefer_server_ciphers  on;</span><span class="comment"></span><span class="comment">    #    location / &#123;</span><span class="comment">    #        root   html;</span><span class="comment">    #        index  index.html index.htm;</span><span class="comment">    #    &#125;</span><span class="comment">    #&#125;</span><span class="attr">&#125;</span></code></pre><h2 id="请求定位"><a class="markdownIt-Anchor" href="#请求定位"></a> 请求定位</h2><p><strong>如果location匹配到多个路径，就会报错</strong></p><p>配置文件中的location:</p><ul><li>root：表示相对路径路径/绝对路径</li><li>index：表示该路径的默认页面</li></ul><p>这段配置表示访问<u>localhost/</u> 就会在相对路径html目录下取找默认页面<code>index.html</code>或<code>index.htm</code></p><pre><code class="highlight plaintext">location / &#123;    root   html;    index  index.html index.htm;&#125;</code></pre><hr /><p>这段配置表示访问   <u> localhost/default</u>  就会在相对路径 html/default 目录下取找默认页面<code>index.html</code>或<code>index.htm</code></p><p>访问 <u>localhost/default/login.html</u> 就会在相对路径html/default目录下去找 <code>login.html</code></p><pre><code class="highlight plaintext">location /default &#123;    root   html;    index  index.html index.htm;&#125;</code></pre><p>这段配置表示访问 <u>localhost/xxx/ooo</u> 就会在  /opt/static/xxx/ooo 目录去找默认页面 <code>default.html</code></p><p>访问 <u>localhost/xxx/ooo/login.html</u> 就会在  /opt/static/xxx/ooo 目录去找<code> login.html</code></p><pre><code class="highlight plaintext">location /xxx/ooo&#123;    root   /opt/static;    index  default.html;&#125;</code></pre><h2 id="多个tomcat"><a class="markdownIt-Anchor" href="#多个tomcat"></a> 多个tomcat</h2><p>为什么要提供多个tomcat</p><ul><li>在解释为什么要提供多个tomcat之前，首先解释一下为什么要额外提供tomcat</li><li>Nginx是一个web服务器，很快速，但是不能作为servlet容器独立运行，所以通常的工作方式就是Nginx配合Tomcat来协同工作</li><li>此时分别准备两个tomcat，后续的负载均衡，session共享需要使用，端口号分别为8333和8444</li></ul><h3 id="配置启动windows"><a class="markdownIt-Anchor" href="#配置启动windows"></a> 配置启动（Windows）</h3><ul><li><p>启动bin目录下的startup.bat</p></li><li><p>访问地址</p><ul><li>启动后访问地址</li></ul></li></ul><pre><code class="highlight plaintext">http://127.0.0.1:8333/</code></pre><blockquote><p>在这个login.jsp页面上有图片，图片是为了后续讲解<strong>动静分离</strong>做的铺垫，并且在tomcat里跟踪信息输出，用于观察图片静态资源的访问是否在当前的tomcat上发生</p></blockquote><blockquote><p>这里准备了两个tomcat，因为要做<strong>负载均衡</strong>，只是端口号不同</p></blockquote><blockquote><p>这个simple会把登陆的信息放在session中，方便后续的<strong>session共享</strong>使用</p></blockquote><h3 id="配置启动linux"><a class="markdownIt-Anchor" href="#配置启动linux"></a> 配置启动（Linux）</h3><p>下载tomcat包上传到Linux服务器</p><p>解压：</p><pre><code class="highlight plaintext">tar -zxvf apache-tomcat-9.0.12.gz -C /usr/local/</code></pre><p>解压完成后，tomcat就可以之间使用，我们把tomcat命令加入到全局PATH路径</p><p>首先规避版本号，建立软连接</p><pre><code class="highlight plaintext">ln -s apache-tomcat-9.0.12/ ./tomcat</code></pre><hr /><p>注册bin目录，<code>vim /etc/profile</code></p><pre><code class="highlight plaintext">export TOMCAT_HOME=/usr/local/tomcatexport PATH=$TOMCAT_HOME/bin:$PATH</code></pre><p>重新加载配置文件：</p><pre><code class="highlight plaintext">source /etc/profile</code></pre><blockquote><p>如果<code>vim /etc/profile</code>配置文件写错了，可以写如下命令</p></blockquote><pre><code class="highlight plaintext">export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</code></pre><hr /><p><strong>配置tomcat端口</strong><br />配置文件路径</p><pre><code class="highlight plaintext">vim tomcat/conf/server.xml</code></pre><blockquote><p>如果同一个服务器有多个tomcat，每个tomcat的端口都需要更改三个端口</p></blockquote><p>然后把war文件直接扔到tomcat/webapps目录下</p><ul><li>放到webapps后tomcat会自动解压加载</li><li>放到webapps下的ROOT目录tomcat不会自动解压加载<ul><li>可以使用<code>unzip demo.war</code>自己解压</li></ul></li></ul><hr /><p><strong>启动tomcat</strong></p><pre><code class="highlight plaintext">startup.sh</code></pre><p>启动tomcat并查看输出日志：</p><pre><code class="highlight plaintext">startup.sh | tail -f /usr/local/tomcat/logs/catalina.out</code></pre><p><strong>关闭tomct</strong></p><pre><code class="highlight plaintext">shutdown.sh</code></pre><h2 id="反向代理"><a class="markdownIt-Anchor" href="#反向代理"></a> 反向代理</h2><h3 id="反向代理概念"><a class="markdownIt-Anchor" href="#反向代理概念"></a> 反向代理概念</h3><p>先说正向代理，比如要访问YouTube，但是不能直接访问，智能先找个翻墙软件，通过翻墙软件才能访问YouTube，翻墙软件就叫做正向代理</p><p>所谓的反向代理，指的是用户要访问YouTube，但是YouTube悄悄的把这个请求交个bilibili来做，那么bilibili就是反向代理了</p><p>当前就是访问nginx，但是nginx把亲求交给tomcat来做</p><h3 id="结合nginx和tomcat"><a class="markdownIt-Anchor" href="#结合nginx和tomcat"></a> 结合nginx和tomcat</h3><p>首先启动tomcat中端口号8333的tomcat</p><p><strong>修改nginx.conf</strong></p><ul><li><code>location/</code>   ：表示处理所有请求</li><li><code>proxy_pass http://127.0.0.1:8333</code>  ：表示把请求都交给http://127.0.0.1:8333来处理</li></ul><pre><code class="highlight plaintext">location / &#123;    proxy_pass http://127.0.0.1:8111;&#125;</code></pre><p><strong>重启nginx并访问</strong></p><ul><li>发现此时已经反向代理到tomcat了</li></ul><h3 id="意义何在"><a class="markdownIt-Anchor" href="#意义何在"></a> 意义何在</h3><p>既然直接通过127.0.0.1:8333/login.jsp可以访问，为社么要通过127.0.0.1/login.jsp反向代理到tomcat呢？为什么不直接使用tomcat呢？</p><ul><li>因为nginx在处理静态文件的吞吐量上面比tomcat好很多，通常他们两配合，不会把所有的请求都如本例交给tomcat，而是把静态请求交给nginx，动态请求，如jsp，servlet，ssm，struts等请求交给tomcat，从而达到动静分离的效果</li></ul><h2 id="静态代理"><a class="markdownIt-Anchor" href="#静态代理"></a> 静态代理</h2><p><strong>如果location匹配到多个路径，就会报错</strong></p><p>Nginx静态代理是指，将所有的静态资源，例如css js、html Jpg等资源存放到Ninx服务器，而不存放在应用服务器Tomcat中，当客户端发出的请求是对这些静态资源的请求时，Nginx直接将这些静态资源响应给客户端，而无需提交给应用服务器处理，这样就降低了应用服务器的压力。。</p><p>同时，Nginx对于静态资源的处理较Tomcat, 性能更好，效率更高，所以，在实际生产环境下，会使用Nginx作为静态代理服务器，专门处理静态资源的响应。</p><p>Nginx对于静态资源请求的拦截方式，可以通过静态资源名称的扩展名拦截，也可以通过静态资源所在的目录名称拦截。</p><h3 id="扩展名拦截"><a class="markdownIt-Anchor" href="#扩展名拦截"></a> 扩展名拦截</h3><p>location后面为正则表达式</p><ul><li><code>~</code>  表示正则开始（如果不写~，表示前面还有字符）</li><li><code>$</code> 表示正则结束（即后面不能有字符，如果不写$，表示后面还有字符）</li><li><code>.</code>  表示任意字符</li><li><code>*</code>  表示多个</li><li><code>.*</code>  表示多个任意字符</li><li><code>\.</code>  表示转义，显示真正的点</li></ul><p>此配置表示凡是以 jpg/png/js/css/html 为后缀的访问都从 /opt/static 目录下去找</p><p>例：让问 <u>localhost/img/man.jpg</u>  就会在 <u>/opt/static/img/man.jpg</u> 找到图片</p><pre><code class="highlight plaintext">location ~.*\.(jpg|png|js|css|html)&#123;    root /opt/static;&#125;</code></pre><p>配置完后使用该命令平滑重启</p><pre><code class="highlight plaintext">nginx -s reload</code></pre><h3 id="目录名拦截"><a class="markdownIt-Anchor" href="#目录名拦截"></a> 目录名拦截</h3><ul><li><code>.+</code> 表示后面必须有字符</li></ul><pre><code class="highlight plaintext">location ~.*(css|js|images).+&#123;    root /opt/static;&#125;</code></pre><h2 id="动静分离"><a class="markdownIt-Anchor" href="#动静分离"></a> 动静分离</h2><h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3><p>所谓的动静分离就是值图片，css，js之类的都交给nginx来处理，nginx处理不了的，比如jsp交给tomcat来处理</p><p>好处就是nginx处理静态内容的吞吐量很高，比tomcat高多了，这样就无形中提升了性能</p><h3 id="配置动静分离"><a class="markdownIt-Anchor" href="#配置动静分离"></a> 配置动静分离</h3><p><strong>修改nginx.conf</strong></p><ul><li>在location下面添加一个新的location<ul><li>表示所有的css js png访问都由nginx来做，访问的地址是<code>D:/apache/tomcat_test/tomcat_8333/webapps/ROOT</code></li></ul></li></ul><pre><code class="highlight plaintext">location ~\.(css|js|png)$ &#123;    root     D:/apache/tomcat_test/tomcat_8333/webapps/ROOT;&#125;</code></pre><p><strong>观察输入日志</strong></p><ul><li>再到tomcat的输出日志里观察，就会发现，只访问了jsp, 所有的css,js,png都不会经过 tomcat，而是由nginx自己负责处理了</li></ul><h3 id="动静分离负载"><a class="markdownIt-Anchor" href="#动静分离负载"></a> 动静分离+负载</h3><p><strong>nginx也可以转到其他的nginx服务器</strong></p><p>配置两台tomcat，负责动态文件</p><ul><li>192.168.1.1:8080</li><li>192.168.1.2:8080</li></ul><p>配置两台nginx，负责静态文件</p><ul><li>192.168.1.3:80</li><li>192.168.1.4:80</li></ul><pre><code class="highlight plaintext">location ~.*\.(jpg|png|js|gif|css|html)$&#123;    root /opt/static;&#125;</code></pre><p>负载均衡服务器配置文件：</p><pre><code class="highlight properties"><span class="comment">#两台tomcat，负责处理动态资源</span><span class="attr">upstream</span> <span class="string">tomcat&#123;</span>    <span class="attr">server</span> <span class="string">192.168.1.1:8080 weight=1;</span>        <span class="attr">server</span> <span class="string">192.168.1.2:8080 weight=1;</span><span class="attr">&#125;</span><span class="comment">#两台nginx，负责处理动静分离</span><span class="attr">upstream</span> <span class="string">static&#123;</span>        <span class="attr">server</span> <span class="string">192.168.1.3:80 weight=1;</span>        <span class="attr">server</span> <span class="string">192.168.1.4:80 weight=1;</span><span class="attr">&#125;</span><span class="comment"></span><span class="comment"></span><span class="comment">#拦截出了静态资源的其他访问</span><span class="attr">location</span> <span class="string">/ &#123;</span>    <span class="attr">proxy_pass</span> <span class="string">http://tomcat;</span><span class="attr">&#125;</span><span class="comment">#拦截静态资源</span><span class="attr">location</span> <span class="string">~.*\.(jpg|png|js|gif|css|html)$&#123;</span>    <span class="attr">proxy_pass</span> <span class="string">http://static;</span><span class="attr">&#125;</span></code></pre><h2 id="负载均衡"><a class="markdownIt-Anchor" href="#负载均衡"></a> 负载均衡</h2><p>负载均衡，就是对请求的处理分摊到多个操作单元上进行，这个均衡是指在大批量访问前提下的一种基本均衡，并非是绝对的均衡。</p><p>对于web工程的负载均衡，就是将相同的web应用部署到多个不同的web服务器上，形成多个web应用服务器，当请求到来时，由负载均衡服务器负责将请求按照实现设定好的比例向web应用服务器进行分发，从而增加系统的整体吞吐量</p><h3 id="概念-2"><a class="markdownIt-Anchor" href="#概念-2"></a> 概念</h3><p>负载均衡的概念就是访问量很大的时候，一个tomcat吃不消，这时候就准备了多个tomcat，由nginx按照权重来对请求进行分配，从而缓解单独一个tomcat受到的压力</p><h3 id="启动两个tomcat"><a class="markdownIt-Anchor" href="#启动两个tomcat"></a> 启动两个tomcat</h3><p><strong>修改start.bat文件</strong></p><p>分别启动即可</p><h3 id="修改nginxconf"><a class="markdownIt-Anchor" href="#修改nginxconf"></a> 修改nginx.conf</h3><p>首先，增加一个upstream，用来指向两个tomcat</p><pre><code class="highlight plaintext">upstream tomcat_8111_8222&#123;    server 127.0.0.1:8111 weight=1;    server 127.0.0.1:8222 weight=2;&#125;</code></pre><p>然后修改location，反向代理到上述配置</p><pre><code class="highlight plaintext">location / &#123;    proxy_pass http://tomcat_8111_8222;&#125;</code></pre><blockquote><p><code>weight</code>:表示权重，值越大，被分配到的几率越大</p></blockquote><p><strong>然后重启nginx并多次访问</strong></p><p>会发现nginx会根据权重去访问两个服务器</p><h2 id="session共享"><a class="markdownIt-Anchor" href="#session共享"></a> session共享</h2><h3 id="负载均衡session问题"><a class="markdownIt-Anchor" href="#负载均衡session问题"></a> 负载均衡session问题</h3><p>通过负载均衡，我们可以把请求分发到不同的tomcat来缓解服务器的压力，但是这里存在一个问题：当同一个用户第一次访问tomcat_8333并且登陆成功，而第二次访问却被分配到了tomcat_8444，这里没有记录他的登陆状态，那么就会呈现未登录的状态了，严重伤害了用户体验</p><h3 id="方式一ip_hash"><a class="markdownIt-Anchor" href="#方式一ip_hash"></a> 方式一：ip_hash</h3><p>通过IP地址标记用户，如果多次请求都是从同一个IP来的，那么就都分配到同一个tomcat</p><p>这样就不会出现负载均衡session问题了，秩序在<strong>upstream最后加上ip_hash</strong>，就行了</p><pre><code class="highlight plaintext">upstream tomcat_8333_8444&#123; server  127.0.0.1:8333  weight=1;  server  127.0.0.1:8444 weight=2;     ip_hash;&#125;</code></pre><p>不过这种方案并不完美，如下几种情况就有问题</p><blockquote><p>大量请求来之某个局域网，那么想断关于就没有负载均衡了</p></blockquote><blockquote><p>如果tomcat_8333挂了，那么此时nginx只能把 请求交给了tomcat_8444，但是这里却没有记录session，用户体验依然受影响</p></blockquote><h3 id="方式二redistomcatsession-manager"><a class="markdownIt-Anchor" href="#方式二redistomcatsession-manager"></a> 方式二：redis+tomcat+session-manager</h3><p>既然第一种解决方式有问题，那么就采用第二种解决办法：用redis来存取session</p><p>redis就是独立的HashMap，用来存放键值对</p><p>这样当tomcat1需要保存session值的时候，就可以把它放在redis上，需要取的时候，也是从redis上面取</p><p><strong>场景</strong></p><ul><li>用户提交账号密码的行为被分配在了tomcat_8333上，登陆信息被存放在redis里</li><li>当用户第二次访问的时候，被分配到了tomcat_8444上</li><li>那么此时tomcat_8333就会从redis去获取相关信息，一看有对应信息，那么就会呈现出登陆状态</li></ul><h4 id="具体实现"><a class="markdownIt-Anchor" href="#具体实现"></a> 具体实现</h4><ol><li>启动redis</li><li>给两个tomcat使用jar包</li><li>配置两个tomcat</li><li>重启两个tomcat</li><li>测试</li></ol><h5 id="启动redis"><a class="markdownIt-Anchor" href="#启动redis"></a> 启动redis</h5><p>在redis安装路劲点击<code>redis-server.exe</code>运行</p><h5 id="jar包"><a class="markdownIt-Anchor" href="#jar包"></a> jar包</h5><ul><li><p>所需要的jar包</p></li><li><p>tomcat需要链接redis，所以需要专门的jar包</p><ul><li>下载好放在两个tomcat的lib目录下即可</li></ul></li></ul><h5 id="修改contextxml"><a class="markdownIt-Anchor" href="#修改contextxml"></a> 修改context.xml</h5><p>修改tomcat/conf/context.xml，增加如下代码</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">&quot;com.orangefunction.tomcat.redissessions.RedisSessionManager&quot;</span></span><span class="tag"><span class="attr">host</span>=<span class="string">&quot;127.0.0.1&quot;</span></span><span class="tag"><span class="attr">port</span>=<span class="string">&quot;6379&quot;</span></span><span class="tag"><span class="attr">database</span>=<span class="string">&quot;0&quot;</span></span><span class="tag"><span class="attr">maxInactiveInterval</span>=<span class="string">&quot;60&quot;</span> /&gt;</span></code></pre><h5 id="重启tomcat"><a class="markdownIt-Anchor" href="#重启tomcat"></a> 重启tomcat</h5><p>两个tomcat都需要重启</p><h5 id="分别测试访问两个tomcat"><a class="markdownIt-Anchor" href="#分别测试访问两个tomcat"></a> 分别测试访问两个tomcat</h5><p>Redis session共享机制和nginx其实无关，是发生在nginx之后的事情，所以直接访问login.jsp，然后登陆，并观察到已登陆状态</p><p>即在tomcat1登陆成功后，登陆tomcat2，也是登陆成功状态</p><h2 id="虚拟主机"><a class="markdownIt-Anchor" href="#虚拟主机"></a> 虚拟主机</h2><p>虚拟主机，<strong>就是将一台物理服务器虚拟为多个服务器来使用</strong>，从而实现在一台服务器上配置多个站点，即可以在一台物理主机上配置多个域名。Nginx中，一个server标签就是一台虚拟主机，配置多个server标签就虚拟出了多台主机。</p><p>Nginx虚拟主机的实现方式有两种:域名虚拟方式与端口虚拟方式。</p><ul><li><strong>域名虚拟</strong>方式是指不同的虑拟机使用不同的域名, 通过不同的域名虚拟出不同的主机</li><li><strong>端口虚拟</strong>方式是指不同的虚拟机使用相同的域名不同的端口号，通过不同的端口号虚拟出不同的主机。 基于端口的虚拟方式不常用。</li></ul><h3 id="总体规划"><a class="markdownIt-Anchor" href="#总体规划"></a> 总体规划</h3><p>现在很多生活服务类网络平台都具有这样的功能。不同城市的用户可以打开不同城市专属的站点。用户首先打开的是平台总的站点，然后允许用户切换到不同的城市。其实，不同的城市都是一个不同的站点。</p><p>这里我们要实现的功能是为平台总站点北京、上海两个城市站点分别创建一个虚拟主机。每一个虚拟主机都具有两台Tomcat的负载均衡主机。由于有三个站点，所以共需六台Tomcat主机，克隆Tomcat主机太过麻烦，所以这六台Tomcat我们使用一台主机实现。在一台主机中安 装六个Tomcat，它们分别使用六个不同的端口号。</p><p>首先要创建一个web工程，其中就一个index.jsp页面，页面除了显示当前城市外，还要显示城市切换的超链接。为了能够再明显的区分出当前访问的Tomcat,再在页面中显示出当前工程所在的主机名与端口号。</p><h3 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h3><p>在nginx中，一个server标签就是一个虚拟主机，如果需要虚拟多个主机，我们就可以配多个server标签</p><h3 id="配置虚拟主机"><a class="markdownIt-Anchor" href="#配置虚拟主机"></a> 配置虚拟主机</h3><p>对于虚拟主机的配置，可以写道两个地方，直接写入当前nginx.conf中，或者可以单独的写入一个文件，采用虚拟主机单独占用一个文件的方式，便于后期对于虚拟主机的维护</p><p><strong>虚拟主机的配置文件配置方式：</strong></p><ul><li>server name 为虚拟服务器的识别路径。因此不同的域名会通过请求头中的HOST字段，匹配到特定的server块，转发到对应的应用服务器中去</li></ul><pre><code class="highlight properties"><span class="comment">#user  nobody;</span><span class="comment">#工作进程</span><span class="attr">worker_processes</span>  <span class="string">1;</span><span class="comment"></span><span class="comment">#error_log  logs/error.log;</span><span class="comment">#error_log  logs/error.log  notice;</span><span class="comment">#error_log  logs/error.log  info;</span><span class="comment"></span><span class="comment">#pid        logs/nginx.pid;</span><span class="attr">events</span> <span class="string">&#123;</span>    <span class="attr">worker_connections</span>  <span class="string">1024;</span><span class="attr">&#125;</span><span class="attr">http</span> <span class="string">&#123;</span>    <span class="attr">include</span>       <span class="string">mime.types;</span>    <span class="attr">default_type</span>  <span class="string">application/octet-stream;</span><span class="comment"></span><span class="comment">    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><span class="comment">    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><span class="comment">    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><span class="comment"></span><span class="comment">    #access_log  logs/access.log  main;</span>    <span class="attr">sendfile</span>        <span class="string">on;</span><span class="comment">    #tcp_nopush     on;</span><span class="comment"></span><span class="comment">    #keepalive_timeout  0;</span>    <span class="attr">keepalive_timeout</span>  <span class="string">65;</span><span class="comment"></span><span class="comment">    #gzip  on;</span>        <span class="attr">upstream</span> <span class="string">cent&#123;</span>        <span class="attr">server</span> <span class="string">192.168.1.1:8081 weight=1;</span>        <span class="attr">server</span> <span class="string">192.168.1.1:8082 eight=1;</span>    <span class="attr">&#125;</span>    <span class="attr">upstream</span> <span class="string">beijing</span>        <span class="attr">server</span> <span class="string">192.168.1.1:8083 weight=1;</span>        <span class="attr">server</span> <span class="string">192.168.1.1:8084 weight=1;</span>    <span class="attr">&#125;</span>        <span class="attr">upstream</span> <span class="string">shanghai</span>        <span class="attr">server</span> <span class="string">192.168.1.1:8085 weight=1;</span>        <span class="attr">server</span> <span class="string">192.168.1.1:8086 weight=1;</span>    <span class="attr">&#125;</span>            <span class="attr">server&#123;</span>        <span class="attr">listen</span>       <span class="string">80;</span>        <span class="attr">server_name</span>  <span class="string">www.cent.com;</span>                <span class="attr">location</span> <span class="string">/ &#123;</span>            <span class="attr">proxy_pass</span> <span class="string">http://cent;</span>        <span class="attr">&#125;</span>    <span class="attr">&#125;</span>    <span class="attr">server&#123;</span>        <span class="attr">listen</span>       <span class="string">80;</span>        <span class="attr">server_name</span>  <span class="string">www.beijing.com;</span>                <span class="attr">location</span> <span class="string">/ &#123;</span>            <span class="attr">proxy_pass</span> <span class="string">http://beijing;</span>        <span class="attr">&#125;</span>    <span class="attr">&#125;</span>    <span class="attr">server&#123;</span>        <span class="attr">listen</span>       <span class="string">80;</span>        <span class="attr">server_name</span>  <span class="string">www.shanghai.com</span>                <span class="attr">location</span> <span class="string">/ &#123;</span>            <span class="attr">proxy_pass</span> <span class="string">http://shagnhai;</span>        <span class="attr">&#125;</span>    <span class="attr">&#125;</span>    <span class="attr">server</span> <span class="string">&#123;</span>        <span class="attr">listen</span>       <span class="string">80;</span>        <span class="attr">server_name</span>  <span class="string">localhost;</span><span class="comment"></span><span class="comment">        #charset koi8-r;</span><span class="comment"></span><span class="comment">        #access_log  logs/host.access.log  main;</span><span class="comment">        #默认访问目录</span><span class="comment">        #表示默认访问html目录下的index.html，html表示相对路径，可以写绝对路径</span><span class="comment">        #如果写成location /usr&#123; &#125; 就表示访问localhost/usr默认访问html目录下usr目录下的index.html</span>        <span class="attr">location</span> <span class="string">/ &#123;</span>            <span class="attr">root</span>   <span class="string">html;</span>            <span class="attr">index</span>  <span class="string">index.html index.htm;</span>        <span class="attr">&#125;</span><span class="comment"></span><span class="comment">        #error_page  404              /404.html;</span><span class="comment"></span><span class="comment">        # redirect server error pages to the static page /50x.html</span><span class="comment">        #</span>        <span class="attr">error_page</span>   <span class="string">500 502 503 504  /50x.html;</span>        <span class="attr">location</span> = <span class="string">/50x.html &#123;</span>            <span class="attr">root</span>   <span class="string">html;</span>        <span class="attr">&#125;</span><span class="comment"></span><span class="comment">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><span class="comment">        #</span><span class="comment">        #location ~ \.php$ &#123;</span><span class="comment">        #    proxy_pass   http://127.0.0.1;</span><span class="comment">        #&#125;</span><span class="comment"></span><span class="comment">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><span class="comment">        #</span><span class="comment">        #location ~ \.php$ &#123;</span><span class="comment">        #    root           html;</span><span class="comment">        #    fastcgi_pass   127.0.0.1:9000;</span><span class="comment">        #    fastcgi_index  index.php;</span><span class="comment">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><span class="comment">        #    include        fastcgi_params;</span><span class="comment">        #&#125;</span><span class="comment"></span><span class="comment">        # deny access to .htaccess files, if Apache&#x27;s document root</span><span class="comment">        # concurs with nginx&#x27;s one</span><span class="comment">        #</span><span class="comment">        #location ~ /\.ht &#123;</span><span class="comment">        #    deny  all;</span><span class="comment">        #&#125;</span>    <span class="attr">&#125;</span><span class="comment"></span><span class="comment"></span><span class="comment">    # another virtual host using mix of IP-, name-, and port-based configuration</span><span class="comment">    #</span><span class="comment">    #server &#123;</span><span class="comment">    #    listen       8000;</span><span class="comment">    #    listen       somename:8080;</span><span class="comment">    #    server_name  somename  alias  another.alias;</span><span class="comment"></span><span class="comment">    #    location / &#123;</span><span class="comment">    #        root   html;</span><span class="comment">    #        index  index.html index.htm;</span><span class="comment">    #    &#125;</span><span class="comment">    #&#125;</span><span class="comment"></span><span class="comment"></span><span class="comment">    # HTTPS server</span><span class="comment">    #</span><span class="comment">    #server &#123;</span><span class="comment">    #    listen       443 ssl;</span><span class="comment">    #    server_name  localhost;</span><span class="comment"></span><span class="comment">    #    ssl_certificate      cert.pem;</span><span class="comment">    #    ssl_certificate_key  cert.key;</span><span class="comment"></span><span class="comment">    #    ssl_session_cache    shared:SSL:1m;</span><span class="comment">    #    ssl_session_timeout  5m;</span><span class="comment"></span><span class="comment">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><span class="comment">    #    ssl_prefer_server_ciphers  on;</span><span class="comment"></span><span class="comment">    #    location / &#123;</span><span class="comment">    #        root   html;</span><span class="comment">    #        index  index.html index.htm;</span><span class="comment">    #    &#125;</span><span class="comment">    #&#125;</span><span class="attr">&#125;</span></code></pre><p>匹配的就是我们访问的这个host字段，可以让不同的域名指向相同的ip，然后通过nginx的虚拟主机 匹配到不同的服务器上面去</p><h2 id="nginx性能调优"><a class="markdownIt-Anchor" href="#nginx性能调优"></a> Nginx性能调优</h2><h3 id="nginx进程"><a class="markdownIt-Anchor" href="#nginx进程"></a> Nginx进程</h3><p>当nginx启动后，使用<code>ps -aux|grep nginx</code>命令查看当前系统运行的进程，我们发现有关Nginx的有两个进程：master与worker</p><ul><li><strong>master进程</strong>：用于管理worker进程，例如，对worker进程工作状态的监控，当请求到达时应该将请求交给那个worker进行处理等</li><li><strong>worker进程</strong>：专门用于处理客户端请求的进程，其可以配置多个，但默认只有一个</li></ul><h3 id="worker_processes"><a class="markdownIt-Anchor" href="#worker_processes"></a> worker_processes</h3><p>打开nginx.conf配置文件，可以看到<strong>worker_processes的默认值为1</strong></p><p>worker_processes：工作进程，用于指定Nginx的工作进程数量，该数值一般设置为cpu的内核数量，或<strong>内核数量的整数倍</strong></p><blockquote><p>注意：现代的cpu一般都是多内核的</p></blockquote><p>若当前系统具有2块cpu，而每块cpu中包含2个内核，那么，worker_Processes的值一般可以设置为4或者8，也可以设置2</p><p>不过，该值不仅仅取决于cpu内核数量，还有硬盘及负载均衡模式相关，<strong>在不确定时可以指定其值为auto</strong></p><h3 id="worker_cpu_affinity"><a class="markdownIt-Anchor" href="#worker_cpu_affinity"></a> worker_cpu_affinity</h3><p>为了进一步提高系统性能，我们会将worker进程与具体的内核进行绑定，该绑定操作是通过了worker_cpu_affinity属性进行设置的。</p><p><strong>不过，若指定worker_processes的值为auto，则无法设置worker_cpu_affinity</strong>。</p><p>该设置是通过二进制进行的，每个内核使用一个二进制为表示，0代表内核关闭，1代表内核开启，也就是说，有几个内核，就需要使用几个二进制位</p>]]>
    </content>
    <id>http://example.com/2022/06/01/Nginx/</id>
    <link href="http://example.com/2022/06/01/Nginx/"/>
    <published>2022-06-01T04:00:00.000Z</published>
    <summary>Nginx是一个轻量级，高性能的基于HTTP的反向代理服务器。Linux安装，请求定位，多个tomcat，反向代理，静态代理，动静分离，负载均衡，session共享，虚拟主机，调优。</summary>
    <title>Nginx</title>
    <updated>2026-02-27T01:11:08.943Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    <content>
      <![CDATA[<h1 id="python"><a class="markdownIt-Anchor" href="#python"></a> Python</h1><p>[toc]</p><h2 id="python解析器"><a class="markdownIt-Anchor" href="#python解析器"></a> Python解析器</h2><p><strong>CPython</strong></p><ul><li>当我们从Python官方网站下载并安装好Python 3.x后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。</li></ul><p><strong>PyPy</strong></p><ul><li>PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。</li></ul><p><strong>Jython</strong></p><ul><li>Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行</li></ul><p><strong>IronPython</strong></p><ul><li>IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。</li></ul><p><strong>小结</strong></p><ul><li>Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。</li></ul><h2 id="第一个python程序"><a class="markdownIt-Anchor" href="#第一个python程序"></a> 第一个Python程序</h2><h3 id="python交互模式"><a class="markdownIt-Anchor" href="#python交互模式"></a> Python交互模式</h3><ul><li>Python程序的后缀为<code> .py</code></li><li>在Windows命令行模式下敲命令 <code>python</code> , 输出如下文本，就进入Python交互模式，他的提示符是 <code>&gt;&gt;&gt;</code><br />*</li><li>输入<code>exit()</code>回车，就可以退出Python交互模式，并回到命令行模式</li><li>可以使用<code>print()</code>函数，打印指定的文字，把文字用<strong>单引号</strong>或<strong>双引号</strong>括起来</li></ul><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;hello,world&#x27;</span>)hello,world<span class="meta">&gt;&gt;&gt; </span><span class="number">2</span>**<span class="number">10</span><span class="number">1024</span></code></pre><p><strong>在命令行执行<code>.py</code>文件</strong></p><ul><li><a href="http://calc.py">calc.py</a></li></ul><pre><code class="highlight python"><span class="built_in">print</span>(<span class="number">100</span>+<span class="number">200</span>+<span class="number">300</span>)</code></pre><ul><li>执行（先进入<code>.py</code>文件所在的文件夹）</li></ul><pre><code class="highlight python">C:\work&gt;python calc.py<span class="number">600</span></code></pre><ul><li>在python交互模式下，可以直接输入代码，然后执行，可以立刻得到结果</li><li>在命令模式下，可以直接运行<code>.py</code>文件</li></ul><h3 id="使用文本编辑器"><a class="markdownIt-Anchor" href="#使用文本编辑器"></a> 使用文本编辑器</h3><ul><li>使用文本编辑器直接写python程序，然后保存为<code>.py</code>，就可以用python直接运行这个程序了</li><li>直接输入<code>python</code>进入交互模式，相当于启动了python解释器，但是等待你一行一行的输入源代码，每输入一行就执行一行</li><li>直接运行<code>.py</code>文件相当于启动了python解释器，然后一次性把<code>.py</code>文件的源代码给执行了</li></ul><p><strong>如何直接运行<code>.py</code>文件</strong></p><ul><li>Windows：<ul><li>不可以直接运行</li></ul></li><li>Linux：<ul><li>在<code>.py</code>文件第一行加上<code>#!/usr/bin/env python3</code></li><li>使用chmod命令加可执行权限</li></ul></li></ul><h3 id="输入和输出"><a class="markdownIt-Anchor" href="#输入和输出"></a> 输入和输出</h3><h4 id="输出"><a class="markdownIt-Anchor" href="#输出"></a> 输出</h4><ul><li>用<code>print()</code>在括号中加上字符串，就可以输出指定文字</li><li><code>print()</code>函数也可以接受多个字符串，用逗号“,”隔开(&quot;,&quot;就表示一个空格)，就可以连成一串输出</li><li><code>print()</code>也可以使用加号，拼接字符串</li><li><code>print()</code>也可以打印整数，或者计算结果</li></ul><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;hello, world&#x27;</span>)hello, world<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;The quick brown fox&#x27;</span>, <span class="string">&#x27;jumps over&#x27;</span>, <span class="string">&#x27;the lazy dog&#x27;</span>)The quick brown fox jumps over the lazy dog<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;The quick brown fox&#x27;</span>+<span class="string">&#x27;jumps over&#x27;</span>, <span class="string">&#x27;the lazy dog&#x27;</span>)The quick brown foxjumps over the lazy dog<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">300</span>)<span class="number">300</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">100</span> + <span class="number">200</span>)<span class="number">300</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;100 + 200 =&#x27;</span>, <span class="number">100</span> + <span class="number">200</span>)<span class="number">100</span> + <span class="number">200</span> = <span class="number">300</span></code></pre><ul><li></li></ul><h4 id="输入"><a class="markdownIt-Anchor" href="#输入"></a> 输入</h4><ul><li><code>input()</code>，可以让用户输入字符串</li></ul><p>当运行下述代码，Python交互式命令就在等待用户的输入，可以输入任意的字符</p><pre><code class="highlight python">name = <span class="built_in">input</span>()<span class="built_in">print</span>(<span class="string">&#x27;hello,&#x27;</span>, name)输入输出:Michaelhello, Michael</code></pre><p>示例</p><pre><code class="highlight py">name = <span class="built_in">input</span>(<span class="string">&quot;Please enter your name: &quot;</span>)<span class="built_in">print</span>(<span class="string">f&quot;\nHello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)<span class="comment">##可使用函数int() ，它让Python将输入视为数值</span>age = <span class="built_in">input</span>(<span class="string">&quot;how old are you ?&quot;</span>)age = <span class="built_in">int</span>(age)<span class="built_in">print</span>(<span class="string">f&quot;是否成年：<span class="subst">&#123;age&gt;<span class="number">18</span>&#125;</span>&quot;</span>)prompt = <span class="string">&quot;\nTell me something, and I will repeat it back to you:&quot;</span>prompt += <span class="string">&quot;\nEnter &#x27;quit&#x27; to end the program. &quot;</span>active = <span class="literal">True</span>message = <span class="string">&quot;&quot;</span><span class="keyword">while</span> active:    message = <span class="built_in">input</span>(prompt)    <span class="keyword">if</span> message == <span class="string">&#x27;quit&#x27;</span>:        active = <span class="literal">False</span>    <span class="keyword">else</span>:        <span class="built_in">print</span>(message)<span class="comment">##break退出循环</span><span class="keyword">while</span> <span class="literal">True</span>:    message = <span class="built_in">input</span>(prompt)    <span class="keyword">if</span> message == <span class="string">&#x27;quit&#x27;</span>:        <span class="keyword">break</span>;    <span class="keyword">else</span>:        <span class="built_in">print</span>(message)<span class="comment">##continue跳过一次循环</span>current_number = <span class="number">1</span><span class="keyword">while</span> current_number &lt; <span class="number">10</span>:    current_number+=<span class="number">1</span>    <span class="keyword">if</span> current_number % <span class="number">2</span> == <span class="number">0</span>:        <span class="keyword">continue</span>    <span class="built_in">print</span>(current_number)</code></pre><h2 id="python基础"><a class="markdownIt-Anchor" href="#python基础"></a> python基础</h2><h3 id="格式"><a class="markdownIt-Anchor" href="#格式"></a> 格式</h3><ul><li>python的语法比较简单，采用<strong>缩进方式</strong></li></ul><pre><code class="highlight plaintext">#print absolute value of an integer:a = 100if a &gt;= 0:    print(a)else:    print(-a)</code></pre><blockquote><ul><li>以 <code>#</code> 开头的语句是注释，多行注释以’‘‘开头，’’'结束</li><li>当语句以冒号 <code>:</code> 结尾时，后面缩进tab的语句为代码块，缩进<strong>强制 4 空格</strong>格式</li><li><strong>无“：”符号</strong>的语句，每行为一条语句，可通过‘ /’（续行符）再换行则换行的代码也属于同一条语句</li><li><strong>带“：”符号</strong>则缩进区域到下一条语句前为同一语句（代码块）。另外当有括号时，成对括号之间换行仍属于同一条语句（[],（）,{}）</li><li><strong>大小写敏感</strong>，严格区分大小写</li><li><strong>弱类型</strong>（一般根据输入的内容判断变量类型）</li><li>缩进的好处时强迫写出缩进较少的代码，你会倾向于把一段很长的代码拆分成若干个函数，从而得到缩进较少的代码</li><li>坏处就是不能复制粘贴，IDE无法格式化Python代码</li></ul></blockquote><h3 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h3><h4 id="整数int"><a class="markdownIt-Anchor" href="#整数int"></a> 整数int</h4><ul><li><strong>Python可以处理任意大小的整数</strong>，负整数，写法与数学一摸一样</li><li>计算机由于使用二进制，使用十六进制表示整数比较方便，十六进制用<code>0x</code>前缀和<code>0-9,a-f</code>表示，例如：0xff00，0xa5b4c3d2</li><li>对于很大的数，例如10000000000，很难数清楚0的个数。Python允许在数字中间以_分隔，因此，写成10_000_000_000和10000000000是完全一样的。十六进制数也可以写成0xa1b2_c3d4。</li></ul><h4 id="浮点数float"><a class="markdownIt-Anchor" href="#浮点数float"></a> 浮点数float</h4><ul><li><strong>浮点数也就是小数</strong>，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10<sup>9和12.3x10</sup>8是完全相等的</li><li>对于很大或很小的浮点数，使用科学记数法表示，把10用e表示，1.23x10^9就是1.23e9，或者12.3e8，0.000012就是1.2e-5</li><li>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差</li></ul><hr /><p>整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; 10 / 33.3333333333333335</code></pre><p><strong>/除法计算结果是浮点数，即使是两个整数恰好整除</strong>，结果也是浮点数：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; 9 / 33.0</code></pre><hr /><p><strong>还有一种除法是//，称为地板除</strong>，两个整数的除法仍然是整数：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; 10 // 33</code></pre><blockquote><p>你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。</p></blockquote><p>因为//除法只取结果的整数部分，所以Python还提供一个<strong>余数运算</strong>，可以得到两个整数相除的余数：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; 10 % 31</code></pre><h4 id="字符串str"><a class="markdownIt-Anchor" href="#字符串str"></a> 字符串str</h4><ul><li><strong>字符串是以单引号’或双引号&quot;括起来的任意文本</strong>，比如’abc’，“xyz&quot;等等。请注意，''或”“本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。如果’本身也是一个字符，那就可以用”&quot;括起来，比如&quot;I’m OK&quot;包含的字符是I，'，m，空格，O，K这6个字符。</li><li>如果字符串内部既包含’又包含&quot;怎么办？可以用转义字符\来标识，比如：</li></ul><pre><code class="highlight plaintext">&#x27;I\&#x27;m \&quot;OK\&quot;!&#x27;表示I&#x27;m &quot;OK&quot;!</code></pre><ul><li><strong>转义字符\可以转义很多字符</strong>，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\表示的字符就是\，可以在Python的交互式命令行用print()打印字符串看看：</li></ul><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;I\&#x27;m ok.&#x27;</span>)I<span class="string">&#x27;m ok.</span><span class="string">&gt;&gt;&gt; print(&#x27;</span>I\<span class="string">&#x27;m learning\nPython.&#x27;</span>)I<span class="string">&#x27;m learning</span><span class="string">Python.</span><span class="string">&gt;&gt;&gt; print(&#x27;</span>\\\n\\<span class="string">&#x27;)</span><span class="string">\</span><span class="string">\</span></code></pre><ul><li>如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还<strong>允许用r’‘表示’'内部的字符串默认不转义</strong>，可以自己试试：</li></ul><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;\\\t\\&#x27;</span>)\       \<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">r&#x27;\\\t\\&#x27;</span>)\\\t\\</code></pre><ul><li><strong>如果字符串内部有很多换行</strong>，用\n写在一行里不好阅读，为了简化，Python允许用’‘’…‘’'的格式表示多行内容，可以自己试试：</li></ul><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&#x27;&#x27;line1</span><span class="string"><span class="meta">... </span>line2</span><span class="string"><span class="meta">... </span>line3&#x27;&#x27;&#x27;</span>)line1line2line3</code></pre><blockquote><p>上面是在交互式命令行内输入，注意在输入多行内容时，提示符由&gt;&gt;&gt;变为…，提示你可以接着上一行输入，注意…是提示符，不是代码的一部分：</p></blockquote><blockquote><p>当输入完结束符’''和括号)后，执行该语句并打印结果。</p></blockquote><ul><li><strong>多行字符串’‘’…‘’'还可以在前面加上r(不转义)使用</strong>，请自行测试：</li></ul><pre><code class="highlight python"><span class="built_in">print</span>(<span class="string">r&#x27;&#x27;&#x27;hello,\n</span><span class="string">world&#x27;&#x27;&#x27;</span>)</code></pre><ul><li>常用函数</li></ul><pre><code class="highlight python">message = <span class="string">&quot;this is string&quot;</span><span class="comment">#首字母大写</span>message.title()<span class="comment">#转大写</span>message.upper()<span class="comment">#转小写</span>message.lower()<span class="comment">#去除首位空格，lstrip rstrip 删除首/尾空格</span>message.strip()</code></pre><ul><li>格式字符串f</li></ul><p>要在字符串中插入变量的值，可在前引号前加上字母f再将要插入的变量放在花括号内。这样，当Python显示字符串时，将把每个变量都替换为其值。</p><p>这种字符串名为f字符串 。f是format（设置格式）的简写，因为Python通过把花括号内的变量替换为其值来设置字符串的格式。</p><pre><code class="highlight python">first_name = <span class="string">&quot;lee&quot;</span>last_name = <span class="string">&quot;bo&quot;</span><span class="built_in">print</span>(first_name + <span class="string">&quot; &quot;</span> + last_name)<span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;first_name&#125;</span> <span class="subst">&#123;last_name&#125;</span>&#x27;</span>)</code></pre><h4 id="布尔值"><a class="markdownIt-Anchor" href="#布尔值"></a> 布尔值</h4><p>布尔值和布尔代数的表示完全一致，<strong>一个布尔值只有True、False两种值</strong>，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; TrueTrue&gt;&gt;&gt; FalseFalse&gt;&gt;&gt; 3 &gt; 2True&gt;&gt;&gt; 3 &gt; 5False</code></pre><p><strong>布尔值可以用and、or和not运算</strong>。</p><ul><li>and运算是与运算，只有所有都为True，and运算结果才是True：</li></ul><pre><code class="highlight plaintext">&gt;&gt;&gt; True and TrueTrue&gt;&gt;&gt; True and FalseFalse&gt;&gt;&gt; False and FalseFalse&gt;&gt;&gt; 5 &gt; 3 and 3 &gt; 1True</code></pre><ul><li>or运算是或运算，只要其中有一个为True，or运算结果就是True：</li></ul><pre><code class="highlight plaintext">&gt;&gt;&gt; True or TrueTrue&gt;&gt;&gt; True or FalseTrue&gt;&gt;&gt; False or FalseFalse&gt;&gt;&gt; 5 &gt; 3 or 1 &gt; 3True</code></pre><ul><li>not运算是非运算，它是一个单目运算符，把True变成False，False变成True：</li></ul><pre><code class="highlight plaintext">&gt;&gt;&gt; not TrueFalse&gt;&gt;&gt; not FalseTrue&gt;&gt;&gt; not 1 &gt; 2True</code></pre><p>布尔值经常用在条件判断中，比如：</p><pre><code class="highlight python"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:    <span class="built_in">print</span>(<span class="string">&#x27;adult&#x27;</span>)<span class="keyword">else</span>:    <span class="built_in">print</span>(<span class="string">&#x27;teenager&#x27;</span>)</code></pre><h4 id="空值none"><a class="markdownIt-Anchor" href="#空值none"></a> 空值None</h4><p><strong>空值是Python里一个特殊的值，用None</strong>表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</p><h4 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h4><p>变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</p><p>变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如：</p><ul><li>变量a是一个整数。</li></ul><pre><code class="highlight plaintext">a = 1</code></pre><ul><li>变量t_007是一个字符串</li></ul><pre><code class="highlight plaintext">t_007 = &#x27;T007&#x27;</code></pre><ul><li>变量Answer是一个布尔值True</li></ul><pre><code class="highlight plaintext">Answer = True</code></pre><ul><li>同时给多字段赋值</li></ul><pre><code class="highlight py"><span class="comment">#同时给多个字段赋值</span>name,age,adress = <span class="string">&quot;lee bo&quot;</span>,<span class="number">15</span>,<span class="string">&quot;xi&#x27;an&quot;</span></code></pre><p>在Python中，<strong>等号=是赋值语句</strong>，可以把任意数据类型赋值给变量，<strong>同一个变量可以反复赋值，而且可以是不同类型的变量</strong>，例如：</p><pre><code class="highlight python">a = <span class="number">123</span> <span class="comment"># a是整数</span><span class="built_in">print</span>(a)a = <span class="string">&#x27;ABC&#x27;</span> <span class="comment"># a变为字符串</span><span class="built_in">print</span>(a)</code></pre><blockquote><p>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：</p></blockquote><pre><code class="highlight java"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">123</span>; <span class="comment">// a是整数类型变量</span>a = <span class="string">&quot;ABC&quot;</span>; <span class="comment">// 错误：不能把字符串赋给整型变量</span></code></pre><hr /><p>最后，理解变量在计算机内存中的表示也非常重要。当我们写：</p><pre><code class="highlight plaintext">a = &#x27;ABC&#x27;</code></pre><p>时，Python解释器干了两件事情：</p><ul><li>在内存中创建了一个’ABC’的字符串；</li><li>在内存中创建了一个名为a的变量，并把它指向’ABC’。</li></ul><p>也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：</p><pre><code class="highlight python">a = <span class="string">&#x27;ABC&#x27;</span>b = aa = <span class="string">&#x27;XYZ&#x27;</span><span class="built_in">print</span>(b)   <span class="comment">#ABC</span></code></pre><ol><li>执行a = ‘ABC’，解释器创建了字符串’ABC’和变量a，并把a指向’ABC’：</li><li>执行b = a，解释器创建了变量b，并把b指向a指向的字符串’ABC’：</li><li>执行a = ‘XYZ’，解释器创建了字符串’XYZ’，并把a的指向改为’XYZ’，但b并没有更改：</li></ol><h4 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h4><p>所谓<strong>常量就是不能变的变量</strong>，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：</p><pre><code class="highlight python">PI = <span class="number">3.14159265329</span></code></pre><blockquote><p><strong>但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变</strong>，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。</p></blockquote><h3 id="字符串编码"><a class="markdownIt-Anchor" href="#字符串编码"></a> 字符串/编码</h3><p>字符串也是一种数据类型，但是，字符串比较特殊的是还有一个编码问题。</p><p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295</p><p>由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。</p><p>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。</p><p>你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。</p><p>因此，Unicode字符集应运而生。<strong>Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了</strong>。</p><p>Unicode标准也在不断发展，但最常用的是UCS-16编码，用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p><p>现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。</p><ul><li>字母A用ASCII编码是十进制的65，二进制的01000001；</li><li>字符0用ASCII编码是十进制的48，二进制的00110000，注意字符’0’和整数0是不同的；</li><li>汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。</li></ul><p>你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。</p><p>新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p><p>所以，本着节约的精神，又出现了<strong>把Unicode编码转化为“可变长编码”的UTF-8编码</strong>。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：</p><table><thead><tr><th>字符</th><th>ASCII</th><th>Unicode</th><th>UTF-8</th></tr></thead><tbody><tr><td>A</td><td>01000001</td><td>00000000 01000001</td><td>01000001</td></tr><tr><td>中</td><td>x</td><td>01001110 00101101</td><td>11100100 10111000 10101101</td></tr></tbody></table><p>从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。</p><p>搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：</p><ul><li><strong>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</strong></li></ul><p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：</p><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：</p><p>所以你看到很多网页的源码上会有类似<meta charset="UTF-8" />的信息，表示该网页正是用的UTF-8编码。</p><h4 id="python的字符串"><a class="markdownIt-Anchor" href="#python的字符串"></a> python的字符串</h4><p>在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; print(&#x27;包含中文的str&#x27;)包含中文的str</code></pre><p>对于单个字符的编码，Python提供了</p><ul><li>ord()函数获取字符的整数表示</li><li>chr()函数把编码转换为对应的字符</li></ul><pre><code class="highlight plaintext">&gt;&gt;&gt; ord(&#x27;A&#x27;)65&gt;&gt;&gt; ord(&#x27;中&#x27;)20013&gt;&gt;&gt; chr(66)&#x27;B&#x27;&gt;&gt;&gt; chr(25991)&#x27;文&#x27;</code></pre><p>如果知道字符的整数编码，还可以用十六进制这么写str：</p><ul><li>两种写法完全是等价的</li></ul><pre><code class="highlight plaintext">&gt;&gt;&gt; &#x27;\u4e2d\u6587&#x27;&#x27;中文&#x27;&gt;&gt;&gt; &#x27;中文&#x27;&#x27;中文&#x27;</code></pre><p>由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。<strong>如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes</strong>。</p><hr /><p><strong>bytes类型</strong></p><ul><li>Python对<strong>bytes类型的数据用带b前缀的单引号或双引号表示</strong>：</li></ul><pre><code class="highlight plaintext">x = b&#x27;ABC&#x27;</code></pre><blockquote><p>注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。</p></blockquote><p><strong>encode()</strong></p><ul><li>以Unicode表示的str通过<strong>encode()方法可以编码为指定的bytes</strong>，例如：</li></ul><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;ABC&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>)<span class="string">b&#x27;ABC&#x27;</span><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)<span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>)Traceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;UnicodeEncodeError: <span class="string">&#x27;ascii&#x27;</span> codec can<span class="string">&#x27;t encode characters in position 0-1: ordinal not in range(128)</span></code></pre><blockquote><p>纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。</p></blockquote><blockquote><p>在bytes中，无法显示为ASCII字符的字节，用\x##显示。</p></blockquote><p><strong>decode()</strong></p><ul><li>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。<strong>要把bytes变为str，就需要用decode()方</strong>法：</li></ul><pre><code class="highlight plaintext">&gt;&gt;&gt; b&#x27;ABC&#x27;.decode(&#x27;ascii&#x27;)&#x27;ABC&#x27;&gt;&gt;&gt; b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;.decode(&#x27;utf-8&#x27;)&#x27;中文&#x27;</code></pre><ul><li>如果bytes中包含无法解码的字节，decode()方法会报错：</li></ul><pre><code class="highlight plaintext">&gt;&gt;&gt; b&#x27;\xe4\xb8\xad\xff&#x27;.decode(&#x27;utf-8&#x27;)Traceback (most recent call last):  ...UnicodeDecodeError: &#x27;utf-8&#x27; codec can&#x27;t decode byte 0xff in position 3: invalid start byte</code></pre><ul><li>如果bytes中只有一小部分无效的字节，可以<strong>传入errors='ignore’忽略错误</strong>的字节：</li></ul><pre><code class="highlight plaintext">&gt;&gt;&gt; b&#x27;\xe4\xb8\xad\xff&#x27;.decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;)&#x27;中&#x27;</code></pre><p><strong>len()</strong></p><ul><li>要计算str包含多少个字符，可以用len()函数：</li></ul><pre><code class="highlight plaintext">&gt;&gt;&gt; len(&#x27;ABC&#x27;)3&gt;&gt;&gt; len(&#x27;中文&#x27;)2</code></pre><ul><li>len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：</li></ul><pre><code class="highlight plaintext">&gt;&gt;&gt; len(b&#x27;ABC&#x27;)3&gt;&gt;&gt; len(b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;)6&gt;&gt;&gt; len(&#x27;中文&#x27;.encode(&#x27;utf-8&#x27;))6</code></pre><blockquote><p>可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节</p></blockquote><blockquote><p>在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。</p></blockquote><p>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在<strong>保存源代码时，就需要务必指定保存为UTF-8编码</strong>。当Python解释器<strong>读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行</strong>：</p><ul><li>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</li><li>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</li></ul><pre><code class="highlight python"><span class="comment">#!/usr/bin/env python3</span><span class="comment"># -*- coding: utf-8 -*-</span></code></pre><p>申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码：</p><p>如果.py文件本身使用UTF-8编码，并且也申明了<code># -*- coding: utf-8 -*-</code>，打开命令提示符测试就可以正常显示中文：</p><h4 id="格式化"><a class="markdownIt-Anchor" href="#格式化"></a> 格式化</h4><p>我们经常会输出类似’亲爱的xxx你好！你xx月的话费是xx，余额是xx’之类的字符串，而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。</p><p>在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; &#x27;Hello, %s&#x27; % &#x27;world&#x27;&#x27;Hello, world&#x27;&gt;&gt;&gt; &#x27;Hi, %s, you have $%d.&#x27; % (&#x27;Michael&#x27;, 1000000)&#x27;Hi, Michael, you have $1000000.&#x27;</code></pre><p>你可能猜到了，%<strong>运算符就是用来格式化字符串的</strong>。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。</p><table><thead><tr><th>占位符</th><th>替换内容</th></tr></thead><tbody><tr><td>%d</td><td>整数</td></tr><tr><td>%f</td><td>浮点数</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%x</td><td>十六进制整数</td></tr></tbody></table><p>其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：</p><pre><code class="highlight python"><span class="comment"># -*- coding: utf-8 -*-</span><span class="built_in">print</span>(<span class="string">&#x27;%2d-%02d&#x27;</span> % (<span class="number">3</span>, <span class="number">1</span>))<span class="built_in">print</span>(<span class="string">&#x27;%.2f&#x27;</span> % <span class="number">3.1415926</span>)<span class="comment">#输出</span> <span class="number">3</span>-01<span class="number">3.14</span></code></pre><p>如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; &#x27;Age: %s. Gender: %s&#x27; % (25, True)&#x27;Age: 25. Gender: True&#x27;</code></pre><p>有些时候，字符串里面的%是一个普通字符怎么办？这个时候就<strong>需要转义，用%%来表示一个%</strong>：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; &#x27;growth rate: %d %%&#x27; % 7growth rate: 7 %&#x27;</code></pre><p><strong>format()</strong></p><ul><li>另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多：</li></ul><pre><code class="highlight plaintext">&gt;&gt;&gt; &#x27;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&#x27;.format(&#x27;小明&#x27;, 17.125)&#x27;Hello, 小明, 成绩提升了 17.1%&#x27;</code></pre><p><strong>f-string</strong></p><p>最后一种格式化字符串的方法是使用以f开头的字符串，称之为f-string，它和普通字符串不同之处在于，字符串如果包含{xxx}，就会以对应的变量替换：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; r = 2.5&gt;&gt;&gt; s = 3.14 * r ** 2&gt;&gt;&gt; print(f&#x27;The area of a circle with radius &#123;r&#125; is &#123;s:.2f&#125;&#x27;)The area of a circle with radius 2.5 is 19.62</code></pre><blockquote><p>上述代码中，{r}被变量r的值替换，{s:.2f}被变量s的值替换，并且:后面的.2f指定了格式化参数（即保留两位小数），因此，{s:.2f}的替换结果是19.62。</p></blockquote><h3 id="使用list和tuple"><a class="markdownIt-Anchor" href="#使用list和tuple"></a> 使用list和tuple</h3><h4 id="list"><a class="markdownIt-Anchor" href="#list"></a> list[]</h4><p>Python内置的一种数据类型是列表：list。list是一种<strong>有序的集合</strong>，可以随时添加和删除其中的元素。</p><p>比如，列出班里所有同学的名字，就可以用一个list表示：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; classmates = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]&gt;&gt;&gt; classmates[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</code></pre><p>变量classmates就是一个list。用len()函数可以获得list元素的个数：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; len(classmates)3</code></pre><p>用索引来访问list中每一个位置的元素，记得索引是从0开始的：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; classmates[0]&#x27;Michael&#x27;&gt;&gt;&gt; classmates[1]&#x27;Bob&#x27;&gt;&gt;&gt; classmates[2]&#x27;Tracy&#x27;&gt;&gt;&gt; classmates[3]Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range</code></pre><p>当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得<strong>最后一个元素的索引是len(classmates) - 1</strong></p><p>如果要取最后一个元素，除了计算索引位置外，还可以<strong>用-1做索引，直接获取最后一个元素</strong>：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; classmates[-1]&#x27;Tracy&#x27;&gt;&gt;&gt; classmates[-2]&#x27;Bob&#x27;&gt;&gt;&gt; classmates[-3]&#x27;Michael&#x27;&gt;&gt;&gt; classmates[-4]Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range</code></pre><p><strong>list是一个可变的有序表</strong></p><ul><li>往list中<strong>追加元素到末尾</strong>：</li></ul><pre><code class="highlight plaintext">&gt;&gt;&gt; classmates.append(&#x27;Adam&#x27;)&gt;&gt;&gt; classmates[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;]</code></pre><ul><li><strong>插入到指定的位置</strong>，比如索引号为1的位置：</li></ul><pre><code class="highlight plaintext">&gt;&gt;&gt; classmates.insert(1, &#x27;Jack&#x27;)&gt;&gt;&gt; classmates[&#x27;Michael&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;]</code></pre><ul><li>要<strong>删除list末尾的元素</strong>，用pop()方法：</li></ul><pre><code class="highlight plaintext">&gt;&gt;&gt; classmates.pop()&#x27;Adam&#x27;&gt;&gt;&gt; classmates[&#x27;Michael&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</code></pre><p>要<strong>删除指定位置的元素</strong>，用pop(i)方法，其中i是索引位置：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; classmates.pop(1)&#x27;Jack&#x27;&gt;&gt;&gt; classmates[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]#或者&gt;&gt;&gt; del motorcycles[1]</code></pre><p>删除指定名字的元素</p><pre><code class="highlight py"><span class="comment">##删除指定元素的首个</span>motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]too_expensive = <span class="string">&quot;yamaha&quot;</span>motorcycles.remove(too_expensive)</code></pre><p>要把某个<strong>元素替换成别的元素</strong>，可以直接赋值给对应的索引位置：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; classmates[1] = &#x27;Sarah&#x27;&gt;&gt;&gt; classmates[&#x27;Michael&#x27;, &#x27;Sarah&#x27;, &#x27;Tracy&#x27;]</code></pre><p>list里面的<strong>元素的数据类型也可以不同</strong>，比如：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; L = [&#x27;Apple&#x27;, 123, True]</code></pre><p><strong>排序</strong></p><pre><code class="highlight py"><span class="comment">##排序</span>cars = [<span class="string">&quot;bmw&quot;</span>,<span class="string">&quot;audi&quot;</span>,<span class="string">&quot;toyota&quot;</span>,<span class="string">&quot;subaru&quot;</span>]cars_copy = cars<span class="comment">##默认按照字母顺序排序（永久排序）</span>cars.sort()<span class="built_in">print</span>(cars)<span class="comment">##反向排序</span>cars.sort(reverse=<span class="literal">True</span>)<span class="built_in">print</span>(cars)<span class="comment">##临时排序</span>cars = [<span class="string">&quot;bmw&quot;</span>,<span class="string">&quot;audi&quot;</span>,<span class="string">&quot;toyota&quot;</span>,<span class="string">&quot;subaru&quot;</span>]<span class="built_in">print</span>(<span class="string">&quot;here is the original list:&quot;</span>)<span class="built_in">print</span>(cars)<span class="built_in">print</span>(<span class="string">&quot;here is the sorted list:&quot;</span>)<span class="built_in">print</span>(<span class="built_in">sorted</span>(cars))<span class="built_in">print</span>(<span class="built_in">sorted</span>(cars,reverse=<span class="literal">True</span>))<span class="built_in">print</span>(<span class="string">&quot;here is the original list again:&quot;</span>)<span class="built_in">print</span>(cars)<span class="comment">##反转列表</span>cars = [<span class="string">&quot;bmw&quot;</span>,<span class="string">&quot;audi&quot;</span>,<span class="string">&quot;toyota&quot;</span>,<span class="string">&quot;subaru&quot;</span>]<span class="built_in">print</span>(cars)cars.reverse()<span class="built_in">print</span>(cars)</code></pre><p><strong>list元素也可以是另一个list</strong>，比如：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; s = [&#x27;python&#x27;, &#x27;java&#x27;, [&#x27;asp&#x27;, &#x27;php&#x27;], &#x27;scheme&#x27;]&gt;&gt;&gt; len(s)4</code></pre><p>要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; p = [&#x27;asp&#x27;, &#x27;php&#x27;]&gt;&gt;&gt; s = [&#x27;python&#x27;, &#x27;java&#x27;, p, &#x27;scheme&#x27;]</code></pre><blockquote><p>要拿到’php’可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到。</p></blockquote><p>如果一个list中一个元素也没有，就是一个空的list，它的长度为0：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; L = []&gt;&gt;&gt; len(L)0</code></pre><p>边循环边删除元素只能用while</p><pre><code class="highlight py"><span class="comment">#for循环是一种遍历列表的有效方式，但不应在for 循环中修改列 表，否则将导致Python难以跟踪其中的元素。要在遍历列表的同时 对其进行修改，可使用while 循环。通过将while 循环同列表和字 典结合起来使用，可收集、存储并组织大量输入，供以后查看和显示。</span><span class="comment"># 首先，创建一个待验证用户列表</span><span class="comment"># 和一个用于存储已验证用户的空列表。</span>unconfirmed_users = [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;brian&#x27;</span>, <span class="string">&#x27;candace&#x27;</span>]confirmed_users = []<span class="keyword">while</span> unconfirmed_users:    current_user = unconfirmed_users.pop()    <span class="built_in">print</span>(<span class="string">f&quot;Verifying user:<span class="subst">&#123;current_user.title()&#125;</span>&quot;</span>)    confirmed_users.append(current_user)<span class="comment">##循环删除列表元素</span>pets = [<span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;goldfish&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;rabbit&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>]<span class="built_in">print</span>(pets)<span class="keyword">while</span> <span class="string">&#x27;cat&#x27;</span> <span class="keyword">in</span> pets:    pets.remove(<span class="string">&#x27;cat&#x27;</span>)<span class="built_in">print</span>(pets)<span class="comment">##使用用户输入来填充字典</span>responses = &#123;&#125;polling_active = <span class="literal">True</span><span class="keyword">while</span> polling_active:    name = <span class="built_in">input</span>(<span class="string">&quot;\nWhat is your name?&quot;</span>)    response = <span class="built_in">input</span>(<span class="string">&quot;Which mountain would you like to climb someday&quot;</span>)    <span class="comment"># 将回答存储在字典中</span>    responses[name] = response    <span class="comment"># 看看是否还有人要参与调查。</span>    repeat = <span class="built_in">input</span>(<span class="string">&quot;Would you like to let another person respond? (yes/ no) &quot;</span>)    <span class="keyword">if</span> repeat == <span class="string">&#x27;no&#x27;</span>:        polling_active = <span class="literal">False</span></code></pre><h4 id="tuple"><a class="markdownIt-Anchor" href="#tuple"></a> tuple()</h4><p>另一种有序列表叫元组：tuple。tuple和list非常类似，但是<strong>tuple一旦初始化就不能修改</strong>，比如同样是列出同学的名字：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; classmates = (&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;)</code></pre><p>现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。</p><p>不可变的tuple有什么意义？<strong>因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple</strong></p><p>tuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来，比如：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; t = (1, 2)&gt;&gt;&gt; t(1, 2)</code></pre><p>如果要定义一个空的tuple，可以写成()：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; t = ()&gt;&gt;&gt; t()</code></pre><p>但是，要定义一个只有1个元素的tuple，如果你这么定义：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; t = (1)&gt;&gt;&gt; t1</code></pre><blockquote><p>定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。</p></blockquote><p>所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; t(1,)</code></pre><p>Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。</p><p><strong>可变的tuple</strong>：</p><pre><code class="highlight plaintext">&gt;&gt;&gt; t = (&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;A&#x27;, &#x27;B&#x27;])&gt;&gt;&gt; t[2][0] = &#x27;X&#x27;&gt;&gt;&gt; t[2][1] = &#x27;Y&#x27;&gt;&gt;&gt; t(&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;X&#x27;, &#x27;Y&#x27;])</code></pre><p>这个tuple定义的时候有3个元素，分别是’a’，'b’和一个list。不是说tuple一旦定义后就不可变了吗？怎么后来又变了？</p><p>当我们把list的元素’A’和’B’修改为’X’和’Y’后，tuple变为：</p><p>表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！</p><h3 id="条件判断"><a class="markdownIt-Anchor" href="#条件判断"></a> 条件判断</h3><p>计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。</p><p>比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，用if语句实现：</p><pre><code class="highlight python">age = <span class="number">20</span><span class="keyword">if</span> age &gt;= <span class="number">18</span>:    <span class="built_in">print</span>(<span class="string">&#x27;your age is&#x27;</span>, age)    <span class="built_in">print</span>(<span class="string">&#x27;adult&#x27;</span>)</code></pre><blockquote><p>根据Python的缩进规则，如果if语句判断是True，就把缩进的两行print语句执行了，否则，什么也不做</p></blockquote><p>也可以给if添加一个else语句，意思是，如果if判断是False，不要执行if的内容，去把else执行了：</p><ul><li><strong>注意不要少写了冒号</strong></li></ul><pre><code class="highlight python">age = <span class="number">3</span><span class="keyword">if</span> age &gt;= <span class="number">18</span>:    <span class="built_in">print</span>(<span class="string">&#x27;your age is&#x27;</span>, age)    <span class="built_in">print</span>(<span class="string">&#x27;adult&#x27;</span>)<span class="keyword">else</span>:    <span class="built_in">print</span>(<span class="string">&#x27;your age is&#x27;</span>, age)    <span class="built_in">print</span>(<span class="string">&#x27;teenager&#x27;</span>)</code></pre><p>elif是else if的缩写，完全可以有多个elif，所以if语句的完整形式就是：</p><pre><code class="highlight plaintext">if &lt;条件判断1&gt;:    &lt;执行1&gt;elif &lt;条件判断2&gt;:    &lt;执行2&gt;elif &lt;条件判断3&gt;:    &lt;执行3&gt;else:    &lt;执行4&gt;</code></pre><p>if语句执行有个特点，它是从上往下判断，如果在<strong>某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else</strong>，所以，请测试并解释为什么下面的程序打印的是teenager：</p><pre><code class="highlight python">age = <span class="number">20</span><span class="keyword">if</span> age &gt;= <span class="number">6</span>:    <span class="built_in">print</span>(<span class="string">&#x27;teenager&#x27;</span>)<span class="keyword">elif</span> age &gt;= <span class="number">18</span>:    <span class="built_in">print</span>(<span class="string">&#x27;adult&#x27;</span>)<span class="keyword">else</span>:    <span class="built_in">print</span>(<span class="string">&#x27;kid&#x27;</span>)</code></pre><p>if判断条件还可以简写，比如写：</p><ul><li>只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。</li></ul><pre><code class="highlight python"><span class="keyword">if</span> x:    <span class="built_in">print</span>(<span class="string">&#x27;True&#x27;</span>)</code></pre><blockquote><p><strong>如果if条件中是一个list，则列表至少包含一个元素时返回True ，并在列表为空时返回False</strong></p></blockquote><p>多条件的if：</p><pre><code class="highlight py"><span class="comment">##多个条件比较and/or</span>age = <span class="number">50</span><span class="keyword">if</span> (age&gt;=<span class="number">18</span>) <span class="keyword">and</span> (age&lt;=<span class="number">30</span>):    <span class="built_in">print</span>(<span class="string">&quot;young people!&quot;</span>)<span class="keyword">elif</span> (age&lt;<span class="number">19</span>) <span class="keyword">or</span> (age&gt;<span class="number">30</span>):    <span class="built_in">print</span>(<span class="string">&quot;no young people!&quot;</span>)</code></pre><p><strong>字符串比较</strong></p><pre><code class="highlight py">alien = <span class="string">&quot;yellow&quot;</span><span class="keyword">if</span> alien == <span class="string">&#x27;green&#x27;</span>:    points = <span class="number">5</span><span class="keyword">elif</span> alien == <span class="string">&#x27;yellow&#x27;</span>:    points = <span class="number">10</span><span class="keyword">else</span>:    points = <span class="number">15</span><span class="built_in">print</span>(<span class="string">f&quot;Players scored <span class="subst">&#123;points&#125;</span> points!&quot;</span>)</code></pre><p><strong>in关键字</strong></p><pre><code class="highlight py"><span class="comment">##in包含关键字</span>requested_toppings = [<span class="string">&#x27;mushrooms&#x27;</span>,<span class="string">&#x27;onions&#x27;</span>,<span class="string">&#x27;pineapple&#x27;</span>]<span class="keyword">if</span> <span class="string">&#x27;mushrooms&#x27;</span> <span class="keyword">in</span> requested_toppings:    <span class="built_in">print</span>(<span class="string">f&quot;requested_toppings contain mushrooms!&quot;</span>)<span class="keyword">else</span>:    <span class="built_in">print</span>(<span class="string">f&quot;requested_toppings no contain mushrooms!&quot;</span>)<span class="comment">##不包含</span><span class="keyword">if</span> <span class="string">&#x27;mushrooms&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> requested_toppings:    <span class="built_in">print</span>(<span class="string">f&quot;requested_toppings no contain mushrooms!&quot;</span>)<span class="keyword">else</span>:    <span class="built_in">print</span>(<span class="string">f&quot;requested_toppings contain mushrooms!&quot;</span>)</code></pre><hr /><p><strong>再议input</strong></p><p>最后看一个有问题的条件判断。很多同学会用input()读取用户的输入，这样可以自己输入，程序运行得更有意思：</p><pre><code class="highlight plaintext">birth = input(&#x27;birth: &#x27;)if birth &lt; 2000:    print(&#x27;00前&#x27;)else:    print(&#x27;00后&#x27;)</code></pre><p>输入1982，结果报错：</p><pre><code class="highlight plaintext">Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: unorderable types: str() &gt; int()</code></pre><p>这是<strong>因为input()返回的数据类型是str，str不能直接和整数比较</strong>，必须先把str转换成整数。Python提供了int()函数来完成这件事情：</p><pre><code class="highlight python">s = <span class="built_in">input</span>(<span class="string">&#x27;birth: &#x27;</span>)birth = <span class="built_in">int</span>(s)<span class="keyword">if</span> birth &lt; <span class="number">2000</span>:    <span class="built_in">print</span>(<span class="string">&#x27;00前&#x27;</span>)<span class="keyword">else</span>:    <span class="built_in">print</span>(<span class="string">&#x27;00后&#x27;</span>)</code></pre><p>再次运行，就可以得到正确地结果。但是，如果输入abc呢？又会得到一个错误信息：</p><pre><code class="highlight plaintext">Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: invalid literal for int() with base 10: &#x27;abc&#x27;</code></pre><p>原来int()函数发现一个字符串并不是合法的数字时就会报错，程序就退出了。</p><h3 id="循环"><a class="markdownIt-Anchor" href="#循环"></a> 循环</h3><h4 id="for"><a class="markdownIt-Anchor" href="#for"></a> for</h4><p>Python的循环有两种，一种是for…in循环，依次把list或tuple中的每个元素迭代出来</p><pre><code class="highlight python">names = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]<span class="keyword">for</span> name <span class="keyword">in</span> names:    <span class="built_in">print</span>(name)</code></pre><blockquote><p>所以for x in …循环就是把每个元素代入变量x，然后执行缩进块的语句。</p></blockquote><p>再比如我们想计算1-10的整数之和，可以用一个sum变量做累加：</p><pre><code class="highlight python"><span class="built_in">sum</span> = <span class="number">0</span><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]:    <span class="built_in">sum</span> = <span class="built_in">sum</span> + x<span class="built_in">print</span>(<span class="built_in">sum</span>)</code></pre><p><strong>range()</strong></p><ul><li>如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数：</li></ul><pre><code class="highlight py"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>))[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]<span class="comment">##range函数可以生成数字</span><span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):    <span class="built_in">print</span>(value)<span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):    <span class="built_in">print</span>(value)numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>))<span class="built_in">print</span>(numbers)<span class="comment">##第三个参数是步长的意思</span>even_numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2</span>,<span class="number">11</span>,<span class="number">2</span>))<span class="built_in">print</span>(even_numbers)<span class="comment">##列表解析</span>squares = [value**<span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)]<span class="built_in">print</span>(squares)</code></pre><p>range(101)就可以生成0-100的整数序列，计算如下：</p><pre><code class="highlight python"><span class="comment"># -*- coding: utf-8 -*-</span><span class="built_in">sum</span> = <span class="number">0</span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>):    <span class="built_in">sum</span> = <span class="built_in">sum</span> + x<span class="built_in">print</span>(<span class="built_in">sum</span>)</code></pre><h4 id="while"><a class="markdownIt-Anchor" href="#while"></a> while</h4><p>第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：</p><pre><code class="highlight plaintext">sum = 0n = 99while n &gt; 0:    sum = sum + n    n = n - 2print(sum)</code></pre><blockquote><p>在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出</p></blockquote><h4 id="break"><a class="markdownIt-Anchor" href="#break"></a> break</h4><p>如果要<strong>提前结束循环</strong>，可以用break语句：</p><pre><code class="highlight python">n = <span class="number">1</span><span class="keyword">while</span> n &lt;= <span class="number">100</span>:    <span class="keyword">if</span> n &gt; <span class="number">10</span>: <span class="comment"># 当n = 11时，条件满足，执行break语句</span>        <span class="keyword">break</span> <span class="comment"># break语句会结束当前循环</span>    <span class="built_in">print</span>(n)    n = n + <span class="number">1</span><span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</code></pre><blockquote><p>执行上面的代码可以看到，打印出1~10后，紧接着打印END，程序结束</p></blockquote><h4 id="continue"><a class="markdownIt-Anchor" href="#continue"></a> continue</h4><p>在循环过程中，也可以通过continue语句，<strong>跳过当前的这次循环</strong>，直接开始下一次循环。</p><pre><code class="highlight python">n = <span class="number">0</span><span class="keyword">while</span> n &lt; <span class="number">10</span>:    n = n + <span class="number">1</span>    <span class="built_in">print</span>(n)</code></pre><p>上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用continue语句跳过某些循环：</p><pre><code class="highlight python">n = <span class="number">0</span><span class="keyword">while</span> n &lt; <span class="number">10</span>:    n = n + <span class="number">1</span>    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>: <span class="comment"># 如果n是偶数，执行continue语句</span>        <span class="keyword">continue</span> <span class="comment"># continue语句会直接继续下一轮循环，后续的print()语句不会执行</span>    <span class="built_in">print</span>(n)</code></pre><blockquote><p>执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9</p></blockquote><h3 id="使用dict和set"><a class="markdownIt-Anchor" href="#使用dict和set"></a> 使用dict和set</h3><h4 id="dict"><a class="markdownIt-Anchor" href="#dict"></a> dict{}</h4><p>和list比较，dict有以下几个特点：</p><ul><li>查找和插入的速度极快，不会随着key的增加而变慢；</li><li>需要占用大量的内存，内存浪费多。</li></ul><p>而list相反：</p><ul><li>查找和插入的时间随着元素的增加而增加；</li><li>占用空间小，浪费内存很少。</li></ul><blockquote><p>所以，dict是用空间来换取时间的一种方法。</p></blockquote><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用<strong>键-值（key-value）存储，具有极快的查找速度</strong>。</p><p>举个例子，假设要根据同学的名字查找对应的成绩，如果用list实现，需要两个list：</p><pre><code class="highlight python">names = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]scores = [<span class="number">95</span>, <span class="number">75</span>, <span class="number">85</span>]</code></pre><p>给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，list越长，耗时越长。</p><p>如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;Michael&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;Bob&#x27;</span>: <span class="number">75</span>, <span class="string">&#x27;Tracy&#x27;</span>: <span class="number">85</span>&#125;<span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Michael&#x27;</span>]<span class="number">95</span></code></pre><p>为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。</p><p>第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。</p><p>dict就是第二种实现方式，给定一个名字，比如’Michael’，dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。</p><p>你可以猜到，<strong>这种key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value</strong>。</p><p>把<strong>数据放入dict</strong>的方法，除了初始化时指定外，还可以通过key放入：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Adam&#x27;</span>] = <span class="number">67</span><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Adam&#x27;</span>]<span class="number">67</span></code></pre><p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Jack&#x27;</span>] = <span class="number">90</span><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Jack&#x27;</span>]<span class="number">90</span><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Jack&#x27;</span>] = <span class="number">88</span><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Jack&#x27;</span>]<span class="number">88</span></code></pre><p>如果key不存在，dict就会报错：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Thomas&#x27;</span>]Traceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;KeyError: <span class="string">&#x27;Thomas&#x27;</span></code></pre><p><strong>要避免key不存在的错误</strong>，有两种办法</p><ul><li>一是通过in判断key是否存在：</li></ul><pre><code class="highlight plaintext">&gt;&gt;&gt; &#x27;Thomas&#x27; in dFalse</code></pre><ul><li>二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：</li></ul><pre><code class="highlight plaintext">&gt;&gt;&gt; d.get(&#x27;Thomas&#x27;)&gt;&gt;&gt; d.get(&#x27;Thomas&#x27;, -1)-1</code></pre><blockquote><p>注意：返回None的时候Python的交互环境不显示结果</p></blockquote><p><strong>要删除一个key</strong>，用pop(key)方法，对应的value也会从dict中删除：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>d.pop(<span class="string">&#x27;Bob&#x27;</span>)<span class="number">75</span><span class="meta">&gt;&gt;&gt; </span>d&#123;<span class="string">&#x27;Michael&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;Tracy&#x27;</span>: <span class="number">85</span>&#125;</code></pre><blockquote><p>请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。</p></blockquote><p>dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条<strong>就是dict的key必须是不可变对象</strong>。</p><p>这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。</p><p>要保证hash的正确性，作为key的对象就不能变。在Python中，<strong>字符串、整数等都是不可变的</strong>，因此，可以放心地作为key。而list是可变的，就不能作为key：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>key = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]<span class="meta">&gt;&gt;&gt; </span>d[key] = <span class="string">&#x27;a list&#x27;</span>Traceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></code></pre><p>基本操作</p><pre><code class="highlight py"><span class="comment">#dict字典，相当于map</span><span class="comment">#6.1一个简单的字典</span>alien = &#123;<span class="string">&#x27;color&#x27;</span>:<span class="string">&#x27;green&#x27;</span>,<span class="string">&#x27;points&#x27;</span>:<span class="number">5</span>&#125;<span class="built_in">print</span>(alien[<span class="string">&#x27;color&#x27;</span>])<span class="built_in">print</span>(alien[<span class="string">&#x27;points&#x27;</span>])<span class="comment">#6.2使用字典，字典用&#123;&#125;表示</span><span class="comment">##字典 是一系列键值对 。每个键 都与一个值相关联， 你可使用键来访问相关联的值。与键相关联的值可以是数、字符 串、列表乃至字典。</span>alien = &#123;<span class="string">&#x27;color&#x27;</span>:<span class="string">&#x27;green&#x27;</span>,<span class="string">&#x27;points&#x27;</span>:<span class="number">5</span>&#125;new_points = alien[<span class="string">&#x27;points&#x27;</span>]<span class="built_in">print</span>(<span class="string">f&quot;You just earned <span class="subst">&#123;new_points&#125;</span> points!&quot;</span>)<span class="comment">##添加</span><span class="built_in">print</span>(alien)alien[<span class="string">&#x27;x_position&#x27;</span>] = <span class="number">0</span>alien[<span class="string">&#x27;y_position&#x27;</span>] = <span class="number">25</span><span class="built_in">print</span>(alien)<span class="comment">##创建一个空字典</span>alien = &#123;&#125;alien[<span class="string">&#x27;color&#x27;</span>] = <span class="string">&#x27;green&#x27;</span>alien[<span class="string">&#x27;points&#x27;</span>] = <span class="number">5</span><span class="built_in">print</span>(alien)<span class="comment">##修改</span>alien = &#123;<span class="string">&#x27;color&#x27;</span>:<span class="string">&#x27;green&#x27;</span>&#125;<span class="built_in">print</span>(<span class="string">f&quot;The alien is <span class="subst">&#123;alien[<span class="string">&#x27;color&#x27;</span>]&#125;</span>.&quot;</span>)alien[<span class="string">&#x27;color&#x27;</span>] = <span class="string">&#x27;yellow&#x27;</span><span class="built_in">print</span>(<span class="string">f&quot;The alien is now <span class="subst">&#123;alien[<span class="string">&#x27;color&#x27;</span>]&#125;</span>.&quot;</span>)<span class="comment">##删除(注意，删除的键会永远消失)</span>alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>:<span class="string">&#x27;green&#x27;</span>,<span class="string">&#x27;points&#x27;</span>:<span class="number">5</span>&#125;<span class="built_in">print</span>(alien_0)<span class="keyword">del</span> alien_0[<span class="string">&#x27;points&#x27;</span>]<span class="built_in">print</span>(alien_0)</code></pre><p>遍历dict</p><pre><code class="highlight py">user_0 = &#123;    <span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;dfermi&#x27;</span>,    <span class="string">&#x27;first&#x27;</span>:<span class="string">&#x27;enrico&#x27;</span>,    <span class="string">&#x27;last&#x27;</span>:<span class="string">&#x27;fermi&#x27;</span>,&#125;<span class="keyword">for</span> key,value <span class="keyword">in</span> user_0.items():    <span class="built_in">print</span>(<span class="string">f&quot;key:<span class="subst">&#123;key&#125;</span>&quot;</span>)    <span class="built_in">print</span>(<span class="string">f&quot;value:<span class="subst">&#123;value&#125;</span>&quot;</span>)    favorite_languages = &#123;    <span class="string">&#x27;jen&#x27;</span>:<span class="string">&#x27;python&#x27;</span>,    <span class="string">&#x27;sarah&#x27;</span>:<span class="string">&#x27;c&#x27;</span>,    <span class="string">&#x27;edward&#x27;</span>:<span class="string">&#x27;ruby&#x27;</span>,    <span class="string">&#x27;phil&#x27;</span>:<span class="string">&#x27;python&#x27;</span>,&#125;<span class="keyword">for</span> name,language <span class="keyword">in</span> favorite_languages.items():    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name.title()&#125;</span>&#x27;s favorite language is <span class="subst">&#123;language.title()&#125;</span>&quot;</span>)<span class="keyword">for</span> name <span class="keyword">in</span> favorite_languages.keys():    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name.title()&#125;</span>&quot;</span>)<span class="keyword">if</span> <span class="string">&#x27;erin&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> favorite_languages.keys():    <span class="built_in">print</span>(<span class="string">&quot;Erin, please take our poll!&quot;</span>)<span class="comment">##排序显示</span><span class="keyword">for</span> name <span class="keyword">in</span> <span class="built_in">sorted</span>(favorite_languages.keys()):    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name.title()&#125;</span> thank youe for taking the poll.&quot;</span>)<span class="comment">##遍历值</span><span class="keyword">for</span> language <span class="keyword">in</span> favorite_languages.values():    <span class="built_in">print</span>(language.title())<span class="built_in">print</span>(<span class="string">&quot;(\n&quot;</span>)<span class="comment">##遍历值时去重</span><span class="keyword">for</span> only_language <span class="keyword">in</span> <span class="built_in">set</span>(favorite_languages.values()):    <span class="built_in">print</span>(only_language.title())    <span class="comment">##字典中存储列表</span>pizza = &#123;    <span class="string">&#x27;crust&#x27;</span>:<span class="string">&#x27;thick&#x27;</span>,    <span class="string">&#x27;toppings&#x27;</span>:[<span class="string">&#x27;mushrooms&#x27;</span>,<span class="string">&#x27;extra cheese&#x27;</span>]&#125;<span class="built_in">print</span>(<span class="string">f&quot;You ordered a <span class="subst">&#123;pizza[<span class="string">&#x27;crust&#x27;</span>]&#125;</span>-crust pizza&quot;</span><span class="string">&quot;with the following toppings:&quot;</span>)<span class="keyword">for</span> topping <span class="keyword">in</span> pizza[<span class="string">&#x27;toppings&#x27;</span>]:    <span class="built_in">print</span>(<span class="string">f&quot;\t<span class="subst">&#123;topping&#125;</span>&quot;</span>)favorite_languages = &#123;    <span class="string">&#x27;jen&#x27;</span>: [<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;ruby&#x27;</span>],    <span class="string">&#x27;sarah&#x27;</span>: [<span class="string">&#x27;c&#x27;</span>],    <span class="string">&#x27;edward&#x27;</span>: [<span class="string">&#x27;ruby&#x27;</span>, <span class="string">&#x27;go&#x27;</span>],    <span class="string">&#x27;phil&#x27;</span>: [<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;haskell&#x27;</span>],    &#125;<span class="keyword">for</span> name,languages <span class="keyword">in</span> favorite_languages.items():    <span class="keyword">if</span> <span class="built_in">len</span>(languages) &gt; <span class="number">1</span>:        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name.title()&#125;</span>&#x27;s favorite languages are:&quot;</span>)        <span class="keyword">for</span> language <span class="keyword">in</span> languages:            <span class="built_in">print</span>(<span class="string">f&quot;\t<span class="subst">&#123;language.title()&#125;</span>&quot;</span>)    <span class="keyword">else</span>:        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name.title()&#125;</span>&#x27;s favorite languages is <span class="subst">&#123;languages[<span class="number">0</span>].title()&#125;</span>&quot;</span>)                <span class="comment">##字典中嵌套字典</span>users = &#123;    <span class="string">&#x27;aeinstein&#x27;</span>:&#123;        <span class="string">&#x27;first&#x27;</span>:<span class="string">&#x27;albert&#x27;</span>,        <span class="string">&#x27;last&#x27;</span>:<span class="string">&#x27;einstein&#x27;</span>,        <span class="string">&#x27;location&#x27;</span>: <span class="string">&#x27;princeton&#x27;</span>,        &#125;,    <span class="string">&#x27;mcurie&#x27;</span>: &#123;        <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;marie&#x27;</span>,        <span class="string">&#x27;last&#x27;</span>: <span class="string">&#x27;curie&#x27;</span>,        <span class="string">&#x27;location&#x27;</span>: <span class="string">&#x27;paris&#x27;</span>,        &#125;,    &#125;<span class="keyword">for</span> username,userinfo <span class="keyword">in</span> users.items():    <span class="built_in">print</span>(<span class="string">f&quot;Username:<span class="subst">&#123;username.title()&#125;</span>&quot;</span>)    full_name = <span class="string">f&quot;<span class="subst">&#123;userinfo[<span class="string">&#x27;first&#x27;</span>]&#125;</span> <span class="subst">&#123;userinfo[<span class="string">&#x27;last&#x27;</span>]&#125;</span>&quot;</span>    location = userinfo[<span class="string">&#x27;location&#x27;</span>]    <span class="built_in">print</span>(<span class="string">f&quot;\tfull_name:<span class="subst">&#123;full_name.title()&#125;</span>&quot;</span>)    <span class="built_in">print</span>(<span class="string">f&quot;\tlocation:<span class="subst">&#123;location.title()&#125;</span>&quot;</span>)</code></pre><h4 id="set"><a class="markdownIt-Anchor" href="#set"></a> set([])</h4><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p><p>要创建一个set，需要提供一个list作为输入集合：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])<span class="meta">&gt;&gt;&gt; </span>s&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</code></pre><blockquote><p>注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。</p></blockquote><p><strong>重复元素在set中自动被过滤</strong>：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])<span class="meta">&gt;&gt;&gt; </span>s&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</code></pre><p><strong>通过add(key)方法可以添加元素到set中</strong>，可以重复添加，但不会有效果：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)<span class="meta">&gt;&gt;&gt; </span>s&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;<span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)<span class="meta">&gt;&gt;&gt; </span>s&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</code></pre><p><strong>通过remove(key)方法可以删除元</strong>素：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="number">4</span>)<span class="meta">&gt;&gt;&gt; </span>s&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</code></pre><p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的<strong>交集、并集</strong>等操作：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])<span class="meta">&gt;&gt;&gt; </span>s2 = <span class="built_in">set</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])<span class="meta">&gt;&gt;&gt; </span>s1 &amp; s2&#123;<span class="number">2</span>, <span class="number">3</span>&#125;<span class="meta">&gt;&gt;&gt; </span>s1 | s2&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</code></pre><blockquote><p>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。</p></blockquote><h4 id="再议不可变对象"><a class="markdownIt-Anchor" href="#再议不可变对象"></a> 再议不可变对象</h4><p>上面我们讲了，str是不变对象，而list是可变对象。</p><p>对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]<span class="meta">&gt;&gt;&gt; </span>a.sort()<span class="meta">&gt;&gt;&gt; </span>a[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</code></pre><p>而对于不可变对象，比如str，对str进行操作呢：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&#x27;abc&#x27;</span><span class="meta">&gt;&gt;&gt; </span>a.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)<span class="string">&#x27;Abc&#x27;</span><span class="meta">&gt;&gt;&gt; </span>a<span class="string">&#x27;abc&#x27;</span></code></pre><p>虽然字符串有个replace()方法，也确实变出了’Abc’，但变量a最后仍是’abc’，应该怎么理解呢？</p><p>我们先把代码改成下面这样：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&#x27;abc&#x27;</span><span class="meta">&gt;&gt;&gt; </span>b = a.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)<span class="meta">&gt;&gt;&gt; </span>b<span class="string">&#x27;Abc&#x27;</span><span class="meta">&gt;&gt;&gt; </span>a<span class="string">&#x27;abc&#x27;</span></code></pre><p>要始终牢记的是，a是变量，而’abc’才是字符串对象！有些时候，我们经常说，对象a的内容是’abc’，但其实是指，a本身是一个变量，它指向的对象的内容才是’abc’：</p><p>当我们调用a.replace(‘a’, ‘A’)时，实际上调用方法replace是作用在字符串对象’abc’上的，而这个方法虽然名字叫replace，但却没有改变字符串’abc’的内容。相反，replace方法创建了一个新字符串’Abc’并返回，如果我们用变量b指向该新字符串，就容易理解了，变量a仍指向原有的字符串’abc’，但变量b却指向新字符串’Abc’了：</p><p>所以，<strong>对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的</strong>。</p><h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2><p>我们知道圆的面积计算公式为：<br />S = πr2</p><p>当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：</p><pre><code class="highlight python">r1 = <span class="number">12.34</span>r2 = <span class="number">9.08</span>r3 = <span class="number">73.1</span>s1 = <span class="number">3.14</span> * r1 * r1s2 = <span class="number">3.14</span> * r2 * r2s3 = <span class="number">3.14</span> * r3 * r3</code></pre><p>当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 * x * x不仅很麻烦，而且，如果要把3.14改成3.14159265359的时候，得全部替换。</p><p>有了函数，我们就不再每次写s = 3.14 * x * x，而是写成更有意义的函数调用s = area_of_circle(x)，而函数area_of_circle本身只需要写一次，就可以多次调用。</p><p>基本上所有的高级语言都支持函数，Python也不例外。Python不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。</p><p><strong>抽象</strong></p><p>抽象是数学中非常常见的概念。举个例子：</p><p>计算数列的和，比如：1 + 2 + 3 + … + 100，写起来十分不方便，于是数学家发明了求和符号∑，可以把1 + 2 + 3 + … + 100记作：</p><p>这种抽象记法非常强大，因为我们看到 ∑ 就可以理解成求和，而不是还原成低级的加法运算。而且，这种抽象记法是可扩展的，比如：</p><p>还原成加法运算就变成了：</p><p>(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + … + (100 x 100 + 1)</p><p>可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。</p><p>写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。</p><h3 id="调用函数"><a class="markdownIt-Anchor" href="#调用函数"></a> 调用函数</h3><p>Python内置了很多有用的函数，我们可以直接调用。</p><p>要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数abs，只有一个参数。可以直接从Python的官方网站查看文档：</p><p><a href="http://docs.python.org/3/library/functions.html#abs">http://docs.python.org/3/library/functions.html#abs</a></p><p>也可以在交互式命令行通过help(abs)查看abs函数的帮助信息。</p><p>调用abs函数：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(<span class="number">100</span>)<span class="number">100</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(-<span class="number">20</span>)<span class="number">20</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(<span class="number">12.34</span>)<span class="number">12.34</span></code></pre><p>调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(<span class="number">1</span>, <span class="number">2</span>)Traceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;TypeError: <span class="built_in">abs</span>() takes exactly one argument (<span class="number">2</span> given)</code></pre><p>如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(<span class="string">&#x27;a&#x27;</span>)Traceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;TypeError: bad operand <span class="built_in">type</span> <span class="keyword">for</span> <span class="built_in">abs</span>(): <span class="string">&#x27;str&#x27;</span></code></pre><p>而max函数max()可以接收任意多个参数，并返回最大的那个：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(<span class="number">1</span>, <span class="number">2</span>)<span class="number">2</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, -<span class="number">5</span>)<span class="number">3</span></code></pre><h4 id="数据类型转换"><a class="markdownIt-Anchor" href="#数据类型转换"></a> 数据类型转换</h4><p>Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;123&#x27;</span>)<span class="number">123</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="number">12.34</span>)<span class="number">12</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">float</span>(<span class="string">&#x27;12.34&#x27;</span>)<span class="number">12.34</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(<span class="number">1.23</span>)<span class="string">&#x27;1.23&#x27;</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(<span class="number">100</span>)<span class="string">&#x27;100&#x27;</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="number">1</span>)<span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="string">&#x27;&#x27;</span>)<span class="literal">False</span></code></pre><p><strong>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量</strong>，相当于给这个函数起了一个“别名”：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">abs</span> <span class="comment"># 变量a指向abs函数</span><span class="meta">&gt;&gt;&gt; </span>a(-<span class="number">1</span>) <span class="comment"># 所以也可以通过a调用abs函数</span><span class="number">1</span></code></pre><h3 id="定义函数"><a class="markdownIt-Anchor" href="#定义函数"></a> 定义函数</h3><p>在Python中，<strong>定义一个函数要使用def语句</strong>，依次写出<strong>函数名、括号、括号中的参数和冒号</strong>:，然后，<strong>在缩进块中编写函数体，函数的返回值用return语句返回</strong>。</p><p>我们以自定义一个求绝对值的my_abs函数为例：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">my_abs</span>(<span class="params">x</span>):    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:        <span class="keyword">return</span> x    <span class="keyword">else</span>:        <span class="keyword">return</span> -x</code></pre><blockquote><p>请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。</p></blockquote><p>如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。return None可以简写为return。</p><p>在Python交互环境中定义函数时，注意Python会出现…的提示。函数定义结束后需要按两次回车重新回到&gt;&gt;&gt;提示符下：</p><h4 id="导入文件函数"><a class="markdownIt-Anchor" href="#导入文件函数"></a> 导入文件/函数</h4><p>如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用<strong>from abstest import my_abs来导入my_abs()函数</strong>，注意abstest是文件名（不含.py扩展名）：</p><h4 id="空函数"><a class="markdownIt-Anchor" href="#空函数"></a> 空函数</h4><p>如果想定义一个什么事也不做的空函数，可以用pass语句：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">nop</span>():    <span class="keyword">pass</span></code></pre><p>pass语句什么都不做，那有什么用？实际上<strong>pass可以用来作为占位符</strong>，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。pass还可以用在其他语句里，比如：</p><pre><code class="highlight python"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</code></pre><blockquote><p>pass缺少了pass，代码运行就会有语法错误。</p></blockquote><h4 id="参数检查"><a class="markdownIt-Anchor" href="#参数检查"></a> 参数检查</h4><p>调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>my_abs(<span class="number">1</span>, <span class="number">2</span>)Traceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;TypeError: my_abs() takes <span class="number">1</span> positional argument but <span class="number">2</span> were given</code></pre><p>但是如果参数类型不对，Python解释器就无法帮我们检查。试试my_abs和内置函数abs的差别：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>my_abs(<span class="string">&#x27;A&#x27;</span>)Traceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> my_absTypeError: unorderable types: <span class="built_in">str</span>() &gt;= <span class="built_in">int</span>()<span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(<span class="string">&#x27;A&#x27;</span>)Traceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;TypeError: bad operand <span class="built_in">type</span> <span class="keyword">for</span> <span class="built_in">abs</span>(): <span class="string">&#x27;str&#x27;</span></code></pre><p>当传入了不恰当的参数时，内置函数abs会检查出参数错误，而我们定义的my_abs没有参数检查，会导致if语句出错，出错信息和abs不一样。所以，这个函数定义不够完善。</p><p>让我们修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。<strong>数据类型检查可以用内置函数isinstance()实现</strong>：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">my_abs</span>(<span class="params">x</span>):    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(x, (<span class="built_in">int</span>, <span class="built_in">float</span>)):        <span class="keyword">raise</span> TypeError(<span class="string">&#x27;bad operand type&#x27;</span>)    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:        <span class="keyword">return</span> x    <span class="keyword">else</span>:        <span class="keyword">return</span> -x</code></pre><p>添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>my_abs(<span class="string">&#x27;A&#x27;</span>)Traceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> my_absTypeError: bad operand <span class="built_in">type</span></code></pre><h4 id="返回多个值"><a class="markdownIt-Anchor" href="#返回多个值"></a> 返回多个值</h4><p>python是允许返回多个值的。</p><p>比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：</p><pre><code class="highlight python"><span class="keyword">import</span> math<span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">x, y, step, angle=<span class="number">0</span></span>):    nx = x + step * math.cos(angle)    ny = y - step * math.sin(angle)    <span class="keyword">return</span> nx, ny</code></pre><p><strong>import math语句表示导入math包，并允许后续代码引用math包里的sin、cos等函数</strong>。</p><p>然后，我们就可以同时获得返回值：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>x, y = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(x, y)<span class="number">151.96152422706632</span> <span class="number">70.0</span></code></pre><p>但其实这只是一种假象，Python<strong>函数返回的仍然是单一值</strong>：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>r = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(r)(<span class="number">151.96152422706632</span>, <span class="number">70.0</span>)</code></pre><p>原来返回值是一个<strong>tuple</strong>！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p><h3 id="函数的参数"><a class="markdownIt-Anchor" href="#函数的参数"></a> 函数的参数</h3><p>定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。</p><p>Python的函数定义非常简单，但灵活度却非常大。<strong>除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数</strong>，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。</p><h4 id="位置参数"><a class="markdownIt-Anchor" href="#位置参数"></a> 位置参数</h4><p>调用函数时，Python必须将函数调用中的每个实参都关联到函数定义中的一个形参。为此，最简单的关联方式是基于实参的顺序。这种关联方式称为位置实参。</p><p>我们先写一个计算x2的函数：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x</span>):    <span class="keyword">return</span> x * x;</code></pre><p>对于power(x)函数，参数x就是一个位置参数。当我们调用power函数时，必须传入有且仅有的一个参数x：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>power(<span class="number">5</span>)<span class="number">25</span><span class="meta">&gt;&gt;&gt; </span>power(<span class="number">15</span>)<span class="number">225</span></code></pre><p>或者我们可以增加一个参数来计算x^n</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x ,n</span>):    s = <span class="number">1</span>    <span class="keyword">while</span> n &gt; <span class="number">0</span>:        n = n - <span class="number">1</span>        s = s * x    <span class="keyword">return</span> s</code></pre><p>修改后的power(x, n)函数有两个参数：x和n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数x和n</p><h4 id="默认参数"><a class="markdownIt-Anchor" href="#默认参数"></a> 默认参数</h4><p>新的power(x, n)函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>power(<span class="number">5</span>)Traceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;TypeError: power() missing <span class="number">1</span> required positional argument: <span class="string">&#x27;n&#x27;</span></code></pre><blockquote><p>Python的错误信息很明确：调用函数power()缺少了一个位置参数n</p></blockquote><p>这个时候，默认参数就排上用场了。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x, n=<span class="number">2</span></span>):    s = <span class="number">1</span>    <span class="keyword">while</span> n &gt; <span class="number">0</span>:        n = n - <span class="number">1</span>        s = s * x    <span class="keyword">return</span> s</code></pre><p>这样，当我们调用power(5)时，相当于调用power(5, 2)：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>power(<span class="number">5</span>)<span class="number">25</span><span class="meta">&gt;&gt;&gt; </span>power(<span class="number">5</span>, <span class="number">2</span>)<span class="number">25</span></code></pre><p>而对于n &gt; 2的其他情况，就必须明确地传入n，比如power(5, 3)</p><p>从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意：</p><ul><li>一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；</li><li>二是如何设置默认参数。</li><li>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</li></ul><p>有多个默认参数时，调用的时候，既<strong>可以按顺序提供默认参数</strong>，比如调用enroll(‘Bob’, ‘M’, 7)，意思是，除了name，gender这两个参数外，最后1个参数应用在参数age上，city参数由于没有提供，仍然使用默认值。</p><p><strong>也可以不按顺序提供部分默认参数</strong>。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用enroll(‘Adam’, ‘M’, city=‘Tianjin’)，意思是，city参数用传进去的值，其他默认参数继续使用默认值。</p><hr /><p>默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑，演示如下：</p><p>先定义一个函数，传入一个list，添加一个END再返回：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">add_end</span>(<span class="params">L=[]</span>):    L.append(<span class="string">&#x27;END&#x27;</span>)    <span class="keyword">return</span> L</code></pre><p>当你正常调用时，结果似乎不错：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>add_end([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;END&#x27;</span>]<span class="meta">&gt;&gt;&gt; </span>add_end([<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>])[<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;END&#x27;</span>]</code></pre><p>当你使用默认参数调用时，一开始结果也是对的：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>add_end()[<span class="string">&#x27;END&#x27;</span>]</code></pre><p>但是，再次调用add_end()时，结果就不对了：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>add_end()[<span class="string">&#x27;END&#x27;</span>, <span class="string">&#x27;END&#x27;</span>]<span class="meta">&gt;&gt;&gt; </span>add_end()[<span class="string">&#x27;END&#x27;</span>, <span class="string">&#x27;END&#x27;</span>, <span class="string">&#x27;END&#x27;</span>]</code></pre><p>原因解释如下：</p><ul><li>Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。</li><li><strong>定义默认参数要牢记一点：默认参数必须指向不变对象</strong></li></ul><p>要修改上面的例子，我们可以用None这个不变对象来实现：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">add_end</span>(<span class="params">L=<span class="literal">None</span></span>):    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:        L = []    L.append(<span class="string">&#x27;END&#x27;</span>)    <span class="keyword">return</span> L</code></pre><p>现在，无论调用多少次，都不会有问题：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>add_end()[<span class="string">&#x27;END&#x27;</span>]<span class="meta">&gt;&gt;&gt; </span>add_end()[<span class="string">&#x27;END&#x27;</span>]</code></pre><blockquote><p>为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</p></blockquote><h4 id="可变参数"><a class="markdownIt-Anchor" href="#可变参数"></a> 可变参数</h4><p>在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。</p><p>我们以数学题为例子，给定一组数字a，b，c……，请计算a^2 + b^2 + c^2 + ……。</p><p>要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">numbers</span>):    <span class="built_in">sum</span> = <span class="number">0</span>    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:        <span class="built_in">sum</span> = <span class="built_in">sum</span> + n * n    <span class="keyword">return</span> <span class="built_in">sum</span></code></pre><p>但是调用的时候，需要先组装出一个list或tuple：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>calc([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])<span class="number">14</span><span class="meta">&gt;&gt;&gt; </span>calc((<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>))<span class="number">84</span></code></pre><p>如果利用可变参数，调用函数的方式可以简化成这样：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)<span class="number">14</span><span class="meta">&gt;&gt;&gt; </span>calc(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>)<span class="number">84</span></code></pre><p>所以，<strong>我们把函数的参数改为可变参数</strong>：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">*numbers</span>):    <span class="built_in">sum</span> = <span class="number">0</span>    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:        <span class="built_in">sum</span> = <span class="built_in">sum</span> + n * n    <span class="keyword">return</span> <span class="built_in">sum</span></code></pre><p>定义可变参数和定义一个list或tuple参数相比，<strong>仅仅在参数前面加了一<code>个*号</code>。在函数内部，参数numbers接收到的是一个tuple</strong>，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="number">1</span>, <span class="number">2</span>)<span class="number">5</span><span class="meta">&gt;&gt;&gt; </span>calc()<span class="number">0</span></code></pre><p>如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]<span class="meta">&gt;&gt;&gt; </span>calc(nums[<span class="number">0</span>], nums[<span class="number">1</span>], nums[<span class="number">2</span>])<span class="number">14</span></code></pre><p>这种写法当然是可行的，问题是太繁琐，所以<strong>Python允许你在list或tuple前面加一<code>个*号</code>，把list或tuple的元素变成可变参数传进去</strong>：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]<span class="meta">&gt;&gt;&gt; </span>calc(*nums)<span class="number">14</span></code></pre><blockquote><p><code>*nums</code>表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见</p></blockquote><h4 id="关键字参数"><a class="markdownIt-Anchor" href="#关键字参数"></a> 关键字参数</h4><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而<strong>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict</strong>。请看示例：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, **kw</span>):    <span class="built_in">print</span>(<span class="string">&#x27;name:&#x27;</span>, name, <span class="string">&#x27;age:&#x27;</span>, age, <span class="string">&#x27;other:&#x27;</span>, kw)</code></pre><p>函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Michael&#x27;</span>, <span class="number">30</span>)name: Michael age: <span class="number">30</span> other: &#123;&#125;</code></pre><p>也可以传入任意个数的关键字参数：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">35</span>, city=<span class="string">&#x27;Beijing&#x27;</span>)name: Bob age: <span class="number">35</span> other: &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>&#125;<span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">45</span>, gender=<span class="string">&#x27;M&#x27;</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)name: Adam age: <span class="number">45</span> other: &#123;<span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</code></pre><p>关键字参数有什么用？</p><ul><li>它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。</li></ul><p>和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>extra = &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;<span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, city=extra[<span class="string">&#x27;city&#x27;</span>], job=extra[<span class="string">&#x27;job&#x27;</span>])name: Jack age: <span class="number">24</span> other: &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</code></pre><p>当然，上面复杂的调用可以用简化的写法：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>extra = &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;<span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, **extra)name: Jack age: <span class="number">24</span> other: &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</code></pre><blockquote><p><code>**extra</code>表示把extra这个dict的所有key-value用关键字参数传入到函数的<code>**kw</code>参数，kw将获得一个dict，<strong>注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra</strong></p></blockquote><h4 id="命名关键字函数"><a class="markdownIt-Anchor" href="#命名关键字函数"></a> 命名关键字函数</h4><p>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查</p><p>仍以person()函数为例，我们希望检查是否有city和job参数：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, **kw</span>):    <span class="keyword">if</span> <span class="string">&#x27;city&#x27;</span> <span class="keyword">in</span> kw:        <span class="comment"># 有city参数</span>        <span class="keyword">pass</span>    <span class="keyword">if</span> <span class="string">&#x27;job&#x27;</span> <span class="keyword">in</span> kw:        <span class="comment"># 有job参数</span>        <span class="keyword">pass</span>    <span class="built_in">print</span>(<span class="string">&#x27;name:&#x27;</span>, name, <span class="string">&#x27;age:&#x27;</span>, age, <span class="string">&#x27;other:&#x27;</span>, kw)</code></pre><p>但是调用者仍可以传入不受限制的关键字参数：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, city=<span class="string">&#x27;Beijing&#x27;</span>, addr=<span class="string">&#x27;Chaoyang&#x27;</span>, zipcode=<span class="number">123456</span>)</code></pre><p>如果要<strong>限制关键字参数的名字</strong>，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, *, city, job</span>):    <span class="built_in">print</span>(name, age, city, job)</code></pre><p><strong>和关键字参数<code>**kw</code>不同，命名关键字参数需要一个<code>特殊分隔符*，*后面</code>的参数被视为命名关键字参数</strong>。</p><p>调用方式如下：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, city=<span class="string">&#x27;Beijing&#x27;</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)Jack <span class="number">24</span> Beijing Engineer</code></pre><p><strong>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个<code>特殊分隔符*了</code>：</strong></p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, *args, city, job</span>):    <span class="built_in">print</span>(name, age, args, city, job)</code></pre><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;libo&#x27;</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,city=<span class="string">&#x27;xian&#x27;</span>,job=<span class="string">&#x27;cxy&#x27;</span>)libo <span class="number">13</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) xian cxy</code></pre><p><strong>命名关键字参数必须传入参数名</strong>，这和位置参数不同。如果没有传入参数名，调用将报错：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;Engineer&#x27;</span>)Traceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;TypeError: person() takes <span class="number">2</span> positional arguments but <span class="number">4</span> were given</code></pre><blockquote><p>由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数</p></blockquote><p><strong>命名关键字参数可以有缺省值</strong>，从而简化调用：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, *, city=<span class="string">&#x27;Beijing&#x27;</span>, job</span>):    <span class="built_in">print</span>(name, age, city, job)</code></pre><p>由于命名关键字参数city具有默认值，调用时，可不传入city参数：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)Jack <span class="number">24</span> Beijing Engineer</code></pre><hr /><p>使用<strong>命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数</strong>：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, city, job</span>):    <span class="comment"># 缺少 *，city和job被视为位置参数</span>    <span class="keyword">pass</span></code></pre><h4 id="参数组合"><a class="markdownIt-Anchor" href="#参数组合"></a> 参数组合</h4><p>在Python中定义函数，可以用<strong>必选参数</strong>、<strong>默认参数</strong>、<strong>可变参数</strong>、<strong>关键字参数</strong>和<strong>命名关键字参数</strong>，这5种参数都可以组合使用。</p><p>但是请注意，参数定义的顺序必须是：</p><ul><li>必选参数-&gt;默认参数-&gt;可变参数-&gt;命名关键字参数和关键字参数</li></ul><p>比如定义一个函数，包含上述若干种参数：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">a, b, c=<span class="number">0</span>, *args, **kw</span>):    <span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a, <span class="string">&#x27;b =&#x27;</span>, b, <span class="string">&#x27;c =&#x27;</span>, c, <span class="string">&#x27;args =&#x27;</span>, args, <span class="string">&#x27;kw =&#x27;</span>, kw)<span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">a, b, c=<span class="number">0</span>, *, d, **kw</span>):    <span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a, <span class="string">&#x27;b =&#x27;</span>, b, <span class="string">&#x27;c =&#x27;</span>, c, <span class="string">&#x27;d =&#x27;</span>, d, <span class="string">&#x27;kw =&#x27;</span>, kw)</code></pre><p>在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>)a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> args = () kw = &#123;&#125;<span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = () kw = &#123;&#125;<span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>)a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = () kw = &#123;&#125;<span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) kw = &#123;&#125;<span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, x=<span class="number">99</span>)a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) kw = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">99</span>&#125;<span class="meta">&gt;&gt;&gt; </span>f2(<span class="number">1</span>, <span class="number">2</span>, d=<span class="number">99</span>, ext=<span class="literal">None</span>)a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> d = <span class="number">99</span> kw = &#123;<span class="string">&#x27;ext&#x27;</span>: <span class="literal">None</span>&#125;</code></pre><p>最神奇的是通过一个tuple和dict，你也可以调用上述函数：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)<span class="meta">&gt;&gt;&gt; </span>kw = &#123;<span class="string">&#x27;d&#x27;</span>: <span class="number">99</span>, <span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;#&#x27;</span>&#125;<span class="meta">&gt;&gt;&gt; </span>f1(*args, **kw)a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="number">4</span>,) kw = &#123;<span class="string">&#x27;d&#x27;</span>: <span class="number">99</span>, <span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;#&#x27;</span>&#125;<span class="meta">&gt;&gt;&gt; </span>args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)<span class="meta">&gt;&gt;&gt; </span>kw = &#123;<span class="string">&#x27;d&#x27;</span>: <span class="number">88</span>, <span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;#&#x27;</span>&#125;<span class="meta">&gt;&gt;&gt; </span>f2(*args, **kw)a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> d = <span class="number">88</span> kw = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;#&#x27;</span>&#125;</code></pre><blockquote><p>所以，对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的</p></blockquote><blockquote><p>虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</p></blockquote><h3 id="递归参数"><a class="markdownIt-Anchor" href="#递归参数"></a> 递归参数</h3><p>在函数内部，可以调用其他函数。<strong>如果一个函数在内部调用自身本身，这个函数就是递归函数</strong></p><p>举个例子，我们来计算阶乘n! = 1 x 2 x 3 x … x n，用函数fact(n)表示，可以看出：</p><p>fact(n)=n!=1×2×3×⋅⋅⋅×(n−1)×n=(n−1)!×n=fact(n−1)×n</p><p>所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。</p><p>于是，fact(n)用递归的方式写出来就是：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):    <span class="keyword">if</span> n==<span class="number">1</span>:        <span class="keyword">return</span> <span class="number">1</span>    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</code></pre><p>上面就是一个递归函数。可以试试：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">1</span>)<span class="number">1</span>&gt;&gt;&gt; fact(<span class="number">5</span>)<span class="number">120</span>&gt;&gt;&gt; fact(<span class="number">100</span>)<span class="number">93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</span></code></pre><p>如果我们计算fact(5)，可以根据函数定义看到计算过程如下：</p><pre><code class="highlight plaintext">===&gt; fact(5)===&gt; 5 * fact(4)===&gt; 5 * (4 * fact(3))===&gt; 5 * (4 * (3 * fact(2)))===&gt; 5 * (4 * (3 * (2 * fact(1))))===&gt; 5 * (4 * (3 * (2 * 1)))===&gt; 5 * (4 * (3 * 2))===&gt; 5 * (4 * 6)===&gt; 5 * 24===&gt; 120</code></pre><blockquote><p>递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。</p></blockquote><p>使用<strong>递归函数需要注意防止栈溢出</strong>。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">1000</span>)Traceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">4</span>, <span class="keyword">in</span> fact  ...  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">4</span>, <span class="keyword">in</span> factRuntimeError: maximum recursion depth exceeded <span class="keyword">in</span> comparison</code></pre><p><strong>解决递归调用栈溢出的方法是通过尾递归优化</strong>，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p><blockquote><p>尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p></blockquote><p>上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):    <span class="keyword">return</span> fact_iter(n, <span class="number">1</span>)<span class="keyword">def</span> <span class="title function_">fact_iter</span>(<span class="params">num, product</span>):    <span class="keyword">if</span> num == <span class="number">1</span>:        <span class="keyword">return</span> product    <span class="keyword">return</span> fact_iter(num - <span class="number">1</span>, num * product)</code></pre><p>可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，num - 1和num * product在函数调用前就会被计算，不影响函数调用。<br />fact(5)对应的fact_iter(5, 1)的调用如下：</p><pre><code class="highlight python">===&gt; fact_iter(<span class="number">5</span>, <span class="number">1</span>)===&gt; fact_iter(<span class="number">4</span>, <span class="number">5</span>)===&gt; fact_iter(<span class="number">3</span>, <span class="number">20</span>)===&gt; fact_iter(<span class="number">2</span>, <span class="number">60</span>)===&gt; fact_iter(<span class="number">1</span>, <span class="number">120</span>)===&gt; <span class="number">120</span></code></pre><p>尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</p><p>遗憾的是，<strong>大多数编程语言没有针对尾递归做优化</strong>，<strong>Python解释器也没有做优化</strong>，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。</p><h2 id="高级特性"><a class="markdownIt-Anchor" href="#高级特性"></a> 高级特性</h2><h3 id="切片"><a class="markdownIt-Anchor" href="#切片"></a> 切片</h3><p>表示取一个list或tuple的部分元素。</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Sarah&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>]</code></pre><p>取前3个元素:</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">0</span>:<span class="number">3</span>][<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Sarah&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</code></pre><blockquote><p>L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。</p></blockquote><p>如果第一个索引是0，还可以省略：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">3</span>][<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Sarah&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</code></pre><p>也可以从索引1开始，取出2个元素出来：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">1</span>:<span class="number">3</span>][<span class="string">&#x27;Sarah&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</code></pre><p>类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L[-<span class="number">2</span>:][<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>]<span class="meta">&gt;&gt;&gt; </span>L[-<span class="number">2</span>:-<span class="number">1</span>][<span class="string">&#x27;Bob&#x27;</span>]</code></pre><blockquote><p>记住倒数第一个元素的索引是-1。</p></blockquote><hr /><p>实例：</p><p>切片操作十分有用。我们先创建一个0-99的数列：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">100</span>))<span class="meta">&gt;&gt;&gt; </span>L[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ..., <span class="number">99</span>]</code></pre><p>可以通过切片轻松取出某一段数列。比如前10个数：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">10</span>][<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</code></pre><p>后10个数：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L[-<span class="number">10</span>:][<span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>]</code></pre><p>前11-20个数：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">10</span>:<span class="number">20</span>][<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>]</code></pre><p>前10个数，每两个取一个：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">10</span>:<span class="number">2</span>][<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</code></pre><p>所有数，每5个取一个：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L[::<span class="number">5</span>][<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">55</span>, <span class="number">60</span>, <span class="number">65</span>, <span class="number">70</span>, <span class="number">75</span>, <span class="number">80</span>, <span class="number">85</span>, <span class="number">90</span>, <span class="number">95</span>]</code></pre><p>甚至什么都不写，只写[:]就可以<strong>原样复制</strong>一个list：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L[:][<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ..., <span class="number">99</span>]</code></pre><p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)[:<span class="number">3</span>](<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</code></pre><p>字符串’xxx’也可以看成是一种list，每个元素就是一个字符。因此，<strong>字符串也可以用切片操作</strong>，只是操作结果仍是字符串：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;ABCDEFG&#x27;</span>[:<span class="number">3</span>]<span class="string">&#x27;ABC&#x27;</span><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;ABCDEFG&#x27;</span>[::<span class="number">2</span>]<span class="string">&#x27;ACEG&#x27;</span></code></pre><p>在很多编程语言中，针对字符串提供了很多各种截取函数（例如，substring），其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。</p><h3 id="迭代"><a class="markdownIt-Anchor" href="#迭代"></a> 迭代</h3><p>如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。</p><p>在Python中，<strong>迭代是通过for … in来完成</strong>的，而很多语言比如C语言，迭代list是通过下标完成的，比如Java代码：</p><pre><code class="highlight java"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;list.length; i++) &#123;    n = list[i];&#125;</code></pre><p>可以看出，Python的for循环抽象程度要高于C的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。</p><p>list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，<strong>只要是可迭代对象，无论有无下标，都可以迭代</strong>，比如dict就可以迭代：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;<span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> d:<span class="meta">... </span>    <span class="built_in">print</span>(key)...acb</code></pre><blockquote><p><strong>因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样</strong>。</p></blockquote><p>默认情况下，dict迭代的是key。</p><ul><li>如果要<strong>迭代value</strong>，可以用for value in d.values()</li><li>如果要同时<strong>迭代key和value</strong>，可以用for k, v in d.items()</li></ul><p>由于字符串也是可迭代对象，因此，也可以作用于for循环：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span>:<span class="meta">... </span>    <span class="built_in">print</span>(ch)...ABC</code></pre><p>所以，当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。</p><p>那么，如何判断一个对象是可迭代对象呢？</p><ul><li>方法是<strong>通过collections模块的Iterable类型判断</strong>：</li></ul><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">&#x27;abc&#x27;</span>, Iterable) <span class="comment"># str是否可迭代</span><span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], Iterable) <span class="comment"># list是否可迭代</span><span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="number">123</span>, Iterable) <span class="comment"># 整数是否可迭代</span><span class="literal">False</span></code></pre><p>最后一个小问题，如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]):<span class="meta">... </span>    <span class="built_in">print</span>(i, value)...<span class="number">0</span> A<span class="number">1</span> B<span class="number">2</span> C</code></pre><p>上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x, y <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">9</span>)]:<span class="meta">... </span>    <span class="built_in">print</span>(x, y)...<span class="number">1</span> <span class="number">12</span> <span class="number">43</span> <span class="number">9</span></code></pre><h3 id="列表生成式"><a class="markdownIt-Anchor" href="#列表生成式"></a> 列表生成式</h3><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p><p>举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>))[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</code></pre><p>但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L = []<span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):<span class="meta">... </span>   L.append(x * x)...<span class="meta">&gt;&gt;&gt; </span>L[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</code></pre><p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)][<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</code></pre><blockquote><p>写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。</p></blockquote><p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>][<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</code></pre><p>还可以使用两层循环，可以生成全排列：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">&#x27;XYZ&#x27;</span>][<span class="string">&#x27;AX&#x27;</span>, <span class="string">&#x27;AY&#x27;</span>, <span class="string">&#x27;AZ&#x27;</span>, <span class="string">&#x27;BX&#x27;</span>, <span class="string">&#x27;BY&#x27;</span>, <span class="string">&#x27;BZ&#x27;</span>, <span class="string">&#x27;CX&#x27;</span>, <span class="string">&#x27;CY&#x27;</span>, <span class="string">&#x27;CZ&#x27;</span>]</code></pre><blockquote><p>三层和三层以上的循环就很少用到了。</p></blockquote><p><strong>运用列表生成式，可以写出非常简洁的代码</strong>。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os <span class="comment"># 导入os模块，模块的概念后面讲到</span><span class="meta">&gt;&gt;&gt; </span>[d <span class="keyword">for</span> d <span class="keyword">in</span> os.listdir(<span class="string">&#x27;.&#x27;</span>)] <span class="comment"># os.listdir可以列出文件和目录</span>[<span class="string">&#x27;.emacs.d&#x27;</span>, <span class="string">&#x27;.ssh&#x27;</span>, <span class="string">&#x27;.Trash&#x27;</span>, <span class="string">&#x27;Adlm&#x27;</span>, <span class="string">&#x27;Applications&#x27;</span>, <span class="string">&#x27;Desktop&#x27;</span>, <span class="string">&#x27;Documents&#x27;</span>, <span class="string">&#x27;Downloads&#x27;</span>, <span class="string">&#x27;Library&#x27;</span>, <span class="string">&#x27;Movies&#x27;</span>, <span class="string">&#x27;Music&#x27;</span>, <span class="string">&#x27;Pictures&#x27;</span>, <span class="string">&#x27;Public&#x27;</span>, <span class="string">&#x27;VirtualBox VMs&#x27;</span>, <span class="string">&#x27;Workspace&#x27;</span>, <span class="string">&#x27;XCode&#x27;</span>]</code></pre><hr /><p>for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;y&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;z&#x27;</span>: <span class="string">&#x27;C&#x27;</span> &#125;<span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():<span class="meta">... </span>    <span class="built_in">print</span>(k, <span class="string">&#x27;=&#x27;</span>, v)...y = Bx = Az = C</code></pre><p>因此，列表生成式也可以使用两个变量来生成list：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;y&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;z&#x27;</span>: <span class="string">&#x27;C&#x27;</span> &#125;<span class="meta">&gt;&gt;&gt; </span>[k + <span class="string">&#x27;=&#x27;</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items()][<span class="string">&#x27;y=B&#x27;</span>, <span class="string">&#x27;x=A&#x27;</span>, <span class="string">&#x27;z=C&#x27;</span>]</code></pre><p>最后把一个list中所有的字符串变成小写：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>, <span class="string">&#x27;IBM&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>]<span class="meta">&gt;&gt;&gt; </span>[s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L][<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;ibm&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</code></pre><hr /><p><strong>if…else</strong></p><p>使用列表生成式的时候，有些童鞋经常搞不清楚if…else的用法。</p><p>例如，以下代码正常输出偶数：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>][<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</code></pre><p>但是，我们不能在最后的if加上else：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>]  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>    [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>]                                              ^SyntaxError: invalid syntax</code></pre><p>这是因为跟在for后面的if是一个筛选条件，不能带else，否则如何筛选？</p><p>另一些童鞋发现把if写在for前面必须加else，否则报错：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>    [x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]                       ^SyntaxError: invalid syntax</code></pre><p>这是因为for前面的部分是一个表达式，它必须根据x计算出一个结果。因此，考察表达式：x if x % 2 == 0，它无法根据x计算出结果，因为缺少else，必须加上else：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> -x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)][-<span class="number">1</span>, <span class="number">2</span>, -<span class="number">3</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">6</span>, -<span class="number">7</span>, <span class="number">8</span>, -<span class="number">9</span>, <span class="number">10</span>]</code></pre><p>上述for前面的表达式x if x % 2 == 0 else -x才能根据x计算出确定的结果。</p><p>可见，在一个列表生成式中，for前面的if … else是表达式，而for后面的if是过滤条件，不能带else。</p><h3 id="生成器"><a class="markdownIt-Anchor" href="#生成器"></a> 生成器</h3><p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p><p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？</p><p>这样就不必创建完整的list，从而节省大量的空间。<strong>在Python中，这种一边循环一边计算的机制，称为生成器：generator</strong>。</p><p>要创建一个generator，有很多种方法。第一种方法很简单，<strong>只要把一个列表生成式的[]改成()，就创建了一个generator</strong>：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]<span class="meta">&gt;&gt;&gt; </span>L[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]<span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))<span class="meta">&gt;&gt;&gt; </span>g&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x1022ef630</span>&gt;</code></pre><p>创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。</p><p>我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？</p><ul><li>如果要一个一个打印出来，<strong>可以通过next()函数获得generator的下一个返回值</strong>：</li></ul><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)<span class="number">0</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)<span class="number">1</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)<span class="number">4</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)<span class="number">9</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)<span class="number">16</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)<span class="number">25</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)<span class="number">36</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)<span class="number">49</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)<span class="number">64</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)<span class="number">81</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)Traceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;StopIteration</code></pre><p>我们讲过，<strong>generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误</strong>。</p><p>当然，上面这种不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))<span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> g:<span class="meta">... </span>    <span class="built_in">print</span>(n)<span class="meta">... </span><span class="number">0</span><span class="number">1</span><span class="number">4</span><span class="number">9</span><span class="number">16</span><span class="number">25</span><span class="number">36</span><span class="number">49</span><span class="number">64</span><span class="number">81</span></code></pre><blockquote><p>所以，我们创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，并且不需要关心StopIteration的错误</p></blockquote><p>generator非常强大。<strong>如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现</strong>。</p><p>比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：</p><pre><code class="highlight plaintext">1, 1, 2, 3, 5, 8, 13, 21, 34, ...</code></pre><p>斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params"><span class="built_in">max</span></span>):    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:        <span class="built_in">print</span>(b)        a, b = b, a + b        n = n + <span class="number">1</span>    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></code></pre><p>注意，赋值语句：</p><pre><code class="highlight python">a, b = b, a + b<span class="comment">#相当于：</span>t = (b, a + b) <span class="comment"># t是一个tuple</span>a = t[<span class="number">0</span>]b = t[<span class="number">1</span>]</code></pre><p>但不必显式写出临时变量t就可以赋值。</p><p>上面的函数可以输出斐波那契数列的前N个数：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">6</span>)<span class="number">1</span><span class="number">1</span><span class="number">2</span><span class="number">3</span><span class="number">5</span><span class="number">8</span><span class="string">&#x27;done&#x27;</span></code></pre><p>仔细观察，可以看出，fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。也就是说，</p><p><strong>yield关键字</strong></p><p>上面的函数和generator仅一步之遥。<strong>要把fib函数变成generator，只需要把print(b)改为yield b就可以</strong>了：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params"><span class="built_in">max</span></span>):    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:        <span class="keyword">yield</span> b        a, b = b, a + b        n = n + <span class="number">1</span>    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></code></pre><p>这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = fib(<span class="number">6</span>)<span class="meta">&gt;&gt;&gt; </span>f&lt;generator <span class="built_in">object</span> fib at <span class="number">0x104feaaa0</span>&gt;</code></pre><p>这里，最难理解的就是generator和函数的执行流程不一样。</p><ul><li>函数是<strong>顺序执行</strong>，遇到return语句或者最后一行函数语句就返回。</li><li>而变成generator的函数，<strong>在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行</strong>。</li></ul><p>举个简单的例子，定义一个generator，依次返回数字1，3，5：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">odd</span>():    <span class="built_in">print</span>(<span class="string">&#x27;step 1&#x27;</span>)    <span class="keyword">yield</span> <span class="number">1</span>    <span class="built_in">print</span>(<span class="string">&#x27;step 2&#x27;</span>)    <span class="keyword">yield</span>(<span class="number">3</span>)    <span class="built_in">print</span>(<span class="string">&#x27;step 3&#x27;</span>)    <span class="keyword">yield</span>(<span class="number">5</span>)</code></pre><p>调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>o = odd()<span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)step <span class="number">11</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)step <span class="number">23</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)step <span class="number">35</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)Traceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;StopIteration</code></pre><blockquote><p>可以看到，odd不是普通函数，而是generator，在执行过程中，遇到yield就中断，下次又继续执行。执行3次yield后，已经没有yield可以执行了，所以，第4次调用next(o)就报错。</p></blockquote><p>回到fib的例子，我们在循环过程中不断调用yield，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。</p><p>同样的，把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> fib(<span class="number">6</span>):<span class="meta">... </span>    <span class="built_in">print</span>(n)...<span class="number">1</span><span class="number">1</span><span class="number">2</span><span class="number">3</span><span class="number">5</span><span class="number">8</span></code></pre><p>但是用for循环调用generator时，发现拿不到generator的return语句的返回值(每次拿到的值都是yield返回的)。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>g = fib(<span class="number">6</span>)<span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:<span class="meta">... </span>    <span class="keyword">try</span>:<span class="meta">... </span>        x = <span class="built_in">next</span>(g)<span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;g:&#x27;</span>, x)<span class="meta">... </span>    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:<span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;Generator return value:&#x27;</span>, e.value)<span class="meta">... </span>        <span class="keyword">break</span>...g: <span class="number">1</span>g: <span class="number">1</span>g: <span class="number">2</span>g: <span class="number">3</span>g: <span class="number">5</span>g: <span class="number">8</span>Generator <span class="keyword">return</span> value: done</code></pre><p>案例：</p><p>生成杨辉三角：</p><p>方法1：</p><pre><code class="highlight python">L = [<span class="number">1</span>]<span class="keyword">while</span> <span class="literal">True</span>:    <span class="keyword">yield</span> L    L = [<span class="built_in">sum</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="number">0</span>]+L, L+[<span class="number">0</span>])]</code></pre><p>方法2：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">triangles</span>():    L = [<span class="number">1</span>]    <span class="keyword">while</span> <span class="literal">True</span>:        <span class="keyword">yield</span> L        L = [([<span class="number">0</span>] + L)[i] + (L + [<span class="number">0</span>])[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(L) + <span class="number">1</span>)]</code></pre><p>方法3：</p><pre><code class="highlight python">L = [<span class="number">1</span>]<span class="keyword">while</span> <span class="literal">True</span>:    <span class="keyword">yield</span> L    L = [ x+y <span class="keyword">for</span> (x,y) <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="number">0</span>]+L,L+[<span class="number">0</span>])]</code></pre><h3 id="迭代器"><a class="markdownIt-Anchor" href="#迭代器"></a> 迭代器</h3><p>我们已经知道，可以直接作用于for循环的数据类型有以下几种：</p><ul><li>一类是集合数据类型，如list、tuple、dict、set、str等；</li><li>一类是generator，包括生成器和带yield的generator function。</li></ul><p>这些可以直接作用于for循环的对象统称为<strong>可迭代对象：Iterable</strong>。</p><p>可以使用isinstance()判断一个对象是否是Iterable对象：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>([], Iterable)<span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(&#123;&#125;, Iterable)<span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">&#x27;abc&#x27;</span>, Iterable)<span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>((x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)), Iterable)<span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="number">100</span>, Iterable)<span class="literal">False</span></code></pre><p>而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。</p><p>可以被next()函数调用并不断返回下一个值的对象称为<strong>迭代器：Iterator</strong>。</p><p>可以使用isinstance()判断一个对象是否是Iterator对象：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>((x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)), Iterator)<span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>([], Iterator)<span class="literal">False</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(&#123;&#125;, Iterator)<span class="literal">False</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">&#x27;abc&#x27;</span>, Iterator)<span class="literal">False</span></code></pre><blockquote><p>生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator</p></blockquote><p>把list、dict、str等<strong>Iterable变成Iterator可以使用iter()函数</strong>：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="built_in">iter</span>([]), Iterator)<span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="built_in">iter</span>(<span class="string">&#x27;abc&#x27;</span>), Iterator)<span class="literal">True</span></code></pre><p>为什么list、dict、str等数据类型不是Iterator？</p><p>这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p><p>Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p><p>Python的for循环本质上就是通过不断调用next()函数实现的，例如：</p><pre><code class="highlight python"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]:</code></pre><p>pass实际上完全等价于：</p><pre><code class="highlight python"><span class="comment"># 首先获得Iterator对象:</span>it = <span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])<span class="comment"># 循环:while True:</span>    <span class="keyword">try</span>:        <span class="comment"># 获得下一个值:</span>        x = <span class="built_in">next</span>(it)    <span class="keyword">except</span> StopIteration:        <span class="comment"># 遇到StopIteration就退出循环</span>        <span class="keyword">break</span></code></pre><h2 id="函数式编程"><a class="markdownIt-Anchor" href="#函数式编程"></a> 函数式编程</h2><p>函数是Python内建支持的一种封装，<strong>我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计</strong>。函数就是面向过程的程序设计的基本单元。</p><p>而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想<strong>更接近数学计算</strong>。</p><p>我们首先要搞明白计算机（Computer）和计算（Compute）的概念。</p><p>在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。</p><p>而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。</p><p>对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。</p><p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p><p><strong>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数</strong>！</p><p>Python对函数式编程提供<strong>部分支持</strong>。由于Python允许使用变量，因此，<strong>Python不是纯函数式编程语言</strong>。</p><h3 id="高阶函数"><a class="markdownIt-Anchor" href="#高阶函数"></a> 高阶函数</h3><p>高阶函数英文叫Higher-order function。什么是高阶函数？我们以实际代码为例子，一步一步深入概念。</p><p><strong>变量可以指向函数</strong></p><p>以Python内置的求绝对值的函数abs()为例，调用该函数用以下代码：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(-<span class="number">10</span>)<span class="number">10</span></code></pre><p>但是，如果只写abs呢？</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>&lt;built-<span class="keyword">in</span> function <span class="built_in">abs</span>&gt;</code></pre><blockquote><p>可见，abs(-10)是函数调用，而abs是函数本身。</p></blockquote><p>要获得函数调用结果，我们可以把结果赋值给变量：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">abs</span>(-<span class="number">10</span>)<span class="meta">&gt;&gt;&gt; </span>x<span class="number">10</span></code></pre><p>但是，如果把函数本身赋值给变量呢？</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">abs</span><span class="meta">&gt;&gt;&gt; </span>f&lt;built-<span class="keyword">in</span> function <span class="built_in">abs</span>&gt;</code></pre><blockquote><p>结论：函数本身也可以赋值给变量，即：<strong>变量可以指向函数</strong>。</p></blockquote><p>如果一个变量指向了一个函数，那么，可否通过该变量来调用这个函数？用代码验证一下：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">abs</span><span class="meta">&gt;&gt;&gt; </span>f(-<span class="number">10</span>)<span class="number">10</span></code></pre><blockquote><p>成功！说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。</p></blockquote><p><strong>函数名也是变量</strong></p><p>那么函数名是什么呢？<strong>函数名其实就是指向函数的变量</strong>！对于abs()这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数！</p><p>如果把abs指向其他对象，会有什么情况发生？</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span> = <span class="number">10</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(-<span class="number">10</span>)Traceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;TypeError: <span class="string">&#x27;int&#x27;</span> <span class="built_in">object</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">callable</span></code></pre><p>把abs指向10后，就无法通过abs(-10)调用该函数了！因为abs这个变量已经不指向求绝对值函数而是指向一个整数10！</p><p>当然实际代码绝对不能这么写，这里是为了说明函数名也是变量。要恢复abs函数，请重启Python交互环境。</p><blockquote><p>注：由于abs函数实际上是定义在import builtins模块中的，所以要让修改abs变量的指向在其它模块也生效，要用import builtins; builtins.abs = 10。</p></blockquote><p><strong>传入函数</strong></p><p>既然变量可以指向函数，函数的参数能接收变量，那么<strong>一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数</strong>。</p><p>一个最简单的高阶函数：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y, f</span>):    <span class="keyword">return</span> f(x) + f(y)</code></pre><p>当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，我们可以推导计算过程为：</p><pre><code class="highlight python">x = -<span class="number">5</span>y = <span class="number">6</span>f = <span class="built_in">abs</span>f(x) + f(y) ==&gt; <span class="built_in">abs</span>(-<span class="number">5</span>) + <span class="built_in">abs</span>(<span class="number">6</span>) ==&gt; <span class="number">11</span><span class="keyword">return</span> <span class="number">11</span></code></pre><h4 id="map"><a class="markdownIt-Anchor" href="#map"></a> map</h4><p>Python内建了map()和reduce()函数。</p><p>我们先看map。<strong>map()函数接收两个参数，一个是函数</strong>，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。</p><p>举例说明，比如我们有一个函数f(x)=x2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下：</p><p>现在，我们用Python代码实现：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):<span class="meta">... </span>    <span class="keyword">return</span> x * x...<span class="meta">&gt;&gt;&gt; </span>r = <span class="built_in">map</span>(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])<span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(r)[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</code></pre><p>map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。</p><p>你可能会想，不需要map()函数，写一个循环，也可以计算出结果：</p><pre><code class="highlight python">L = []<span class="keyword">for</span> n <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]:    L.append(f(n))<span class="built_in">print</span>(L)</code></pre><blockquote><p>的确可以，但是，从上面的循环代码，能一眼看明白“把f(x)作用在list的每一个元素并把结果生成一个新的list”吗？</p></blockquote><p>所以，map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把这个list所有数字转为字符串：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>]</code></pre><h4 id="reduce"><a class="markdownIt-Anchor" href="#reduce"></a> reduce</h4><p>reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：</p><pre><code class="highlight python">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code></pre><p>比方说对一个序列求和，就可以用reduce实现：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce<span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):<span class="meta">... </span>    <span class="keyword">return</span> x + y...<span class="meta">&gt;&gt;&gt; </span>reduce(add, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])<span class="number">25</span></code></pre><blockquote><p>当然求和运算可以直接用Python内建函数sum()，没必要动用reduce</p></blockquote><p>但是如果要把序列[1, 3, 5, 7, 9]变换成整数13579，reduce就可以派上用场：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce<span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fn</span>(<span class="params">x, y</span>):<span class="meta">... </span>    <span class="keyword">return</span> x * <span class="number">10</span> + y...<span class="meta">&gt;&gt;&gt; </span>reduce(fn, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])<span class="number">13579</span></code></pre><p>这个例子本身没多大用处，但是，如果考虑到字符串str也是一个序列，对上面的例子稍加改动，配合map()，我们就可以写出把str转换为int的函数：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce<span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fn</span>(<span class="params">x, y</span>):<span class="meta">... </span>    <span class="keyword">return</span> x * <span class="number">10</span> + y...<span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">char2num</span>(<span class="params">s</span>):<span class="meta">... </span>    digits = &#123;<span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;8&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>: <span class="number">9</span>&#125;<span class="meta">... </span>    <span class="keyword">return</span> digits[s]...<span class="meta">&gt;&gt;&gt; </span>reduce(fn, <span class="built_in">map</span>(char2num, <span class="string">&#x27;13579&#x27;</span>))<span class="number">13579</span></code></pre><p>整理成一个str2int的函数就是：</p><pre><code class="highlight python"><span class="keyword">from</span> functools <span class="keyword">import</span> reduceDIGITS = &#123;<span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;8&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>: <span class="number">9</span>&#125;<span class="keyword">def</span> <span class="title function_">str2int</span>(<span class="params">s</span>):    <span class="keyword">def</span> <span class="title function_">fn</span>(<span class="params">x, y</span>):        <span class="keyword">return</span> x * <span class="number">10</span> + y    <span class="keyword">def</span> <span class="title function_">char2num</span>(<span class="params">s</span>):        <span class="keyword">return</span> DIGITS[s]    <span class="keyword">return</span> reduce(fn, <span class="built_in">map</span>(char2num, s))</code></pre><p>还可以用lambda函数进一步简化成：</p><pre><code class="highlight python"><span class="keyword">from</span> functools <span class="keyword">import</span> reduceDIGITS = &#123;<span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;8&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>: <span class="number">9</span>&#125;<span class="keyword">def</span> <span class="title function_">char2num</span>(<span class="params">s</span>):    <span class="keyword">return</span> DIGITS[s]<span class="keyword">def</span> <span class="title function_">str2int</span>(<span class="params">s</span>):    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x * <span class="number">10</span> + y, <span class="built_in">map</span>(char2num, s))</code></pre><blockquote><p>也就是说，假设Python没有提供int()函数，你完全可以自己写一个把字符串转化为整数的函数，而且只需要几行代码！</p></blockquote><hr /><p>练习1：利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：[‘adam’, ‘LISA’, ‘barT’]，输出：[‘Adam’, ‘Lisa’, ‘Bart’]：</p><pre><code class="highlight python"><span class="comment"># 测试:</span>L1 = [<span class="string">&#x27;adam&#x27;</span>, <span class="string">&#x27;LISA&#x27;</span>, <span class="string">&#x27;barT&#x27;</span>]L2 = <span class="built_in">list</span>(<span class="built_in">map</span>(normalize, L1))<span class="built_in">print</span>(L2)<span class="comment">#答案1：</span><span class="keyword">def</span> <span class="title function_">normalize</span>(<span class="params">name</span>):    ii=<span class="string">&#x27;&#x27;</span>    <span class="keyword">for</span> i,ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(name):        <span class="keyword">if</span> i==<span class="number">0</span>:            ii=ii+ch.upper()        <span class="keyword">else</span>:            ii=ii+ch.lower()    <span class="keyword">return</span> ii答案<span class="number">2</span>：<span class="keyword">def</span> <span class="title function_">normalize</span>(<span class="params">name</span>):    <span class="keyword">from</span> functools <span class="keyword">import</span> reduce    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y: x+y, [ch.upper() <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">else</span> ch.lower() <span class="keyword">for</span> i, ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(name)])</code></pre><p>练习2:Python提供的sum()函数可以接受一个list并求和，请编写一个prod()函数，可以接受一个list并利用reduce()求积：</p><pre><code class="highlight python"><span class="comment">#测试</span><span class="built_in">print</span>(<span class="string">&#x27;3 * 5 * 7 * 9 =&#x27;</span>, prod([<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]))<span class="keyword">if</span> prod([<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]) == <span class="number">945</span>:    <span class="built_in">print</span>(<span class="string">&#x27;测试成功!&#x27;</span>)<span class="keyword">else</span>:    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)<span class="comment"># -*- coding: utf-8 -*-</span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce<span class="keyword">def</span> <span class="title function_">prod</span>(<span class="params">L</span>):    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y:x*y,L)</code></pre><h4 id="filter"><a class="markdownIt-Anchor" href="#filter"></a> filter</h4><p>Python内建的<strong>filter()函数用于过滤序列</strong>。</p><p>和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，<strong>filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素</strong>。</p><p>例如，在一个list中，删掉偶数，只保留奇数，可以这么写：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">is_odd</span>(<span class="params">n</span>):    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span><span class="built_in">list</span>(<span class="built_in">filter</span>(is_odd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>]))<span class="comment"># 结果: [1, 5, 9, 15]</span></code></pre><p>把一个序列中的空字符串删掉，可以这么写：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">not_empty</span>(<span class="params">s</span>):    <span class="keyword">return</span> s <span class="keyword">and</span> s.strip()<span class="built_in">list</span>(<span class="built_in">filter</span>(not_empty, [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="literal">None</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;  &#x27;</span>]))<span class="comment"># 结果: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></code></pre><blockquote><p>可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。</p></blockquote><p>注意到<strong>filter()函数返回的是一个Iterator</strong>，也就是一个惰性序列，所以要强迫filter()完成计算结果，<strong>需要用list()函数获得所有结果并返回list</strong>。</p><hr /><p><strong>用filter求素数</strong></p><ul><li>计算素数的一个方法是埃氏筛法，它的算法理解起来非常简单：</li><li>首先，列出从2开始的所有自然数，构造一个序列：2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …</li><li>取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉：3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …</li><li>取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉：5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …</li><li>取新序列的第一个数5，然后用5把序列的5的倍数筛掉：7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …</li><li>不断筛下去，就可以得到所有的素数。</li></ul><p>用Python来实现这个算法，可以先构造一个从3开始的奇数序列：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">_odd_iter</span>():    n = <span class="number">1</span>    <span class="keyword">while</span> <span class="literal">True</span>:        n = n + <span class="number">2</span>        <span class="keyword">yield</span> n</code></pre><blockquote><p>注意这是一个生成器，并且是一个无限序列。</p></blockquote><p>然后定义一个筛选函数：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">_not_divisible</span>(<span class="params">n</span>):    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x % n &gt; <span class="number">0</span></code></pre><p>最后，定义一个生成器，不断返回下一个素数：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">primes</span>():    <span class="keyword">yield</span> <span class="number">2</span>    it = _odd_iter() <span class="comment"># 初始序列</span>    <span class="keyword">while</span> <span class="literal">True</span>:        n = <span class="built_in">next</span>(it) <span class="comment"># 返回序列的第一个数</span>        <span class="keyword">yield</span> n        it = <span class="built_in">filter</span>(_not_divisible(n), it) <span class="comment"># 构造新序列</span></code></pre><p>这个生成器先返回第一个素数2，然后，利用filter()不断产生筛选后的新的序列。</p><p>由于primes()也是一个无限序列，所以调用时需要设置一个退出循环的条件：</p><pre><code class="highlight python"><span class="comment"># 打印1000以内的素数:</span><span class="keyword">for</span> n <span class="keyword">in</span> primes():    <span class="keyword">if</span> n &lt; <span class="number">1000</span>:        <span class="built_in">print</span>(n)    <span class="keyword">else</span>:        <span class="keyword">break</span></code></pre><blockquote><p>注意到Iterator是惰性计算的序列，所以我们可以用Python表示“全体自然数”，“全体素数”这样的序列，而代码非常简洁。</p></blockquote><hr /><p>练习:</p><p>回数是指从左向右读和从右向左读都是一样的数，例如12321，909。请利用filter()筛选出回数：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">is_palindrome</span>(<span class="params">n</span>):    <span class="keyword">return</span> <span class="built_in">str</span>(n)==<span class="built_in">str</span>(n)[::-<span class="number">1</span>]<span class="comment"># 测试:</span>output = <span class="built_in">filter</span>(is_palindrome, <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1000</span>))<span class="built_in">print</span>(<span class="string">&#x27;1~1000:&#x27;</span>, <span class="built_in">list</span>(output))<span class="keyword">if</span> <span class="built_in">list</span>(<span class="built_in">filter</span>(is_palindrome, <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">200</span>))) == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>, <span class="number">101</span>, <span class="number">111</span>, <span class="number">121</span>, <span class="number">131</span>, <span class="number">141</span>, <span class="number">151</span>, <span class="number">161</span>, <span class="number">171</span>, <span class="number">181</span>, <span class="number">191</span>]:    <span class="built_in">print</span>(<span class="string">&#x27;测试成功!&#x27;</span>)<span class="keyword">else</span>:    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</code></pre><h4 id="sorted"><a class="markdownIt-Anchor" href="#sorted"></a> sorted</h4><p>排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个dict呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。</p><p>Python内置的sorted()函数就可以对list进行排序：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="number">36</span>, <span class="number">5</span>, -<span class="number">12</span>, <span class="number">9</span>, -<span class="number">21</span>])[-<span class="number">21</span>, -<span class="number">12</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">36</span>]</code></pre><p>此外，sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="number">36</span>, <span class="number">5</span>, -<span class="number">12</span>, <span class="number">9</span>, -<span class="number">21</span>], key=<span class="built_in">abs</span>)[<span class="number">5</span>, <span class="number">9</span>, -<span class="number">12</span>, -<span class="number">21</span>, <span class="number">36</span>]</code></pre><p>key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过key=abs处理过的list：</p><pre><code class="highlight python"><span class="built_in">list</span> = [<span class="number">36</span>, <span class="number">5</span>, -<span class="number">12</span>, <span class="number">9</span>, -<span class="number">21</span>]keys = [<span class="number">36</span>, <span class="number">5</span>,  <span class="number">12</span>, <span class="number">9</span>,  <span class="number">21</span>]<span class="comment">#然后sorted()函数按照keys进行排序，并按照对应关系返回list相应的元素：</span>keys排序结果 =&gt; [<span class="number">5</span>, <span class="number">9</span>,  <span class="number">12</span>,  <span class="number">21</span>, <span class="number">36</span>]最终结果       =&gt; [<span class="number">5</span>, <span class="number">9</span>, -<span class="number">12</span>, -<span class="number">21</span>, <span class="number">36</span>]</code></pre><p>我们再看一个字符串排序的例子：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>])[<span class="string">&#x27;Credit&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>]</code></pre><p>默认情况下，对字符串排序，是按照ASCII的大小比较的，由于’Z’ &lt; ‘a’，结果，大写字母Z会排在小写字母a的前面。</p><p>现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。<br />这样，我们给sorted传入key函数，即可实现忽略大小写的排序：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>], key=<span class="built_in">str</span>.lower)[<span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>]</code></pre><p>要进行反向排序，不必改动key函数，可以传入第三个参数</p><pre><code class="highlight python">reverse=<span class="literal">True</span>：&gt;&gt;&gt; <span class="built_in">sorted</span>([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>], key=<span class="built_in">str</span>.lower, reverse=<span class="literal">True</span>)[<span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>]</code></pre><p>从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。</p><h3 id="返回函数"><a class="markdownIt-Anchor" href="#返回函数"></a> 返回函数</h3><p><strong>函数作为返回值</strong></p><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p><p>我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">calc_sum</span>(<span class="params">*args</span>):    ax = <span class="number">0</span>    <span class="keyword">for</span> n <span class="keyword">in</span> args:        ax = ax + n    <span class="keyword">return</span> ax</code></pre><p>但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">lazy_sum</span>(<span class="params">*args</span>):    <span class="keyword">def</span> <span class="title function_">sum</span>():        ax = <span class="number">0</span>        <span class="keyword">for</span> n <span class="keyword">in</span> args:            ax = ax + n        <span class="keyword">return</span> ax    <span class="keyword">return</span> <span class="built_in">sum</span></code></pre><p>当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)<span class="meta">&gt;&gt;&gt; </span>f&lt;function lazy_sum.&lt;<span class="built_in">locals</span>&gt;.<span class="built_in">sum</span> at <span class="number">0x101c6ed90</span>&gt;<span class="comment">#调用函数f时，才真正计算求和的结果：</span><span class="meta">&gt;&gt;&gt; </span>f()<span class="number">25</span></code></pre><p>在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“<strong>闭包</strong>（Closure）”的程序结构拥有极大的威力。</p><p>请再注意一点，当我们调用lazy_sum()时，<strong>每次调用都会返回一个新的函数，即使传入相同的参数</strong>：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f1 = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)<span class="meta">&gt;&gt;&gt; </span>f2 = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)<span class="meta">&gt;&gt;&gt; </span>f1==f2<span class="literal">False</span></code></pre><blockquote><p><strong>f1()和f2()的调用结果互不影响</strong>。</p></blockquote><hr /><p><strong>闭包</strong></p><p>注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。</p><p>另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">count</span>():    fs = []    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):        <span class="keyword">def</span> <span class="title function_">f</span>():             <span class="keyword">return</span> i*i        fs.append(f)    <span class="keyword">return</span> fsf1, f2, f3 = count()</code></pre><blockquote><p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。</p></blockquote><p>你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f1()<span class="number">9</span><span class="meta">&gt;&gt;&gt; </span>f2()<span class="number">9</span><span class="meta">&gt;&gt;&gt; </span>f3()<span class="number">9</span></code></pre><p>全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。</p><blockquote><p>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p></blockquote><p>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">count</span>():    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">j</span>):        <span class="keyword">def</span> <span class="title function_">g</span>():            <span class="keyword">return</span> j*j        <span class="keyword">return</span> g    fs = []    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):        fs.append(f(i)) <span class="comment"># f(i)立刻被执行，因此i的当前值被传入f()</span>    <span class="keyword">return</span> fs</code></pre><p>再看看结果</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f1, f2, f3 = count()<span class="meta">&gt;&gt;&gt; </span>f1()<span class="number">1</span><span class="meta">&gt;&gt;&gt; </span>f2()<span class="number">4</span><span class="meta">&gt;&gt;&gt; </span>f3()<span class="number">9</span></code></pre><p>缺点是代码较长，可利用lambda函数缩短代码。</p><hr /><p>练习：</p><p>利用闭包返回一个计数器函数，每次调用它返回递增整数：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">createCounter</span>():    <span class="keyword">def</span> <span class="title function_">counter</span>():        <span class="keyword">return</span> <span class="number">1</span>    <span class="keyword">return</span> counter<span class="comment"># 测试:</span>counterA = createCounter()<span class="built_in">print</span>(counterA(), counterA(), counterA(), counterA(), counterA()) <span class="comment"># 1 2 3 4 5</span>counterB = createCounter()<span class="keyword">if</span> [counterB(), counterB(), counterB(), counterB()] == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]:    <span class="built_in">print</span>(<span class="string">&#x27;测试通过!&#x27;</span>)<span class="keyword">else</span>:    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</code></pre><pre><code class="highlight python"><span class="comment">#方法一：使用nonlocal关键字声明内函数的变量</span><span class="keyword">def</span> <span class="title function_">createCounter</span>():    a=<span class="number">0</span>    <span class="keyword">def</span> <span class="title function_">counter</span>():        <span class="keyword">nonlocal</span> a <span class="comment">#nonlocal声明这个变量不是局部变量空间的变量，需要向上一个层级变量空间找这个变量</span>        a=a+<span class="number">1</span>        <span class="keyword">return</span> a    <span class="keyword">return</span> counter<span class="comment">#方法二：使用可变类型数据的闭包变量，如list。方法一和二本质上是一样的，都是在内函数中修改外函数的闭包变量。有两种方法进行修改，一是使用nonlocal关键字在内函数中进行声明，另一种是使用可变类型的数据作为闭包变量，此时在内函数中可以直接修改这个变量的值</span><span class="keyword">def</span> <span class="title function_">createCounter</span>():    c=[<span class="number">0</span>]    <span class="keyword">def</span> <span class="title function_">counter</span>():        c[<span class="number">0</span>]+=<span class="number">1</span>        <span class="keyword">return</span> c[<span class="number">0</span>]    <span class="keyword">return</span> counter<span class="comment">#方法三：使用generator及next()生成一个计数器</span><span class="keyword">def</span> <span class="title function_">createCounter</span>():    <span class="keyword">def</span> <span class="title function_">iterator</span>(): <span class="comment">#定义一个生成器，逐个生成1,2,3...自然数序列</span>        n=<span class="number">0</span>        <span class="keyword">while</span> <span class="literal">True</span>:            n+=<span class="number">1</span>            <span class="keyword">yield</span> n    g=iterator() <span class="comment">#需声明一个变量g指向生成器</span>    <span class="keyword">def</span> <span class="title function_">counter</span>():        <span class="keyword">return</span> <span class="built_in">next</span>(g)    <span class="keyword">return</span> counter <span class="comment">#注意外函数返回内函数时，内函数名后不能有()</span></code></pre><h3 id="匿名函数-lamdba"><a class="markdownIt-Anchor" href="#匿名函数-lamdba"></a> 匿名函数 lamdba</h3><p>当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。</p><p>在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</code></pre><p>通过对比可以看出，匿名函数lambda x: x * x实际上就是：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):    <span class="keyword">return</span> x * x</code></pre><p><strong>关键字lambda表示匿名函数，冒号前面的x表示函数参数</strong>。</p><blockquote><p>匿名函数有个限制，就是<strong>只能有一个表达式</strong>，<strong>不用写return</strong>，返回值就是该表达式的结果。</p></blockquote><p>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = <span class="keyword">lambda</span> x: x * x<span class="meta">&gt;&gt;&gt; </span>f&lt;function &lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x101c6ef28</span>&gt;<span class="meta">&gt;&gt;&gt; </span>f(<span class="number">5</span>)<span class="number">25</span></code></pre><p>同样，也可以把匿名函数作为返回值返回，比如：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">x, y</span>):    <span class="keyword">return</span> <span class="keyword">lambda</span>: x * x + y * y</code></pre><h3 id="装饰器"><a class="markdownIt-Anchor" href="#装饰器"></a> 装饰器</h3><p>由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">now</span>():<span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;2015-3-25&#x27;</span>)...<span class="meta">&gt;&gt;&gt; </span>f = now<span class="meta">&gt;&gt;&gt; </span>f()<span class="number">2015</span>-<span class="number">3</span>-<span class="number">25</span></code></pre><p><strong>函数对象有一个__name__属性，可以拿到函数的名字</strong>：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>now.__name__<span class="string">&#x27;now&#x27;</span><span class="meta">&gt;&gt;&gt; </span>f.__name__<span class="string">&#x27;now&#x27;</span></code></pre><p>现在，假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种<strong>在代码运行期间动态增加功能的方式，称之为“装饰器”</strong>（Decorator）。</p><p><strong>本质上，decorator就是一个返回函数的高阶函数</strong>。所以，我们要定义一个能打印日志的decorator，可以定义如下：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">func</span>):    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):        <span class="built_in">print</span>(<span class="string">&#x27;call %s():&#x27;</span> % func.__name__)        <span class="keyword">return</span> func(*args, **kw)    <span class="keyword">return</span> wrapper</code></pre><p>观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助<strong>Python的@语法，把decorator置于函数的定义处</strong>：</p><pre><code class="highlight python"><span class="meta">@log</span><span class="keyword">def</span> <span class="title function_">now</span>():    <span class="built_in">print</span>(<span class="string">&#x27;2015-3-25&#x27;</span>)</code></pre><p>调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>now()call now():<span class="number">2015</span>-<span class="number">3</span>-<span class="number">25</span></code></pre><p>把@log放到now()函数的定义处，相当于执行了语句：</p><pre><code class="highlight python">now = log(now)</code></pre><p>由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。</p><p>wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。</p><hr /><p><strong>如果decorator本身需要传入参数</strong>，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">text</span>):    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):            <span class="built_in">print</span>(<span class="string">&#x27;%s %s():&#x27;</span> % (text, func.__name__))            <span class="keyword">return</span> func(*args, **kw)        <span class="keyword">return</span> wrapper    <span class="keyword">return</span> decorator</code></pre><p>这个3层嵌套的decorator用法如下：</p><pre><code class="highlight python"><span class="meta">@log(<span class="params"><span class="string">&#x27;execute&#x27;</span></span>)</span><span class="keyword">def</span> <span class="title function_">now</span>():    <span class="built_in">print</span>(<span class="string">&#x27;2015-3-25&#x27;</span>)<span class="comment">#执行结果如下：</span><span class="meta">&gt;&gt;&gt; </span>now()execute now():<span class="number">2015</span>-<span class="number">3</span>-<span class="number">25</span></code></pre><p>和两层嵌套的decorator相比，3层嵌套的效果是这样的：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>now = log(<span class="string">&#x27;execute&#x27;</span>)(now)</code></pre><blockquote><p>我们来剖析上面的语句，首先执行log(‘execute’)，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数</p></blockquote><p>以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的’now’变成了’wrapper’：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>now.__name__<span class="string">&#x27;wrapper&#x27;</span></code></pre><p>因为返回的那个wrapper()函数名字就是’wrapper’，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。</p><p><strong>不需要编写wrapper.__name__ = func.__name__这样的代码，Python内置的functools.wraps就是干这个事的</strong>，所以，一个完整的decorator的写法如下：</p><pre><code class="highlight python"><span class="keyword">import</span> functools<span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">func</span>):<span class="meta">    @functools.wraps(<span class="params">func</span>)</span>    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):        <span class="built_in">print</span>(<span class="string">&#x27;call %s():&#x27;</span> % func.__name__)        <span class="keyword">return</span> func(*args, **kw)    <span class="keyword">return</span> wrapper</code></pre><p>或者针对带参数的decorator：</p><pre><code class="highlight python"><span class="keyword">import</span> functools<span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">text</span>):    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):<span class="meta">        @functools.wraps(<span class="params">func</span>)</span>        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):            <span class="built_in">print</span>(<span class="string">&#x27;%s %s():&#x27;</span> % (text, func.__name__))            <span class="keyword">return</span> func(*args, **kw)        <span class="keyword">return</span> wrapper    <span class="keyword">return</span> decorator</code></pre><blockquote><p>import functools是导入functools模块。现在，只需记住在定义wrapper()的前面加上@functools.wraps(func)即可。</p></blockquote><hr /><p>练习：</p><p>请设计一个decorator，它可作用于任何函数上，并打印该函数的执行时间：</p><pre><code class="highlight python"><span class="comment"># -*- coding: utf-8 -*-</span><span class="keyword">import</span> time, functools<span class="keyword">def</span> <span class="title function_">metric</span>(<span class="params">fn</span>):<span class="meta">    @functools.wraps(<span class="params">fn</span>)</span>    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):      t0 = time.time()      result = fn(*args, **kw)      <span class="built_in">print</span>(<span class="string">&#x27;%s executed in %s ms&#x27;</span> % (fn.__name__, time.time()-t0))      <span class="keyword">return</span> result    <span class="keyword">return</span> wrapper<span class="comment"># 测试</span><span class="meta">@metric</span><span class="keyword">def</span> <span class="title function_">fast</span>(<span class="params">x, y</span>):    time.sleep(<span class="number">0.0012</span>)    <span class="keyword">return</span> x + y;<span class="meta">@metric</span><span class="keyword">def</span> <span class="title function_">slow</span>(<span class="params">x, y, z</span>):    time.sleep(<span class="number">0.1234</span>)    <span class="keyword">return</span> x * y * z;f = fast(<span class="number">11</span>, <span class="number">22</span>)s = slow(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>)<span class="keyword">if</span> f != <span class="number">33</span>:    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)<span class="keyword">elif</span> s != <span class="number">7986</span>:    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</code></pre><h3 id="偏函数"><a class="markdownIt-Anchor" href="#偏函数"></a> 偏函数</h3><p>Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。</p><p>在介绍函数参数的时候，我们讲到，通<strong>过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点</strong>。</p><p>举例如下：int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;12345&#x27;</span>)<span class="number">12345</span></code></pre><p>但int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做N进制的转换：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;12345&#x27;</span>, base=<span class="number">8</span>)<span class="number">5349</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;12345&#x27;</span>, <span class="number">16</span>)<span class="number">74565</span></code></pre><p>假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">int2</span>(<span class="params">x, base=<span class="number">2</span></span>):    <span class="keyword">return</span> <span class="built_in">int</span>(x, base)</code></pre><p>这样，我们转换二进制就非常方便了：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">&#x27;1000000&#x27;</span>)<span class="number">64</span>&gt;&gt;&gt; int2(<span class="string">&#x27;1010101&#x27;</span>)<span class="number">85</span></code></pre><p><strong>functools.partial就是帮助我们创建一个偏函数的</strong>，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools<span class="meta">&gt;&gt;&gt; </span>int2 = functools.partial(<span class="built_in">int</span>, base=<span class="number">2</span>)<span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">&#x27;1000000&#x27;</span>)<span class="number">64</span>&gt;&gt;&gt; int2(<span class="string">&#x27;1010101&#x27;</span>)<span class="number">85</span></code></pre><p>所以，简单<strong>总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单</strong>。</p><p>注意到上面的新的int2函数，仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">&#x27;1000000&#x27;</span>, base=<span class="number">10</span>)<span class="number">1000000</span></code></pre><p>最后，创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数，当传入：</p><pre><code class="highlight python">int2 = functools.partial(<span class="built_in">int</span>, base=<span class="number">2</span>)<span class="comment">#实际上固定了int()函数的关键字参数base，也就是：</span>int2(<span class="string">&#x27;10010&#x27;</span>)<span class="comment">#相当于：</span>kw = &#123; <span class="string">&#x27;base&#x27;</span>: <span class="number">2</span> &#125;<span class="built_in">int</span>(<span class="string">&#x27;10010&#x27;</span>, **kw)</code></pre><p>当传入：</p><pre><code class="highlight python">max2 = functools.partial(<span class="built_in">max</span>, <span class="number">10</span>)<span class="comment">#实际上会把10作为\*args的一部分自动加到左边，也就是：</span>max2(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)<span class="comment">#相当于：</span>args = (<span class="number">10</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)<span class="built_in">max</span>(*args)<span class="comment">#结果为10。</span></code></pre><h2 id="模块"><a class="markdownIt-Anchor" href="#模块"></a> 模块</h2><p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。</p><p><strong>模块</strong></p><ul><li><p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，<strong>一个.py文件就称之为一个模块</strong>（Module）。</p></li><li><p>使用模块最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。</p></li><li><p><strong>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突</strong>。但是也要注意，尽量不要与内置函数名字冲突。点这里 <a href="https://docs.python.org/3/library/functions.html#built-in-functions">查看</a> Python的所有内置函数。</p></li></ul><p><strong>包</strong></p><ul><li>为了<strong>避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包</strong>（Package）。</li></ul><blockquote><p>举个例子，一个abc.py的文件就是一个名字叫abc的模块，一个xyz.py的文件就是一个名字叫xyz的模块</p></blockquote><ul><li><p>现在，假设我们的abc和xyz这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，比如mycompany，按照如下目录存放：</p></li><li><p>引入了包以后，<strong>只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突</strong>。现在，abc.py模块的名字就变成了mycompany.abc，类似的，xyz.py的模块名变成了mycompany.xyz。</p></li></ul><p>请注意，<strong>每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的</strong>，否则，Python就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是mycompany</p><p>类似的，可以有多级目录，组成多级层次的包结构。比如如下的目录结构：</p><blockquote><p>文件www.py的模块名就是mycompany.web.www，两个文件utils.py的模块名分别是mycompany.utils和mycompany.web.utils。</p></blockquote><blockquote><p><strong>自己创建模块时要注意命名，不能和Python自带的模块名称冲突</strong>。例如，系统自带了sys模块，<a href="http://xn--sys-628d3h362a9f56aw1q4qn0uezn8b1w7afm7a.py">自己的模块就不可命名为sys.py</a>，否则将无法导入系统自带的sys模块。</p></blockquote><h3 id="使用模块"><a class="markdownIt-Anchor" href="#使用模块"></a> 使用模块</h3><p>Python本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。</p><p>我们以内建的sys模块为例，编写一个hello的模块：</p><ul><li>第1行注释可以让这个hello.py文件直接在Unix/Linux/Mac上运行</li><li>第2行注释表示.py文件本身使用标准UTF-8编码</li><li>第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释</li><li>第6行使用__author__变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名</li></ul><blockquote><p>以上就是Python模块的标准文件模板，当然也可以全部删掉不写，但是，按标准办事肯定没错</p></blockquote><pre><code class="highlight python"><span class="comment">#!/usr/bin/env python3</span><span class="comment"># -*- coding: utf-8 -*-</span><span class="string">&#x27; a test module &#x27;</span>__author__ = <span class="string">&#x27;Michael Liao&#x27;</span><span class="keyword">import</span> sys<span class="keyword">def</span> <span class="title function_">test</span>():    args = sys.argv    <span class="keyword">if</span> <span class="built_in">len</span>(args)==<span class="number">1</span>:        <span class="built_in">print</span>(<span class="string">&#x27;Hello, world!&#x27;</span>)    <span class="keyword">elif</span> <span class="built_in">len</span>(args)==<span class="number">2</span>:        <span class="built_in">print</span>(<span class="string">&#x27;Hello, %s!&#x27;</span> % args[<span class="number">1</span>])    <span class="keyword">else</span>:        <span class="built_in">print</span>(<span class="string">&#x27;Too many arguments!&#x27;</span>)<span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:    test()</code></pre><p>使用sys模块的第一步，就是导入该模块：</p><pre><code class="highlight python"><span class="keyword">import</span> sys</code></pre><p>导入sys模块后，我们就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。</p><p>sys模块有一个<strong>argv变量，用list存储了命令行的所有参数</strong>。argv至少有一个元素，因为<strong>第一个参数永远是该.py文件的名称</strong>，例如：</p><ul><li>运行python3 hello.py获得的sys.argv就是[‘<a href="http://hello.py">hello.py</a>’]</li><li>运行python3 <a href="http://hello.py">hello.py</a> Michael获得的sys.argv就是[‘<a href="http://hello.py">hello.py</a>’, ‘Michael’]</li></ul><hr /><p>最后，注意到这两行代码：</p><pre><code class="highlight python"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:    test()</code></pre><p>当我们在命令行运行hello模块文件时，<strong>Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败</strong>，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p><p>我们可以用命令行运行hello.py看看效果：</p><pre><code class="highlight plaintext">$ python3 hello.pyHello, world!$ python hello.py MichaelHello, Michael!</code></pre><p>如果启动Python交互环境，再导入hello模块：</p><pre><code class="highlight python">$ python3Python <span class="number">3.4</span><span class="number">.3</span> (v3<span class="number">.4</span><span class="number">.3</span>:9b73f1c3e601, Feb <span class="number">23</span> <span class="number">2015</span>, 02:<span class="number">52</span>:03) [GCC <span class="number">4.2</span><span class="number">.1</span> (Apple Inc. build <span class="number">5666</span>) (dot <span class="number">3</span>)] on darwin<span class="type">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.<span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> hello&gt;&gt;&gt;</code></pre><blockquote><p>导入时，没有打印Hello, word!，因为没有执行test()函数。</p></blockquote><p>调用hello.test()时，才能打印出Hello, word!：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>hello.test()Hello, world!</code></pre><hr /><p><strong>作用域</strong></p><p>在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。</p><p>正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等；</p><p>类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的__author__，__name__就是特殊变量，hello模块定义的文档注释也可以用特殊变量__doc__访问，我们自己的变量一般不要用这种变量名；</p><p>类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等；</p><p>之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</p><p>private函数或变量不应该被别人引用，那它们有什么用呢？请看例子：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">_private_1</span>(<span class="params">name</span>):    <span class="keyword">return</span> <span class="string">&#x27;Hello, %s&#x27;</span> % name<span class="keyword">def</span> <span class="title function_">_private_2</span>(<span class="params">name</span>):    <span class="keyword">return</span> <span class="string">&#x27;Hi, %s&#x27;</span> % name<span class="keyword">def</span> <span class="title function_">greeting</span>(<span class="params">name</span>):    <span class="keyword">if</span> <span class="built_in">len</span>(name) &gt; <span class="number">3</span>:        <span class="keyword">return</span> _private_1(name)    <span class="keyword">else</span>:        <span class="keyword">return</span> _private_2(name)</code></pre><p>我们在模块里公开greeting()函数，而把内部逻辑用private函数隐藏起来了，这样，调用greeting()函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即：</p><ul><li>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</li></ul><h3 id="安装第三方模块"><a class="markdownIt-Anchor" href="#安装第三方模块"></a> 安装第三方模块</h3><p><strong>在Python中，安装第三方模块，是通过包管理工具pip完成的</strong>。</p><p>如果你正在使用Mac或Linux，安装pip本身这个步骤就可以跳过了。</p><p>如果是Windows，则安装python时勾选pip和add python.exe to path即可</p><p>在命令提示符窗口下尝试运行pip，如果Windows提示未找到命令，可以重新运行安装程序添加pip。</p><blockquote><p>注意：Mac或Linux上有可能并存Python 3.x和Python 2.x，因此对应的pip命令是pip3。</p></blockquote><p>例如，我们要安装一个第三方库——Python Imaging Library，这是Python下非常强大的处理图像的工具库。不过，PIL目前只支持到Python 2.7，并且有年头没有更新了，因此，基于PIL的Pillow项目开发非常活跃，并且支持最新的Python 3。</p><p>一般来说，第三方库都会在Python官方的<a href="pypi.python.org">pypi.python.org</a>网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Pillow的名称叫Pillow，因此，安装Pillow的命令就是：</p><pre><code class="highlight python">pip install Pillow</code></pre><hr /><p><strong>安装常用模块</strong></p><p>在使用Python时，我们经常需要用到很多第三方库，例如，上面提到的Pillow，以及MySQL驱动程序，Web框架Flask，科学计算Numpy等。用pip一个一个安装费时费力，还需要考虑兼容性。我们推荐直接使用Anaconda，这是一个基于Python的数据处理和科学计算平台，它已经内置了许多非常有用的第三方库，我们装上Anaconda，就相当于把数十个第三方模块自动安装好了，非常简单易用。</p><p>可以从Anaconda官网下载GUI安装包，安装包有500~600M，所以需要耐心等待下载。下载后直接安装，Anaconda会把系统Path中的python指向自己自带的Python，并且，Anaconda安装的第三方模块会安装在Anaconda自己的路径下，不影响系统已安装的Python目录。</p><p>安装好Anaconda后，重新打开命令行窗口，输入python，可以看到Anaconda的信息：</p><blockquote><p>可以尝试直接import numpy等已安装的第三方模块。</p></blockquote><p><strong>模块搜索路径</strong></p><p>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mymoduleTraceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;ImportError: No module named mymodule</code></pre><p>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys<span class="meta">&gt;&gt;&gt; </span>sys.path[<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip&#x27;</span>, <span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6&#x27;</span>, ..., <span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages&#x27;</span>]</code></pre><p><strong>如果我们要添加自己的搜索目录</strong>，有两种方法：</p><ul><li>一是<strong>直接修改sys.path</strong>，添加要搜索的目录（这种方法是在运行时修改，运行结束后失效）：</li></ul><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys<span class="meta">&gt;&gt;&gt; </span>sys.path.append(<span class="string">&#x27;/Users/michael/my_py_scripts&#x27;</span>)</code></pre><ul><li>第二种方法是<strong>设置环境变量PYTHONPATH</strong>，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。</li></ul><h4 id="配置其他镜像源"><a class="markdownIt-Anchor" href="#配置其他镜像源"></a> 配置其他镜像源</h4><p><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a></p><pre><code class="highlight python">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 包名</code></pre><h2 id="面向对象编程"><a class="markdownIt-Anchor" href="#面向对象编程"></a> 面向对象编程</h2><p>面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。</p><p>面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p><p>而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p><p>在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。</p><hr /><p>我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处。</p><p>假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个dict表示：</p><pre><code class="highlight python">std1 = &#123; <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">98</span> &#125;std2 = &#123; <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">81</span> &#125;</code></pre><p>而处理学生成绩可以通过函数实现，比如打印学生的成绩：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">std</span>):    <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (std[<span class="string">&#x27;name&#x27;</span>], std[<span class="string">&#x27;score&#x27;</span>]))</code></pre><p>如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是Student这种数据类型应该被视为一个对象，这个对象拥有name和score这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来。</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):        <span class="variable language_">self</span>.name = name        <span class="variable language_">self</span>.score = score    <span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (<span class="variable language_">self</span>.name, <span class="variable language_">self</span>.score))</code></pre><p>给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：</p><pre><code class="highlight python">bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">59</span>)lisa = Student(<span class="string">&#x27;Lisa Simpson&#x27;</span>, <span class="number">87</span>)bart.print_score()lisa.print_score()</code></pre><p>面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。Class是一种抽象概念，比如我们定义的Class——Student，是指学生这个概念，而实例（Instance）则是一个个具体的Student，比如，Bart Simpson和Lisa Simpson是两个具体的Student。</p><p>所以，面向对象的设计思想是抽象出Class，根据Class创建Instance。</p><p>面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法。</p><h3 id="类和实例"><a class="markdownIt-Anchor" href="#类和实例"></a> 类和实例</h3><p>面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。</p><p>仍以Student类为例，在Python中，定义类是通过class关键字：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">pass</span></code></pre><p>class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。</p><p>定义好了Student类，就可以根据Student类创建出Student的实例，创建实例是通过类名+()实现的：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>bart = Student()<span class="meta">&gt;&gt;&gt; </span>bart&lt;__main__.Student <span class="built_in">object</span> at <span class="number">0x10a67a590</span>&gt;<span class="meta">&gt;&gt;&gt; </span>Student&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Student&#x27;</span>&gt;</code></pre><p>可以看到，变量bart指向的就是一个Student的实例，后面的0x10a67a590是内存地址，每个object的地址都不一样，而Student本身则是一个类。</p><p><strong>可以自由地给一个实例变量绑定属性</strong>，比如，给实例bart绑定一个name属性：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>bart.name = <span class="string">&#x27;Bart Simpson&#x27;</span><span class="meta">&gt;&gt;&gt; </span>bart.name<span class="string">&#x27;Bart Simpson&#x27;</span></code></pre><h4 id="__init__"><a class="markdownIt-Anchor" href="#__init__"></a> __init__</h4><p>由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):        <span class="variable language_">self</span>.name = name        <span class="variable language_">self</span>.score = score</code></pre><blockquote><p><strong>注意：特殊方法“<strong>init</strong>”前后分别有两个下划线！！！</strong></p></blockquote><p>注意到__init__方法的<strong>第一个参数永远是self，表示创建的实例本身</strong>，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。</p><p>有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">59</span>)<span class="meta">&gt;&gt;&gt; </span>bart.name<span class="string">&#x27;Bart Simpson&#x27;</span><span class="meta">&gt;&gt;&gt; </span>bart.score<span class="number">59</span></code></pre><p><strong>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数</strong>。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</p><hr /><p><strong>数据封装</strong></p><p>面向对象编程的一个重要特点就是数据封装。在上面的Student类中，每个实例就拥有各自的name和score这些数据。我们可以通过函数来访问这些数据，比如打印一个学生的成绩：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">std</span>):<span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (std.name, std.score))...<span class="meta">&gt;&gt;&gt; </span>print_score(bart)Bart Simpson: <span class="number">59</span></code></pre><p>但是，既然Student实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在Student类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和Student类本身是关联起来的，我们称之为类的方法：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):        <span class="variable language_">self</span>.name = name        <span class="variable language_">self</span>.score = score    <span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (<span class="variable language_">self</span>.name, <span class="variable language_">self</span>.score))</code></pre><p>要定义一个方法，除了第一个参数是self外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>bart.print_score()Bart Simpson: <span class="number">59</span></code></pre><p>这样一来，我们从外部看Student类，就只需要知道，创建实例需要给出name和score，而如何打印，都是在Student类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。</p><p>封装的另一个好处是可以给Student类增加新的方法，比如get_grade：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):    ...    <span class="keyword">def</span> <span class="title function_">get_grade</span>(<span class="params">self</span>):        <span class="keyword">if</span> <span class="variable language_">self</span>.score &gt;= <span class="number">90</span>:            <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span>        <span class="keyword">elif</span> <span class="variable language_">self</span>.score &gt;= <span class="number">60</span>:            <span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span>        <span class="keyword">else</span>:            <span class="keyword">return</span> <span class="string">&#x27;C&#x27;</span></code></pre><p>同样的，get_grade方法可以直接在实例变量上调用，不需要知道内部实现细节：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):        <span class="variable language_">self</span>.name = name        <span class="variable language_">self</span>.score = score    <span class="keyword">def</span> <span class="title function_">get_grade</span>(<span class="params">self</span>):        <span class="keyword">if</span> <span class="variable language_">self</span>.score &gt;= <span class="number">90</span>:            <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span>        <span class="keyword">elif</span> <span class="variable language_">self</span>.score &gt;= <span class="number">60</span>:            <span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span>        <span class="keyword">else</span>:            <span class="keyword">return</span> <span class="string">&#x27;C&#x27;</span>lisa = Student(<span class="string">&#x27;Lisa&#x27;</span>, <span class="number">99</span>)bart = Student(<span class="string">&#x27;Bart&#x27;</span>, <span class="number">59</span>)<span class="built_in">print</span>(lisa.name, lisa.get_grade())<span class="built_in">print</span>(bart.name, bart.get_grade())</code></pre><h3 id="访问限制"><a class="markdownIt-Anchor" href="#访问限制"></a> 访问限制</h3><p>在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。</p><p>但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">59</span>)<span class="meta">&gt;&gt;&gt; </span>bart.score<span class="number">59</span><span class="meta">&gt;&gt;&gt; </span>bart.score = <span class="number">99</span><span class="meta">&gt;&gt;&gt; </span>bart.score<span class="number">99</span></code></pre><p><strong>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线</strong><code>__</code>，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):        <span class="variable language_">self</span>.__name = name        <span class="variable language_">self</span>.__score = score    <span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (<span class="variable language_">self</span>.__name, <span class="variable language_">self</span>.__score))</code></pre><p>改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量.__name和实例变量.__score了：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">59</span>)<span class="meta">&gt;&gt;&gt; </span>bart.__nameTraceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;AttributeError: <span class="string">&#x27;Student&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;__name&#x27;</span></code></pre><p>这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。</p><p>但是如果外部代码要获取name和score怎么办？可以给Student类增加get_name和get_score这样的方法：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):    ...    <span class="keyword">def</span> <span class="title function_">get_name</span>(<span class="params">self</span>):        <span class="keyword">return</span> <span class="variable language_">self</span>.__name    <span class="keyword">def</span> <span class="title function_">get_score</span>(<span class="params">self</span>):        <span class="keyword">return</span> <span class="variable language_">self</span>.__score</code></pre><p>如果又要允许外部代码修改score怎么办？可以再给Student类增加set_score方法：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):    ...    <span class="keyword">def</span> <span class="title function_">set_score</span>(<span class="params">self, score</span>):        <span class="variable language_">self</span>.__score = score</code></pre><p>你也许会问，原先那种直接通过bart.score = 99也可以修改啊，为什么要定义一个方法大费周折？</p><ul><li><strong>因为在方法中，可以对参数做检查，避免传入无效的参数</strong>：</li></ul><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):    ...    <span class="keyword">def</span> <span class="title function_">set_score</span>(<span class="params">self, score</span>):        <span class="keyword">if</span> <span class="number">0</span> &lt;= score &lt;= <span class="number">100</span>:            <span class="variable language_">self</span>.__score = score        <span class="keyword">else</span>:            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;bad score&#x27;</span>)</code></pre><p>需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，<strong>特殊变量是可以直接访问的</strong>，不是private变量，所以，不能用__name__、__score__这样的变量名。</p><p>有些时候，你会看到以<strong>一个下划线开头的实例变量名</strong>，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“<strong>虽然我可以被访问，但是，请把我视为私有变量，不要随意访问</strong>”。</p><p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。<strong>不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name</strong>，所以，仍然可以通过_Student__name来访问__name变量：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>bart._Student__name<span class="string">&#x27;Bart Simpson&#x27;</span></code></pre><blockquote><p>但是<strong>强烈建议你不要这么干</strong>，因为不同版本的Python解释器可能会把__name改成不同的变量名。</p></blockquote><p>总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。</p><p>最后注意下面的这种错误写法：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">59</span>)<span class="meta">&gt;&gt;&gt; </span>bart.get_name()<span class="string">&#x27;Bart Simpson&#x27;</span><span class="meta">&gt;&gt;&gt; </span>bart.__name = <span class="string">&#x27;New Name&#x27;</span> <span class="comment"># 设置__name变量！&gt;&gt;&gt; bart.__name</span><span class="string">&#x27;New Name&#x27;</span></code></pre><p>表面上看，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量！内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给bart新增了一个__name变量。不信试试：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>bart.get_name() <span class="comment">#get_name()内部返回self.__name&#x27;</span>Bart Simpson<span class="string">&#x27;</span></code></pre><h3 id="继承和多态"><a class="markdownIt-Anchor" href="#继承和多态"></a> 继承和多态</h3><p>在OOP程序设计中，<strong>当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类</strong>（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。</p><p>比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;Animal is running...&#x27;</span>)</code></pre><p>当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):    <span class="keyword">pass</span><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):    <span class="keyword">pass</span></code></pre><p>对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是它的子类。Cat和Dog类似。</p><p>继承有什么好处？<strong>最大的好处是子类获得了父类的全部功能</strong>。由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法：</p><pre><code class="highlight python">dog = Dog()dog.run()cat = Cat()cat.run()<span class="comment">#运行结果如下：</span>Animal <span class="keyword">is</span> running...Animal <span class="keyword">is</span> running...</code></pre><p>当然，也可以对子类增加一些方法，比如Dog类：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;Dog is running...&#x27;</span>)    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;Eating meat...&#x27;</span>)</code></pre><p>继承的第二个好处需要我们对代码做一点改进。你看到了，无论是Dog还是Cat，它们run()的时候，显示的都是Animal is running…，符合逻辑的做法是分别显示Dog is running…和Cat is running…，因此，对Dog和Cat类改进如下：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;Dog is running...&#x27;</span>)<span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;Cat is running...&#x27;</span>)        <span class="comment">#再次运行，结果如下：</span>Dog <span class="keyword">is</span> running...Cat <span class="keyword">is</span> running...</code></pre><p><strong>当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run</strong>()。这样，我们就获得了继承的另一个好处：<strong>多态</strong>。</p><hr /><p><strong>多态</strong></p><p>要理解什么是多态，我们首先要对数据类型再作一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：</p><pre><code class="highlight python">a = <span class="built_in">list</span>() <span class="comment"># a是list类型</span>b = Animal() <span class="comment"># b是Animal类型</span>c = Dog() <span class="comment"># c是Dog类型</span></code></pre><p>判断一个变量是否是某个类型可以用isinstance()判断：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(a, <span class="built_in">list</span>)<span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(b, Animal)<span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(c, Dog)<span class="literal">True</span><span class="comment">#看来a、b、c确实对应着list、Animal、Dog这3种类型。</span><span class="comment">#看来c不仅仅是Dog，c还是Animal！</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(c, Animal)<span class="literal">True</span></code></pre><blockquote><p>不过仔细想想，这是有道理的，因为Dog是从Animal继承下来的，当我们创建了一个Dog的实例c时，我们认为c的数据类型是Dog没错，但c同时也是Animal也没错，Dog本来就是Animal的一种</p></blockquote><p>所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>b = Animal()<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(b, Dog)<span class="literal">False</span><span class="comment">#Dog可以看成Animal，但Animal不可以看成Dog</span></code></pre><p>要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个Animal类型的变量：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">run_twice</span>(<span class="params">animal</span>):    animal.run()    animal.run()</code></pre><p>当我们传入Animal的实例时，run_twice()就打印出：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>run_twice(Animal())Animal <span class="keyword">is</span> running...Animal <span class="keyword">is</span> running...</code></pre><p>当我们传入Dog的实例时，run_twice()就打印出：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>run_twice(Dog())Dog <span class="keyword">is</span> running...Dog <span class="keyword">is</span> running...</code></pre><p>当我们传入Cat的实例时，run_twice()就打印出：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>run_twice(Cat())Cat <span class="keyword">is</span> running...Cat <span class="keyword">is</span> running...</code></pre><p>看上去没啥意思，但是仔细想想，现在，如果我们再定义一个Tortoise类型，也从Animal派生：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Tortoise</span>(<span class="title class_ inherited__">Animal</span>):    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;Tortoise is running slowly...&#x27;</span>)</code></pre><p>当我们调用run_twice()时，传入Tortoise的实例：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>run_twice(Tortoise())Tortoise <span class="keyword">is</span> running slowly...Tortoise <span class="keyword">is</span> running slowly...</code></pre><p>你会发现，新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。</p><p>多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思：</p><p>对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，<strong>这就是多态真正的威力：调用方只管调用，不管细节</strong>，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p><ul><li><p><strong>对扩展开放</strong>：允许新增Animal子类；</p></li><li><p><strong>对修改封闭</strong>：不需要修改依赖Animal类型的run_twice()等函数。</p></li></ul><p>继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系**。而任何类，最终都可以追溯到根类object**，这些继承关系看上去就像一颗倒着的树。比如如下的继承树：</p><hr /><p><strong>静态语言VS动态语言</strong></p><p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。</p><p>对于Python这样的<strong>动态语言</strong>来说，则<strong>不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了</strong>：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Timer</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;Start...&#x27;</span>)</code></pre><p>这就是动态语言的“鸭子类型”，<strong>它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子</strong>。</p><p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。</p><h3 id="获取对象信息"><a class="markdownIt-Anchor" href="#获取对象信息"></a> 获取对象信息</h3><p>当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？</p><h4 id="使用type"><a class="markdownIt-Anchor" href="#使用type"></a> <strong>使用type</strong>()</h4><p>首先，我们来判断对象类型，使用type()函数：</p><p>基本类型都可以用type()判断：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">123</span>)&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;<span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="string">&#x27;str&#x27;</span>)&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;<span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="literal">None</span>)&lt;<span class="built_in">type</span>(<span class="literal">None</span>) <span class="string">&#x27;NoneType&#x27;</span>&gt;</code></pre><p>如果一个变量指向函数或者类，也可以用type()判断：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="built_in">abs</span>)&lt;<span class="keyword">class</span> <span class="string">&#x27;builtin_function_or_method&#x27;</span>&gt;<span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a)&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Animal&#x27;</span>&gt;</code></pre><p><strong>type()函数返回对应的Class类型</strong>。如果我们要在if语句中判断，就需要比较两个变量的type类型是否相同：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">123</span>)==<span class="built_in">type</span>(<span class="number">456</span>)<span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">123</span>)==<span class="built_in">int</span><span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="string">&#x27;abc&#x27;</span>)==<span class="built_in">type</span>(<span class="string">&#x27;123&#x27;</span>)<span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="string">&#x27;abc&#x27;</span>)==<span class="built_in">str</span><span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="string">&#x27;abc&#x27;</span>)==<span class="built_in">type</span>(<span class="number">123</span>)<span class="literal">False</span></code></pre><p>判断基本数据类型可以直接写int，str等，但如果要判断一个对象是否是函数怎么办？可以<strong>使用types模块中定义的常量</strong>：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> types<span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fn</span>():<span class="meta">... </span>    <span class="keyword">pass</span>...<span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(fn)==types.FunctionType<span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="built_in">abs</span>)==types.BuiltinFunctionType<span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="keyword">lambda</span> x: x)==types.LambdaType<span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>((x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)))==types.GeneratorType<span class="literal">True</span></code></pre><h4 id="使用isinstance"><a class="markdownIt-Anchor" href="#使用isinstance"></a> 使用isinstance()</h4><p>对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数。</p><p>我们回顾上次的例子，如果继承关系是：</p><pre><code class="highlight plaintext">object -&gt; Animal -&gt; Dog -&gt; Husky</code></pre><p>那么，isinstance()就可以告诉我们，一个对象是否是某种类型。先创建3种类型的对象：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>a = Animal()<span class="meta">&gt;&gt;&gt; </span>d = Dog()<span class="meta">&gt;&gt;&gt; </span>h = Husky()</code></pre><p>然后，判断：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(h, Husky)<span class="literal">True</span><span class="comment">#没有问题，因为h变量指向的就是Husky对象。</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(h, Dog)<span class="literal">True</span></code></pre><p>h虽然自身是Husky类型，但由于Husky是从Dog继承下来的，所以，h也还是Dog类型。换句话说，<strong>isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上</strong>。</p><p>因此，我们可以确信，h还是Animal类型：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(h, Animal)<span class="literal">True</span></code></pre><p>但是，d不是Husky类型：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(d, Husky)<span class="literal">False</span></code></pre><p>能用type()判断的基本类型也可以用isinstance()判断：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">&#x27;a&#x27;</span>, <span class="built_in">str</span>)<span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="number">123</span>, <span class="built_in">int</span>)<span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">b&#x27;a&#x27;</span>, <span class="built_in">bytes</span>)<span class="literal">True</span></code></pre><p>并且还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (<span class="built_in">list</span>, <span class="built_in">tuple</span>))<span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="built_in">list</span>, <span class="built_in">tuple</span>))<span class="literal">True</span></code></pre><blockquote><p><strong>总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”</strong></p></blockquote><h4 id="使用dir"><a class="markdownIt-Anchor" href="#使用dir"></a> 使用dir()</h4><p><strong>如果要获得一个对象的所有属性和方法，可以使用dir()函数</strong>，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(<span class="string">&#x27;ABC&#x27;</span>)[<span class="string">&#x27;__add__&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>,..., <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;capitalize&#x27;</span>, <span class="string">&#x27;casefold&#x27;</span>,..., <span class="string">&#x27;zfill&#x27;</span>]</code></pre><p>类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法，所以，下面的代码是等价的：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="string">&#x27;ABC&#x27;</span>)<span class="number">3</span><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;ABC&#x27;</span>.__len__()<span class="number">3</span></code></pre><p>我们自己写的类，如果也想用len(myObj)的话，就自己写一个__len__()方法：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">MyDog</span>(<span class="title class_ inherited__">object</span>):<span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):<span class="meta">... </span>        <span class="keyword">return</span> <span class="number">100</span>...<span class="meta">&gt;&gt;&gt; </span>dog = MyDog()<span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(dog)<span class="number">100</span></code></pre><p>剩下的都是普通属性或方法，比如lower()返回小写的字符串：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;ABC&#x27;</span>.lower()<span class="string">&#x27;abc&#x27;</span></code></pre><p>仅仅把属性和方法列出来是不够的，<strong>配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态</strong>：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">MyObject</span>(<span class="title class_ inherited__">object</span>):<span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):<span class="meta">... </span>        <span class="variable language_">self</span>.x = <span class="number">9</span><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">self</span>):<span class="meta">... </span>        <span class="keyword">return</span> <span class="variable language_">self</span>.x * <span class="variable language_">self</span>.x...<span class="meta">&gt;&gt;&gt; </span>obj = MyObject()</code></pre><p>紧接着，可以测试该对象的属性：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(obj, <span class="string">&#x27;x&#x27;</span>) <span class="comment"># 有属性&#x27;x&#x27;吗？</span><span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span>obj.x<span class="number">9</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(obj, <span class="string">&#x27;y&#x27;</span>) <span class="comment"># 有属性&#x27;y&#x27;吗？</span><span class="literal">False</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">setattr</span>(obj, <span class="string">&#x27;y&#x27;</span>, <span class="number">19</span>) <span class="comment"># 设置一个属性&#x27;y&#x27;</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(obj, <span class="string">&#x27;y&#x27;</span>) <span class="comment"># 有属性&#x27;y&#x27;吗？</span><span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(obj, <span class="string">&#x27;y&#x27;</span>) <span class="comment"># 获取属性&#x27;y&#x27;</span><span class="number">19</span><span class="meta">&gt;&gt;&gt; </span>obj.y <span class="comment"># 获取属性&#x27;y&#x27;</span><span class="number">19</span></code></pre><p>如果试图获取不存在的属性，会抛出AttributeError的错误：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(obj, <span class="string">&#x27;z&#x27;</span>) <span class="comment"># 获取属性&#x27;z&#x27;</span>Traceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;AttributeError: <span class="string">&#x27;MyObject&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;z&#x27;</span></code></pre><p>可以传入一个default参数，如果属性不存在，就返回默认值：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(obj, <span class="string">&#x27;z&#x27;</span>, <span class="number">404</span>) <span class="comment"># 获取属性&#x27;z&#x27;，如果不存在，返回默认值404</span><span class="number">404</span></code></pre><p>也可以获得对象的方法：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(obj, <span class="string">&#x27;power&#x27;</span>) <span class="comment"># 有属性&#x27;power&#x27;吗？</span><span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(obj, <span class="string">&#x27;power&#x27;</span>) <span class="comment"># 获取属性&#x27;power&#x27;</span>&lt;bound method MyObject.power of &lt;__main__.MyObject <span class="built_in">object</span> at <span class="number">0x10077a6a0</span>&gt;&gt;<span class="meta">&gt;&gt;&gt; </span>fn = <span class="built_in">getattr</span>(obj, <span class="string">&#x27;power&#x27;</span>) <span class="comment"># 获取属性&#x27;power&#x27;并赋值到变量fn</span><span class="meta">&gt;&gt;&gt; </span>fn <span class="comment"># fn指向obj.power</span>&lt;bound method MyObject.power of &lt;__main__.MyObject <span class="built_in">object</span> at <span class="number">0x10077a6a0</span>&gt;&gt;<span class="meta">&gt;&gt;&gt; </span>fn() <span class="comment"># 调用fn()与调用obj.power()是一样的</span><span class="number">81</span></code></pre><p>通过内置的一系列函数，我们可以对任意一个Python对象进行剖析，拿到其内部的数据。要注意的是，只有在不知道对象信息的时候，我们才会去获取对象信息。如果可以直接写：</p><pre><code class="highlight python"><span class="built_in">sum</span> = obj.x + obj.y</code></pre><p>就不要写：</p><pre><code class="highlight python"><span class="built_in">sum</span> = <span class="built_in">getattr</span>(obj, <span class="string">&#x27;x&#x27;</span>) + <span class="built_in">getattr</span>(obj, <span class="string">&#x27;y&#x27;</span>)</code></pre><p>一个正确的用法的例子如下：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">readImage</span>(<span class="params">fp</span>):    <span class="keyword">if</span> <span class="built_in">hasattr</span>(fp, <span class="string">&#x27;read&#x27;</span>):        <span class="keyword">return</span> readData(fp)    <span class="keyword">return</span> <span class="literal">None</span></code></pre><p>假设我们希望从文件流fp中读取图像，我们首先要判断该fp对象是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取。hasattr()就派上了用场。</p><p>请注意，在Python这类动态语言中，根据鸭子类型，有read()方法，不代表该fp对象就是一个文件流，它也可能是网络流，也可能是内存中的一个字节流，但只要read()方法返回的是有效的图像数据，就不影响读取图像的功能。</p><h3 id="实例属性和类属性"><a class="markdownIt-Anchor" href="#实例属性和类属性"></a> 实例属性和类属性</h3><p>由于Python是动态语言，根据类创建的实例可以任意绑定属性。</p><p>给实例绑定属性的方法是通过实例变量，或者通过self变量：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):        <span class="variable language_">self</span>.name = names = Student(<span class="string">&#x27;Bob&#x27;</span>)s.score = <span class="number">90</span></code></pre><p>但是，如果Student类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归Student类所有：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):    name = <span class="string">&#x27;Student&#x27;</span></code></pre><p>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):<span class="meta">... </span>    name = <span class="string">&#x27;Student&#x27;</span>...<span class="meta">&gt;&gt;&gt; </span>s = Student() <span class="comment"># 创建实例s</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.name) <span class="comment"># 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span>Student<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Student.name) <span class="comment"># 打印类的name属性</span>Student<span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">&#x27;Michael&#x27;</span> <span class="comment"># 给实例绑定name属性</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.name) <span class="comment"># 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span>Michael<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Student.name) <span class="comment"># 但是类属性并未消失，用Student.name仍然可以访问</span>Student<span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> s.name <span class="comment"># 如果删除实例的name属性</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.name) <span class="comment"># 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span>Student</code></pre><blockquote><p>从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p></blockquote><p><strong>练习</strong></p><p>为了统计学生人数，可以给Student类增加一个类属性，每创建一个实例，该属性自动增加：</p><pre><code class="highlight python"><span class="comment"># -*- coding: utf-8 -*-</span><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):    count = <span class="number">0</span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):        <span class="variable language_">self</span>.name = name        Student.count = Student.count+<span class="number">1</span></code></pre><h2 id="面向对象高级编程"><a class="markdownIt-Anchor" href="#面向对象高级编程"></a> 面向对象高级编程</h2><h3 id="使用__slots__"><a class="markdownIt-Anchor" href="#使用__slots__"></a> 使用__slots__</h3><p>正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。先定义class：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">pass</span></code></pre><p>然后，尝试给实例绑定一个属性：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s = Student()<span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">&#x27;Michael&#x27;</span> <span class="comment"># 动态给实例绑定一个属性</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.name)Michael</code></pre><p>还可以尝试给实例绑定一个方法：</p><ul><li>这里之所以要使用MethodType方法是因为，如果只像赋值类方法一样给实例赋值方法，self参数是无法正常使用的。</li></ul><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">set_age</span>(<span class="params">self, age</span>): <span class="comment"># 定义一个函数作为实例方法</span><span class="meta">... </span>    <span class="variable language_">self</span>.age = age...<span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> MethodType<span class="meta">&gt;&gt;&gt; </span>s.set_age = MethodType(set_age, s) <span class="comment"># 给实例绑定一个方法</span><span class="meta">&gt;&gt;&gt; </span>s.set_age(<span class="number">25</span>) <span class="comment"># 调用实例方法</span><span class="meta">&gt;&gt;&gt; </span>s.age <span class="comment"># 测试结果</span><span class="number">25</span><span class="comment">#错误的示范，提示缺少参数</span>&gt;&gt;&gt;s.set_age =set_age&gt;&gt;&gt;s.set_age(<span class="number">15</span>)Traceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;TypeError: set_age() missing <span class="number">1</span> required positional argument: <span class="string">&#x27;age&#x27;</span><span class="comment">#只能这样使用</span>&gt;&gt;&gt;s.set_age(s,<span class="number">15</span>)&gt;&gt;&gt;s.age<span class="number">15</span></code></pre><p>但是，给一个实例绑定的方法，对另一个实例是不起作用的：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s2 = Student() <span class="comment"># 创建新的实例</span><span class="meta">&gt;&gt;&gt; </span>s2.set_age(<span class="number">25</span>) <span class="comment"># 尝试调用方法</span>Traceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;AttributeError: <span class="string">&#x27;Student&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;set_age&#x27;</span></code></pre><p>为了给所有实例都绑定方法，可以给class绑定方法：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">set_score</span>(<span class="params">self, score</span>):<span class="meta">... </span>    <span class="variable language_">self</span>.score = score...<span class="meta">&gt;&gt;&gt; </span>Student.set_score = set_score</code></pre><p>给class绑定方法后，所有实例均可调用：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s.set_score(<span class="number">100</span>)<span class="meta">&gt;&gt;&gt; </span>s.score<span class="number">100</span><span class="meta">&gt;&gt;&gt; </span>s2.set_score(<span class="number">99</span>)<span class="meta">&gt;&gt;&gt; </span>s2.score<span class="number">99</span></code></pre><p>通常情况下，上面的set_score方法可以直接定义在class中，但动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。</p><hr /><p><strong>使用__slots__</strong></p><p>但是，如果我们想要限制实例的属性怎么办？比如，只允许对Student实例添加name和age属性。</p><p>为了达到限制的目的，<strong>Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性</strong>：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):    __slots__ = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>) <span class="comment"># 用tuple定义允许绑定的属性名称</span></code></pre><p>然后，我们试试：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s = Student() <span class="comment"># 创建新的实例</span><span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">&#x27;Michael&#x27;</span> <span class="comment"># 绑定属性&#x27;name&#x27;</span><span class="meta">&gt;&gt;&gt; </span>s.age = <span class="number">25</span> <span class="comment"># 绑定属性&#x27;age&#x27;</span><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">99</span> <span class="comment"># 绑定属性&#x27;score&#x27;</span>Traceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;AttributeError: <span class="string">&#x27;Student&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;score&#x27;</span></code></pre><p>由于’score’没有被放到__slots__中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。</p><blockquote><p>使用__slots__要注意，<strong>slots</strong><strong>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的</strong>：</p></blockquote><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">GraduateStudent</span>(<span class="title class_ inherited__">Student</span>):<span class="meta">... </span>    <span class="keyword">pass</span>...<span class="meta">&gt;&gt;&gt; </span>g = GraduateStudent()<span class="meta">&gt;&gt;&gt; </span>g.score = <span class="number">9999</span></code></pre><p>除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。</p><h3 id="使用property"><a class="markdownIt-Anchor" href="#使用property"></a> 使用@property</h3><p>在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改：</p><pre><code class="highlight python">s = Student()s.score = <span class="number">9999</span></code></pre><p>这显然不合逻辑。为了限制score的范围，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">get_score</span>(<span class="params">self</span>):         <span class="keyword">return</span> <span class="variable language_">self</span>._score    <span class="keyword">def</span> <span class="title function_">set_score</span>(<span class="params">self, value</span>):        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must be an integer!&#x27;</span>)        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must between 0 ~ 100!&#x27;</span>)        <span class="variable language_">self</span>._score = value</code></pre><p>现在，对任意的Student实例进行操作，就不能随心所欲地设置score了：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s = Student()<span class="meta">&gt;&gt;&gt; </span>s.set_score(<span class="number">60</span>) <span class="comment"># ok!</span><span class="meta">&gt;&gt;&gt; </span>s.get_score()<span class="number">60</span><span class="meta">&gt;&gt;&gt; </span>s.set_score(<span class="number">9999</span>)Traceback (most recent call last):  ...ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span>!</code></pre><p>但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。</p><p>有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的Python程序员来说，这是必须要做到的！</p><p>还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。<strong>Python内置的@property装饰器就是负责把一个方法变成属性调用的</strong>：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):<span class="meta">    @property</span>    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self</span>):        <span class="keyword">return</span> <span class="variable language_">self</span>._score<span class="meta">    @score.setter</span>    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self, value</span>):        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must be an integer!&#x27;</span>)        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must between 0 ~ 100!&#x27;</span>)        <span class="variable language_">self</span>._score = value</code></pre><p>@property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s = Student()<span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">60</span> <span class="comment"># OK，实际转化为s.set_score(60)</span><span class="meta">&gt;&gt;&gt; </span>s.score <span class="comment"># OK，实际转化为s.get_score()</span><span class="number">60</span><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">9999</span>Traceback (most recent call last):  ...ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span>!</code></pre><p>注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。</p><p>还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):<span class="meta">    @property</span>    <span class="keyword">def</span> <span class="title function_">birth</span>(<span class="params">self</span>):        <span class="keyword">return</span> <span class="variable language_">self</span>._birth<span class="meta">    @birth.setter</span>    <span class="keyword">def</span> <span class="title function_">birth</span>(<span class="params">self, value</span>):        <span class="variable language_">self</span>._birth = value<span class="meta">    @property</span>    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):        <span class="keyword">return</span> <span class="number">2015</span> - <span class="variable language_">self</span>._birth</code></pre><p>上面的birth是可读写属性，而age就是一个只读属性，因为age可以根据birth和当前时间计算出来。</p><h3 id="多重继承"><a class="markdownIt-Anchor" href="#多重继承"></a> 多重继承</h3><p>继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能。<br />回忆一下Animal类层次的设计，假设我们要实现以下4种动物：</p><ul><li>Dog - 狗狗；</li><li>Bat - 蝙蝠；</li><li>Parrot - 鹦鹉；</li><li>Ostrich - 鸵鸟。</li></ul><p>如果按照哺乳动物和鸟类归类，我们可以设计出这样的类的层次：</p><p>但是如果按照“能跑”和“能飞”来归类，我们就应该设计出这样的类的层次：</p><p>如果要把上面的两种分类都包含进来，我们就得设计更多的层次：</p><ul><li>哺乳类：能跑的哺乳类，能飞的哺乳类；</li><li>鸟类：能跑的鸟类，能飞的鸟类。</li></ul><p>这么一来，类的层次就复杂了：</p><p>如果要再增加“宠物类”和“非宠物类”，这么搞下去，类的数量会呈指数增长，很明显这样设计是不行的。</p><p>正确的做法是采用多重继承。首先，主要的类层次仍按照哺乳类和鸟类设计：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">pass</span><span class="comment"># 大类:</span><span class="keyword">class</span> <span class="title class_">Mammal</span>(<span class="title class_ inherited__">Animal</span>):    <span class="keyword">pass</span><span class="keyword">class</span> <span class="title class_">Bird</span>(<span class="title class_ inherited__">Animal</span>):    <span class="keyword">pass</span><span class="comment"># 各种动物:</span><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Mammal</span>):    <span class="keyword">pass</span><span class="keyword">class</span> <span class="title class_">Bat</span>(<span class="title class_ inherited__">Mammal</span>):    <span class="keyword">pass</span><span class="keyword">class</span> <span class="title class_">Parrot</span>(<span class="title class_ inherited__">Bird</span>):    <span class="keyword">pass</span><span class="keyword">class</span> <span class="title class_">Ostrich</span>(<span class="title class_ inherited__">Bird</span>):    <span class="keyword">pass</span></code></pre><p>现在，我们要给动物再加上Runnable和Flyable的功能，只需要先定义好Runnable和Flyable的类：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Runnable</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;Running...&#x27;</span>)<span class="keyword">class</span> <span class="title class_">Flyable</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;Flying...&#x27;</span>)</code></pre><p>对于需要Runnable功能的动物，就多继承一个Runnable，例如Dog：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Dog</span>(Mammal, Runnable):    <span class="keyword">pass</span></code></pre><p>对于需要Flyable功能的动物，就多继承一个Flyable，例如Bat：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Bat</span>(Mammal, Flyable):    <span class="keyword">pass</span></code></pre><p>通过多重继承，一个子类就可以同时获得多个父类的所有功能。</p><h4 id="mixln设计"><a class="markdownIt-Anchor" href="#mixln设计"></a> Mixln设计</h4><p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。</p><p>为了更好地看出继承关系，我们把Runnable和Flyable改为RunnableMixIn和FlyableMixIn。类似的，你还可以定义出肉食动物CarnivorousMixIn和植食动物HerbivoresMixIn，让某个动物同时拥有好几个MixIn：<br />MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</p><p>Python自带的很多库也使用了MixIn。举个例子，Python自带了TCPServer和UDPServer这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由ForkingMixIn和ThreadingMixIn提供。通过组合，我们就可以创造出合适的服务来。</p><p>比如，编写一个多进程模式的TCP服务，定义如下：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">MyTCPServer</span>(TCPServer, ForkingMixIn):    <span class="keyword">pass</span></code></pre><p>编写一个多线程模式的UDP服务，定义如下：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">MyUDPServer</span>(UDPServer, ThreadingMixIn):    <span class="keyword">pass</span></code></pre><p>如果你打算搞一个更先进的协程模型，可以编写一个CoroutineMixIn：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">MyTCPServer</span>(TCPServer, CoroutineMixIn):    <span class="keyword">pass</span></code></pre><p>这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。</p><h4 id="多重继承排序原理"><a class="markdownIt-Anchor" href="#多重继承排序原理"></a> 多重继承排序原理</h4><p><strong>拓扑排序</strong></p><p>在图论中，拓扑排序(Topological Sorting) 是一个 有向无环图(DAG,Directed Acyclic Graph) 的所有顶点的线性序列。且该序列必须满足下面两个条件：</p><ul><li>每个顶点出现且只出现一次。</li><li>若存在一条从顶点A到顶点B的路径，那么在序列中顶点A出现在顶点B的前面。</li></ul><p>例如，下面这个图：</p><p>它是一个DAG图，那么如何写出它的拓扑顺序呢？这里说一种比较常用的方法：</p><ul><li>从DAG途中选择一个没有前驱(即入度为0)的顶点并输出</li><li>从图中删除该顶点和所有以它为起点的有向边。</li><li>重复1和2直到当前DAG图为空或当前途中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。</li></ul><p>于是，得到拓扑排序后的结果是{1,2,4,3,5}</p><hr /><p><strong>python多重继承</strong></p><pre><code class="highlight python"><span class="comment">#!/usr/bin/env python3</span><span class="comment"># -*- coding: utf-8 -*-</span><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;A foo&#x27;</span>)    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;A bar&#x27;</span>)<span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;B foo&#x27;</span>)    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;B bar&#x27;</span>)<span class="keyword">class</span> <span class="title class_">C1</span>(A,B):    <span class="keyword">pass</span><span class="keyword">class</span> <span class="title class_">C2</span>(A,B):    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;C2-bar&#x27;</span>)<span class="keyword">class</span> <span class="title class_">D</span>(C1,C2):    <span class="keyword">pass</span><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:    <span class="built_in">print</span>(D.__mro__)    d=D()    d.foo()    d.bar()</code></pre><p>首先，我们根据上面的继承关系构成一张图，如下</p><ul><li>找到入度为0的点，只有一个D，把D拿出来，把D相关的边剪掉</li><li>现在有两个入度为0的点(C1,C2)，取最左原则，拿C1，剪掉C1相关的边，这时候的排序是{D,C1}</li><li>现在我们看，入度为0的点(C2),拿C2,剪掉C2相关的边，这时候排序是{D,C1,C2}</li><li>接着看，入度为0的点(A,B),取最左原则，拿A，剪掉A相关的边，这时候的排序是{D,C1,C2,A}</li><li>继续，入度为0的点只有B，拿B，剪掉B相关的边，最后只剩下object</li><li>所以最后的排序是{D,C1,C2,A,B,object}</li></ul><p>我们执行上面的代码，发现print(D.mro)的结果也正是这样，而这也就是多重继承所使用的C3算法啦</p><pre><code class="highlight python">(&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.D&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.C1&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.C2&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.A&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.B&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;)A fooC2-bar</code></pre><p>为了进一步熟悉这个拓扑排序的方法，我们再来一张图，试试看排序结果是怎样的，它继承的内容是否如你所想</p><pre><code class="highlight python"><span class="comment">#!/usr/bin/env python3</span><span class="comment"># -*- coding: utf-8 -*-</span><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;A foo&#x27;</span>)    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;A bar&#x27;</span>)<span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;B foo&#x27;</span>)    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;B bar&#x27;</span>)<span class="keyword">class</span> <span class="title class_">C1</span>(<span class="title class_ inherited__">A</span>):    <span class="keyword">pass</span><span class="keyword">class</span> <span class="title class_">C2</span>(<span class="title class_ inherited__">B</span>):    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;C2-bar&#x27;</span>)<span class="keyword">class</span> <span class="title class_">D</span>(C1,C2):    <span class="keyword">pass</span><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:    <span class="built_in">print</span>(D.__mro__)    d=D()    d.foo()    d.bar()</code></pre><p>还是先根据继承关系构一个继承图</p><ul><li>找到入度为0的顶点，只有一个D，拿D，剪掉D相关的边</li><li>得到两个入度为0的顶点(C1,C2),根据最左原则，拿C1，剪掉C1相关的边，这时候序列为{D,C1}</li><li>接着看，入度为0的顶点有两个(A,C1),根据最左原则，拿A，剪掉A相关的边，这时候序列为{D,C1,A}</li><li>接着看，入度为0的顶点为C2,拿C2，剪掉C2相关的边，这时候序列为{D,C1,A,C2}</li><li>继续，入度为0的顶点为B，拿B，剪掉B相关的边，最后还有一个object</li><li>所以最后的序列为{D,C1,A,C2,B,object}</li></ul><p>最后，我们执行上面的代码，发现print(D.mro)的结果正如上面所计算的结果</p><pre><code class="highlight python">(&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.D&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.C1&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.A&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.C2&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.B&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;)A fooA bar</code></pre><blockquote><p><strong>python继承顺序遵循C3算法，只要在一个地方找到了所需的内容，就不再继续查找</strong></p></blockquote><h3 id="定制类"><a class="markdownIt-Anchor" href="#定制类"></a> 定制类</h3><p>看到类似__slots__这种形如__xxx__的变量或者函数名就要注意，这些在Python中是有特殊用途的。</p><p>__slots__我们已经知道怎么用了，<strong>len</strong>()方法我们也知道是为了能让class作用于len()函数。</p><p>除此之外，Python的class中还有许多这样有特殊用途的函数，可以帮助我们定制类。</p><h4 id="__str__和__repr__"><a class="markdownIt-Anchor" href="#__str__和__repr__"></a> <strong>__str__和__repr__</strong></h4><p>我们先定义一个Student类，打印一个实例：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):<span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):<span class="meta">... </span>        <span class="variable language_">self</span>.name = name...<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Student(<span class="string">&#x27;Michael&#x27;</span>))&lt;__main__.Student <span class="built_in">object</span> at <span class="number">0x109afb190</span>&gt;</code></pre><p>打印出一堆&lt;<strong>main</strong>.Student object at 0x109afb190&gt;，不好看。</p><p>怎么才能打印得好看呢？只需要定义好__str__()方法，返回一个好看的字符串就可以了：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):<span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):<span class="meta">... </span>        <span class="variable language_">self</span>.name = name<span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):<span class="meta">... </span>        <span class="keyword">return</span> <span class="string">&#x27;Student object (name: %s)&#x27;</span> % <span class="variable language_">self</span>.name...<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Student(<span class="string">&#x27;Michael&#x27;</span>))Student <span class="built_in">object</span> (name: Michael)</code></pre><p>这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。</p><p>但是细心的朋友会发现直接敲变量不用print，打印出来的实例还是不好看：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">&#x27;Michael&#x27;</span>)<span class="meta">&gt;&gt;&gt; </span>s&lt;__main__.Student <span class="built_in">object</span> at <span class="number">0x109afb310</span>&gt;</code></pre><p>这是因为直接显示变量调用的不是__str__()，而是__repr__()，两者的区别是__str__()返回用户看到的字符串，而__repr__()返回程序开发者看到的字符串，也就是说，__repr__()是为调试服务的。</p><p>解决办法是再定义一个__repr__()。但是通常__str__()和__repr__()代码都是一样的，所以，有个偷懒的写法：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):        <span class="variable language_">self</span>.name = name    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):        <span class="keyword">return</span> <span class="string">&#x27;Student object (name=%s)&#x27;</span> % <span class="variable language_">self</span>.name    __repr__ = __str__</code></pre><hr /><h4 id="__iter__"><a class="markdownIt-Anchor" href="#__iter__"></a> <strong>__iter__</strong></h4><p>如果一个类想被用于for … in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。</p><p>我们以斐波那契数列为例，写一个Fib类，可以作用于for循环：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Fib</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):        <span class="variable language_">self</span>.a, <span class="variable language_">self</span>.b = <span class="number">0</span>, <span class="number">1</span> <span class="comment"># 初始化两个计数器a，b</span>    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):        <span class="keyword">return</span> <span class="variable language_">self</span> <span class="comment"># 实例本身就是迭代对象，故返回自己</span>    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):        <span class="variable language_">self</span>.a, <span class="variable language_">self</span>.b = <span class="variable language_">self</span>.b, <span class="variable language_">self</span>.a + <span class="variable language_">self</span>.b <span class="comment"># 计算下一个值</span>        <span class="keyword">if</span> <span class="variable language_">self</span>.a &gt; <span class="number">100000</span>: <span class="comment"># 退出循环的条件</span>            <span class="keyword">raise</span> StopIteration()        <span class="keyword">return</span> <span class="variable language_">self</span>.a <span class="comment"># 返回下一个值</span></code></pre><p>现在，试试把Fib实例作用于for循环：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> Fib():<span class="meta">... </span>    <span class="built_in">print</span>(n)...<span class="number">1</span><span class="number">1</span><span class="number">2</span><span class="number">3</span><span class="number">5</span>...<span class="number">46368</span><span class="number">75025</span></code></pre><h4 id="__getitem__"><a class="markdownIt-Anchor" href="#__getitem__"></a> <strong>__getitem__</strong></h4><p>Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>Fib()[<span class="number">5</span>]Traceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;TypeError: <span class="string">&#x27;Fib&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support indexing</code></pre><p>要表现得像list那样按照下标取出元素，需要实现__getitem__()方法：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Fib</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, n</span>):        a, b = <span class="number">1</span>, <span class="number">1</span>        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):            a, b = b, a + b        <span class="keyword">return</span> a</code></pre><p>现在，就可以按下标访问数列的任意一项了：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = Fib()<span class="meta">&gt;&gt;&gt; </span>f[<span class="number">0</span>]<span class="number">1</span><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">1</span>]<span class="number">1</span><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">2</span>]<span class="number">2</span><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">3</span>]<span class="number">3</span><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">10</span>]<span class="number">89</span><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">100</span>]<span class="number">573147844013817084101</span></code></pre><p>对于Fib却报错。原因是__getitem__()传入的参数可能是一个int，也可能是一个切片对象slice，所以要做判断：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Fib</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, n</span>):        <span class="keyword">if</span> <span class="built_in">isinstance</span>(n, <span class="built_in">int</span>): <span class="comment"># n是索引</span>            a, b = <span class="number">1</span>, <span class="number">1</span>            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):                a, b = b, a + b            <span class="keyword">return</span> a        <span class="keyword">if</span> <span class="built_in">isinstance</span>(n, <span class="built_in">slice</span>): <span class="comment"># n是切片</span>            start = n.start            stop = n.stop            <span class="keyword">if</span> start <span class="keyword">is</span> <span class="literal">None</span>:                start = <span class="number">0</span>            a, b = <span class="number">1</span>, <span class="number">1</span>            L = []            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(stop):                <span class="keyword">if</span> x &gt;= start:                    L.append(a)                a, b = b, a + b            <span class="keyword">return</span> L</code></pre><p>现在试试Fib的切片：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = Fib()<span class="meta">&gt;&gt;&gt; </span>f[<span class="number">0</span>:<span class="number">5</span>][<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]<span class="meta">&gt;&gt;&gt; </span>f[:<span class="number">10</span>][<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>]</code></pre><p>但是没有对step参数作处理：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f[:<span class="number">10</span>:<span class="number">2</span>][<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>]</code></pre><p>也没有对负数作处理，所以，要正确实现一个__getitem__()还是有很多工作要做的。</p><p>此外，如果把对象看成dict，<strong>getitem</strong>()的参数也可能是一个可以作key的object，例如str。</p><p>与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋值。最后，还有一个__delitem__()方法，用于删除某个元素。</p><p>总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。</p><h4 id="__getattr__"><a class="markdownIt-Anchor" href="#__getattr__"></a> __getattr__</h4><p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义Student类：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):        <span class="variable language_">self</span>.name = <span class="string">&#x27;Michael&#x27;</span></code></pre><p>调用name属性，没问题，但是，调用不存在的score属性，就有问题了：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s = Student()<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.name)Michael<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.score)Traceback (most recent call last):  ...AttributeError: <span class="string">&#x27;Student&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;score&#x27;</span></code></pre><p>错误信息很清楚地告诉我们，没有找到score这个attribute。</p><p>要避免这个错误，除了可以加上一个score属性外，Python还有另一个机制，那就是写一个__getattr__()方法，动态返回一个属性。修改如下：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):        <span class="variable language_">self</span>.name = <span class="string">&#x27;Michael&#x27;</span>    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):        <span class="keyword">if</span> attr==<span class="string">&#x27;score&#x27;</span>:            <span class="keyword">return</span> <span class="number">99</span></code></pre><p>当调用不存在的属性时，比如score，Python解释器会试图调用__getattr__(self, ‘score’)来尝试获得属性，这样，我们就有机会返回score的值：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s = Student()<span class="meta">&gt;&gt;&gt; </span>s.name<span class="string">&#x27;Michael&#x27;</span><span class="meta">&gt;&gt;&gt; </span>s.score<span class="number">99</span></code></pre><p>返回函数也是完全可以的：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):        <span class="keyword">if</span> attr==<span class="string">&#x27;age&#x27;</span>:            <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="number">25</span></code></pre><p>只是调用方式要变为：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s.age()<span class="number">25</span></code></pre><p>注意，只有在没有找到属性的情况下，才调用__getattr__，已有的属性，比如name，不会在__getattr__中查找。</p><p>此外，注意到任意调用如s.abc都会返回None，这是因为我们定义的__getattr__默认返回就是None。要让class只响应特定的几个属性，我们就要按照约定，抛出AttributeError的错误：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):        <span class="keyword">if</span> attr==<span class="string">&#x27;age&#x27;</span>:            <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="number">25</span>        <span class="keyword">raise</span> AttributeError(<span class="string">&#x27;\&#x27;Student\&#x27; object has no attribute \&#x27;%s\&#x27;&#x27;</span> % attr)</code></pre><p>这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。</p><p>这种完全动态调用的特性有什么实际作用呢？作用就是，可以针对完全动态的情况作调用。<br />举个例子：</p><p>现在很多网站都搞REST API，比如新浪微博、豆瓣啥的，调用API的URL类似：</p><pre><code class="highlight python">http://api.server/user/friendshttp://api.server/user/timeline/<span class="built_in">list</span></code></pre><p>如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。</p><p>利用完全动态的__getattr__，我们可以写出一个链式调用：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Chain</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, path=<span class="string">&#x27;&#x27;</span></span>):        <span class="variable language_">self</span>._path = path    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, path</span>):        <span class="keyword">return</span> Chain(<span class="string">&#x27;%s/%s&#x27;</span> % (<span class="variable language_">self</span>._path, path))    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):        <span class="keyword">return</span> <span class="variable language_">self</span>._path    __repr__ = __str__</code></pre><p>试试：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>Chain().status.user.timeline.<span class="built_in">list</span><span class="string">&#x27;/status/user/timeline/list&#x27;</span></code></pre><p>这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变！</p><p>还有些REST API会把参数放到URL中，比如GitHub的API：</p><pre><code class="highlight python">GET /users/:user/repos</code></pre><p>调用时，需要把:user替换为实际用户名。如果我们能写出这样的链式调用：</p><pre><code class="highlight python">Chain().users(<span class="string">&#x27;michael&#x27;</span>).repos</code></pre><p>就可以非常方便地调用API了。有兴趣的童鞋可以试试写出来。</p><ul><li>注意.users(‘michael’)分为了两部，先.users调用getattr方法，然后返回Chain的实例，chain()又调用call方法，再返回一个Chain实例。</li></ul><p>代码如下：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Chain</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, path=<span class="string">&#x27;&#x27;</span></span>):       <span class="variable language_">self</span>.__path = path   <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, path</span>):       <span class="keyword">return</span> Chain(<span class="string">&#x27;%s/%s&#x27;</span> % (<span class="variable language_">self</span>.__path, path))      <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, path</span>):       <span class="keyword">return</span> Chain(<span class="string">&#x27;%s/%s&#x27;</span> % (<span class="variable language_">self</span>.__path, path))   <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):       <span class="keyword">return</span> <span class="variable language_">self</span>.__path   __repr__ = __str__   <span class="built_in">print</span>(Chain().users(<span class="string">&#x27;michael&#x27;</span>).repos) <span class="comment"># /users/michael/repos</span></code></pre><h4 id="__call__"><a class="markdownIt-Anchor" href="#__call__"></a> __call__</h4><p>一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用instance.method()来调用。能不能直接在实例本身上调用呢？在Python中，答案是肯定的。</p><p>任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用。请看示例：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):        <span class="variable language_">self</span>.name = name    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;My name is %s.&#x27;</span> % <span class="variable language_">self</span>.name)</code></pre><p>调用方式如下：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">&#x27;Michael&#x27;</span>)<span class="meta">&gt;&gt;&gt; </span>s() <span class="comment"># self参数不要传入</span>My name <span class="keyword">is</span> Michael.</code></pre><p>__call__()还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。</p><p>如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。</p><p>那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个Callable对象，比如函数和我们上面定义的带有__call__()的类实例：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(Student())<span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(<span class="built_in">max</span>)<span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])<span class="literal">False</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(<span class="literal">None</span>)<span class="literal">False</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(<span class="string">&#x27;str&#x27;</span>)<span class="literal">False</span></code></pre><p>通过callable()函数，我们就可以判断一个对象是否是“可调用”对象。</p><h3 id="使用枚举类"><a class="markdownIt-Anchor" href="#使用枚举类"></a> 使用枚举类</h3><p>当我们需要定义常量时，一个办法是用大写变量通过整数来定义，例如月份：</p><pre><code class="highlight python">JAN = <span class="number">1</span>FEB = <span class="number">2</span>MAR = <span class="number">3</span>...NOV = <span class="number">11</span>DEC = <span class="number">12</span></code></pre><p>好处是简单，缺点是类型是int，并且仍然是变量。</p><p>更好的方法是为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了Enum类来实现这个功能：</p><pre><code class="highlight python"><span class="keyword">from</span> enum <span class="keyword">import</span> EnumMonth = Enum(<span class="string">&#x27;Month&#x27;</span>, (<span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Mar&#x27;</span>, <span class="string">&#x27;Apr&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;Jun&#x27;</span>, <span class="string">&#x27;Jul&#x27;</span>, <span class="string">&#x27;Aug&#x27;</span>, <span class="string">&#x27;Sep&#x27;</span>, <span class="string">&#x27;Oct&#x27;</span>, <span class="string">&#x27;Nov&#x27;</span>, <span class="string">&#x27;Dec&#x27;</span>))</code></pre><p>这样我们就获得了Month类型的枚举类，可以直接使用Month.Jan来引用一个常量，或者枚举它的所有成员：</p><pre><code class="highlight python"><span class="keyword">for</span> name, member <span class="keyword">in</span> Month.__members__.items():    <span class="built_in">print</span>(name, <span class="string">&#x27;=&gt;&#x27;</span>, member, <span class="string">&#x27;,&#x27;</span>, member.value)    <span class="comment">#输出</span>Jan =&gt; Month.Jan , <span class="number">1</span>Feb =&gt; Month.Feb , <span class="number">2</span>Mar =&gt; Month.Mar , <span class="number">3</span>Apr =&gt; Month.Apr , <span class="number">4</span>May =&gt; Month.May , <span class="number">5</span>Jun =&gt; Month.Jun , <span class="number">6</span>Jul =&gt; Month.Jul , <span class="number">7</span>Aug =&gt; Month.Aug , <span class="number">8</span>Sep =&gt; Month.Sep , <span class="number">9</span>Oct =&gt; Month.Oct , <span class="number">10</span>Nov =&gt; Month.Nov , <span class="number">11</span>Dec =&gt; Month.Dec , <span class="number">12</span></code></pre><blockquote><p><strong>value属性则是自动赋给成员的int常量，默认从1开始计数</strong>。</p></blockquote><p>如果需要更精确地控制枚举类型，<strong>可以从Enum派生出自定义类</strong>：</p><pre><code class="highlight python"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique<span class="meta">@unique</span><span class="keyword">class</span> <span class="title class_">Weekday</span>(<span class="title class_ inherited__">Enum</span>):    Sun = <span class="number">0</span> <span class="comment"># Sun的value被设定为0</span>    Mon = <span class="number">1</span>    Tue = <span class="number">2</span>    Wed = <span class="number">3</span>    Thu = <span class="number">4</span>    Fri = <span class="number">5</span>    Sat = <span class="number">6</span></code></pre><p>@<strong>unique装饰器可以帮助我们检查保证没有重复值</strong>。</p><p>访问这些枚举类型可以有若干种方法：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>day1 = Weekday.Mon<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(day1)Weekday.Mon<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Weekday.Tue)Weekday.Tue<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Weekday[<span class="string">&#x27;Tue&#x27;</span>])Weekday.Tue<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Weekday.Tue.value)<span class="number">2</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(day1 == Weekday.Mon)<span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(day1 == Weekday.Tue)<span class="literal">False</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Weekday(<span class="number">1</span>))Weekday.Mon<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(day1 == Weekday(<span class="number">1</span>))<span class="literal">True</span><span class="meta">&gt;&gt;&gt; </span>Weekday(<span class="number">7</span>)Traceback (most recent call last):  ...ValueError: <span class="number">7</span> <span class="keyword">is</span> <span class="keyword">not</span> a valid Weekday<span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, member <span class="keyword">in</span> Weekday.__members__.items():<span class="meta">... </span>    <span class="built_in">print</span>(name, <span class="string">&#x27;=&gt;&#x27;</span>, member)...</code></pre><p>输出：</p><pre><code class="highlight plaintext">Sun =&gt; Weekday.SunMon =&gt; Weekday.MonTue =&gt; Weekday.TueWed =&gt; Weekday.WedThu =&gt; Weekday.ThuFri =&gt; Weekday.FriSat =&gt; Weekday.Sat</code></pre><p>可见，既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量。</p><h3 id="使用元类"><a class="markdownIt-Anchor" href="#使用元类"></a> 使用元类</h3><h4 id="type"><a class="markdownIt-Anchor" href="#type"></a> type()</h4><p>比方说我们要定义一个Hello的class，就写一个hello.py模块：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Hello</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self, name=<span class="string">&#x27;world&#x27;</span></span>):        <span class="built_in">print</span>(<span class="string">&#x27;Hello, %s.&#x27;</span> % name)</code></pre><p>当Python解释器载入hello模块时，就会依次执行该模块的所有语句，执行结果就是动态创建出一个Hello的class对象，测试如下：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> hello <span class="keyword">import</span> Hello<span class="meta">&gt;&gt;&gt; </span>h = Hello()<span class="meta">&gt;&gt;&gt; </span>h.hello()Hello, world.<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(Hello))&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(h))&lt;<span class="keyword">class</span> <span class="string">&#x27;hello.Hello&#x27;</span>&gt;</code></pre><p>type()函数可以查看一个类型或变量的类型，Hello是一个class，它的类型就是type，而h是一个实例，它的类型就是class Hello。</p><p>我们说class的定义是运行时动态创建的，而创建class的方法就是使用type()函数。<br />type()函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过type()函数创建出Hello类，而无需通过class Hello(object)…的定义：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fn</span>(<span class="params">self, name=<span class="string">&#x27;world&#x27;</span></span>): <span class="comment"># 先定义函数</span><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;Hello, %s.&#x27;</span> % name)...<span class="meta">&gt;&gt;&gt; </span>Hello = <span class="built_in">type</span>(<span class="string">&#x27;Hello&#x27;</span>, (<span class="built_in">object</span>,), <span class="built_in">dict</span>(hello=fn)) <span class="comment"># 创建Hello class</span><span class="meta">&gt;&gt;&gt; </span>h = Hello()<span class="meta">&gt;&gt;&gt; </span>h.hello()Hello, world.<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(Hello))&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(h))&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Hello&#x27;</span>&gt;</code></pre><p>要创建一个class对象，<strong>type()函数依次传入3个参数</strong>：</p><ul><li>class的名称；</li><li>继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；</li><li>class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。</li></ul><p>通过<strong>type()函数创建的类和直接写class是完全一样的</strong>，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。</p><p>正常情况下，我们都用class Xxx…来定义类，但是，type()函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。</p><h4 id="metaclass"><a class="markdownIt-Anchor" href="#metaclass"></a> metaclass</h4><p>除了使用type()动态创建类以外，要<strong>控制类的创建行为，还可以使用metaclass</strong>。</p><p>metaclass，直译为<strong>元类</strong>，简单的解释就是：</p><ul><li>当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。</li></ul><p>但是如果我们想创建出类呢？那就必须根据metaclass创建出类，所以：先定义metaclass，然后创建类。</p><p>连接起来就是：先定义metaclass，就可以创建类，最后创建实例。</p><p>所以，metaclass允许你创建类或者修改类。换句话说，<strong>你可以把类看成是metaclass创建出来的“实例”</strong>。</p><p>metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用metaclass的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到。</p><p>我们先看一个简单的例子，这个metaclass可以给我们自定义的MyList增加一个add方法：</p><p>定义ListMetaclass，按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass：</p><pre><code class="highlight python"><span class="comment"># metaclass是类的模板，所以必须从`type`类型派生：class ListMetaclass(type):</span>    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, attrs</span>):        attrs[<span class="string">&#x27;add&#x27;</span>] = <span class="keyword">lambda</span> <span class="variable language_">self</span>, value: <span class="variable language_">self</span>.append(value)        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, name, bases, attrs)</code></pre><p>我们先看一个简单的例子，这个metaclass可以给我们自定义的MyList增加一个add方法：</p><p>定义ListMetaclass，<strong>按照默认习惯，metaclass的类名总是以Metaclass结尾</strong>，以便清楚地表示这是一个metaclass：</p><pre><code class="highlight python"><span class="comment"># metaclass是类的模板，所以必须从`type`类型派生：</span><span class="keyword">class</span> <span class="title class_">ListMetaclass</span>(<span class="title class_ inherited__">type</span>):    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, attrs</span>):        attrs[<span class="string">&#x27;add&#x27;</span>] = <span class="keyword">lambda</span> <span class="variable language_">self</span>, value: <span class="variable language_">self</span>.append(value)        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, name, bases, attrs)</code></pre><p>有了ListMetaclass，我们在定义类的时候还要指示使用ListMetaclass来定制类，传入关键字参数metaclass：</p><p>class MyList(list, metaclass=ListMetaclass):<br />pass</p><p>当我们传入关键字参数metaclass时，魔术就生效了，它指示Python解释器在创建MyList时，要通过ListMetaclass.__new__()来创建，在此，<strong>我们可以修改类的定义</strong>，比如，加上新的方法，然后，返回修改后的定义。</p><p>__new__()方法<strong>接收到的参数</strong>依次是：</p><ol><li>当前准备创建的类的对象；</li><li>类的名字；</li><li>类继承的父类集合；</li><li>类的方法集合。</li></ol><p>测试一下MyList是否可以调用add()方法：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L = MyList()<span class="meta">&gt;&gt;&gt; </span>L.add(<span class="number">1</span>)&gt;&gt; L[<span class="number">1</span>]</code></pre><p>而普通的list没有add()方法：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L2 = <span class="built_in">list</span>()<span class="meta">&gt;&gt;&gt; </span>L2.add(<span class="number">1</span>)Traceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;AttributeError: <span class="string">&#x27;list&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;add&#x27;</span></code></pre><p>动态修改有什么意义？直接在MyList定义中写上add()方法不是更简单吗？正常情况下，确实应该直接写，通过metaclass修改纯属变态。</p><p>但是，总会遇到需要通过metaclass修改类定义的。ORM就是一个典型的例子。</p><h4 id="定义orm"><a class="markdownIt-Anchor" href="#定义orm"></a> 定义ORM</h4><p>ORM全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。</p><p>要编写一个ORM框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。</p><p>让我们来尝试编写一个ORM框架。</p><p>编写底层模块的第一步，就是先把调用接口写出来。比如，使用者如果使用这个ORM框架，想定义一个User类来操作对应的数据库表User，我们期待他写出这样的代码：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">Model</span>):    <span class="comment"># 定义类的属性到列的映射：</span>    <span class="built_in">id</span> = IntegerField(<span class="string">&#x27;id&#x27;</span>)    name = StringField(<span class="string">&#x27;username&#x27;</span>)    email = StringField(<span class="string">&#x27;email&#x27;</span>)    password = StringField(<span class="string">&#x27;password&#x27;</span>)<span class="comment"># 创建一个实例：</span>u = User(<span class="built_in">id</span>=<span class="number">12345</span>, name=<span class="string">&#x27;Michael&#x27;</span>, email=<span class="string">&#x27;test@orm.org&#x27;</span>, password=<span class="string">&#x27;my-pwd&#x27;</span>)<span class="comment"># 保存到数据库：</span>u.save()</code></pre><p>其中，父类Model和属性类型StringField、IntegerField是由ORM框架提供的，剩下的魔术方法比如save()全部由metaclass自动完成。虽然metaclass的编写会比较复杂，但ORM的使用者用起来却异常简单。</p><p>现在，我们就按上面的接口来实现该ORM。</p><p>首先来定义Field类，它负责保存数据库表的字段名和字段类型：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Field</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, column_type</span>):        <span class="variable language_">self</span>.name = name        <span class="variable language_">self</span>.column_type = column_type    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):        <span class="keyword">return</span> <span class="string">&#x27;&lt;%s:%s&gt;&#x27;</span> % (<span class="variable language_">self</span>.__class__.__name__, <span class="variable language_">self</span>.name)</code></pre><p>在Field的基础上，进一步定义各种类型的Field，比如StringField，IntegerField等等：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">StringField</span>(<span class="title class_ inherited__">Field</span>):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):        <span class="built_in">super</span>(StringField, <span class="variable language_">self</span>).__init__(name, <span class="string">&#x27;varchar(100)&#x27;</span>)<span class="keyword">class</span> <span class="title class_">IntegerField</span>(<span class="title class_ inherited__">Field</span>):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):        <span class="built_in">super</span>(IntegerField, <span class="variable language_">self</span>).__init__(name, <span class="string">&#x27;bigint&#x27;</span>)</code></pre><p>下一步，就是编写最复杂的ModelMetaclass了：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">ModelMetaclass</span>(<span class="title class_ inherited__">type</span>):    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, attrs</span>):        <span class="keyword">if</span> name==<span class="string">&#x27;Model&#x27;</span>:            <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, name, bases, attrs)        <span class="built_in">print</span>(<span class="string">&#x27;Found model: %s&#x27;</span> % name)        mappings = <span class="built_in">dict</span>()        <span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.items():            <span class="keyword">if</span> <span class="built_in">isinstance</span>(v, Field):                <span class="built_in">print</span>(<span class="string">&#x27;Found mapping: %s ==&gt; %s&#x27;</span> % (k, v))                mappings[k] = v        <span class="keyword">for</span> k <span class="keyword">in</span> mappings.keys():            attrs.pop(k)        attrs[<span class="string">&#x27;__mappings__&#x27;</span>] = mappings <span class="comment"># 保存属性和列的映射关系</span>        attrs[<span class="string">&#x27;__table__&#x27;</span>] = name <span class="comment"># 假设表名和类名一致</span>        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, name, bases, attrs)</code></pre><p>以及基类Model：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Model</span>(<span class="built_in">dict</span>, metaclass=ModelMetaclass):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kw</span>):        <span class="built_in">super</span>(Model, <span class="variable language_">self</span>).__init__(**kw)    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, key</span>):        <span class="keyword">try</span>:            <span class="keyword">return</span> <span class="variable language_">self</span>[key]        <span class="keyword">except</span> KeyError:            <span class="keyword">raise</span> AttributeError(<span class="string">r&quot;&#x27;Model&#x27; object has no attribute &#x27;%s&#x27;&quot;</span> % key)    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, key, value</span>):        <span class="variable language_">self</span>[key] = value    <span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self</span>):        fields = []        params = []        args = []        <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="variable language_">self</span>.__mappings__.items():            fields.append(v.name)            params.append(<span class="string">&#x27;?&#x27;</span>)            args.append(<span class="built_in">getattr</span>(<span class="variable language_">self</span>, k, <span class="literal">None</span>))        sql = <span class="string">&#x27;insert into %s (%s) values (%s)&#x27;</span> % (<span class="variable language_">self</span>.__table__, <span class="string">&#x27;,&#x27;</span>.join(fields), <span class="string">&#x27;,&#x27;</span>.join(params))        <span class="built_in">print</span>(<span class="string">&#x27;SQL: %s&#x27;</span> % sql)        <span class="built_in">print</span>(<span class="string">&#x27;ARGS: %s&#x27;</span> % <span class="built_in">str</span>(args))</code></pre><p>当用户定义一个class User(Model)时，Python解释器首先在当前类User的定义中查找metaclass，如果没有找到，就继续在父类Model中查找metaclass，找到了，就使用Model中定义的metaclass的ModelMetaclass来创建User类，也就是说，metaclass可以隐式地继承到子类，但子类自己却感觉不到。</p><p>在ModelMetaclass中，一共做了几件事情：</p><ol><li>排除掉对Model类的修改；</li><li>在当前类（比如User）中查找定义的类的所有属性，如果找到一个Field属性，就把它保存到一个__mappings__的dict中，同时从类属性中删除该Field属性，否则，容易造成运行时错误（实例的属性会遮盖类的同名属性）；</li><li>把表名保存到__table__中，这里简化为表名默认为类名。</li></ol><p>在Model类中，就可以定义各种操作数据库的方法，比如save()，delete()，find()，update等等。</p><p>我们实现了save()方法，把一个实例保存到数据库中。因为有表名，属性到字段的映射和属性值的集合，就可以构造出INSERT语句。</p><p>编写代码试试：</p><pre><code class="highlight python">u = User(<span class="built_in">id</span>=<span class="number">12345</span>, name=<span class="string">&#x27;Michael&#x27;</span>, email=<span class="string">&#x27;test@orm.org&#x27;</span>, password=<span class="string">&#x27;my-pwd&#x27;</span>)u.save()</code></pre><p>输出如下：</p><pre><code class="highlight python">Found model: UserFound mapping: email ==&gt; &lt;StringField:email&gt;Found mapping: password ==&gt; &lt;StringField:password&gt;Found mapping: <span class="built_in">id</span> ==&gt; &lt;IntegerField:uid&gt;Found mapping: name ==&gt; &lt;StringField:username&gt;SQL: insert into User (password,email,username,<span class="built_in">id</span>) values (?,?,?,?)ARGS: [<span class="string">&#x27;my-pwd&#x27;</span>, <span class="string">&#x27;test@orm.org&#x27;</span>, <span class="string">&#x27;Michael&#x27;</span>, <span class="number">12345</span>]</code></pre><p>可以看到，save()方法已经打印出了可执行的SQL语句，以及参数列表，只需要真正连接到数据库，执行该SQL语句，就可以完成真正的功能。</p><p>不到100行代码，我们就通过metaclass实现了一个精简的ORM框架，是不是非常简单？</p><h2 id="错误调试测试"><a class="markdownIt-Anchor" href="#错误调试测试"></a> 错误/调试/测试</h2><p>在程序运行过程中，总会遇到各种各样的错误。</p><p>有的错误是程序编写有问题造成的，比如本来应该输出整数结果输出了字符串，这种错误我们通常称之为bug，bug是必须修复的。</p><p>有的错误是用户输入造成的，比如让用户输入email地址，结果得到一个空字符串，这种错误可以通过检查用户输入来做相应的处理。</p><p>还有一类错误是完全无法在程序运行过程中预测的，比如写入文件的时候，磁盘满了，写不进去了，或者从网络抓取数据，网络突然断掉了。这类错误也称为异常，在程序中通常是必须处理的，否则，程序会因为各种问题终止并退出。</p><p>Python内置了一套异常处理机制，来帮助我们进行错误处理。</p><p>此外，我们也需要跟踪程序的执行，查看变量的值是否正确，这个过程称为调试。Python的pdb可以让我们以单步方式执行代码。</p><p>最后，编写测试也很重要。有了良好的测试，就可以在程序修改后反复运行，确保程序输出符合我们编写的测试。</p><h3 id="错误处理"><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h3><p>在程序运行的过程中，如果发生了错误，可以事先约定返回一个错误代码，这样，就可以知道是否有错，以及出错的原因。在操作系统提供的调用中，返回错误码非常常见。比如打开文件的函数open()，成功时返回文件描述符（就是一个整数），出错时返回-1。</p><p>用错误码来表示是否出错十分不便，因为函数本身应该返回的正常结果和错误码混在一起，造成调用者必须用大量的代码来判断是否出错：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">foo</span>():    r = some_function()    <span class="keyword">if</span> r==(-<span class="number">1</span>):        <span class="keyword">return</span> (-<span class="number">1</span>)    <span class="comment"># do something</span>    <span class="keyword">return</span> r<span class="keyword">def</span> <span class="title function_">bar</span>():    r = foo()    <span class="keyword">if</span> r==(-<span class="number">1</span>):        <span class="built_in">print</span>(<span class="string">&#x27;Error&#x27;</span>)    <span class="keyword">else</span>:        <span class="keyword">pass</span></code></pre><p>一旦出错，还要一级一级上报，直到某个函数可以处理该错误（比如，给用户输出一个错误信息）。</p><p>所以高级语言通常都内置了一套try…except…finally…的错误处理机制，Python也不例外。</p><h4 id="try"><a class="markdownIt-Anchor" href="#try"></a> try</h4><p>让我们用一个例子来看看try的机制：</p><pre><code class="highlight python"><span class="keyword">try</span>:    <span class="built_in">print</span>(<span class="string">&#x27;try...&#x27;</span>)    r = <span class="number">10</span> / <span class="number">0</span>    <span class="built_in">print</span>(<span class="string">&#x27;result:&#x27;</span>, r)<span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:    <span class="built_in">print</span>(<span class="string">&#x27;except:&#x27;</span>, e)<span class="keyword">finally</span>:    <span class="built_in">print</span>(<span class="string">&#x27;finally...&#x27;</span>)<span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</code></pre><p>当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果<strong>执行出错</strong>，则<strong>后续代码不会继续执行</strong>，而是<strong>直接跳转</strong>至错误处理代码，即<strong>except语句块</strong>，执行完except后，如果有finally语句块，则<strong>最后执行finally语句块</strong>，至此，执行完毕。</p><p>上面的代码在计算10 / 0时会产生一个除法运算错误：</p><pre><code class="highlight python"><span class="keyword">try</span>...<span class="keyword">except</span>: division by zero<span class="keyword">finally</span>...END</code></pre><p>从输出可以看到，当错误发生时，后续语句print(‘result:’, r)不会被执行，except由于捕获到ZeroDivisionError，因此被执行。最后，finally语句被执行。然后，程序继续按照流程往下走。</p><p>如果把除数0改成2，则执行结果如下：</p><pre><code class="highlight python"><span class="keyword">try</span>...result: <span class="number">5</span><span class="keyword">finally</span>...END</code></pre><p>由于没有错误发生，所以except语句块不会被执行，但是finally如果有，则一定会被执行（可以没有finally语句）。</p><p>你还可以猜测，错误应该有很多种类，如果发生了不同类型的错误，应该由不同的except语句块处理。没错，<strong>可以有多个except来捕获不同类型的错误</strong>：</p><pre><code class="highlight python"><span class="keyword">try</span>:    <span class="built_in">print</span>(<span class="string">&#x27;try...&#x27;</span>)    r = <span class="number">10</span> / <span class="built_in">int</span>(<span class="string">&#x27;a&#x27;</span>)    <span class="built_in">print</span>(<span class="string">&#x27;result:&#x27;</span>, r)<span class="keyword">except</span> ValueError <span class="keyword">as</span> e:    <span class="built_in">print</span>(<span class="string">&#x27;ValueError:&#x27;</span>, e)<span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:    <span class="built_in">print</span>(<span class="string">&#x27;ZeroDivisionError:&#x27;</span>, e)<span class="keyword">finally</span>:    <span class="built_in">print</span>(<span class="string">&#x27;finally...&#x27;</span>)<span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</code></pre><p>int()函数可能会抛出ValueError，所以我们用一个except捕获ValueError，用另一个except捕获ZeroDivisionError。</p><p>此外，<strong>如果没有错误发生，可以在except语句块后面加一个else</strong>，当没有错误发生时，会自动执行else语句：</p><pre><code class="highlight python"><span class="keyword">try</span>:    <span class="built_in">print</span>(<span class="string">&#x27;try...&#x27;</span>)    r = <span class="number">10</span> / <span class="built_in">int</span>(<span class="string">&#x27;2&#x27;</span>)    <span class="built_in">print</span>(<span class="string">&#x27;result:&#x27;</span>, r)<span class="keyword">except</span> ValueError <span class="keyword">as</span> e:    <span class="built_in">print</span>(<span class="string">&#x27;ValueError:&#x27;</span>, e)<span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:    <span class="built_in">print</span>(<span class="string">&#x27;ZeroDivisionError:&#x27;</span>, e)<span class="keyword">else</span>:    <span class="built_in">print</span>(<span class="string">&#x27;no error!&#x27;</span>)<span class="keyword">finally</span>:    <span class="built_in">print</span>(<span class="string">&#x27;finally...&#x27;</span>)<span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</code></pre><p>Python的错误其实也是class，所有的错误类型都继承自<strong>BaseException</strong>，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。比如：</p><pre><code class="highlight python"><span class="keyword">try</span>:    foo()<span class="keyword">except</span> ValueError <span class="keyword">as</span> e:    <span class="built_in">print</span>(<span class="string">&#x27;ValueError&#x27;</span>)<span class="keyword">except</span> UnicodeError <span class="keyword">as</span> e:    <span class="built_in">print</span>(<span class="string">&#x27;UnicodeError&#x27;</span>)</code></pre><p>第二个except永远也捕获不到UnicodeError，因为UnicodeError是ValueError的子类，如果有，也被第一个except给捕获了。</p><p>Python所有的错误都是从BaseException类派生的，常见的错误类型和继承关系看这里：</p><p><a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy">https://docs.python.org/3/library/exceptions.html#exception-hierarchy</a></p><p><strong>继承树结构如下所示</strong></p><p>BaseException</p><ul><li>SystemExit</li><li>KeyboardInterrupt</li><li>GeneratorExit</li><li>Exception<ul><li>StopIteration</li><li>StopAsyncIteration</li><li>ArithmeticError<ul><li>FloatingPointError</li><li>OverflowError</li><li>ZeroDivisionError</li></ul></li><li>AssertionError</li><li>AttributeError</li><li>BufferError</li><li>EOFError</li><li>ImportError<ul><li>ModuleNotFoundError</li></ul></li><li>LookupError<ul><li>IndexError</li><li>KeyError</li></ul></li><li>MemoryError</li><li>NameError<ul><li>UnboundLocalError</li></ul></li><li>OSError<ul><li>BlockingIOError</li><li>ChildProcessError</li><li>ConnectionError<ul><li>BrokenPipeError</li><li>ConnectionAbortedError</li><li>ConnectionRefusedError</li><li>ConnectionResetError</li></ul></li><li>FileExistsError</li><li>FileNotFoundError</li><li>InterruptedError</li><li>IsADirectoryError</li><li>NotADirectoryError</li><li>PermissionError</li><li>ProcessLookupError</li><li>TimeoutError</li></ul></li><li>ReferenceError</li><li>RuntimeError<ul><li>NotImplementedError</li><li>RecursionError</li></ul></li><li>SyntaxError<ul><li>IndentationError<ul><li>TabError</li></ul></li></ul></li><li>SystemError</li><li>TypeError</li><li>ValueError<ul><li>UnicodeError<ul><li>UnicodeDecodeError</li><li>UnicodeEncodeError</li><li>UnicodeTranslateError</li></ul></li></ul></li><li>Warning<ul><li>DeprecationWarning</li><li>PendingDeprecationWarning</li><li>RuntimeWarning</li><li>SyntaxWarning</li><li>UserWarning</li><li>FutureWarning</li><li>ImportWarning</li><li>UnicodeWarning</li><li>BytesWarning</li><li>ResourceWarning<br />使用try…except捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数main()调用bar()，bar()调用foo()，结果foo()出错了，这时，只要main()捕获到了，就可以处理：</li></ul></li></ul></li></ul><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):    <span class="keyword">return</span> <span class="number">10</span> / <span class="built_in">int</span>(s)<span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">s</span>):    <span class="keyword">return</span> foo(s) * <span class="number">2</span><span class="keyword">def</span> <span class="title function_">main</span>():    <span class="keyword">try</span>:        bar(<span class="string">&#x27;0&#x27;</span>)    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:        <span class="built_in">print</span>(<span class="string">&#x27;Error:&#x27;</span>, e)    <span class="keyword">finally</span>:        <span class="built_in">print</span>(<span class="string">&#x27;finally...&#x27;</span>)</code></pre><p>也就是说，<strong>不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以</strong>了。这样一来，就大大减少了写try…except…finally的麻烦。</p><h4 id="调用栈"><a class="markdownIt-Anchor" href="#调用栈"></a> 调用栈</h4><p>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。<a href="http://xn--err-o99fu40ea.py">来看看err.py</a>：</p><pre><code class="highlight python"><span class="comment"># err.py:</span><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):    <span class="keyword">return</span> <span class="number">10</span> / <span class="built_in">int</span>(s)<span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">s</span>):    <span class="keyword">return</span> foo(s) * <span class="number">2</span><span class="keyword">def</span> <span class="title function_">main</span>():    bar(<span class="string">&#x27;0&#x27;</span>)main()</code></pre><p>执行，结果如下：</p><pre><code class="highlight python">$ python3 err.pyTraceback (most recent call last):  File <span class="string">&quot;err.py&quot;</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;    main()  File <span class="string">&quot;err.py&quot;</span>, line <span class="number">9</span>, <span class="keyword">in</span> main    bar(<span class="string">&#x27;0&#x27;</span>)  File <span class="string">&quot;err.py&quot;</span>, line <span class="number">6</span>, <span class="keyword">in</span> bar    <span class="keyword">return</span> foo(s) * <span class="number">2</span>  File <span class="string">&quot;err.py&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> foo    <span class="keyword">return</span> <span class="number">10</span> / <span class="built_in">int</span>(s)ZeroDivisionError: division by zero</code></pre><p>出错并不可怕，可怕的是不知道哪里出错了。解读错误信息是定位错误的关键。我们从上往下可以看到整个错误的调用函数链：</p><p>错误信息第1行：</p><pre><code class="highlight python">Traceback (most recent call last):</code></pre><p>告诉我们这是错误的跟踪信息。</p><p>第2~3行：</p><pre><code class="highlight python">File <span class="string">&quot;err.py&quot;</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;  main()</code></pre><p>调用main()出错了，在代码文件err.py的第11行代码，但原因是第9行：</p><pre><code class="highlight python">File <span class="string">&quot;err.py&quot;</span>, line <span class="number">9</span>, <span class="keyword">in</span> main  bar(<span class="string">&#x27;0&#x27;</span>)</code></pre><p>调用bar(‘0’)出错了，在代码文件err.py的第9行代码，但原因是第6行：</p><pre><code class="highlight python">File <span class="string">&quot;err.py&quot;</span>, line <span class="number">6</span>, <span class="keyword">in</span> bar  <span class="keyword">return</span> foo(s) * <span class="number">2</span></code></pre><p>原因是return foo(s) * 2这个语句出错了，但这还不是最终原因，继续往下看：</p><pre><code class="highlight python">File <span class="string">&quot;err.py&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> foo  <span class="keyword">return</span> <span class="number">10</span> / <span class="built_in">int</span>(s)</code></pre><p>原因是return 10 / int(s)这个语句出错了，这是错误产生的源头，因为下面打印了：</p><pre><code class="highlight python">ZeroDivisionError: integer division <span class="keyword">or</span> modulo by zero</code></pre><p>根据错误类型ZeroDivisionError，我们判断，int(s)本身并没有出错，但是int(s)返回0，在计算10 / 0时出错，至此，找到错误源头</p><blockquote><p><strong>出错的时候，一定要分析错误的调用栈信息，才能定位错误的位置</strong>。</p></blockquote><h4 id="记录错误"><a class="markdownIt-Anchor" href="#记录错误"></a> 记录错误</h4><p>如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。</p><p>Python内置的<strong>logging模块</strong>可以非常容易地记录错误信息：</p><pre><code class="highlight python"><span class="comment"># err_logging.py</span><span class="keyword">import</span> logging<span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):    <span class="keyword">return</span> <span class="number">10</span> / <span class="built_in">int</span>(s)<span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">s</span>):    <span class="keyword">return</span> foo(s) * <span class="number">2</span><span class="keyword">def</span> <span class="title function_">main</span>():    <span class="keyword">try</span>:        bar(<span class="string">&#x27;0&#x27;</span>)    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:        logging.exception(e)main()<span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</code></pre><p>同样是出错，但程序打印完错误信息后会继续执行，并正常退出：</p><pre><code class="highlight python">$ python3 err_logging.pyERROR:root:division by zeroTraceback (most recent call last):  File <span class="string">&quot;err_logging.py&quot;</span>, line <span class="number">13</span>, <span class="keyword">in</span> main    bar(<span class="string">&#x27;0&#x27;</span>)  File <span class="string">&quot;err_logging.py&quot;</span>, line <span class="number">9</span>, <span class="keyword">in</span> bar    <span class="keyword">return</span> foo(s) * <span class="number">2</span>  File <span class="string">&quot;err_logging.py&quot;</span>, line <span class="number">6</span>, <span class="keyword">in</span> foo    <span class="keyword">return</span> <span class="number">10</span> / <span class="built_in">int</span>(s)ZeroDivisionError: division by zeroEND</code></pre><p>通过配置，logging还可以把错误记录到日志文件里，方便事后排查。</p><h4 id="抛出错误raise"><a class="markdownIt-Anchor" href="#抛出错误raise"></a> 抛出错误raise</h4><p>因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。</p><p>如果要抛出错误，首先根据需要，可以定义一个错误的class，选择好继承关系，然后，<strong>用raise语句抛出一个错误的实例</strong>：</p><pre><code class="highlight python"><span class="comment"># err_raise.py</span><span class="keyword">class</span> <span class="title class_">FooError</span>(<span class="title class_ inherited__">ValueError</span>):    <span class="keyword">pass</span><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):    n = <span class="built_in">int</span>(s)    <span class="keyword">if</span> n==<span class="number">0</span>:        <span class="keyword">raise</span> FooError(<span class="string">&#x27;invalid value: %s&#x27;</span> % s)    <span class="keyword">return</span> <span class="number">10</span> / nfoo(<span class="string">&#x27;0&#x27;</span>)</code></pre><p>执行，可以最后跟踪到我们自己定义的错误：</p><pre><code class="highlight python">$ python3 err_raise.py Traceback (most recent call last):  File <span class="string">&quot;err_throw.py&quot;</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;    foo(<span class="string">&#x27;0&#x27;</span>)  File <span class="string">&quot;err_throw.py&quot;</span>, line <span class="number">8</span>, <span class="keyword">in</span> foo    <span class="keyword">raise</span> FooError(<span class="string">&#x27;invalid value: %s&#x27;</span> % s)__main__.FooError: invalid value: <span class="number">0</span></code></pre><p>只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如ValueError，TypeError），尽量使用Python内置的错误类型。</p><p>最后，我们来看另一种错误处理的方式：</p><pre><code class="highlight python"><span class="comment"># err_reraise.py</span><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):    n = <span class="built_in">int</span>(s)    <span class="keyword">if</span> n==<span class="number">0</span>:        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;invalid value: %s&#x27;</span> % s)    <span class="keyword">return</span> <span class="number">10</span> / n<span class="keyword">def</span> <span class="title function_">bar</span>():    <span class="keyword">try</span>:        foo(<span class="string">&#x27;0&#x27;</span>)    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:        <span class="built_in">print</span>(<span class="string">&#x27;ValueError!&#x27;</span>)        <span class="keyword">raise</span>bar()</code></pre><p>在bar()函数中，我们明明已经捕获了错误，但是，打印一个ValueError!后，又把错误通过raise语句抛出去了，这不有病么？</p><p>其实这种错误处理方式不但没病，而且相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。好比一个员工处理不了一个问题时，就把问题抛给他的老板，如果他的老板也处理不了，就一直往上抛，最终会抛给CEO去处理。</p><p>raise语句如果不带参数，就会把当前错误原样抛出。此外，在except中raise一个Error，还可以把一种类型的错误转化成另一种类型：</p><pre><code class="highlight python"><span class="keyword">try</span>:    <span class="number">10</span> / <span class="number">0</span><span class="keyword">except</span> ZeroDivisionError:    <span class="keyword">raise</span> ValueError(<span class="string">&#x27;input error!&#x27;</span>)</code></pre><p>只要是合理的转换逻辑就可以，但是，决不应该把一个IOError转换成毫不相干的ValueError。</p><h3 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h3><p>程序能一次写完并正常运行的概率很小，基本不超过1%。总会有各种各样的bug需要修正。有的bug很简单，看看错误信息就知道，有的bug很复杂，我们需要知道出错时，哪些变量的值是正确的，哪些变量的值是错误的，因此，需要一整套调试程序的手段来修复bug。</p><p>第一种方法简单直接粗暴有效，就是用print()把可能有问题的变量打印出来看看：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):    n = <span class="built_in">int</span>(s)    <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt; n = %d&#x27;</span> % n)    <span class="keyword">return</span> <span class="number">10</span> / n<span class="keyword">def</span> <span class="title function_">main</span>():    foo(<span class="string">&#x27;0&#x27;</span>)main()</code></pre><p>执行后在输出中查找打印的变量值：</p><pre><code class="highlight python">$ python err.py<span class="meta">&gt;&gt;&gt; </span>n = <span class="number">0</span>Traceback (most recent call last):  ...ZeroDivisionError: integer division <span class="keyword">or</span> modulo by zero</code></pre><p>用print()最大的坏处是将来还得删掉它，想想程序里到处都是print()，运行结果也会包含很多垃圾信息。所以，我们又有第二种方法。</p><h4 id="断言"><a class="markdownIt-Anchor" href="#断言"></a> 断言</h4><p>凡是用print()来辅助查看的地方，都可以用断言（assert）来替代：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):    n = <span class="built_in">int</span>(s)    <span class="keyword">assert</span> n != <span class="number">0</span>, <span class="string">&#x27;n is zero!&#x27;</span>    <span class="keyword">return</span> <span class="number">10</span> / n<span class="keyword">def</span> <span class="title function_">main</span>():    foo(<span class="string">&#x27;0&#x27;</span>)</code></pre><p><strong>assert的意思是，表达式n != 0应该是True，否则，根据程序运行的逻辑，后面的代码肯定会出错</strong>。</p><p>如果断言失败，assert语句本身就会抛出AssertionError：</p><pre><code class="highlight python">$ python err.pyTraceback (most recent call last):  ...AssertionError: n <span class="keyword">is</span> zero!</code></pre><p>程序中如果到处充斥着assert，和print()相比也好不到哪去。不过，启动Python解释器时可以用-O参数来关闭assert：</p><pre><code class="highlight python">$ python -O err.pyTraceback (most recent call last):  ...ZeroDivisionError: division by zero</code></pre><blockquote><p>注意：<strong>断言的开关“-O”是英文大写字母O，不是数字0</strong>。</p></blockquote><p><strong>关闭后，你可以把所有的assert语句当成pass来看</strong>。</p><h4 id="logging"><a class="markdownIt-Anchor" href="#logging"></a> logging</h4><p>把print()替换为logging是第3种方式，和assert比，<strong>logging不会抛出错误，而且可以输出到文件</strong>：</p><pre><code class="highlight python"><span class="keyword">import</span> loggings = <span class="string">&#x27;0&#x27;</span>n = <span class="built_in">int</span>(s)logging.info(<span class="string">&#x27;n = %d&#x27;</span> % n)<span class="built_in">print</span>(<span class="number">10</span> / n)</code></pre><p><a href="http://logging.info">logging.info</a>()就可以输出一段文本。运行，发现除了ZeroDivisionError，没有任何信息。怎么回事？</p><p>别急，在import logging之后添加一行配置再试试：</p><pre><code class="highlight python"><span class="keyword">import</span> logginglogging.basicConfig(level=logging.INFO)</code></pre><p>看到输出了：</p><pre><code class="highlight python">$ python err.pyINFO:root:n = <span class="number">0</span>Traceback (most recent call last):  File <span class="string">&quot;err.py&quot;</span>, line <span class="number">8</span>, <span class="keyword">in</span> &lt;module&gt;    <span class="built_in">print</span>(<span class="number">10</span> / n)ZeroDivisionError: division by zero</code></pre><p>这就是logging的好处，它允许你<strong>指定记录信息的级别</strong>，有<strong>debug，info，warning，error</strong>等几个级别，当我们指定level=INFO时，logging.debug就不起作用了。同理，指定level=WARNING后，debug和info就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</p><p>logging的另一个好处是<strong>通过简单的配置，一条语句可以同时输出到不同的地方</strong>，比如console和文件。</p><h4 id="pdb"><a class="markdownIt-Anchor" href="#pdb"></a> pdb</h4><p>第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。我们先准备好程序：</p><pre><code class="highlight python"><span class="comment"># err.py</span>s = <span class="string">&#x27;0&#x27;</span>n = <span class="built_in">int</span>(s)<span class="built_in">print</span>(<span class="number">10</span> / n)</code></pre><p>然后启动：</p><pre><code class="highlight python">$ python -m pdb err.py&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(<span class="number">2</span>)&lt;module&gt;()-&gt; s = <span class="string">&#x27;0&#x27;</span></code></pre><p>以参数-m pdb启动后，pdb定位到下一步要执行的代码-&gt; s = ‘0’。输入命令l来查看代码：</p><pre><code class="highlight python">(Pdb) l  <span class="number">1</span>     <span class="comment"># err.py</span>  <span class="number">2</span>  -&gt; s = <span class="string">&#x27;0&#x27;</span>  <span class="number">3</span>     n = <span class="built_in">int</span>(s)  <span class="number">4</span>     <span class="built_in">print</span>(<span class="number">10</span> / n)</code></pre><p>输入命令n可以单步执行代码：</p><pre><code class="highlight python">(Pdb) n&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(<span class="number">3</span>)&lt;module&gt;()-&gt; n = <span class="built_in">int</span>(s)(Pdb) n&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(<span class="number">4</span>)&lt;module&gt;()-&gt; <span class="built_in">print</span>(<span class="number">10</span> / n)</code></pre><p>任何时候都可以输入命令p 变量名来查看变量：</p><pre><code class="highlight python">(Pdb) p s<span class="string">&#x27;0&#x27;</span>(Pdb) p n<span class="number">0</span></code></pre><p>输入命令q结束调试，退出程序：</p><pre><code class="highlight python">(Pdb) q</code></pre><p>这种通过pdb在命令行调试的方法理论上是万能的，但实在是太麻烦了，如果有一千行代码，要运行到第999行得敲多少命令啊。还好，我们还有另一种调试方法。</p><h4 id="pdbset_trace"><a class="markdownIt-Anchor" href="#pdbset_trace"></a> pdb.set_trace()</h4><p>这个方法也是用pdb，但是不需要单步执行，我们只需要import pdb，然后，在可能出错的地方放一个pdb.set_trace()，就可以设置一个断点：</p><pre><code class="highlight python"><span class="comment"># err.py</span><span class="keyword">import</span> pdbs = <span class="string">&#x27;0&#x27;</span>n = <span class="built_in">int</span>(s)pdb.set_trace() <span class="comment"># 运行到这里会自动暂停</span><span class="built_in">print</span>(<span class="number">10</span> / n)</code></pre><p>运行代码，程序会自动在pdb.set_trace()暂停并进入pdb调试环境，可以用命令p查看变量，或者用命令c继续运行：</p><pre><code class="highlight python">$ python err.py &gt; /Users/michael/Github/learn-python3/samples/debug/err.py(<span class="number">7</span>)&lt;module&gt;()-&gt; <span class="built_in">print</span>(<span class="number">10</span> / n)(Pdb) p n<span class="number">0</span>(Pdb) cTraceback (most recent call last):  File <span class="string">&quot;err.py&quot;</span>, line <span class="number">7</span>, <span class="keyword">in</span> &lt;module&gt;    <span class="built_in">print</span>(<span class="number">10</span> / n)ZeroDivisionError: division by zero</code></pre><p>这个方式比直接启动pdb单步调试效率要高很多，但也高不到哪去。</p><h4 id="ide"><a class="markdownIt-Anchor" href="#ide"></a> IDE</h4><p>如果要比较爽地设置断点、单步执行，就需要一个支持调试功能的IDE。目前比较好的Python IDE有：</p><p>Visual Studio Code：<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>，需要安装Python插件。</p><p>PyCharm：<a href="http://www.jetbrains.com/pycharm/">http://www.jetbrains.com/pycharm/</a></p><p>另外，Eclipse加上pydev插件也可以调试Python程序。</p><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><p>如果你听说过“测试驱动开发”（TDD：Test-Driven Development），单元测试就不陌生。</p><p>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。</p><p>比如对函数abs()，我们可以编写出以下几个测试用例：</p><ul><li>输入正数，比如1、1.2、0.99，期待返回值与输入相同；</li><li>输入负数，比如-1、-1.2、-0.99，期待返回值与输入相反；</li><li>输入0，期待返回0；</li><li>输入非数值类型，比如None、[]、{}，期待抛出TypeError。</li></ul><p>把上面的测试用例放到一个测试模块里，就是一个完整的单元测试。</p><p>如果单元测试通过，说明我们测试的这个函数能够正常工作。如果单元测试不通过，要么函数有bug，要么测试条件输入不正确，总之，需要修复使单元测试能够通过。</p><p>单元测试通过后有什么意义呢？如果我们对abs()函数代码做了修改，只需要再跑一遍单元测试，如果通过，说明我们的修改不会对abs()函数原有的行为造成影响，如果测试不通过，说明我们的修改与原有行为不一致，要么修改代码，要么修改测试。</p><p>这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。</p><p>我们来编写一个Dict类，这个类的行为和dict一致，但是可以通过属性来访问，用起来就像下面这样：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>d = <span class="type">Dict</span>(a=<span class="number">1</span>, b=<span class="number">2</span>)<span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;a&#x27;</span>]<span class="number">1</span><span class="meta">&gt;&gt;&gt; </span>d.a<span class="number">1</span></code></pre><p>mydict.py代码如下：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Dict</span>(<span class="title class_ inherited__">dict</span>):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kw</span>):        <span class="built_in">super</span>().__init__(**kw)    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, key</span>):        <span class="keyword">try</span>:            <span class="keyword">return</span> <span class="variable language_">self</span>[key]        <span class="keyword">except</span> KeyError:            <span class="keyword">raise</span> AttributeError(<span class="string">r&quot;&#x27;Dict&#x27; object has no attribute &#x27;%s&#x27;&quot;</span> % key)    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, key, value</span>):        <span class="variable language_">self</span>[key] = value</code></pre><p>为了编写单元测试，我们需要引入Python自带的unittest模块，编写mydict_test.py如下：</p><pre><code class="highlight python"><span class="keyword">import</span> unittest<span class="keyword">from</span> mydict <span class="keyword">import</span> <span class="type">Dict</span><span class="keyword">class</span> <span class="title class_">TestDict</span>(unittest.TestCase):    <span class="keyword">def</span> <span class="title function_">test_init</span>(<span class="params">self</span>):        d = <span class="type">Dict</span>(a=<span class="number">1</span>, b=<span class="string">&#x27;test&#x27;</span>)        <span class="variable language_">self</span>.assertEqual(d.a, <span class="number">1</span>)        <span class="variable language_">self</span>.assertEqual(d.b, <span class="string">&#x27;test&#x27;</span>)        <span class="variable language_">self</span>.assertTrue(<span class="built_in">isinstance</span>(d, <span class="built_in">dict</span>))    <span class="keyword">def</span> <span class="title function_">test_key</span>(<span class="params">self</span>):        d = <span class="type">Dict</span>()        d[<span class="string">&#x27;key&#x27;</span>] = <span class="string">&#x27;value&#x27;</span>        <span class="variable language_">self</span>.assertEqual(d.key, <span class="string">&#x27;value&#x27;</span>)    <span class="keyword">def</span> <span class="title function_">test_attr</span>(<span class="params">self</span>):        d = <span class="type">Dict</span>()        d.key = <span class="string">&#x27;value&#x27;</span>        <span class="variable language_">self</span>.assertTrue(<span class="string">&#x27;key&#x27;</span> <span class="keyword">in</span> d)        <span class="variable language_">self</span>.assertEqual(d[<span class="string">&#x27;key&#x27;</span>], <span class="string">&#x27;value&#x27;</span>)    <span class="keyword">def</span> <span class="title function_">test_keyerror</span>(<span class="params">self</span>):        d = <span class="type">Dict</span>()        <span class="keyword">with</span> <span class="variable language_">self</span>.assertRaises(KeyError):            value = d[<span class="string">&#x27;empty&#x27;</span>]    <span class="keyword">def</span> <span class="title function_">test_attrerror</span>(<span class="params">self</span>):        d = <span class="type">Dict</span>()        <span class="keyword">with</span> <span class="variable language_">self</span>.assertRaises(AttributeError):            value = d.empty</code></pre><p>编写单元测试时，我们需要编写一个测试类，从unittest.TestCase继承。</p><p><strong>以test开头的方法就是测试方法</strong>，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。</p><p>对每一类测试都需要编写一个test_xxx()方法。由于unittest.TestCase提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是assertEqual()：</p><pre><code class="highlight python"><span class="variable language_">self</span>.assertEqual(<span class="built_in">abs</span>(-<span class="number">1</span>), <span class="number">1</span>) <span class="comment"># 断言函数返回的结果与1相等</span></code></pre><p>另一种重要的断言就是期待抛出指定类型的Error，比如通过d[‘empty’]访问不存在的key时，断言会抛出KeyError：</p><pre><code class="highlight python"><span class="keyword">with</span> <span class="variable language_">self</span>.assertRaises(KeyError):    value = d[<span class="string">&#x27;empty&#x27;</span>]</code></pre><p>而通过d.empty访问不存在的key时，我们期待抛出AttributeError：</p><pre><code class="highlight python"><span class="keyword">with</span> <span class="variable language_">self</span>.assertRaises(AttributeError):    value = d.empty</code></pre><p><strong>运行单元测试</strong></p><p>一旦编写好单元测试，我们就可以运行单元测试。最简单的运行方式是在mydict_test.py的最后加上两行代码：</p><pre><code class="highlight python"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:    unittest.main()</code></pre><p>这样就可以把mydict_test.py当做正常的python脚本运行：</p><pre><code class="highlight python">$ python mydict_test.py</code></pre><p>另一种方法是在命令行通过参数-m unittest直接运行单元测试：</p><pre><code class="highlight python">$ python -m unittest mydict_test.....----------------------------------------------------------------------Ran <span class="number">5</span> tests <span class="keyword">in</span> <span class="number">0.000</span>sOK</code></pre><p>这是推荐的做法，因为这样可以一次批量运行很多单元测试，并且，有很多工具可以自动来运行这些单元测试。</p><h4 id="setup与teardown"><a class="markdownIt-Anchor" href="#setup与teardown"></a> setUp与tearDown</h4><p>可以在单元测试中编写两个特殊的setUp()和tearDown()方法。这两个方法会<strong>分别在每调用一个测试方法的前后分别被执行</strong>。</p><p>setUp()和tearDown()方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在setUp()方法中连接数据库，在tearDown()方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码：</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">TestDict</span>(unittest.TestCase):    <span class="keyword">def</span> <span class="title function_">setUp</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;setUp...&#x27;</span>)    <span class="keyword">def</span> <span class="title function_">tearDown</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;tearDown...&#x27;</span>)</code></pre><p>可以再次运行测试看看每个测试方法调用前后是否会打印出setUp…和tearDown…。</p><h3 id="文档测试"><a class="markdownIt-Anchor" href="#文档测试"></a> 文档测试</h3><p>如果你经常阅读Python的官方文档，可以看到很多文档都有示例代码。比如re模块就带了很多示例代码：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re<span class="meta">&gt;&gt;&gt; </span>m = re.search(<span class="string">&#x27;(?&lt;=abc)def&#x27;</span>, <span class="string">&#x27;abcdef&#x27;</span>)<span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">0</span>)<span class="string">&#x27;def&#x27;</span></code></pre><p>可以把这些示例代码在Python的交互式环境下输入并执行，结果与文档中的示例代码显示的一致。</p><p>这些代码与其他说明可以写在注释中，然后，由一些工具来自动生成文档。既然这些代码本身就可以粘贴出来直接运行，那么，可不可以自动执行写在注释中的这些代码呢？</p><p>答案是肯定的。</p><p>当我们编写注释时，如果写上这样的注释：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">abs</span>(<span class="params">n</span>):    <span class="string">&#x27;&#x27;&#x27;</span><span class="string">    Function to get absolute value of number.</span><span class="string">    </span><span class="string">    Example:</span><span class="string">    </span><span class="string">    &gt;&gt;&gt; abs(1)</span><span class="string">    1</span><span class="string">    &gt;&gt;&gt; abs(-1)</span><span class="string">    1</span><span class="string">    &gt;&gt;&gt; abs(0)</span><span class="string">    0</span><span class="string">    &#x27;&#x27;&#x27;</span>    <span class="keyword">return</span> n <span class="keyword">if</span> n &gt;= <span class="number">0</span> <span class="keyword">else</span> (-n)</code></pre><p>无疑更明确地告诉函数的调用者该函数的期望输入和输出。</p><p>并且，<strong>Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试</strong>。</p><p>doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。<strong>只有测试异常的时候，可以用…表示中间一大段烦人的输出</strong>。</p><p>让我们用doctest来测试上次编写的Dict类：</p><pre><code class="highlight python"><span class="comment"># mydict2.py</span><span class="keyword">class</span> <span class="title class_">Dict</span>(<span class="title class_ inherited__">dict</span>):    <span class="string">&#x27;&#x27;&#x27;</span><span class="string">    Simple dict but also support access as x.y style.</span><span class="string"></span><span class="string">    &gt;&gt;&gt; d1 = Dict()</span><span class="string">    &gt;&gt;&gt; d1[&#x27;x&#x27;] = 100</span><span class="string">    &gt;&gt;&gt; d1.x</span><span class="string">    100</span><span class="string">    &gt;&gt;&gt; d1.y = 200</span><span class="string">    &gt;&gt;&gt; d1[&#x27;y&#x27;]</span><span class="string">    200</span><span class="string">    &gt;&gt;&gt; d2 = Dict(a=1, b=2, c=&#x27;3&#x27;)</span><span class="string">    &gt;&gt;&gt; d2.c</span><span class="string">    &#x27;3&#x27;</span><span class="string">    &gt;&gt;&gt; d2[&#x27;empty&#x27;]</span><span class="string">    Traceback (most recent call last):</span><span class="string">        ...</span><span class="string">    KeyError: &#x27;empty&#x27;</span><span class="string">    &gt;&gt;&gt; d2.empty</span><span class="string">    Traceback (most recent call last):</span><span class="string">        ...</span><span class="string">    AttributeError: &#x27;Dict&#x27; object has no attribute &#x27;empty&#x27;</span><span class="string">    &#x27;&#x27;&#x27;</span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kw</span>):        <span class="built_in">super</span>(<span class="type">Dict</span>, <span class="variable language_">self</span>).__init__(**kw)    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, key</span>):        <span class="keyword">try</span>:            <span class="keyword">return</span> <span class="variable language_">self</span>[key]        <span class="keyword">except</span> KeyError:            <span class="keyword">raise</span> AttributeError(<span class="string">r&quot;&#x27;Dict&#x27; object has no attribute &#x27;%s&#x27;&quot;</span> % key)    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, key, value</span>):        <span class="variable language_">self</span>[key] = value<span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:    <span class="keyword">import</span> doctest    doctest.testmod()</code></pre><p>运行python <a href="http://mydict2.py">mydict2.py</a>：</p><pre><code class="highlight python">$ python mydict2.py</code></pre><p>什么输出也没有。这说明我们编写的doctest运行都是正确的。如果程序有问题，比如把__getattr__()方法注释掉，再运行就会报错：</p><pre><code class="highlight python">$ python mydict2.py**********************************************************************File <span class="string">&quot;/Users/michael/Github/learn-python3/samples/debug/mydict2.py&quot;</span>, line <span class="number">10</span>, <span class="keyword">in</span> __main__.<span class="type">Dict</span>Failed example:    d1.xException raised:    Traceback (most recent call last):      ...    AttributeError: <span class="string">&#x27;Dict&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;x&#x27;</span>**********************************************************************File <span class="string">&quot;/Users/michael/Github/learn-python3/samples/debug/mydict2.py&quot;</span>, line <span class="number">16</span>, <span class="keyword">in</span> __main__.<span class="type">Dict</span>Failed example:    d2.cException raised:    Traceback (most recent call last):      ...    AttributeError: <span class="string">&#x27;Dict&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;c&#x27;</span>**********************************************************************<span class="number">1</span> items had failures:   <span class="number">2</span> of   <span class="number">9</span> <span class="keyword">in</span> __main__.<span class="type">Dict</span>***Test Failed*** <span class="number">2</span> failures.</code></pre><p>注意到最后3行代码。当模块正常导入时，doctest不会被执行。只有在命令行直接运行时，才执行doctest。所以，不必担心doctest会在非测试环境下执行。</p><h2 id="io编程"><a class="markdownIt-Anchor" href="#io编程"></a> IO编程</h2><p>IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。</p><p>比如你打开浏览器，访问新浪首页，浏览器这个程序就需要通过网络IO获取新浪的网页。浏览器首先会发送数据给新浪服务器，告诉它我想要首页的HTML，这个动作是往外发数据，叫Output，随后新浪服务器把网页发过来，这个动作是从外面接收数据，叫Input。所以，通常，程序完成IO操作会有Input和Output两个数据流。当然也有只用一个的情况，比如，从磁盘读取文件到内存，就只有Input操作，反过来，把数据写到磁盘文件里，就只是一个Output操作。</p><p>IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。</p><p>由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法：</p><ul><li><p>第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；</p></li><li><p>另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。</p></li></ul><blockquote><p><strong>同步和异步的区别就在于是否等待IO执行的结果</strong>。</p></blockquote><blockquote><p>好比你去麦当劳点餐，你说“来个汉堡”，服务员告诉你，对不起，汉堡要现做，需要等5分钟，于是你站在收银台前面等了5分钟，拿到汉堡再去逛商场，这是<strong>同步IO</strong>。<br />你说“来个汉堡”，服务员告诉你，汉堡需要等5分钟，你可以先去逛商场，等做好了，我们再通知你，这样你可以立刻去干别的事情（逛商场），这是<strong>异步IO</strong>。</p></blockquote><p>很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步IO的复杂度远远高于同步IO。</p><p>操作IO的能力都是由操作系统提供的，每一种编程语言都会把操作系统提供的低级C接口封装起来方便使用，Python也不例外。我们后面会详细讨论Python的IO编程接口。</p><h3 id="文件读写"><a class="markdownIt-Anchor" href="#文件读写"></a> 文件读写</h3><p>读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。</p><p>读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。</p><h4 id="读文件"><a class="markdownIt-Anchor" href="#读文件"></a> 读文件</h4><p><strong>读文件open()</strong></p><p>要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符：</p><ul><li><strong>标示符’r’表示读</strong>，这样，我们就成功地打开了一个文件。</li></ul><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</code></pre><p>如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f=<span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/notfound.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)Traceback (most recent call last):  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;FileNotFoundError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">&#x27;/Users/michael/notfound.txt&#x27;</span></code></pre><p><strong>read()</strong></p><p>如果文件打开成功，接下来，<strong>调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示</strong>：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f.read()<span class="string">&#x27;Hello, world!&#x27;</span></code></pre><p>调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，<strong>可以反复调用read(size)方法</strong>，每次最多读取size个字节的内容。</p><p>另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</p><p>如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：</p><pre><code class="highlight python"><span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():    <span class="built_in">print</span>(line.strip()) <span class="comment"># 把末尾的&#x27;\n&#x27;删掉</span></code></pre><p><strong>close()</strong></p><p>最后一步是<strong>调用close()方法关闭文件</strong>。文件使用完毕后<strong>必须关闭</strong>，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：</p><pre><code class="highlight python">f.close()</code></pre><p>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现：</p><pre><code class="highlight python"><span class="keyword">try</span>:    f = <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)    <span class="built_in">print</span>(f.read())<span class="keyword">finally</span>:    <span class="keyword">if</span> f:        f.close()</code></pre><p><strong>with语句</strong></p><p>但是每次都这么写实在太繁琐，所以，Python引入了<strong>with语句</strong>来自动帮我们调用close()方法：</p><pre><code class="highlight python"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:    <span class="built_in">print</span>(f.read())</code></pre><blockquote><p>这和前面的try … finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。</p></blockquote><p>调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</p><p><strong>如果文件很小，read()一次性读取最方便</strong>；如果<strong>不能确定文件大小，反复调用read(size)比较保险</strong>；如果是<strong>配置文件，调用readlines()最方便</strong>：</p><pre><code class="highlight python"><span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():    <span class="built_in">print</span>(line.strip()) <span class="comment"># 把末尾的&#x27;\n&#x27;删掉</span></code></pre><hr /><p><strong>file-like Object</strong></p><p>像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。</p><p>StringIO就是在内存中创建的file-like Object，常用作临时缓冲。</p><hr /><p><strong>二进制文件</strong></p><p>前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)<span class="meta">&gt;&gt;&gt; </span>f.read()<span class="string">b&#x27;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&#x27;</span> <span class="comment"># 十六进制表示的字节</span></code></pre><hr /><p><strong>字符编码</strong></p><p>要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/gbk.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;gbk&#x27;</span>)<span class="meta">&gt;&gt;&gt; </span>f.read()<span class="string">&#x27;测试&#x27;</span></code></pre><p>遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个<strong>errors参数，表示如果遇到编码错误后如何处理</strong>。最简单的方式是直接忽略：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/gbk.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;gbk&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)</code></pre><h4 id="写文件"><a class="markdownIt-Anchor" href="#写文件"></a> 写文件</h4><p>写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符’w’或者’wb’表示写文本文件或写二进制文件：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)<span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27;Hello, world!&#x27;</span>)<span class="meta">&gt;&gt;&gt; </span>f.close()</code></pre><p>你可以反复调用write()来写入文件，但是<strong>务必要调用f.close()来关闭文件</strong>。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用with语句来得保险：</p><pre><code class="highlight python"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:    f.write(<span class="string">&#x27;Hello, world!&#x27;</span>)</code></pre><p>要写入特定编码的文本文件，请给open()函数传入<strong>encoding参数，将字符串自动转换成指定编码</strong>。</p><p>细心的童鞋会发现，以’w’模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？<strong>可以传入’a’以追加</strong>（append）模式写入。</p><h3 id="stringio和bytesio"><a class="markdownIt-Anchor" href="#stringio和bytesio"></a> StringIO和BytesIO</h3><h4 id="stringio"><a class="markdownIt-Anchor" href="#stringio"></a> StringIO</h4><p>很多时候，数据读写不一定是文件，也可以在内存中读写。</p><p>StringIO顾名思义就是在内存中读写str。</p><p>要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO<span class="meta">&gt;&gt;&gt; </span>f = StringIO()<span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27;hello&#x27;</span>)<span class="number">5</span><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27; &#x27;</span>)<span class="number">1</span><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27;world!&#x27;</span>)<span class="number">6</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(f.getvalue())hello world!</code></pre><blockquote><p><strong>getvalue()方法用于获得写入后的str</strong>。</p></blockquote><p>要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO<span class="meta">&gt;&gt;&gt; </span>f = StringIO(<span class="string">&#x27;Hello!\nHi!\nGoodbye!&#x27;</span>)<span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:<span class="meta">... </span>    s = f.readline()<span class="meta">... </span>    <span class="keyword">if</span> s == <span class="string">&#x27;&#x27;</span>:<span class="meta">... </span>        <span class="keyword">break</span>...     <span class="built_in">print</span>(s.strip())...Hello!Hi!Goodbye!</code></pre><h4 id="byteslo"><a class="markdownIt-Anchor" href="#byteslo"></a> ByteslO</h4><p>StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。</p><p>BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO<span class="meta">&gt;&gt;&gt; </span>f = BytesIO()<span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))<span class="number">6</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(f.getvalue())<span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span></code></pre><p>请注意，写入的不是str，而是经过UTF-8编码的bytes。和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO<span class="meta">&gt;&gt;&gt; </span>f = BytesIO(<span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>)<span class="meta">&gt;&gt;&gt; </span>f.read()<span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span></code></pre><h3 id="操作文件和目录"><a class="markdownIt-Anchor" href="#操作文件和目录"></a> 操作文件和目录</h3><p>如果我们要操作文件、目录，可以在命令行下面输入操作系统提供的各种命令来完成。比如dir、cp等命令。</p><p>如果要在Python程序中执行这些目录和文件的操作怎么办？其实操作系统提供的命令只是简单地调用了操作系统提供的接口函数，Python内置的os模块也可以直接调用操作系统提供的接口函数。</p><p>打开Python交互式命令行，我们来看看如何使用os模块的基本功能：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os<span class="meta">&gt;&gt;&gt; </span>os.name <span class="comment"># 操作系统类型</span><span class="string">&#x27;posix&#x27;</span></code></pre><p>如果是posix，说明系统是Linux、Unix或Mac OS X，如果是nt，就是Windows系统。</p><p>要<strong>获取详细的系统信息，可以调用uname()函数</strong>：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>os.uname()posix.uname_result(sysname=<span class="string">&#x27;Darwin&#x27;</span>, nodename=<span class="string">&#x27;MichaelMacPro.local&#x27;</span>, release=<span class="string">&#x27;14.3.0&#x27;</span>, version=<span class="string">&#x27;Darwin Kernel Version 14.3.0: Mon Mar 23 11:59:05 PDT 2015; root:xnu-2782.20.48~5/RELEASE_X86_64&#x27;</span>, machine=<span class="string">&#x27;x86_64&#x27;</span>)</code></pre><blockquote><p>注意uname()函数在Windows上不提供，也就是说，os模块的某些函数是跟操作系统相关的。</p></blockquote><h4 id="环境变量"><a class="markdownIt-Anchor" href="#环境变量"></a> 环境变量</h4><p>在操作系统中定义的环境变量，全部保存在<strong>os.environ</strong>这个变量中，可以直接查看：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>os.environenviron(&#123;<span class="string">&#x27;VERSIONER_PYTHON_PREFER_32_BIT&#x27;</span>: <span class="string">&#x27;no&#x27;</span>, <span class="string">&#x27;TERM_PROGRAM_VERSION&#x27;</span>: <span class="string">&#x27;326&#x27;</span>, <span class="string">&#x27;LOGNAME&#x27;</span>: <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;PATH&#x27;</span>: <span class="string">&#x27;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin&#x27;</span>, ...&#125;)</code></pre><p>要获取某个环境变量的值，可以调用os.environ.get(‘key’)：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>os.environ.get(<span class="string">&#x27;PATH&#x27;</span>)<span class="string">&#x27;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin&#x27;</span><span class="meta">&gt;&gt;&gt; </span>os.environ.get(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;default&#x27;</span>)<span class="string">&#x27;default&#x27;</span></code></pre><h4 id="操作文件和目录-2"><a class="markdownIt-Anchor" href="#操作文件和目录-2"></a> 操作文件和目录</h4><p>操作文件和目录的函数一部分放在<strong>os模块</strong>中，一部分放在<strong>os.path模块</strong>中，这一点要注意一下。查看、创建和删除目录可以这么调用：</p><pre><code class="highlight python"><span class="comment"># 查看当前目录的绝对路径:</span><span class="meta">&gt;&gt;&gt; </span>os.path.abspath(<span class="string">&#x27;.&#x27;</span>)<span class="string">&#x27;/Users/michael&#x27;</span><span class="comment"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">&#x27;/Users/michael&#x27;</span>, <span class="string">&#x27;testdir&#x27;</span>)<span class="string">&#x27;/Users/michael/testdir&#x27;</span><span class="comment"># 然后创建一个目录:</span><span class="meta">&gt;&gt;&gt; </span>os.mkdir(<span class="string">&#x27;/Users/michael/testdir&#x27;</span>)<span class="comment"># 删掉一个目录:</span><span class="meta">&gt;&gt;&gt; </span>os.rmdir(<span class="string">&#x27;/Users/michael/testdir&#x27;</span>)</code></pre><p>把<strong>两个路径合成一个</strong>时，不要直接拼字符串，而要通过<strong>os.path.join()函数</strong>，这样可以正确处理不同操作系统的路径分隔符。在Linux/Unix/Mac下，os.path.join()返回这样的字符串：</p><pre><code class="highlight python">part-<span class="number">1</span>/part-<span class="number">2</span></code></pre><p>而Windows下会返回这样的字符串：</p><pre><code class="highlight python">part-<span class="number">1</span>\part-<span class="number">2</span></code></pre><p>同样的道理，要<strong>拆分路径</strong>时，也不要直接去拆字符串，而要通过<strong>os.path.split()函数</strong>，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>os.path.split(<span class="string">&#x27;/Users/michael/testdir/file.txt&#x27;</span>)(<span class="string">&#x27;/Users/michael/testdir&#x27;</span>, <span class="string">&#x27;file.txt&#x27;</span>)</code></pre><p><strong>os.path.splitext()可以直接让你得到文件扩展名</strong>，很多时候非常方便：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>os.path.splitext(<span class="string">&#x27;/path/to/file.txt&#x27;</span>)(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;.txt&#x27;</span>)</code></pre><blockquote><p><strong>这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作</strong>。</p></blockquote><p>文件操作使用下面的函数。假定当前目录下有一个test.txt文件：</p><pre><code class="highlight python"><span class="comment"># 对文件重命名:</span><span class="meta">&gt;&gt;&gt; </span>os.rename(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;test.py&#x27;</span>)<span class="comment"># 删掉文件:</span><span class="meta">&gt;&gt;&gt; </span>os.remove(<span class="string">&#x27;test.py&#x27;</span>)</code></pre><p>但是复制文件的函数居然在os模块中不存在！原因是复制文件并非由操作系统提供的系统调用。理论上讲，我们通过上一节的读写文件可以完成文件复制，只不过要多写很多代码。</p><p>幸运的是<strong>shutil模块</strong>提供了<strong>copyfile()的函数</strong>，你还可以在shutil模块中找到很多实用函数，它们可以看做是os模块的补充。</p><p>最后看看如何利用Python的特性来过滤文件。比如我们要列出当前目录下的所有目录，只需要一行代码：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> os.listdir(<span class="string">&#x27;.&#x27;</span>) <span class="keyword">if</span> os.path.isdir(x)][<span class="string">&#x27;.lein&#x27;</span>, <span class="string">&#x27;.local&#x27;</span>, <span class="string">&#x27;.m2&#x27;</span>, <span class="string">&#x27;.npm&#x27;</span>, <span class="string">&#x27;.ssh&#x27;</span>, <span class="string">&#x27;.Trash&#x27;</span>, <span class="string">&#x27;.vim&#x27;</span>, <span class="string">&#x27;Applications&#x27;</span>, <span class="string">&#x27;Desktop&#x27;</span>, ...]</code></pre><p>要列出所有的.py文件，也只需一行代码：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> os.listdir(<span class="string">&#x27;.&#x27;</span>) <span class="keyword">if</span> os.path.isfile(x) <span class="keyword">and</span> os.path.splitext(x)[<span class="number">1</span>]==<span class="string">&#x27;.py&#x27;</span>][<span class="string">&#x27;apis.py&#x27;</span>, <span class="string">&#x27;config.py&#x27;</span>, <span class="string">&#x27;models.py&#x27;</span>, <span class="string">&#x27;pymonitor.py&#x27;</span>, <span class="string">&#x27;test_db.py&#x27;</span>, <span class="string">&#x27;urls.py&#x27;</span>, <span class="string">&#x27;wsgiapp.py&#x27;</span>]</code></pre><p>是不是非常简洁？</p><p><strong>练习</strong></p><ul><li>利用os模块实现dir -l输出的程序</li></ul><pre><code class="highlight python"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime<span class="keyword">import</span> os<span class="comment">#获取当前路径</span>pwd = os.path.abspath(<span class="string">&#x27;.&#x27;</span>)<span class="built_in">print</span>(<span class="string">&#x27;      Size     Last Modified  Name&#x27;</span>)<span class="built_in">print</span>(<span class="string">&#x27;------------------------------------------------------------&#x27;</span>)<span class="comment">#os.listdir()获取指定路径的所有文件</span><span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(pwd):    fsize = os.path.getsize(f)    mtime = datetime.fromtimestamp(os.path.getmtime(f)).strftime(<span class="string">&#x27;%Y-%m-%d %H:%M&#x27;</span>)    flag = <span class="string">&#x27;/&#x27;</span> <span class="keyword">if</span> os.path.isdir(f) <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span>    <span class="built_in">print</span>(<span class="string">&#x27;%10d  %s  %s%s&#x27;</span> % (fsize, mtime, f, flag))</code></pre><p>输出:</p><ul><li>编写一个程序，能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，并打印出相对路径。</li></ul><pre><code class="highlight python"><span class="keyword">import</span> os<span class="keyword">def</span> <span class="title function_">Searchfile</span>(<span class="params"><span class="built_in">str</span></span>):    pwd = os.path.abspath(<span class="string">&#x27;.&#x27;</span>)    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(pwd):        <span class="keyword">for</span> file <span class="keyword">in</span> files:            <span class="keyword">if</span> <span class="built_in">str</span> <span class="keyword">in</span> file: <span class="comment">#用if in实现子字符串的查找</span>                <span class="built_in">print</span>(os.path.join(root, file))<span class="comment">#            if file.find(str) !=-1:    #用find函数实现子字符串的查找</span><span class="comment">#                print(os.path.join(root, file))</span></code></pre><pre><code class="highlight python"><span class="keyword">import</span> os<span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">path,key</span>):    count_dirs = count_files = <span class="number">0</span>    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(path):        <span class="keyword">for</span> x <span class="keyword">in</span> files:            <span class="keyword">if</span> key <span class="keyword">in</span> x:                <span class="built_in">print</span>(os.path.join(root,x),<span class="string">&#x27;文件&#x27;</span>)                count_files += <span class="number">1</span>        <span class="keyword">for</span> y <span class="keyword">in</span> dirs:            <span class="keyword">if</span> key <span class="keyword">in</span> y:                <span class="built_in">print</span>(os.path.join(root,y),<span class="string">&#x27;目录&#x27;</span>)                count_dirs += <span class="number">1</span>    <span class="built_in">print</span>(<span class="string">&#x27;\n文件数：%d, 目录数：%d&#x27;</span>%(count_files,count_dirs))find(<span class="string">&quot;D:\ztest&quot;</span>,<span class="string">&quot;xml&quot;</span>)</code></pre><h3 id="序列化"><a class="markdownIt-Anchor" href="#序列化"></a> 序列化</h3><p>在程序运行的过程中，所有的变量都是在内存中，比如，定义一个dict：</p><pre><code class="highlight python">d = <span class="built_in">dict</span>(name=<span class="string">&#x27;Bob&#x27;</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)</code></pre><p>可以随时修改变量，比如把name改成’Bill’，但是一旦程序结束，变量所占用的内存就被操作系统全部回收。如果没有把修改后的’Bill’存储到磁盘上，下次重新运行程序，变量又被初始化为’Bob’。</p><p><strong>我们把变量从内存中变成可存储或传输的过程称之为序列化</strong>，在Python中叫<strong>pickling</strong>，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</p><p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p><p>反过来，<strong>把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling</strong>。</p><p>Python提供了<strong>pickle模块</strong>来实现序列化。</p><p>首先，我们尝试把一个对象序列化并写入文件：</p><pre><code class="highlight python">&gt;&gt;&gt; <span class="keyword">import</span> pickle&gt;&gt;&gt; d = <span class="built_in">dict</span>(name=<span class="string">&#x27;Bob&#x27;</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)&gt;&gt;&gt; pickle.dumps(d)<span class="string">b&#x27;\x80\x03&#125;q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.&#x27;</span></code></pre><p><strong>pickle.dumps()方法把任意对象序列化成一个bytes</strong>，然后，就可以把这个bytes写入文件。或者用另一个方法pickle.dump()直接把对象序列化后写入一个file-like Object：</p><pre><code class="highlight python">&gt;&gt;&gt; f = <span class="built_in">open</span>(<span class="string">&#x27;dump.txt&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)&gt;&gt;&gt; pickle.dump(d, f)&gt;&gt;&gt; f.close()</code></pre><p>看看写入的dump.txt文件，一堆乱七八糟的内容，这些都是Python保存的对象内部信息。</p><p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用<strong>pickle.loads()方法反序列化出对象</strong>，也可以直接用pickle.load()方法从一个file-like Object中直接反序列化出对象。我们打开另一个Python命令行来反序列化刚才保存的对象：</p><pre><code class="highlight python">&gt;&gt;&gt; f = <span class="built_in">open</span>(<span class="string">&#x27;dump.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)&gt;&gt;&gt; d = pickle.load(f)&gt;&gt;&gt; f.close()&gt;&gt;&gt; d&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">88</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>&#125;</code></pre><p>变量的内容又回来了！</p><blockquote><p>当然，这个变量和原来的变量是完全不相干的对象，它们只是内容相同而已。</p></blockquote><p>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</p><h4 id="json"><a class="markdownIt-Anchor" href="#json"></a> JSON</h4><p>如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p><p>JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：</p><table><thead><tr><th>JSON类型</th><th>Python类型</th></tr></thead><tbody><tr><td>{}</td><td>dict</td></tr><tr><td>[]</td><td>list</td></tr><tr><td>“string”</td><td>str</td></tr><tr><td>1234.56</td><td>int或float</td></tr><tr><td>true/false</td><td>True/False</td></tr><tr><td>null</td><td>None</td></tr></tbody></table><p>Python内置的json模块提供了非常完善的Python对象到JSON格式的转换。我们先看看如何把<strong>Python对象变成一个JSON</strong>：</p><pre><code class="highlight python">&gt;&gt;&gt; <span class="keyword">import</span> json&gt;&gt;&gt; d = <span class="built_in">dict</span>(name=<span class="string">&#x27;Bob&#x27;</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)&gt;&gt;&gt; json.dumps(d)<span class="string">&#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;</span></code></pre><p>dumps()方法返回一个str，内容就是标准的JSON。类似的，dump()方法可以直接把JSON写入一个file-like Object。</p><p>要把<strong>JSON反序列化为Python对象</strong>，用<strong>loads</strong>()或者对应的<strong>load</strong>()方法，前者把JSON的字符串反序列化，后者从file-like Object中读取字符串并反序列化：</p><pre><code class="highlight python">&gt;&gt;&gt; json_str = <span class="string">&#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;</span>&gt;&gt;&gt; json.loads(json_str)&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">88</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>&#125;</code></pre><p>由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的str与JSON的字符串之间转换。</p><h4 id="json进阶"><a class="markdownIt-Anchor" href="#json进阶"></a> JSON进阶</h4><p>Python的dict对象可以直接序列化为JSON的{}，不过，很多时候，我们更喜欢用class表示对象，比如定义Student类，然后序列化：</p><pre><code class="highlight python"><span class="keyword">import</span> json<span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, score</span>):        <span class="variable language_">self</span>.name = name        <span class="variable language_">self</span>.age = age        <span class="variable language_">self</span>.score = scores = Student(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">20</span>, <span class="number">88</span>)<span class="built_in">print</span>(json.dumps(s))</code></pre><p>运行代码，毫不留情地得到一个TypeError：</p><pre><code class="highlight python">Traceback (most recent call last):  ...TypeError: &lt;__main__.Student <span class="built_in">object</span> at <span class="number">0x10603cc50</span>&gt; <span class="keyword">is</span> <span class="keyword">not</span> JSON serializable</code></pre><p>错误的原因是Student对象不是一个可序列化为JSON的对象。</p><p>如果连class的实例对象都无法序列化为JSON，这肯定不合理！</p><p>别急，我们仔细看看dumps()方法的参数列表，可以发现，除了第一个必须的obj参数外，dumps()方法还提供了一大堆的可选参数：</p><p><a href="https://docs.python.org/3/library/json.html#json.dumps">https://docs.python.org/3/library/json.html#json.dumps</a></p><p>这些可选参数就是让我们来定制JSON序列化。前面的代码之所以无法把Student类实例序列化为JSON，是因为默认情况下，dumps()方法不知道如何将Student实例变为一个JSON的{}对象。</p><p>可选参数<strong>default就是把任意一个对象变成一个可序列为JSON的对象</strong>，我们只需要为Student专门写一个转换函数，再把函数传进去即可：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">student2dict</span>(<span class="params">std</span>):    <span class="keyword">return</span> &#123;        <span class="string">&#x27;name&#x27;</span>: std.name,        <span class="string">&#x27;age&#x27;</span>: std.age,        <span class="string">&#x27;score&#x27;</span>: std.score    &#125;</code></pre><p>这样，Student实例首先被student2dict()函数转换成dict，然后再被顺利序列化为JSON：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(json.dumps(s, default=student2dict))&#123;<span class="string">&quot;age&quot;</span>: <span class="number">20</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="number">88</span>&#125;</code></pre><p>对<strong>中文进行JSON序列化</strong>时，json.dumps()提供了一个<strong>ensure_ascii</strong>参数</p><pre><code class="highlight python">obj = <span class="built_in">dict</span>(name=<span class="string">&#x27;小明&#x27;</span>, age=<span class="number">20</span>)s = json.dumps(obj, ensure_ascii=<span class="literal">True</span>)</code></pre><p>不过，下次如果遇到一个Teacher类的实例，照样无法序列化为JSON。我们可以偷个懒，把任意class的实例变为dict：</p><pre><code class="highlight python"><span class="built_in">print</span>(json.dumps(s, default=<span class="keyword">lambda</span> obj: obj.__dict__))</code></pre><p>因为通常class的实例都有一个__dict__属性，它就是一个dict，用来存储实例变量。也有少数例外，比如定义了__slots__的class。</p><p>同样的道理，如果我们要把<strong>JSON反序列化为一个Student对象实例</strong>，loads()方法首先转换出一个dict对象，然后，我们传入的<strong>object_hook</strong>函数负责把dict转换为Student实例：</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">dict2student</span>(<span class="params">d</span>):    <span class="keyword">return</span> Student(d[<span class="string">&#x27;name&#x27;</span>], d[<span class="string">&#x27;age&#x27;</span>], d[<span class="string">&#x27;score&#x27;</span>])</code></pre><p>运行结果如下：</p><pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>json_str = <span class="string">&#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;</span><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(json.loads(json_str, object_hook=dict2student))&lt;__main__.Student <span class="built_in">object</span> at <span class="number">0x10cd3c190</span>&gt;</code></pre><p>打印出的是反序列化的Student实例对象。</p><h2 id="进程和线程"><a class="markdownIt-Anchor" href="#进程和线程"></a> 进程和线程</h2><p>很多同学都听说过，现代操作系统比如Mac OS X，UNIX，Linux，Windows等，都是支持“多任务”的操作系统。</p><p>什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。</p><p>现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？</p><p>答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。</p><p>真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。</p><p>对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p><p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</p><p>由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。</p><p>我们前面编写的所有的Python程序，都是执行单任务的进程，也就是只有一个线程。如果我们要同时执行多个任务怎么办？</p><p>有两种解决方案：</p><p>一种是启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务。</p><p>还有一种方法是启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务。</p><p>当然还有第三种方法，就是启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了，当然这种模型更复杂，实际很少采用。</p><p>总结一下就是，多任务的实现有3种方式：</p><ul><li>多进程模式；</li><li>多线程模式；</li><li>多进程+多线程模式。</li></ul><p>同时执行多个任务通常各个任务之间并不是没有关联的，而是需要相互通信和协调，有时，任务1必须暂停等待任务2完成后才能继续执行，有时，任务3和任务4又不能同时执行，所以，多进程和多线程的程序的复杂度要远远高于我们前面写的单进程单线程的程序。</p><p>因为复杂度高，调试困难，所以，不是迫不得已，我们也不想编写多任务。但是，有很多时候，没有多任务还真不行。想想在电脑上看电影，就必须由一个线程播放视频，另一个线程播放音频，否则，单线程实现的话就只能先把视频播放完再播放音频，或者先把音频播放完再播放视频，这显然是不行的。</p><p><strong>Python既支持多进程，又支持多线程</strong></p><p><strong>线程是最小的执行单元，而进程由至少一个线程组成</strong>。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。</p><h3 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h3><p>要让Python程序实现多进程（<strong>multiprocessing</strong>），我们先了解操作系统的相关知识。</p><p>Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</p><p>子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。</p><p>Python的os模块封装了常见的系统调用，其中就包括fork，可以在Python程序中轻松创建子进程：</p><pre><code class="highlight python"><span class="keyword">import</span> os<span class="built_in">print</span>(<span class="string">&#x27;Process (%s) start...&#x27;</span> % os.getpid())<span class="comment"># Only works on Unix/Linux/Mac:</span>pid = os.fork()<span class="keyword">if</span> pid == <span class="number">0</span>:    <span class="built_in">print</span>(<span class="string">&#x27;I am child process (%s) and my parent is %s.&#x27;</span> % (os.getpid(), os.getppid()))<span class="keyword">else</span>:    <span class="built_in">print</span>(<span class="string">&#x27;I (%s) just created a child process (%s).&#x27;</span> % (os.getpid(), pid))</code></pre><p>运行结果如下：</p><pre><code class="highlight python">Process (<span class="number">876</span>) start...I (<span class="number">876</span>) just created a child process (<span class="number">877</span>).I am child process (<span class="number">877</span>) <span class="keyword">and</span> my parent <span class="keyword">is</span> <span class="number">876.</span></code></pre><p>由于Windows没有fork调用，上面的代码在Windows上无法运行。而Mac系统是基于BSD（Unix的一种）内核，所以，在Mac下运行是没有问题的，推荐大家用Mac学Python！</p><p>有了fork调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。</p><h4 id="multiprocessing"><a class="markdownIt-Anchor" href="#multiprocessing"></a> multiprocessing</h4><p>如果你打算编写多进程的服务程序，Unix/Linux无疑是正确的选择。由于Windows没有fork调用，难道在Windows上无法用Python编写多进程的程序？</p><p>由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持。<strong>multiprocessing模块就是跨平台版本的多进程模块</strong>。</p><p>multiprocessing模块提供了一个<strong>Process类来代表一个进程对象</strong>，下面的例子演示了启动一个子进程并等待其结束：</p><pre><code class="highlight python"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process<span class="keyword">import</span> os<span class="comment"># 子进程要执行的代码</span><span class="keyword">def</span> <span class="title function_">run_proc</span>(<span class="params">name</span>):    <span class="built_in">print</span>(<span class="string">&#x27;Run child process %s (%s)...&#x27;</span> % (name, os.getpid()))<span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:    <span class="built_in">print</span>(<span class="string">&#x27;Parent process %s.&#x27;</span> % os.getpid())    p = Process(target=run_proc, args=(<span class="string">&#x27;test&#x27;</span>,))    <span class="built_in">print</span>(<span class="string">&#x27;Child process will start.&#x27;</span>)    p.start()    p.join()    <span class="built_in">print</span>(<span class="string">&#x27;Child process end.&#x27;</span>)</code></pre><p>执行结果如下：</p><pre><code class="highlight python">Parent process <span class="number">928.</span>Child process will start.Run child process test (<span class="number">929</span>)...Process end.</code></pre><p><strong>创建子进程时，只需要传入一个执行函数和函数的参数</strong>，创建一个Process实例，用<strong>start()方法启动</strong>，这样创建进程比fork()还要简单。</p><p><strong>join()方法可以等待子进程结束后再继续往下运行</strong>，通常用于进程间的同步。</p><h4 id="pool"><a class="markdownIt-Anchor" href="#pool"></a> Pool</h4><p><strong>如果要启动大量的子进程，可以用进程池的方式批量创建子进程</strong>：</p><pre><code class="highlight python"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool<span class="keyword">import</span> os, time, random<span class="keyword">def</span> <span class="title function_">long_time_task</span>(<span class="params">name</span>):    <span class="built_in">print</span>(<span class="string">&#x27;Run task %s (%s)...&#x27;</span> % (name, os.getpid()))    start = time.time()    time.sleep(random.random() * <span class="number">3</span>)    end = time.time()    <span class="built_in">print</span>(<span class="string">&#x27;Task %s runs %0.2f seconds.&#x27;</span> % (name, (end - start)))<span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:    <span class="built_in">print</span>(<span class="string">&#x27;Parent process %s.&#x27;</span> % os.getpid())    <span class="comment">#4表示进程池大小为4</span>    p = Pool(<span class="number">4</span>)    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):        <span class="comment">#新启动一个进程</span>        p.apply_async(long_time_task, args=(i,))    <span class="built_in">print</span>(<span class="string">&#x27;Waiting for all subprocesses done...&#x27;</span>)    p.close()    p.join()    <span class="built_in">print</span>(<span class="string">&#x27;All subprocesses done.&#x27;</span>)</code></pre><p>执行结果如下：</p><pre><code class="highlight python">Parent process <span class="number">669.</span>Waiting <span class="keyword">for</span> <span class="built_in">all</span> subprocesses done...Run task <span class="number">0</span> (<span class="number">671</span>)...Run task <span class="number">1</span> (<span class="number">672</span>)...Run task <span class="number">2</span> (<span class="number">673</span>)...Run task <span class="number">3</span> (<span class="number">674</span>)...Task <span class="number">2</span> runs <span class="number">0.14</span> seconds.Run task <span class="number">4</span> (<span class="number">673</span>)...Task <span class="number">1</span> runs <span class="number">0.27</span> seconds.Task <span class="number">3</span> runs <span class="number">0.86</span> seconds.Task <span class="number">0</span> runs <span class="number">1.41</span> seconds.Task <span class="number">4</span> runs <span class="number">1.91</span> seconds.All subprocesses done.</code></pre><p>代码解读：</p><p><strong>对Pool对象调用join()方法会等待所有子进程执行完毕</strong>，<strong>调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了</strong>。</p><p>请注意输出的结果，task 0，1，2，3是立刻执行的，而task 4要等待前面某个task完成后才执行，这是因为Pool的默认大小在我的电脑上是4，因此，最多同时执行4个进程。这是Pool有意设计的限制，并不是操作系统的限制。如果改成：</p><pre><code class="highlight python">p = Pool(<span class="number">5</span>)</code></pre><p>就可以同时跑5个进程。</p><p>由于Pool的默认大小是CPU的核数，如果你不幸拥有8核CPU，你要提交至少9个子进程才能看到上面的等待效果。</p><h4 id="子进程"><a class="markdownIt-Anchor" href="#子进程"></a> 子进程</h4><p>很多时候，子进程并不是自身，而是一个外部进程。我们创建了子进程后，还需要控制子进程的输入和输出。</p><p><strong>subprocess模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出</strong>。</p><p>下面的例子演示了如何在Python代码中运行命令nslookup <a href="http://www.python.org">www.python.org</a>，这和命令行直接运行的效果是一样的：</p><pre><code class="highlight python"><span class="keyword">import</span> subprocess<span class="built_in">print</span>(<span class="string">&#x27;$ nslookup www.python.org&#x27;</span>)r = subprocess.call([<span class="string">&#x27;nslookup&#x27;</span>, <span class="string">&#x27;www.python.org&#x27;</span>])<span class="built_in">print</span>(<span class="string">&#x27;Exit code:&#x27;</span>, r)</code></pre><p>运行结果：</p><pre><code class="highlight python">$ nslookup www.python.orgServer:<span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span>Address:<span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span><span class="comment">#53</span>Non-authoritative answer:www.python.orgcanonical name = python.<span class="built_in">map</span>.fastly.net.Name:python.<span class="built_in">map</span>.fastly.netAddress: <span class="number">199.27</span><span class="number">.79</span><span class="number">.223</span>Exit code: <span class="number">0</span></code></pre><p>如果子进程还需要输入，则可以通过communicate()方法输入：</p><pre><code class="highlight python"><span class="keyword">import</span> subprocess<span class="built_in">print</span>(<span class="string">&#x27;$ nslookup&#x27;</span>)p = subprocess.Popen([<span class="string">&#x27;nslookup&#x27;</span>], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)output, err = p.communicate(<span class="string">b&#x27;set q=mx\npython.org\nexit\n&#x27;</span>)<span class="built_in">print</span>(output.decode(<span class="string">&#x27;utf-8&#x27;</span>))<span class="built_in">print</span>(<span class="string">&#x27;Exit code:&#x27;</span>, p.returncode)</code></pre><p>上面的代码相当于在命令行执行命令nslookup，然后手动输入：</p><pre><code class="highlight python"><span class="built_in">set</span> q=mxpython.orgexit</code></pre><p>运行结果如下：</p><pre><code class="highlight python">$ nslookupServer:<span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span>Address:<span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span><span class="comment">#53</span>Non-authoritative answer:python.orgmail exchanger = <span class="number">50</span> mail.python.org.Authoritative answers can be found <span class="keyword">from</span>:mail.python.orginternet address = <span class="number">82.94</span><span class="number">.164</span><span class="number">.166</span>mail.python.orghas AAAA address <span class="number">2001</span>:<span class="number">888</span>:<span class="number">2000</span>:d::a6Exit code: <span class="number">0</span></code></pre><h4 id="进程间通信"><a class="markdownIt-Anchor" href="#进程间通信"></a> 进程间通信</h4><p>Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的<strong>multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据</strong>。</p><p>我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据：</p><pre><code class="highlight python"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue<span class="keyword">import</span> os, time, random<span class="comment"># 写数据进程执行的代码:</span><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">q</span>):    <span class="built_in">print</span>(<span class="string">&#x27;Process to write: %s&#x27;</span> % os.getpid())    <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]:        <span class="built_in">print</span>(<span class="string">&#x27;Put %s to queue...&#x27;</span> % value)        q.put(value)        time.sleep(random.random())<span class="comment"># 读数据进程执行的代码:</span><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">q</span>):    <span class="built_in">print</span>(<span class="string">&#x27;Process to read: %s&#x27;</span> % os.getpid())    <span class="keyword">while</span> <span class="literal">True</span>:        value = q.get(<span class="literal">True</span>)        <span class="built_in">print</span>(<span class="string">&#x27;Get %s from queue.&#x27;</span> % value)<span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:    <span class="comment"># 父进程创建Queue，并传给各个子进程：</span>    q = Queue()    pw = Process(target=write, args=(q,))    pr = Process(target=read, args=(q,))    <span class="comment"># 启动子进程pw，写入:</span>    pw.start()    <span class="comment"># 启动子进程pr，读取:</span>    pr.start()    <span class="comment"># 等待pw结束:</span>    pw.join()    <span class="comment"># pr进程里是死循环，无法等待其结束，只能强行终止:</span>    pr.terminate()</code></pre><p>运行结果如下：</p><pre><code class="highlight python">Process to write: <span class="number">50563</span>Put A to queue...Process to read: <span class="number">50564</span>Get A <span class="keyword">from</span> queue.Put B to queue...Get B <span class="keyword">from</span> queue.Put C to queue...Get C <span class="keyword">from</span> queue.</code></pre><p>在Unix/Linux下，multiprocessing模块封装了fork()调用，使我们不需要关注fork()的细节。由于Windows没有fork调用，因此，multiprocessing需要“模拟”出fork的效果，父进程所有Python对象都必须通过pickle序列化再传到子进程去，所以，如果multiprocessing在Windows下调用失败了，要先考虑是不是pickle失败了。</p><h3 id="多线"><a class="markdownIt-Anchor" href="#多线"></a> 多线</h3><p>多任务可以由多进程完成，也可以由一个进程内的多线程完成。</p><p>我们前面提到了进程是由若干线程组成的，一个进程至少有一个线程。由于线程是操作系统直接支持的执行单元，</p><p>因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。</p><p>Python的标准库提供了两个模块：_thread和threading，_thread是低级模块，threading是高级模块，对_thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。</p><p><strong>启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始</strong>执行：</p>]]>
    </content>
    <id>http://example.com/2022/05/14/Python/</id>
    <link href="http://example.com/2022/05/14/Python/"/>
    <published>2022-05-14T04:00:00.000Z</published>
    <summary>本文详细介绍了Git的核心概念、以及日常开发中常用语法，Python基础语法，函数，函数式编程，高级特性，模块，IO，进程。</summary>
    <title>Python</title>
    <updated>2026-02-27T01:15:32.877Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    <category term="MyBatis" scheme="http://example.com/tags/MyBatis/"/>
    <content>
      <![CDATA[<h1 id="mybatis"><a class="markdownIt-Anchor" href="#mybatis"></a> MyBatis</h1><p>[TOC]</p><h2 id="mybatis基础"><a class="markdownIt-Anchor" href="#mybatis基础"></a> MyBatis基础</h2><p>mybaits：<code>http://www.mybatis.org/mybatis-3/zh/index.html</code></p><h3 id="mybatis框架简介"><a class="markdownIt-Anchor" href="#mybatis框架简介"></a> MyBatis框架简介</h3><p>MyBatis框架就是对JDBC的封装，主要目的就是简化JDBC开发流程，实现事务松耦合，将实体类与SQL命令进行动态对应</p><h4 id="什么是mybatis"><a class="markdownIt-Anchor" href="#什么是mybatis"></a> 什么是MyBatis</h4><ul><li>MyBatis最早起源自Apache基金会的一个开源项目ibatis，2010年这个项目由Apache software foundation迁移到了Google code，并改名为MyBatis；</li><li>Mybatis是支持普通SQL，存储过程和高级映射的优秀持久层框架</li><li>MyBatis是支持普通SQL查询，存储过程和高级映射的优秀持久层框架</li><li>MyBatis封装了几乎所有的JDBC代码和参数的手工设置以及结果集的检索</li><li>MyBatis使用简单的XML或注解做配置和定义映射关系，将Java的POJOs(Plain Old Java Object)映射成数据库中的记录</li></ul><h4 id="mybatis体系结构"><a class="markdownIt-Anchor" href="#mybatis体系结构"></a> MyBatis体系结构</h4><ul><li>加载配置<ul><li>配置有两种形式，一种是XML配置文件，另一种是Java代码的注解，MyBatis将SQL的配置信息加载成为一个个的MappedStatement对象（包括传入参数映射配置，执行的SQL语句，结果映射配置），并将其存储在内存中</li></ul></li><li>SQL解析<ul><li>当API接口层接收到调用请求时，会接收到传入SQL的ID和传入对象（可以是Map，JavaBean或者基本数据类型），MyBatis会根据SQL的ID找到对应的MappedStatement，然后根据传入参数对象对MappedStatement进行解析，解析后可以得到最终要执行的SQL语句和参数</li></ul></li><li>SQL执行<ul><li>将最终得到的SQL和参数拿到数据库进行执行，得到操作数据库的结果</li></ul></li><li>结果映射<ul><li>将操作数据库的结果按照映射的配置进行转换，可以转换成HashMap，JavaBean或者基本数据类型，并将最终结果返回</li></ul></li></ul><h4 id="通俗理解"><a class="markdownIt-Anchor" href="#通俗理解"></a> 通俗理解</h4><ul><li>平时我们都用JDBC访问数据库，除了需要自己写SQL之外，还必须操作Connection, Statement, ResultSet 这些其实只是手段的辅助类。 不仅如此，访问不同的表，还会写很多雷同的代码，显得繁琐和枯燥</li><li>那么用了Mybatis之后，只需要自己提供SQL语句，其他的工作，诸如建立连接，Statement， JDBC相关异常处理等等都交给Mybatis去做了，那些重复性的工作Mybatis也给做掉了，我们只需要关注在增删改查等操作层面上，而把技术细节都封装在了我们看不见的地方</li></ul><h4 id="mybatis配置文件"><a class="markdownIt-Anchor" href="#mybatis配置文件"></a> MyBatis配置文件</h4><ul><li>MyBatis框架的XML配置文件包含下面两种类型<ul><li>mybatis-config.xml（1个）<ul><li>主配置文件，用于指定数据库连接参数和框架参数</li></ul></li><li>SqlMap.xml（n个）<ul><li>映射定义文件，用于定义SQL语句和映射信息</li></ul></li></ul></li><li><code>mybaits-config.xml</code></li></ul><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;environment&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;environment&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span>            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;oracle.jdbc.OracleDriver&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc.oracle:thin:@localhost:tarena10g&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;demo&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">valueo</span>=<span class="string">&quot;demo&quot;</span>/&gt;</span>            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span>    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></code></pre><ul><li><code>SqlMap.xml</code></li></ul><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">mapper</span>&gt;</span>    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addDept&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span>        insert into dept(DEPTNO,DNAME,LOC) values (#&#123;deptno&#125;,#&#123;dname&#125;,#&#123;loc&#125;)    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span>        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll1&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;deptMap&quot;</span>&gt;</span>        select DEPTNO,DNAME,LOC from DEPT    <span class="tag">&lt;/<span class="name">select</span>&gt;</span>        <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;deptMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;org.tarena.entity.Dept1&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;no&quot;</span> <span class="attr">column</span>=<span class="string">&quot;DEPTNO&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;DNAME&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;loc&quot;</span> <span class="attr">column</span>=<span class="string">&quot;LOC&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></code></pre><h4 id="框架api简介"><a class="markdownIt-Anchor" href="#框架api简介"></a> 框架API简介</h4><ul><li>在使用MyBatis框架时，主要涉及以下几个API<ul><li>SqlSessionFactoryBuilder<ul><li>该对象负责根据MyBatis配置文件SqlMapConfig.xml构建SqlSessionFactory实例</li></ul></li><li>SqlSessionFactory<ul><li>每一个MyBatis的应用程序都以一个SqlSessionFactory对象为核心，该对象负责创建SqlSession对象实例</li></ul></li><li>SqlSession<ul><li>该对象包含了所有执行SQL操作的方法，用于执行已映射的SQL语句</li></ul></li></ul></li></ul><h4 id="jdbc访问回忆"><a class="markdownIt-Anchor" href="#jdbc访问回忆"></a> JDBC访问（回忆）</h4><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);    <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/lee_test&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;admin&quot;</span>);    con.setAutoCommit(<span class="literal">false</span>); <span class="comment">//设置事务由交接，由该应用程序负责</span>    <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> con.prepareStatement(<span class="string">&quot;insert into category values (?,?)&quot;</span>);    preparedStatement.setInt(<span class="number">1</span>,<span class="number">101</span>);    preparedStatement.setString(<span class="number">2</span>,<span class="string">&quot;李老伯&quot;</span>);    <span class="keyword">try</span> &#123;        preparedStatement.executeUpdate();        con.commit();    &#125; <span class="keyword">catch</span> (Exception ex) &#123;        con.rollback();        ex.printStackTrace();    &#125;<span class="keyword">finally</span> &#123;        <span class="keyword">if</span> (preparedStatement != <span class="literal">null</span>) &#123;            preparedStatement.close();        &#125;        <span class="keyword">if</span> (con != <span class="literal">null</span>) &#123;            con.close();        &#125;    &#125;&#125;</code></pre><h3 id="mybatis基本应用"><a class="markdownIt-Anchor" href="#mybatis基本应用"></a> MyBatis基本应用</h3><h4 id="搭建mybatis技术环境"><a class="markdownIt-Anchor" href="#搭建mybatis技术环境"></a> 搭建MyBatis技术环境</h4><h5 id="pomxml"><a class="markdownIt-Anchor" href="#pomxml"></a> pom.xml</h5><pre><code class="highlight xml"><span class="comment">&lt;!--mybatis基础jar包--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!--添加MySQL的驱动包--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.46<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h5 id="mybatis-configxml"><a class="markdownIt-Anchor" href="#mybatis-configxml"></a> mybatis-config.xml</h5><p>在src下添加MyBatis配置文件mybatis-config.xml (核心配置文件)</p><ul><li>配置表对应实体类位置</li><li>配置数据库驱动，数据库名称，账号密码</li><li>配置表查询语句XML文件地址</li></ul><h6 id="mysql"><a class="markdownIt-Anchor" href="#mysql"></a> MySQL</h6><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>    <span class="comment">&lt;!-- 配置自动扫描com.lee.mybatis1.entity包下的类型，使得在后续配置文件Category.xml中使用resultType的时候可以直接使用Category</span><span class="comment">     而不用写全路径com.lee.mybaits1.entity.Category--&gt;</span>    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span>        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.lee.mybatis1.entity&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span>        <span class="comment">&lt;!--配置数据库连接url，用户名和密码--&gt;</span>    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span>            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/lee_test?characterEncoding=UTF-8&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span>            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span>    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span>        <span class="comment">&lt;!--映射Catrgory.xml--&gt;</span>    <span class="comment">&lt;!--映射,定位当前项目中所有映射文件的位置--&gt;</span>     <span class="tag">&lt;<span class="name">mappers</span>&gt;</span>         <span class="comment">&lt;!--两种方法二选一--&gt;</span>          <span class="comment">&lt;!--mapper中可以通过class,resource,url来定义一个具体的映射文件--&gt;</span>          <span class="comment">&lt;!--resource用于引用resource文件夹下的配置文件--&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/Category.xml&quot;</span>/&gt;</span>        <span class="comment">&lt;!--url方式需给配置文件出固定地址--&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/BlogMapper.xml&quot;</span>/&gt;</span>        <span class="comment">&lt;!--class方式用来配置接口文件--&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.BlogMapper&quot;</span>/&gt;</span>        <span class="comment">&lt;!--可以指向具体的包路径,该路径的所有映射文件和接口将产生对应的连接关系--&gt;</span>         <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.lee.dao&quot;</span>/&gt;</span>     <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></code></pre><h6 id="oracle"><a class="markdownIt-Anchor" href="#oracle"></a> Oracle</h6><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>    <span class="comment">&lt;!-- 配置自动扫描com.lee.mybatis1.entity包下的类型，使得在后续配置文件Category.xml中使用resultType的时候可以直接使用Category</span><span class="comment">     而不用写全路径com.lee.mybaits1.entity.Category--&gt;</span>    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span>        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.lee.mybatis1.entity&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span>    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;environments&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;environments&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span>            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;oracle.jdbc.OracleDriver&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:oracle:thin:@localhost:tarena10g&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span>            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span>    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span>    <span class="comment">&lt;!--映射Catrgory.xml--&gt;</span>    <span class="comment">&lt;!--映射,定位当前项目中所有映射文件的位置--&gt;</span>     <span class="tag">&lt;<span class="name">mappers</span>&gt;</span>         <span class="comment">&lt;!--两种方法二选一--&gt;</span>          <span class="comment">&lt;!--mapper中可以通过class,resource,url来定义一个具体的映射文件--&gt;</span>         <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/lee/mybatis1/entity/Category.xml&quot;</span>/&gt;</span>        <span class="comment">&lt;!--可以指向具体的包路径,该路径的所有映射文件和接口将产生对应的连接关系--&gt;</span>         <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.lee.dao&quot;</span>/&gt;</span>     <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></code></pre><h5 id="数据库表"><a class="markdownIt-Anchor" href="#数据库表"></a> 数据库表</h5><pre><code class="highlight sql"><span class="keyword">CREATE TABLE</span> category_ (  id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT,  name <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,  <span class="keyword">PRIMARY KEY</span> (id)) ENGINE<span class="operator">=</span>MyISAM AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</code></pre><h5 id="实体类"><a class="markdownIt-Anchor" href="#实体类"></a> 实体类</h5><pre><code class="highlight java"><span class="keyword">package</span> com.lee.mybatis1.entity;<span class="comment">/**</span><span class="comment"> * 数据库表实体类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Category</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> id ;    <span class="keyword">private</span> String name ;    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;&#125;</code></pre><h5 id="mapper配置文件"><a class="markdownIt-Anchor" href="#mapper配置文件"></a> Mapper配置文件</h5><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="comment">&lt;!-- namespace表示命名空间，后续调用sql语句的时候会用到 --&gt;</span><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.lee.mybatis1.CategorySpace&quot;</span>&gt;</span>    <span class="comment">&lt;!--</span><span class="comment">        id:一个标识，唯一键，以供后续代码调用</span><span class="comment">        resultType:表示返回的数据和Category关联起来</span><span class="comment">        这里本来应该使Category用com.lee.mybatis1.entity.Category，但是因为在mybatis-config.xml中配置了别名，所以可以直接使用Catrgory</span><span class="comment">     --&gt;</span>    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listCategory&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Category&quot;</span>&gt;</span>        select * from category_        <span class="comment">&lt;!--解析器会把这段sql语句#&#123;&#125;转换为问号，然后把#&#123;&#125;内的名字放到集合中，最后在调用的的时候用反射机制动态的从真正的对象中读取变量值赋值给sql语句然后执行--&gt;</span>        <span class="comment">&lt;!--insert into category values (#&#123;name&#125;,#&#123;loc&#125;)--&gt;</span>       <span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></code></pre><h5 id="获取sqlsession实例"><a class="markdownIt-Anchor" href="#获取sqlsession实例"></a> 获取SqlSession实例</h5><p>利用MyBatis API编程，获取SqlSession实例</p><pre><code class="highlight java"><span class="comment">//根据配置文件mybatis-config.xml得到sqlSessionFactory</span><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;<span class="comment">//Reader reader = Resources.getResourceAsReader(conf);</span><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);<span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<span class="comment">//然后根据sqlSessionFactory得到session</span><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();<span class="comment">//最后通过session的selectList方法，调用id名为listCategory的sql语句（这个语句就在Category.xml文件中）</span><span class="comment">//执行完成后返回一个Category集合</span>List&lt;Category&gt; list = sqlSession.selectList(<span class="string">&quot;listCategory&quot;</span>);<span class="comment">//注：session.selectList(&quot;listCategory&quot;)也可写成session.selectList(&quot;com.lee.mybatis1.CategorySpace.listCategory&quot;)</span><span class="comment">//前缀就是Category.xml中设置的命名表空间名字</span><span class="keyword">for</span> (Category c:list) &#123;    System.out.println(c.getId()+<span class="string">&quot;:&quot;</span>+c.getName());&#125;sqlSession.commit();sqlSession.close();</code></pre><h5 id="基本原理图"><a class="markdownIt-Anchor" href="#基本原理图"></a> 基本原理图</h5><ol><li>应用程序找Mybatis要数据</li><li>mybatis从数据库找来数据<ul><li>通过mybatis-config.xml 定位哪个数据库</li><li>通过Category.xml执行对应的select语句</li><li>基于Category.xml把返回的数据库记录封装在Category对象中</li><li>把多个Category对象装在一个Category集合中</li></ul></li></ol><ul><li>返回一个Category集合</li><li></li></ul><h4 id="利用sqlsession实现crud操作"><a class="markdownIt-Anchor" href="#利用sqlsession实现crud操作"></a> 利用SqlSession实现CRUD操作</h4><ul><li>当获取SqlSession对象后，就可以利用它对数据表执行增删改查操作了，使用步骤如下<ul><li>根据数据表编写实体类（Java POJO）</li><li>编写SqlMap.xml映射文件，定义SQL操作和映射信息</li><li>获取SqlSession对象，执行增删改查操作</li><li>提交事物（DML操作）</li><li>释放SqlSession对象资源</li></ul></li></ul><h5 id="添加"><a class="markdownIt-Anchor" href="#添加"></a> 添加</h5><ul><li><strong>添加</strong>操作的SqlMap.xml定义</li></ul><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addProduct&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Product&quot;</span>&gt;</span>       insert into product (name,price) values (#&#123;name&#125;,#&#123;price&#125;)<span class="tag">&lt;/<span class="name">insert</span>&gt;</span></code></pre><ul><li><strong>添加</strong>操作的Java代码</li></ul><pre><code class="highlight java"><span class="type">Product</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>(<span class="number">0</span>,<span class="string">&quot;小橘子&quot;</span>,<span class="number">8899</span>);sqlSession.insert(<span class="string">&quot;addProduct&quot;</span>,p1);sqlSession.commit();sqlSession.close();</code></pre><h5 id="更新"><a class="markdownIt-Anchor" href="#更新"></a> 更新</h5><ul><li><strong>更新</strong>操作的SqlMap.xml定义</li></ul><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateProduct&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Product&quot;</span>&gt;</span>    update product set name=#&#123;name&#125;,price=#&#123;price&#125; where id=#&#123;id&#125;<span class="tag">&lt;/<span class="name">update</span>&gt;</span></code></pre><ul><li><strong>更新</strong>操作的Java代码</li></ul><pre><code class="highlight java"><span class="type">Product</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>(<span class="number">2</span>,<span class="string">&quot;雷军&quot;</span>,<span class="number">8889</span>);sqlSession.update(<span class="string">&quot;updateProduct&quot;</span>,p2);sqlSession.commit();sqlSession.close();</code></pre><h5 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h5><ul><li><strong>删除</strong>操作的SqlMap.xml定义</li></ul><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteProductById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span>    delete from Product where id=#&#123;id&#125;<span class="tag">&lt;/<span class="name">delete</span>&gt;</span></code></pre><ul><li><strong>删除</strong>操作的Java代码</li></ul><pre><code class="highlight java">sqlSession.delete(<span class="string">&quot;deleteProductById&quot;</span>,<span class="number">1</span>);sqlSession.commit();sqlSession.close();</code></pre><h5 id="查询单行记录"><a class="markdownIt-Anchor" href="#查询单行记录"></a> 查询单行记录</h5><ul><li>查询单行记录的SqlMap.xml定义</li></ul><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getProductById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Product&quot;</span>&gt;</span>        select * from product where id=#&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><ul><li>查询单行记录的Java代码</li></ul><pre><code class="highlight java"><span class="type">Product</span> <span class="variable">p3</span> <span class="operator">=</span> sqlSession.selectOne(<span class="string">&quot;getProductById&quot;</span>,<span class="number">4</span>);System.out.println(p3.getId()+<span class="string">&quot;:&quot;</span>+p3.getName()+<span class="string">&quot;:&quot;</span>+p3.getPrice());sqlSession.close();</code></pre><h5 id="查询多行记录"><a class="markdownIt-Anchor" href="#查询多行记录"></a> 查询多行记录</h5><ul><li>查询多行记录的SqlMap.xml定义</li></ul><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listProduct&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Product&quot;</span>&gt;</span>        select * from product<span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><ul><li>查询多行记录的Java代码</li></ul><pre><code class="highlight java">        List&lt;Product&gt; list = sqlSession.selectList(<span class="string">&quot;listProduct&quot;</span>);        <span class="comment">//注：session.selectList(&quot;listCategory&quot;)也可写成session.selectList(&quot;com.lee.mybatis1.CategorySpace.listCategory&quot;)</span>        <span class="comment">//前缀就是Category.xml中设置的命名表空间名字</span>        <span class="keyword">for</span> (Product c:list) &#123;            System.out.println(c.getId()+<span class="string">&quot;:&quot;</span>+c.getName()+<span class="string">&quot;:&quot;</span>+c.getPrice());        &#125;sqlSession.close();</code></pre><h5 id="模糊查询"><a class="markdownIt-Anchor" href="#模糊查询"></a> 模糊查询</h5><ul><li>模糊查询的sqlMap.xml定义</li></ul><pre><code class="highlight xml"><span class="comment">&lt;!-- 模糊查询 --&gt;</span><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listProductByName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Product&quot;</span>&gt;</span>    select * from product where name like concat(&#x27;%&#x27;,#&#123;0&#125;,&#x27;%&#x27;)    <span class="comment">&lt;!--</span><span class="comment">        concat是MySQL的函数，用来连接字符串-</span><span class="comment">        Oracle语句：select * from product where name like &#x27;%&#x27;||#&#123;0&#125;||&#x27;%&#x27;</span><span class="comment">    --&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><ul><li>模糊查询java代码</li></ul><pre><code class="highlight java">List&lt;Product&gt; list1 = sqlSession.selectList(<span class="string">&quot;listProductByName&quot;</span>,<span class="string">&quot;橘&quot;</span>);<span class="keyword">for</span> (Product c:list1) &#123;    System.out.println(c.getId()+<span class="string">&quot;:&quot;</span>+c.getName()+<span class="string">&quot;:&quot;</span>+c.getPrice());&#125;</code></pre><h5 id="多条件查询"><a class="markdownIt-Anchor" href="#多条件查询"></a> 多条件查询</h5><ul><li>多参数查询可以使用Map</li><li>多条件查询sqlMap.xml</li></ul><pre><code class="highlight xml"><span class="comment">&lt;!-- 多条件查询 --&gt;</span><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listProductByNameAndId&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Product&quot;</span>&gt;</span>    select * from product where id&gt;#&#123;id&#125; and name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><ul><li>多条件查询java代码</li></ul><pre><code class="highlight java">Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();map.put(<span class="string">&quot;id&quot;</span>,<span class="number">4</span>);map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;橘&quot;</span>);List&lt;Product&gt; list2 = sqlSession.selectList(<span class="string">&quot;listProductByNameAndId&quot;</span>,map);<span class="keyword">for</span> (Product c: list2) &#123;    System.out.println(c.getId()+<span class="string">&quot;:&quot;</span>+c.getName()+<span class="string">&quot;:&quot;</span>+c.getPrice());&#125;</code></pre><h3 id="mybatis返回值的方式"><a class="markdownIt-Anchor" href="#mybatis返回值的方式"></a> Mybatis返回值的方式</h3><h4 id="resulttype"><a class="markdownIt-Anchor" href="#resulttype"></a> resultType</h4><ul><li>使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功</li><li>如果查询出来的列名和pojo中的属性名全部不一致，没有创建pojo对象</li><li>只要查询出来的列名和pojo中的属性有一个一致，就会创建pojo对象。</li></ul><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getProductById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Product&quot;</span>&gt;</span>        select * from product where id=#&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><h4 id="返回map类型查询结果"><a class="markdownIt-Anchor" href="#返回map类型查询结果"></a> 返回Map类型查询结果</h4><ul><li>SqlMap.xml映射定义</li></ul><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findDept&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.util.HashMap&quot;</span>&gt;</span>    select DEPTNO,DNAME from DEPT where DEPTNO=#&#123;no&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><ul><li>SqlSession用法</li></ul><pre><code class="highlight java"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sf.openSession();<span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> (Map)session.selectOne(<span class="string">&quot;findDept&quot;</span>,<span class="number">10</span>);System.out.println(map.get(<span class="string">&quot;DEPTNO&quot;</span>));System.out.println(map.get(<span class="string">&quot;DNAME&quot;</span>));</code></pre><h4 id="使用resultmap"><a class="markdownIt-Anchor" href="#使用resultmap"></a> 使用resultMap</h4><ul><li>在SqlMap.xml定义<select>操作时，如果查询结果字段名与Java POJO属性不一致时，需要使用<resultMap>元素显式指定映射关系</li></ul><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll1&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;deptMap&quot;</span>&gt;</span>    select DEPTNO,DNAME,LOC from DEPT<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;deptMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;org.tarena.entity.Dept&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;no&quot;</span> <span class="attr">column</span>=<span class="string">&quot;DEPTNO&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;DNAME&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;loc&quot;</span> <span class="attr">column</span>=<span class="string">&quot;LOC&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre><h5 id="一对多"><a class="markdownIt-Anchor" href="#一对多"></a> 一对多</h5><ul><li>Product类</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.mybatis1.entity;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/5/23.</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> id ;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> <span class="type">double</span> price;    <span class="keyword">private</span> <span class="type">int</span> groups;        <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">()</span>&#123;    &#125;    <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">double</span> price,<span class="type">int</span> groups)</span> &#123;        <span class="built_in">this</span>.id = id;        <span class="built_in">this</span>.name = name;        <span class="built_in">this</span>.price = price;        <span class="built_in">this</span>.groups = groups;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;        <span class="keyword">return</span> price;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;        <span class="built_in">this</span>.price = price;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getGroups</span><span class="params">()</span> &#123;        <span class="keyword">return</span> groups;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGroups</span><span class="params">(<span class="type">int</span> groups)</span> &#123;        <span class="built_in">this</span>.groups = groups;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Product&#123;&quot;</span> +                <span class="string">&quot;id=&quot;</span> + id +                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +                <span class="string">&quot;, price=&quot;</span> + price +                <span class="string">&quot;, groups=&quot;</span> + groups +                <span class="string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre><ul><li>Category类<ul><li>该类中有个成员变量为Product对象的list集合</li></ul></li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.mybatis1.entity;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * 数据库表实体类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Category</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> id ;    <span class="keyword">private</span> String name ;    <span class="keyword">private</span> List&lt;Product&gt; products;    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;    <span class="keyword">public</span> List&lt;Product&gt; <span class="title function_">getProducts</span><span class="params">()</span> &#123;        <span class="keyword">return</span> products;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProducts</span><span class="params">(List&lt;Product&gt; products)</span> &#123;        <span class="built_in">this</span>.products = products;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Category&#123;&quot;</span> +                <span class="string">&quot;id=&quot;</span> + id +                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span>;    &#125;&#125;</code></pre><ul><li>Category.xml<ul><li>通过left join关联查询，对Category和Product表进行关联查询</li></ul></li></ul><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="comment">&lt;!-- namespace表示命名空间，后续调用sql语句的时候会用到 --&gt;</span><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.lee.mybatis1.CategorySpace&quot;</span>&gt;</span>    <span class="comment">&lt;!--使用resultMap可以--&gt;</span>    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;categoryBean&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Category&quot;</span>&gt;</span>    <span class="comment">&lt;!--column表示数据库字段名，property表示类成员变量名--&gt;</span>    <span class="comment">&lt;!--id为数据库主键，result为普通字段--&gt;</span>        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span>                        <span class="comment">&lt;!--一对多</span><span class="comment">            collection表示一个集合</span><span class="comment">            collection中属性：</span><span class="comment">            property：表示products为Category类中的一个成员变量，相当于上一句result中的property</span><span class="comment">            ofType：表示这个成员变量集合元素是什么类型</span><span class="comment">            column：填写临时表中来自于一方表主键字段名，即临时表的主键，例如：该员工都属于10部门，10就是该临时表的主键</span><span class="comment">        --&gt;</span>        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;products&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Product&quot;</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;pid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span>            <span class="comment">&lt;!--如果字段名与Java实体类名相同，可以不写下面的result，框架会自动映射--&gt;</span>            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span>            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;price&quot;</span> <span class="attr">property</span>=<span class="string">&quot;price&quot;</span>/&gt;</span>            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;groups&quot;</span> <span class="attr">property</span>=<span class="string">&quot;groups&quot;</span>/&gt;</span>        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span>    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span><span class="comment">&lt;!--下面查询自动映射到上述resultMap中--&gt;</span>    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listCategory&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;categoryBean&quot;</span>&gt;</span>        select  c.id &#x27;cid&#x27;, c.name &#x27;cname&#x27;, p.id &#x27;pid&#x27;, p.name &#x27;pname&#x27;,p.price,p.groups from Category c left join Product p on c.id=p.groups    <span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></code></pre><ul><li>测试运行</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);    <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession();      List&lt;Category&gt; cs = session.selectList(<span class="string">&quot;listCategory&quot;</span>);    <span class="keyword">for</span> (Category c : cs) &#123;        System.out.println(c);        List&lt;Product&gt; ps = c.getProducts();        <span class="keyword">for</span> (Product p : ps) &#123;            System.out.println(<span class="string">&quot;\t&quot;</span>+p);        &#125;    &#125;    session.commit();    session.close();</code></pre><h5 id="一对多级联查询"><a class="markdownIt-Anchor" href="#一对多级联查询"></a> 一对多级联查询</h5><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;deptMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;dept&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;dept_depno&quot;</span> <span class="attr">property</span>=<span class="string">&quot;deptNo&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dname&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;loc&quot;</span> <span class="attr">property</span>=<span class="string">&quot;loc&quot;</span>/&gt;</span>    <span class="comment">&lt;!--empList变量通过链接一个子查询获得，关联子查询的条件变量就是column中的字段--&gt;</span>    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;empList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;employee&quot;</span> <span class="attr">select</span>=<span class="string">&quot;empFindByDeptno&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_deptno&quot;</span>&gt;</span>    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span><span class="comment">&lt;!--级联查询--&gt;</span><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;empFindBydeptno&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span>    select empno,ename,job from emp where deptno=#&#123;deptno&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="comment">&lt;!--主查询--&gt;</span><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;deptFindBydeptno&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;deptMap&quot;</span>&gt;</span>    select deptno dept_deptno,dname,loc from dept where deptno=#&#123;deptno&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><blockquote><p><strong>此种方式会与数据库建立两次连接，会影响效率</strong></p></blockquote><blockquote><p><strong>如果设置了延迟加载，那么这种方式会更快一点</strong></p></blockquote><h5 id="多对一"><a class="markdownIt-Anchor" href="#多对一"></a> 多对一</h5><ul><li>Category类</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.mybatis1.entity;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * 数据库表实体类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Category</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> id ;    <span class="keyword">private</span> String name ;<span class="comment">//    private List&lt;Product&gt; products;</span>    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;<span class="comment">//    public List&lt;Product&gt; getProducts() &#123;</span><span class="comment">//        return products;</span><span class="comment">//    &#125;</span><span class="comment">//</span><span class="comment">//    public void setProducts(List&lt;Product&gt; products) &#123;</span><span class="comment">//        this.products = products;</span><span class="comment">//    &#125;</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Category&#123;&quot;</span> +                <span class="string">&quot;id=&quot;</span> + id +                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span>;    &#125;&#125;</code></pre><ul><li>Product类<ul><li>新增字段Category,让Product类中包含Category，即一对多，Product类于Category中的成员变量是<strong>一对多</strong>的关系</li></ul></li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.mybatis1.entity;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/5/23.</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> id ;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> <span class="type">double</span> price;    <span class="keyword">private</span> <span class="type">int</span> groups;    <span class="keyword">private</span> Category category;        <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">()</span>&#123;    &#125;    <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">double</span> price,<span class="type">int</span> groups)</span> &#123;        <span class="built_in">this</span>.id = id;        <span class="built_in">this</span>.name = name;        <span class="built_in">this</span>.price = price;        <span class="built_in">this</span>.groups = groups;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;        <span class="keyword">return</span> price;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;        <span class="built_in">this</span>.price = price;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getGroups</span><span class="params">()</span> &#123;        <span class="keyword">return</span> groups;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGroups</span><span class="params">(<span class="type">int</span> groups)</span> &#123;        <span class="built_in">this</span>.groups = groups;    &#125;    <span class="keyword">public</span> Category <span class="title function_">getCategory</span><span class="params">()</span> &#123;        <span class="keyword">return</span> category;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCategory</span><span class="params">(Category category)</span> &#123;        <span class="built_in">this</span>.category = category;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Product&#123;&quot;</span> +                <span class="string">&quot;id=&quot;</span> + id +                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +                <span class="string">&quot;, price=&quot;</span> + price +                <span class="string">&quot;, groups=&quot;</span> + groups +                <span class="string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre><ul><li>Product.xml</li></ul><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;productBean&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Product&quot;</span>&gt;</span>     <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span>     <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span>     <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;price&quot;</span> <span class="attr">property</span>=<span class="string">&quot;price&quot;</span>/&gt;</span>     <span class="comment">&lt;!--多对一--&gt;</span>     <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;category&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Category&quot;</span>&gt;</span>         <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span>         <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span>     <span class="tag">&lt;/<span class="name">association</span>&gt;</span> <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span> <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listProduct2&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;productBean&quot;</span>&gt;</span>     select p.*,c.id &#x27;cid&#x27;,c.name &#x27;cname&#x27; from category c left join product p on c.id = p.groups <span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><ul><li>测试运行</li></ul><pre><code class="highlight java">List&lt;Product&gt; list5 =  sqlSession.selectList(<span class="string">&quot;listProduct2&quot;</span>);<span class="keyword">for</span> (Product p:list5) &#123;    System.out.println(p+<span class="string">&quot;:::::::&quot;</span>+p.getCategory());&#125;</code></pre><h5 id="多对多"><a class="markdownIt-Anchor" href="#多对多"></a> 多对多</h5><ul><li>假设有一个订单类Order，有一个产品类Products，一个关联订单和产品的OrderItem类</li><li>Order</li></ul><pre><code class="highlight java"><span class="keyword">import</span> java.util.List;<span class="comment">//订单类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> id;    <span class="keyword">private</span> String code;         List&lt;OrderItem&gt; orderItems;         <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;    <span class="keyword">public</span> String <span class="title function_">getCode</span><span class="params">()</span> &#123;        <span class="keyword">return</span> code;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(String code)</span> &#123;        <span class="built_in">this</span>.code = code;    &#125;    <span class="keyword">public</span> List&lt;OrderItem&gt; <span class="title function_">getOrderItems</span><span class="params">()</span> &#123;        <span class="keyword">return</span> orderItems;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderItems</span><span class="params">(List&lt;OrderItem&gt; orderItems)</span> &#123;        <span class="built_in">this</span>.orderItems = orderItems;    &#125;&#125;</code></pre><ul><li>OrderItem</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderItem</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> id;    <span class="comment">//数量</span>    <span class="keyword">private</span> <span class="type">int</span> number;    <span class="comment">//订单</span>    <span class="keyword">private</span> Order order;    <span class="comment">//产品</span>    <span class="keyword">private</span> Product product;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span> &#123;        <span class="keyword">return</span> number;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">(<span class="type">int</span> number)</span> &#123;        <span class="built_in">this</span>.number = number;    &#125;    <span class="keyword">public</span> Order <span class="title function_">getOrder</span><span class="params">()</span> &#123;        <span class="keyword">return</span> order;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrder</span><span class="params">(Order order)</span> &#123;        <span class="built_in">this</span>.order = order;    &#125;    <span class="keyword">public</span> Product <span class="title function_">getProduct</span><span class="params">()</span> &#123;        <span class="keyword">return</span> product;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProduct</span><span class="params">(Product product)</span> &#123;        <span class="built_in">this</span>.product = product;    &#125;     &#125;</code></pre><ul><li>Product</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;<span class="comment">//在实体类中存的是对象，数据库表中存的是对象id</span>    <span class="keyword">private</span> <span class="type">int</span> id ;    <span class="comment">//产品名</span>    <span class="keyword">private</span> String name;    <span class="comment">//产品价格</span>    <span class="keyword">private</span> <span class="type">double</span> price;    <span class="comment">//产品分类</span>    <span class="keyword">private</span> <span class="type">int</span> groups;    <span class="comment">//产品分类详细信息</span>    <span class="keyword">private</span> Category category;        <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">()</span>&#123;    &#125;    <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">double</span> price,<span class="type">int</span> groups)</span> &#123;        <span class="built_in">this</span>.id = id;        <span class="built_in">this</span>.name = name;        <span class="built_in">this</span>.price = price;        <span class="built_in">this</span>.groups = groups;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;        <span class="keyword">return</span> price;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;        <span class="built_in">this</span>.price = price;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getGroups</span><span class="params">()</span> &#123;        <span class="keyword">return</span> groups;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGroups</span><span class="params">(<span class="type">int</span> groups)</span> &#123;        <span class="built_in">this</span>.groups = groups;    &#125;    <span class="keyword">public</span> Category <span class="title function_">getCategory</span><span class="params">()</span> &#123;        <span class="keyword">return</span> category;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCategory</span><span class="params">(Category category)</span> &#123;        <span class="built_in">this</span>.category = category;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Product&#123;&quot;</span> +                <span class="string">&quot;id=&quot;</span> + id +                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +                <span class="string">&quot;, price=&quot;</span> + price +                <span class="string">&quot;, groups=&quot;</span> + groups +                <span class="string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre><ul><li>Order.xml</li></ul><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.lee.mybatis1.entity.Order&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;Order&quot;</span> <span class="attr">id</span>=<span class="string">&quot;orderBean&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;oid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span>        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;code&quot;</span> <span class="attr">property</span>=<span class="string">&quot;code&quot;</span> /&gt;</span>        <span class="comment">&lt;!--多对多</span><span class="comment">            订单有一个OrderItem的List</span><span class="comment">        --&gt;</span>        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orderItems&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;OrderItem&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;oiid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span>            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;number&quot;</span> <span class="attr">property</span>=<span class="string">&quot;number&quot;</span> /&gt;</span>            <span class="comment">&lt;!--OrderItem类中又有一个Product对象--&gt;</span>            <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;product&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Product&quot;</span>&gt;</span>                <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;pid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;price&quot;</span> <span class="attr">property</span>=<span class="string">&quot;price&quot;</span>/&gt;</span>            <span class="tag">&lt;/<span class="name">association</span>&gt;</span>                    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span>    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span><span class="comment">&lt;!--三个表关联查询出所有信息，mybait会自动插入对应的resultMap--&gt;</span>    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listOrder&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;orderBean&quot;</span>&gt;</span>        select o.*,p.*,oi.*, o.id &#x27;oid&#x27;, p.id &#x27;pid&#x27;, oi.id &#x27;oiid&#x27;, p.name &#x27;pname&#x27;        from order_item oi        left join orders o on oi.oid =o.id        left join product p on  oi.pid =p.groups    <span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></code></pre><ul><li>OrderItem</li></ul><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.lee.mybatis1.entity&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addOrderItem&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;OrderItem&quot;</span>&gt;</span>    <span class="comment">&lt;!--表中只能存储对象的id--&gt;</span>        insert into order_item_        values(null,#&#123;order.id&#125;,#&#123;product.id&#125;,#&#123;number&#125;)    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span>        <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;deleteOrderItem&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;OrderItem&quot;</span>&gt;</span>        delete from order_item_        where oid = #&#123;order.id&#125; and pid = #&#123;product.id&#125;    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></code></pre><ul><li>Product.xml</li></ul><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="comment">&lt;!-- namespace表示命名空间，后续调用sql语句的时候会用到 --&gt;</span><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.lee.mybatis1.ProductSpace&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;productBean&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Product&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;price&quot;</span> <span class="attr">property</span>=<span class="string">&quot;price&quot;</span>/&gt;</span>        <span class="comment">&lt;!--多对一--&gt;</span>        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;category&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Category&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span>            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span>        <span class="tag">&lt;/<span class="name">association</span>&gt;</span>    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span>    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listProduct2&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;productBean&quot;</span>&gt;</span>        select p.*,c.id &#x27;cid&#x27;,c.name &#x27;cname&#x27; from category c left join product p on c.id = p.groups    <span class="tag">&lt;/<span class="name">select</span>&gt;</span>    <span class="comment">&lt;!--不写parameterType好像也可以传入一些简单的值--&gt;</span>    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getProduct&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;productBean&quot;</span>&gt;</span>        select c.*, p.*, c.id &#x27;cid&#x27;, p.id &#x27;pid&#x27;, c.name &#x27;cname&#x27;, p.name &#x27;pname&#x27;        from category c        left join product p on c.id = p.groups        where p.id = #&#123;id&#125;    <span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></code></pre><ul><li>修改mybatis-config.xml</li></ul><pre><code class="highlight xml">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/how2java/pojo/Order.xml&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/how2java/pojo/OrderItem.xml&quot;</span>/&gt;</span></code></pre><ul><li><strong>查询操作</strong></li></ul><pre><code class="highlight java">List&lt;Order&gt; os = session.selectList(<span class="string">&quot;listOrder&quot;</span>);       <span class="keyword">for</span> (Order o : os) &#123;           System.out.println(o.getCode());           List&lt;OrderItem&gt; ois= o.getOrderItems();           <span class="keyword">for</span> (OrderItem oi : ois) &#123;               System.out.format(<span class="string">&quot;\t%s\t%f\t%d%n&quot;</span>, oi.getProduct().getName(),oi.getProduct().getPrice(),oi.getNumber());           &#125;       &#125;</code></pre><ul><li><strong>新增</strong></li></ul><pre><code class="highlight java"><span class="type">Order</span> <span class="variable">o1</span> <span class="operator">=</span> session.selectOne(<span class="string">&quot;getOrder&quot;</span>, <span class="number">1</span>);<span class="type">Product</span> <span class="variable">p6</span> <span class="operator">=</span> session.selectOne(<span class="string">&quot;getProduct&quot;</span>, <span class="number">6</span>);<span class="type">OrderItem</span> <span class="variable">oi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderItem</span>();oi.setProduct(p6);oi.setOrder(o1);oi.setNumber(<span class="number">200</span>); session.insert(<span class="string">&quot;addOrderItem&quot;</span>, oi);</code></pre><ul><li><strong>删除</strong></li></ul><pre><code class="highlight java">        <span class="type">Order</span> <span class="variable">o1</span> <span class="operator">=</span> session.selectOne(<span class="string">&quot;getOrder&quot;</span>,<span class="number">1</span>);        <span class="type">Product</span> <span class="variable">p6</span> <span class="operator">=</span> session.selectOne(<span class="string">&quot;getProduct&quot;</span>,<span class="number">6</span>);        <span class="type">OrderItem</span> <span class="variable">oi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderItem</span>();        oi.setProduct(p6);        oi.setOrder(o1);        session.delete(<span class="string">&quot;deleteOrderItem&quot;</span>, oi);</code></pre><h3 id="mybatis传参的四种方式"><a class="markdownIt-Anchor" href="#mybatis传参的四种方式"></a> Mybatis传参的四种方式</h3><ul><li><strong>parameterType</strong><ul><li>将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler） 推断出具体传入语句的参数，默认值为未设置（unset）</li></ul></li></ul><h4 id="顺序传参法"><a class="markdownIt-Anchor" href="#顺序传参法"></a> 顺序传参法</h4><ul><li><code>#&#123;index&#125;</code>表示传入参数的顺序</li></ul><pre><code class="highlight xml">public User selectUser(String name, int deptId); <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserResultMap&quot;</span>&gt;</span>         select * from user where user_name = #&#123;0&#125; and dept_id = #&#123;1&#125; <span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><h4 id="param注解传参法推荐"><a class="markdownIt-Anchor" href="#param注解传参法推荐"></a> @Param注解传参法(推荐)</h4><ul><li><code>#&#123;&#125;</code>表示名称对应的注解@Param括号里修饰的名称</li></ul><pre><code class="highlight xml">public User selectUser(@Param(&quot;userName&quot;) String name, int @Param(&quot;deptId&quot;) deptId); <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserResultMap&quot;</span>&gt;</span>        select * from user where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125; <span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><h4 id="map传参法推荐"><a class="markdownIt-Anchor" href="#map传参法推荐"></a> Map传参法(推荐)</h4><ul><li><code>#&#123;key&#125;</code>里面对应的是map里面的key</li></ul><pre><code class="highlight xml">public User selectUser(Map&lt;String, Object&gt; params); <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.util.Map&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserResultMap&quot;</span>&gt;</span>        select * from user where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125; <span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><h4 id="java-bean传参法"><a class="markdownIt-Anchor" href="#java-bean传参法"></a> Java Bean传参法</h4><ul><li><code>#&#123;&#125;</code>里面的名称对应的是User类里面的成员属性</li></ul><pre><code class="highlight xml">public User selectUser(Map&lt;String, Object&gt; params); <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.test.User&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserResultMap&quot;</span>&gt;</span>         select * from user where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125; <span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><h3 id="mybatis动态sql"><a class="markdownIt-Anchor" href="#mybatis动态sql"></a> Mybatis动态SQL</h3><h4 id="if标签"><a class="markdownIt-Anchor" href="#if标签"></a> if标签</h4><ul><li>如果Product的字段比较多的话，为了应付各个字段的查询，那么就要写多条sql语句，变得难以维护</li><li>这个时候，就可以使用Mybatis动态sql里的if标签，如果有传入参数name，就模糊查询，没有name，就查询所有</li></ul><p><strong>test表达式中的变量名必须和实体类中的变量名或Mapper形参 完全相同</strong></p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listProduct&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Product&quot;</span>&gt;</span>    select * from product_    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null and name!=&#x27;&#x27;&quot;</span>&gt;</span>        where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)    <span class="tag">&lt;/<span class="name">if</span>&gt;</span>     <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;loc!=null and loc!=&#x27;&#x27;&quot;</span>&gt;</span>        where loc like &#x27;%&#x27; #&#123;loc&#125; &#x27;%&#x27;    <span class="tag">&lt;/<span class="name">if</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><blockquote><p>如果没有传参数name,那么就查询所有，如果有name参数，那么就进行模糊查询</p></blockquote><ul><li>测试输出</li></ul><pre><code class="highlight java">System.out.println(<span class="string">&quot;查询所有的&quot;</span>);        List&lt;Product&gt; ps = session.selectList(<span class="string">&quot;listProduct&quot;</span>);        <span class="keyword">for</span> (Product p : ps) &#123;            System.out.println(p);        &#125;                          System.out.println(<span class="string">&quot;模糊查询&quot;</span>);        Map&lt;String,Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();        params.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;a&quot;</span>);        <span class="comment">//或者可以直接传入参数session.selectList(&quot;listProductByName&quot;,&quot;a&quot;);</span>        <span class="comment">//sqlmap.xml使用#&#123;0&#125;取值</span>        List&lt;Product&gt; ps2 = session.selectList(<span class="string">&quot;listProductByName&quot;</span>,params);        <span class="keyword">for</span> (Product p : ps2) &#123;            System.out.println(p);        &#125;                       session.commit();        session.close();</code></pre><h4 id="where标签"><a class="markdownIt-Anchor" href="#where标签"></a> where标签</h4><ul><li><strong>为什么要用where标签</strong><ul><li>如果要实现下述功能</li></ul></li></ul><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listProduct&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Product&quot;</span>&gt;</span>select * from product_<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null&quot;</span>&gt;</span>where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<span class="tag">&lt;/<span class="name">if</span>&gt;</span> <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;price!=0&quot;</span>&gt;</span>and price &gt; #&#123;price&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><ul><li>当有name参数但是没有price参数的时候，sql语句就会变成：<s>运行报错</s></li></ul><pre><code class="highlight sql"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product_ <span class="keyword">and</span> price <span class="operator">&gt;</span> <span class="number">10.</span></code></pre><ul><li>上述问题就可以<strong>使用<where>标签解决</strong></li></ul><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listProduct&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Product&quot;</span>&gt;</span>select * from product_<span class="tag">&lt;<span class="name">where</span>&gt;</span><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null&quot;</span>&gt;</span>and name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<span class="tag">&lt;/<span class="name">if</span>&gt;</span> <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;price!=null and price!=0&quot;</span>&gt;</span>and price &gt; #&#123;price&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span><span class="tag">&lt;/<span class="name">where</span>&gt;</span> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><blockquote><p><where>标签会进行自动判断<br />如果任何条件都不成立，那么就在sql语句里就不会出现where关键字<br />如果有任何条件成立，会自动去掉多出来的 and 或者 or</p></blockquote><ul><li>测试运行<br />* 无论是否供值都可以正常运行</li></ul><pre><code class="highlight xml">Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();map.put(&quot;name&quot;,&quot;手&quot;);map.put(&quot;price&quot;,50);List<span class="tag">&lt;<span class="name">Product</span>&gt;</span> list6 = sqlSession.selectList(&quot;listProductChoose&quot;,map);for(Product p:list6)&#123;    System.out.println(p.getName()+&quot;:&quot;+p.getId());&#125;</code></pre><h4 id="set标签"><a class="markdownIt-Anchor" href="#set标签"></a> set标签</h4><ul><li>用于update语句中</li></ul><pre><code class="highlight xml">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateProduct&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Product&quot;</span> &gt;</span>        update product_        <span class="tag">&lt;<span class="name">set</span>&gt;</span>            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span>name=#&#123;name&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span>            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;price != null&quot;</span>&gt;</span>price=#&#123;price&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span>                      <span class="tag">&lt;/<span class="name">set</span>&gt;</span>                  where id=#&#123;id&#125;       <span class="tag">&lt;/<span class="name">update</span>&gt;</span></code></pre><h4 id="trim标签"><a class="markdownIt-Anchor" href="#trim标签"></a> trim标签</h4><ul><li>trim用来定制想要的功能</li></ul><pre><code class="highlight xml">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateProduct&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Product&quot;</span> &gt;</span>        update product_        <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span>name=#&#123;name&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span>            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;price != null&quot;</span>&gt;</span>price=#&#123;price&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span>                      <span class="tag">&lt;/<span class="name">trim</span>&gt;</span>                  where id=#&#123;id&#125;       <span class="tag">&lt;/<span class="name">update</span>&gt;</span></code></pre><pre><code class="highlight xml">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listProduct&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Product&quot;</span>&gt;</span>        select * from product_        <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;WHERE&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;AND |OR &quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null&quot;</span>&gt;</span>                and name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)            <span class="tag">&lt;/<span class="name">if</span>&gt;</span>                    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;price!=null and price!=0&quot;</span>&gt;</span>                and price &gt; #&#123;price&#125;            <span class="tag">&lt;/<span class="name">if</span>&gt;</span>        <span class="tag">&lt;/<span class="name">trim</span>&gt;</span>          <span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><h4 id="choose"><a class="markdownIt-Anchor" href="#choose"></a> choose</h4><ul><li>mybatis中没有else标签，但是可以使用when otherwise标签来达到这样的效果</li></ul><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listProduct&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Product&quot;</span>&gt;</span>  SELECT * FROM product_   <span class="tag">&lt;<span class="name">where</span>&gt;</span>  <span class="tag">&lt;<span class="name">choose</span>&gt;</span>  <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span>    and name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)  <span class="tag">&lt;/<span class="name">when</span>&gt;</span>    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;price !=null and price != 0&quot;</span>&gt;</span>    and price &gt; #&#123;price&#125;  <span class="tag">&lt;/<span class="name">when</span>&gt;</span>      <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span>    and id &gt;1    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span>  <span class="tag">&lt;/<span class="name">choose</span>&gt;</span>  <span class="tag">&lt;/<span class="name">where</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><h4 id="foreach"><a class="markdownIt-Anchor" href="#foreach"></a> foreach</h4><ul><li>foreach标签通常用于in这样的语法里</li><li>foreach标签用于对集合含内容进行遍历，将得到内容作为SQL语句的一部分，实际开发过程中主要用于<strong>in语句</strong>的构建和<strong>批量添加</strong>操作</li></ul><blockquote><p><strong>item</strong>表示结合中每一个元素进行迭代的别名<br /><strong>index</strong>指定一个名字，用于表示在迭代过程中，每次迭代到的位置<br /><strong>open</strong>表示该语句以什么开始<br /><strong>separator</strong>表示每次进行迭代之间以什么符号作为分隔符<br /><strong>close</strong>表示以什么结束<br /><strong>collection</strong>表示传入参数集合类型</p></blockquote><h5 id="in语句"><a class="markdownIt-Anchor" href="#in语句"></a> in语句</h5><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listProduct&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Product&quot;</span>&gt;</span>      SELECT * FROM product_        WHERE ID in            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span></span><span class="tag">                <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span>                #&#123;item&#125;            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><ul><li>测试运行</li></ul><pre><code class="highlight java">        List&lt;Integer&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();        ids.add(<span class="number">1</span>);        ids.add(<span class="number">3</span>);        ids.add(<span class="number">5</span>);               List&lt;Product&gt; ps = session.selectList(<span class="string">&quot;listProduct&quot;</span>,ids);      <span class="keyword">for</span> (Product p : ps) &#123;          System.out.println(p);      &#125;</code></pre><h5 id="使用foreach实现批量添加"><a class="markdownIt-Anchor" href="#使用foreach实现批量添加"></a> 使用foreach实现批量添加</h5><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertDept&quot;</span>&gt;</span>    insert into dept (dname,loc) values    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span>        (#&#123;dept.dname&#125;,#&#123;dept.loc&#125;)    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></code></pre><p>接口方法：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptMapper</span>&#123;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insertDept</span> <span class="params">(List&lt;Dept&gt; dept)</span>;&#125;</code></pre><p>生成sql示例</p><pre><code class="highlight plaintext">insert into dept (dename,loc) values (&#x27;政府事业部&#x27;,&#x27;上海&#x27;),(&#x27;医院事业部&#x27;,&#x27;西安&#x27;)</code></pre><h5 id="使用foreach批量修改"><a class="markdownIt-Anchor" href="#使用foreach批量修改"></a> 使用foreach批量修改</h5><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;UPDATE_HOTEL_REAL_TIME_PRICE&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.util.List&quot;</span>&gt;</span>   <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;;&quot;</span>&gt;</span>       UPDATE VST_HOTEL_REAL_TIME_PRICE       <span class="tag">&lt;<span class="name">set</span>&gt;</span>           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;item.realTimePrice1 != null&quot;</span>&gt;</span>               REAL_TIME_PRICE1 = #&#123;item.realTimePrice1&#125;,           <span class="tag">&lt;/<span class="name">if</span>&gt;</span>           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;item.realTimePrice2 != null&quot;</span>&gt;</span>               REAL_TIME_PRICE2 = #&#123;item.realTimePrice2&#125;,           <span class="tag">&lt;/<span class="name">if</span>&gt;</span>           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;item.realTimeRemain1 != null&quot;</span>&gt;</span>               REAL_TIME_REMAIN1 = #&#123;item.realTimeRemain1&#125;,           <span class="tag">&lt;/<span class="name">if</span>&gt;</span>           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;item.realTimeRemain2 != null&quot;</span>&gt;</span>               REAL_TIME_REMAIN2 = #&#123;item.realTimeRemain2&#125;,           <span class="tag">&lt;/<span class="name">if</span>&gt;</span>           UPDATE_TIME = NOW()       <span class="tag">&lt;/<span class="name">set</span>&gt;</span>       WHERE PRODUCT_ID = $&#123;item.productId&#125;    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span><span class="tag">&lt;/<span class="name">update</span>&gt;</span></code></pre><h5 id="使用foreach遍历list集合作为查询条件"><a class="markdownIt-Anchor" href="#使用foreach遍历list集合作为查询条件"></a> 使用foreach遍历list集合作为查询条件</h5><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findForeachByList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;dept&quot;</span>&gt;</span>    select * from dept where deptno in    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;deptno&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span>        #&#123;deptno&#125;    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><p>接口方法：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptMapper</span>&#123;     <span class="keyword">public</span> List <span class="title function_">findForeachByList</span> <span class="params">(List deptNoList)</span>; &#125;</code></pre><h5 id="使用foreach遍历数组作为查询条件"><a class="markdownIt-Anchor" href="#使用foreach遍历数组作为查询条件"></a> 使用foreach遍历数组作为查询条件</h5><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findForeachByArray&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;dept&quot;</span>&gt;</span>    select * from dept where deptno in    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;array&quot;</span> <span class="attr">item</span>=<span class="string">&quot;deptno&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">sparator</span>=<span class="string">&quot;,&quot;</span>&gt;</span>        #&#123;deptno&#125;     <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span>        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><p>接口方法：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptMapper</span>&#123;     <span class="keyword">public</span> List <span class="title function_">findForeachByArray</span> <span class="params">(<span class="type">int</span>[] deptArray)</span>;     &#125;</code></pre><h5 id="使用foreach遍历map"><a class="markdownIt-Anchor" href="#使用foreach遍历map"></a> 使用foreach遍历Map</h5><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findForeachByMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;dept&quot;</span>&gt;</span>    select * from dept where deptno in    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;myMap.values&quot;</span> <span class="attr">item</span>=<span class="string">&quot;deptno&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>&quot;)&quot; <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span>        #&#123;deptno&#125;    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><p>接口方法：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptMapper</span>&#123;     <span class="keyword">public</span> List <span class="title function_">findForeachByMap</span> <span class="params">(<span class="meta">@Param(&quot;myMap&quot;)</span> Map map)</span>;     &#125;</code></pre><h4 id="bind标签"><a class="markdownIt-Anchor" href="#bind标签"></a> bind标签</h4><ul><li>bind标签就像在做一次字符串拼接，方便后续使用</li></ul><pre><code class="highlight xml">       <span class="comment">&lt;!-- 本来的模糊查询方式 --&gt;</span><span class="comment">&lt;!--         &lt;select id=&quot;listProduct&quot; resultType=&quot;Product&quot;&gt; --&gt;</span><span class="comment">&lt;!--             select * from   product_  where name like concat(&#x27;%&#x27;,#&#123;0&#125;,&#x27;%&#x27;) --&gt;</span><span class="comment">&lt;!--         &lt;/select&gt; --&gt;</span>                     <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listProduct&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Product&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">&quot;likename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#x27;%&#x27; + name + &#x27;%&#x27;&quot;</span> /&gt;</span>            select * from   product_  where name like #&#123;likename&#125;        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><h3 id="mybatis标签"><a class="markdownIt-Anchor" href="#mybatis标签"></a> mybatis标签</h3><h4 id="sql标签"><a class="markdownIt-Anchor" href="#sql标签"></a> sql标签</h4><p>如果某条语句的一部分是大量重复使用的，就可以使用sql标签</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;deptFindSql&quot;</span>&gt;</span>    select * from emp<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></code></pre><p>然后通过<include>标签注入</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByDeptNo&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;deptFindSql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span> where deptno=#&#123;deptno&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByDeptId&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;deptFindSql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span> where deptno=#&#123;deptid&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><h2 id="mybatis注解"><a class="markdownIt-Anchor" href="#mybatis注解"></a> Mybatis注解</h2><h3 id="注解crud"><a class="markdownIt-Anchor" href="#注解crud"></a> 注解CRUD</h3><h4 id="实体类-2"><a class="markdownIt-Anchor" href="#实体类-2"></a> 实体类</h4><pre><code class="highlight java"><span class="keyword">package</span> com.lee.mybatis1.entity;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * 数据库表实体类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Category</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> id ;    <span class="keyword">private</span> String name ;<span class="comment">//    private List&lt;Product&gt; products;</span>    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;<span class="comment">//    public List&lt;Product&gt; getProducts() &#123;</span><span class="comment">//        return products;</span><span class="comment">//    &#125;</span><span class="comment">//</span><span class="comment">//    public void setProducts(List&lt;Product&gt; products) &#123;</span><span class="comment">//        this.products = products;</span><span class="comment">//    &#125;</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Category&#123;&quot;</span> +                <span class="string">&quot;id=&quot;</span> + id +                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span>;    &#125;&#125;</code></pre><h4 id="新增mapper接口"><a class="markdownIt-Anchor" href="#新增mapper接口"></a> 新增mapper接口</h4><ul><li>该接口就相当于Category.xml配置文件</li><li>其实就是把sql语句从xml挪到了注解上</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.mybatis1.entity;<span class="keyword">import</span> org.apache.ibatis.annotations.Delete;<span class="keyword">import</span> org.apache.ibatis.annotations.Insert;<span class="keyword">import</span> org.apache.ibatis.annotations.Select;<span class="keyword">import</span> org.apache.ibatis.annotations.Update;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * 这个类就相当于Category.xml，都是一样的</span><span class="comment"> * 要想使用这个类也需要在mybatis-config.xml中配置</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CategoryMapper</span> &#123;    <span class="meta">@Insert(&quot;insert into category (name) values (#&#123;name&#125;)&quot;)</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addCategory</span><span class="params">(Category category)</span>;    <span class="meta">@Delete(&quot;delete from category where id = #&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteCategory</span><span class="params">(<span class="type">int</span> i)</span>;    <span class="meta">@Select(&quot;select * from category where id = #&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> Category <span class="title function_">getCategory</span><span class="params">(<span class="type">int</span> id)</span>;    <span class="meta">@Update(&quot;update category set name = #&#123;name&#125; where id = #&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateCategory</span><span class="params">(Category category)</span>;    <span class="meta">@Select(&quot;select * from category&quot;)</span>    <span class="keyword">public</span> List&lt;Category&gt; <span class="title function_">listCategory</span><span class="params">()</span>;&#125;</code></pre><blockquote><p><strong>或者也可以不写注解</strong><br />只写一个Java接口，不写注解，方法名与xml文件中的id相对应，也可使用mapper调用</p></blockquote><h4 id="在mybatis-configxml中配置"><a class="markdownIt-Anchor" href="#在mybatis-configxml中配置"></a> 在mybatis-config.xml中配置</h4><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>    <span class="comment">&lt;!-- 配置自动扫描com.lee.mybatis1.entity包下的类型，使得在后续配置文件Category.xml中使用resultType的时候可以直接使用Category</span><span class="comment">     而不用写全路径com.lee.mybaits1.entity.Category--&gt;</span>    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span>        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.lee.mybatis1.entity&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span>    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span>            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/lee_test?characterEncoding=UTF-8&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span>            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span>    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span>    <span class="comment">&lt;!--映射Catrgory.xml--&gt;</span>    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/lee/mybatis1/entity/Category.xml&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/lee/mybatis1/entity/Product.xml&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/lee/mybatis1/entity/OrderItem.xml&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/lee/mybatis1/entity/Order.xml&quot;</span>/&gt;</span>新增-------------------------------------------------------        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.lee.mybatis1.entity.CategoryMapper&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span>------------------------------------------------------------<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></code></pre><h4 id="使用mapper调用"><a class="markdownIt-Anchor" href="#使用mapper调用"></a> 使用mapper调用</h4><pre><code class="highlight java"><span class="keyword">package</span> com.lee.mybatis1.test;<span class="keyword">import</span> com.lee.mybatis1.entity.Category;<span class="keyword">import</span> com.lee.mybatis1.entity.CategoryMapper;<span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;<span class="keyword">import</span> org.apache.ibatis.io.Resources;<span class="keyword">import</span> org.apache.ibatis.session.SqlSession;<span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<span class="keyword">import</span> java.io.IOException;<span class="keyword">import</span> java.io.InputStream;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/5/27.</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMybatis2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();        <span class="comment">//使用注解方式在这里要加一行语句</span>        <span class="comment">// sqlSession.getMapper(CategoryMapper.class)应该相当于根据接口方法和注解中的sql语句，使用Java反射生成一个封装好的实现类</span>        <span class="comment">//内部实现了</span>        <span class="type">CategoryMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(CategoryMapper.class);        <span class="type">Category</span> <span class="variable">category</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Category</span>();        <span class="comment">//增加</span>        category.setName(<span class="string">&quot;公关部&quot;</span>);        mapper.addCategory(category);        <span class="comment">//获取</span>        <span class="type">Category</span> <span class="variable">category1</span> <span class="operator">=</span> mapper.getCategory(<span class="number">6</span>);        System.out.println(category1);        <span class="comment">//修改</span>        <span class="type">Category</span> <span class="variable">category2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Category</span>();        category2.setName(<span class="string">&quot;哈哈部&quot;</span>);        category2.setId(<span class="number">6</span>);        mapper.updateCategory(category2);        <span class="comment">//删除</span>        mapper.deleteCategory(<span class="number">6</span>);        <span class="comment">//获取list</span>        List&lt;Category&gt; list = mapper.listCategory();        <span class="keyword">for</span> (Category c : list) &#123;            System.out.println(c);        &#125;    &#125;&#125;</code></pre><h3 id="注解-一对多"><a class="markdownIt-Anchor" href="#注解-一对多"></a> 注解 一对多</h3><ul><li>使用<code>@Many</code>关键字</li></ul><h4 id="实体类-3"><a class="markdownIt-Anchor" href="#实体类-3"></a> 实体类</h4><pre><code class="highlight java"><span class="keyword">package</span> com.lee.mybatis1.entity;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * 数据库表实体类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Category</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> id ;    <span class="keyword">private</span> String name ;    <span class="keyword">private</span> List&lt;Product&gt; products;    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;    <span class="keyword">public</span> List&lt;Product&gt; <span class="title function_">getProducts</span><span class="params">()</span> &#123;        <span class="keyword">return</span> products;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProducts</span><span class="params">(List&lt;Product&gt; products)</span> &#123;        <span class="built_in">this</span>.products = products;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Category&#123;&quot;</span> +                <span class="string">&quot;id=&quot;</span> + id +                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span>;    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="keyword">package</span> com.lee.mybatis1.entity;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/5/23.</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> id ;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> <span class="type">double</span> price;    <span class="keyword">private</span> <span class="type">int</span> groups;    <span class="keyword">private</span> Category category;    <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">()</span>&#123;    &#125;    <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">double</span> price,<span class="type">int</span> groups)</span> &#123;        <span class="built_in">this</span>.id = id;        <span class="built_in">this</span>.name = name;        <span class="built_in">this</span>.price = price;        <span class="built_in">this</span>.groups = groups;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;        <span class="keyword">return</span> price;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;        <span class="built_in">this</span>.price = price;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getGroups</span><span class="params">()</span> &#123;        <span class="keyword">return</span> groups;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGroups</span><span class="params">(<span class="type">int</span> groups)</span> &#123;        <span class="built_in">this</span>.groups = groups;    &#125;    <span class="keyword">public</span> Category <span class="title function_">getCategory</span><span class="params">()</span> &#123;        <span class="keyword">return</span> category;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCategory</span><span class="params">(Category category)</span> &#123;        <span class="built_in">this</span>.category = category;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Product&#123;&quot;</span> +                <span class="string">&quot;id=&quot;</span> + id +                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +                <span class="string">&quot;, price=&quot;</span> + price +                <span class="string">&quot;, groups=&quot;</span> + groups +                <span class="string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre><h4 id="定义mapper接口"><a class="markdownIt-Anchor" href="#定义mapper接口"></a> 定义mapper接口</h4><ul><li>CategoryMapper接口<ul><li><code>column</code>表示数据库字段名</li><li><code>property</code>表示成员变量名</li><li><code>javaType</code>表示成员变量类型，基本类型不用特别标注</li></ul></li></ul><blockquote><p>数据库字段名于实体类成员变量名<strong>不同</strong>的需要特别标注。<br />数据库字段<strong>多次</strong>使用赋值的要特别标注。<br />成员变量类型特殊的(List)需要特别标注</p></blockquote><pre><code class="highlight java"><span class="keyword">package</span> com.lee.mybatis1.entity;<span class="keyword">import</span> org.apache.ibatis.annotations.Many;<span class="keyword">import</span> org.apache.ibatis.annotations.Result;<span class="keyword">import</span> org.apache.ibatis.annotations.Results;<span class="keyword">import</span> org.apache.ibatis.annotations.Select;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/5/28.</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CategoryMapper2</span> &#123;    <span class="meta">@Select(&quot;select * from category&quot;)</span>    <span class="meta">@Results(&#123;</span><span class="meta">            //column表示数据库字段名，property表示成员变量名，javaType表示成员变量类型，基本类型不用特别标注</span><span class="meta">            //如果一个字段多次使用，必须标注每次查询要传递给哪个字段，这个例子就是第一行和第三行各用了一次id，如果不标注，就会查询出null</span><span class="meta">            //像name字段名和成员变量名相同，也只用了一次，就不用特别标注，框架会自动入参</span><span class="meta">            @Result(property = &quot;id&quot; , column = &quot;id&quot;),</span><span class="meta">            @Result(property = &quot;name&quot; , column = &quot;name&quot;),</span><span class="meta">            //@Results 通过@Result和@Many中调用ProductMapper.listByCategory()方法相结合，来获取一对多关系</span><span class="meta">            @Result(property = &quot;products&quot; , javaType = List.class , column = &quot;id&quot; , many = @Many(select =</span><span class="meta">                    &quot;com.lee.mybatis1.entity.ProductMapper.listByCategory&quot;))</span><span class="meta">    &#125;)</span>    <span class="keyword">public</span> List&lt;Category&gt; <span class="title function_">listCategory</span><span class="params">()</span>;&#125;</code></pre><ul><li>ProductMapper</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.mybatis1.entity;<span class="keyword">import</span> org.apache.ibatis.annotations.Select;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/5/28.</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductMapper</span> &#123;    <span class="meta">@Select(&quot;select * from Product where groups = #&#123;cid&#125;&quot;)</span>    <span class="keyword">public</span> List&lt;Product&gt; <span class="title function_">listByCategory</span><span class="params">(<span class="type">int</span> cid)</span>;&#125;</code></pre><h5 id="在mybatis-configxml中定义"><a class="markdownIt-Anchor" href="#在mybatis-configxml中定义"></a> 在mybatis-config.xml中定义</h5><pre><code class="highlight xml"> <span class="tag">&lt;<span class="name">mappers</span>&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.lee.mybatis1.entity.CategoryMapper2&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.lee.mybatis1.entity.ProductMapper&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></code></pre><h4 id="测试运行"><a class="markdownIt-Anchor" href="#测试运行"></a> 测试运行</h4><pre><code class="highlight java"><span class="keyword">package</span> com.lee.mybatis1.test;<span class="keyword">import</span> com.lee.mybatis1.entity.Category;<span class="keyword">import</span> com.lee.mybatis1.entity.CategoryMapper2;<span class="keyword">import</span> com.lee.mybatis1.entity.Product;<span class="keyword">import</span> org.apache.ibatis.io.Resources;<span class="keyword">import</span> org.apache.ibatis.session.SqlSession;<span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<span class="keyword">import</span> java.io.InputStream;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * Created by liboar on 2019/5/28.</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMybatis3</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();        <span class="type">CategoryMapper2</span> <span class="variable">categoryMapper2</span> <span class="operator">=</span> sqlSession.getMapper(CategoryMapper2.class);        List&lt;Category&gt; list = categoryMapper2.listCategory();        <span class="keyword">for</span> (Category c: list) &#123;            System.out.println(c.getId()+<span class="string">&quot;-&quot;</span>+c.getName());;            <span class="keyword">for</span> (Product p:c.getProducts()) &#123;                System.out.println(p);            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="注解-多对一"><a class="markdownIt-Anchor" href="#注解-多对一"></a> 注解 多对一</h3><ul><li>即 <strong>一</strong> 个类型里包含另一个类型（<strong>多</strong>个字段）</li><li>使用<code>@One</code>关键字</li></ul><h4 id="实体类-4"><a class="markdownIt-Anchor" href="#实体类-4"></a> 实体类</h4><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Category</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> id ;    <span class="keyword">private</span> String name ;<span class="comment">//    private List&lt;Product&gt; products;</span>    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;<span class="comment">//    public List&lt;Product&gt; getProducts() &#123;</span><span class="comment">//        return products;</span><span class="comment">//    &#125;</span><span class="comment">//</span><span class="comment">//    public void setProducts(List&lt;Product&gt; products) &#123;</span><span class="comment">//        this.products = products;</span><span class="comment">//    &#125;</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Category&#123;&quot;</span> +                <span class="string">&quot;id=&quot;</span> + id +                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span>;    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> id ;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> <span class="type">double</span> price;    <span class="keyword">private</span> <span class="type">int</span> groups;    <span class="keyword">private</span> Category category;    <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">()</span>&#123;    &#125;    <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">double</span> price,<span class="type">int</span> groups)</span> &#123;        <span class="built_in">this</span>.id = id;        <span class="built_in">this</span>.name = name;        <span class="built_in">this</span>.price = price;        <span class="built_in">this</span>.groups = groups;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;        <span class="keyword">return</span> price;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;        <span class="built_in">this</span>.price = price;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getGroups</span><span class="params">()</span> &#123;        <span class="keyword">return</span> groups;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGroups</span><span class="params">(<span class="type">int</span> groups)</span> &#123;        <span class="built_in">this</span>.groups = groups;    &#125;    <span class="keyword">public</span> Category <span class="title function_">getCategory</span><span class="params">()</span> &#123;        <span class="keyword">return</span> category;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCategory</span><span class="params">(Category category)</span> &#123;        <span class="built_in">this</span>.category = category;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Product&#123;&quot;</span> +                <span class="string">&quot;id=&quot;</span> + id +                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +                <span class="string">&quot;, price=&quot;</span> + price +                <span class="string">&quot;, groups=&quot;</span> + groups +                <span class="string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre><h4 id="定义mapper"><a class="markdownIt-Anchor" href="#定义mapper"></a> 定义mapper</h4><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CategoryMapper3</span> &#123;    <span class="meta">@Select(&quot;select * from category where id = #&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> Category <span class="title function_">getCategory</span><span class="params">(<span class="type">int</span> id)</span>;&#125;</code></pre><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductMapper2</span> &#123;    <span class="meta">@Select(&quot;select * from product&quot;)</span>    <span class="meta">@Results(&#123;</span><span class="meta">            //其他成员变量名于数据库字段相同的都不用特别说明</span><span class="meta">            @Result(property=&quot;groups&quot; , column = &quot;groups&quot;),</span><span class="meta">            @Result(property=&quot;category&quot; , column=&quot;groups&quot; ,one=@One(select=&quot;com.lee.mybatis1.entity.CategoryMapper3.getCategory&quot;))</span><span class="meta">    &#125;)</span>    <span class="keyword">public</span> List&lt;Product&gt; <span class="title function_">listProduct</span><span class="params">()</span>;&#125;</code></pre><h4 id="配置mybatis-configxml"><a class="markdownIt-Anchor" href="#配置mybatis-configxml"></a> 配置mybatis-config.xml</h4><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.lee.mybatis1.entity.CategoryMapper3&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.lee.mybatis1.entity.ProductMapper2&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></code></pre><h4 id="测试运行-2"><a class="markdownIt-Anchor" href="#测试运行-2"></a> 测试运行</h4><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();    <span class="type">ProductMapper2</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ProductMapper2.class);    List&lt;Product&gt; list = mapper.listProduct();    <span class="keyword">for</span> (Product p:list) &#123;        System.out.println(p+<span class="string">&quot;--&quot;</span>+p.getCategory().getId()+<span class="string">&quot;:&quot;</span>+p.getCategory().getName())；    &#125;&#125;</code></pre><h3 id="注解-多对多"><a class="markdownIt-Anchor" href="#注解-多对多"></a> 注解 多对多</h3><h4 id="实体类-5"><a class="markdownIt-Anchor" href="#实体类-5"></a> 实体类</h4><pre><code class="highlight java"><span class="keyword">package</span> com.lee.mybatis1.entity;<span class="keyword">import</span> java.util.List;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> id;    <span class="keyword">private</span> String code;    List&lt;OrderItem&gt; orderItems;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;    <span class="keyword">public</span> String <span class="title function_">getCode</span><span class="params">()</span> &#123;        <span class="keyword">return</span> code;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(String code)</span> &#123;        <span class="built_in">this</span>.code = code;    &#125;    <span class="keyword">public</span> List&lt;OrderItem&gt; <span class="title function_">getOrderItems</span><span class="params">()</span> &#123;        <span class="keyword">return</span> orderItems;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderItems</span><span class="params">(List&lt;OrderItem&gt; orderItems)</span> &#123;        <span class="built_in">this</span>.orderItems = orderItems;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Order&#123;&quot;</span> +                <span class="string">&quot;id=&quot;</span> + id +                <span class="string">&quot;, code=&#x27;&quot;</span> + code + <span class="string">&#x27;\&#x27;&#x27;</span> +                <span class="string">&quot;, orderItems=&quot;</span> + orderItems +                <span class="string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="keyword">package</span> com.lee.mybatis1.entity;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderItem</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> id;    <span class="keyword">private</span> <span class="type">int</span> number;    <span class="keyword">private</span> Order order;    <span class="keyword">private</span> Product product;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span> &#123;        <span class="keyword">return</span> number;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">(<span class="type">int</span> number)</span> &#123;        <span class="built_in">this</span>.number = number;    &#125;    <span class="keyword">public</span> Order <span class="title function_">getOrder</span><span class="params">()</span> &#123;        <span class="keyword">return</span> order;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrder</span><span class="params">(Order order)</span> &#123;        <span class="built_in">this</span>.order = order;    &#125;    <span class="keyword">public</span> Product <span class="title function_">getProduct</span><span class="params">()</span> &#123;        <span class="keyword">return</span> product;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProduct</span><span class="params">(Product product)</span> &#123;        <span class="built_in">this</span>.product = product;    &#125;&#125;</code></pre><h4 id="定义mapper-2"><a class="markdownIt-Anchor" href="#定义mapper-2"></a> 定义mapper</h4><ul><li>OrderMapper</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderMapper</span> &#123;    <span class="meta">@Select(&quot;select * from orders&quot;)</span>    <span class="meta">@Results(&#123;</span><span class="meta">            @Result(property = &quot;id&quot; , column = &quot;id&quot;),</span><span class="meta">            @Result(property = &quot;orderItems&quot; , javaType = List.class,column = &quot;id&quot; ,many = @Many(select = &quot;com.lee.mybatis1.entity.OrderItemMapper.listByOrder&quot;))</span><span class="meta">    &#125;)</span>    <span class="keyword">public</span> List&lt;Order&gt; <span class="title function_">listOrder</span><span class="params">()</span>;&#125;</code></pre><ul><li>OrderItemMapper</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderItemMapper</span> &#123;    <span class="meta">@Select(&quot;select * from order_item where oid = #&#123;oid&#125;&quot;)</span>    <span class="meta">@Results(&#123;</span><span class="meta">            //这里没有标注order成员变量的赋值，因为用不到，所以为null</span><span class="meta">            @Result(property = &quot;product&quot; , column = &quot;pid&quot; , one = @One(select = &quot;com.lee.mybatis1.entity.ProductMapper3.getProductById&quot;))</span><span class="meta">    &#125;)</span>    <span class="keyword">public</span> List&lt;OrderItem&gt; <span class="title function_">listByOrder</span><span class="params">(<span class="type">int</span> oid)</span>;&#125;</code></pre><ul><li>ProductMapper3</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductMapper3</span> &#123;    <span class="meta">@Select(&quot;select * from product where id = #&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> Product <span class="title function_">getProductById</span><span class="params">(<span class="type">int</span> id)</span>;&#125;</code></pre><h4 id="配置mybatis-configxml-2"><a class="markdownIt-Anchor" href="#配置mybatis-configxml-2"></a> 配置mybatis-config.xml</h4><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span>      <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.lee.mybatis1.entity.ProductMapper3&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.lee.mybatis1.entity.OrderMapper&quot;</span>/&gt;</span>       <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.lee.mybatis1.entity.OrderItemMapper&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></code></pre><h4 id="测试运行-3"><a class="markdownIt-Anchor" href="#测试运行-3"></a> 测试运行</h4><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();    <span class="type">OrderMapper</span> <span class="variable">orderMapper</span> <span class="operator">=</span> sqlSession.getMapper(OrderMapper.class);    List&lt;Order&gt; list = orderMapper.listOrder();    <span class="keyword">for</span>(Order o:list)&#123;        System.out.println(o.getCode());        <span class="keyword">for</span>(OrderItem oi:o.getOrderItems())&#123;            System.out.println(oi.getProduct().getName()+<span class="string">&quot;:&quot;</span>+oi.getProduct().getPrice()+<span class="string">&quot;:&quot;</span>+oi.getNumber());        &#125;    &#125;&#125;</code></pre><h3 id="动态sql语句"><a class="markdownIt-Anchor" href="#动态sql语句"></a> 动态SQL语句</h3><ul><li>这里的SQL语句使用SQL类的方式构建</li></ul><h4 id="新建provider类"><a class="markdownIt-Anchor" href="#新建provider类"></a> 新建Provider类</h4><pre><code class="highlight java"><span class="keyword">package</span> com.lee.mybatis1.entity;<span class="keyword">import</span> org.apache.ibatis.jdbc.SQL;<span class="comment">/**</span><span class="comment"> * 这里的sql语句使用动态sql类的方式构建</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryDynaSqlProvider</span> &#123;    <span class="keyword">public</span> String <span class="title function_">list</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>().SELECT(<span class="string">&quot;*&quot;</span>).FROM(<span class="string">&quot;category&quot;</span>).toString();    &#125;    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>().SELECT(<span class="string">&quot;*&quot;</span>).FROM(<span class="string">&quot;category&quot;</span>).WHERE(<span class="string">&quot;id=#&#123;id&#125;&quot;</span>).toString();    &#125;    <span class="keyword">public</span> String <span class="title function_">add</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>().INSERT_INTO(<span class="string">&quot;category&quot;</span>).VALUES(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;#&#123;name&#125;&quot;</span>).toString();    &#125;    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>().UPDATE(<span class="string">&quot;category&quot;</span>).SET(<span class="string">&quot;name=#&#123;name&#125;&quot;</span>).WHERE(<span class="string">&quot;id=#&#123;id&#125;&quot;</span>).toString();    &#125;    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>().DELETE_FROM(<span class="string">&quot;category&quot;</span>).WHERE(<span class="string">&quot;id=#&#123;id&#125;&quot;</span>).toString();    &#125;&#125;</code></pre><h4 id="修改categorymapper"><a class="markdownIt-Anchor" href="#修改categorymapper"></a> 修改CategoryMapper</h4><ul><li>修改这个类以前的注解sql，改为引用的方式</li><li>使用运行方式和以前的Mapper方式相同</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.lee.mybatis1.entity;<span class="keyword">import</span> org.apache.ibatis.annotations.*;<span class="keyword">import</span> java.util.List;<span class="comment">/**</span><span class="comment"> * 这个类就相当于Category.xml，都是一样的</span><span class="comment"> * 要想使用这个类也需要在mybatis-config.xml中配置</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CategoryMapper</span> &#123;    <span class="comment">//@Insert(&quot;insert into category (name) values (#&#123;name&#125;)&quot;)</span>    <span class="meta">@InsertProvider(type = CategoryDynaSqlProvider.class, method = &quot;add&quot;)</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addCategory</span><span class="params">(Category category)</span>;    <span class="comment">//@Delete(&quot;delete from category where id = #&#123;id&#125;&quot;)</span>    <span class="meta">@DeleteProvider(type = CategoryDynaSqlProvider.class, method = &quot;delete&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteCategory</span><span class="params">(<span class="type">int</span> i)</span>;    <span class="comment">//@Select(&quot;select * from category where id = #&#123;id&#125;&quot;)</span>    <span class="meta">@SelectProvider(type = CategoryDynaSqlProvider.class, method = &quot;get&quot;)</span>    <span class="keyword">public</span> Category <span class="title function_">getCategory</span><span class="params">(<span class="type">int</span> id)</span>;    <span class="comment">//@Update(&quot;update category set name = #&#123;name&#125; where id = #&#123;id&#125;&quot;)</span>    <span class="meta">@UpdateProvider(type = CategoryDynaSqlProvider.class, method = &quot;update&quot;)</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateCategory</span><span class="params">(Category category)</span>;    <span class="comment">//@Select(&quot;select * from category&quot;)</span>    <span class="meta">@SelectProvider(type = CategoryDynaSqlProvider.class, method = &quot;list&quot;)</span>    <span class="keyword">public</span> List&lt;Category&gt; <span class="title function_">listCategory</span><span class="params">()</span>;&#125;</code></pre><h4 id="复杂动态sql示例"><a class="markdownIt-Anchor" href="#复杂动态sql示例"></a> 复杂动态sql示例</h4><pre><code class="highlight java"><span class="keyword">private</span> String <span class="title function_">selectPersonSql</span><span class="params">()</span> &#123;  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;&#123;    SELECT(<span class="string">&quot;P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME&quot;</span>);    SELECT(<span class="string">&quot;P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON&quot;</span>);    FROM(<span class="string">&quot;PERSON P&quot;</span>);    FROM(<span class="string">&quot;ACCOUNT A&quot;</span>);    INNER_JOIN(<span class="string">&quot;DEPARTMENT D on D.ID = P.DEPARTMENT_ID&quot;</span>);    INNER_JOIN(<span class="string">&quot;COMPANY C on D.COMPANY_ID = C.ID&quot;</span>);    WHERE(<span class="string">&quot;P.ID = A.ID&quot;</span>);    WHERE(<span class="string">&quot;P.FIRST_NAME like ?&quot;</span>);    OR();    WHERE(<span class="string">&quot;P.LAST_NAME like ?&quot;</span>);    GROUP_BY(<span class="string">&quot;P.ID&quot;</span>);    HAVING(<span class="string">&quot;P.LAST_NAME like ?&quot;</span>);    OR();    HAVING(<span class="string">&quot;P.FIRST_NAME like ?&quot;</span>);    ORDER_BY(<span class="string">&quot;P.ID&quot;</span>);    ORDER_BY(<span class="string">&quot;P.FULL_NAME&quot;</span>);  &#125;&#125;.toString();&#125;</code></pre><h2 id="mybatis-实战"><a class="markdownIt-Anchor" href="#mybatis-实战"></a> Mybatis 实战</h2><h3 id="日志"><a class="markdownIt-Anchor" href="#日志"></a> 日志</h3><ul><li>有时候需要打印日志，知道mybatis执行了什么样的SQL语句，以便进行调试。这时，就需要开启日志，而mybatis自身是没有带日志的，使用的都是第三方日志工具log4j</li></ul><h4 id="导入log4j-jar包"><a class="markdownIt-Anchor" href="#导入log4j-jar包"></a> 导入log4j jar包</h4><ul><li></li></ul><h4 id="定义log4properties"><a class="markdownIt-Anchor" href="#定义log4properties"></a> 定义log4.properties</h4><pre><code class="highlight properties"><span class="comment"># 全局的日志设置</span><span class="comment"># 代表root节点整个工程下所有输出日志的地方配置的输出的级别和输出的位置</span><span class="attr">log4j.rootLogger</span>=<span class="string">ERROR, stdout</span><span class="comment"># mybatis的日志设置</span><span class="comment"># 代表特定包下的特定级别。log4j把日志分为ALL、TRACE&amp;（跟踪）、DEBUG（调试）、INFO（信息）、WARNING（警告）、ERROR（错误）、FITAL（致命）、OFF等几个级别，级别依次升高。级别高的Level会屏蔽级别低的信息。</span> <span class="attr">log4j.logger.com.lee</span>=<span class="string">TRACE</span><span class="comment"># 输出到控制台</span><span class="attr">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span><span class="attr">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span><span class="comment"># 定义输出格式</span><span class="attr">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%5p [%t] - %m%n</span></code></pre><ul><li>别人的配置，仅供参考</li></ul><pre><code class="highlight properties"><span class="comment"></span><span class="comment">### 设置Logger输出级别和输出目的地 ### debug更具体,假设设为info那么打印出的表数据遇到字符串就不显示。此外还有logfile</span><span class="attr">log4j.rootLogger</span>=<span class="string">debug,stdout</span><span class="comment"></span><span class="comment">### 把日志信息输出到控制台 ### </span><span class="attr">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender </span><span class="comment">#log4j.appender.stdout.Target=System.err </span><span class="attr">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.SimpleLayout </span><span class="comment"></span><span class="comment">### 把日志信息输出到文件：jbit.log ### </span><span class="comment">#log4j.appender.logfile=org.apache.log4j.FileAppender </span><span class="comment">#log4j.appender.logfile.File=jbit.log </span><span class="comment">#log4j.appender.logfile.layout=org.apache.log4j.PatternLayout </span><span class="comment">#log4j.appender.logfile.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %F %p %m%n </span><span class="comment"></span><span class="comment">###显示SQL语句部分 </span><span class="comment">#log4j.logger.com.mybatis=DEBUG</span><span class="comment">#log4j.logger.com.mybatis.common.jdbc.SimpleDataSource=DEBUG </span><span class="comment">#log4j.logger.com.mybatis.common.jdbc.ScriptRunner=DEBUG </span><span class="comment">#log4j.logger.com.mybatis.sqlmap.engine.impl.SqlMapClientDelegate=DEBUG </span><span class="comment">#log4j.logger.java.sql.Connection=DEBUG</span><span class="comment">#log4j.logger.java.sql.Statement=DEBUG</span><span class="comment">#log4j.logger.java.sql.PreparedStatement=DEBUG</span><span class="comment">#log4j.logger.java.sql.ResultSet=DEBUG</span></code></pre><h4 id="运行测试"><a class="markdownIt-Anchor" href="#运行测试"></a> 运行测试</h4><ul><li>直接运行TestMybatis.java类中的main方法</li><li>就可以直接打印出日志</li></ul><h3 id="事务管理"><a class="markdownIt-Anchor" href="#事务管理"></a> 事务管理</h3><h4 id="jdbc方式"><a class="markdownIt-Anchor" href="#jdbc方式"></a> JDBC方式</h4><ul><li>首先要确保mybatis-config.xml中<code>&lt;transactionManager type=&quot;JDBC&quot;&gt;</code></li><li>即事物管理者类型为JDBC</li></ul><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>    <span class="comment">&lt;!-- 配置自动扫描com.lee.mybatis1.entity包下的类型，使得在后续配置文件Category.xml中使用resultType的时候可以直接使用Category</span><span class="comment">     而不用写全路径com.lee.mybaits1.entity.Category--&gt;</span>    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span>        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.lee.mybatis1.entity&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span>    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span>------------------------------------------------            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span>------------------------------------------------            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/lee_test?characterEncoding=UTF-8&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span>            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span>    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span>    <span class="comment">&lt;!--映射Catrgory.xml--&gt;</span>    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/lee/mybatis1/entity/Category.xml&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/lee/mybatis1/entity/Product.xml&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/lee/mybatis1/entity/OrderItem.xml&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/lee/mybatis1/entity/Order.xml&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></code></pre><h4 id="innodb引擎"><a class="markdownIt-Anchor" href="#innodb引擎"></a> INNODB引擎</h4><ul><li>确保MySQL中的表为innodb类型，才能支持事物，所以需要把表设置为innodb类型</li><li><strong>修改表为innodb</strong></li></ul><pre><code class="highlight sql"><span class="keyword">alter table</span> category_ ENGINE <span class="operator">=</span> innodb;</code></pre><ul><li><strong>查看表引擎为什么类型</strong></li></ul><pre><code class="highlight sql"><span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">from</span> how2java;</code></pre><h4 id="测试代码"><a class="markdownIt-Anchor" href="#测试代码"></a> 测试代码</h4><ul><li>插入第二个数据会因为长度超过32，而导致无法插入到数据库。因为在同一个事务里，所以第一个数据，也<strong>无法插入成功</strong></li><li>如果在第二个数据之前第一个数据之后写commit语句，则第一个数据会插入成功，第二个数据之后的数据全部插入失败，如果把第二个错误数据用try catch包起来，那么只有第二个插入失败，第二个后面也可以成功</li></ul><pre><code class="highlight java"><span class="type">CategoryMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(CategoryMapper.class);<span class="comment">//增加</span><span class="type">Category</span> <span class="variable">category</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Category</span>();category.setName(<span class="string">&quot;公关部&quot;</span>);mapper.addCategory(category);<span class="type">Category</span> <span class="variable">category2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Category</span>();category2.setName(<span class="string">&quot;超过最大长度30的名称超过最大长度30的名称超过最大长度30的名称超过最大长度30的名称超过最大长度30的名称超过最大长度30的名称&quot;</span>);mapper.addCategory(category2);<span class="comment">//提交事物</span>sqlSession.commit();sqlSession.close();</code></pre><h3 id="延迟加载"><a class="markdownIt-Anchor" href="#延迟加载"></a> 延迟加载</h3><ul><li>其作用是给一个实体类查询赋值时，若该实体类包含另一个实体类，需要单独在查询一次包含的实体类，即一对多的情况下，加上延迟加载后，如果你调用的包含类财货执行包含类的查询语句，如果没有使用该包含类，则不调用该包含类的单独的查询语句</li></ul><h4 id="在mybatis-configxml配置延迟加载"><a class="markdownIt-Anchor" href="#在mybatis-configxml配置延迟加载"></a> 在mybatis-config.xml配置延迟加载</h4><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>    <span class="tag">&lt;<span class="name">settings</span>&gt;</span>          <span class="comment">&lt;!-- 打开延迟加载的开关 --&gt;</span>          <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span>          <span class="comment">&lt;!-- 将积极加载改为消息加载即按需加载 --&gt;</span>          <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span>     <span class="tag">&lt;/<span class="name">settings</span>&gt;</span> <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></code></pre><h4 id="测试运行-4"><a class="markdownIt-Anchor" href="#测试运行-4"></a> 测试运行</h4><ul><li>CategoryMapper2</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CategoryMapper2</span> &#123;    <span class="meta">@Select(&quot;select * from category&quot;)</span>    <span class="meta">@Results(&#123;</span><span class="meta">            //column表示数据库字段名，property表示成员变量名，javaType表示成员变量类型，基本类型不用特别标注</span><span class="meta">            //如果一个字段多次使用，必须标注每次查询要传递给哪个字段，这个例子就是第一行和第三行各用了一次id，如果不标注，就会查询出null</span><span class="meta">            //像name字段名和成员变量名相同，也只用了一次，就不用特别标注，框架会自动入参</span><span class="meta">            @Result(property = &quot;id&quot; , column = &quot;id&quot;),</span><span class="meta">            @Result(property = &quot;name&quot; , column = &quot;name&quot;),</span><span class="meta">            //@Results 通过@Result和@Many中调用ProductMapper.listByCategory()方法相结合，来获取一对多关系</span><span class="meta">            @Result(property = &quot;products&quot; , javaType = List.class , column = &quot;id&quot; , many = @Many(select =</span><span class="meta">                    &quot;com.lee.mybatis1.entity.ProductMapper.listByCategory&quot;))</span><span class="meta">    &#125;)</span>    <span class="keyword">public</span> List&lt;Category&gt; <span class="title function_">listCategory</span><span class="params">()</span>;&#125;</code></pre><ul><li>当注掉这三个语句后，就不会执行product的相关查询</li></ul><pre><code class="highlight java">        <span class="type">CategoryMapper2</span> <span class="variable">categoryMapper2</span> <span class="operator">=</span> sqlSession.getMapper(CategoryMapper2.class);        List&lt;Category&gt; list = categoryMapper2.listCategory();        <span class="keyword">for</span> (Category c: list) &#123;            System.out.println(c.getId()+<span class="string">&quot;-&quot;</span>+c.getName());;<span class="comment">//            for (Product p:c.getProducts()) &#123;</span><span class="comment">//                System.out.println(p);</span><span class="comment">//            &#125;</span>        &#125;</code></pre><ul><li><strong>放开注释后</strong><ul><li>发现两个语句都执行了</li></ul></li></ul><h3 id="分页"><a class="markdownIt-Anchor" href="#分页"></a> 分页</h3><h4 id="xml方式"><a class="markdownIt-Anchor" href="#xml方式"></a> xml方式</h4><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listCategory100&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Category&quot;</span>&gt;</span>    select * from   category    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;start!=null and count!=null&quot;</span>&gt;</span>        limit #&#123;start&#125;,#&#123;count&#125;    <span class="tag">&lt;/<span class="name">if</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><ul><li>调用</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">xmlWay</span><span class="params">(SqlSession sqlSession,<span class="type">int</span> start,<span class="type">int</span> count)</span>&#123;    Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    <span class="comment">//从第几个开始</span>    map.put(<span class="string">&quot;start&quot;</span>,start);    <span class="comment">//每页展示几个</span>    map.put(<span class="string">&quot;count&quot;</span>,count);    List&lt;Category&gt; list = sqlSession.selectList(<span class="string">&quot;listCategory100&quot;</span>,map);    <span class="keyword">for</span>(Category c:list)&#123;        System.out.println(c.getName());    &#125;&#125;</code></pre><h4 id="注解方式"><a class="markdownIt-Anchor" href="#注解方式"></a> 注解方式</h4><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CategoryMapper</span> &#123;    <span class="meta">@Select(&quot; select * from category limit #&#123;start&#125;,#&#123;count&#125;&quot;)</span>    <span class="keyword">public</span> List&lt;Category&gt; <span class="title function_">listCategory100</span><span class="params">(<span class="meta">@Param(&quot;start&quot;)</span> <span class="type">int</span> start,<span class="meta">@Param(&quot;count&quot;)</span> <span class="type">int</span> count)</span>;&#125;</code></pre><ul><li>调用</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">annotationWay</span><span class="params">(SqlSession sqlSession,<span class="type">int</span> start,<span class="type">int</span> count)</span>&#123;    <span class="type">CategoryMapper</span> <span class="variable">categoryMapper</span> <span class="operator">=</span> sqlSession.getMapper(CategoryMapper.class);    List&lt;Category&gt; list = categoryMapper.listCategory100(start,count);    <span class="keyword">for</span>(Category c:list)&#123;        System.out.println(c.getName());    &#125;&#125;</code></pre><blockquote><p>原理：使用MySQL的<strong>limit</strong>关键字</p></blockquote><h4 id="rowbounds方式"><a class="markdownIt-Anchor" href="#rowbounds方式"></a> RowBounds方式</h4><ul><li>在使用SqlSession的selectList()方法时，指定一个RowBounds分页器参数，即可查询指定范围的记录</li><li><code>RowBounds(offset,limit)</code>构造器</li></ul><pre><code class="highlight java"><span class="type">RowBounds</span> <span class="variable">bounds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RowBounds</span>(offset.limit);- offset指定抓取记录的起始行，从<span class="number">0</span>开始- limit指定抓取记录</code></pre><ul><li><code>selectList()</code>使用方法</li></ul><pre><code class="highlight java">sqlSession.selectList(sql的id,参数,RowBounds对象);</code></pre><ul><li>MyBatis分页是基于内存分页，原理是查询出所有的记录，然后<strong>基于jdbc的absolute()和next()方法</strong>定位获取部分记录，因此在遇到大量数据情况下，不推荐使用MyBatis自带分页功能，需要开发者指定分页查询的sql语句或对MyBatis进行扩展使用</li></ul><h3 id="pagehelper分页插件"><a class="markdownIt-Anchor" href="#pagehelper分页插件"></a> PageHelper分页插件</h3><ul><li>pageHelper是一个犀利的mybaits分页插件，使用该插件，开发分页更加简单容易</li></ul><h4 id="导jar包"><a class="markdownIt-Anchor" href="#导jar包"></a> 导jar包</h4><h4 id="在mybatis中配置"><a class="markdownIt-Anchor" href="#在mybatis中配置"></a> 在mybatis中配置</h4><ul><li>该配置语句对行数有要求</li></ul><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>    <span class="tag">&lt;<span class="name">settings</span>&gt;</span>        <span class="comment">&lt;!-- 打开延迟加载的开关 --&gt;</span>        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span>        <span class="comment">&lt;!-- 将积极加载改为消息加载即按需加载 --&gt;</span>        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span>    <span class="comment">&lt;!-- 配置自动扫描com.lee.mybatis1.entity包下的类型，使得在后续配置文件Category.xml中使用resultType的时候可以直接使用Category</span><span class="comment">     而不用写全路径com.lee.mybaits1.entity.Category--&gt;</span>    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span>        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.lee.mybatis1.entity&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span>    -------------------------------------------------------------------------------------------------------------    <span class="comment">&lt;!--使用pageheler分页工具，该配置语句有位置要求，只能卸载typeAliases和environments之间--&gt;</span>    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>-------------------------------------------------------------------------------------------------------------    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span>            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/lee_test?characterEncoding=UTF-8&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span>            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span>    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span>        <span class="comment">&lt;!--映射Catrgory.xml--&gt;</span>    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/lee/mybatis1/entity/Category.xml&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/lee/mybatis1/entity/Product.xml&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/lee/mybatis1/entity/OrderItem.xml&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/lee/mybatis1/entity/Order.xml&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.lee.mybatis1.entity.CategoryMapper&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.lee.mybatis1.entity.CategoryMapper2&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.lee.mybatis1.entity.ProductMapper&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.lee.mybatis1.entity.CategoryMapper3&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.lee.mybatis1.entity.ProductMapper2&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.lee.mybatis1.entity.ProductMapper3&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.lee.mybatis1.entity.OrderMapper&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.lee.mybatis1.entity.OrderItemMapper&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></code></pre><h3 id="一级缓存"><a class="markdownIt-Anchor" href="#一级缓存"></a> 一级缓存</h3><ul><li>Mybatis的一级缓存在session上，只要通过session查过的数据，都会放在session上，下一次再查询相同id的数据，都直接冲缓存中取出来，而不用到数据库里去取了</li></ul><h4 id="测试代码-2"><a class="markdownIt-Anchor" href="#测试代码-2"></a> 测试代码</h4><ul><li>可以发现调用了两次，但是sql语句只执行了一次，数据是从session缓存中取出来的</li></ul><pre><code class="highlight java"><span class="type">Category</span> <span class="variable">category</span> <span class="operator">=</span> sqlSession.selectOne(<span class="string">&quot;getCategoryOne&quot;</span>,<span class="number">2</span>);System.out.println(category.getName());<span class="type">Category</span> <span class="variable">category1</span> <span class="operator">=</span> sqlSession.selectOne(<span class="string">&quot;getCategoryOne&quot;</span>,<span class="number">2</span>);System.out.println(category1.getName());</code></pre><ul><li>如果重新new一个sqlSession，就会重新执行sql，<strong>证实了一级缓存是在session里的</strong></li><li>二级缓存用来实现不同sqlSession之间查询同id语句的缓存</li></ul><pre><code class="highlight java"><span class="type">Category</span> <span class="variable">category</span> <span class="operator">=</span> sqlSession.selectOne(<span class="string">&quot;getCategoryOne&quot;</span>,<span class="number">2</span>);System.out.println(category.getName());<span class="type">Category</span> <span class="variable">category1</span> <span class="operator">=</span> sqlSessionFactory.openSession().selectOne(<span class="string">&quot;getCategoryOne&quot;</span>,<span class="number">2</span>);System.out.println(category1.getName());</code></pre><h3 id="二级缓存"><a class="markdownIt-Anchor" href="#二级缓存"></a> 二级缓存</h3><ul><li>对一级缓存进行改造，以支持二级缓存</li><li>使得在同一个sqlSessionFactory下所有的sqlSession查询相同id的sql语句都是从二级缓存中取</li></ul><h4 id="配置mybatis-configxml-3"><a class="markdownIt-Anchor" href="#配置mybatis-configxml-3"></a> 配置mybatis-config.xml</h4><ul><li>配置以支持二级缓存</li></ul><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>    <span class="tag">&lt;<span class="name">settings</span>&gt;</span>        <span class="comment">&lt;!-- 打开延迟加载的开关 --&gt;</span>        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span>        <span class="comment">&lt;!-- 将积极加载改为消息加载即按需加载 --&gt;</span>        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span>        <span class="comment">&lt;!--增加二级缓存--&gt;</span>        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span>    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span>               ... ...    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></code></pre><h4 id="在categoryxml中增加cache"><a class="markdownIt-Anchor" href="#在categoryxml中增加cache"></a> 在Category.xml中增加<cache/></h4><ul><li>新增<code>&lt;cache/&gt;</code>以启动对Category对象的二级缓存</li></ul><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span><span class="meta">    <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="meta">    <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>     <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.how2java.pojo&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">cache</span>/&gt;</span>        <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addCategory&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Category&quot;</span> &gt;</span>            insert into category_ ( name ) values (#&#123;name&#125;)           <span class="tag">&lt;/<span class="name">insert</span>&gt;</span>                 <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteCategory&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Category&quot;</span> &gt;</span>            delete from category_ where id= #&#123;id&#125;          <span class="tag">&lt;/<span class="name">delete</span>&gt;</span>              <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></code></pre><h4 id="序列化category"><a class="markdownIt-Anchor" href="#序列化category"></a> 序列化Category</h4><ul><li>让Category实现序列化接口</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Category</span>  <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> id ;    <span class="keyword">private</span> String name ;    <span class="comment">//private List&lt;Product&gt; products;</span>    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;&#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;&#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;&#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id; &#125;&#125;</code></pre><h4 id="测试运行-5"><a class="markdownIt-Anchor" href="#测试运行-5"></a> 测试运行</h4><ul><li>但是要想二级缓存<strong>生效</strong>，必须让第一个sqlSession close()或commit()否则无法生效</li></ul><pre><code class="highlight java"><span class="type">Category</span> <span class="variable">category</span> <span class="operator">=</span> sqlSession.selectOne(<span class="string">&quot;getCategoryOne&quot;</span>,<span class="number">1</span>);System.out.println(category.getName());sqlSession.commit();<span class="type">Category</span> <span class="variable">category1</span> <span class="operator">=</span> sqlSessionFactory.openSession().selectOne(<span class="string">&quot;getCategoryOne&quot;</span>,<span class="number">1</span>);System.out.println(category1.getName());</code></pre><h3 id="c3p0连接池"><a class="markdownIt-Anchor" href="#c3p0连接池"></a> c3p0连接池</h3><h4 id="导入jar包"><a class="markdownIt-Anchor" href="#导入jar包"></a> 导入jar包</h4><h4 id="新建c3p0datasourcefactory"><a class="markdownIt-Anchor" href="#新建c3p0datasourcefactory"></a> 新建C3P0DataSourceFactory</h4><ul><li>Mybatis使用C3P0有点怪怪的，需要自己写个类继承<code>UnpooledDataSourceFactory</code>，然后指定dataSource 为<code>ComboPooledDataSource</code></li><li>这个ComboPooledDataSource就是c3p0的数据源</li></ul><blockquote><p>看了下源码，这个类实现了DataSourceFactory接口，所以直接自己 建个类实现DataSourceFactory接口就行，不用通过继承UnpooledDataSourceFactory间接实现这个接口，实现类C3P0DataSourceFactory里面的代码直接抄UnpooledDataSourceFactory这个类就行，就把this.dataSource = new UnpooledDataSource();改成this.dataSource =new ComboPooledDataSource();就行了。测试了下，好像也行，没发现啥问题</p></blockquote><pre><code class="highlight java"><span class="keyword">package</span> com.lee.mybatis1.c3p0;<span class="keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;<span class="keyword">import</span> org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;<span class="comment">/**</span><span class="comment"> * Mybatis使用C3P0有点怪怪的，需要自己写个类继承UnpooledDataSourceFactory，然后指定dataSource 为ComboPooledDataSource。</span><span class="comment"> 这个ComboPooledDataSource就是c3p0的数据源。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C3P0DataSourceFactory</span> <span class="keyword">extends</span> <span class="title class_">UnpooledDataSourceFactory</span>&#123;    <span class="keyword">public</span> <span class="title function_">C3P0DataSourceFactory</span><span class="params">()</span>&#123;        <span class="built_in">this</span>.dataSource =<span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();    &#125;&#125;</code></pre><h4 id="配置mybatis-configxml-4"><a class="markdownIt-Anchor" href="#配置mybatis-configxml-4"></a> 配置mybatis-config.xml</h4><ul><li>注释掉type=&quot;POOLED&quot;的数据源，换成type=&quot;org.mybatis.c3p0.C3P0DataSourceFactory&quot;的数据源<br />这样就使用c3p0了</li></ul><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span>        <span class="comment">&lt;!--&lt;dataSource type=&quot;POOLED&quot;&gt;--&gt;</span>            <span class="comment">&lt;!--&lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;--&gt;</span>            <span class="comment">&lt;!--&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/lee_test?characterEncoding=UTF-8&quot;/&gt;--&gt;</span>            <span class="comment">&lt;!--&lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;--&gt;</span>            <span class="comment">&lt;!--&lt;property name=&quot;password&quot; value=&quot;admin&quot;/&gt;--&gt;</span>        <span class="comment">&lt;!--&lt;/dataSource&gt;--&gt;</span>        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;com.lee.mybatis1.c3p0.C3P0DataSourceFactory&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span>            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/lee_test?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8<span class="symbol">&amp;amp;</span>autoReconnect=true<span class="symbol">&amp;amp;</span>failOverReadOnly=false&quot;</span>/&gt;</span>            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span>            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;admin&quot;</span> /&gt;</span>            <span class="comment">&lt;!-- 连接池初始化大小为3 --&gt;</span>            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>/&gt;</span>            <span class="comment">&lt;!-- 连接池最大为10 --&gt;</span>            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span>            <span class="comment">&lt;!-- 连接池最小为3 --&gt;</span>            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>/&gt;</span>            <span class="comment">&lt;!-- 连接池在无空闲连接可用时一次性最多创建的新数据库连接数  --&gt;</span>            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span>/&gt;</span>            <span class="comment">&lt;!-- 连接的最大空闲时间，如果超过这个时间（秒），某个数据库连接还没有被使用，则会断开掉这个连接。如果为0，则永远不会断开连接,即回收此连接 --&gt;</span>            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdleTime&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>/&gt;</span>            <span class="comment">&lt;!-- 最大的Statement数量 --&gt;</span>            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatements&quot;</span> <span class="attr">value</span>=<span class="string">&quot;500&quot;</span>/&gt;</span>            <span class="comment">&lt;!-- 每个连接启动的最大Statement数量 --&gt;</span>            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatementsPerConnection&quot;</span> <span class="attr">value</span>=<span class="string">&quot;50&quot;</span>/&gt;</span>            <span class="comment">&lt;!-- 同时运行的线程数 --&gt;</span>            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;numHelperThreads&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span>/&gt;</span>        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></code></pre><h4 id="测试运行-6"><a class="markdownIt-Anchor" href="#测试运行-6"></a> 测试运行</h4><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);    <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession();    List&lt;Category&gt; cs =session.selectList(<span class="string">&quot;com.lee.mybatis1.CategorySpace.listCategory&quot;</span>);    <span class="keyword">for</span> (Category c : cs) &#123;        System.out.println(c.getName());    &#125;    session.close();&#125;</code></pre><h3 id="逆向工程"><a class="markdownIt-Anchor" href="#逆向工程"></a> 逆向工程</h3><ul><li>Mybatis Generator是一个用于Mybatis逆向工程的工具。前面学习的方式都是先有pojo, mapper, xml, 然后再创建表。</li><li>用逆向工程的方式，首先保证数据库里有表，然后通过Mybatis Generator生成pojo, mapper和xml。</li><li>可以节约大家的时间，提高开发效率，降低出错几率</li></ul><h4 id="导入jar包-2"><a class="markdownIt-Anchor" href="#导入jar包-2"></a> 导入jar包</h4><h4 id="创建配置文件"><a class="markdownIt-Anchor" href="#创建配置文件"></a> 创建配置文件</h4><ul><li>在src目录下创建generatorConfig.xml</li><li>这个配置文件有如下作用<ol><li>指定 mysql jdbcjar 包的位置,这里用的位置是 e:/project/mybatis/lib/mysql-connector-java-5.0.8-bin.jar</li><li>设置数据库链接账号密码</li><li>指定pojo,mapper,xml分别生成的包名</li><li>指定表名以及表名对应的类名<br />4.1  使用自增长键：</li></ol></li></ul><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;my.isgen.usekeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">generatedKey</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">sqlStatement</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></code></pre><ul><li>完整代码</li></ul><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span></span><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span>    <span class="comment">&lt;!--数据库驱动--&gt;</span>    <span class="comment">&lt;!--</span><span class="comment">        如果IDE(eclipse或者idea) 项目里导入了jar包，那么就不需要配置了jar包的绝对路径了</span><span class="comment">         &lt;classPathEntry    location=&quot;e:/project/mybatis/lib/mysql-connector-java-5.0.8-bin.jar&quot;/&gt;</span><span class="comment">    --&gt;</span>    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;DB2Tables&quot;</span>    <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span>            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressDate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span>        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span>        <span class="comment">&lt;!--数据库链接地址账号密码--&gt;</span>        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost/how2java&quot;</span> <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;admin&quot;</span>&gt;</span>        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span>        <span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span>            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;forceBigDecimals&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span>        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span>        <span class="comment">&lt;!--生成Model类存放位置--&gt;</span>        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.how2java.pojo&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span>        <span class="comment">&lt;!--生成映射文件存放位置--&gt;</span>        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.how2java.pojo&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span>        <span class="comment">&lt;!--生成Dao类存放位置--&gt;</span>                 <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.how2java.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span>        <span class="comment">&lt;!--生成对应表及类名--&gt;</span>        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;category_&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Category&quot;</span> <span class="attr">enableCountByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableUpdateByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableDeleteByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableSelectByExample</span>=<span class="string">&quot;true&quot;</span> <span class="attr">selectByExampleQueryId</span>=<span class="string">&quot;false&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;my.isgen.usekeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>            <span class="tag">&lt;<span class="name">generatedKey</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">sqlStatement</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span>               <span class="tag">&lt;/<span class="name">table</span>&gt;</span><span class="comment">&lt;!--         &lt;table tableName=&quot;product_&quot; domainObjectName=&quot;Product&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;&lt;/table&gt; --&gt;</span>    <span class="tag">&lt;/<span class="name">context</span>&gt;</span><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></code></pre><ul><li>测试运行</li></ul><pre><code class="highlight java"><span class="keyword">package</span> com.how2java; <span class="keyword">import</span> java.io.File;<span class="keyword">import</span> java.io.InputStream;<span class="keyword">import</span> java.util.ArrayList;<span class="keyword">import</span> java.util.List; <span class="keyword">import</span> org.mybatis.generator.api.MyBatisGenerator;<span class="keyword">import</span> org.mybatis.generator.config.Configuration;<span class="keyword">import</span> org.mybatis.generator.config.xml.ConfigurationParser;<span class="keyword">import</span> org.mybatis.generator.internal.DefaultShellCallback; <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMybatisGenerator</span> &#123;     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        List&lt;String&gt; warnings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();        <span class="type">boolean</span> <span class="variable">overwrite</span> <span class="operator">=</span> <span class="literal">true</span>;        InputStream is= TestMybatisGenerator.class.getClassLoader().getResource(<span class="string">&quot;generatorConfig.xml&quot;</span>).openStream();        <span class="type">ConfigurationParser</span> <span class="variable">cp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationParser</span>(warnings);        <span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> cp.parseConfiguration(is);        is.close();        <span class="type">DefaultShellCallback</span> <span class="variable">callback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultShellCallback</span>(overwrite);        <span class="type">MyBatisGenerator</span> <span class="variable">myBatisGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBatisGenerator</span>(config, callback, warnings);        myBatisGenerator.generate(<span class="literal">null</span>);        System.out.println(<span class="string">&quot;生成代码成功，刷新项目，查看文件,然后执行TestMybatis.java&quot;</span>);             &#125;&#125;</code></pre><h3 id="创建insert时返回id"><a class="markdownIt-Anchor" href="#创建insert时返回id"></a> 创建(insert)时返回id</h3><ul><li>只需在insert标签中添加几个属性即可在新增这条信息的时候返回它的id值</li></ul><blockquote><p>注意：返回的id值并不是通过mapper接口方法返回，而是直接赋值给了pojo类HostForPost中的hostId字段</p></blockquote><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.suninfo.adm.pojo.postRequestBody.integratedMgmt.hostMgmt.HostForPost&quot;</span>  <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span></span><span class="tag">        <span class="attr">keyProperty</span>=<span class="string">&quot;hostId&quot;</span>&gt;</span>  insert into t_adm_host(name, ostype_id, ip, workgroup,node_id, regist_status, cdm_serverip,ha, ha_master,   ha_slave, create_time, update_time,run_status)  values (#&#123;name,jdbcType=VARCHAR&#125;,          #&#123;ostypeId,jdbcType=INTEGER&#125;,          #&#123;ip,jdbcType=VARCHAR&#125;,          #&#123;workgroup,jdbcType=VARCHAR&#125;,          #&#123;nodeId,jdbcType=INTEGER&#125;,          #&#123;registStatus,jdbcType=INTEGER&#125;,          #&#123;cdmServerIp,jdbcType=VARCHAR&#125;,          #&#123;ha,jdbcType=TINYINT&#125;,          #&#123;haMaster,jdbcType=VARCHAR&#125;,          #&#123;haSlave,jdbcType=VARCHAR&#125;,          #&#123;createTime,jdbcType=INTEGER&#125;,          #&#123;updateTime,jdbcType=INTEGER&#125;,          #&#123;runStatus,jdbcType=INTEGER&#125;)<span class="tag">&lt;/<span class="name">insert</span>&gt;</span></code></pre><h3 id="使用阿里druid连接池"><a class="markdownIt-Anchor" href="#使用阿里druid连接池"></a> 使用阿里Druid连接池</h3><h4 id="applicationcontextxml"><a class="markdownIt-Anchor" href="#applicationcontextxml"></a> applicationContext.xml</h4><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd&quot;</span>&gt;</span>    <span class="comment">&lt;!--通过注解，将Service的生命周期纳入Spring的管理--&gt;</span>    <span class="tag">&lt;<span class="name">context:annotation-config</span> /&gt;</span>    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.lee.service&quot;</span> /&gt;</span>-----------------------------------------------------------------------------------------------------------    <span class="comment">&lt;!--使用阿里的Druid连接池配置--&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span>        <span class="comment">&lt;!-- 基本属性 url、user、password --&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/lee_test?characterEncoding=UTF-8&quot;</span> /&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;admin&quot;</span> /&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span>        <span class="comment">&lt;!-- 配置初始化大小、最小、最大 --&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> /&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> /&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span> /&gt;</span>        <span class="comment">&lt;!-- 配置获取连接等待超时的时间 --&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWait&quot;</span> <span class="attr">value</span>=<span class="string">&quot;60000&quot;</span> /&gt;</span>        <span class="comment">&lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;60000&quot;</span> /&gt;</span>        <span class="comment">&lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;300000&quot;</span> /&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;validationQuery&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SELECT 1&quot;</span> /&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnReturn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span>        <span class="comment">&lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;poolPreparedStatements&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolPreparedStatementPerConnectionSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span> /&gt;</span>    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>-----------------------------------------------------------------------------------------------------------    <span class="comment">&lt;!--&amp;lt;!&amp;ndash;配置数据源（无连接池）&amp;ndash;&amp;gt;--&gt;</span>    <span class="comment">&lt;!--&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;--&gt;</span>        <span class="comment">&lt;!--&lt;property name=&quot;driverClassName&quot;&gt;--&gt;</span>            <span class="comment">&lt;!--&lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;--&gt;</span>        <span class="comment">&lt;!--&lt;/property&gt;--&gt;</span>        <span class="comment">&lt;!--&lt;property name=&quot;url&quot;&gt;--&gt;</span>            <span class="comment">&lt;!--&lt;value&gt;jdbc:mysql://localhost:3306/lee_test?characterEncoding=UTF-8&lt;/value&gt;--&gt;</span>        <span class="comment">&lt;!--&lt;/property&gt;--&gt;</span>        <span class="comment">&lt;!--&lt;property name=&quot;username&quot;&gt;--&gt;</span>            <span class="comment">&lt;!--&lt;value&gt;root&lt;/value&gt;--&gt;</span>        <span class="comment">&lt;!--&lt;/property&gt;--&gt;</span>        <span class="comment">&lt;!--&lt;property name=&quot;password&quot;&gt;--&gt;</span>            <span class="comment">&lt;!--&lt;value&gt;admin&lt;/value&gt;--&gt;</span>        <span class="comment">&lt;!--&lt;/property&gt;--&gt;</span>    <span class="comment">&lt;!--&lt;/bean&gt;--&gt;</span>    <span class="comment">&lt;!--扫描存放SQL语句的Category.xml--&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.lee.pojo&quot;</span> /&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:com/lee/mapper/*.xml&quot;</span>/&gt;</span>        <span class="comment">&lt;!--pageHelper分页插件，如果使用数据库limit分页关键字，则不用下列配置--&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;plugins&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">array</span>&gt;</span>                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span>                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span>                        <span class="comment">&lt;!--使用下面的方式配置参数，一行配置一个 --&gt;</span>                        <span class="tag">&lt;<span class="name">value</span>&gt;</span>                        <span class="tag">&lt;/<span class="name">value</span>&gt;</span>                    <span class="tag">&lt;/<span class="name">property</span>&gt;</span>                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>            <span class="tag">&lt;/<span class="name">array</span>&gt;</span>        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    <span class="comment">&lt;!--扫描Mapper，并将其生命周期纳入Spring的管理--&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.lee.mapper&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></code></pre><h4 id="属性详解"><a class="markdownIt-Anchor" href="#属性详解"></a> 属性详解</h4><pre><code class="highlight properties"><span class="attr">connection.url</span>=<span class="string">jdbc:mysql://192.168.211.182:13507/adm_dbmodel?allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><span class="attr">connection.username</span>=<span class="string">adm_admin</span><span class="attr">connection.password</span>=<span class="string">dSadm@34e%</span><span class="comment">#druid datasource</span><span class="comment">#初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</span><span class="attr">druid.initialSize</span>=<span class="string">5</span><span class="comment">#最小连接池数量</span><span class="attr">druid.minIdle</span>=<span class="string">3</span><span class="comment">#最大连接池数量</span><span class="attr">druid.maxActive</span>=<span class="string">20</span><span class="comment">#获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</span><span class="attr">druid.maxWait</span>=<span class="string">60000</span><span class="comment">#有两个含义：1) Destroy线程会检测连接的间隔时间2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明</span><span class="attr">druid.timeBetweenEvictionRunsMillis</span>=<span class="string">60000</span><span class="comment">#一个连接在池中最小生存的时间，单位是毫秒</span><span class="attr">druid.minEvictableIdleTimeMillis</span>=<span class="string">100000</span><span class="comment">#用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。</span><span class="attr">druid.validationQuery</span>=<span class="string">SELECT &#x27;x&#x27;</span><span class="comment">#建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</span><span class="attr">druid.testWhileIdle</span>=<span class="string">true</span><span class="comment">#申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</span><span class="attr">druid.testOnBorrow</span>=<span class="string">true</span><span class="comment">#归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</span><span class="attr">druid.testOnReturn</span>=<span class="string">false</span><span class="comment">#是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</span><span class="attr">druid.poolPreparedStatements</span>=<span class="string">false</span><span class="attr">druid.maxPoolPreparedStatementPerConnectionSize</span>=<span class="string">20</span><span class="comment">#属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</span><span class="attr">druid.filters</span>=<span class="string">stat</span></code></pre><h3 id="防止sql注入"><a class="markdownIt-Anchor" href="#防止sql注入"></a> 防止sql注入</h3><p>使用#号不会发生sql注入，使用$可以。</p><h4 id="模糊查询-2"><a class="markdownIt-Anchor" href="#模糊查询-2"></a> 模糊查询</h4><pre><code class="highlight sql"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> news <span class="keyword">where</span> title <span class="keyword">like</span> ‘<span class="operator">%</span>#&#123;title&#125;<span class="operator">%</span>’</code></pre><p>在这种情况下使用#程序会报错，新手程序员就把#号改成了$,这样如果java代码层面没有对用户输入的内容做处理势必会产生SQL注入漏洞。</p><p>正确写法:</p><pre><code class="highlight sql"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> news <span class="keyword">where</span> tile <span class="keyword">like</span> concat(‘<span class="operator">%</span>’,#&#123;title&#125;, ‘<span class="operator">%</span>’)</code></pre><h4 id="in之后多个参数"><a class="markdownIt-Anchor" href="#in之后多个参数"></a> in之后多个参数</h4><p>in之后多个id查询时使用# 同样会报错</p><pre><code class="highlight sql"><span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">from</span> news <span class="keyword">where</span> id <span class="keyword">in</span> (#&#123;ids&#125;)</code></pre><p>正确用法为使用foreach，而不是将#替换为$</p><pre><code class="highlight sql">id <span class="keyword">in</span><span class="operator">&lt;</span>foreach collection<span class="operator">=</span>&quot;ids&quot; item<span class="operator">=</span>&quot;item&quot; <span class="keyword">open</span><span class="operator">=</span>&quot;(&quot;separatosr<span class="operator">=</span>&quot;,&quot; <span class="keyword">close</span><span class="operator">=</span>&quot;)&quot;<span class="operator">&gt;</span>    #&#123;ids&#125; <span class="operator">&lt;</span><span class="operator">/</span>foreach<span class="operator">&gt;</span></code></pre><h4 id="order-by之后"><a class="markdownIt-Anchor" href="#order-by之后"></a> order by之后</h4><p>这种场景应当在Java层面做映射，设置一个字段/表名数组，仅允许用户传入索引值。这样保证传入的字段或者表名都在白名单里面。需要注意的是在mybatis-generator自动生成的SQL语句中，order by使用的也是$，而like和in没有问题。</p>]]>
    </content>
    <id>http://example.com/2022/01/04/Mybatis/</id>
    <link href="http://example.com/2022/01/04/Mybatis/"/>
    <published>2022-01-04T04:00:00.000Z</published>
    <summary>MyBatis框架就是对JDBC的封装，主要目的就是简化JDBC开发流程，实现事务松耦合，将实体类与SQL命令进行动态对应。</summary>
    <title>MyBatis</title>
    <updated>2026-02-26T09:51:32.079Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    <content>
      <![CDATA[<h1 id="docker"><a class="markdownIt-Anchor" href="#docker"></a> Docker</h1><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><h3 id="传统部署项目方式"><a class="markdownIt-Anchor" href="#传统部署项目方式"></a> 传统部署项目方式</h3><p>简单地说，我们手里有个 WEB 应用，叫做模仿天猫 J2EE版，现在站长把这个给大家用。 大家为了能够顺利地把这个 WEB应用跑起来，必须做如下工作：</p><ol><li>安装 FTP 服务器，配置它，配置FTP用户</li><li>安装JAVA环境</li><li>安装数据库，配置数据库</li><li>安装TOMCAT</li><li>开放FTP和TOMCAT端口</li><li>上传站长给大家的 模仿天猫J2EE应用</li><li>配置 TOMCAT</li><li>上传站长给大家的 模仿天猫的 SQL语句</li><li>导入这个 SQL 语句</li><li>启动TOMCAT</li></ol><p>这么一系列的动作，才可以使用起来！</p><p>原因只有一个，你没有运行模仿天猫的环境，得自己搭建这个环境才行。</p><p>这个搭建环境的过程是如此之长， 不仅耗时耗力，而且只要有一步忘记了，或者做错了，都会卡在那里做不下去，无法得到最后想要的效果</p><h3 id="docker方式"><a class="markdownIt-Anchor" href="#docker方式"></a> Docker方式</h3><p>还是部署 J2EE 这个事情，下面用 Docker 来做。</p><ol><li>首先，要弄个 Linux 操作系统，这个是跑不掉的</li><li>安装 Docker</li><li>在Docker里， 装了个小的操作系统 Linux</li><li>站长把 部署一个J2EE应用 里 列举出来的 10件事情都 由站长做了<br />4.1. <code>安装 FTP 服务器，配置它，配置FTP用户</code><br />4.2. <code>安装JAVA环境</code><br />4.3. <code>安装数据库，配置数据库</code><br />4.4. <code>安装TOMCAT</code><br />4.5. <code>开发FTP和TOMCAT端口</code><br />4.6. <code>上传站长给大家的 模仿天猫J2EE应用</code><br />4.7. <code>配置 TOMCAT</code><br />4.8. <code>上传站长给大家的 模仿天猫的 SQL语句</code><br />4.9. <code>导入这个 SQL 语句</code><br />4.10. <code>启动TOMCAT</code></li><li>然后，站长直接把 Docker 里面这个，已经有环境，已经装好了J2EE应用，已经确保可以用<strong>的 &quot;Linux 操作系统” 整个儿扔给你</strong></li></ol><blockquote><p>这就是 Docker</p></blockquote><h2 id="安装docker"><a class="markdownIt-Anchor" href="#安装docker"></a> 安装Docker</h2><p>市面上的教程，安装 Docker 通常会分为</p><ol><li>Linux 里安装 Docker</li><li>Mac 里安装 Docker</li><li>Windows 里安装 Docker</li></ol><p>事实上呢，大家工作的时候90%的可能性，都是会在 Linux 上装 Docker,用 Docker. 所以 Mac安装和 Windows 安装就显得意义不大了，所以站长就直接带着大家撸 Linux 安装好了</p><h3 id="安装启动docker"><a class="markdownIt-Anchor" href="#安装启动docker"></a> 安装/启动docker</h3><p><strong>更新yum</strong></p><p>我们会通过 yum 来安装 Docker, 所以首先更新 yum</p><pre><code class="highlight plaintext">yum -y update</code></pre><hr /><p><strong>安装docker</strong></p><pre><code class="highlight plaintext">yum install docker -y</code></pre><hr /><p><strong>启动docker</strong></p><pre><code class="highlight plaintext">systemctl start docker.servicesystemctl status docker.service</code></pre><blockquote><p>看到那个 active 就表示已经在运行啦</p></blockquote><p>以下是docker 的生命周期管理常用命令：</p><pre><code class="highlight plaintext">systemctl stop docker.servicesystemctl start docker.servicesystemctl restart docker.servicesystemctl status docker.service</code></pre><h2 id="docker跑天猫项目"><a class="markdownIt-Anchor" href="#docker跑天猫项目"></a> Docker跑天猫项目</h2><h3 id="常用工具"><a class="markdownIt-Anchor" href="#常用工具"></a> 常用工具</h3><p>围绕 Docker 的正常使用，还需要一些配套工具。<br />刚装的 CentOS ， 有些工具有，有些没有，所以我会习惯性地装如下工具</p><ul><li><strong>iproute</strong> 用来执行 ip address 查看本机地址</li><li><strong>ftp</strong> 用来测试ftp 服务器</li><li><strong>bind_utils</strong> 用来运行 nslookup</li><li><strong>net-tools</strong> 用来执行 netstate</li><li><strong>wget</strong> 既是执行 wget的</li></ul><pre><code class="highlight plaintext">yum install iproute ftp bind-utils net-tools wget -y</code></pre><blockquote><p>这些工具都是比较常见的，尤其在检验某个服务是否正常工作的时候，会起到很好的作用</p></blockquote><h3 id="配置dns"><a class="markdownIt-Anchor" href="#配置dns"></a> 配置DNS</h3><p>虚拟机的 dns 是宿主机，即同学用的台式电脑或者笔记本。 有时候会有问题，我们需要把它改成常用的 DNS。</p><p>先运行</p><pre><code class="highlight plaintext">nslookup www.baidu.com</code></pre><p>会发现它使用的域名服务器地址是<br />192.168.84.2，这样是不行的，后面 docker 运行会出问题。<br />所以我们把它改为公用的 域名服务器地址</p><pre><code class="highlight plaintext">vi /etc/resolv.conf</code></pre><p>为如下</p><pre><code class="highlight plaintext"># Generated by NetworkManagersearch www.tendawifi.comnameserver 119.29.29.29nameserver 182.254.116.116</code></pre><pre><code class="highlight plaintext">nslookup www.baidu.com</code></pre><p>可以看到 域名服务器地址已经是 119.29.29.29 了</p><h3 id="配置镜像加速器"><a class="markdownIt-Anchor" href="#配置镜像加速器"></a> 配置镜像加速器</h3><p>站长的 天猫是放在 <a href="http://hub.docker.com">hub.docker.com</a> 的，系在国外滴，学员要拉到本机会比较卡。<br />为了提高网络速度，我们需要配置镜像加速器。<br />直接运行如下代码</p><pre><code class="highlight plaintext">sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;&quot;registry-mirrors&quot;: [&quot;https://hvmf8r55.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><p>然后通过如下命令查看 daemon.json 是否已经生效了</p><pre><code class="highlight plaintext">tail /etc/docker/daemon.json</code></pre><h3 id="拉取运行镜像"><a class="markdownIt-Anchor" href="#拉取运行镜像"></a> 拉取/运行镜像</h3><p><strong>拉取镜像</strong><br />站长把 可运行天猫的 Linux，做成了一个叫做 “镜像” 的东西。 经过以上的配置工作后，接下来，就要把它从 <a href="http://hub.docker.com">hub.docker.com</a> 上拉下来</p><pre><code class="highlight plaintext">docker pull how2j/tmall</code></pre><hr /><p><strong>运行镜像</strong></p><pre><code class="highlight plaintext">docker run -dit --privileged -p21:21 -p80:80 -p8080:8080 -p30000-30010:30000-30010 --name how2jtmall how2j/tmall:latest /usr/sbin/init</code></pre><hr /><p><strong>检查是否启动</strong></p><pre><code class="highlight plaintext">netstat -anp|grep 8080</code></pre><p>可以发现8080端口已经启动了，而且是交给了docker在使用</p><h3 id="访问"><a class="markdownIt-Anchor" href="#访问"></a> 访问</h3><pre><code class="highlight plaintext">http://192.168.84.128:8080/tmall/</code></pre><p>有的同学，跑起来之后，只有图片，没有数据，我研究了一下，发现是容器里数据库起慢了导致的，需要重启tomcat才可以解决。 解决步骤：</p><ol><li>先进入容器</li></ol><pre><code class="highlight plaintext">docker exec -it how2jtmall /bin/bash</code></pre><ol start="2"><li>然后重启</li></ol><pre><code class="highlight plaintext">tomcat/usr/local/tomcat7/bin/shutdown.sh/usr/local/tomcat7/bin/startup.sh</code></pre><hr /><p><strong>访问地址</strong></p><p>在教程里使用的访问地址是站长虚拟机的地址，你的虚拟机地址肯定不是这个。 使用</p><pre><code class="highlight plaintext">ip address</code></pre><p>就可以获取你的地址了</p><h2 id="docker概念理解"><a class="markdownIt-Anchor" href="#docker概念理解"></a> Docker概念理解</h2><h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3><p><strong>仓库</strong>： 别人做好的现成的镜像，都放在仓库里<br /><strong>镜像</strong>： 自己要用哪个镜像，就先拉到本地来。镜像就相当于还没激活的容器。<br /><strong>容器</strong>： 容器就是跑起来的镜像，就是一个完整的工作环境</p><h3 id="概念图"><a class="markdownIt-Anchor" href="#概念图"></a> 概念图</h3><p>如图所示： 最上面是镜像仓库</p><p>在 <strong>拉取镜像</strong> 中的语句：</p><pre><code class="highlight plaintext">docker pull how2j/tmall</code></pre><p>“how2j/tmall” 就是站长事先做好的一个镜像。 所谓的镜像，就是持久化后的，安装了各种工具，软件和服务的一个Linux 操作系统</p><p>它是 站长事先就上传到 docker 的镜像仓库去的。 镜像仓库又在哪里呢？</p><p>它就在这里啦：</p><pre><code class="highlight plaintext">https://cloud.docker.com/u/how2j/repository/docker/how2j/tmall</code></pre><p>通过pull 命令, pull 就是拉取的意思，指的是把镜像从服务器上拉到 Docker 本地。</p><hr /><p>拉到本地之后，再把这个<strong>镜像激活</strong>，所谓的激活，就是把他 run 起来。 用的命令就是 运行镜像 中的 run 命令。</p><ul><li>docker run 表示运行一个镜像</li><li>-dit 是 -d -i -t 的缩写。 -d ，表示 detach，即在后台运行。 -i 表示提供交互接口，这样才可以通过 docker 和 跑起来的操作系统交互。 -t 表示提供一个 tty (伪终端)，与 -i 配合就可以通过 ssh 工具连接到 这个容器里面去了</li><li>–privileged 启动容器的时候，把权限带进去。 这样才可以在容器里进行完整的操作</li><li>-p21:21 第一个21，表示在CentOS 上开放21端口。 第二个21 表示在容器里开放21端口。 这样当访问CentOS 的21端口的时候，就会间接地访问到容器里了</li><li>-p8080:8080 和21 一个道理，在本例里，访问的地址是 <a href="http://192.168.84.128:8080/tmall/%EF%BC%8C">http://192.168.84.128:8080/tmall/，</a> 这个 192.168.84.128 是CentOS 的ip地址，8080是 CentOS 的端口，但是通过-p8080:8080 这么一映射，就访问到容器里的8080端口上的 tomcat了</li><li>-p30000-30010 和21也是一个道理，这个是ftp用来传输数据的</li><li>–name how2jtmall 给容器取了个名字，叫做 how2jtmall，方便后续管理</li><li>how2j/tmall:latest how2j/tmall就是镜像的名称， latest是版本号，即最新版本</li><li>/usr/sbin/init: 表示启动后运行的程序，即通过这个命令做初始化</li></ul><pre><code class="highlight plaintext">docker run -dit --privileged -p21:21 -p80:80 -p8080:8080 -p30000-30010:30000-30010 --name how2jtmall how2j/tmall:latest /usr/sbin/init</code></pre><h3 id="进入容器"><a class="markdownIt-Anchor" href="#进入容器"></a> 进入容器</h3><p>所谓的进入容器，就是进入启动的 运行Tomcat的Linux。<br />进入办法：</p><pre><code class="highlight plaintext">docker exec -it how2jtmall /bin/bash</code></pre><p>进去之后，就可以像操作一个普通 linux 那样操作了，如图所示执行 ls 命令</p><h2 id="docker镜像管理"><a class="markdownIt-Anchor" href="#docker镜像管理"></a> Docker镜像管理</h2><p>镜像管理常见的有这么些：</p><ol><li>search 查看仓库里有些什么镜像</li><li>pull 拉取镜像</li><li>images 查看本地有些什么镜像</li><li>rmi 删除本地镜像</li><li>修改本地镜像名称</li><li>push , 把镜像提交到仓库</li></ol><h3 id="search"><a class="markdownIt-Anchor" href="#search"></a> search</h3><pre><code class="highlight plaintext">docker search how2j</code></pre><p>如图所示仓库里通过关键字 找到一个 how2j 的镜像。<br />当然我们也可以找其他常见的，如 mysql, tomcat, nginx 等等。</p><blockquote><p>镜像名称前面会默认加上 <a href="http://docker.io/">docker.io/</a></p></blockquote><h4 id="示例查找tomcat"><a class="markdownIt-Anchor" href="#示例查找tomcat"></a> 示例：查找tomcat</h4><pre><code class="highlight plaintext">docker search tomcat</code></pre><p>会出来很多，那么到底应该用哪个呢？<br />这时，就打开 <a href="http://hub.docker.com">hub.docker.com</a> ，然后搜索 tomcat。 或者点击如下链接</p><pre><code class="highlight plaintext">https://hub.docker.com/search?q=tomcat&amp;type=image</code></pre><p>可以看到更多的 tomcat了。<br />而第一个，就是docker 官网提供的 tomcat了，一般就用他了吧</p><hr /><p><strong>选择版本</strong></p><p>tomcat 又有很多版本，到底选哪个呢？<br />点击官网的 Tomcat 镜像，然后点击 tag，就发现又有很多版本</p><p><a href="https://hub.docker.com/_/tomcat?tab=tags">https://hub.docker.com/_/tomcat?tab=tags</a></p><p>那么就选一个自己当前需要的吧。 比如我要用 8.0 的话，那么就执行如下命令</p><pre><code class="highlight plaintext">docker pull tomcat:8.0</code></pre><p>不同镜像的用法不一样，在它的描述里都有详细讲解如何启动等等信息：</p><p><a href="https://hub.docker.com/_/tomcat?tab=description&amp;page=2">https://hub.docker.com/_/tomcat?tab=description&amp;page=2</a></p><p>比如这个8.0,按照官方指导启动办法：</p><pre><code class="highlight plaintext">docker run -it --rm -p 8888:8080 tomcat:8.0</code></pre><blockquote><p>这个 --rm 表示如果容器已经存在了，自动删除容器</p></blockquote><hr /><p><strong>访问</strong></p><p>然后访问：<a href="http://%3Cip%3E:8888">http://&lt;ip&gt;:8888</a></p><p>就可以看到如图所示的效果</p><h3 id="images命令"><a class="markdownIt-Anchor" href="#images命令"></a> images命令</h3><p>就可以查看所有的本地镜像</p><pre><code class="highlight plaintext">docker images</code></pre><h3 id="rmi命令"><a class="markdownIt-Anchor" href="#rmi命令"></a> rmi命令</h3><p>用于删除镜像</p><pre><code class="highlight plaintext">docker imagesdocker rmi docker.io/tomcat:8.0</code></pre><blockquote><p>用于删除镜像。 e? 怎么删不掉，这是因为这个镜像有对应的容器啦。 最好把对应的容器删了，才来删除它比较好啦。 所以这里就暂时不管啦，等后面学会了删除容器，再来删除镜像吧</p></blockquote><h3 id="push"><a class="markdownIt-Anchor" href="#push"></a> push</h3><p>push 用于把镜像提交到仓库。 但是呢，还没讲怎么修改镜像，所以先不谈怎么提交，后面专门来谈如何push</p><h3 id="tag"><a class="markdownIt-Anchor" href="#tag"></a> tag</h3><p>通过tag可以对镜像进行标记，如图所示，把 <a href="http://docker.io/tomcat:8.0">docker.io/tomcat:8.0</a> <a href="http://xn--docker-2e8iz74kwhlk20g.io/mytomcat:8.0">标记成了docker.io/mytomcat:8.0</a></p><pre><code class="highlight plaintext">docker tag docker.io/tomcat:8.0 docker.io/mytomcat:8.0</code></pre><p>这样 image_id= “ef6a7c98d192” 的镜像，就有两个标记了，分别是</p><ul><li><a href="http://docker.io/tomcat:8.0">docker.io/tomcat:8.0</a></li><li><a href="http://docker.io/mytomcat:8.0">docker.io/mytomcat:8.0</a></li></ul><h3 id="删除全部镜像"><a class="markdownIt-Anchor" href="#删除全部镜像"></a> 删除全部镜像</h3><p>有时候为了调试，需要不厌其烦地删除镜像，下面这句话就会自动删除所有镜像啦</p><pre><code class="highlight plaintext">docker rmi $(docker images -q)</code></pre><h2 id="docker容器管理"><a class="markdownIt-Anchor" href="#docker容器管理"></a> Docker容器管理</h2><p>接着就是容器管理的一套命令了</p><ol><li>运行 run</li><li>进入 exec attach</li><li>生命周期管理， 暂停，恢复，停止，启动 pause, unpause, stop, start</li><li>ps 查看所有的容器</li><li>检查某个具体的容器</li><li>rm 删除容器</li><li>commit，对容器做了修改后，把改动后的容器，再次转换为镜像</li></ol><h3 id="run"><a class="markdownIt-Anchor" href="#run"></a> run</h3><p><strong>启动一个容器</strong></p><ul><li>docker run 表示运行一个镜像</li><li>-dit 是 -d -i -t 的缩写。 -d ，表示 detach，即在后台运行。 -i 表示提供交互接口，这样才可以通过 docker 和 跑起来的操作系统交互。 -t 表示提供一个 tty (伪终端)，与 -i 配合就可以通过 ssh 工具连接到 这个容器里面去了</li><li>–privileged 启动容器的时候，把权限带进去。 这样才可以在容器里进行完整的操作</li><li>-p21:21 第一个21，表示在CentOS 上开放21端口。 第二个21 表示在容器里开放21端口。 这样当访问CentOS 的21端口的时候，就会间接地访问到容器里了</li><li>-p8080:8080 和21 一个道理，在本例里，访问的地址是 <a href="http://192.168.84.128:8080/tmall/%EF%BC%8C">http://192.168.84.128:8080/tmall/，</a> 这个 192.168.84.128 是CentOS 的ip地址，8080是 CentOS 的端口，但是通过-p8080:8080 这么一映射，就访问到容器里的8080端口上的 tomcat了</li><li>-p30000-30010 和21也是一个道理，这个是ftp用来传输数据的</li><li>–name how2jtmall 给容器取了个名字，叫做 how2jtmall，方便后续管理</li><li>how2j/tmall:latest how2j/tmall就是镜像的名称， latest是版本号，即最新版本</li><li>/usr/sbin/init: 表示启动后运行的程序，即通过这个命令做初始化</li></ul><pre><code class="highlight plaintext">docker run -dit --privileged -p21:21 -p80:80 -p8080:8080 -p30000-30010:30000-30010 --name how2jtmall how2j/tmall:latest /usr/sbin/init</code></pre><h3 id="execattach"><a class="markdownIt-Anchor" href="#execattach"></a> exec/attach</h3><p>在 进入容器 里演示过，使用 exec 进入这个容器</p><pre><code class="highlight plaintext">docker exec -it how2jtmall /bin/bash</code></pre><blockquote><p>attach命令已经过时了</p></blockquote><h3 id="commit"><a class="markdownIt-Anchor" href="#commit"></a> commit</h3><p>commit 很有意思了，因为它的作用就是把一个活生生的容器，再转换为镜像。<br />正式因为有了这个命令，所以站长才把 how2j/tmall 这个镜像做出来啦，哈哈<br />使用办法：</p><pre><code class="highlight plaintext">docker commit how2jtmall how2j/tmall:now</code></pre><p>如图所示，就在 how2j/tmall:latest 这个镜像的基础上，又做了个镜像啦</p><h3 id="生命周期管理"><a class="markdownIt-Anchor" href="#生命周期管理"></a> 生命周期管理</h3><p><strong>暂停</strong>：pause<br /><strong>恢复</strong>：unpause<br /><strong>停止</strong>：stop<br /><strong>开始</strong>：start</p><p>就是常见的生命周期命令。<br />需要注意的是， stop 之后再 start, 容器需要启动，tomcat也需要启动，里面的mysql 也需要启动，都很花时间，所以要等待十几秒再访问，才能看到结果，否则会误以启动失败了</p><h3 id="ps"><a class="markdownIt-Anchor" href="#ps"></a> ps</h3><p>查询所有的容器</p><pre><code class="highlight plaintext">docker ps -a</code></pre><p>查询查询 run 状态的和 pause 状态的， stop状态的就不会查询出来了</p><pre><code class="highlight plaintext">docker ps</code></pre><p>如图所示，故意先stop 容器，再执行 docker ps 就什么都看不到了</p><h3 id="inspect"><a class="markdownIt-Anchor" href="#inspect"></a> inspect</h3><p>检查这个容器里的各项信息</p><pre><code class="highlight plaintext">docker inspect how2jtmall</code></pre><h3 id="rm"><a class="markdownIt-Anchor" href="#rm"></a> rm</h3><p>删除容器，与删除镜像 rmi 命令遥相呼应</p><pre><code class="highlight plaintext">docker rm how2jtmall</code></pre><p>如图所示，在运行中的 容器是不能删除的，要先 stop ,然后再删除。<br />好现在删除了容器了，这下回头再试试 当时因为容器在运行而不能执行的 删除镜像 rmi 命令， 能否执行成功吧</p><h3 id="删除所有容器"><a class="markdownIt-Anchor" href="#删除所有容器"></a> 删除所有容器</h3><p>有时候为了调试，需要不厌其烦地删除容器，下面这句话就会自动删除所有容器啦</p><pre><code class="highlight plaintext">docker rm `docker ps -a -q` -f</code></pre><h2 id="网络恢复"><a class="markdownIt-Anchor" href="#网络恢复"></a> 网络恢复</h2><p>虚拟机一旦重启，或者关机过，那么就会出现可以访问 Linux，但是无法访问里面的 Docker的情况。 可以在 CentOS里做如下事情：</p><pre><code class="highlight plaintext">vi /etc/sysctl.conf或者vi /usr/lib/sysctl.d/00-system.conf添加如下代码：net.ipv4.ip_forward=1重启network服务systemctl restart network查看是否修改成功sysctl net.ipv4.ip_forward如果返回为“net.ipv4.ip_forward = 1”则表示成功了</code></pre><h2 id="docker提交镜像"><a class="markdownIt-Anchor" href="#docker提交镜像"></a> Docker提交镜像</h2><p>在 commit 提交容器 中，我们把一个容器转换为了镜像，接下来我们要把这个镜像提交到仓库里，应该怎么做呢？</p><h3 id="注册登录账号"><a class="markdownIt-Anchor" href="#注册登录账号"></a> 注册/登录账号</h3><p><strong>注册</strong><br />仓库位于 <a href="hub.docker.com">hub.docker.com</a> 上，为了提交新的镜像，肯定要有账号才行，所以第一步是注册账号。<br />比如我就注册了名为 how2j 的账号。<br />注意： 这里命名很重要，因为在提交镜像的时候，由于不是官方的，必须在提交的时候用 ： how2j/tmall 这样的命名格式，而不能简单地命名为 tmall</p><p>注册地址：<a href="https://hub.docker.com/signup">https://hub.docker.com/signup</a><br />注册激活流程都很标准化，就自己去撸吧，我就不多赘述了。</p><hr /><p><strong>登录</strong></p><p>这里说的登录，不是在 <a href="http://hub.docker.com">hub.docker.com</a> 网站上，而是在 docker 后台进行登录。<br />执行命令：</p><pre><code class="highlight plaintext">docker login</code></pre><p>然后输入账号密码就行了，注意，账号不是邮箱地址哦</p><h3 id="push-2"><a class="markdownIt-Anchor" href="#push-2"></a> push</h3><p>推送镜像到仓库<br />首先镜像命名要符合 how2j/tmall 这样的风格，即斜杠前面必须是你的账号名。 如果镜像不是这个名字，可以通过 tag进行标记。 用法在这里： 通过 tag 进行标记<br />然后就可以推送了</p><pre><code class="highlight plaintext">docker push how2j/tmall:latest</code></pre><h2 id="dockerfile"><a class="markdownIt-Anchor" href="#dockerfile"></a> DockerFile</h2><p>DockerFile 与 commit一样，也是用于做镜像的。 与 commit 把现成的 容器转换为镜像不同的是， DockerFile 需要自己写脚本，一条一条地把最终镜像需要的内容撸进去~</p><h3 id="简单举例"><a class="markdownIt-Anchor" href="#简单举例"></a> 简单举例</h3><p>创建一个 docker_demo 目录</p><pre><code class="highlight plaintext">mkdir docker_demo</code></pre><p>然后在里面创建要给 Dockerfile</p><pre><code class="highlight plaintext">cd docker_demovi Dockerfile</code></pre><p>文件内容如下</p><pre><code class="highlight plaintext">FROM how2j/centos7_tools_ftp:latestMAINTAINER 1473335800@qq.comRUN yum -y install java-1.8.0-openjdk.x86_64</code></pre><blockquote><p>就表示基于 how2j/centos7_tools_ftp:latest 这个镜像创建，作者是 <a href="mailto:1473335800@qq.com">1473335800@qq.com</a>， 运行的命令是安装 java.</p></blockquote><p>接着运行到 docker_demo 目录下运行：</p><pre><code class="highlight plaintext">docker build -t how2j/centos_7_tools_ftp_java .</code></pre><blockquote><p>注意，最后有一个点的哦</p></blockquote><h3 id="动手实践"><a class="markdownIt-Anchor" href="#动手实践"></a> 动手实践</h3><p>可以自己做一个Docker的CentOS镜像，然后再CentOS镜像的基础上，结合之前的步骤把天猫项目部署进去，然后再提交到自己的的docker仓库中</p><p>推荐使用7.6.1810这个版本</p><pre><code class="highlight plaintext">docker pull centos:7.6.1810</code></pre>]]>
    </content>
    <id>http://example.com/2021/09/10/Docker/</id>
    <link href="http://example.com/2021/09/10/Docker/"/>
    <published>2021-09-10T04:00:00.000Z</published>
    <summary>docker是一个用Go语言实现的开源项目，可以让我们方便的创建和使用容器，docker将程序以及程序所有的依赖都打包到docker container，这样你的程序可以在任何环境都会有一致的表现，这里程序运行的依赖也就是容器就好比集装箱，容器所处的操作系统环境就好比货船或港口，程序的表现只和集装箱有关系(容器)，和集装箱放在哪个货船或者哪个港口(操作系统)没有关系。</summary>
    <title>Docker</title>
    <updated>2026-02-26T09:38:32.587Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    <content>
      <![CDATA[<h1 id="shell"><a class="markdownIt-Anchor" href="#shell"></a> $Shell</h1><ul><li><a href="">Shell</a><ul><li><a href="">shell教程</a><ul><li><a href="">shell脚本</a></li><li><a href="">shell环境</a></li><li><a href="">第一个shell脚本</a><ul><li><a href="">运行shell脚本有两种方法</a></li></ul></li><li><a href="">存放脚本的好去处</a></li></ul></li><li><a href="">shell变量</a><ul><li><a href="">使用变量</a></li><li><a href="">只读变量</a></li><li><a href="">删除变量</a></li><li><a href="">变量作用域</a><ul><li><a href="">全局变量</a></li><li><a href="">局部变量</a></li><li><a href="">环境变量</a></li></ul></li><li><a href="">变量类型</a></li><li><a href="">获取键盘输入信息</a></li></ul></li><li><a href="">shell传递参数</a><ul><li><a href="">特殊字符处理参数</a></li><li><a href="">获取一条命令的执行结果</a><ul><li><a href="">用 ` 将一条命令包裹起来</a></li><li><a href="">以$(command)这种方式执行命令</a></li></ul></li></ul></li><li><a href="">shell字符串</a><ul><li><a href="">直接</a></li><li><a href="">单引号</a></li><li><a href="">双引号</a></li><li><a href="">拼接字符串</a><ul><li><a href="">获取字符串长度</a></li><li><a href="">提取子字符串</a></li><li><a href="">查找子字符串</a></li></ul></li><li><a href="">截取字符串</a></li></ul></li><li><a href="">shell数组</a><ul><li><a href="">定义数组</a></li><li><a href="">读取数组</a></li><li><a href="">获取数组的所有元�</a>�</li><li><a href="">获取数组的长度</a></li><li><a href="">数组遍历</a></li></ul></li><li><a href="">shell注释</a></li><li><a href="">shell基本运算符</a><ul><li><a href="">算数运算符</a></li><li><a href="">关系运算符</a></li><li><a href="">布尔运算符</a></li><li><a href="">逻辑运算符</a></li><li><a href="">字符串运算符</a></li><li><a href="">文件测试运算符</a></li><li><a href="">;运算符</a></li><li><a href="">Shell中的中括号的用法总结</a><ul><li><a href="">算数比较</a></li><li><a href="">字符串比较</a></li><li><a href="">文件属性比较</a></li></ul></li></ul></li><li><a href="">shell echo命令</a></li><li><a href="">shell printf命令</a><ul><li><a href="">printf的转义序列</a></li></ul></li><li><a href="">shell test命令</a><ul><li><a href="">数值测试</a></li><li><a href="">字符串测试</a></li><li><a href="">文件测试</a></li><li><a href="">逻辑运算</a></li></ul></li><li><a href="">shell流程控制</a><ul><li><a href="">if</a></li><li><a href="">if else</a></li><li><a href="">if else-if else</a></li><li><a href="">for循环</a><ul><li><a href="">for…list</a></li><li><a href="">for…++</a></li></ul></li><li><a href="">while语句</a></li><li><a href="">无限循环</a></li><li><a href="">until循环</a></li><li><a href="">case</a></li><li><a href="">跳出循环</a><ul><li><a href="">break</a></li><li><a href="">continue</a></li></ul></li><li><a href="">case…esac</a></li></ul></li><li><a href="">shell函数</a><ul><li><a href="">shell函数参数</a></li></ul></li><li><a href="">shell输入/输出重定向</a><ul><li><a href="">输出重定向</a></li><li><a href="">输入重定向</a><ul><li><a href="">重定向深入理解</a></li></ul></li><li><a href="">Here Document</a></li><li><a href="">/dev/null文件</a></li></ul></li><li><a href="">shell文件包含</a></li></ul></li></ul><h1 id="shell-2"><a class="markdownIt-Anchor" href="#shell-2"></a> Shell</h1><h2 id="shell教程"><a class="markdownIt-Anchor" href="#shell教程"></a> shell教程</h2><ul><li>shell是一个用c语言编写的程序，他是用户使用Linux的桥梁，shell既是一种命令语言，又是是一种程序设计语言</li><li>shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统的内核服务</li><li>Ken Thompson 的sh 是第一种Unix Shell，Windows Exporer是一个典型的图形界面shell</li></ul><h3 id="shell脚本"><a class="markdownIt-Anchor" href="#shell脚本"></a> shell脚本</h3><ul><li>shell脚本（shell script），是一种为shell编写的脚本程序</li><li>通常所说的shell都指shell脚本，但是shell 和 shell script 是两个不同的概念</li><li>下列shell 都概称shell 脚本，不是指shell自身</li></ul><h3 id="shell环境"><a class="markdownIt-Anchor" href="#shell环境"></a> shell环境</h3><ul><li>shell编程和Java，php编程一样，只要有一个能编写代码的文本编辑器和一个能执行的脚本解释器就可以了，liunx的shell种类众多，常见的有：<ul><li>Bourne shell（/use/bin/sh或/bin/<strong>sh</strong>）<ul><li>是UNIX最初使用的 shell，而且在每种 UNIX 上都可以使用。Bourne Shell 在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种 shell</li></ul></li><li>Bourne Again Shell(/bin/<strong>bash</strong>)<ul><li>LinuxOS 默认的，它是 Bourne Shell 的扩展。 与 Bourne Shell 完全兼容，并且在 Bourne Shell 的基础上增加了很多特性。可以提供命令补全，命令编辑和命令历史等功能。它还包含了很多 C Shell 和 Korn Shell 中的优点，有灵活和强大的编辑接口，同时又很友好的用户界面</li></ul></li><li>C Shell（/usr/bin/<strong>csh</strong>）<ul><li>是一种比 Bourne Shell更适合的变种 Shell，它的语法与 C 语言很相似</li></ul></li><li>K Shell（/usr/bin/<strong>ksh</strong>）<ul><li>集合了 C Shell 和 Bourne Shell 的优点并且和 Bourne Shell 完全兼容</li></ul></li><li>Shell for Root（/sbin/sh）</li><li>… …</li></ul></li><li>本次学习的是Bash,由于易用和免费，bash在日常工作中被广泛使用，同时，bash也是大多数liunx系统默认的shell。</li><li>一般情况下，人们并不区分Bourne Shell和Bourne Again Shell，所以，像#!/bin/sh，同样可以改为#!/bin/bash</li><li>#! 表示告诉系统其后路径所指定的程序即是解释此脚本文件的shell程序。</li></ul><h3 id="第一个shell脚本"><a class="markdownIt-Anchor" href="#第一个shell脚本"></a> 第一个shell脚本</h3><ul><li>打开文本编辑器（可以使用vi/vim命令来创建文件），<a href="http://xn--test-k84fui24c61mkp6ahyn.sh">创建一个文件test.sh</a>，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意，如果用php写shell脚本，扩展名用PHP就可以。</li><li><code>#!</code> <strong>表示告诉系统其后路径所指定的程序即是解释此脚本文件的shell程序</strong>。</li><li><code>echo</code> <strong>命令用于向窗口输出文本</strong>。</li></ul><pre><code class="highlight plaintext">#!/bin/bashecho &quot;Hello World !&quot;</code></pre><h4 id="运行shell脚本有两种方法"><a class="markdownIt-Anchor" href="#运行shell脚本有两种方法"></a> 运行shell脚本有两种方法</h4><ul><li><strong>1 作为可执行程序</strong><ul><li><a href="http://xn--test-z94f1jw4bf7c099bvqbs54ma860cdv7k.sh">将上面的的代码保存为test.sh</a>,并cd到相应的目录</li><li>注意：<strong>一定要写成 <code>./test.sh</code>，<a href="http://xn--test-fb5f919jf30b.sh">而不是test.sh</a>，运行其他二进制的程序也是一样，<a href="http://xn--test-4z8f558f7oc212d.sh">直接写成test.sh</a>，<a href="http://xn--Linuxpathtest-7r7vyuk19a70vlz0ameta5811a6x3fcdjqq8i.sh">Linux系统回去path里寻找有没有叫test.sh</a>，而只有/bin，/sbin，/usr/bin，/usr/sbin等再path里，所以写成test.sh是会找不到命令，要用./test.sh告诉系统说，就在当前目录找</strong>。</li></ul></li></ul><pre><code class="highlight plaintext">$ chmod +x ./test.sh  #使脚本具有执行权限$ ./test.sh  #执行脚本</code></pre><ul><li><strong>2 作为可执行程序</strong><ul><li>这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如<strong>这种运行方式的脚本，不需要再第一行指定解释器信息，写了也没用</strong></li></ul></li></ul><pre><code class="highlight plaintext">$ /bin/sh test.sh  #作为解释器参数$ /bin/php test.php     #作为解释器参数</code></pre><hr /><p>如果<strong>直接运行脚本，我们会报错</strong>，这是为什么呢？</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ hello_worldbash: hello_world: command not found</code></pre><p>如果没有给出可执行程序的明确路径名，那么系统每次都会 搜索一系列的目录，来查找此可执行程序。这个/bin 目录就是其中一个系统会自动搜索的目录。 这个目录列表被存储在一个名为 PATH 的环境变量中。这个 PATH 变量包含一个由冒号分隔开的目录列表。 我们可以查看 PATH 的内容：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ echo $PATH/home/me/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games</code></pre><p>这里我们看到了我们的目录列表。如果我们的脚本驻扎在此列表中任意目录下，那么我们的问题将 会被解决。注意列表中的第一个目录，/home/me/bin。大多数的 Linux 发行版会配置 PATH 变量，让其包含 一个位于用户家目录下的 bin 目录，从而允许用户能够执行他们自己的程序。所以如果我们创建了 一个 bin 目录，并把我们的脚本放在这个目录下，那么这个脚本就应该像其它程序一样开始工作了：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ mkdir bin[me@linuxbox ~]$ mv hello_world bin[me@linuxbox ~]$ hello_worldHello World!</code></pre><p>如果这个 <strong>PATH 变量不包含这个目录</strong>，我们能够轻松地添加它，通过在我们的.bashrc 文件中包含下面 这一行文本：</p><pre><code class="highlight plaintext">export PATH=~/bin:&quot;$PATH&quot;</code></pre><p>当做了这个修改之后，它会在每个新的终端会话中生效。为了把这个修改应用到当前的终端会话中， 我们必须让 shell 重新读取这个 .bashrc 文件。这可以<strong>通过 “sourcing”.bashrc 文件</strong>来完成：</p><pre><code class="highlight plaintext">[me@linuxbox ~]$ . .bashrc</code></pre><blockquote><p>这个点（.）命令是 source 命令的同义词，一个 shell 内部命令，用来读取一个指定的 shell 命令文件， 并把它看作是从键盘中输入的一样</p></blockquote><h3 id="存放脚本的好去处"><a class="markdownIt-Anchor" href="#存放脚本的好去处"></a> 存放脚本的好去处</h3><p>这个 ~/bin 目录是存放为个人所用脚本的好地方。如果我们编写了一个脚本，系统中的每个用户都可以使用它， 那么这个脚本的传统位置是 /usr/local/bin。系统管理员使用的脚本经常放到 /usr/local/sbin 目录下。 <strong>大多数情况下，本地支持的软件，不管是脚本还是编译过的程序，都应该放到 /usr/local 目录下， 而不是在 /bin 或 /usr/bin 目录下。这些目录都是由 Linux 文件系统层次结构标准指定</strong>，只包含由 Linux 发行商 所提供和维护的文件。</p><h2 id="shell变量"><a class="markdownIt-Anchor" href="#shell变量"></a> shell变量</h2><ul><li><strong>定义变量时，变量名不加美元负号</strong>，如：</li></ul><pre><code class="highlight plaintext">your_name=&quot;runoob.com&quot;      # 注意：变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样</code></pre><ul><li>命令只能使用英文字母，数字和下划线，首个字母不可以用数字开头</li><li>中间不能使用空格，可以使用下划线</li><li>不能使用标符号</li><li>不能使用bash中的关键字</li></ul><pre><code class="highlight plaintext">for file in &#x27;ls /etc&#x27;或for file in $(ls /etc)#以上语句可以把/etc下目录的文件名循环出来</code></pre><h3 id="使用变量"><a class="markdownIt-Anchor" href="#使用变量"></a> 使用变量</h3><ul><li><strong>使用一个定义过的变量，只要在变量名前面加美元符号即可</strong>，如</li></ul><pre><code class="highlight plaintext">your_name=&quot;qinjx&quot;echo $your_nameecho $&#123;your_name&#125;#加花括号是可选的，用来识别边界，比如for skill in Ada Coffe Action Java; do    echo &quot;i am good at $&#123;skill&#125;Script&quot;done</code></pre><blockquote><p>如果不给skill变量加花括号，写成echo “I am good at skillScript”，解释器就会把skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p></blockquote><blockquote><p><strong>推荐给所有变量加上花括号，这是个好的编程习惯</strong>。</p></blockquote><pre><code class="highlight plaintext">#已经定义的变量，可以重复定义your_name=&quot;tom&quot;echo $your_nameyour_name=&quot;alibaba&quot;echo $your_name</code></pre><blockquote><p>这样写是合法的，但<strong>注意，第二次赋值的时候不能写<code>$your_name=&quot;alibaba&quot;</code>，使用变量的时候才加美元符（$）</strong></p></blockquote><h3 id="只读变量"><a class="markdownIt-Anchor" href="#只读变量"></a> 只读变量</h3><ul><li>使用<strong>readonly</strong>命令可以奖变量定义为只读变量，只读变量的值不能被改变。</li></ul><pre><code class="highlight plaintext">#!/bin/bashmyUrl=&quot;http://www.google.com&quot;readonly myUrlmyUrl=&quot;http://www.runoob.com&quot;</code></pre><ul><li>运行脚本报错</li></ul><pre><code class="highlight plaintext">/bin/sh: NAME: This variable is read only.</code></pre><h3 id="删除变量"><a class="markdownIt-Anchor" href="#删除变量"></a> 删除变量</h3><ul><li>使用<strong>unset</strong>命令可以删除变量，语法：</li></ul><pre><code class="highlight plaintext">unset variable_name</code></pre><ul><li><strong>变量删除后不可以再次使用，unset命令不能删除只读变量</strong></li><li>实例</li></ul><pre><code class="highlight plaintext">#!/bin/shmyUrl=&quot;http://www.runoob.com&quot;unset myUrlecho $myUrl#以上实例没有任何输出</code></pre><h3 id="变量作用域"><a class="markdownIt-Anchor" href="#变量作用域"></a> 变量作用域</h3><h4 id="全局变量"><a class="markdownIt-Anchor" href="#全局变量"></a> 全局变量</h4><p>没有任何命令修饰的变量是一个全局变量，全局变量在同一个shell会话中都是有效的。</p><pre><code class="highlight plaintext">function func()&#123;    a=90&#125;funcecho $a输出：90</code></pre><pre><code class="highlight plaintext">$ a=90$ echo $&#123;a&#125;$ bash $ echo $&#123;a&#125;输出：90 空值</code></pre><h4 id="局部变量"><a class="markdownIt-Anchor" href="#局部变量"></a> 局部变量</h4><p>local命令用于声明一个局部变量</p><pre><code class="highlight plaintext">function func()&#123;    local a=90&#125;funcecho $a输出：空值</code></pre><h4 id="环境变量"><a class="markdownIt-Anchor" href="#环境变量"></a> 环境变量</h4><p>用export命令修饰的变量称为环境变量，在父shell会话中声明一个环境变量，子shell中都可以访问</p><pre><code class="highlight plaintext">$ export path=&quot;/system/bin&quot;$ bash #创建一个新的shell会话$ echo $&#123;path&#125;</code></pre><h3 id="变量类型"><a class="markdownIt-Anchor" href="#变量类型"></a> 变量类型</h3><p>运行shell时，会同事存在三种变量：</p><ul><li><strong>局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li><li><strong>环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行，必要时shell脚本也可以定义环境变量</li><li><strong>shell变量</strong> shell变量是由shell程序设置的特殊变量，shell变量中有一部分时环境变量，有一部分时局部变量，这些变量保证了shell的正常运行</li></ul><h3 id="获取键盘输入信息"><a class="markdownIt-Anchor" href="#获取键盘输入信息"></a> 获取键盘输入信息</h3><ul><li>语法</li></ul><pre><code class="highlight plaintext">read [-options] [variable...]</code></pre><ul><li>以下实例读取键盘输入的内容并将其赋值给shell变量，为 -p 参数用于设置提示信息</li></ul><pre><code class="highlight plaintext">read -p &quot;input a val:&quot; a    #获取键盘输入的 a 变量数字read -p &quot;input b val:&quot; b    #获取键盘输入的 b 变量数字r=$[a+b]                    #计算a+b的结果 赋值给r  不能有空格echo &quot;result = $&#123;r&#125;&quot;        #输出显示结果 r#输出input a val:1input b val:2result = 3</code></pre><ul><li>read 命令一个一个词组地接收输入的参数，每个词组需要使用空格进行分隔；如果输入的词组个数大于需要的参数个数，则多出的词组将被作为整体为最后一个参数接收。</li></ul><pre><code class="highlight plaintext">案例1read firstStr secondStrecho &quot;第一个参数:$firstStr; 第二个参数:$secondStr&quot;执行输出：$ sh test.sh 一 二 三 四第一个参数:一; 第二个参数:二 三 四</code></pre><ul><li>参数说明：<ul><li>-p 输入提示文字</li><li>-n 输入字符长度限制(达到6位，自动结束)</li><li>-t 输入限时</li><li>-s 隐藏输入内容</li></ul></li></ul><pre><code class="highlight plaintext">案例2read -p &quot;请输入一段文字:&quot; -n 6 -t 5 -s passwordecho -e &quot;\npassword is $password&quot;执行输出：$ sh test.sh 请输入一段文字:password is asdfgh</code></pre><h2 id="shell传递参数"><a class="markdownIt-Anchor" href="#shell传递参数"></a> shell传递参数</h2><ul><li>我们可以在执行shell脚本时，<strong>向脚本传递参数，脚本内获取参数的格式为：$n</strong></li><li>n代表一个数字，1为执行脚本的第一个参数，2为执行脚本的第二个参数，以此类推</li><li><strong>实例</strong><ul><li>以下实例我们向脚本传递三个参数，并分别输出，其中<strong>此$0为执行的文件名</strong></li></ul></li></ul><blockquote><p>在为shell脚本传递的参数中如果包含空格，应该使用<strong>单引号或者双引号</strong>将该参数括起来，以便于脚本将这个参数作为整体来接收。</p></blockquote><pre><code class="highlight plaintext">#!/bin/bashecho &quot;Shell 传递参数实例！&quot;;echo &quot;执行的文件名：$0&quot;;echo &quot;第一个参数为：$1&quot;;echo &quot;第二个参数为：$2&quot;;echo &quot;第三个参数为：$3&quot;;</code></pre><ul><li>为脚本设置可执行权限，并执行脚本</li></ul><pre><code class="highlight plaintext">$ chmod +x test.sh $ ./test.sh 1 2 3输出：Shell 传递参数实例！执行的文件名：./test.sh第一个参数为：1第二个参数为：2第三个参数为：3</code></pre><hr /><p>传递参数时，可以使用对参数进行校验的方式处理以减少错误发生：</p><pre><code class="highlight plaintext">if [ -n &quot;$1&quot; ]; then    echo &quot;包含第一个参数&quot;else    echo &quot;没有包含第一参数&quot;fi</code></pre><blockquote><p>注意：中括号 [] 与其中间的代码应该有空格隔开</p></blockquote><h3 id="特殊字符处理参数"><a class="markdownIt-Anchor" href="#特殊字符处理参数"></a> 特殊字符处理参数</h3><table><thead><tr><th>参数处理</th><th>说明</th></tr></thead><tbody><tr><td>$#</td><td>传递到脚本的参数个数</td></tr><tr><td>$*</td><td>以一个单字符串显示所有向脚本传递的参数。如&quot;$* “用「”」括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。</td></tr><tr><td>$$</td><td>脚本运行的当前进程ID号</td></tr><tr><td>$!</td><td>后台运行的最后一个进程ID号</td></tr><tr><td>$@</td><td>与* 相同，但是使用时加引号，并在引号中返回每个参数。如&quot;@“用「”」括起来的情况、以&quot;$ 1&quot; &quot; $ 2&quot; … “$ n” 的形式输出所有参数。</td></tr><tr><td>$-</td><td>显示Shell使用的当前选项，与set命令功能相同。</td></tr><tr><td>$?</td><td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr><tr><td>$0</td><td>当前脚本文件名</td></tr><tr><td>$n(n≥1)</td><td>传递给脚本或函数的参数，n是一个数字，表示第几个参数，注意：n大于9，需要使用${10}的方式</td></tr></tbody></table><ul><li>案例</li></ul><pre><code class="highlight plaintext">#!/bin/bashecho &quot;Shell 传递参数实例！&quot;;echo &quot;第一个参数为：$1&quot;;echo &quot;参数个数为：$#&quot;;echo &quot;传递的参数作为一个字符串显示：$*&quot;;</code></pre><ul><li>执行脚本</li></ul><pre><code class="highlight plaintext">$ chmod +x test.sh $ ./test.sh 1 2 3输出：Shell 传递参数实例！第一个参数为：1参数个数为：3传递的参数作为一个字符串显示：1 2 3</code></pre><ul><li>$* 与 $@的区别<ul><li>相同点：都是引用所有参数</li><li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 &quot; * &quot; 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</li></ul></li></ul><pre><code class="highlight plaintext">#!/bin/bashecho &quot;-- \$* 演示 ---&quot;for i in &quot;$*&quot;;  do    echo $idoneecho &quot;-- \$@ 演示 ---&quot;for i in &quot;$@&quot;;  do    echo $idone</code></pre><ul><li>执行脚本</li></ul><pre><code class="highlight plaintext">$ chmod +x test.sh $ ./test.sh 1 2 3输出：-- $* 演示 ---1 2 3-- $@ 演示 ---123</code></pre><h3 id="获取一条命令的执行结果"><a class="markdownIt-Anchor" href="#获取一条命令的执行结果"></a> 获取一条命令的执行结果</h3><h4 id="用-将一条命令包裹起来"><a class="markdownIt-Anchor" href="#用-将一条命令包裹起来"></a> 用 ` 将一条命令包裹起来</h4><p>`这个符号，在键盘上的位置是在Esc键的下方</p><pre><code class="highlight plaintext">ret=`pwd`echo $&#123;ret&#125;</code></pre><p>在 ` 包裹起来的命令中，也可以访问到变量</p><pre><code class="highlight plaintext">path=&#x27;/&#x27;ret=`ls -l $&#123;path&#125;`echo $&#123;ret&#125;</code></pre><h4 id="以command这种方式执行命令"><a class="markdownIt-Anchor" href="#以command这种方式执行命令"></a> 以$(command)这种方式执行命令</h4><pre><code class="highlight plaintext">ret=$(pwd)echo $&#123;ret&#125;</code></pre><p>用$(command)这种方式也可以访问到变量</p><pre><code class="highlight plaintext">path=&#x27;/&#x27;ret=$(ls -l $&#123;path&#125;)echo $&#123;ret&#125;</code></pre><p>上面的例子中，如果想打印命令结果中的换行符，则：</p><pre><code class="highlight plaintext">path=&#x27;/&#x27;ret=$(ls -l $&#123;path&#125;)echo &quot;$&#123;ret&#125;&quot;</code></pre><blockquote><p>(command)方式来执行命令更加直观，但是要注意，(command) 仅在 Bash Shell 中有效，而反引号可在多种 Shell 中都可使用</p></blockquote><h2 id="shell字符串"><a class="markdownIt-Anchor" href="#shell字符串"></a> shell字符串</h2><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似</p><h3 id="直接"><a class="markdownIt-Anchor" href="#直接"></a> 直接</h3><pre><code class="highlight plaintext">str=helloecho $&#123;str&#125;</code></pre><p>输出：</p><pre><code class="highlight plaintext">hello</code></pre><blockquote><p>这种方式的字符串遇到空格就会被终止</p></blockquote><h3 id="单引号"><a class="markdownIt-Anchor" href="#单引号"></a> 单引号</h3><ul><li>单引号里的<strong>任何字符</strong>都会<strong>原样输出</strong>，单引号中的<strong>变量是无效</strong>的</li><li>单引号字串中<strong>不能出现单独一个的单引号</strong>（对单引号使用转义符后也不行），但<strong>可成对出现</strong>，作为字符串拼接使用。</li></ul><pre><code class="highlight plaintext">str=&#x27;this is a string&#x27;</code></pre><h3 id="双引号"><a class="markdownIt-Anchor" href="#双引号"></a> 双引号</h3><ul><li>双引号中<strong>可以有变量</strong></li><li>双引号中<strong>可以出现转义字符</strong></li></ul><pre><code class="highlight plaintext">your_name=&#x27;runoob&#x27;str=&quot;Hello, I know you are \&quot;$your_name\&quot;! \n&quot;echo -e $str</code></pre><ul><li>输出</li></ul><pre><code class="highlight plaintext">Hello, I know you are &quot;runoob&quot;!</code></pre><h3 id="拼接字符串"><a class="markdownIt-Anchor" href="#拼接字符串"></a> 拼接字符串</h3><pre><code class="highlight plaintext">your_name=&quot;runoob&quot;# 使用双引号拼接greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;echo $greeting  $greeting_1# 使用单引号拼接greeting_2=&#x27;hello, &#x27;$your_name&#x27; !&#x27;greeting_3=&#x27;hello, $&#123;your_name&#125; !&#x27;echo $greeting_2  $greeting_3</code></pre><ul><li>输出结果为</li></ul><pre><code class="highlight plaintext">hello, runoob ! hello, runoob !hello, runoob ! hello, $&#123;your_name&#125; !</code></pre><h4 id="获取字符串长度"><a class="markdownIt-Anchor" href="#获取字符串长度"></a> 获取字符串长度</h4><pre><code class="highlight plaintext">string=&quot;abcd&quot;echo $&#123;#string&#125;   #输出4#或者string=&quot;abcd&quot;expr length &quot;$string&quot;    #输出4</code></pre><h4 id="提取子字符串"><a class="markdownIt-Anchor" href="#提取子字符串"></a> 提取子字符串</h4><ul><li>以下实例从字符串第二个字符开始截取四个字</li></ul><pre><code class="highlight plaintext">string=&quot;runoob is a great site&quot;echo $&#123;string:1:4&#125;输出 unoo</code></pre><blockquote><p>注意：第一个字符的索引值为0</p></blockquote><h4 id="查找子字符串"><a class="markdownIt-Anchor" href="#查找子字符串"></a> 查找子字符串</h4><ul><li>查找字符i或o的位置（哪个字母先出现就计算哪个）</li><li>注意，以上脚本中 ` 是反引号，而不是单引号 '，不要看错了哦。</li></ul><pre><code class="highlight plaintext">string=&quot;runoob is a great site&quot;echo &quot;expr index &quot;$string&quot; io`输出 4</code></pre><h3 id="截取字符串"><a class="markdownIt-Anchor" href="#截取字符串"></a> 截取字符串</h3><ul><li>总结了八种方法</li><li>假定有变量 var=<a href="http://www.aaa.com/123.htm">http://www.aaa.com/123.htm</a></li><li><strong>1.#号截取，删除左边字符，包留右边字符</strong><ul><li>一个 <code>#</code> 表示从左边删除到第一个指定的字符</li><li>其中var是变量名，<code>#</code>号是运算符，<code>*//</code>表示从左边开始删除第一个//号及左边的所有字符</li><li>即删除http://</li><li>结果是：<a href="http://www.aaa.com/123.htm">www.aaa.com/123.htm</a></li></ul></li></ul><pre><code class="highlight plaintext">echo $&#123;var#*//&#125;</code></pre><ul><li><strong>2.<code>##</code>号截取，删除左边字符，包留右边字符</strong><ul><li><code>##*/</code>表示从左边开始删除最后（最右边）一个/号及左边的所有字符</li><li>即删除：<a href="http://www.aaa.com/">http://www.aaa.com/</a></li><li>结果是：123.htm</li></ul></li></ul><pre><code class="highlight plaintext">echo $&#123;var##*/&#125;</code></pre><ul><li><strong>3.%号截取，删除右边的字符，包留左边字符</strong><ul><li>一个 % 表示从右边删除到第一个指定的字符</li><li>%/*表示从右边开始，删除第一个/号及右边的字符</li><li>结果是：<a href="http://www.aaa.com">http://www.aaa.com</a></li></ul></li></ul><pre><code class="highlight plaintext">echo $&#123;var%/*&#125;</code></pre><ul><li><strong>4.%%号截取，删除右边字符，包留左边字符</strong><ul><li>两个 % 表示从左边删除到最后一个指定的字符</li><li>%%/*表示从右边开始，删除最后（最左边）一个/号及右边的字符</li><li>结果是：http:</li></ul></li></ul><pre><code class="highlight plaintext">echo $&#123;var%%/*&#125;</code></pre><ul><li><strong>5.从左边第几个字符开始，及字符的个数</strong><ul><li>其中0表示左边第一个字符开始，5表示字符的总个数</li><li>结果是：http:</li></ul></li></ul><pre><code class="highlight plaintext">echo $&#123;var:0:5&#125;</code></pre><ul><li><strong>6.从左边第几个字符开始，一直到结束</strong><ul><li>其中的7表示左边第8个字符开始，一直到结束</li><li>结果是：<a href="http://www.aaa.com/123.htm">www.aaa.com/123.htm</a></li></ul></li></ul><pre><code class="highlight plaintext">echo $&#123;var:7&#125;</code></pre><ul><li><strong>7.从右边第几个字符开始，及字符的个数</strong><ul><li>其中的0-7表示右边算起第七个字符开始，3表示字符的个数</li><li>结果是：123</li></ul></li></ul><pre><code class="highlight plaintext">echo $&#123;var:0-7:3&#125;</code></pre><ul><li><strong>从右边第几个字符开始，一直到结束</strong><ul><li>表示从右边第七个字符开始，一直到结束</li><li>结果是：123.htm</li></ul></li></ul><pre><code class="highlight plaintext">echo $&#123;var:0-7&#125;</code></pre><blockquote><p>注：左边第一个字符用0表示，右边第一个字符用0-1表示</p></blockquote><h2 id="shell数组"><a class="markdownIt-Anchor" href="#shell数组"></a> shell数组</h2><ul><li>bash支持一维数组（不支持多维数组），并且没有限定数组的大小</li><li>数组的下标由0开始编号，获取数组中的元素要利用下标，下标可以是整数或者算数表达式，其值应大于或等于0</li></ul><h3 id="定义数组"><a class="markdownIt-Anchor" href="#定义数组"></a> 定义数组</h3><ul><li>在shell中，用括号来表示数组，数组元素用“空格”符号分割开，定义语法为：</li></ul><pre><code class="highlight plaintext">数组名=（值1 值2 ... 值n）</code></pre><ul><li>例如：</li></ul><pre><code class="highlight plaintext">#1array_name=(value1 value2 value3 value4)#2array_name=(value0value1value2value3)#3还可以单独定义数组的各个分量array_name[0]=value0array_name[1]=value1array_name[n]=valuen    #可以使用不连续的下标，而且下标的范围没有限制#4数组的值也可以直接写入变量A=1my_array=($A B C D)echo &quot;第一个元素为: $&#123;my_array[0]&#125;&quot;echo &quot;第二个元素为: $&#123;my_array[1]&#125;&quot;echo &quot;第三个元素为: $&#123;my_array[2]&#125;&quot;echo &quot;第四个元素为: $&#123;my_array[3]&#125;&quot;</code></pre><h3 id="读取数组"><a class="markdownIt-Anchor" href="#读取数组"></a> 读取数组</h3><ul><li>读取数据的一般格式</li></ul><pre><code class="highlight plaintext">$&#123;数组名[下标]&#125;</code></pre><ul><li>例如</li></ul><pre><code class="highlight plaintext">valuen=$&#123;array_name[n]&#125;#使用@符号可以获取数组中的所有元素，例如：echo $&#123;array_name[@]&#125;#数组的下标也可以是变量arr=(a b c d)i=2echo $&#123;arr[i]&#125;</code></pre><h3 id="获取数组的所有元素"><a class="markdownIt-Anchor" href="#获取数组的所有元素"></a> 获取数组的所有元素</h3><ul><li>使用@或者* 可以获取数组中的所有元素，例如：</li></ul><pre><code class="highlight plaintext">#!/bin/bashmy_array[0]=Amy_array[1]=Bmy_array[2]=Cmy_array[3]=Decho &quot;数组的元素为: $&#123;my_array[*]&#125;&quot;echo &quot;数组的元素为: $&#123;my_array[@]&#125;&quot;</code></pre><ul><li>执行脚本，输出结果如下：</li></ul><pre><code class="highlight plaintext">$ chmod +x test.sh $ ./test.sh输出：数组的元素为: A B C D数组的元素为: A B C D</code></pre><h3 id="获取数组的长度"><a class="markdownIt-Anchor" href="#获取数组的长度"></a> 获取数组的长度</h3><ul><li>获取数组长度的方法与获取字符串长度的方法相同，例如：</li></ul><pre><code class="highlight plaintext"># 获取数组元素的个数length=$&#123;#array_name[@]&#125;# 或者length=$&#123;#array_name[*]&#125;# 取得数组单个元素的长度lengthn=$&#123;#array_name[n]&#125;</code></pre><h3 id="数组遍历"><a class="markdownIt-Anchor" href="#数组遍历"></a> 数组遍历</h3><ul><li>总结了遍历数组的几种方法</li></ul><pre><code class="highlight plaintext">#!/bin/bashmy_arry=(a b &quot;c&quot;,&quot;d&quot; abc)echo &quot;-------FOR循环遍历输出数组--------&quot;for i in $&#123;my_arry[@]&#125;;do  echo $idoneecho &quot;-------::::WHILE循环输出 使用 let i++ 自增:::::---------&quot;j=0while [ $j -lt $&#123;#my_arry[@]&#125; ]do  echo $&#123;my_arry[$j]&#125;  let j++doneecho &quot;--------:::WHILE循环输出 使用 let  &quot;n++ &quot;自增: 多了双引号，其实不用也可以:::---------&quot;n=0while [ $n -lt $&#123;#my_arry[@]&#125; ]do  echo $&#123;my_arry[$n]&#125;  let &quot;n++&quot;doneecho &quot;---------::::WHILE循环输出 使用 let m+=1 自增,这种写法其他编程中也常用::::----------&quot;m=0while [ $m -lt $&#123;#my_arry[@]&#125; ]do  echo $&#123;my_arry[$m]&#125;  let m+=1doneecho &quot;-------::WHILE循环输出 使用 a=$[$a+1] 自增,个人觉得这种写法比较麻烦::::----------&quot;a=0while [ $a -lt $&#123;#my_arry[@]&#125; ]do echo $&#123;my_arry[$a]&#125; a=$[$a+1]done</code></pre><h2 id="shell注释"><a class="markdownIt-Anchor" href="#shell注释"></a> shell注释</h2><ul><li><strong>以# 开头的行就是注释，会被解释器忽略</strong></li><li>通过每一行加个#号设置多行注释，像这样</li></ul><pre><code class="highlight plaintext">#--------------------------------------------# 这是一个注释# author：李博# site：liboar# slogan：呵呵#--------------------------------------------##### 用户配置区 开始 ######## 这里可以添加脚本描述信息# ###### 用户配置区 结束  #####</code></pre><p>如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？</p><p>每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p><hr /><p><strong>多行注释</strong></p><p>多行注释还可以使用以下格式：</p><pre><code class="highlight plaintext">:&lt;&lt;EOF注释内容...注释内容...注释内容...EOF</code></pre><p>EOF 也可以使用其他符号:</p><pre><code class="highlight plaintext">:&lt;&lt;&#x27;注释内容...注释内容...注释内容...&#x27;:&lt;&lt;!注释内容...注释内容...注释内容...!</code></pre><h2 id="shell基本运算符"><a class="markdownIt-Anchor" href="#shell基本运算符"></a> shell基本运算符</h2><ul><li><strong>算数运算符</strong></li><li><strong>关系运算符</strong></li><li><strong>布尔运算符</strong></li><li><strong>字符串运算符</strong></li><li><strong>文件检测运算符</strong></li></ul><p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如<strong>awk</strong>和<strong>expr</strong>,其中expr最常用，expr是一款表达式计算工具，使用它能完成表达式的求值操作。</p><ul><li>例如，两个数相加（<strong>注意使用的是反引号` 而不是单引号</strong>）</li><li><strong>两点注意</strong>：<ul><li>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</li><li>完整的表达式要被 反斜号<code> </code>包含，注意这个字符不是常用的单引号，在 Esc 键下边。</li></ul></li></ul><pre><code class="highlight plaintext">#!/bin/bashval=`expr 2 + 2`echo &quot;两数之和为 : $val&quot;输出：两数之和为：4</code></pre><h3 id="算数运算符"><a class="markdownIt-Anchor" href="#算数运算符"></a> 算数运算符</h3><ul><li>假定变量a=10,b=20</li><li>注意：条件表达式要放在括号之间，例如 [$ a==$b] 是错误的，必须写成 [ $a == $b ]。</li></ul><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>+</td><td>加法</td><td><code>expr $a + $b</code> 结果为 30。</td></tr><tr><td>-</td><td>减法</td><td><code> expr $a - $b</code> 结果为 -10。</td></tr><tr><td>*</td><td>乘法</td><td><code> expr $a * $b</code> 结果为  200。</td></tr><tr><td>/</td><td>除法</td><td><code> expr $b / $a</code> 结果为 2。</td></tr><tr><td>%</td><td>取余</td><td><code> expr $b % $a</code> 结果为 0。</td></tr><tr><td>=</td><td>赋值</td><td>a=$b 将把变量 b 的值赋给 a。</td></tr><tr><td>==</td><td>相等，用于比较两个数字，相同则返回true</td><td>[ $a == $b ] 返回 false。</td></tr><tr><td>!=</td><td>不想等，用于比较两个数字，不相同则返回true</td><td>[ $a != $b ] 返回 true。</td></tr></tbody></table><blockquote><p><strong>注意</strong>：条件表达式要放在方括号之间，并且要有空格，例如: <code>[$a==$b]</code> 是错误的，必须写成 <code>[ $a == $b ]</code></p></blockquote><ul><li>实例</li></ul><pre><code class="highlight plaintext">#!/bin/basha=10b=20val=`expr $a + $b`echo &quot;a + b : $val&quot;val=`expr $a - $b`echo &quot;a - b : $val&quot;val=`expr $a \* $b`echo &quot;a * b : $val&quot;val=`expr $b / $a`echo &quot;b / a : $val&quot;val=`expr $b % $a`echo &quot;b % a : $val&quot;if [ $a == $b ]then   echo &quot;a 等于 b&quot;fiif [ $a != $b ]then   echo &quot;a 不等于 b&quot;fi</code></pre><ul><li>执行脚本</li></ul><pre><code class="highlight plaintext">a + b : 30a - b : -10a * b : 200b / a : 2b % a : 0a 不等于 b</code></pre><blockquote><p>注意：</p><ul><li>乘号（* ）前边必须加反斜杠（\）才能实现乘法运算</li><li>在mac中shell的expr语法是：<strong>$((表达式))</strong> ，此处表达式中的“* ”不需要转意符号“\”</li></ul></blockquote><ul><li><strong>相加的三种方法</strong></li></ul><pre><code class="highlight plaintext">方式一：a=10b=20c=`expr $&#123;a&#125; + $&#123;b&#125;`echo &quot;$c&quot;方式二：c=$[ `expr 10 + 20` ]echo &quot;$c&quot;方式三：c=$[ 10 + 20 ]echo &quot;$c&quot;方式四：val=$(expr 10 + 20)方式五：a=10b=20c=$(($a+$b))方式六：a=5b=6result=$[$a+$b]或者result=$[ $a + $b ]或者result=$[a+b]或者result=$[ a + b ]</code></pre><h3 id="关系运算符"><a class="markdownIt-Anchor" href="#关系运算符"></a> 关系运算符</h3><ul><li><strong>关系运算符只支持数字，不支持字符串</strong>，除非字符串的值是数字</li><li>假设a=10,b=20</li></ul><blockquote><p><strong>进行数值比较时</strong></p><ul><li>[ expression1 OP expression2 ]，OP 可以为 -gt、-lt、-ge、-le、-eq、-ne</li><li>[[expression1 OP expression2]]，OP 可以为 &gt;、&lt;、&gt;=、&lt;=、==、!=</li></ul></blockquote><blockquote><p><strong>进行字符串比较时</strong></p><ul><li><blockquote><p>、&lt;、==、!= 也可以进行字符串比较</p></blockquote></li><li>进行字符串比较时，== 可以使用 = 替代</li><li>== 和 !=进行字符串比较时，可以使用 [ string1 OP string2 ] 或者 [[ string1 OP string2 ]] 的形式</li><li><blockquote><p>和 &lt; 进行字符串比较时，需要使用[[ string1 OP string2 ]] 或者 [ string1 \OP string2 ]。也就是使用 [] 时，&gt; 和 &lt; 需要使用反斜线转义</p></blockquote></li></ul></blockquote><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>-eq</td><td>equal 检测两个数是否相等，相等返回 true。</td><td>[ $a -eq $b ] 返回 false。</td></tr><tr><td>-ne</td><td>not equal 检测两个数是否不相等，不相等返回 true。</td><td>[ $a -ne $b ] 返回 true。</td></tr><tr><td>-gt</td><td>greater than 检测左边的数是否大于右边的，如果是，则返回 true。</td><td>[ $a -gt $b ] 返回 false。</td></tr><tr><td>-lt</td><td>less than 检测左边的数是否小于右边的，如果是，则返回 true。</td><td>[ $a -lt $b ] 返回 true。</td></tr><tr><td>-ge</td><td>greater than or equal 检测左边的数是否大于等于右边的，如果是，则返回 true。</td><td>[ $a -ge $b ] 返回 false。</td></tr><tr><td>-le</td><td>less than or equal 检测左边的数是否小于等于右边的，如果是，则返回 true。</td><td>[ $a -le $b ] 返回 true。</td></tr></tbody></table><ul><li>实例</li><li><strong>注意：if后有空格</strong></li></ul><pre><code class="highlight plaintext">#!/bin/basha=10b=20if [ $a -eq $b ]then    echo &quot;$a -eq $b : a 等于 b&quot;else    echo &quot;$a -eq $b : a 不等于 b&quot;fiif [ $a -gt $b ]then   echo &quot;$a -gt $b: a 大于 b&quot;else   echo &quot;$a -gt $b: a 不大于 b&quot;fiif [ $a -lt $b ]then   echo &quot;$a -lt $b: a 小于 b&quot;else   echo &quot;$a -lt $b: a 不小于 b&quot;fi   if [ $a -ge $b ]then   echo &quot;$a -ge $b: a 大于或等于 b&quot;else   echo &quot;$a -ge $b: a 小于 b&quot;fiif [ $a -le $b ]then   echo &quot;$a -le $b: a 小于或等于 b&quot;else   echo &quot;$a -le $b: a 大于 b&quot;fi</code></pre><ul><li>执行脚本，输出以下结果：</li></ul><pre><code class="highlight plaintext">10 -eq 20: a 不等于 b10 -ne 20: a 不等于 b10 -gt 20: a 不大于 b10 -lt 20: a 小于 b10 -ge 20: a 小于 b10 -le 20: a 小于或等于 b</code></pre><h3 id="布尔运算符"><a class="markdownIt-Anchor" href="#布尔运算符"></a> 布尔运算符</h3><ul><li>下表列出了常用的布尔运算符，假定变量a为10，变量b为20：</li></ul><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>!</td><td>非运算，表达式为ture则返回false，否则返回true</td><td>[ ! false ] 返回 true</td></tr><tr><td>-o</td><td>或运算，有一个表达式为 true 则返回 true</td><td>[ $a -lt 20 -o $b -gt 100 ] 返回 true</td></tr><tr><td>-a</td><td>与运算，两个表达式都为true才返回true</td><td>[ $a -lt 20 -a $b -gt 100 ] 返回 false</td></tr></tbody></table><ul><li>实例</li></ul><pre><code class="highlight plaintext">#!/bin/bash# a=10b=20if [ $a != $b ]then   echo &quot;$a != $b : a 不等于 b&quot;else   echo &quot;$a != $b: a 等于 b&quot;fiif [ $a -lt 100 -a $b -gt 15 ]then   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 true&quot;else   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 false&quot;fiif [ $a -lt 100 -o $b -gt 100 ]then   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 true&quot;else   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 false&quot;fiif [ $a -lt 5 -o $b -gt 100 ]then   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 true&quot;else   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 false&quot;fi</code></pre><ul><li>执行脚本，输出：</li></ul><pre><code class="highlight plaintext">10 != 20 : a 不等于 b10 小于 100 且 20 大于 15 : 返回 true10 小于 100 或 20 大于 100 : 返回 true10 小于 5 或 20 大于 100 : 返回 false</code></pre><h3 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符"></a> 逻辑运算符</h3><ul><li>以下接受shell的逻辑运算符，a=10,b=20</li><li><strong>注意：这里是双括号[[ ]]</strong></li></ul><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑的AND</td><td>[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><blockquote><p>用&amp;&amp;连接起来的两个命令，前面的执行失败就不执行后面的命令</p></blockquote><blockquote><p>用||连接起来的两个命令，前面的执行失败才会执行后面的命令</p></blockquote><ul><li>实例：</li></ul><pre><code class="highlight plaintext">#!/bin/basha=10b=20if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]then   echo &quot;返回 true&quot;else   echo &quot;返回 false&quot;fiif [[ $a -lt 100 || $b -gt 100 ]]then   echo &quot;返回 true&quot;else   echo &quot;返回 false&quot;fi</code></pre><ul><li>执行脚本，输出</li></ul><pre><code class="highlight plaintext">返回 false返回 true</code></pre><h3 id="字符串运算符"><a class="markdownIt-Anchor" href="#字符串运算符"></a> 字符串运算符</h3><ul><li>下表列出了常用的字符串运算符，假定变量为“abc”,变量b为“efg”</li></ul><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>==/=</td><td>检测两个字符串是否相等，相等返回true</td><td>[ $a == $b ] 返回 false</td></tr><tr><td>!=</td><td>检测两个字符串是否相等，不想等放回true</td><td>[ $a != $b ] 返回 true</td></tr><tr><td>-z</td><td>检测字符串长度是否为0，为0返回true</td><td>[ -z $a ] 返回 false</td></tr><tr><td>-n</td><td>检测字符串长度是否为0，不为0返回true</td><td>[ -n “$a” ] 返回 true</td></tr><tr><td>$</td><td>检测字符串是否为空，不为空返回true</td><td>[ $a ] 返回 true</td></tr></tbody></table><ul><li>实例</li></ul><pre><code class="highlight plaintext">#!/bin/basha=&quot;abc&quot;b=&quot;efg&quot;if [ $a = $b ]then   echo &quot;$a = $b : a 等于 b&quot;else   echo &quot;$a = $b: a 不等于 b&quot;fi   if [ $a != $b ];then   echo &quot;$a != $b : a 不等于 b&quot;else   echo &quot;$a != $b: a 等于 b&quot;fi#并方式if [ $a == &quot;aaa&quot; ] &amp;&amp; [ $b == &quot;bbb&quot; ]then   echo &quot;a 等于 aaa，b 等于 bbb&quot;else   echo &quot;a 不等于 aaa，b 不等于 bbb&quot;fiif [ -z $a ]then   echo &quot;-z $a : 字符串长度为 0&quot;else   echo &quot;-z $a : 字符串长度不为 0&quot;fiif [ -n &quot;$a&quot; ]then   echo &quot;-n $a : 字符串长度不为 0&quot;else   echo &quot;-n $a : 字符串长度为 0&quot;fiif [ $a ]then   echo &quot;$a : 字符串不为空&quot;else   echo &quot;$a : 字符串为空&quot;fi</code></pre><ul><li>运行结果</li></ul><pre><code class="highlight plaintext">abc = efg: a 不等于 babc != efg : a 不等于 b-z abc : 字符串长度不为 0-n abc : 字符串长度不为 0abc : 字符串不为空注意：当a=&quot; &quot;时，输出... ...-z   : 字符串长度为 0-n   : 字符串长度不为 0  : 字符串为空  注意：当a=   时，输出... ...-z  : 字符串长度为 0-n  : 字符串长度为 0 : 字符串为空</code></pre><ul><li><strong>当字符串为“”或者当字符串为“ ”时-z/-n输出不一致的问题</strong></li></ul><h3 id="文件测试运算符"><a class="markdownIt-Anchor" href="#文件测试运算符"></a> 文件测试运算符</h3><ul><li>文件测试运算符用于检测Unix文件的各种属性</li></ul><table><thead><tr><th>操作符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>-b file</td><td>file检测文件是否是块设备文件，如果是，则返回 true</td><td>[ -b $file ] 返回 false</td></tr><tr><td>-c file</td><td>检测文件是否是字符设备文件，如果是，则返回 true</td><td>[ -c $file ] 返回 false</td></tr><tr><td>-d file</td><td>检测文件是否是目录，如果是，则返回 true</td><td>[ -d $file ] 返回 false</td></tr><tr><td>-f file</td><td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true</td><td>[ -f $file ] 返回 true</td></tr><tr><td>-g file</td><td>检测文件是否设置了 SGID 位，如果是，则返回 true</td><td>[ -g $file ] 返回 false</td></tr><tr><td>-k file</td><td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true</td><td>[ -k $file ] 返回 false</td></tr><tr><td>-p file</td><td>检测文件是否是有名管道，如果是，则返回 true</td><td>[ -p $file ] 返回 false</td></tr><tr><td>-u file</td><td>检测文件是否设置了 SUID 位，如果是，则返回 true</td><td>[ -u $file ] 返回 false</td></tr><tr><td>-r file</td><td>检测文件是否可读，如果是，则返回 true</td><td>[ -r $file ] 返回 true</td></tr><tr><td>-w file</td><td>检测文件是否可写，如果是，则返回 true</td><td>[ -w $file ] 返回 true</td></tr><tr><td>-x file</td><td>检测文件是否可执行，如果是，则返回 true</td><td>[ -x $file ] 返回 true</td></tr><tr><td>-s file</td><td>检测文件是否为空（文件大小是否大于0），不为空返回 true</td><td>[ -s $file ] 返回 true</td></tr><tr><td>-e file</td><td>检测文件（包括目录）是否存在，如果是，则返回 true</td><td>[ -e $file ] 返回 true</td></tr></tbody></table><ul><li>实例（变量file表示文件“/var/www/runoob/test.sh”,它的大小为100字节，具有rex权限，将检测该文件的各种属性）</li></ul><pre><code class="highlight plaintext">#!/bin/bashfile=&quot;/var/www/runoob/test.sh&quot;if [ -r $file ]then   echo &quot;文件可读&quot;else   echo &quot;文件不可读&quot;fiif [ -w $file ]then   echo &quot;文件可写&quot;else   echo &quot;文件不可写&quot;fiif [ -x $file ]then   echo &quot;文件可执行&quot;else   echo &quot;文件不可执行&quot;fiif [ -f $file ]then   echo &quot;文件为普通文件&quot;else   echo &quot;文件为特殊文件&quot;fiif [ -d $file ]then   echo &quot;文件是个目录&quot;else   echo &quot;文件不是个目录&quot;fiif [ -s $file ]then   echo &quot;文件不为空&quot;else   echo &quot;文件为空&quot;fiif [ -e $file ]then   echo &quot;文件存在&quot;else   echo &quot;文件不存在&quot;fi</code></pre><ul><li>执行脚本，输出</li></ul><pre><code class="highlight plaintext">文件可读文件可写文件可执行文件为普通文件文件不是个目录文件不为空文件存在</code></pre><h3 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> ;运算符</h3><p>这个运算符用于连接多个语句，使多个语句能够在同一行。用;连接起来的语句，不管前面的执行成不成功，都会执行后面的</p><pre><code class="highlight plaintext">mkdir luoye;cd luoye;pwd</code></pre><h3 id="shell中的中括号的用法总结"><a class="markdownIt-Anchor" href="#shell中的中括号的用法总结"></a> Shell中的中括号的用法总结</h3><ul><li><strong>算术比较</strong>, 比如一个变量是否为0, [ $var -eq 0 ]。</li><li><strong>文件属性测试</strong>，比如一个文件是否存在，[ -e $var ], 是否是目录，[ -d $var ]。</li><li><strong>字符串比较</strong>, 比如两个字符串是否相同， [[ $var1 = $var2 ]]</li></ul><h4 id="算数比较"><a class="markdownIt-Anchor" href="#算数比较"></a> 算数比较</h4><p>对变量或值进行算术条件判断：</p><pre><code class="highlight plaintext">[ $var -eq 0 ]  # 当 $var 等于 0 时，返回真[ $var -ne 0 ]  # 当 $var 不等于 0 时，返回真[ $var -ge 0 ]  # 当 $var 大于等于 0 时，返回真[ $var -gt 0 ]  # 当 $var 大于 0 时，返回真[ $var -le 0 ]  # 当 $var 小于等于等于 0 时，返回真[ $var -lt 0 ]  # 当 $var 小于 0 时，返回真</code></pre><blockquote><p>需要注意的是 [ 与 ] 与操作数之间一定要有一个空格，否则会报错</p></blockquote><p>可以通过 -a (and) 或 -o (or) 结合多个条件进行测试：</p><pre><code class="highlight plaintext">[ $var1 -ne 0 -a $var2 -gt 2 ]  # 使用逻辑与 -a[ $var1 -ne 0 -o $var2 -gt 2 ]  # 使用逻辑或 -o</code></pre><h4 id="字符串比较"><a class="markdownIt-Anchor" href="#字符串比较"></a> 字符串比较</h4><p>在进行字符串比较时，最好使用双中括号 [[ ]]. 因为单中括号可能会导致一些错误，因此最好避开它们。检查两个字符串是否相同：</p><pre><code class="highlight plaintext">[[ $str1 = $str2 ]]     #当 str1等于str1等于str2 时，返回真。也就是说，str1 和 str2 包含的文本是一样的。[[ $str1 != $str2 ]]    #如果 str1 与 str2 不相同，则返回真[[ -z $str1 ]]   #如果 str1 是空字符串，则返回真[[ -n $str1 ]]   #如果 str1 是非空字符串，则返回真</code></pre><blockquote><p>其中的单等于号也可以写成双等于号，也就是说，上面的字符串比较等效于 [[ $str1 == $str2 ]]</p></blockquote><blockquote><p>注意 = 前后有一个空格，如果忘记加空格, 就变成了赋值语句，而非比较关系了</p></blockquote><p>使用逻辑运算符 &amp;&amp; 和 || 可以轻松地将多个条件组合起来, 比如：</p><pre><code class="highlight plaintext">str1=&quot;Not empty&quot;str2=&quot;&quot;if [[ -n $str1 ]] &amp;&amp; [[ -z $str2 ]];then  echo str1 is nonempty and str2 is empty string.fi</code></pre><hr /><p>test 命令也可以从来执行条件检测，用 test 可以避免使用过多的括号，[] 中的测试条件同样可以通过 test 来完成。</p><pre><code class="highlight plaintext">if [ $var -eq 0 ]; then echo &quot;True&quot;; fi</code></pre><p>等价于:</p><pre><code class="highlight plaintext">if test $var -eq 0; then echo &quot;True&quot;; fi</code></pre><h4 id="文件属性比较"><a class="markdownIt-Anchor" href="#文件属性比较"></a> 文件属性比较</h4><pre><code class="highlight plaintext">[ -f $file_var ]    #变量 $file_var 是一个正常的文件路径或文件名 (file)，则返回真[ -x $var ]     #变量 $var 包含的文件可执行 (execute)，则返回真[ -d $var ]     #变量 $var 包含的文件是目录 (directory)，则返回真[ -e $var ]   #变量 $var 包含的文件存在 (exist)，则返回真[ -c $var ]   #变量 $var 包含的文件是一个字符设备文件的路径 (character)，则返回真[ -b $var ]   #变量 $var 包含的文件是一个块设备文件的路径 (block)，则返回真[ -w $var ]   #变量 $var 包含的文件可写(write)，则返回真[ -r $var ]   #变量 $var 包含的文件可读 (read)，则返回真[ -L $var ]   #变量 $var 包含是一个符号链接 (link)，则返回真</code></pre><p>使用方法如下：</p><pre><code class="highlight plaintext">fpath=&quot;/etc/passwd&quot;if [ -e $fpath ]; then  echo File exits;else  echo Does not exit;fi</code></pre><h2 id="shell-echo命令"><a class="markdownIt-Anchor" href="#shell-echo命令"></a> shell echo命令</h2><ul><li>shell的echo指令与php的echo指令类似，都是用于字符串的输出，命令格式：</li></ul><pre><code class="highlight plaintext">echo string</code></pre><ul><li>显示普通字符串：</li></ul><pre><code class="highlight plaintext">echo &#x27;it is a test&#x27;输出it is a test</code></pre><ul><li>显示转义字符</li></ul><pre><code class="highlight plaintext">echo &quot;\&quot;it is a test\&quot;&quot;输出&quot;it is a test&quot;</code></pre><ul><li>显示变量</li></ul><pre><code class="highlight plaintext">#!/bin/shread name echo &quot;$name It is a test&quot;输出[root@www ~]# sh test.shOK                     #标准输入OK It is a test        #输出</code></pre><ul><li>显示换行</li></ul><pre><code class="highlight plaintext">echo -e &quot;OK! \n&quot;    #开启转义echo &quot;It is a test&quot;输出OK!It is a test</code></pre><ul><li>显示不换行</li></ul><pre><code class="highlight plaintext">#!/bin/shecho -e &quot;OK! \c&quot; # -e 开启转义 \c 不换行echo &quot;It is a test&quot;输出OK! It is a test</code></pre><ul><li><strong>显示结果定向至文件</strong><ul><li><code>&gt;</code>重定向输出到某个位置，替换原有文件的所有内容。</li><li><code>&gt;&gt;</code> 重定向追加到某个位置，在原有文件的末尾添加内容。</li><li><code>&lt;</code>重定向输入某个位置文件。2&gt; 重定向错误输出。</li><li><code>2&gt;&gt;</code> 重定向错误追加输出到文件末尾。</li><li><code>&amp;&gt;</code> 混合输出错误的和正确的都输出</li></ul></li></ul><pre><code class="highlight plaintext">echo &quot;It is a test&quot; &gt; myfile</code></pre><ul><li>原样输出字符串，不进行转义或取变量（用单引号）</li></ul><pre><code class="highlight plaintext">echo &#x27;$name\&quot;&#x27;输出￥name\&quot;</code></pre><ul><li>显示命令执行结果</li></ul><pre><code class="highlight plaintext">echo `date`输出Thu Jul 24 10：08：46 CST 2014</code></pre><h2 id="shell-printf命令"><a class="markdownIt-Anchor" href="#shell-printf命令"></a> shell printf命令</h2><ul><li>printf命令语法</li></ul><pre><code class="highlight plaintext">printf format-string [arguments...]</code></pre><ul><li>参数说明<ul><li>format-string:为格式控制字符串</li><li>arguments:为参数列表</li></ul></li><li>实例1</li></ul><pre><code class="highlight plaintext">$ echo &quot;Hello, Shell&quot;Hello, Shell$ printf &quot;Hello, Shell\n&quot;Hello, Shell$</code></pre><ul><li>案例2</li></ul><pre><code class="highlight plaintext">#!/bin/bash printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg  printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234 printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543 printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876 输出：姓名     性别   体重kg郭靖     男      66.12杨过     男      48.65郭芙     女      47.99</code></pre><blockquote><p>%s %c %d %f都是格式替代符</p><p>%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</p><p>%-4.2f 指格式化为小数，其中.2指保留2位小数。</p></blockquote><ul><li>d: Decimal 十进制整数</li><li>s: String 字符串</li><li>c: Char 字符</li><li>f: Float 浮点</li></ul><pre><code class="highlight plaintext">#!/bin/bash # format-string为双引号printf &quot;%d %s\n&quot; 1 &quot;abc&quot;# 单引号与双引号效果一样 printf &#x27;%d %s\n&#x27; 1 &quot;abc&quot; # 没有引号也可以输出printf %s abcdef# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用printf %s abc defprintf &quot;%s\n&quot; abc defprintf &quot;%s %s %s\n&quot; a b c d e f g h i j# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替printf &quot;%s and %d \n&quot; 输出：1 abc1 abcabcdefabcdefabcdefa b cd e fg h ij   and 0</code></pre><h3 id="printf的转义序列"><a class="markdownIt-Anchor" href="#printf的转义序列"></a> printf的转义序列</h3><table><thead><tr><th>序列</th><th>说明</th></tr></thead><tbody><tr><td>\a</td><td>警告字符，通常为ASCII的BEL字符</td></tr><tr><td>\b</td><td>后退</td></tr><tr><td>\c</td><td>抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td></tr><tr><td>\f</td><td>换页</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\t</td><td>水平制表符</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\</td><td>一个字面上的反斜杠字符</td></tr><tr><td>\ddd</td><td>表示1到3位数八进制的字符，仅在格式字符串中有效</td></tr><tr><td>\0ddd</td><td>表示1-3位的八进制字符</td></tr></tbody></table><pre><code class="highlight plaintext">$ printf &quot;a string, no processing:&lt;%s&gt;\n&quot; &quot;A\nB&quot;a string, no processing:&lt;A\nB&gt;$ printf &quot;a string, no processing:&lt;%b&gt;\n&quot; &quot;A\nB&quot;a string, no processing:&lt;AB&gt;$ printf &quot;www.runoob.com \a&quot;www.runoob.com $                  #不换行</code></pre><h2 id="shell-test命令"><a class="markdownIt-Anchor" href="#shell-test命令"></a> shell test命令</h2><ul><li>shell中的test命令用于检查某个条件是否成立，它可以进行数值，字符和文件三个方面的测试</li></ul><h3 id="数值测试"><a class="markdownIt-Anchor" href="#数值测试"></a> 数值测试</h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-eq</td><td>等于则为真</td></tr><tr><td>-ne</td><td>不等于则为真</td></tr><tr><td>-gt</td><td>大于则为真</td></tr><tr><td>-ge</td><td>大于等于为真</td></tr><tr><td>-lt</td><td>小于则为真</td></tr><tr><td>-le</td><td>小于等于则为真</td></tr></tbody></table><p>实例演示：</p><pre><code class="highlight plaintext">num1=100num2=100if test $[num1] -eq $[num2]then     echo &#x27;两个数相等&#x27;else    echo &#x27;两个数不相等&#x27;fi</code></pre><ul><li>代码中的[]执行基本的算数运算，如</li></ul><pre><code class="highlight plaintext">#!/bin/basha=5b=6result=$[a+b]   #注意等号两边不能有空格echo &quot;result 为: $result&quot;# 输出：result 为： 11</code></pre><h3 id="字符串测试"><a class="markdownIt-Anchor" href="#字符串测试"></a> 字符串测试</h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>等于则为真</td></tr><tr><td>!=</td><td>不想等则为真</td></tr><tr><td>-z 字符串</td><td>字符串的长度为零则为真</td></tr><tr><td>-n 字符串</td><td>字符串的长度不为零则为真</td></tr></tbody></table><pre><code class="highlight plaintext">num1=&quot;ru1noob&quot;num2=&quot;runoob&quot;if test $num1 = $num2then    echo &#x27;两个字符串相等!&#x27;else    echo &#x27;两个字符串不相等!&#x27;fi</code></pre><h3 id="文件测试"><a class="markdownIt-Anchor" href="#文件测试"></a> 文件测试</h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-e 文件名</td><td>如果文件存在则为真</td></tr><tr><td>-r 文件名</td><td>如果文件存在且可读则为真</td></tr><tr><td>-w 文件名</td><td>如果文件存在且可写则为真</td></tr><tr><td>-x 文件名</td><td>如果文件存在且可执行则为真</td></tr><tr><td>-s 文件名</td><td>如果文件存在且至少有一个字符则为真</td></tr><tr><td>-d 文件名</td><td>如果文件存在且为目录则为真</td></tr><tr><td>-f 文件名</td><td>如果文件存在且为普通文件则为真</td></tr><tr><td>-c 文件名</td><td>如果文件存在且为字符型特殊文件则为真</td></tr><tr><td>-b 文件名</td><td>如果文件存在且为块特殊文件则为真</td></tr></tbody></table><pre><code class="highlight plaintext">cd /binif test -e ./bashthen    echo &#x27;文件已存在&#x27;else    echo &#x27;文件不存在&#x27;fi</code></pre><h3 id="逻辑运算"><a class="markdownIt-Anchor" href="#逻辑运算"></a> 逻辑运算</h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>与</td></tr><tr><td>-o</td><td>或（优先级最低）</td></tr><tr><td>!</td><td>非（优先级最高）</td></tr></tbody></table><pre><code class="highlight plaintext">cd /binif test -e ./notFile -o -e ./bashthen    echo &#x27;至少有一个文件存在!&#x27;else    echo &#x27;两个文件都不存在&#x27;fi</code></pre><h2 id="shell流程控制"><a class="markdownIt-Anchor" href="#shell流程控制"></a> shell流程控制</h2><h3 id="if"><a class="markdownIt-Anchor" href="#if"></a> if</h3><ul><li>语法格式</li></ul><pre><code class="highlight plaintext">if conditionthen    command1    command2    ...    commandNfi或者if [ $(ps -ef | grep -c &quot;ssh&quot;) -gt 1 ]; then echo &quot;true&quot;; fi</code></pre><blockquote><p>末尾的fi就是if倒过来拼写，后面还会遇到类似的</p></blockquote><h3 id="if-else"><a class="markdownIt-Anchor" href="#if-else"></a> if else</h3><ul><li>语法</li></ul><pre><code class="highlight plaintext">if conditionthen    command1    command2    ...    command3else    commandNfi</code></pre><h3 id="if-else-if-else"><a class="markdownIt-Anchor" href="#if-else-if-else"></a> if else-if else</h3><ul><li>语法</li></ul><pre><code class="highlight plaintext">if conditionthen    command1elif conditionthen    command2else    commandNfi</code></pre><ul><li>实例：判断两个变量是否相等</li></ul><pre><code class="highlight plaintext">a=10b=20if [ $a == $b ]then   echo &quot;a 等于 b&quot;elif [ $a -gt $b ]then   echo &quot;a 大于 b&quot;elif [ $a -lt $b ]then   echo &quot;a 小于 b&quot;else   echo &quot;没有符合的条件&quot;fi</code></pre><ul><li>if else语句也经常和test命令结合使用</li></ul><pre><code class="highlight plaintext">num1=$[2*3]num2=$[1+5]if test $[num1] -eq $[num2]then    echo &#x27;两个数字相等!&#x27;else    echo &#x27;两个数字不相等!&#x27;fi</code></pre><h3 id="for循环"><a class="markdownIt-Anchor" href="#for循环"></a> for循环</h3><h4 id="forlist"><a class="markdownIt-Anchor" href="#forlist"></a> for…list</h4><pre><code class="highlight plaintext">for var in item1 item2...itemNdo    command1    command2    ...    commandNdone或者for var in item1 item2 ... itemN; do command1; command2… done;</code></pre><ul><li>当变量值在列表里，for循环即执行一次所有命令，使用变量名获取列表里的当前值，命令可为任何有效的shell命令和语句。in列表可以包含替换，字符串，文件名</li><li>in列表是可选的，如果不用它，for循环使用命令行的位置参数</li></ul><pre><code class="highlight plaintext">for loop in 1 2 3 4 5do    echo &quot;The value is: $loop&quot;done输出：The value is: 1The value is: 2The value is: 3The value is: 4The value is: 5</code></pre><ul><li>输出字符串</li></ul><pre><code class="highlight plaintext">for str in &#x27;This is a string&#x27;do    echo $strdone输出结果：this is a string</code></pre><h4 id="for"><a class="markdownIt-Anchor" href="#for"></a> for…++</h4><p>for还有另外一种使用方法</p><pre><code class="highlight plaintext">for((assignment;condition:next));do    command_1;    command_2;    commond_..;done;</code></pre><p>如上所示，这里的 for 循环与 C 中的相似，但并不完全相同。</p><p>通常情况下 shell 变量调用需要加 $,但是 for 的 (()) 中不需要,下面来看一个例子：</p><pre><code class="highlight plaintext">#!/bin/bashfor((i=1;i&lt;=5;i++));do    echo &quot;这是第 $i 次调用&quot;;done;#执行结果这是第1次调用这是第2次调用这是第3次调用这是第4次调用这是第5次调用</code></pre><h3 id="while语句"><a class="markdownIt-Anchor" href="#while语句"></a> while语句</h3><ul><li>while循环用于不断执行一系列命令，也用于从输入文件中读取数据，命令通常为测试条件，格式为：</li></ul><pre><code class="highlight plaintext">while conditiondo    commanddone</code></pre><ul><li>以下是一个基本的while循环，测试条件是：如果int小于等于5，那么条件返回真，int从0开始，每次循环处理时，int加1，运行上述脚本，返回数字1到5，然后终止</li></ul><blockquote><p>使用中使用了bash let命令，它用于执行一个或者多个表达式，变量计算中不需要加上$来表示变量</p></blockquote><pre><code class="highlight plaintext">#!/bin/bashint=1while(( $int&lt;=5 ))do    echo $int    let &quot;int++&quot;done输出12345</code></pre><ul><li>while也可以用于从键盘读取信息，下面的例子中，输入信息被设置为变量FILM，按<ctrl-D>结束循环</li></ul><pre><code class="highlight plaintext">echo &#x27;按下 &lt;CTRL-D&gt; 退出&#x27;echo -n &#x27;输入你最喜欢的网站名: &#x27;while read FILMdo    echo &quot;是的！$FILM 是一个好网站&quot;done输出：按下 &lt;CTRL-D&gt; 退出输入你最喜欢的网站名:菜鸟教程是的！菜鸟教程 是一个好网站</code></pre><h3 id="无限循环"><a class="markdownIt-Anchor" href="#无限循环"></a> 无限循环</h3><pre><code class="highlight plaintext">while:do    commanddone</code></pre><p>或者</p><pre><code class="highlight plaintext">while truedo    commanddone</code></pre><p>或者</p><pre><code class="highlight plaintext">for (( ; ; ))</code></pre><h3 id="until循环"><a class="markdownIt-Anchor" href="#until循环"></a> until循环</h3><ul><li>until循环执行一系列命令直到条件为true时停止</li><li>until循环与while循环处理方式上刚好相反</li><li>一般while循环优于until循环，但在某些售后也只是极少数情况下，until循环更加有用</li></ul><pre><code class="highlight plaintext">until conditiondo    commanddone</code></pre><ul><li>condition一般为条件表达式，如果返回值为false,则继续执行循环体内的语句，否则跳出循环，以下实例我们使用until命令输出0-9的数字</li></ul><pre><code class="highlight plaintext">#!/bin/basha=0until [ ! $a -lt 10 ]do   echo $a   a=`expr $a + 1`done输出：0123456789</code></pre><h3 id="case"><a class="markdownIt-Anchor" href="#case"></a> case</h3><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td><code>a)</code></td><td>若单词为 “a”，则匹配</td></tr><tr><td><code>[[:alpha:]])</code></td><td>若单词是一个字母字符，则匹配</td></tr><tr><td><code>???)</code></td><td>若单词只有3个字符，则匹配</td></tr><tr><td><code>*.txt)</code></td><td>若单词以 “.txt” 字符结尾，则匹配</td></tr><tr><td><code>*)</code></td><td>匹配任意单词。把这个模式做为 case 命令的最后一个模式，是一个很好的做法， 可以捕捉到任意一个与先前模式不匹配的数值；也就是说，捕捉到任何可能的无效值。</td></tr></tbody></table><pre><code class="highlight plaintext">case 值 in模式1)    command1    command2    ...    commandN    ;;模式2）    command1    command2    ...    commandN    ;;esac</code></pre><ul><li>caes工作方式如上图所示，取值后面必须为单词in，每一模式必须以又括号结束，取值可以为变量或常熟，匹配发现取值符合某一模式后，其间所有命令开始执行直至;;。</li><li>取值将检测匹配的每一个模式，一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式，如果无一匹配模式，使用星号* 捕获此值，再执行后面的命令</li></ul><pre><code class="highlight plaintext">echo &#x27;输入 1 到 4 之间的数字:&#x27;echo &#x27;你输入的数字为:&#x27;read aNumcase $aNum in    1)  echo &#x27;你选择了 1&#x27;    ;;    2)  echo &#x27;你选择了 2&#x27;    ;;    3)  echo &#x27;你选择了 3&#x27;    ;;    4)  echo &#x27;你选择了 4&#x27;    ;;    *)  echo &#x27;你没有输入 1 到 4 之间的数字&#x27;    ;;esac输出：输入 1 到 4 之间的数字:你输入的数字为:3你选择了 3</code></pre><h3 id="跳出循环"><a class="markdownIt-Anchor" href="#跳出循环"></a> 跳出循环</h3><ul><li>break和continue</li></ul><h4 id="break"><a class="markdownIt-Anchor" href="#break"></a> break</h4><ul><li>break命令允许跳出所有循环（终止执行后面的所有循环）</li><li>下面的列子中，脚本进入死循环直至用户输入数字大于5</li></ul><pre><code class="highlight plaintext">#!/bin/bashwhile :do    echo -n &quot;输入 1 到 5 之间的数字:&quot;    read aNum    case $aNum in        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;        ;;        *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;            break        ;;    esacdone输出：输入 1 到 5 之间的数字:3你输入的数字为 3!输入 1 到 5 之间的数字:7你输入的数字不是 1 到 5 之间的! 游戏结束</code></pre><h4 id="continue"><a class="markdownIt-Anchor" href="#continue"></a> continue</h4><p>continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p><pre><code class="highlight plaintext">#!/bin/bashwhile :do    echo -n &quot;输入 1 到 5 之间的数字: &quot;    read aNum    case $aNum in        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;        ;;        *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot;            continue            echo &quot;游戏结束&quot;        ;;    esacdone</code></pre><blockquote><p>运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 echo “游戏结束” 永远不会被执行。</p></blockquote><h3 id="caseesac"><a class="markdownIt-Anchor" href="#caseesac"></a> case…esac</h3><p>case … esac 与其他语言中的 switch … case 语句类似，是一种多分枝选择结构，每个 case 分支用右圆括号开始，用两个分号 ;; 表示 break，即执行结束，跳出整个 case … esac 语句，esac（就是 case 反过来）作为结束标记。case … esac 语法格式如下：</p><pre><code class="highlight plaintext">case 值 in模式1)    command1    command2    command3    ;;模式2）    command1    command2    command3    ;;*)    command1    command2    command3    ;;esac</code></pre><p>case 后为取值，值可以为变量或常数。</p><p>值后为关键字 in，接下来是匹配的各种模式，每一模式最后必须以右括号结束，模式支持正则表达式。</p><pre><code class="highlight plaintext">#!/bin/shsite=&quot;runoob&quot;case &quot;$site&quot; in   &quot;runoob&quot;) echo &quot;菜鸟教程&quot;   ;;   &quot;google&quot;) echo &quot;Google 搜索&quot;   ;;   &quot;taobao&quot;) echo &quot;淘宝网&quot;   ;;esac</code></pre><h2 id="shell函数"><a class="markdownIt-Anchor" href="#shell函数"></a> shell函数</h2><p>linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。</p><p>shell中函数的定义格式如下：</p><ul><li>可以带function fun() 定义，也可以直接fun() 定义,不带任何参数</li><li>参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)</li></ul><pre><code class="highlight plaintext">[ function ] funname [()]&#123;    action;    [return int;]&#125;</code></pre><p>下面的例子定义了一个函数并进行调用：</p><pre><code class="highlight plaintext">#!/bin/bash# author:菜鸟教程# url:www.runoob.comdemoFun()&#123;    echo &quot;这是我的第一个 shell 函数!&quot;&#125;echo &quot;-----函数开始执行-----&quot;demoFunecho &quot;-----函数执行完毕-----&quot;</code></pre><p>输出结果：</p><pre><code class="highlight plaintext">-----函数开始执行-----这是我的第一个 shell 函数!-----函数执行完毕-----</code></pre><hr /><p>下面定义一个带有return语句的函数：</p><ul><li><strong>函数返回值在调用该函数后通过 $? 来获得</strong></li></ul><pre><code class="highlight plaintext">#!/bin/bash# author:菜鸟教程# url:www.runoob.comfunWithReturn()&#123;    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;    echo &quot;输入第一个数字: &quot;    read aNum    echo &quot;输入第二个数字: &quot;    read anotherNum    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;    return $(($aNum+$anotherNum))&#125;funWithReturnecho &quot;输入的两个数字之和为 $? !&quot;</code></pre><p>输出：</p><pre><code class="highlight plaintext">这个函数会对输入的两个数字进行相加运算...输入第一个数字: 1输入第二个数字: 2两个数字分别为 1 和 2 !输入的两个数字之和为 3 !</code></pre><blockquote><p>注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可</p></blockquote><h3 id="shell函数参数"><a class="markdownIt-Anchor" href="#shell函数参数"></a> shell函数参数</h3><p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数…</p><p>带参数的函数示例：</p><pre><code class="highlight plaintext">#!/bin/bash# author:菜鸟教程# url:www.runoob.comfunWithParam()&#123;    echo &quot;第一个参数为 $1 !&quot;    echo &quot;第二个参数为 $2 !&quot;    echo &quot;第十个参数为 $10 !&quot;    echo &quot;第十个参数为 $&#123;10&#125; !&quot;    echo &quot;第十一个参数为 $&#123;11&#125; !&quot;    echo &quot;参数总数有 $# 个!&quot;    echo &quot;作为一个字符串输出所有参数 $* !&quot;&#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73</code></pre><p>输出结果：</p><pre><code class="highlight plaintext">第一个参数为 1 !第二个参数为 2 !第十个参数为 10 !第十个参数为 34 !第十一个参数为 73 !参数总数有 11 个!作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !</code></pre><blockquote><p><strong>注意，10 不能获取第十个参数，获取第十个参数需要{10}。当n&gt;=10时，需要使用${n}来获取参数</strong>。</p></blockquote><table><thead><tr><th>参数处理</th><th>说明</th></tr></thead><tbody><tr><td>$#</td><td>传递到脚本或函数的参数个数</td></tr><tr><td>$*</td><td>以一个单字符串显示所有向脚本传递的参数</td></tr><tr><td>$$</td><td>脚本运行的当前进程ID号</td></tr><tr><td>$!</td><td>后台运行的最后一个进程的ID号</td></tr><tr><td>$@</td><td>与<code>$*</code>相同，但是使用时加引号，并在引号中返回每个参数</td></tr><tr><td>$-</td><td>显示Shell使用的当前选项，与set命令功能相同</td></tr><tr><td>$?</td><td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误</td></tr></tbody></table><blockquote><p>函数与命令的执行结果可以作为条件语句使用。要注意的是，和 C 语言不同，shell 语言中 0 代表 true，0 以外的值代表 false</p></blockquote><hr /><p>$? <strong>仅对其上一条指令负责</strong>，一旦函数返回后其返回值没有立即保存入参数，那么其返回值将不再能通过 $? 获得</p><p>测试代码</p><pre><code class="highlight plaintext">#!/bin/bashfunction demoFun1()&#123;    echo &quot;这是我的第一个 shell 函数!&quot;    return `expr 1 + 1`&#125;demoFun1echo $?function demoFun2()&#123; echo &quot;这是我的第二个 shell 函数!&quot; expr 1 + 1&#125;demoFun2echo $?demoFun1echo 在这里插入命令！echo $?</code></pre><p>输出：</p><pre><code class="highlight plaintext">这是我的第一个 shell 函数!2这是我的第二个 shell 函数!20这是我的第一个 shell 函数!在这里插入命令！0</code></pre><p>调用 demoFun2 后，函数最后一条命令 expr 1 + 1 得到的返回值（$?值）为 0，意思是这个命令没有出错。所有的命令的返回值仅表示其是否出错，而不会有其他有含义的结果。第二次调用 demoFun1 后，没有立即查看 $? 的值，而是先插入了一条别的 echo 命令，最后再查看 $? 的值得到的是 0，也就是上一条 echo 命令的结果，而 demoFun1 的返回值被覆盖了。下面这个测试，连续使用两次 echo $?，得到的结果不同，更为直观：</p><pre><code class="highlight plaintext">#!/bin/bashfunction demoFun1()&#123;    echo &quot;这是我的第一个 shell 函数!&quot;    return `expr 1 + 1`&#125;demoFun1echo $?echo $?</code></pre><p>输出：</p><pre><code class="highlight plaintext">这是我的第一个 shell 函数!20</code></pre><h2 id="shell输入输出重定向"><a class="markdownIt-Anchor" href="#shell输入输出重定向"></a> shell输入/输出重定向</h2><p>大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回​​到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。</p><p>重定向命令列表如下：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>command &gt; file</td><td>将输出重定向到 file</td></tr><tr><td>command &lt; file</td><td>将输入重定向到 file</td></tr><tr><td>command &gt;&gt; file</td><td>将输出以追加的方式重定向到 file</td></tr><tr><td>n &gt; file</td><td>将文件描述符为 n 的文件重定向到 file</td></tr><tr><td>n &gt;&gt; file</td><td>将文件描述符为 n 的文件以追加的方式重定向到 file</td></tr><tr><td>n &gt;&amp; m</td><td>将输出文件 m 和 n 合并。n &lt;&amp; m将输入文件 m 和 n 合并</td></tr><tr><td>&lt;&lt; tag</td><td>将开始标记 tag 和结束标记 tag 之间的内容作为输入</td></tr></tbody></table><blockquote><p>需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）</p></blockquote><h3 id="输出重定向"><a class="markdownIt-Anchor" href="#输出重定向"></a> 输出重定向</h3><p>重定向一般通过在命令间插入特定的符号来实现。特别的，这些符号的语法如下所示:</p><pre><code class="highlight plaintext">command1 &gt; file1</code></pre><blockquote><p>上面这个命令执行command1然后将输出的内容存入file1。</p></blockquote><blockquote><p>注意任何file1内的已经存在的内容将被新内容替代。如果要将新内容添加在文件末尾，请使用&gt;&gt;操作符</p></blockquote><p>实例：</p><p>执行下面的 who 命令，它将命令的完整的输出重定向在用户文件中(users):</p><pre><code class="highlight plaintext">$ who &gt; users</code></pre><p>执行后，并没有在终端输出信息，这是因为输出已被从默认的标准输出设备（终端）重定向到指定的文件。你可以使用 cat 命令查看文件内容：</p><pre><code class="highlight plaintext">$ cat users_mbsetupuser console  Oct 31 17:35 tianqixin    console  Oct 31 17:35 tianqixin    ttys000  Dec  1 11:33</code></pre><p>输出重定向会覆盖文件内容，请看下面的例子：</p><pre><code class="highlight plaintext">$ echo &quot;菜鸟教程：www.runoob.com&quot; &gt; users$ cat users菜鸟教程：www.runoob.com$</code></pre><p>如果不希望文件内容被覆盖，可以使用 &gt;&gt; 追加到文件末尾，例如：</p><pre><code class="highlight plaintext">$ echo &quot;菜鸟教程：www.runoob.com&quot; &gt;&gt; users$ cat users菜鸟教程：www.runoob.com菜鸟教程：www.runoob.com$</code></pre><h3 id="输入重定向"><a class="markdownIt-Anchor" href="#输入重定向"></a> 输入重定向</h3><p>和输出重定向一样，Unix命令也可以从文件获取输入，语法为：</p><pre><code class="highlight plaintext">command1 &lt; file1</code></pre><blockquote><p>这样，本来需要从键盘获取输入的命令会转移到文件读取内容</p></blockquote><p>实例：</p><ul><li>接着以上实例，我们需要统计test.txt 文件的行数,执行以下命令：</li></ul><pre><code class="highlight plaintext">$ wc -l test.txt41 test.txt</code></pre><ul><li>也可以使用重定向：</li></ul><pre><code class="highlight plaintext">$  wc -l &lt; test.txt2</code></pre><blockquote><p>注意：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容</p></blockquote><hr /><p>同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中</p><pre><code class="highlight plaintext">command1 &lt; infile &gt; outfile</code></pre><h4 id="重定向深入理解"><a class="markdownIt-Anchor" href="#重定向深入理解"></a> 重定向深入理解</h4><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p><ul><li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li><li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li><li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息</li></ul><p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。如果希望 stderr 重定向到 file，可以这样写：</p><pre><code class="highlight plaintext">$ command 2 &gt; file</code></pre><p>如果希望 stderr 追加到 file 文件末尾，可以这样写：</p><pre><code class="highlight plaintext">$ command 2 &gt;&gt; file</code></pre><hr /><p>2表示错误文件(stderr)</p><p>如果希望将stdout和stderr合并后重定向到file，可以这样写：</p><pre><code class="highlight plaintext">$ command &gt; file 2&gt;&amp;1或者$ command &gt;&gt; file 2&gt;&amp;1</code></pre><h3 id="here-document"><a class="markdownIt-Anchor" href="#here-document"></a> Here Document</h3><p>Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。</p><p>它的基本的形式如下：</p><pre><code class="highlight plaintext">command &lt;&lt; delimiter    documentdelimiter</code></pre><p>它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command</p><blockquote><p>结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。</p></blockquote><blockquote><p>开始的delimiter前后的空格会被忽略掉。</p></blockquote><p>实例：</p><p>在命令中通过wc -l 命令计算Here Document的行数</p><pre><code class="highlight plaintext">$ wc -l &lt;&lt; EOF    欢迎来到    菜鸟教程    www.runoob.comEOF3          # 输出结果为 3 行$</code></pre><p>我们也可以将 Here Document 用在脚本中，例如：</p><pre><code class="highlight plaintext">#!/bin/bash# author:菜鸟教程# url:www.runoob.comcat &lt;&lt; EOF欢迎来到菜鸟教程www.runoob.comEOF</code></pre><p>执行以上脚本，输出结果：</p><pre><code class="highlight plaintext">欢迎来到菜鸟教程www.runoob.com</code></pre><h3 id="devnull文件"><a class="markdownIt-Anchor" href="#devnull文件"></a> /dev/null文件</h3><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：</p><pre><code class="highlight plaintext">$ command &gt; /dev/null</code></pre><p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到&quot;禁止输出&quot;的效果。</p><p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p><pre><code class="highlight plaintext">$ command &gt; /dev/null 2&gt;&amp;1</code></pre><blockquote><p>注意：0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）</p></blockquote><h2 id="shell文件包含"><a class="markdownIt-Anchor" href="#shell文件包含"></a> shell文件包含</h2><p>和其他语言一样，<strong>Shell 也可以包含外部脚本</strong>。这样可以很方便的封装一些公用的代码作为一个独立的文件。Shell 文件包含的语法格式如下：</p><pre><code class="highlight plaintext">. filename   # 注意点号(.)和文件名中间有一空格或source filename</code></pre><p>实例：</p><p>创建两个 shell 脚本文件</p><p><a href="http://test1.sh">test1.sh</a> 代码如下：</p><pre><code class="highlight plaintext">#!/bin/bashurl=&quot;http://www.runoob.com&quot;</code></pre><p><a href="http://test2.sh">test2.sh</a> 代码如下：</p><pre><code class="highlight plaintext">#!/bin/bash#使用 . 号来引用test1.sh 文件. ./test1.sh# 或者使用以下包含文件代码source ./test1.shecho &quot;菜鸟教程官网地址：$url&quot;</code></pre><p>接下来，我们为 <a href="http://test2.sh">test2.sh</a> 添加可执行权限并执行：</p><pre><code class="highlight plaintext">$ chmod +x test2.sh $ ./test2.sh 菜鸟教程官网地址：http://www.runoob.com</code></pre><blockquote><p>注：被包含的文件 <a href="http://test1.sh">test1.sh</a> 不需要可执行权限。</p></blockquote>]]>
    </content>
    <id>http://example.com/2021/08/22/Shell/</id>
    <link href="http://example.com/2021/08/22/Shell/"/>
    <published>2021-08-22T05:00:00.000Z</published>
    <summary>shell常用命令以及基础知识。</summary>
    <title>Shell</title>
    <updated>2026-02-26T08:20:58.125Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Nanohttp" scheme="http://example.com/tags/Nanohttp/"/>
    <content>
      <![CDATA[<h1 id="nanohttp"><a class="markdownIt-Anchor" href="#nanohttp"></a> $NanoHTTP</h1><h1 id="nanohttp使用教程"><a class="markdownIt-Anchor" href="#nanohttp使用教程"></a> NanoHTTP使用教程</h1><p>nanohttp是一个轻量级的，微型的HTTP服务器，如果想给某项目增加一个http的访问，nanohttp是一个很好的选择，只需引入一个jar包，即可轻松配置。</p><h2 id="依赖"><a class="markdownIt-Anchor" href="#依赖"></a> 依赖</h2><pre><code class="highlight plaintext">&lt;dependency&gt;    &lt;groupId&gt;org.nanohttpd&lt;/groupId&gt;     &lt;!-- &lt;groupId&gt;com.nanohttpd&lt;/groupId&gt; for 2.1.0 and earlier --&gt;    &lt;artifactId&gt;nanohttpd&lt;/artifactId&gt;    &lt;version&gt;2.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.nanohttpd&lt;/groupId&gt;     &lt;!-- &lt;groupId&gt;com.nanohttpd&lt;/groupId&gt; for 2.1.0 and earlier --&gt;    &lt;artifactId&gt;nanohttpd-apache-fileupload&lt;/artifactId&gt;    &lt;version&gt;2.2.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="文件服务器源代码"><a class="markdownIt-Anchor" href="#文件服务器源代码"></a> 文件服务器源代码</h2><pre><code class="highlight plaintext">import fi.iki.elonen.NanoFileUpload;import fi.iki.elonen.NanoHTTPD;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.io.FileUtils;import org.springframework.http.HttpEntity;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpMethod;import org.springframework.http.ResponseEntity;import org.springframework.util.LinkedMultiValueMap;import org.springframework.util.MultiValueMap;import org.springframework.web.client.RestTemplate;import shaded.org.apache.commons.lang.StringUtils;import java.io.*;import java.net.URL;import java.security.KeyStore;import java.util.*;import java.util.zip.CRC32;import java.util.zip.CheckedOutputStream;import java.util.zip.ZipEntry;import java.util.zip.ZipOutputStream;/** * @author libo * @date Created in 2020/8/11 13:59 */public class NanoHttpServer extends NanoHTTPD &#123;    public static void main(String[] args) &#123;        try &#123;            NanoHttpServer nanoHttpServer = new NanoHttpServer(44016, new RestTemplate());            //nanoHttpServer.makeSecure(NanoHTTPD.makeSSLSocketFactory(&quot;/keystore.jks&quot;, &quot;password&quot;.toCharArray()), null);            nanoHttpServer.start(NanoHTTPD.SOCKET_READ_TIMEOUT, false);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    private RestTemplate restTemplate ;    private String url = &quot;https://adm.suninfo.com:44000/sdmPermissionCheck&quot;;    private NanoFileUpload uploader;    private Properties props;    public NanoHttpServer(int port, RestTemplate restTemplate) throws IOException &#123;        super(port);        this.restTemplate = restTemplate;        this.uploader = new NanoFileUpload(new DiskFileItemFactory());        this.props = new Properties();        InputStream resourceAsStream = this.getClass().getClassLoader().getResourceAsStream(&quot;constant.properties&quot;);        props.load(resourceAsStream);        System.setProperty(&quot;javax.net.ssl.trustStore&quot;, new File(NanoHttpServer.class.getClassLoader().getResource(&quot;keystore.jks&quot;).getPath()).getAbsolutePath());        //start(NanoHTTPD.SOCKET_READ_TIMEOUT, false);    &#125;    @Override    public Response serve(IHTTPSession session) &#123;        String uri = session.getUri();        //跨域域请求通过//        if(session.getMethod() == Method.OPTIONS)&#123;//            Response response = newFixedLengthResponse(Response.Status.OK, &quot;text/html;charset=utf-8&quot;, null);//            response.addHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);//            response.addHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;GET,POST,PUT,DELETE,OPTIONS,PATCH&quot;);//            response.addHeader(&quot;Access-Control-Allow-Headers&quot;, session.getHeaders().get(&quot;access-control-request-headers&quot;));//            //response.addHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);//            //response.addHeader(&quot;Access-Control-Max-Age&quot;, &quot;2&quot;);//            return response;//        &#125;//        if(!checkLegal(session))&#123;            return responseError(&quot;无权限&quot;);        &#125;        if(uri.contains(&quot;upload&quot;))&#123;            return uploadFile(session);        &#125;else if(uri.contains(&quot;download&quot;))&#123;            return downFile(session);        &#125;else if(uri.contains(&quot;delete&quot;))&#123;            return delFile(session);        &#125;        return responseError(&quot;未知错误&quot;);    &#125;    //删除文件    private Response delFile(IHTTPSession session) &#123;        try &#123;            session.parseBody(new HashMap&lt;String, String&gt;());            Map&lt;String, String&gt; parms = session.getParms();            Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = parms.entrySet();            for(Map.Entry&lt;String, String&gt; tempEntry:entries)&#123;                String value = tempEntry.getValue();                deleteFile(new File(value));            &#125;        &#125; catch (Exception e) &#123;            return responseError(&quot;error&quot;);        &#125;        return responseSuccess(&quot;success&quot;);    &#125;    //上传文件    private Response uploadFile(IHTTPSession session) &#123;        String uri = session.getUri();        String queryParameterString = session.getQueryParameterString();        Map&lt;String, String&gt; parms = session.getParms();        String typeName = parms.get(&quot;typeName&quot;);        String taskName = parms.get(&quot;taskName&quot;);        String userName = parms.get(&quot;userName&quot;);        if (taskName.contains(&quot;/&quot;) || userName.contains(&quot;/&quot;))&#123;            return responseError(&quot;非法访问&quot;);        &#125;        String startPath = &quot;&quot;;        String dirPath = &quot;&quot;;        String filePath = &quot;&quot;;        File newFile = null;        if(typeName.equals(&quot;text&quot;))&#123;            startPath = props.getProperty(&quot;input_filepath&quot;);        &#125;else if(typeName.equals(&quot;hive&quot;))&#123;            startPath = props.getProperty(&quot;hive_filepath&quot;);        &#125;else if(typeName.equals(&quot;hadoop&quot;))&#123;            startPath = props.getProperty(&quot;hadoop_filepath&quot;);        &#125;else&#123;            return responseError(&quot;非法访问&quot;);        &#125;        try &#123;            if(NanoFileUpload.isMultipartContent(session))&#123;                List&lt;FileItem&gt; fileItems = uploader.parseRequest(session);                for(FileItem fileItem:fileItems)&#123;                    if(fileItem.getFieldName().contains(&quot;file&quot;))&#123;                        String fileName = StringUtils.substringAfter(fileItem.getFieldName(),&quot;_&quot;);                        if(fileItem.getSize() &gt; 1073741824L)&#123;                            return responseError(&quot;上传文件夹过大&quot;);                        &#125;                        dirPath = startPath + userName+ File.separator + taskName + File.separator;                        filePath = dirPath + fileName;                        File dir = new File(dirPath);                        if (!dir.exists())&#123;                            dir.mkdirs();                            dir.setWritable(true);                        &#125;                        newFile = new File(filePath);                        if(newFile.exists())&#123;                            newFile.delete();                        &#125;                        fileItem.write(newFile);                        newFile.setExecutable(false);                    &#125;                &#125;            &#125;            if(typeName.equals(&quot;hive&quot;) || typeName.equals(&quot;hadoop&quot;))&#123;                return responseSuccess(dirPath);            &#125;else&#123;                return responseSuccess(filePath);            &#125;        &#125; catch (Exception e) &#123;            if(null != newFile &amp;&amp; newFile.exists())&#123;                newFile.delete();            &#125;            return responseError(&quot;未知错误&quot;);        &#125;    &#125;    //下载文件    private Response downFile(IHTTPSession session)&#123;        String queryParameterString = session.getQueryParameterString();        Map&lt;String, String&gt; parms = session.getParms();        String taskName = parms.get(&quot;taskName&quot;);        String userName = parms.get(&quot;userName&quot;);        if (taskName.contains(&quot;/&quot;) || userName.contains(&quot;/&quot;))&#123;            return responseError(&quot;非法访问&quot;);        &#125;        //下载文件之前，先压缩        String filepath = props.getProperty(&quot;output_filepath&quot;) + userName + &quot;/&quot; + taskName;        File dirFile = new File(filepath);        if (!dirFile.exists())&#123;            return responseError(&quot;文件不存在&quot;);        &#125;        if (dirFile.isDirectory())&#123;            if (!ifHasChildFile(dirFile))&#123;                return responseError(&quot;文件不存在&quot;);            &#125;        &#125;        long sizeOfDirFile = FileUtils.sizeOfDirectory(dirFile);        if(sizeOfDirFile &gt; 1073741824L)&#123;            return responseError(&quot;文件超过1G，无法下载，请在&quot;+filepath+&quot;路径自行下载&quot;);        &#125;        deleteFile(new File(filepath + &quot;.zip&quot;));        String srcPath = props.getProperty(&quot;output_filepath&quot;) + userName + &quot;/&quot; + taskName;        String zipPath = props.getProperty(&quot;output_filepath&quot;) + userName;        String zipFileName = taskName + &quot;.zip&quot;;        try &#123;            zipFile(srcPath, zipPath, zipFileName);        &#125; catch (Exception e) &#123;            return responseError(&quot;生成压缩文件失败&quot;);        &#125;        //下载文件        filepath = filepath + &quot;.zip&quot;;        File file = new File(filepath);        if(file.length() &gt; 1073741824L)&#123;            return responseError(&quot;文件超过1G，无法下载，请在&quot;+filepath+&quot;路径自行下载&quot;);        &#125;        try&#123;            FileInputStream fis = new FileInputStream(filepath);            Response response = newFixedLengthResponse(Response.Status.OK, &quot;application/octet-stream;charset=UTF-8&quot;, fis, fis.available());            response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + new String(taskName.getBytes(&quot;GBK&quot;),&quot;ISO-8859-1&quot;) + &quot;.zip&quot;);            return response;        &#125; catch (Exception e) &#123;            return responseError(&quot;未知错误&quot;);        &#125;    &#125;    //校验请求和否是合法请求    public boolean checkLegal(IHTTPSession session) &#123;//        boolean legalFlag = true;//        //请求头添加cookie//        Map&lt;String, String&gt; srcHeader = session.getHeaders();//        String cookie = srcHeader.get(&quot;cookiepara&quot;);//        HttpHeaders headers = new HttpHeaders();//        headers.add(HttpHeaders.COOKIE,cookie);//        HttpEntity&lt;String&gt; requestEntity = new HttpEntity&lt;&gt;(null, headers);//        //获取currentUserSID//        Map&lt;String, String&gt; parms = session.getParms();//        String currentUserSID = parms.get(&quot;currentUserSID&quot;);//        try&#123;//            ResponseEntity&lt;String&gt; resEntity = restTemplate.exchange(url+&quot;?currentUserSID=&quot;+currentUserSID, HttpMethod.GET, requestEntity, String.class);//            Logger.logger.info(&quot;file download:&quot; + url);//            if(resEntity.getStatusCode().toString().startsWith(&quot;4&quot;))&#123;//                legalFlag = false;//            &#125;//        &#125;catch (Exception e)&#123;//            legalFlag = false;//        &#125;        Map&lt;String, String&gt; srcHeader = session.getHeaders();        String cookie = srcHeader.get(&quot;cookie&quot;);        if(cookie.equals(&quot;sdmHttpServer_jh7(_8Hk9GH%jkl&quot;))&#123;            return true;        &#125;        return false;    &#125;    //返回错误信息    public Response responseError(String message) &#123;        message = &quot;&#123;\&quot;code\&quot;:1,\&quot;message\&quot;:\&quot;&quot;+message+&quot;\&quot;&#125;&quot;;        Response response = newFixedLengthResponse(Response.Status.NOT_FOUND, &quot;application/json;charset=UTF-8&quot;, message);        return response;    &#125;    //返回成功信息    public Response responseSuccess(String message) &#123;        message = &quot;&#123;\&quot;code\&quot;:0,\&quot;message\&quot;:\&quot;&quot;+message+&quot;\&quot;&#125;&quot;;        Response response = newFixedLengthResponse(Response.Status.OK, &quot;application/json;charset=UTF-8&quot;, message);        return response;    &#125;    /**     * 检查当前文件夹下是否有子文件     * @param file 待检查文件夹     * @return true:有子文件，false:没有子文件     */    private boolean ifHasChildFile(File file)&#123;        boolean[] flag = &#123;false&#125;;        ifHasChildFile(file,flag);        return flag[0];    &#125;    private void ifHasChildFile(File file,boolean[] flag)&#123;        if (file.isFile())&#123;            flag[0] = true;        &#125;        else &#123;            for (File tempFile : file.listFiles())&#123;                if (tempFile.isDirectory())&#123;                    ifHasChildFile(tempFile,flag);                &#125;                else &#123;                    flag[0] = true;                &#125;            &#125;        &#125;    &#125;    /**     * 删除指定文件     * @param file 待删除的文件对象     */    private void deleteFile(File file)&#123;        if (!file.exists())&#123;            return;        &#125;        if (file.isFile())&#123;            file.delete();        &#125;        else&#123;            File[] fileList = file.listFiles();            if (fileList != null &amp;&amp; fileList.length !=0)&#123;                for (File item : fileList)&#123;                    if (item.isDirectory())&#123;                        deleteFile(item);                    &#125;                    else&#123;                        item.delete();                    &#125;                &#125;            &#125;            file.delete();        &#125;    &#125;    private void zipFile(String srcPath, String zipPath, String zipFileName) throws Exception    &#123;        CheckedOutputStream cos = null;        ZipOutputStream zos = null;        try        &#123;            File srcFile = new File(srcPath);            //判断压缩文件保存的路径是否存在，如果不存在，则创建目录            File zipDir = new File(zipPath);            if (!zipDir.exists() || !zipDir.isDirectory())            &#123;                zipDir.mkdirs();            &#125;            //创建压缩文件保存的文件对象            String zipFilePath = zipPath + File.separator + zipFileName;            File zipFile = new File(zipFilePath);            if (zipFile.exists())            &#123;                //检测文件是否允许删除，如果不允许删除，将会抛出SecurityException                SecurityManager securityManager = new SecurityManager();                securityManager.checkDelete(zipFilePath);                //删除已存在的目标文件                zipFile.delete();            &#125;            cos = new CheckedOutputStream(new FileOutputStream(zipFile), new CRC32());            zos = new ZipOutputStream(cos);            //如果只是压缩一个文件，则需要截取该文件的父目录            String srcRootDir = srcPath;            if (srcFile.isFile())            &#123;                int index = srcPath.lastIndexOf(File.separator);                if (index != -1)                &#123;                    srcRootDir = srcPath.substring(0, index);                &#125;            &#125;            //调用递归压缩方法进行目录或文件压缩            compress(srcRootDir, srcFile, zos);            zos.flush();        &#125;        catch (Exception e)        &#123;            throw e;        &#125;        finally        &#123;            try            &#123;                if (zos != null)                &#123;                    zos.close();                &#125;            &#125;            catch (Exception e)            &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    private void compress(String srcRootDir, File file, ZipOutputStream zos) throws Exception    &#123;        if (file == null)        &#123;            return;        &#125;        //如果是文件，则直接压缩该文件        if (file.isFile())        &#123;            int count, bufferLen = 1024;            byte data[] = new byte[bufferLen];            //获取文件相对于压缩文件夹根目录的子路径            String subPath = file.getAbsolutePath();            int index = subPath.indexOf(srcRootDir);            if (index != -1)            &#123;                subPath = subPath.substring(srcRootDir.length() + File.separator.length());            &#125;            ZipEntry entry = new ZipEntry(subPath);            zos.putNextEntry(entry);            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file));            while ((count = bis.read(data, 0, bufferLen)) != -1)            &#123;                zos.write(data, 0, count);            &#125;            bis.close();            zos.closeEntry();        &#125;        //如果是目录，则压缩整个目录        else        &#123;            //压缩目录中的文件或子目录            File[] childFileList = file.listFiles();            for (int n=0; n&lt;childFileList.length; n++)            &#123;                compress(srcRootDir, childFileList[n], zos);            &#125;        &#125;    &#125;&#125;</code></pre>]]>
    </content>
    <id>http://example.com/2021/05/16/NanoHTTP/</id>
    <link href="http://example.com/2021/05/16/NanoHTTP/"/>
    <published>2021-05-16T04:00:00.000Z</published>
    <summary>nanohttp是一个轻量级的，微型的HTTP服务器，如果想给某项目增加一个http的访问，nanohttp是一个很好的选择，只需引入一个jar包，即可轻松配置。</summary>
    <title>Nanohttp</title>
    <updated>2026-02-26T08:55:33.212Z</updated>
  </entry>
  <entry>
    <author>
      <name>Lism</name>
    </author>
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    <content>
      <![CDATA[<h1 id="消息中间件"><a class="markdownIt-Anchor" href="#消息中间件"></a> 消息中间件</h1><p>[TOC]</p><h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><p>什么是消息中间件？</p><p>以公众号为例，如果某学员订阅了公众号，每当站长发布新教程的时候，都可以在这个公众号得到通知，这就是一种广播订阅模式</p><p>而公众号如何实现这一点呢？ 就可以通过 消息中间件 来轻松实现。<br />站长把最新的教程信息 发给 消息中间件服务器， 学员手机上的微信里的消息中间件客户端，就会自动去把消息获取出来显示，这样站长就达到了教程广播的效果了</p><p><strong>实现方式</strong></p><ul><li>ActiveMQ</li><li>RabbitMQ</li></ul><h2 id="activemq"><a class="markdownIt-Anchor" href="#activemq"></a> ActiveMQ</h2><h3 id="安装启动"><a class="markdownIt-Anchor" href="#安装启动"></a> 安装启动</h3><h4 id="下载启动"><a class="markdownIt-Anchor" href="#下载启动"></a> 下载启动</h4><p>下载好后直接运行 <code>activemq.bat</code> 即可启动</p><p>启动成功界面</p><h4 id="访问"><a class="markdownIt-Anchor" href="#访问"></a> 访问</h4><p>启动后，访问地址<code>http://127.0.0.1:8161/</code>就可以看到如图所示的界面</p><p>这就是服务器的管理界面，在里面就可以看到都有哪些消息被创建了，哪些被消费了</p><h4 id="管理界面"><a class="markdownIt-Anchor" href="#管理界面"></a> 管理界面</h4><p>点击manager ActiveMQ broker，或者直接访问地址：<code>http://127.0.0.1:8161/admin/</code></p><p>会弹出对话框，输入默认的账号和密码，都是<code>admin</code>，就进入了管理界面了</p><blockquote><p>这里就可以观察到队列数据和主题数据等信息</p></blockquote><h3 id="队列模式"><a class="markdownIt-Anchor" href="#队列模式"></a> 队列模式</h3><h4 id="模式"><a class="markdownIt-Anchor" href="#模式"></a> 模式</h4><p>activeMQ有两种模式，分别是<strong>队列模式</strong>和<strong>主题模式</strong></p><p><strong>队列模式</strong>：其实就是分食模式，比如生产方发了10条消息到activeMQ服务器，而此时有多个消费方，那么这些消费方就会瓜分这些10条消息，一条消息只会被一个消费方得到</p><h4 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h4><h5 id="jar包"><a class="markdownIt-Anchor" href="#jar包"></a> jar包</h5><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee.MQSimple<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>MQSimple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.15.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><h5 id="工具类"><a class="markdownIt-Anchor" href="#工具类"></a> 工具类</h5><pre><code class="highlight java"><span class="keyword">package</span> activeMQ;<span class="keyword">import</span> javax.swing.JOptionPane;<span class="keyword">import</span> cn.hutool.core.util.NetUtil;<span class="comment">/**</span><span class="comment"> * 用于判断activeMQ是否启动</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActiveMQUtil</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        checkServer();    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkServer</span><span class="params">()</span> &#123;        <span class="keyword">if</span>(NetUtil.isUsableLocalPort(<span class="number">8161</span>)) &#123;            JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;ActiveMQ 服务器未启动 &quot;</span>);            System.exit(<span class="number">1</span>);        &#125;    &#125;&#125;</code></pre><h5 id="生产者-producer"><a class="markdownIt-Anchor" href="#生产者-producer"></a> 生产者 Producer</h5><pre><code class="highlight java"><span class="keyword">package</span> activeMQ;<span class="keyword">import</span> javax.jms.Connection;<span class="keyword">import</span> javax.jms.ConnectionFactory;<span class="keyword">import</span> javax.jms.Destination;<span class="keyword">import</span> javax.jms.JMSException;<span class="keyword">import</span> javax.jms.MessageProducer;<span class="keyword">import</span> javax.jms.Session;<span class="keyword">import</span> javax.jms.TextMessage;<span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;<span class="comment">/**</span><span class="comment"> * 生产者</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProducer</span> &#123;    <span class="comment">//服务地址，端口默认61616</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url=<span class="string">&quot;tcp://127.0.0.1:61616&quot;</span>;    <span class="comment">//这次发送的消息名称</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String topicName=<span class="string">&quot;queue_style&quot;</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException &#123;        <span class="comment">//0. 先判断端口是否启动了  Active MQ 服务器</span>        ActiveMQUtil.checkServer();        <span class="comment">//1.创建ConnectionFactory,绑定地址</span>        ConnectionFactory factory=<span class="keyword">new</span> <span class="title class_">ActiveMQConnectionFactory</span>(url);        <span class="comment">//2.创建Connection</span>        Connection connection= factory.createConnection();        <span class="comment">//3.启动连接</span>        connection.start();        <span class="comment">//4.创建会话</span>        Session session=connection.createSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);        <span class="comment">//5.创建一个目标 (队列类型)</span>        Destination destination=session.createQueue(topicName);        <span class="comment">//6.创建一个生产者</span>        MessageProducer producer=session.createProducer(destination);        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            <span class="comment">//7.创建消息</span>            TextMessage textMessage=session.createTextMessage(<span class="string">&quot;队列消息-&quot;</span>+i);            <span class="comment">//8.发送消息</span>            producer.send(textMessage);            System.out.println(<span class="string">&quot;发送：&quot;</span>+textMessage.getText());        &#125;        <span class="comment">//7. 关闭连接</span>        connection.close();    &#125;&#125;</code></pre><h5 id="消费者-consumer"><a class="markdownIt-Anchor" href="#消费者-consumer"></a> 消费者 Consumer</h5><pre><code class="highlight java"><span class="keyword">package</span> activeMQ;<span class="keyword">import</span> javax.jms.Connection;<span class="keyword">import</span> javax.jms.ConnectionFactory;<span class="keyword">import</span> javax.jms.Destination;<span class="keyword">import</span> javax.jms.JMSException;<span class="keyword">import</span> javax.jms.Message;<span class="keyword">import</span> javax.jms.MessageConsumer;<span class="keyword">import</span> javax.jms.MessageListener;<span class="keyword">import</span> javax.jms.Session;<span class="keyword">import</span> javax.jms.TextMessage;<span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;<span class="keyword">import</span> cn.hutool.core.util.RandomUtil;<span class="comment">/**</span><span class="comment"> * 订阅者</span><span class="comment"> * <span class="doctag">@author</span> root</span><span class="comment"> *</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConsumer</span> &#123;    <span class="comment">//服务地址，端口默认61616</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url=<span class="string">&quot;tcp://127.0.0.1:61616&quot;</span>;    <span class="comment">//这次消费的消息名称</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String topicName=<span class="string">&quot;queue_style&quot;</span>;    <span class="comment">//消费者有可能是多个，为了区分不同的消费者，为其创建随机名称</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String consumerName=<span class="string">&quot;consumer-&quot;</span> + RandomUtil.randomString(<span class="number">5</span>);    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException &#123;        <span class="comment">//0. 先判断端口是否启动了 Active MQ 服务器</span>        ActiveMQUtil.checkServer();        System.out.printf(<span class="string">&quot;%s 消费者启动了。 %n&quot;</span>, consumerName);        <span class="comment">//1.创建ConnectiongFactory,绑定地址</span>        ConnectionFactory factory=<span class="keyword">new</span> <span class="title class_">ActiveMQConnectionFactory</span>(url);        <span class="comment">//2.创建Connection</span>        Connection connection= factory.createConnection();        <span class="comment">//3.启动连接</span>        connection.start();        <span class="comment">//4.创建会话</span>        Session session=connection.createSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);        <span class="comment">//5.创建一个目标 （队列类型）</span>        Destination destination=session.createQueue(topicName);        <span class="comment">//6.创建一个消费者</span>        MessageConsumer consumer=session.createConsumer(destination);        <span class="comment">//7.创建一个监听器</span>        consumer.setMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message arg0)</span> &#123;                <span class="comment">// TODO Auto-generated method stub</span>                TextMessage textMessage=(TextMessage)arg0;                <span class="keyword">try</span> &#123;                    System.out.println(consumerName +<span class="string">&quot; 接收消息：&quot;</span>+textMessage.getText());                &#125; <span class="keyword">catch</span> (JMSException e) &#123;                    <span class="comment">// TODO Auto-generated catch block</span>                    e.printStackTrace();                &#125;            &#125;        &#125;);        <span class="comment">//8. 因为不知道什么时候有，所以没法主动关闭，就不关闭了，一直处于监听状态</span>        <span class="comment">//connection.close();</span>    &#125;&#125;</code></pre><h4 id="运行"><a class="markdownIt-Anchor" href="#运行"></a> 运行</h4><ol><li>首先运行两次TestConsumer类，启动两个消费者</li><li>运行一次TestProducer，以启动生产者，生产者会生成100条消息</li></ol><blockquote><p>然后两个消费者会瓜分这100条消息，如图所示，两个消费者会瓜分不同的消息</p></blockquote><h4 id="管理界面-2"><a class="markdownIt-Anchor" href="#管理界面-2"></a> 管理界面</h4><p>访问地址：<code>http://127.0.0.1:8161/admin/queues.jsp</code>就可以看到刚才消息处理情况</p><p>queue_style 是在代码中定义的消息名称</p><p>number Of Consumers 表示有2个消费者</p><p>Messages Enqueued：表示收到了 100 个消息</p><p>Messages Dequeued：表示消费了 100 个消息</p><h3 id="主题模式"><a class="markdownIt-Anchor" href="#主题模式"></a> 主题模式</h3><p>需要注意的一点是，对于主题模式而言，消费者要先启动，如果在生产者生产完成之后，再启动，是看不到消息的</p><h4 id="模式-2"><a class="markdownIt-Anchor" href="#模式-2"></a> 模式</h4><p>activeMQ有两种模式，分别是<strong>队列模式</strong>和<strong>主题模式</strong></p><p><strong>主题模式</strong>：就是订阅模式，比如生产方发了10条消息，而此时有多个消费方，那么多个消费方都能得到这10条消息，就如同订阅公众号那样</p><p>主题模式就是每个订阅了的消费者，都可以获取所有的消息，而不像队列模式那样要争抢</p><h4 id="实现-2"><a class="markdownIt-Anchor" href="#实现-2"></a> 实现</h4><p>主题模式实现和队列模式实现基本相同，只有一行代码不同</p><pre><code class="highlight plaintext">Destination destination=session.createTopic(topicName);</code></pre><h5 id="jar包-2"><a class="markdownIt-Anchor" href="#jar包-2"></a> jar包</h5><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee.MQSimple<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>MQSimple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.15.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><h5 id="工具类-2"><a class="markdownIt-Anchor" href="#工具类-2"></a> 工具类</h5><pre><code class="highlight java"><span class="keyword">package</span> activeMQ.topic;<span class="keyword">import</span> cn.hutool.core.util.NetUtil;<span class="keyword">import</span> javax.swing.*;<span class="comment">/**</span><span class="comment"> * 用于判断activeMQ是否启动</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActiveMQUtil</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        checkServer();    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkServer</span><span class="params">()</span> &#123;        <span class="keyword">if</span>(NetUtil.isUsableLocalPort(<span class="number">8161</span>)) &#123;            JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;ActiveMQ 服务器未启动 &quot;</span>);            System.exit(<span class="number">1</span>);        &#125;    &#125;&#125;</code></pre><h5 id="生产者-producer-2"><a class="markdownIt-Anchor" href="#生产者-producer-2"></a> 生产者 Producer</h5><pre><code class="highlight java"><span class="keyword">package</span> activeMQ.topic;<span class="keyword">import</span> javax.jms.Connection;<span class="keyword">import</span> javax.jms.ConnectionFactory;<span class="keyword">import</span> javax.jms.Destination;<span class="keyword">import</span> javax.jms.JMSException;<span class="keyword">import</span> javax.jms.MessageProducer;<span class="keyword">import</span> javax.jms.Session;<span class="keyword">import</span> javax.jms.TextMessage;<span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProducer</span> &#123;    <span class="comment">//服务地址，端口默认61616</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url=<span class="string">&quot;tcp://127.0.0.1:61616&quot;</span>;    <span class="comment">//这次发送的消息名称</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String topicName=<span class="string">&quot;topic_style&quot;</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException &#123;        <span class="comment">//0. 先判断端口是否启动了  Active MQ 服务器</span>        ActiveMQUtil.checkServer();        <span class="comment">//1.创建ConnectiongFactory,绑定地址</span>        ConnectionFactory factory=<span class="keyword">new</span> <span class="title class_">ActiveMQConnectionFactory</span>(url);        <span class="comment">//2.创建Connection</span>        Connection connection= factory.createConnection();        <span class="comment">//3.启动连接</span>        connection.start();        <span class="comment">//4.创建会话</span>        Session session=connection.createSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);        <span class="comment">//5.创建一个目标 (主题类型)</span>        Destination destination=session.createTopic(topicName);        <span class="comment">//6.创建一个生产者</span>        MessageProducer producer=session.createProducer(destination);        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            <span class="comment">//7.创建消息</span>            TextMessage textMessage=session.createTextMessage(<span class="string">&quot;主题消息-&quot;</span>+i);            <span class="comment">//8.发送消息</span>            producer.send(textMessage);            System.out.println(<span class="string">&quot;发送：&quot;</span>+textMessage.getText());        &#125;        <span class="comment">//7. 关闭连接</span>        connection.close();    &#125;&#125;</code></pre><h5 id="消费者-consumer-2"><a class="markdownIt-Anchor" href="#消费者-consumer-2"></a> 消费者 Consumer</h5><pre><code class="highlight java"><span class="keyword">package</span> activeMQ.topic;<span class="keyword">import</span> javax.jms.Connection;<span class="keyword">import</span> javax.jms.ConnectionFactory;<span class="keyword">import</span> javax.jms.Destination;<span class="keyword">import</span> javax.jms.JMSException;<span class="keyword">import</span> javax.jms.Message;<span class="keyword">import</span> javax.jms.MessageConsumer;<span class="keyword">import</span> javax.jms.MessageListener;<span class="keyword">import</span> javax.jms.Session;<span class="keyword">import</span> javax.jms.TextMessage;<span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;<span class="keyword">import</span> cn.hutool.core.util.RandomUtil;<span class="comment">/**</span><span class="comment"> * 订阅者</span><span class="comment"> * <span class="doctag">@author</span> root</span><span class="comment"> *</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConsumer</span> &#123;    <span class="comment">//服务地址，端口默认61616</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url=<span class="string">&quot;tcp://127.0.0.1:61616&quot;</span>;    <span class="comment">//这次消费的消息名称</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String topicName=<span class="string">&quot;topic_style&quot;</span>;    <span class="comment">//消费者有可能是多个，为了区分不同的消费者，为其创建随机名称</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String consumerName=<span class="string">&quot;consumer-&quot;</span> + RandomUtil.randomString(<span class="number">5</span>);    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException &#123;        <span class="comment">//0. 先判断端口是否启动了 Active MQ 服务器</span>        ActiveMQUtil.checkServer();        System.out.printf(<span class="string">&quot;%s 消费者启动了。 %n&quot;</span>, consumerName);        <span class="comment">//1.创建ConnectiongFactory,绑定地址</span>        ConnectionFactory factory=<span class="keyword">new</span> <span class="title class_">ActiveMQConnectionFactory</span>(url);        <span class="comment">//2.创建Connection</span>        Connection connection= factory.createConnection();        <span class="comment">//3.启动连接</span>        connection.start();        <span class="comment">//4.创建会话</span>        Session session=connection.createSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);        <span class="comment">//5.创建一个目标 （主题类型）</span>        Destination destination=session.createTopic(topicName);        <span class="comment">//6.创建一个消费者</span>        MessageConsumer consumer=session.createConsumer(destination);        <span class="comment">//7.创建一个监听器</span>        consumer.setMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message arg0)</span> &#123;                <span class="comment">// TODO Auto-generated method stub</span>                TextMessage textMessage=(TextMessage)arg0;                <span class="keyword">try</span> &#123;                    System.out.println(consumerName +<span class="string">&quot; 接收消息：&quot;</span>+textMessage.getText());                &#125; <span class="keyword">catch</span> (JMSException e) &#123;                    <span class="comment">// TODO Auto-generated catch block</span>                    e.printStackTrace();                &#125;            &#125;        &#125;);        <span class="comment">//8. 因为不知道什么时候有，所以没法主动关闭，就不关闭了，一直处于监听状态</span>        <span class="comment">//connection.close();</span>    &#125;&#125;</code></pre><h4 id="运行-2"><a class="markdownIt-Anchor" href="#运行-2"></a> 运行</h4><ol><li>首先运行两次 TestConsumer 类，以启动两个不同的消费者</li><li>运行一次 TestProducer， 以启动 生产者，<br />这个生产者会生产100条消息</li></ol><blockquote><p>这两个消费者都会收到这100条消息，如图所示这样的效果，两个消费者都能获取全部的信息</p></blockquote><h4 id="管理界面-3"><a class="markdownIt-Anchor" href="#管理界面-3"></a> 管理界面</h4><p>访问地址： <code>http://127.0.0.1:8161/admin/topics.jsp</code> 就可以看到 刚才的消息处理情况</p><p>看最下面那行：<br />topics_style 是在代码中定义的消息名称</p><p>number Of Consumers 表示有2个消费者</p><p>Messages Enqueued：表示收到了 100 个消息</p><p>Messages Dequeued：表示消费了 200 个消息</p><h3 id="spring模式"><a class="markdownIt-Anchor" href="#spring模式"></a> spring模式</h3><h4 id="pomxml"><a class="markdownIt-Anchor" href="#pomxml"></a> pom.xml</h4><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lee.MQSimple<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>MQSimple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="comment">&lt;!--activeMQ--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.15.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!--工具包--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="comment">&lt;!--spring核心组件--&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jms<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><h4 id="spring_jmsxml"><a class="markdownIt-Anchor" href="#spring_jmsxml"></a> spring_jms.xml</h4><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="string"><span class="tag">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;activeMQ.springActiveMQ&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span>    <span class="comment">&lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;targetConnectionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;brokerURL&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tcp://127.0.0.1:61616&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    <span class="comment">&lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jms.connection.SingleConnectionFactory&quot;</span>&gt;</span>        <span class="comment">&lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetConnectionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;targetConnectionFactory&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    <span class="comment">&lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jmsTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jms.core.JmsTemplate&quot;</span>&gt;</span>        <span class="comment">&lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;connectionFactory&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    <span class="comment">&lt;!--这个是队列目的地, ActiveMQQueue 就表示队列模式。 如果要用主题模式就改成 ActiveMQTopic就行了 --&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;textDestination&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.activemq.command.ActiveMQQueue&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;queue_style&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    <span class="comment">&lt;!-- 我的监听类 --&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myMessageListener&quot;</span> <span class="attr">class</span>=<span class="string">&quot;activeMQ.springActiveMQ.MyMessageListener&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    <span class="comment">&lt;!-- 消息监听容器，会伴随spring的启动 --&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jms.listener.DefaultMessageListenerContainer&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;connectionFactory&quot;</span> /&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;destination&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;textDestination&quot;</span> /&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageListener&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;myMessageListener&quot;</span> /&gt;</span>    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></code></pre><h4 id="工具类-3"><a class="markdownIt-Anchor" href="#工具类-3"></a> 工具类</h4><p>测试activeMQ是否启动</p><pre><code class="highlight java"><span class="keyword">package</span> activeMQ.springActiveMQ;<span class="keyword">import</span> javax.swing.JOptionPane;<span class="keyword">import</span> cn.hutool.core.util.NetUtil;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActiveMQUtil</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        checkServer();    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkServer</span><span class="params">()</span> &#123;        <span class="keyword">if</span>(NetUtil.isUsableLocalPort(<span class="number">8161</span>)) &#123;            JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;ActiveMQ 服务器未启动 &quot;</span>);            System.exit(<span class="number">1</span>);        &#125;    &#125;&#125;</code></pre><h4 id="生产者-producer-3"><a class="markdownIt-Anchor" href="#生产者-producer-3"></a> 生产者 Producer</h4><pre><code class="highlight java"><span class="keyword">import</span> javax.jms.Destination;<span class="keyword">import</span> javax.jms.JMSException;<span class="keyword">import</span> javax.jms.Message;<span class="keyword">import</span> javax.jms.Session; <span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;<span class="keyword">import</span> org.springframework.jms.core.MessageCreator;<span class="keyword">import</span> org.springframework.stereotype.Component; <span class="meta">@Component</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;         <span class="meta">@Autowired</span>    <span class="keyword">private</span> JmsTemplate jmsTemplate;         <span class="meta">@Autowired</span>    <span class="keyword">private</span> Destination textDestination;         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendTextMessage</span><span class="params">(<span class="keyword">final</span> String text)</span>&#123;        jmsTemplate.send(textDestination, <span class="keyword">new</span> <span class="title class_">MessageCreator</span>() &#123;                         <span class="keyword">public</span> Message <span class="title function_">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException &#123;                <span class="keyword">return</span> session.createTextMessage(text);            &#125;        &#125;);    &#125;     &#125;</code></pre><h4 id="testproducer-测试使用生产者"><a class="markdownIt-Anchor" href="#testproducer-测试使用生产者"></a> TestProducer 测试使用生产者</h4><pre><code class="highlight java"><span class="keyword">import</span> org.junit.Before;<span class="keyword">import</span> org.junit.Test;<span class="keyword">import</span> org.junit.runner.RunWith;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;<span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner; <span class="keyword">import</span> cn.how2j.util.ActiveMQUtil; <span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span><span class="meta">@ContextConfiguration(locations=&quot;classpath:spring_jms.xml&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProducer</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> Producer producer;         <span class="meta">@Before</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkServer</span><span class="params">()</span> &#123;        ActiveMQUtil.checkServer();    &#125;         <span class="meta">@Test</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSend</span><span class="params">()</span>&#123;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            producer.sendTextMessage(<span class="string">&quot;消息 &quot;</span> + i);        &#125;    &#125;&#125;</code></pre><h4 id="消费者-consumer-3"><a class="markdownIt-Anchor" href="#消费者-consumer-3"></a> 消费者 Consumer</h4><pre><code class="highlight java"><span class="keyword">import</span> javax.jms.JMSException;<span class="keyword">import</span> javax.jms.Message;<span class="keyword">import</span> javax.jms.MessageListener;<span class="keyword">import</span> javax.jms.TextMessage; <span class="keyword">import</span> cn.hutool.core.util.RandomUtil; <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMessageListener</span> <span class="keyword">implements</span> <span class="title class_">MessageListener</span> &#123;     <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;consumer-&quot;</span>+ RandomUtil.randomString(<span class="number">5</span>);    <span class="keyword">public</span>  <span class="title function_">MyMessageListener</span><span class="params">()</span> &#123;        System.out.println(name + <span class="string">&quot; started&quot;</span>);    &#125;         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message)</span> &#123;        TextMessage textMessage=(TextMessage)message;               <span class="keyword">try</span> &#123;            System.out.println(name+<span class="string">&quot; 接收到消息：&quot;</span>+textMessage.getText());        &#125; <span class="keyword">catch</span> (JMSException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h4 id="testconsumer-测试使用消费者"><a class="markdownIt-Anchor" href="#testconsumer-测试使用消费者"></a> TestConsumer 测试使用消费者</h4><p>消费者测试类，他其实什么都没做。 虽然它什么都没做，但是因为他是运行在 spring框架下的测试，所以一旦启动，就会导致一个新的 DefaultMessageListenerContainer 被启动，间接地导致 一个新的 MyMessageListener 被启动。 于是也就充当了消费者的角色了。<br />其中的</p><pre><code class="highlight plaintext">System.in.read();</code></pre><p>是为了这个类不退出，可以一直监听用</p><p>于这个类似的，TestProducer类启动，也会导致一个MyMessageListener被启动，所以TestProducer本身即是一个生产者，也是一个消费者</p><pre><code class="highlight java"><span class="keyword">import</span> java.io.IOException; <span class="keyword">import</span> org.junit.Before;<span class="keyword">import</span> org.junit.Test;<span class="keyword">import</span> org.junit.runner.RunWith;<span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;<span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner; <span class="keyword">import</span> cn.how2j.util.ActiveMQUtil; <span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span><span class="meta">@ContextConfiguration(locations=&quot;classpath:spring_jms.xml&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConsumer</span> &#123;    <span class="meta">@Before</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkServer</span><span class="params">()</span> &#123;        ActiveMQUtil.checkServer();    &#125;         <span class="meta">@Test</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;        <span class="keyword">try</span> &#123;            <span class="comment">//写这个是为了不让当前测试退出。  因为 spring的配置， MyMessageListener 会自动启动</span>            System.in.read();        &#125; <span class="keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;           &#125;   &#125;</code></pre><h4 id="模式切换"><a class="markdownIt-Anchor" href="#模式切换"></a> 模式切换</h4><p>当前例子是队列模式，要切换为主题模式只需修改spring_jms就可以了，顺便把queue也修改成topic_style，免得混淆</p><pre><code class="highlight xml"><span class="comment">&lt;!--这个是队列目的地, ActiveMQQueue 就表示队列模式。 如果要用主题模式就改成 ActiveMQTopic就行了 --&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;textDestination&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.activemq.command.ActiveMQQueue&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;queue_style&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre><h2 id="rabbitmq"><a class="markdownIt-Anchor" href="#rabbitmq"></a> RabbitMQ</h2><p>与 ActiveMQ 一样， rabbitmq 也是一种 消息中间件的实现。与之的区别在于， rabbitmq 更专业，更灵活，大企业，大型高要求的应用，普遍会采用 rabbitmq 来支持</p><h3 id="安装运行"><a class="markdownIt-Anchor" href="#安装运行"></a> 安装运行</h3><h4 id="安装erlang"><a class="markdownIt-Anchor" href="#安装erlang"></a> 安装erlang</h4><p>RabbitMQ使用erlang语言开发，需要安装对应语言的环境</p><p>下载安装erlang <code>otp_win64_18.1.exe</code>，配置环境<strong>变量path增加erlang的安装路径</strong>即可</p><p>测试运行</p><h4 id="安装运行-rabbitmq"><a class="markdownIt-Anchor" href="#安装运行-rabbitmq"></a> 安装/运行 rabbitMQ</h4><p>下载rabbitMQ，运行<code>rabbitmq-server-3.6.5.exe</code>，使用默认设置，下一步下一步即可。</p><p><strong>配置插件</strong></p><p>运行如下命令</p><pre><code class="highlight plaintext">&quot;D:\MQ\rabbitmq\rabbitmq_server-3.6.5\sbin\rabbitmq-plugins.bat&quot; enable rabbitmq_management</code></pre><p><strong>重启 rabbitmq</strong></p><p>运行以下命令以重启rabbitmq</p><pre><code class="highlight plaintext">net stop RabbitMQ net start RabbitMQ</code></pre><h4 id="访问管理界面"><a class="markdownIt-Anchor" href="#访问管理界面"></a> 访问管理界面</h4><p>管理界面</p><pre><code class="highlight plaintext">http://127.0.0.1:15672</code></pre><blockquote><p>账号：guest<br />密码：guest</p></blockquote><h3 id="模式讲解"><a class="markdownIt-Anchor" href="#模式讲解"></a> 模式讲解</h3><h4 id="amqp"><a class="markdownIt-Anchor" href="#amqp"></a> AMQP</h4><p>于activeMQ不同，rabbitMQ使用的是一种叫做AMQP的协议来通信，AMQP是dvanced Message Queuing Protocol 的缩写。协议内容我们就没必要深入研究了，简单地说，通过这种协议，可以处理更为复杂的业务需求</p><h4 id="消息路由过程"><a class="markdownIt-Anchor" href="#消息路由过程"></a> 消息路由过程</h4><p>于ActiveMQ拿到消息就直接放在队列等待消费者拿走不同，Rabbit拿到消息后，先交给交换机exchange，然后交换机再根据预先设定的不同绑定bingdings策略，来确定要发给哪个队列</p><p>如图所示，比起ActiveMQ多了Exchange和Bindings</p><p>正式由于有了Exchange和Bindings，RabbitMQ就可以灵活地支撑多种模式</p><h4 id="模式-3"><a class="markdownIt-Anchor" href="#模式-3"></a> 模式</h4><p>RabbitMQ提供了Exchange模式：fanout,direct,topic,header，header模式在实际使用中较少，暂时学习前三种模式</p><h5 id="fanout-模式"><a class="markdownIt-Anchor" href="#fanout-模式"></a> fanout 模式</h5><p><strong>fanout</strong>模式就是广播模式，消息来了，会发给所有的队列</p><h5 id="direct-模式"><a class="markdownIt-Anchor" href="#direct-模式"></a> direct 模式</h5><p><strong>direct</strong>模式就是指定队列的模式，消息来了，只发给指定的quere，其他的queue都收不到</p><h5 id="topic-模式"><a class="markdownIt-Anchor" href="#topic-模式"></a> topic 模式</h5><p>主题模式，注意这里的主题模式，和 ActivityMQ 里的不一样。 ActivityMQ 里的主题，更像是广播模式</p><p>那么这里的主题模式是什么意思呢？ 如图所示消息来源有： 美国新闻，美国天气，欧洲新闻，欧洲天气</p><p>如果你想看 美国主题： 那么就会收到 美国新闻，美国天气<br />如果你想看 新闻主题： 那么就会收到 美国新闻，欧洲新闻<br />如果你想看 天气主题： 那么就会收到 美国天气，欧洲天气<br />如果你想看 欧洲主题： 那么就会收到 欧洲新闻，欧洲天气</p><h3 id="fanout-模式代码"><a class="markdownIt-Anchor" href="#fanout-模式代码"></a> fanout 模式代码</h3><h4 id="pomxml-2"><a class="markdownIt-Anchor" href="#pomxml-2"></a> pom.xml</h4><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h4 id="rabbitmqutil"><a class="markdownIt-Anchor" href="#rabbitmqutil"></a> RabbitMQUtil</h4><pre><code class="highlight java"><span class="keyword">package</span> rabbitMQ.fanout;<span class="comment">/**</span><span class="comment"> * 判断rabbitMQ服务器是否启动</span><span class="comment"> */</span><span class="keyword">import</span> javax.swing.JOptionPane;<span class="keyword">import</span> cn.hutool.core.util.NetUtil;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQUtil</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        checkServer();    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkServer</span><span class="params">()</span> &#123;        <span class="keyword">if</span>(NetUtil.isUsableLocalPort(<span class="number">15672</span>)) &#123;            JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;RabbitMQ 服务器未启动 &quot;</span>);            System.exit(<span class="number">1</span>);        &#125;    &#125;&#125;</code></pre><h4 id="testproducer"><a class="markdownIt-Anchor" href="#testproducer"></a> TestProducer</h4><p>生产者</p><pre><code class="highlight java"><span class="keyword">package</span> rabbitMQ.fanout;<span class="keyword">import</span> java.io.IOException;<span class="keyword">import</span> java.util.concurrent.TimeoutException;<span class="keyword">import</span> com.rabbitmq.client.Channel;<span class="keyword">import</span> com.rabbitmq.client.Connection;<span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;<span class="comment">/**</span><span class="comment"> * 消息生成者</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProducer</span> &#123;    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME=<span class="string">&quot;fanout_exchange&quot;</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;        RabbitMQUtil.checkServer();        <span class="comment">//创建连接工厂</span>        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();        <span class="comment">//设置RabbitMQ相关信息</span>        factory.setHost(<span class="string">&quot;localhost&quot;</span>);        <span class="comment">//创建一个新的连接</span>        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();        <span class="comment">//创建一个通道</span>        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;direct 消息 &quot;</span> +i;            <span class="comment">//发送消息到队列中</span>            channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));            System.out.println(<span class="string">&quot;发送消息： &quot;</span> + message);        &#125;        <span class="comment">//关闭通道和连接</span>        channel.close();        connection.close();    &#125;&#125;</code></pre><h4 id="testcustomer"><a class="markdownIt-Anchor" href="#testcustomer"></a> TestCustomer</h4><p>消费者</p><pre><code class="highlight java"><span class="keyword">package</span> rabbitMQ.fanout;<span class="keyword">import</span> java.io.IOException;<span class="keyword">import</span> java.util.concurrent.TimeoutException;<span class="keyword">import</span> com.rabbitmq.client.AMQP;<span class="keyword">import</span> com.rabbitmq.client.Channel;<span class="keyword">import</span> com.rabbitmq.client.Connection;<span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;<span class="keyword">import</span> com.rabbitmq.client.Consumer;<span class="keyword">import</span> com.rabbitmq.client.DefaultConsumer;<span class="keyword">import</span> com.rabbitmq.client.Envelope;<span class="keyword">import</span> cn.hutool.core.util.RandomUtil;<span class="comment">/**</span><span class="comment"> * 消息消费者</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCustomer</span> &#123;    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME=<span class="string">&quot;fanout_exchange&quot;</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;        <span class="comment">//为当前消费者取随机名</span>        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;consumer-&quot;</span>+ RandomUtil.randomString(<span class="number">5</span>);        <span class="comment">//判断服务器是否启动</span>        RabbitMQUtil.checkServer();        <span class="comment">// 创建连接工厂</span>        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();        <span class="comment">//设置RabbitMQ地址</span>        factory.setHost(<span class="string">&quot;localhost&quot;</span>);        <span class="comment">//创建一个新的连接</span>        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();        <span class="comment">//创建一个通道</span>        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();        <span class="comment">//交换机声明（参数为：交换机名称；交换机类型）</span>        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">&quot;fanout&quot;</span>);        <span class="comment">//获取一个临时队列</span>        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();        <span class="comment">//队列与交换机绑定（参数为：队列名称；交换机名称；routingKey忽略）</span>        channel.queueBind(queueName,EXCHANGE_NAME,<span class="string">&quot;&quot;</span>);        System.out.println(name +<span class="string">&quot; 等待接受消息&quot;</span>);        <span class="comment">//DefaultConsumer类实现了Consumer接口，通过传入一个频道，</span>        <span class="comment">// 告诉服务器我们需要那个频道的消息，如果频道中有消息，就会执行回调函数handleDelivery</span>        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span><span class="params">                                       AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span>                    <span class="keyword">throws</span> IOException &#123;                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body, <span class="string">&quot;UTF-8&quot;</span>);                System.out.println(name + <span class="string">&quot; 接收到消息 &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);            &#125;        &#125;;        <span class="comment">//自动回复队列应答 -- RabbitMQ中的消息确认机制</span>        channel.basicConsume(queueName, <span class="literal">true</span>, consumer);    &#125;&#125;</code></pre><h3 id="direct-模式代码"><a class="markdownIt-Anchor" href="#direct-模式代码"></a> direct 模式代码</h3><h4 id="pomxml-3"><a class="markdownIt-Anchor" href="#pomxml-3"></a> pom.xml</h4><pre><code class="highlight xml"><span class="comment">&lt;!--activeMQ--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.15.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!--rabbitMQ--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h4 id="rabbitmqutil-2"><a class="markdownIt-Anchor" href="#rabbitmqutil-2"></a> RabbitMQUtil</h4><pre><code class="highlight java"><span class="keyword">package</span> rabbitMQ.direct;<span class="comment">/**</span><span class="comment"> * 判断rabbitMQ服务器是否启动</span><span class="comment"> */</span><span class="keyword">import</span> cn.hutool.core.util.NetUtil;<span class="keyword">import</span> javax.swing.*;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQUtil</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        checkServer();    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkServer</span><span class="params">()</span> &#123;        <span class="keyword">if</span>(NetUtil.isUsableLocalPort(<span class="number">15672</span>)) &#123;            JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;RabbitMQ 服务器未启动 &quot;</span>);            System.exit(<span class="number">1</span>);        &#125;    &#125;&#125;</code></pre><h4 id="testdirectproducer"><a class="markdownIt-Anchor" href="#testdirectproducer"></a> TestDirectProducer</h4><p>生成者</p><pre><code class="highlight java"><span class="keyword">package</span> rabbitMQ.direct;<span class="keyword">import</span> java.io.IOException;<span class="keyword">import</span> java.util.concurrent.TimeoutException;<span class="keyword">import</span> com.rabbitmq.client.Channel;<span class="keyword">import</span> com.rabbitmq.client.Connection;<span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;<span class="comment">/**</span><span class="comment"> * 消息生成者</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDirectProducer</span> &#123;    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME=<span class="string">&quot;direct_queue&quot;</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;        RabbitMQUtil.checkServer();        <span class="comment">//创建连接工厂</span>        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();        <span class="comment">//设置RabbitMQ相关信息</span>        factory.setHost(<span class="string">&quot;localhost&quot;</span>);        <span class="comment">//创建一个新的连接</span>        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();        <span class="comment">//创建一个通道</span>        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;direct 消息 &quot;</span> +i;            <span class="comment">//发送消息到队列中</span>            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));            System.out.println(<span class="string">&quot;发送消息： &quot;</span> + message);        &#125;        <span class="comment">//关闭通道和连接</span>        channel.close();        connection.close();    &#125;&#125;</code></pre><h4 id="testdirectcustomer"><a class="markdownIt-Anchor" href="#testdirectcustomer"></a> TestDirectCustomer</h4><p>消费者</p><pre><code class="highlight java"><span class="keyword">package</span> rabbitMQ.direct;<span class="keyword">import</span> java.io.IOException;<span class="keyword">import</span> java.util.concurrent.TimeoutException;<span class="keyword">import</span> com.rabbitmq.client.AMQP;<span class="keyword">import</span> com.rabbitmq.client.Channel;<span class="keyword">import</span> com.rabbitmq.client.Connection;<span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;<span class="keyword">import</span> com.rabbitmq.client.Consumer;<span class="keyword">import</span> com.rabbitmq.client.DefaultConsumer;<span class="keyword">import</span> com.rabbitmq.client.Envelope;<span class="keyword">import</span> cn.hutool.core.util.RandomUtil;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDirectCustomer</span> &#123;    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_queue&quot;</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;        <span class="comment">//为当前消费者取随机名</span>        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;consumer-&quot;</span>+ RandomUtil.randomString(<span class="number">5</span>);        <span class="comment">//判断服务器是否启动</span>        RabbitMQUtil.checkServer();        <span class="comment">// 创建连接工厂</span>        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();        <span class="comment">//设置RabbitMQ地址</span>        factory.setHost(<span class="string">&quot;localhost&quot;</span>);        <span class="comment">//创建一个新的连接</span>        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();        <span class="comment">//创建一个通道</span>        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();        <span class="comment">//声明要关注的队列</span>        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">null</span>);        System.out.println(name +<span class="string">&quot; 等待接受消息&quot;</span>);        <span class="comment">//DefaultConsumer类实现了Consumer接口，通过传入一个频道，</span>        <span class="comment">// 告诉服务器我们需要那个频道的消息，如果频道中有消息，就会执行回调函数handleDelivery</span>        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span><span class="params">                                       AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span>                    <span class="keyword">throws</span> IOException &#123;                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body, <span class="string">&quot;UTF-8&quot;</span>);                System.out.println(name + <span class="string">&quot; 接收到消息 &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);            &#125;        &#125;;        <span class="comment">//自动回复队列应答 -- RabbitMQ中的消息确认机制</span>        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, consumer);    &#125;&#125;</code></pre><h3 id="topic-模式代码"><a class="markdownIt-Anchor" href="#topic-模式代码"></a> topic 模式代码</h3><p>先运行 TestCustomer4USA 专门用于接受美国专题消息<br />再运行 TestCustomer4News 专门用于接受新闻专题消息<br />最后运行 TestProducer ，分别在 四个路由：“usa.news”, “usa.weather”, “europe.news”, “europe.weather” 上发布 “美国新闻”, “美国天气”, “欧洲新闻”, “欧洲天气”.<br />于是就能在消费者端看到 不同的主题收到对应的消息了。</p><h4 id="pomxml-4"><a class="markdownIt-Anchor" href="#pomxml-4"></a> pom.xml</h4><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h4 id="rabbitmqutil-3"><a class="markdownIt-Anchor" href="#rabbitmqutil-3"></a> RabbitMQUtil</h4><p>判断服务器是否启动</p><pre><code class="highlight java"><span class="keyword">package</span> rabbitMQ.topic;<span class="comment">/**</span><span class="comment"> * 判断rabbitMQ服务器是否启动</span><span class="comment"> */</span><span class="keyword">import</span> cn.hutool.core.util.NetUtil;<span class="keyword">import</span> javax.swing.*;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQUtil</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        checkServer();    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkServer</span><span class="params">()</span> &#123;        <span class="keyword">if</span>(NetUtil.isUsableLocalPort(<span class="number">15672</span>)) &#123;            JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;RabbitMQ 服务器未启动 &quot;</span>);            System.exit(<span class="number">1</span>);        &#125;    &#125;&#125;</code></pre><h4 id="testproducer-2"><a class="markdownIt-Anchor" href="#testproducer-2"></a> TestProducer</h4><p>分别在 四个路由：“usa.news”, “usa.weather”, “europe.news”, “europe.weather” 上发布 “美国新闻”, “美国天气”, “欧洲新闻”, “欧洲天气”.</p><pre><code class="highlight java"><span class="keyword">package</span> rabbitMQ.topic;<span class="keyword">import</span> java.io.IOException;<span class="keyword">import</span> java.util.concurrent.TimeoutException;<span class="keyword">import</span> com.rabbitmq.client.Channel;<span class="keyword">import</span> com.rabbitmq.client.Connection;<span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;<span class="comment">/**</span><span class="comment"> * 消息生成者</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProducer</span> &#123;    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME=<span class="string">&quot;topics_exchange&quot;</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;        RabbitMQUtil.checkServer();        <span class="comment">//创建连接工厂</span>        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();        <span class="comment">//设置RabbitMQ相关信息</span>        factory.setHost(<span class="string">&quot;localhost&quot;</span>);        <span class="comment">//创建一个新的连接</span>        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();        <span class="comment">//创建一个通道</span>        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);        String[] routing_keys = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;usa.news&quot;</span>, <span class="string">&quot;usa.weather&quot;</span>,                <span class="string">&quot;europe.news&quot;</span>, <span class="string">&quot;europe.weather&quot;</span> &#125;;        String[] messages = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;美国新闻&quot;</span>, <span class="string">&quot;美国天气&quot;</span>,                <span class="string">&quot;欧洲新闻&quot;</span>, <span class="string">&quot;欧洲天气&quot;</span> &#125;;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; routing_keys.length; i++) &#123;            <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> routing_keys[i];            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> messages[i];            channel.basicPublish(EXCHANGE_NAME, routingKey, <span class="literal">null</span>, message                    .getBytes());            System.out.printf(<span class="string">&quot;发送消息到路由：%s, 内容是: %s%n &quot;</span>, routingKey,message);        &#125;        <span class="comment">//关闭通道和连接</span>        channel.close();        connection.close();    &#125;&#125;</code></pre><h4 id="testcustomer4usa"><a class="markdownIt-Anchor" href="#testcustomer4usa"></a> TestCustomer4USA</h4><p>专门用于接受 usa.* 消息</p><pre><code class="highlight java"><span class="keyword">package</span> rabbitMQ.topic;<span class="keyword">import</span> java.io.IOException;<span class="keyword">import</span> java.util.concurrent.TimeoutException;<span class="keyword">import</span> com.rabbitmq.client.AMQP;<span class="keyword">import</span> com.rabbitmq.client.Channel;<span class="keyword">import</span> com.rabbitmq.client.Connection;<span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;<span class="keyword">import</span> com.rabbitmq.client.Consumer;<span class="keyword">import</span> com.rabbitmq.client.DefaultConsumer;<span class="keyword">import</span> com.rabbitmq.client.Envelope;<span class="keyword">import</span> cn.hutool.core.util.RandomUtil;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCustomer4USA</span> &#123;    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME=<span class="string">&quot;topics_exchange&quot;</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;        <span class="comment">//为当前消费者取名称</span>        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;consumer-usa&quot;</span>;        <span class="comment">//判断服务器是否启动</span>        RabbitMQUtil.checkServer();        <span class="comment">// 创建连接工厂</span>        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();        <span class="comment">//设置RabbitMQ地址</span>        factory.setHost(<span class="string">&quot;localhost&quot;</span>);        <span class="comment">//创建一个新的连接</span>        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();        <span class="comment">//创建一个通道</span>        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();        <span class="comment">//交换机声明（参数为：交换机名称；交换机类型）</span>        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">&quot;topic&quot;</span>);        <span class="comment">//获取一个临时队列</span>        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();        <span class="comment">//接受 USA 信息</span>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;usa.*&quot;</span>);        System.out.println(name +<span class="string">&quot; 等待接受消息&quot;</span>);        <span class="comment">//DefaultConsumer类实现了Consumer接口，通过传入一个频道，</span>        <span class="comment">// 告诉服务器我们需要那个频道的消息，如果频道中有消息，就会执行回调函数handleDelivery</span>        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span><span class="params">                                       AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span>                    <span class="keyword">throws</span> IOException &#123;                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body, <span class="string">&quot;UTF-8&quot;</span>);                System.out.println(name + <span class="string">&quot; 接收到消息 &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);            &#125;        &#125;;        <span class="comment">//自动回复队列应答 -- RabbitMQ中的消息确认机制</span>        channel.basicConsume(queueName, <span class="literal">true</span>, consumer);    &#125;&#125;</code></pre><h4 id="testcustomer4news"><a class="markdownIt-Anchor" href="#testcustomer4news"></a> TestCustomer4News</h4><p>专门用于接受 *.news 消息</p><pre><code class="highlight java"><span class="keyword">package</span> rabbitMQ.topic;<span class="keyword">import</span> java.io.IOException;<span class="keyword">import</span> java.util.concurrent.TimeoutException;<span class="keyword">import</span> com.rabbitmq.client.AMQP;<span class="keyword">import</span> com.rabbitmq.client.Channel;<span class="keyword">import</span> com.rabbitmq.client.Connection;<span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;<span class="keyword">import</span> com.rabbitmq.client.Consumer;<span class="keyword">import</span> com.rabbitmq.client.DefaultConsumer;<span class="keyword">import</span> com.rabbitmq.client.Envelope;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCustomer4News</span> &#123;    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME=<span class="string">&quot;topics_exchange&quot;</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;        <span class="comment">//为当前消费者取名称</span>        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;consumer-news&quot;</span>;        <span class="comment">//判断服务器是否启动</span>        RabbitMQUtil.checkServer();        <span class="comment">// 创建连接工厂</span>        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();        <span class="comment">//设置RabbitMQ地址</span>        factory.setHost(<span class="string">&quot;localhost&quot;</span>);        <span class="comment">//创建一个新的连接</span>        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();        <span class="comment">//创建一个通道</span>        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();        <span class="comment">//交换机声明（参数为：交换机名称；交换机类型）</span>        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">&quot;topic&quot;</span>);        <span class="comment">//获取一个临时队列</span>        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();        <span class="comment">//接受 USA 信息</span>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;*.news&quot;</span>);        System.out.println(name +<span class="string">&quot; 等待接受消息&quot;</span>);        <span class="comment">//DefaultConsumer类实现了Consumer接口，通过传入一个频道，</span>        <span class="comment">// 告诉服务器我们需要那个频道的消息，如果频道中有消息，就会执行回调函数handleDelivery</span>        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span><span class="params">                                       AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span>                    <span class="keyword">throws</span> IOException &#123;                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body, <span class="string">&quot;UTF-8&quot;</span>);                System.out.println(name + <span class="string">&quot; 接收到消息 &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);            &#125;        &#125;;        <span class="comment">//自动回复队列应答 -- RabbitMQ中的消息确认机制</span>        channel.basicConsume(queueName, <span class="literal">true</span>, consumer);    &#125;&#125;</code></pre>]]>
    </content>
    <id>http://example.com/2021/03/05/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/</id>
    <link href="http://example.com/2021/03/05/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <published>2021-03-05T04:00:00.000Z</published>
    <summary>什么是消息中间件？以公众号为例，如果某学员订阅了公众号，每当站长发布新教程的时候，都可以在这个公众号得到通知，这就是一种广播订阅模式</summary>
    <title>消息中间件ActiveMQ/RabbitMQ</title>
    <updated>2026-02-26T09:48:21.371Z</updated>
  </entry>
</feed>
