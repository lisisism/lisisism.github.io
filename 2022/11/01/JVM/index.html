<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    Jvm 丨
    

    Lism Blog
  </title>

  
  <link rel="shortcut icon" href="/icon.svg">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="/Lism Blog" type="application/atom+xml">
</head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">/Lism Blog</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <article class="post">
  
  <div class="post-title">Jvm</div>
  <div class="post-meta">
    <div class="date">2022 十一月 1日</div>
    <div class="tags">
      
      <div class="tag-item">Java</div>
      
    </div>
  </div>
  

  <main class="post-content"><h1 id="jvm"><a class="markdownIt-Anchor" href="#jvm"></a> $JVM</h1>
<h1 id="jvm-2"><a class="markdownIt-Anchor" href="#jvm-2"></a> JVM</h1>
<ul>
<li><a href="">JVM</a>
<ul>
<li><a href="">JVM概述</a>
<ul>
<li><a href="">JVM常识</a></li>
<li><a href="">JVM分类</a></li>
<li><a href="">HotSpot</a></li>
<li><a href="">JVM架构理解</a></li>
<li><a href="">JIT即时编译器</a></li>
<li><a href="">JIT编译器优化</a></li>
</ul>
</li>
<li><a href="">CLASS文件</a>
<ul>
<li><a href="">class文件概述</a></li>
<li><a href="">class常量池理解</a></li>
<li><a href="">class文件中的应用和特殊字符串</a></li>
</ul>
</li>
<li><a href="">类加载子系统</a>
<ul>
<li><a href="">JVM程序执行流程</a></li>
<li><a href="">类加载过程</a></li>
<li><a href="">类加载的时机</a></li>
<li><a href="">类加载器</a></li>
<li><a href="">自定义类加载器</a></li>
<li><a href="">双亲委派模型</a></li>
<li><a href="">破坏双亲委派模型</a></li>
</ul>
</li>
<li><a href="">运行时数据区</a>
<ul>
<li><a href="">程序计数器</a></li>
<li><a href="">Java虚拟机栈</a>
<ul>
<li><a href="">栈帧</a></li>
<li><a href="">局部变量表</a></li>
<li><a href="">操作数栈</a></li>
<li><a href="">动态连接</a></li>
<li><a href="">方法返回</a></li>
<li><a href="">附加信息/栈异常</a></li>
</ul>
</li>
<li><a href="">本地方法栈</a>
<ul>
<li><a href="">介绍</a></li>
<li><a href="">使用流程</a></li>
</ul>
</li>
<li><a href="">Java内存模型</a></li>
<li><a href="">JVM调优</a>
<ul>
<li><a href="">取消伸缩区</a></li>
<li><a href="">GC处理流程</a></li>
<li><a href="">查看垃圾回收</a></li>
<li><a href="">内存回收算法</a></li>
</ul>
</li>
<li><a href="">Java堆</a>
<ul>
<li><a href="">堆分类</a></li>
<li><a href="">对象创建</a></li>
<li><a href="">内存分配</a></li>
<li><a href="">对象的访问</a></li>
<li><a href="">数组内存分析</a></li>
</ul>
</li>
<li><a href="">方法区</a>
<ul>
<li><a href="">永久代、方法区、元空间的关系</a></li>
<li><a href="">PermGen(永久代)</a></li>
<li><a href="">Metaspace(元空间)</a></li>
</ul>
</li>
<li><a href="">运行时常量池/字符串常量�</a>�</li>
</ul>
</li>
<li><a href="">JVM如何运行字节码</a></li>
<li><a href="">JVM堆溢出分析</a>
<ul>
<li><a href="">jconsole内存监控工具</a></li>
<li><a href="">jmap内存分析工具</a></li>
</ul>
</li>
<li><a href="">JVM远程debug</a></li>
</ul>
</li>
</ul>
<h2 id="jvm概述"><a class="markdownIt-Anchor" href="#jvm概述"></a> JVM概述</h2>
<h3 id="jvm常识"><a class="markdownIt-Anchor" href="#jvm常识"></a> JVM常识</h3>
<p><strong>程序的执行方式有哪些？</strong></p>
<ul>
<li>主要有三种：<strong>静态编译执行</strong>、<strong>动态编译执行</strong>和<strong>动态解释执行</strong></li>
</ul>
<blockquote>
<p>注意：此处所说的编译指的是编译成可让操作系统直接执行的机器码</p>
</blockquote>
<hr />
<p><strong>字节码和机器码的区别？</strong></p>
<p>机器码是电脑CPU直接读取运行的机器指令，运行速度最快，但是非常晦涩难懂，也比较难编写，一般从业人员接触不到。</p>
<p>字节码是一种中间状态（中间码）的二进制代码（文件）。需要直译器转译后才能成为机器码</p>
<hr />
<p><strong>JDK,JRE与JVM的关系是？</strong></p>
<hr />
<p><strong>OracleJDK和openJDK的关系是？</strong></p>
<p>查看JDK的版本</p>
<pre><code class="highlight plaintext">java -version</code></pre>
<ul>
<li>如果是SUN/OracleJDK，显示信息为</li>
</ul>
<blockquote>
<p><code>Java HotSpot(TM) 64-Bit Server VM</code>表明，此JDK的JVM是Oracle的64位的HotSpot虚拟机；运行在Server模式下(虚拟机有Server和Client两种运行模式).</p>
</blockquote>
<blockquote>
<p><code>Java(TM) SE Runtime Environment (build 1.8.0_162-b12)</code> 是Java运行时环境(即JRE)的版本信息.</p>
</blockquote>
<ul>
<li>如果是OpenJDK，显示信息为：</li>
</ul>
<pre><code class="highlight plaintext">[root@localhost ~]# java -version

openjdk version &quot;1.8.0_144&quot;
OpenJDK Runtime Environment (build 1.8.0_144-b01)
OpenJDK 64-Bit Server VM (build 25.144-b01, mixed mode)</code></pre>
<hr />
<p><strong>什么是OpenJDK</strong></p>
<p>Sun发布的OpenJDK是一款只能运行在i386和AMD-64机器上的软件</p>
<ul>
<li><strong>OpenJDK 的来历</strong></li>
</ul>
<p>Java由SUN公司(Sun Microsystems, 发起于美国斯坦福大学, SUN是Stanford University Network的缩写)发明, 2006年SUN公司将Java开源, 此时的JDK即为OpenJDK.</p>
<p>也就是说, OpenJDK是Java SE的开源实现, 它由SUN和Java社区提供支持, 2009年Oracle收购了Sun公司,自此Java的维护方之一的SUN也变成了Oracle</p>
<p>大多数JDK都是在OpenJDK的基础上编写实现的, 比如IBM J9, Azul Zulu, Azul Zing和Oracle JDK. 几乎所有的所有JDK都派生自OpenJDK, 它们之间不同的是许可证:</p>
<blockquote>
<p>OpenJDK根据许可证GPL v2发布;</p>
</blockquote>
<blockquote>
<p>Oracle JDK根据Oracle二进制代码许可协议获得许可.</p>
</blockquote>
<ul>
<li><strong>OracleJDK的来历</strong></li>
</ul>
<p>Oracle JDK之前被称为SUN JDK, 这是在2009年Oracle收购SUN公司之前, 收购后被命名为Oracle JDK.</p>
<p>实际上, Oracle JDK是基于OpenJDK源代码构建的, 因此Oracle JDK和OpenJDK之间没有重大的技术差异.</p>
<p>Oracle的项目发布经理Joe Darcy在OSCON 2011 上对两者关系的介绍也证实了OpenJDK 7和Oracle JDK 7在程序上是非常接近的, 两者共用了大量相同的代码(如下图), 注意: 图中提示了两者共同代码的占比要远高于图形上看到的比例, 所以我们编译的OpenJDK基本上可以认为性能、功能和执行逻辑上都和官方的Oracle JDK是一致的.</p>
<ul>
<li><strong>Oracle JDK与OpenJDK的区别</strong></li>
</ul>
<blockquote>
<p>OpenJDK使用的是开源免费的FreeType, 可以按照GPL v2许可证使用.GPL V2允许在商业上使用;</p>
</blockquote>
<blockquote>
<p>Oracle JDK则采用JRL(Java Research License, Java研究授权协议) 放出.JRL只允许个人研究使用,要获得Oracle JDK的商业许可证, 需要联系Oracle的销售人员进行购买</p>
</blockquote>
<hr />
<p><strong>JRockit是Oracle的JVM, 从Java SE 7开始, HotSpot和JRockit合并为一个JVM</strong>.</p>
<ul>
<li><strong>JVM和Hotspot的关系是什么？</strong></li>
</ul>
<p>JVM是《JVM虚拟机规范》中提出来的规范</p>
<p>Hotspot是使用JVM规范的商用产品，除此之外还有Oracle JRockit、IBM的J9也是JVM产品</p>
<ul>
<li>
<p><strong>JVM和Java的关系是什么？</strong></p>
</li>
<li>
<p><strong>JVM的client运行模式和server运行模式的区别是什么？</strong></p>
</li>
</ul>
<p>JVM有两种运行模式<strong>Server</strong>与<strong>Client</strong>。</p>
<p>两种模式的区别在于，Client模式启动速度较快，Server模式启动较慢；但是启动进入稳定期长期运行之后Server模式的程序运行速度比Client要快很多。这是因为Server模式启动的JVM采用的是重量级的虚拟机，对程序采用了更多的优化；而Client模式启动的JVM采用的是轻量级的虚拟机。所以Server启动慢，但稳定后速度比Client远远要快。</p>
<h3 id="jvm分类"><a class="markdownIt-Anchor" href="#jvm分类"></a> JVM分类</h3>
<ul>
<li>Java是直接通过指针进行的程序访问，所以他没有采用句柄的形式操作，这样使得程序的性能更高。</li>
<li>传统意义来讲，JVM一共分为三类（虚拟机是一个公共标准）
<ul>
<li>SUN：从JDK1.2开始使用了HotSpot虚拟机标准（06年开源，利用C++实现，一些JNI部分使用的是系统提供的C程序实现的，JIT即使编译器）</li>
<li>BEA：使用了JRockit虚拟机标准，例如：WebLogic</li>
<li>IBM：开发了JVM’s(J9)虚拟机</li>
</ul>
</li>
<li>Oracle后来通过收购得到了：SUN与BEA，那么Oracle有了两个虚拟机标准</li>
</ul>
<h3 id="hotspot"><a class="markdownIt-Anchor" href="#hotspot"></a> HotSpot</h3>
<pre><code class="highlight plaintext">java -version</code></pre>
<p>获取信息：</p>
<pre><code class="highlight plaintext">java version &quot;1.8.0_201&quot;
Java(TM) SE Runtime Environment (build 1.8.0_201-b09)
Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)</code></pre>
<p><strong>虚拟机提供有三种处理模式：</strong></p>
<ul>
<li>混合模式：Java -version</li>
<li>[禁用JIT]纯解释模式：java Xint -version</li>
<li>纯编译模式：java -Xcomp -version</li>
</ul>
<p><strong>运行模式：</strong></p>
<ul>
<li>[client]客户端运行：启动速度快，但是中间程序的执行慢，占用内存小</li>
<li>[server]服务器端运行：启动速度慢，占用内存多，执行效率高</li>
</ul>
<p>修改路径：</p>
<pre><code class="highlight plaintext">D:\java1.8\jdk1.8.0_201\lib\jvm.cfg</code></pre>
<h3 id="jvm架构理解"><a class="markdownIt-Anchor" href="#jvm架构理解"></a> JVM架构理解</h3>
<p><strong>解析器与JIT即时编译器</strong></p>
<p>在部分商用虚拟机中（如HotSpot），Java程序最初是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为<strong>即时编译器</strong>（Just In Time Compiler，下文统称JIT编译器）</p>
<p>由于Java虚拟机规范并没有具体的约束规则去限制即使编译器应该如何实现，所以这部分功能完全是与虚拟机具体实现相关的内容，如无特殊说明，我们提到的编译器、即时编译器都是指Hotspot虚拟机内的即时编译器，虚拟机也是特指HotSpot虚拟机</p>
<p>我们的JIT是属于动态编译方式的，<strong>动态编译</strong>（dynamic compilation）指的是“在运行时进行编译”；与之相对的是事前编译（ahead-of-time compilation，简称AOT），也叫<strong>静态编译</strong>（staticcompilation）。</p>
<p>JIT编译（just-in-time compilation）狭义来说是当某段代码即将第一次被执行时进行编译，因而叫“即时编译”。<strong>JIT编译是动态编译的一种特例</strong>。JIT编译一词后来被泛化，时常与动态编译等价；但要注意广义与狭义的JIT编译所指的区别</p>
<hr />
<p><strong>Java编译成字节码、动态编译和解释为机器码的过程分析：</strong></p>
<p><strong>编译器和解释器的协调工作流程：</strong></p>
<h3 id="jit即时编译器"><a class="markdownIt-Anchor" href="#jit即时编译器"></a> JIT即时编译器</h3>
<p><strong>为什么HotSpot虚拟机要使用解释器与编译器并存的架构？</strong></p>
<p>尽管并不是所有的Java虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚拟机（如HotSpot），都同时包含解释器和编译器。</p>
<hr />
<p><strong>解释器与编译器两者各有优势：</strong></p>
<p>当程序需要<strong>迅速启动和执行</strong>的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取<strong>更高的执行效率</strong>。</p>
<p>当程序运行环境中<strong>内存资源限制较大</strong>（如部分嵌入式系统中），可以<strong>使用解释器执行节约内存</strong>，反之可以使用<strong>编译执行来提升效率</strong>。</p>
<hr />
<p><strong>编译的时间开销</strong></p>
<p>解释器的执行，抽象的看是这样的：</p>
<ul>
<li>输入的代码 -&gt; [ 解释器 解释执行 ] -&gt; 执行结果</li>
</ul>
<p>而要JIT编译然后再执行的话，抽象的看则是：</p>
<ul>
<li>输入的代码 -&gt; [ 编译器 编译 ] -&gt; 编译后的代码 -&gt; [ 执行 ] -&gt; 执行结果</li>
</ul>
<blockquote>
<p>说JIT比解释快，其实说的是“执行编译后的代码”比“解释器解释执行”要快，并不是说“编译”这个动作比“解释”这个动作快。JIT编译再怎么快，至少也比解释执行一次略慢一些，而要得到最后的执行结果还得再经过一个“执行编译后的代码”的过程。所以，<strong>对“只执行一次”的代码而言，解释执行其实总是比JIT编译执行要快</strong></p>
</blockquote>
<hr />
<p><strong>怎么算是“只执行一次的代码”呢？</strong></p>
<p>粗略说，下面两个条件同时满足时就是严格的“只执行一次”</p>
<p>1、只被调用一次，例如类的构造器（class initializer，()）</p>
<p>2、没有循环</p>
<p>对只执行一次的代码做JIT编译再执行，可以说是得不偿失。</p>
<p>对只执行少量次数的代码，JIT编译带来的执行速度的提升也未必能抵消掉最初编译带来的开销</p>
<blockquote>
<p><strong>只有对频繁执行的代码，JIT编译才能保证有正面的收益</strong></p>
</blockquote>
<hr />
<p><strong>编译的空间开销</strong></p>
<p>对一般的Java方法而言，编译后代码的大小相对于class字节码的大小，膨胀比达到10x是很正常的。同上面说的时间开销一样，这里的空间开销也是，只有对执行频繁的代码才值得编译，如果把所有代码都编译则会显著增加代码所占空间，导致“代码爆炸”</p>
<blockquote>
<p><strong>这也就解释了为什么有些JVM会选择不总是做JIT编译，而是选择用解释器+JIT编译器的混合执行引擎</strong></p>
</blockquote>
<hr />
<p><strong>为何HotSpot虚拟机要实现两个不同的即时编译器？</strong></p>
<p>HotSpot虚拟机中内置了两个即时编译器：<strong>Client Complier和Server Complier</strong>，简称为C1、C2编译器，分别用在客户端和服务端。</p>
<p>目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。<strong>程序使用哪个编译器，取决于虚拟机运行的模式</strong>。HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用</p>
<pre><code class="highlight plaintext">“-client”或“-server”</code></pre>
<p>参数去强制指定虚拟机运行在Client模式或Server模式。</p>
<p>用Client Complier获取更高的<strong>编译速度</strong>，用Server Complier 来获取更好的<strong>编译质量</strong>。为什么提供多个即时编译器与为什么提供多个垃圾收集器类似，都是为了适应不同的应用场景。</p>
<hr />
<p><strong>哪些程序代码会被编译？</strong></p>
<p>程序中的代码只有是热点代码时，才会编译为本地代码，那么什么是热点代码呢？</p>
<p>运行过程中会被即时编译器编译的“热点代码”有两类：</p>
<ol>
<li>被多次调用的方法。</li>
<li>被多次执行的循环体。</li>
</ol>
<p>两种情况，编译器都是以<strong>整个方法</strong>作为编译对象。 这种编译方法因为编译发生在方法执行过程之中，因此形象的称之为栈上替换（On Stack Replacement，OSR），即方法栈帧还在栈上，方法就被替换了</p>
<hr />
<p><strong>如何判断热点代码呢？</strong></p>
<p>要知道方法或一段代码是不是热点代码，是不是需要触发即时编译，需要进行Hot Spot Detection（热点探测）</p>
<p>目前主要的热点探测方式有以下两种：</p>
<p><strong>基于采样的热点探测</strong></p>
<ul>
<li><strong>采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这个方法就是“热点方法”</strong>。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可），缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li>
</ul>
<p><strong>基于计数器的热点探测</strong></p>
<ul>
<li><strong>采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”</strong>。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨。</li>
</ul>
<hr />
<p><strong>HotSpot虚拟机中使用的是哪种热点检测方式呢？</strong></p>
<p>在HotSpot虚拟机中使用的是第二种,基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：<strong>方法调用计数器和回边计数器</strong>。在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译</p>
<p><strong>方法调用计数器</strong></p>
<p>顾名思义，这个计数器用于统计方法被调用的次数</p>
<p><strong>回边计数器</strong></p>
<p>它的作用就是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”。</p>
<hr />
<p><strong>如何编译为本地代码？</strong></p>
<p>Server Compiler和Client Compiler两个编译器的编译过程是不一样的。</p>
<p>对Client Compiler来说，它是一个简单快速的编译器，主要关注点在于<strong>局部优化</strong>，而放弃许多耗时较长的全局优化手段。</p>
<p>而Server Compiler则是专门面向服务器端的，并为服务端的性能配置特别调整过的编译器，是一个<strong>充分优化</strong>过的高级编译器。</p>
<h3 id="jit编译器优化"><a class="markdownIt-Anchor" href="#jit编译器优化"></a> JIT编译器优化</h3>
<p>HotSpot 虚拟机使用了很多种优化技术，这里只简单介绍其中的几种，完整的优化技术介绍可以参考官网内容</p>
<p><strong>公共子表达式的消除</strong></p>
<p>公共子表达式消除是一个普遍应用于各种编译器的经典优化技术，他的含义是：如果一个表达式E已经计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成为了公共子表达式。对于这种表达式，没有必要花时间再对他进行计算，只需要直接用前面计算过的表达式结果代替E就可以了。如果这种优化仅限于程序的基本块内，便称为局部公共子表达式消除（Local Common Subexpression Elimination），如果这种优化范围涵盖了多个基本块，那就称为全局公共子表达式消除（Global Common Subexpression Elimination）。举个简单的例子来说明他的优化过程，假设存在如下代码：</p>
<pre><code class="highlight plaintext">int d = (c*b)*12+a+(a+b*c)</code></pre>
<p>如果这段代码交给Javac编译器则不会进行任何优化，那生成的代码如下所示，是完全遵照Java源码的写法直译而成的</p>
<pre><code class="highlight plaintext">iload_2 // b
imul // 计算b*c bipush 12 // 推入12 imul // 计算(c*b)*12 iload_1 // a
iadd // 计算(c*b)*12+a iload_1 // a
iload_2 // b
iload_3 // c
imul // 计算b*c
iadd // 计算a+b*c
iadd // 计算(c*b)*12+a+(a+b*c) istore 4</code></pre>
<p>当这段代码进入到虚拟机即时编译器后，他将进行如下优化：编译器检测到”cb“与”bc“是一样的表达式，而且在计算期间b与c的值是不变的。因此，这条表达式就可能被视</p>
<pre><code class="highlight plaintext">int d = E*12+a+(a+E);</code></pre>
<p>这时，编译器还可能（取决于哪种虚拟机的编译器以及具体的上下文而定）进行另外一种优化：代数化简（Algebraic Simpliﬁcation），把表达式变为：</p>
<pre><code class="highlight plaintext">int d = E*13+a*2;</code></pre>
<p>表达式进行变换之后，再计算起来就可以节省一些时间了</p>
<hr />
<p><strong>方法内联</strong></p>
<p>在使用JIT进行即时编译时，将方法调用直接使用方法体中的代码进行替换，这就是方法内联，减少了方法调用过程中<strong>压栈与入栈</strong>的开销。同时为之后的一些优化手段提供条件。</p>
<p>如果JVM监测到一些小方法被频繁的执行，它会把方法的调用替换成方法体本身。比如说下面这个：</p>
<pre><code class="highlight plaintext">private int add4(int x1, int x2, int x3, int x4) &#123;
    return add2(x1, x2) + add2(x3, x4);
&#125;
private int add2(int x1, int x2) &#123;
    return x1 + x2;
&#125;</code></pre>
<p>可以肯定的是运行一段时间后JVM会把add2方法去掉，并把你的代码翻译成：</p>
<pre><code class="highlight plaintext">private int add4(int x1, int x2, int x3, int x4) &#123;
    return x1 + x2 + x3 + x4;
&#125;</code></pre>
<hr />
<p><strong>逃逸分析</strong></p>
<p>逃逸分析(Escape Analysis)是目前Java虚拟机中比较前沿的优化技术。这是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
<p><strong>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸</strong></p>
<p>逃逸分析包括：</p>
<ul>
<li>全局变量赋值逃逸</li>
<li>方法返回值逃逸</li>
<li>实例引用发生逃逸</li>
<li>线程逃逸:赋值给类变量或可以在其他线程中访问的实例变量</li>
</ul>
<pre><code class="highlight plaintext">public class EscapeAnalysis &#123;

    public static Object object;

    public void globalVariableEscape()&#123;//全局变量赋值逃逸
       object =new Object();
    &#125;

    public Object methodEscape()&#123; //方法返回值逃逸
       return new Object();
    &#125;

    public void instancePassEscape()&#123; //实例引用发生逃逸
       this.speak(this);
    &#125;

    public void speak(EscapeAnalysis escapeAnalysis)&#123;
       System.out.println(&quot;Escape Hello&quot;);
    &#125;

&#125;
</code></pre>
<p>使用方法逃逸的案例进行分析：</p>
<pre><code class="highlight plaintext">public static StringBuffer craeteStringBuffer(String s1, String s2) &#123;
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb;
&#125;</code></pre>
<blockquote>
<p>StringBuffer sb是一个方法内部变量，上述代码中直接将sb返回，这样这个StringBuffer有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为<strong>线程逃逸</strong>。</p>
</blockquote>
<p>上述代码如果想要StringBuffer sb不逃出方法，可以这样写：</p>
<pre><code class="highlight plaintext">public static String createStringBuffer(String s1, String s2) &#123;
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb.toString();
&#125;</code></pre>
<blockquote>
<p>不直接返回 StringBuffer，那么StringBuffer将不会逃逸出方法</p>
</blockquote>
<p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<blockquote>
<p>一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>
</blockquote>
<blockquote>
<p>二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p>
</blockquote>
<blockquote>
<p>三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中</p>
</blockquote>
<p><strong>在Java代码运行时，通过JVM参数可指定是否开启逃逸分析</strong></p>
<pre><code class="highlight plaintext">-XX:+DoEscapeAnalysis ： 表示开启逃逸分析
-XX:-DoEscapeAnalysis ： 表示关闭逃逸分析</code></pre>
<blockquote>
<p>从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis</p>
</blockquote>
<hr />
<p><strong>对象的栈上内存分配</strong></p>
<p>我们知道，在<strong>一般情况下，对象和数组元素的内存分配是在堆内存上进行的</strong>。但是随着JIT编译器的日渐成熟，很多优化使这种分配策略并不绝对。JIT编译器就可以在编译期间根据逃逸分析的结果，来决定是否可以将对象的内存分配从堆转化为栈</p>
<pre><code class="highlight plaintext">public class EscapeAnalysisTest &#123;

    public static void main(String[] args) &#123;
        long a1 = System.currentTimeMillis();
        for (int i = 0; i &lt; 1000000; i++) &#123;
            alloc();
        &#125;
        // 查看执行时间
        long a2 = System.currentTimeMillis();
        System.out.println(&quot;cost &quot; + (a2 - a1) + &quot; ms&quot;);
        // 为了方便查看堆内存中对象个数，线程sleep
        try &#123;
           Thread.sleep(100000);
        &#125; catch (InterruptedException e1) &#123;
            e1.printStackTrace();
        &#125;
    &#125;

    private static void alloc() &#123;
     User user = new User();
    &#125;

    static class User &#123;
    &#125;

&#125;
</code></pre>
<blockquote>
<p>其实代码内容很简单，就是使用for循环，在代码中创建100万个User对象</p>
</blockquote>
<blockquote>
<p>我们在alloc方法中定义了User对象，但是并没有在方法外部引用他。也就是说，这个对象并不会逃逸到alloc外部。经过JIT的逃逸分析之后，就可以对其内存分配进行优化</p>
</blockquote>
<p>我们指定以下JVM参数并运行：</p>
<pre><code class="highlight plaintext">-Xmx4G -Xms4G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError</code></pre>
<p>在程序打印出 <code>cost XX ms</code> 后，代码运行结束之前，我们使用<code>[jmap][1]</code> 命令，来查看下当前堆内存中有多少个User对象：</p>
<pre><code class="highlight plaintext">~ jps

2809 StackAllocTest
2810 Jps
~ jmap -histo 2809
num #instances #bytes class name
.
----------------------------------------------
1: 524 87282184 [I
2: 1000000 16000000 StackAllocTest$User
3: 6806 2093136 [B
4: 8006 1320872 [C
5: 4188 100512 java.lang.String
6: 581 66304 java.lang.Class</code></pre>
<p>从上面的jmap执行结果中我们可以看到，堆中共创建了100万个StackAllocTest$User 实例。</p>
<p>在关闭逃避分析的情况下（<code>-XX:-DoEscapeAnalysis</code>），虽然在alloc方法中创建的User对象并没有逃逸到方法外部，但是还是被分配在堆内存中。也就说，如果没有JIT编译器优化，没有逃逸分析技术，正常情况下就应该是这样的。即所有对象都分配到堆内存中。</p>
<p>接下来，我们开启逃逸分析，再来执行下以上代码</p>
<pre><code class="highlight plaintext">-Xmx4G -Xms4G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError</code></pre>
<p>在程序打印出 cost XX ms 后，代码运行结束之前，我们使用jmap 命令，来查看下当前堆内存中有多少个User对象：</p>
<p>从以上打印结果中可以发现，开启了逃逸分析之后（-XX:+DoEscapeAnalysis），在堆内存中只有12万多个StackAllocTest$User 对象。也就是说在经过JIT优化之后，堆内存中分配的对象数量，从100万降到了12万。</p>
<p>除了以上通过jmap验证对象个数的方法以外，读者还可以尝试将堆内存调小，然后执行以上代码，根据GC的次数来分析，也能发现，开启了逃逸分析之后，在运行期间，GC次数会明显减少。正是因为很多堆上分配被优化成了栈上分配，所以GC次数有了明显的减少</p>
<p><strong>总结</strong></p>
<p>所以，如果以后再有人问你：是不是所有的对象和数组都会在堆内存分配空间？</p>
<p>那么你可以告诉他：不一定，随着JIT编译器的发展，在编译期间，如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。但是这也并不是绝对的。就像我们前面看到的一样，在开启逃逸分析之后，也并不是所有User对象都没有在堆上分配</p>
<hr />
<p><strong>标量替换</strong></p>
<p>标量（Scalar）是指一个无法再分解成更小的数据的数据 。</p>
<p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替</p>
<pre><code class="highlight plaintext">//有一个类A
public class A&#123;
    public int a=1;
    public int b=2
&#125;
//方法getAB使用类A里面的a,b
private void getAB()&#123;
    A x = new A();
    x.a;
    x.b;
&#125;
//JVM在编译的时候会直接编译成
private void getAB()&#123;
    a = 1;
    b = 2;
&#125;
//这就是标量替换</code></pre>
<hr />
<p><strong>同步锁消除</strong></p>
<p>同样基于逃逸分析，当加锁的变量不会发生逃逸，是线程私有的完全没有必要加锁。 在jit编译时期就可以将同步锁去掉，以减少加锁与解锁造成的资源开销</p>
<pre><code class="highlight plaintext">public class TestLockEliminate &#123;

    public static String getString(String s1, String s2) &#123;
        StringBuffer sb = new StringBuffer();
        sb.append(s1);
        sb.append(s2);
        return sb.toString();
    &#125;

    public static void main(String[] args) &#123;
        long tsStart = System.currentTimeMillis();
        for (int i = 0; i &lt; 1000000; i++) &#123;
         getString(&quot;TestLockEliminate &quot;, &quot;Suffix&quot;);
        &#125;
        System.out.println(&quot;一共耗费：&quot; + (System.currentTimeMillis() - tsStart) + &quot; ms&quot;);
    &#125;

&#125;</code></pre>
<p>getString()方法中的StringBuffer数以函数内部的局部变量，进作用于方法内部，不可能逃逸出该方法，因此他就不可能被多个线程同时访问，也就没有资源的竞争，但是StringBuffer的append操作却需要执行同步操作:</p>
<pre><code class="highlight plaintext">@Override
public synchronized StringBuffer append(String str) &#123;
    toStringCache = null;
    super.append(str);
    return this;
&#125;</code></pre>
<p>逃逸分析和锁消除分别可以使用参数<code>-XX:+DoEscapeAnalysis</code>和<code>-XX:+EliminateLocks</code>(锁消除必须在-server模式下)开启。使用如下参数运行上面的程序：</p>
<pre><code class="highlight plaintext">-XX:+DoEscapeAnalysis -XX:-EliminateLocks</code></pre>
<p>得到如下结果：</p>
<p>使用如下命令</p>
<pre><code class="highlight plaintext">-XX:+DoEscapeAnalysis -XX:+EliminateLocks</code></pre>
<p>得到如下结果：</p>
<h2 id="class文件"><a class="markdownIt-Anchor" href="#class文件"></a> CLASS文件</h2>
<h3 id="class文件概述"><a class="markdownIt-Anchor" href="#class文件概述"></a> class文件概述</h3>
<p>我们可任意打开一个Class文件（使用Hex Editor等工具打开），内容如下（内容是16进制）：</p>
<p><strong>魔数</strong></p>
<p>所有的由Java编译器编译而成的class文件的前4个字节都是“0xCAFEBABE”。</p>
<p>它的作用在于：当JVM在尝试加载某个文件到内存中来的时候，会首先判断此class文件有没有JVM认为可以接受的“签名”，即JVM会首先读取文件的前4个字节，判断该4个字节是否是“0xCAFEBABE”，如果是，则JVM会认为可以将此文件当作class文件来加载并使用。</p>
<p><strong>版本号</strong></p>
<p>随着Java本身的发展，Java语言特性和JVM虚拟机也会有相应的更新和增强。目前我们能够用到的JDK版本如：1.5，1.6，1.7，还有现如今的1.8及更高的版本。发布新版本的目的在于：在原有的版本上增加新特性和相应的JVM虚拟机的优化。而随着主版本发布的次版本，则是修改相应主版本上出现的bug。我们平时只需要关注主版本就可以了。</p>
<p>主版本号和次版本号在class文件中各占两个字节，副版本号占用第5、6两个字节，而主版本号则占用第7，8两个字节。JDK1.0的主版本号为45，以后的每个新主版本都会在原先版本的基础上加1。若现在使用的是JDK1.7编译出来的class文件，则相应的主版本号应该是51,对应的7，8个字节的十六进制的值应该是 0x33。</p>
<p>一个 JVM实例只能支持特定范围内的主版本号 （Mi 至Mj） 和 0 至特定范围内 （0 至 m） 的副版本号。假设一个 Class 文件的格式版本号为 V， 仅当Mi.0 ≤ v ≤ Mj.m成立时，这个 Class 文件才可以被此 Java 虚拟机支持。不同版本的 Java 虚拟机实现支持的版本号也不同，高版本号的 Java 虚拟机实现可以支持低版本号的 Class 文件，反之则不成立。</p>
<p>JVM在加载class文件的时候，会读取出主版本号，然后比较这个class文件的主版本号和JVM本身的版本号，如果JVM本身的版本号 &lt; class文件的版本号，JVM会认为加载不了这个class文件，会抛出我们经常见到的&quot; java.lang.UnsupportedClassVersionError: Bad version number in .class file &quot; Error 错误；反之，JVM会认为可以加载此class文件，继续加载此class文件</p>
<blockquote>
<ol>
<li>有时候我们在运行程序时会抛出这个Error 错误：“java.lang.UnsupportedClassVersionError: Bad version number in .class ﬁle”。上面已经揭示了出现这个问题的原因，就是在于当前尝试加载class文件的JVM虚拟机的版本 低于class文件的版本。解决方法：1.重新使用当前jvm编译源代码，然后再运行代码；2.将当前JVM虚拟机更新到class文件的版本。</li>
<li>怎样查看class文件的版本号？可以借助于文本编辑工具，直接查看该文件的7，8个字节的值，确定class文件是什么版本的。</li>
</ol>
</blockquote>
<p>当然快捷的方式使用JDK自带的javap工具，如当前有Math.class 文件，进入此文件所在的目录，然后执行 ”javap -v Math“,结果会类似如下所示：</p>
<p><strong>常量池计数器</strong></p>
<p>常量池是class文件中非常重要的结构，它描述着整个class文件的字面量信息。常量池是由一组constant_pool结构体数组组成的，而数组的大小则由常量池计数器指定。常量池计数器</p>
<p>constant_pool_count 的值 =constant_pool表中的成员数+ 1。constant_pool表的索引值只有在大于 0 且小于constant_pool_count时才会被认为是有效的。</p>
<blockquote>
<p>注意事项</p>
</blockquote>
<p>常量池计数器默认从1开始而不是从0开始：</p>
<ul>
<li>当constant_pool_count = 1时，常量池中的cp_info个数为0；当constant_pool_count为n时，常量池中的cp_info个数为n-1。</li>
</ul>
<p>原因：</p>
<ul>
<li>在指定class文件规范的时候，将索引#0项常量空出来是有特殊考虑的，这样当：某些数据在特定的情况下想表达“不引用任何一个常量池项”的意思时，就可以将其引用的常量的索引值设置为#0来表示</li>
</ul>
<p><strong>常量池数据区</strong></p>
<p><strong>访问标志</strong></p>
<p>访问标志，access_flags 是一种掩码标志，用于表示某个类或者接口的访问权限及基础属性。</p>
<p><strong>类索引</strong></p>
<p>类索引，this_class的值必须是对constant_pool表中项目的一个有效索引值。constant_pool表在这个索引处的项必须为CONSTANT_Class_info 类型常量，表示这个 Class 文件所定义的类或接口</p>
<p><strong>父类索引</strong></p>
<p>父类索引，对于类来说，super_class 的值必须为 0 或者是对constant_pool 表中项目的一个有效索引值。</p>
<p>如果它的值不为 0，那 constant_pool 表在这个索引处的项必须为CONSTANT_Class_info 类型常量，表示这个 Class 文件所定义的类的直接父类。当前类的直接父类，以及它所有间接父类的access_flag 中都不能带有ACC_FINAL 标记。对于接口来说，它的Class文件的super_class项的值必须是对constant_pool表中项目的一个有效索引值。constant_pool表在这个索引处的项必须为代表 java.lang.Object 的 CONSTANT_Class_info 类型常量 。</p>
<p>如果 Class 文件的 super_class的值为 0，那这个Class文件只可能是定义的是java.lang.Object类，只有它是唯一没有父类的类。</p>
<p><strong>接口计数器</strong></p>
<p>接口计数器，interfaces_count的值表示当前类或接口的【直接父接口数量】。</p>
<p><strong>接口信息数据区</strong></p>
<p>接口表，interfaces[]数组中的每个成员的值必须是一个对constant_pool表中项目的一个有效索引值， 它的长度为 interfaces_count。每个成员interfaces[i] 必须为</p>
<p>CONSTANT_Class_info类型常量，其中 【0 ≤ i &lt;interfaces_count】。在interfaces[]数组中，成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即interfaces[0]对应的是源代码中最左边的接口。</p>
<p><strong>字段计数器</strong></p>
<p>字段计数器，fields_count的值表示当前 Class 文件 fields[]数组的成员个数。 fields[]数组中每一项都是一个field_info结构的数据项，它用于表示该类或接口声明的类字段或者实例字段。</p>
<p><strong>字段信息数据区</strong></p>
<p>字段表，fields[]数组中的每个成员都必须是一个fields_info结构的数据项，用于表示当前类或接口中某个字段的完整描述。 fields[]数组描述当前类或接口声明的所有字段，但不包括从父类或父接口继承的部分。</p>
<p><strong>方法计数器</strong></p>
<p>方法计数器， methods_count的值表示当前Class 文件 methods[]数组的成员个数。Methods[]数组中每一项都是一个 method_info 结构的数据项。</p>
<p><strong>方法信息数据区</strong></p>
<p>方法表，methods[] 数组中的每个成员都必须是一个 method_info 结构的数据项，用于表示当前类或接口中某个方法的完整描述。</p>
<p>如果某个method_info 结构的access_flags 项既没有设置 ACC_NATIVE 标志也没有设置</p>
<p>ACC_ABSTRACT 标志，那么它所对应的方法体就应当可以被 Java 虚拟机直接从当前类加载，而不需要引用其它类。</p>
<p>method_info结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法 。</p>
<p>【methods[]数组只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法】。</p>
<p><strong>属性计数器</strong></p>
<p>属性计数器，attributes_count的值表示当前 Class 文件attributes表的成员个数。 attributes表中每一项都是一个attribute_info 结构的数据项。</p>
<p><strong>属性信息数据区</strong></p>
<p>属性表，attributes 表的每个项的值必须是attribute_info结构。</p>
<p>在Java 7 规范里，Class文件结构中的attributes表的项包括下列定义的属性： InnerClasses 、 EnclosingMethod 、 Synthetic 、Signature、SourceFile，SourceDebugExtension 、Deprecated、RuntimeVisibleAnnotations 、RuntimeInvisibleAnnotations以及BootstrapMethods属性。</p>
<p>对于支持 Class 文件格式版本号为 49.0 或更高的 Java 虚拟机实现，必须正确识别并读取attributes表中的Signature、RuntimeVisibleAnnotations和RuntimeInvisibleAnnotations属性。对于支持Class文件格式版本号为 51.0 或更高的 Java 虚拟机实现，必须正确识别并读取 attributes表中的BootstrapMethods属性。Java 7 规范 要求任一 Java 虚拟机实现可以自动忽略 Class 文件的 attributes表中的若干 （甚至全部） 它不可识别的属性项。任何本规范未定义的属性不能影响Class文件的语义，只能提供附加的描述信息 。</p>
<h3 id="class常量池理解"><a class="markdownIt-Anchor" href="#class常量池理解"></a> class常量池理解</h3>
<p><strong>1.常量池在class文件的什么位置？</strong></p>
<p><strong>2.常量池的里面是怎么组织的？</strong></p>
<p>cp_info：常量池项</p>
<p>constant_pool_count：常量池计算器</p>
<p><strong>3.常量池项 (cp_info) 的结构是什么？</strong></p>
<p>JVM虚拟机规定了不同的tag值和不同类型的字面量对应关系如下：</p>
<p>所以根据cp_info中的tag 不同的值，可以将cp_info 更细化为以下结构体：</p>
<p>现在让我们看一下细化了的常量池的结构会是类似下图所示的样子：</p>
<p><strong>4. int和ﬂoat数据类型的常量在常量池中是怎样表示和存储的？</strong></p>
<p>Java语言规范规定了 int类型和Float 类型的数据类型占用 4 个字节的空间。那么存在于class字节码文件中的该类型的常量是如何存储的呢？</p>
<p>举例：建下面的类 IntAndFloatTest.java，在这个类中，我们声明了五个变量，但是取值就两种int类型的10 和Float类型的11f。</p>
<pre><code class="highlight plaintext">package com.kkb.jvm;  
 public class IntAndFloatTest &#123;
     private final int a = 10;  
     private final int b = 10;  
     private float c = 11f; 
     private float d = 11f;  
     private float e = 11f; 
 &#125;</code></pre>
<p>然后用编译器编译成IntAndFloatTest.class字节码文件，我们通过javap -v IntAndFloatTest 指令来看一下其常量池中的信息，可以看到虽然我们在代码中写了两次10 和三次11f，但是常量池中，就只有一个常量10 和一个常量11f,如下图所示:</p>
<p>从结果上可以看到常量池第#8 个常量池项(cp_info) 就是CONSTANT_Integer_info,值为10；第#23个常量池项(cp_info) 就是CONSTANT_Float_info,值为11f。</p>
<p>代码中所有用到 int 类型 10 的地方，会使用指向常量池的指针值#8 定位到第#8 个常量池项</p>
<p>(cp_info)，即值为 10的结构体CONSTANT_Integer_info，而用到ﬂoat类型的11f时，也会指向常量池的指针值#23来定位到第#23个常量池项(cp_info) 即值为11f的结构体CONSTANT_Float_info。如下图所示：</p>
<p><strong>5. long和 double数据类型的常量在常量池中是怎样表示和存储的？</strong></p>
<p>Java语言规范规定了 long 类型和 double类型的数据类型占用8 个字节的空间。那么存在于class 字节码文件中的该类型的常量是如何存储的呢？</p>
<p>举例：建下面的类 LongAndDoubleTest.java，在这个类中，我们声明了六个变量，但是取值就两种Long 类型的-6076574518398440533L 和Double 类型的10.1234567890D。</p>
<pre><code class="highlight plaintext">public class LongAndDoubleTest &#123;

    private long a = -6076574518398440533L;  
    private long b = -6076574518398440533L;  
    private long c = -6076574518398440533L;  
    private double d = 10.1234567890D;  
    private double e = 10.1234567890D; 
    private double f = 10.1234567890D; 
&#125;</code></pre>
<p>然后用编译器编译成 LongAndDoubleTest.class 字节码文件，我们通过javap -v LongAndDoubleTest指令来看一下其常量池中的信息，可以看到虽然我们在代码中写了三次-6076574518398440533L 和三次10.1234567890D，但是常量池中，就只有一个常</p>
<p>量-6076574518398440533L 和一个常量10.1234567890D,如下图所示:</p>
<p>从结果上可以看到常量池第 #18 个常量池项(cp_info) 就是CONSTANT_Long_info,值</p>
<p>为-6076574518398440533L ；第 #26个常量池项(cp_info) 就是CONSTANT_Double_info,值为10.1234567890D。</p>
<p>代码中所有用到 long 类型-6076574518398440533L 的地方，会使用指向常量池的指针值#18 定位到第 #18 个常量池项(cp_info)，即值为-6076574518398440533L 的结构体CONSTANT_Long_info，而用到double类型的10.1234567890D时，也会指向常量池的指针值#26来定位到第 #26 个常量池项</p>
<p>(cp_info) 即值为10.1234567890D的结构体CONSTANT_Double_info。如下图所示：</p>
<p><strong>6. String类型的字符串常量在常量池中是怎样表示和存储的？</strong></p>
<p>对于字符串而言，JVM会将字符串类型的字面量以UTF-8 编码格式存储到在class字节码文件中。这么说可能有点摸不着北，我们先从直观的Java源码中中出现的用双引号&quot;&quot; 括起来的字符串来看，在编译器编译的时候，都会将这些字符串转换成CONSTANT_String_info结构体，然后放置于常量池中。其结构如下所示：</p>
<p>如上图所示的结构体，CONSTANT_String_info结构体中的string_index的值指向了CONSTANT_Utf8_info结构体，而字符串的utf-8编码数据就在这个结构体之中。如下图所示：</p>
<p>请看一例，定义一个简单的StringTest.java类，然后在这个类里加一个&quot;JVM原理&quot; 字符串，然后，我们来看看它在class文件中是怎样组织的。</p>
<pre><code class="highlight plaintext">public class StringTest &#123;
    private String s1 = &quot;JVM原理&quot;; 
    private String s2 = &quot;JVM原理&quot;; 
    private String s3 = &quot;JVM原理&quot;; 
    private String s4 = &quot;JVM原理&quot;;
&#125;</code></pre>
<p>将Java源码编译成StringTest.class文件后，在此文件的目录下执行 javap -v StringTest 命令，会看到如下的常量池信息的轮廓：</p>
<p>(PS :使用javap -v 指令能看到易于我们阅读的信息，查看真正的字节码文件可以使用HEXWin、 NOTEPAD++、UtraEdit 等工具。)</p>
<p>在面的图中，我们可以看到CONSTANT_String_info结构体位于常量池的第#15个索引位置。而存</p>
<p>放&quot;Java虚拟机原理&quot; 字符串的 UTF-8编码格式的字节数组被放到CONSTANT_Utf8_info结构体中，该结构体位于常量池的第#16个索引位置。上面的图只是看了个轮廓，让我们再深入地看一下它们的组织吧。请看下图：</p>
<p>由上图可见：“JVM原理”的UTF-8编码的数组是：4A564D E5 8E 9FE7 90 86，并且存入了CONSTANT_Utf8_info结构体中</p>
<p><strong>7. 类文件中定义的类名和类中使用到的类在常量池中是怎样被组织和存储的？</strong></p>
<p>JVM会将某个Java 类中所有使用到了的类的完全限定名 以二进制形式的完全限定名 封装成CONSTANT_Class_info结构体中，然后将其放置到常量池里。CONSTANT_Class_info 的tag值为 7 。其结构如下：</p>
<blockquote>
<p>Tips：类的完全限定名和二进制形式的完全限定名</p>
</blockquote>
<blockquote>
<p>在某个Java源码中，我们会使用很多个类，比如我们定义了一个 ClassTest的类，并把它放到com.kkb.jvm 包下，则 ClassTest类的完全限定名为com.kkb.jvm.ClassTest，将JVM编译器将类编译成class文件后，此完全限定名在class文件中，是以二进制形式的完全限定名存储的，即它会把完全限定符的&quot;.“换成”/&quot; ，即在class文件中存储的 ClassTest类的完全限定名称</p>
<p>是&quot;com/kkb/jvm/ClassTest&quot;。因为这种形式的完全限定名是放在了class二进制形式的字节码文件中，所以就称之为 二进制形式的完全限定名。</p>
</blockquote>
<p>举例，我们定义一个很简单的ClassTest类，来看一下常量池是怎么对类的完全限定名进行存储的。</p>
<pre><code class="highlight plaintext"> import  java.util.Date;   
 public class ClassTest &#123;
    private Date date =new Date();
&#125;</code></pre>
<p>将Java源码编译成ClassTest.class文件后，在此文件的目录下执行 javap -v ClassTest 命令，会看到如下的常量池信息的轮廓：</p>
<p>如上图所示，在ClassTest.class文件的常量池中，共有 3 个CONSTANT_Class_info结构体，分别表示ClassTest 中用到的Class信息。 我们就看其中一个表示com/jvm.ClassTest的</p>
<p>CONSTANT_Class_info 结构体。它在常量池中的位置是#1，它的name_index值为#2，它指向了常量池的第2 个常量池项，如下所示:</p>
<p>注意：</p>
<blockquote>
<p>对于某个类而言，其class文件中至少要有两个CONSTANT_Class_info常量池项，用来表示自己的类信息和其父类信息。(除了java.lang.Object类除外，其他的任何类都会默认继承自</p>
<p>java.lang.Object）如果类声明实现了某些接口，那么接口的信息也会生成对应的</p>
<p>CONSTANT_Class_info常量池项。</p>
</blockquote>
<p>除此之外，如果在类中使用到了其他的类，只有真正使用到了相应的类，JDK编译器才会将类的信息组成CONSTANT_Class_info常量池项放置到常量池中。如下图：</p>
<pre><code class="highlight plaintext">import java.util.Date; 
public  class Other&#123; 
    private Date date;  
    public Other()  &#123; 
        Date da;
    &#125;
&#125;</code></pre>
<p>上述的Other的类，在JDK将其编译成class文件时，常量池中并没有java.util.Date对应的CONSTANT_Class_info常量池项，为什么呢?</p>
<p>在Other类中虽然定义了Date类型的两个变量date、da，但是JDK编译的时候，认为你只是声明</p>
<p>了“Ljava/util/Date”类型的变量，并没有实际使用到Ljava/util/Date类。将类信息放置到常量池中的目的，是为了在后续的代码中有可能会反复用到它。很显然，JDK在编译Other类的时候，会解析到Date类有没有用到，发现该类在代码中就没有用到过，所以就认为没有必要将它的信息放置到常量池中了。</p>
<hr />
<p>将上述的Other类改写一下，仅使用new Date()，如下图所示：</p>
<pre><code class="highlight plaintext">import java.util.Date; 
public  class Other&#123; 
    private Date date;  
    public Other()  &#123; 
        new Date();;
    &#125;
&#125;</code></pre>
<p>这时候使用javap -v Other ，可以查看到常量池中有表示java/util/Date的常量池项：</p>
<hr />
<p><strong>总结</strong></p>
<p>对于某个类或接口而言，其自身、父类和继承或实现的接口的信息会被直接组装成</p>
<p>CONSTANT_Class_info常量池项放置到常量池中；</p>
<p>类中或接口中使用到了其他的类，只有在类中实际使用到了该类时，该类的信息才会在常量池中有对应的CONSTANT_Class_info常量池项；</p>
<p>类中或接口中仅仅定义某种类型的变量，JDK只会将变量的类型描述信息以UTF-8字符串组成CONSTANT_Utf8_info常量池项放置到常量池中，上面在类中的private Date date;JDK编译器只会将表示date的数据类型的“Ljava/util/Date”字符串放置到常量池中。</p>
<hr />
<p><strong>8.哪些字面量会进入常量池中？</strong></p>
<ol>
<li>final类型的8种基本类型的值会进入常量池。</li>
<li>非final类型（包括static的）的8种基本类型的值，只有double、float、long的值会进入常量池。</li>
<li>常量池中包含的字符串类型字面量（双引号引起来的字符串值）。</li>
</ol>
<p>测试代码：</p>
<pre><code class="highlight plaintext">public class Test&#123;
     private int int_num = 110;
     private char char_num = &#x27;a&#x27;;
     private short short_num = 120;
     private float float_num = 130.0f; 
     private double double_num = 140.0;  
     private byte byte_num = 111;
    private long long_num = 3333L; 
    private long long_delay_num;
    private boolean boolean_flage = true;
    
    public void init()&#123;
        this.long_delay_num = 5555L;
    &#125;
&#125;</code></pre>
<p>使用javap命令打印的结果如下：</p>
<h3 id="class文件中的应用和特殊字符串"><a class="markdownIt-Anchor" href="#class文件中的应用和特殊字符串"></a> class文件中的应用和特殊字符串</h3>
<p><strong>符号引用</strong></p>
<p>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。</p>
<p>例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、</p>
<p>CONSTANT_Methodref_info等类型的常量出现</p>
<p>符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中</p>
<p>在[Java]中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p>
<hr />
<p><strong>直接引用</strong></p>
<ol>
<li>直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）</li>
<li>相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）</li>
<li>一个能间接定位到目标的句柄</li>
</ol>
<p>直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。</p>
<hr />
<p><strong>符号引用替换为直接引用的时机</strong></p>
<p>符号引用替换为直接引用的操作发生在类加载过程(加载 -&gt; 连接(验证、准备、解析) -&gt; 初始化)中的解析阶段，会将符号引用转换(替换)为对应的直接引用，放入运行时常量池中</p>
<blockquote>
<p>注：直接引用可以是指向目标内存的指针，也可以是偏移量，也可以是一个能定位到目标内存的句柄。</p>
</blockquote>
<p>特殊字符串包括三种： 类的全限定名， 字段和方法的描述符， 特殊方法的方法名。 下面我们就分别介绍这三种特殊字符串。</p>
<hr />
<p><strong>类的全限定名</strong></p>
<p>Object类，在源文件中的全限定名是 java.lang.Object。而class文件中的全限定名是将点号替换成“/” 。</p>
<p>Object类在class文件中的全限定名是 java/lang/Object 。 源文件中一个类的名字， 在class文件中是用全限定名表述的。</p>
<hr />
<p><strong>描述符</strong></p>
<ul>
<li><strong>各类型的描述符</strong></li>
</ul>
<p>对于字段的数据类型，其描述符主要有以下几种</p>
<ul>
<li>
<p>基本数据类型（byte、char、double、ﬂoat、int、long、short、boolean）：除 long 和 boolean，其他基本数据类型的描述符用对应单词的大写首字母表示。long 用 J 表示，boolean 用 Z 表示。</p>
</li>
<li>
<p>void：描述符是 V。</p>
</li>
<li>
<p>对象类型：描述符用字符 L加上对象的全限定名表示，如 String 类型的描述符为 Ljava/lang/String。</p>
</li>
<li>
<p>数组类型：每增加一个维度则在对应的字段描述符前增加一个<code>[ ，如一维数组 int[] 的描述符为 [I，二维数组 String[][] 的描述符为 [[Ljava/lang/String 。</code></p>
</li>
<li>
<p><strong>字段描述符</strong></p>
</li>
</ul>
<p>字段的描述符就是字段的类型所对应的字符或字符串。</p>
<pre><code class="highlight plaintext">int i 中， 字段i的描述符就是 I
Object o中， 字段o的描述符就是 Ljava/lang/Object;
double[][] d中， 字段d的描述符就是 [[D</code></pre>
<ul>
<li><strong>方法描述符</strong></li>
</ul>
<p>方法的描述符比较复杂， 包括所有参数的类型列表和方法返回值。 它的格式是这样的：</p>
<pre><code class="highlight plaintext">(参数1类型 参数2类型 参数3类型 ...)返回值类型</code></pre>
<blockquote>
<p>不管是参数的类型还是返回值类型， 都是使用对应字符和对应字符串来表示的， 并且参数列表使用小括号括起来， 并且各个参数类型之间没有空格， 参数列表和返回值类型之间也没有空格。</p>
</blockquote>
<p>方法描述符举例说明如下：</p>
<p>特殊方法的方法名</p>
<p>首先要明确一下， 这里的特殊方法是指的类的构造方法和类型初始化方法。</p>
<p>构造方法就不用多说了， 至于类型的初始化方法， 对应到源码中就是静态初始化块。 也就是说， 静态初始化块， 在class文件中是以一个方法表述的， 这个方法同样有方法描述符和方法名，具体如下:</p>
<ul>
<li>类的构造方法的方法名使用字符串 表示</li>
<li>静态初始化方法的方法名使用字符串 表示。</li>
<li>除了这两种特殊的方法外， 其他普通方法的方法名， 和源文件中的方法名相同</li>
</ul>
<hr />
<p><strong>总结</strong></p>
<ol>
<li>方法和字段的描述符中， 不包括字段名和方法名， 字段描述符中只包括字段类型， 方法描述符中只包括参数列表和返回值类型。</li>
<li>无论method()是静态方法还是实例方法，它的方法描述符都是相同的。尽管实例方法除了传递自身定义的参数，还需要额外传递参数this，但是这一点不是由方法描述符来表达的。参数this的传递，是由Java虚拟机实现在调用实例方法所使用的指令中实现的隐式传递。</li>
</ol>
<h2 id="类加载子系统"><a class="markdownIt-Anchor" href="#类加载子系统"></a> 类加载子系统</h2>
<h3 id="jvm程序执行流程"><a class="markdownIt-Anchor" href="#jvm程序执行流程"></a> JVM程序执行流程</h3>
<p><strong>Bootstrap：系统类加载器</strong></p>
<p>如示例：String是系统类加载的，我们无法看到其类加载器</p>
<pre><code class="highlight plaintext">package com.lee.configserver;

public class testMain &#123;
    public static void main(String[] args) &#123;
        //String是一个系统类，系统类里面的类加载器是不同的
        String str = &quot;hello&quot;; //静态常量池定义
        System.out.println(str.getClass().getClassLoader());
    &#125;
&#125;</code></pre>
<p>输出：</p>
<p><strong>App类加载器</strong></p>
<pre><code class="highlight plaintext">package com.lee.configserver;

class People&#123;&#125;

public class testMain &#123;
    public static void main(String[] args) &#123;
        People people = new People();   //实例化了一个自定义类对象
        System.out.println(people.getClass().getClassLoader());
    &#125;
&#125;</code></pre>
<p>输出：</p>
<p><strong>平台类加载器</strong></p>
<pre><code class="highlight plaintext">package com.lee.configserver;

class People&#123;&#125;

public class testMain &#123;
    public static void main(String[] args) &#123;
        People people = new People();   //实例化了一个自定义类对象
        System.out.println(people.getClass().getClassLoader());
        System.out.println(people.getClass().getClassLoader().getParent());
        System.out.println(people.getClass().getClassLoader().getParent().getParent());
    &#125;
&#125;</code></pre>
<h3 id="类加载过程"><a class="markdownIt-Anchor" href="#类加载过程"></a> 类加载过程</h3>
<p><strong>加载</strong></p>
<p>“加载”是“类加载”(Class Loading)过程的第一步。这个加载过程主要就是靠<strong>类加载器</strong>实现的，包括用户自定义类加载器。</p>
<p><strong>加载的过程</strong></p>
<p>在加载的过程中,JVM主要做3件事情</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流(class文件)在程序运行过程中,当要访问一个类时,若发现这个类尚未被加载,并满足类初始化的条件时，就根据要被初始化的这个类的全限定名找到该类的二进制字节流,开始加载过程</li>
<li>将这个字节流的<strong>静态存储结构</strong>转化为<strong>方法区的运行时数据结构</strong></li>
<li><strong>在内存中创建一个该类的java.lang.Class对象</strong>,作为方法区该类的各种数据的访问入口</li>
</ul>
<blockquote>
<p>程序在运行中所有对该类的访问都通过这个类对象,也就是这个Class对象是提供给外界访问该类的接口。</p>
</blockquote>
<hr />
<p><strong>加载源</strong></p>
<p>JVM规范对于加载过程给予了较大的宽松度.一般二进制字节流都从已经编译好的本地class文件中读取,此外还可以从以下地方读取。</p>
<ul>
<li><strong>zip�</strong>�<br />
Jar、War、Ear等</li>
<li><strong>其它文件生成</strong><br />
由JSP文件中生成对应的Class类.</li>
<li><strong>数据库中</strong><br />
将二进制字节流存储至数据库中,然后在加载时从数据库中读取.有些中间件会这么做,用来实现代码在集群间分发</li>
<li><strong>网络</strong><br />
从网络中获取二进制字节流.典型就是Applet.</li>
<li><strong>运行时计算生成</strong><br />
动态代理技术,用ProxyGenerator.generateProxyClass为特定接口生成形式为<code>&quot;*$Proxy&quot;</code>的代理类的二进制字节流.</li>
</ul>
<p><strong>类和数组加载的区别</strong></p>
<p>数组也有类型,称为“数组类型”.如:</p>
<pre><code class="highlight plaintext">String[] str = new String[10];</code></pre>
<blockquote>
<p>这个数组的数组类型是[Ljava.lang.String ,而String只是这个数组的元素类型</p>
</blockquote>
<p>数组类和非数组类的类加载是不同的，具体情况如下：</p>
<ul>
<li><strong>非数组类</strong>：是由类加载器来完成。</li>
<li><strong>数组类</strong>：数组类本身不通过类加载器创建，它是由java虚拟机直接创建，但数组类与类加载器有很密切的关系，因为数组类的元素类型最终要靠类加载器创建</li>
</ul>
<hr />
<p><strong>加载过程的注意点</strong></p>
<ul>
<li><strong>JVM规范并未给出类在方法区中存放的数据结构</strong></li>
</ul>
<p>类完成加载后,二进制字节流就以特定的数据结构存储在方法区中,但存储的数据结构是由虚拟机自己定义的,虚拟机规范并没有指定。</p>
<ul>
<li><strong>JVM规范并没有指定Class对象存放的位置</strong></li>
</ul>
<p>在二进制字节流以特定格式存储在方法区后,JVM会创建一个java.lang.Class类的对象,作为本类的外部访问接口。</p>
<p>既然是对象就应该存放在Java堆中,不过JVM规范并没有给出限制,不同的虚拟机根据自己的需求存放这个对象。</p>
<p>HotSpot将Class对象存放在方法区。</p>
<ul>
<li><strong>加载阶段和链接阶段是交叉的</strong></li>
</ul>
<p>类加载的过程中每个步骤的开始顺序都有严格限制,但每个步骤的结束顺序没有限制。也就是说,类加载过程中,必须按照如下顺序开始:</p>
<blockquote>
<p>加载 -&gt; 链接 -&gt; 初始化</p>
</blockquote>
<p>但结束顺序无所谓,因此由于每个步骤处理时间的长短不一就会导致有些步骤会出现交叉</p>
<hr />
<p><strong>验证</strong></p>
<p>验证阶段比较耗时,它非常重要但不一定必要(因为对程序运行期没有影响)<strong>,如果所运行的代码已经被反复使用和验证过,那么可以使用参数关闭,以缩短类加载时间</strong></p>
<pre><code class="highlight plaintext">-Xverify:none</code></pre>
<ul>
<li><strong>验证的目的</strong></li>
</ul>
<p>保证二进制字节流中的信息符合虚拟机规范,并没有安全问题</p>
<ul>
<li><strong>验证的必要性</strong></li>
</ul>
<p>虽然Java语言是一门安全的语言,它能确保程序猿无法访问数组边界以外的内存、避免让一个对象转换成任意类型、避免跳转到不存在的代码行.也就是说,Java语言的安全性是通过编译器来保证的.</p>
<p>但是我们知道,编译器和虚拟机是两个独立的东西,虚拟机只认二进制字节流,它不会管所获得的二进制字节流是哪来的，当然，如果是编译器给它的，那么就相对安全，但如果是从其它途径获得的，那么无法确保该二进制字节流是安全的。</p>
<p>通过上文可知，虚拟机规范中没有限制二进制字节流的来源，在字节码层面上,上述Java代码无法做到的都是可以实现的,至少语义上是可以表达出来的,为了防止字节流中有安全问题，需要验证！</p>
<ul>
<li>
<p><strong>验证的过程</strong></p>
</li>
<li>
<p><strong>文件格式验证</strong></p>
</li>
</ul>
<p>验证字节流是否符合Class文件格式的规范,并且能被当前的虚拟机处理.</p>
<p>本验证阶段是基于二进制字节流进行的,<strong>只有通过本阶段验证,才被允许存到方法区</strong></p>
<p>后面的三个验证阶段都是基于方法区的存储结构进行,不会再直接操作字节流</p>
<p>印证【加载和验证】是交叉进行的：</p>
<ol>
<li>加载开始前，二进制字节流还没进方法区，而加载完成后，二进制字节流已经存入方法区</li>
<li>而在文件格式验证前，二进制字节流尚未进入方法区，文件格式验证通过之后才进入方法区，也就是说，加载开始后，立即启动了文件格式验证，本阶段验证通过后，二进制字节流被转换成特定数据结构存储至方法区中，继而开始下阶段的验证和创建Class对象等操作</li>
</ol>
<ul>
<li><strong>元数据验证</strong></li>
</ul>
<p>对字节码描述信息进行语义分析,确保符合Java语法规范</p>
<ul>
<li><strong>字节码验证</strong></li>
</ul>
<p>本阶段是验证过程的最复杂的一个阶段。</p>
<p>本阶段对方法体进行语义分析,保证方法在运行时不会出现危害虚拟机的事件。</p>
<p>字节码验证将对类的方法进行校验分析，保证被校验的方法在运行时不会做出危害虚拟机的事，一个类方法体的字节码没有通过字节码验证，那一定有问题，但若一个方法通过了验证，也不能说明它一定安全</p>
<ul>
<li><strong>符号引用验证</strong></li>
</ul>
<p>发生在JVM将符号引用转化为直接引用的时候,这个转化动作发生在解析阶段,对类自身以外的信息进行匹配校验,确保解析能正常执行</p>
<hr />
<p><strong>准备</strong></p>
<p>仅仅为类变量（即static修饰的字段变量）分配内存并且设置该类变量的初始值即零值，这里不包含用final修饰的static，因为final在编译的时候就会分配了（编译器的优化），同时这里也不会为实例变量分配初始化。类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</p>
<p>准备阶段主要完成两件事情：</p>
<ul>
<li>为已在方法区中的类的静态成员变量分配内存</li>
<li>为静态成员变量设置初始值，初始值为0、false、null等</li>
</ul>
<p>比如：</p>
<pre><code class="highlight plaintext">public static int x = 1000;</code></pre>
<blockquote>
<p>实际上变量x在准备阶段过后的初始值为0而不是1000</p>
</blockquote>
<blockquote>
<p>将x赋值为1000的putstatic指令是程序被编译后，存放于类构造器<client>方法之中</p>
</blockquote>
<p>但是如果声明为</p>
<pre><code class="highlight plaintext">public static final int x = 1000;</code></pre>
<blockquote>
<p>在编译阶段会为x生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将x赋值为1000</p>
</blockquote>
<hr />
<p><strong>解析</strong></p>
<p>解析是虚拟机将常量池的符号引用替换为直接引用的过程</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info 、CONSTANT_Fieldref_info 、CONSTANT_Methodref_info 、CONSTANT_InterfaceMethodref_info 四种常量类型</p>
<ol>
<li><strong>类或接口的解析</strong>：</li>
</ol>
<p>判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。</p>
<ol>
<li><strong>字段解析</strong>：</li>
</ol>
<p>对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束(优先从接口来，然后是继承的父类.理论上是按照上述顺序进行搜索解析，但在实际应用中，虚拟机的编译器实现可能要比上述规范要求的更严格一些。如果有一个同名字段同时出现在该类的接口和父类中，或同时在自己或父类的接口中出现，编译器可能会拒绝编译）.</p>
<ol>
<li><strong>类方法解析</strong>：</li>
</ol>
<p>对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。</p>
<ol>
<li><strong>接口方法解析</strong>：</li>
</ol>
<p>与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行了。</p>
<hr />
<p><strong>初始化</strong></p>
<p>初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码(初始化成为代码设定的默认值)。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源</p>
<p>其实初始化过程就是调用类初始化方法的过程，完成<strong>对static修饰的类变量的手动赋值</strong>还有<strong>主动调用静态代码块</strong>。</p>
<p><strong>初始化过程的注意点</strong></p>
<ul>
<li>方法是编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的,编译器收集的顺序是由语句在源文件中出现的顺序所决定的.</li>
<li>静态代码块只能访问到出现在静态代码块之前的变量,定义在它之后的变量,在前面的静态语句块可以赋值,但是不能访问.</li>
</ul>
<pre><code class="highlight plaintext">public class Test &#123;
    static &#123;
        i=0;
        System.out.println(i);//编译失败:&quot;非法向前引用&quot;
    &#125;
    static int i = 1;
&#125;
</code></pre>
<ul>
<li>实例构造器需要显式调用父类构造函数,而类的不需要调用父类的类构造函数,虚拟机会确保子类的方法执行前已经执行完毕父类的方法.因此在JVM中第一个被执行的方法的类肯定是java.lang.Object.</li>
<li>如果一个类/接口中没有静态代码块,也没有静态成员变量的赋值操作,那么编译器就不会为此类生成方法.</li>
<li>接口也需要通过方法为接口中定义的静态成员变量显示初始化。接口中不能使用静态代码块,但仍然有变量初始化的赋值操作,因此接口与类一样都会生成方法.不同的是,执行接口的方法不需要先执行父接口的方法.只有当父接口中的静态成员变量被使用到时才会执行父接口的方法.</li>
<li>虚拟机会保证在多线程环境中一个类的方法别正确地加锁,同步.当多条线程同时去初始化一个类时，只会有一个线程去执行该类的方法,其它线程都被阻塞等待,直到活动线程执行方法完毕.其他线程虽会被阻塞,只要有一个方法执行完,其它线程唤醒后不会再进入方法.<strong>同一个类加载器下,一个类型只会初始化一次</strong>.</li>
</ul>
<p><strong>使用静态内部类的单例实现：</strong></p>
<pre><code class="highlight plaintext">public class Student &#123;
	private Student() &#123;&#125;
	/*
	* 此处使用一个内部类来维护单例 JVM在类加载的时候，是互斥的，所以可以由此保证线
	程安全问题
	*/
	private static class SingletonFactory &#123;
		private static Student student = new Student();
	&#125;
	/* 获取实例 */
	public static Student getSingletonInstance() &#123;
		return SingletonFactory.student;
	&#125;
&#125;</code></pre>
<h3 id="类加载的时机"><a class="markdownIt-Anchor" href="#类加载的时机"></a> 类加载的时机</h3>
<p>什么时候开始加载，虚拟机规范并没有强制性的约束，对于其它大部分阶段究竟何时开始虚拟机规范也都没有进行规范，这些都是交由虚拟机的具体实现来把握。所以不同的虚拟机它们开始的时机可能是不同的。但是对于初始化却严格的规定了有且只有四种情况必须先对类进行“初始化”(加载，验证，准备自然需要在初始化之前完成)：</p>
<ol>
<li>遇到new 、getstatic 、putstatic 和invokestatic 这四条指令时，如果对应的类没有初始化，则要对对应的类先进行初始化。</li>
</ol>
<ul>
<li>这四个指令对应到我们java代码中的场景分别是：
<ul>
<li>new关键字实例化对象的时候；</li>
<li>读取或设置一个类的静态字段（读取被final修饰，已在编译器把结果放入常量池的静态字段除外） ；</li>
<li>调用类的静态方法时。</li>
</ul>
</li>
</ul>
<ol>
<li>使用java.lang.reflect 包方法时对类进行反射调用的时候。</li>
<li>初始化一个类的时候发现其父类还没初始化，要先初始化其父类。</li>
<li>当虚拟机开始启动时，用户需要指定一个主类，虚拟机会先执行这个主类的初始化</li>
</ol>
<h3 id="类加载器"><a class="markdownIt-Anchor" href="#类加载器"></a> 类加载器</h3>
<p><strong>启动类加载器</strong>(Bootstrap ClassLoader)：</p>
<ul>
<li>负责加载 JAVA_HOME\lib 目录中的，</li>
<li>或通过-Xbootclasspath参数指定路径中的，</li>
<li>且被虚拟机认可（按文件名识别，如rt.jar）的类。</li>
<li>由C++实现，不是ClassLoader子类</li>
</ul>
<p><strong>扩展类加载器</strong>(Extension ClassLoader)：</p>
<ul>
<li>负责加载 JAVA_HOME\lib\ext 目录中的，</li>
<li>或通过java.ext.dirs系统变量指定路径中的类库。</li>
</ul>
<p><strong>应用程序类加载器</strong>(Application ClassLoader)：</p>
<ul>
<li>负责加载用户路径（classpath）上的类</li>
</ul>
<p><strong>JVM的类加载是通过ClassLoader及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：</strong></p>
<p>加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</p>
<h3 id="自定义类加载器"><a class="markdownIt-Anchor" href="#自定义类加载器"></a> 自定义类加载器</h3>
<p><strong>自定义类加载器步骤</strong></p>
<ul>
<li>继承ClassLoader</li>
<li>重写findClass（）方法</li>
<li>调用defineClass（）方法</li>
</ul>
<p><strong>实践</strong></p>
<p>下面写一个自定义类加载器：指定类加载路径在D盘下的lib文件夹下。</p>
<p>（1）在本地磁盘新建一个Test.java 类，代码如下：</p>
<pre><code class="highlight plaintext">package jvm.classloader;
public class Test &#123;
    public void say()&#123;
        System.out.println(&quot;Hello MyClassLoader&quot;);
    &#125;
&#125;</code></pre>
<p>（2）使用javac -d . Test.java 命令，将生成的Test.class 文件放到D:/lib/jvm/classloader文件夹下</p>
<p>（3）在Eclipse中自定义类加载器，代码如下：</p>
<pre><code class="highlight plaintext">package com.lee.configserver;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;

public class MyClassLoader extends ClassLoader &#123;
    private String classpath;

    public MyClassLoader(String classpath) &#123;
        this.classpath = classpath;
    &#125;

    @Override
    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;
        try &#123;
            byte[] classDate = getData(name);
            if (classDate == null) &#123;
            &#125; else &#123;
//defineClass方法将字节码转化为类
                return defineClass(name, classDate, 0, classDate.length);
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        return super.findClass(name);
    &#125;

    //返回类的字节码
    private byte[] getData(String className) throws IOException &#123;
        InputStream in = null;
        ByteArrayOutputStream out = null;
        String path = classpath + File.separatorChar +
                className.replace(&#x27;.&#x27;, File.separatorChar) + &quot;.class&quot;;
        try &#123;
            in = new FileInputStream(path);
            out = new ByteArrayOutputStream();
            byte[] buffer = new byte[2048];
            int len = 0;
            while ((len = in.read(buffer)) != -1) &#123;
                out.write(buffer, 0, len);
            &#125;
            return out.toByteArray();
        &#125; catch (FileNotFoundException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            in.close();
            out.close();
        &#125;
        return null;
    &#125;
&#125;</code></pre>
<p>测试运行：</p>
<pre><code class="highlight plaintext">package com.lee.configserver;

import java.lang.reflect.Method;

public class TestMyClassLoader &#123;
    public static void main(String[] args) throws Exception &#123;
        //自定义类加载器的加载路径
        MyClassLoader myClassLoader = new MyClassLoader(&quot;D:\\lib&quot;);
        //包名+类名
        Class c = myClassLoader.loadClass(&quot;jvm.classloader.Test&quot;);
        if (c != null) &#123;
            Object obj = c.newInstance();
            Method method = c.getMethod(&quot;say&quot;, null);
            method.invoke(obj, null);
            System.out.println(c.getClassLoader().toString());
        &#125;
    &#125;
&#125;</code></pre>
<p><strong>自定义类加载器的作用：</strong></p>
<p>JVM自带的三个加载器只能加载指定路径下的类字节码。</p>
<p>如果某个情况下，我们需要加载应用程序之外的类文件呢？比如本地D盘下的，或者去加载网络上的某个类文件，这种情况就可以使用自定义加载器了</p>
<h3 id="双亲委派模型"><a class="markdownIt-Anchor" href="#双亲委派模型"></a> 双亲委派模型</h3>
<p>JVM通过双亲委派模型进行类的加载，当然我们也可以通过继承java.lang.ClassLoader实现自定义的类加载器。</p>
<ul>
<li>当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，</li>
<li>只有当父类加载器无法完成加载任务时，才会尝试执行加载任务。</li>
</ul>
<p>采用双亲委派的一个好处是：</p>
<ul>
<li>比如加载位于rt.jar包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个Object对象。</li>
</ul>
<p><strong>为什么要使用双亲委托这种模型呢？</strong></p>
<p>因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。</p>
<p>考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，<strong>因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法</strong></p>
<hr />
<p><strong>但是JVM在搜索类的时候，又是如何判定两个class是相同的呢？</strong></p>
<p>JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。</p>
<p>只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class</p>
<p><strong>既然JVM已经提供了默认的类加载器，为什么还要定义自已的类加载器呢？</strong></p>
<p>因为Java中提供的默认ClassLoader，只加载指定目录下的jar和class，如果我们想加载其它位置的类或jar时。</p>
<p>比如：我要加载网络上的一个class文件，通过动态加载到内存之后，要调用这个类中的方法实现我的业务逻辑。在这样的情况下，默认的ClassLoader就不能满足我们的需求了，所以需要定义自己的ClassLoader</p>
<h3 id="破坏双亲委派模型"><a class="markdownIt-Anchor" href="#破坏双亲委派模型"></a> 破坏双亲委派模型</h3>
<p>因为在某些情况下父类加载器需要委托子类加载器去加载class文件（双亲委派模式的话，是子类委托父类加载器去加载class文件）。因为受到加载范围的限制，父类加载器无法加载到需要的文件。</p>
<p>以Driver接口为例，由于Driver接口定义在jdk当中的，而其实现由各个数据库的服务商来提供，比如mysql的就写了MySQL Connector ，那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接口的实现类，然后进行管理，但是DriverManager由启动类加载器加载，只能记载JAVA_HOME的lib下文件，而其实现是由服务商提供的，由系统类加载器加载，这个时候就需要启动类加载器来委托子类来加载Driver实现，从而破坏了双亲委派，这里仅仅是举了破坏双亲委派的其中一个情况。</p>
<pre><code class="highlight plaintext">package com.lee.configserver;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import org.junit.Test;

public class TestJdbc &#123;
    @Test
    public void testJdbc() &#123;
        Connection connection = null;
        PreparedStatement preparedStatement = null;
        ResultSet rs = null;
        try &#123;
            // 加载数据库驱动
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            // 通过驱动管理类获取数据库链接connection = DriverManager
            connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/ssm?characterEncoding=utf-8&quot;, &quot; root&quot;, &quot;root&quot;);
            // 定义sql语句 ?表示占位符
            String sql = &quot;select * from user where id = ?&quot;;
            // 获取预处理 statement
            preparedStatement = connection.prepareStatement(sql);
            // 设置参数，第一个参数为 sql 语句中参数的序号（从 1 开始），第二个参数为
            preparedStatement.setInt(1, 1);
            // 向数据库发出 sql 执行查询，查询出结果集
            rs = preparedStatement.executeQuery();
            // 遍历查询结果集
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
// 释放资源
            if (rs != null) &#123;
                try &#123;
                    rs.close();
                &#125; catch (SQLException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            if (preparedStatement != null) &#123;
                try &#123;
                    preparedStatement.close();
                &#125; catch (SQLException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            if (connection != null) &#123;
                try &#123;
                    connection.close();
                &#125; catch (SQLException e) &#123;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<h2 id="运行时数据区"><a class="markdownIt-Anchor" href="#运行时数据区"></a> 运行时数据区</h2>
<ul>
<li>方法区：最重要的内存区域，多线程共享，保存了类的信息（名称，成员，接口，父类），反射机制时重要的组成部分，动态进行类操作的实现；</li>
<li><strong>堆内存</strong>（Heap）:保存对象的真实信息，该内存牵扯到释放问题（GC）</li>
<li><strong>栈内存</strong>（Stack）:线程的私有空间，在每一次进行方法调用的时候都会存在有栈帧，采用先进后出的设计原则
<ul>
<li>本地变量表：局部参数或者形参，允许保存有32位的插槽（Salt）,如果超过了32位的长度就需要开辟两个连续性的插槽（long，double）</li>
<li>操作数栈：执行所有得方法计算操作</li>
<li>常量长引用：String类型，Integer类示例</li>
<li>返回地址：方法执行完毕后的恢复执行的点</li>
</ul>
</li>
<li>程序计数器：执行指令的一个顺序编码，该区域的所占比例几乎可以忽略</li>
<li>本地方法栈：与栈内存的功能类似，区别在于是为本地方法服务的</li>
</ul>
<h3 id="程序计数器"><a class="markdownIt-Anchor" href="#程序计数器"></a> 程序计数器</h3>
<p><strong>程序计数器</strong>（Program Counter Register），也叫<strong>PC寄存器</strong>，是一块较小的内存空间，它可以看作是当前线程所执行的字节码指令的行号指示器。字节码解释器的工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支，循环，跳转，异常处理，线程回复等都需要依赖这个计数器来完成。</p>
<p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（针对多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，<strong>每条线程都需要有一个独立的程序计数器</strong>，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>如果一个线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；</p>
<p>如果正在执行的是一个Native方法，这个计数器的值则为空。</p>
<p>此内存区域是唯一一个在Java的虚拟机规范中没有规定任何OutOfMemoryError异常情况的区域</p>
<h3 id="java虚拟机栈"><a class="markdownIt-Anchor" href="#java虚拟机栈"></a> Java虚拟机栈</h3>
<p>虚拟机栈也是线程私有，而且生命周期与线程相同，每个Java方法在执行的时候都会创建一个栈帧（Stack Frame）</p>
<h4 id="栈帧"><a class="markdownIt-Anchor" href="#栈帧"></a> 栈帧</h4>
<p><strong>栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用至执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程</strong>。</p>
<p>栈帧溢出：</p>
<pre><code class="highlight plaintext">package com.lee.configserver;

public class testMain &#123;
    public static void main(String[] args) &#123;
        fun();
    &#125;

    public static void fun() &#123;
        fun();//死循环
    &#125;
&#125;</code></pre>
<p>输出：</p>
<p>一个线程中方法的调用链可能会很长，很多方法都同时处于执行状态。对于JVM执行引擎来说，在在活动线程中，只有位于JVM虚拟机栈<strong>栈顶</strong>的元素才是有效的，即称为当前栈帧，与这个栈帧相关连的方法称为<strong>当前方法</strong>，定义这个方法的类叫做当前类。</p>
<p>执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。如果当前方法调用了其他方法，或者当前方法执行结束，那这个方法的栈帧就不再是当前栈帧了。</p>
<p>调用新的方法时，新的栈帧也会随之创建。并且随着程序控制权转移到新方法，新的栈帧成为了当前栈帧。方法返回之际，原栈帧会返回方法的执行结果给之前的栈帧(返回给方法调用者)，随后虚拟机将会丢弃此栈帧。</p>
<p>关于「栈帧」，我们在看看《Java虚拟机规范》中的描述：</p>
<blockquote>
<p>栈帧是用来存储数据和部分过程结果的数据结构，同时也用来处理动态连接、方法返回值和异常分派。</p>
</blockquote>
<blockquote>
<p>栈帧随着方法调用而创建，随着方法结束而销毁——无论方法正常完成还是异常完成都算作方法结束。</p>
</blockquote>
<blockquote>
<p>栈帧的存储空间由创建它的线程分配在Java虚拟机栈之中，每一个栈帧都有自己的本地变量表(局部变量表)、操作数栈和指向当前方法所属的类的运行时常量池的引用</p>
</blockquote>
<p>接下来，详细讲解一下栈帧中的局部变量表、操作数栈、动态连接、方法返回地址等各个部分的数据结构和作用。</p>
<h4 id="局部变量表"><a class="markdownIt-Anchor" href="#局部变量表"></a> 局部变量表</h4>
<p><strong>局部变量表</strong>(Local Variable Table)是一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。局部变量表的容量以变量槽(Variable Slot)为最小单位，Java虚拟机规范并没有定义一个槽所应该占用内存空间的大小，但是规定了一个槽应该可以存放一个32位以内的数据类型</p>
<blockquote>
<p>在Java程序编译为Class文件时,就在方法的Code属性中的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。(最大Slot数量)</p>
</blockquote>
<p>一个局部变量可以保存一个类型为boolean、byte、char、short、int、float、reference和returnAddress类型的数据。reference类型表示对一个对象实例的引用。returnAddress类型是为jsr、jsr_w和ret指令服务的，目前已经很少使用了</p>
<p>虚拟机通过索引定位的方法查找相应的局部变量，索引的范围是从0~局部变量表最大容量。如果Slot是32位的，则遇到一个64位数据类型的变量(如long或double型)，则会连续使用两个连续的Slot来存储</p>
<h4 id="操作数栈"><a class="markdownIt-Anchor" href="#操作数栈"></a> 操作数栈</h4>
<p><strong>操作数栈</strong>(Operand Stack)也常称为操作栈，它是一个后入先出栈(LIFO)。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到方法的Code属性的max_stacks数据项中。</p>
<p>操作数栈的每一个元素可以是任意Java数据类型，32位的数据类型占一个栈容量，64位的数据类型占2个栈容量,且在方法执行的任意时刻，操作数栈的深度都不会超过max_stacks中设置的最大值。</p>
<p>当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。</p>
<h4 id="动态连接"><a class="markdownIt-Anchor" href="#动态连接"></a> 动态连接</h4>
<p>在一个class文件中，一个方法要调用其他方法，需要将这些方法的<strong>符号引用</strong>转化为其在内存地址中的<strong>直接引用</strong>，而符号引用存在于方法区中的运行时常量池。</p>
<p>Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的<strong>动态连接</strong>(Dynamic Linking)。</p>
<p>这些符号引用一部分会在类加载阶段或者第一次使用时就直接转化为直接引用，这类转化称为静态解析。另一部分将在每次运行期间转化为直接引用，这类转化称为动态连接。</p>
<h4 id="方法返回"><a class="markdownIt-Anchor" href="#方法返回"></a> 方法返回</h4>
<p><strong>当一个方法开始执行时，可能有两种方式退出该方法</strong>：</p>
<ul>
<li>正常完成出口</li>
<li>异常完成出口</li>
</ul>
<p><strong>正常完成出口</strong>是指方法正常完成并退出，没有抛出任何异常(包括Java虚拟机异常以及执行时通过throw语句显示抛出的异常)。如果当前方法正常完成，则根据当前方法返回的字节码指令，这时有可能会有返回值传递给方法调用者(调用它的方法)，或者无返回值。具体是否有返回值以及返回值的数据类型将根据该方法返回的字节码指令确定</p>
<p><strong>异常完成出口</strong>是指方法执行过程中遇到异常，并且这个异常在方法体内部没有得到处理，导致方法退出。</p>
<blockquote>
<p>无论是Java虚拟机抛出的异常还是代码中使用athrow指令产生的异常，只要在本方法的异常表中没有搜索到相应的异常处理器，就会导致方法退出</p>
</blockquote>
<p>无论方法采用何种方式退出，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在当前栈帧中保存一些信息，用来帮他恢复它的上层方法执行状态</p>
<blockquote>
<p>方法退出过程实际上就等同于把当前栈帧出栈，因此退出可以执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压如调用者的操作数栈中，调整PC计数器的值以指向方法调用指令后的下一条指令</p>
</blockquote>
<p>一般来说，方法正常退出时，调用者的PC计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过异常处理器表确定的，栈帧中一般不会保存此部分信息</p>
<h4 id="附加信息栈异常"><a class="markdownIt-Anchor" href="#附加信息栈异常"></a> 附加信息/栈异常</h4>
<p><strong>附加信息</strong></p>
<p>虚拟机规范允许具体的虚拟机实现增加一些规范中没有描述的信息到栈帧之中，例如和调试相关的信息，这部分信息完全取决于不同的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其</p>
<p>他附加信息一起归为一类，称为栈帧信息</p>
<p><strong>栈异常</strong></p>
<p>Java虚拟机规范中，对该区域规定了这两种异常情况：</p>
<ol>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出StackOverflowError异常；</li>
<li>虚拟机栈可以动态拓展，当扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常</li>
</ol>
<h3 id="本地方法栈"><a class="markdownIt-Anchor" href="#本地方法栈"></a> 本地方法栈</h3>
<p>本地方法栈和虚拟机栈相似，区别就是虚拟机栈为虚拟机执行<strong>Java服务（字节码服务）</strong>，而本地方法栈为虚拟机使用到的<strong>Native方法（比如C++方法）服务</strong></p>
<h4 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h4>
<p>简单地讲，一个Native Method就是一个java调用非java代码的接口</p>
<pre><code class="highlight plaintext">&quot;A native method is a Java method whose implementation is provided by nonjava code.&quot;</code></pre>
<p>一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C</p>
<p>在定义一个native method时，并不提供实现体（有些像定义一个java interface），因为其实现体是由非java语言在外面实现的。，下面给了一个示例：</p>
<pre><code class="highlight plaintext">public class IHaveNatives
&#123;
    native public void Native1( int x ) ;
    native static public long Native2() ;
    native synchronized private float Native3( Object o ) ;
    native void Native4( int[] ary ) throws Exception ;
&#125;</code></pre>
<p>这些方法的声明描述了一些非java代码在这些java代码里看起来像什么样子</p>
<p><strong>标识符native可以与所有其它的java标识符连用，但是abstract除外</strong>。这是合理的，因为native暗示这些方法是有实现体的，只不过这些实现体是非java的，但是abstract却显然的指明这些方法无实现体。</p>
<p><strong>native与其它java标识符连用时，其意义同非Native Method并无差别</strong>，比如native static表明这个方法可以在不产生类的实例时直接调用，这非常方便，比如当你想用一个native method去调用一个C的类库时。上面的第三个方法用到了native synchronized，JVM在进入这个方法的实现体之前会执行同步锁机制（就像java的多线程。）</p>
<p><strong>一个native method方法可以返回任何java类型</strong>，<strong>包括非基本类型，而且同样可以进行异常控制</strong>。这些方法的实现体可以制一个异常并且将其抛出，这一点与java的方法非常相似。</p>
<p><strong>当一个native method接收到一些非基本类型时如Object或一个整型数组时，这个方法可以访问这些非基本型的内部，但是这将使这个native方法依赖于你所访问的java类的实现</strong>。有一点要牢牢记住：我们可以在一个native method的本地实现中访问所有的java特性，但是这要依赖于你所访问的java特性的实现，而且这样做远远不如在java语言中使用那些特性方便和容易</p>
<p><strong>native method的存在并不会对其他类调用这些本地方法产生任何影响，实际上调用这些方法的其他类甚至不知道它所调用的是一个本地方法。JVM将控制调用本地方法的所有细节</strong>。需要注意当我们将一个本地方法声明为final的情况。用java实现的方法体在被编译时可能会因为内联而产生效率上的提升。但是一个native final方法是否也能获得这样的好处却是值得怀疑的，但是这只是一个代码优化方面的问题，对功能实现没有影响</p>
<p><strong>如果一个含有本地方法的类被继承，子类会继承这个本地方法并且可以用java语言重写这个方法（这个似乎看起来有些奇怪），同样的如果一个本地方法被fianl标识，它被继承后不能被重写</strong>。</p>
<p><strong>本地方法非常有用，因为它有效地扩充了jvm</strong>。事实上，我们所写的java代码已经用到了本地方法，在sun的java的并发（多线程）的机制实现中，许多与操作系统的接触点都用到了本地方法，这使得java程序能够超越java运行时的界限。有了本地方法，java程序可以做任何应用层次的任务</p>
<hr />
<p><strong>为什么要用本地方法？</strong></p>
<p>java使用起来非常方便，然而有些层次的任务用java实现起来不容易，或者我们对程序的效率很在意时，问题就来了</p>
<p><strong>有时java应用需要与java外面的环境交互。这是本地方法存在的主要原因，你可以想想java需要与一些底层系统如操作系统或某些硬件交换信息时的情况</strong>。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐的细节</p>
<p>JVM支持着java语言本身和运行时库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎 样，它毕竟不是一个完整的系统，它经常依赖于一些底层（underneath在下面的）系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的，还有，如果我们要使用一些java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法</p>
<hr />
<p><strong>JVM怎样使本地方法跑起来</strong></p>
<p>我们知道，当一个类第一次被使用到时，这个类的字节码会被加载到内存，并且只会回载一次。在这个被加载的字节码的入口维持着一个该类所有方法描述符的list，这些方法描述符包含这样一些信息：方法代码存于何处，它有哪些参数，方法的描述符（public之类）等等。</p>
<p>如果一个方法描述符内有native，这个描述符块将有一个指向该方法的实现的指针。这些实现在一些DLL文件内，但是它们会被操作系统加载到java程序的地址空间。当一个带有本地方法的类被加载时，其相关的DLL并未被加载，因此指向方法实现的指针并不会被设置。当本地方法被调用之前，这些DLL才会被加载，这是通过调用java.system.loadLibrary()实现的。</p>
<p>最后需要提示的是，使用本地方法是有开销的，它丧失了java的很多好处。如果别无选择，我们可以选择使用本地方法。</p>
<h4 id="使用流程"><a class="markdownIt-Anchor" href="#使用流程"></a> 使用流程</h4>
<p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。本地方法可以通过本地方法接口来访问虚拟机的运行时数据区，但不止如此，它还可以做任何它想做的事情。</p>
<p>本地方法本质上时依赖于实现的，虚拟机实现的设计者们可以自由地决定使用怎样的机制来让Java程序调用本地方法。</p>
<p>任何本地方法接口都会使用某种本地方法栈。当线程调用Java方法时，虚拟机会创建一个新的栈帧并压入Java栈。<strong>然而当它调用的是本地方法时，虚拟机会保持Java栈不变，不再在线程的Java栈中压入新的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法</strong>。</p>
<p>如果某个虚拟机实现的本地方法接口是使用C连接模型的话，那么它的本地方法栈就是C栈。当C程序调用一个C函数时，其栈操作都是确定的。传递给该函数的参数以某个确定的顺序压入栈，它的返回值也以确定的方式传回调用者。同样，这就是虚拟机实现中本地方法栈的行为。</p>
<p>很可能本地方法接口需要回调Java虚拟机中的Java方法，在这种情况下，该线程会保存本地方法栈的状态并进入到另一个Java栈</p>
<hr />
<p><strong>下图描绘了这样一个情景，就是当一个线程调用一个本地方法时，本地方法又回调虚拟机中的另一个Java方法</strong></p>
<p>这幅图展示了JAVA虚拟机内部线程运行的全景图。一个线程可能在整个生命周期中都执行Java方法，操作它的Java栈；或者它可能毫无障碍地在Java栈和本地方法栈之间跳转</p>
<p>该线程首先调用了两个Java方法，而第二个Java方法又调用了一个本地方法，这样导致虚拟机使用了一个本地方法栈。假设这是一个C语言栈，其间有两个C函数，第一个C函数被第二个Java方法当做本地方法调用，而这个C函数又调用了第二个C函数。之后第二个C函数又通过本地方法接口回调了一个Java方法（第三个Java方法），最终这个Java方法又调用了一个Java方法（它成为图中的当前方法</p>
<h3 id="java内存模型"><a class="markdownIt-Anchor" href="#java内存模型"></a> Java内存模型</h3>
<p>合理的内存模型可以使GC的性能更加强大，不必太大的浪费服务器的性能，从而减少阻塞所带来的程序的性能影响</p>
<ul>
<li>例：你现在收拾屋子，基本上我们会有两类收拾方法
<ul>
<li>方式一：简单的进行物品的码放以及打扫卫生，时间短</li>
<li>方式二：房屋装修与改造，时间长</li>
</ul>
</li>
</ul>
<p>Java中数据报错的内存位置：堆内存（调优，原理）：</p>
<ul>
<li>最需要强调的就是JDK1.8之后所带来的内存结构改变以及GC策略提升</li>
</ul>
<p><strong>jdk1.8之前</strong></p>
<p><strong>jdk1.8之后</strong></p>
<ul>
<li>当内存不足的时候需要堆伸缩区进行控制，当内存充足的时候就要考虑将伸缩区的内存释放掉，来回的计算伸缩必会造成额外的计算机性能的影响，导致程序的整体性能下降</li>
</ul>
<p><strong>用RunTime类获取当前运行环境的最大内存和最小内存</strong></p>
<p>RunTime类常用方法：</p>
<ul>
<li>getRuntime()：该方法用于返回当前应用程序的运行环境对象</li>
<li>exec(String command)：该方法用于根据指定的路径执行对应的可执行文件。</li>
<li>freeMemory()：该方法用于返回Java虚拟机中的空闲内存量，以字节为单位。</li>
<li>maxMemory()：该方法用于返回Java虚拟机试图使用的最大内存量</li>
<li>totalMemory()：该方法用于返回Java虚拟机中的内存总量。</li>
</ul>
<pre><code class="highlight plaintext">package com.lee.configserver;

public class testMain &#123;
    public static void main(String[] args) &#123;
        //RunTime类主要代表了应用程序的运行环境。一个RunTime就代表一个运行环境
        System.out.println(&quot;MAX_MEMORY:&quot;+byteToM(Runtime.getRuntime().maxMemory())+&quot;M&quot;);
        System.out.println(&quot;TOTAL_MEMORY:&quot;+byteToM(Runtime.getRuntime().totalMemory())+&quot;M&quot;);
    &#125;

    public static double round(double num,int scale)&#123;
        //Math.pow求次方
        //Math.round取整
        return Math.round(Math.pow(10, scale) * num) / Math.pow(10, scale);
    &#125;
    public static double byteToM(long num)&#123;
        return round(num/1024/1024,2);
    &#125;
&#125;</code></pre>
<blockquote>
<p>我先自的内存为8G，所以会发现默认的内容：</p>
<p>MaxMemory：整体电脑内存的1/4</p>
<p>TotalMemory：整体电脑内存的1/64</p>
</blockquote>
<blockquote>
<p>伸缩区的空间：MaxMemory - TotalMemory = 可变的伸缩区空间极大</p>
</blockquote>
<h3 id="jvm调优"><a class="markdownIt-Anchor" href="#jvm调优"></a> JVM调优</h3>
<p>JVM可以调优的点重要的就是这三点:</p>
<ul>
<li>取消伸缩区</li>
<li>GC执行分析（算法）</li>
<li>垃圾回收策略</li>
</ul>
<h4 id="取消伸缩区"><a class="markdownIt-Anchor" href="#取消伸缩区"></a> 取消伸缩区</h4>
<p><strong>当伸缩区空间较小的时候那么JVM的性能必然会得到提升</strong></p>
<p>所以我们程序执行的设置有相应的执行参数：</p>
<ul>
<li><code>-Xmx</code>：分配最大的初始化内存</li>
<li><code>-Xms</code>：最大的分配内存</li>
</ul>
<p>执行jar程序的时候就可以加执行参数：</p>
<pre><code class="highlight plaintext">java -Xmx大小单位 -Xms大小单位 类文件

示例：
java -Xmx1000M -Xms3G</code></pre>
<p>示例：</p>
<p>现在idea中设置jvm启动参数：</p>
<p>然后执行程序：</p>
<pre><code class="highlight plaintext">package com.lee.configserver;

public class testMain &#123;
    public static void main(String[] args) &#123;
        //RunTime类主要代表了应用程序的运行环境。一个RunTime就代表一个运行环境
        System.out.println(&quot;MAX_MEMORY:&quot;+byteToM(Runtime.getRuntime().maxMemory())+&quot;M&quot;);
        System.out.println(&quot;TOTAL_MEMORY:&quot;+byteToM(Runtime.getRuntime().totalMemory())+&quot;M&quot;);
    &#125;

    public static double round(double num,int scale)&#123;
        //Math.pow求次方
        //Math.round取整
        return Math.round(Math.pow(10, scale) * num) / Math.pow(10, scale);
    &#125;
    public static double byteToM(long num)&#123;
        return round(num/1024/1024,2);
    &#125;
&#125;</code></pre>
<p>结果：</p>
<ul>
<li>我们发现，加了启动参数后，jvm的运行时空间内存发生了改变</li>
</ul>
<h4 id="gc处理流程"><a class="markdownIt-Anchor" href="#gc处理流程"></a> GC处理流程</h4>
<ol>
<li>对象实例化需要依据关键字new完成，所有的新对象都会在伊甸园开辟，如果伊甸园的内存空间不足会发生MinorGc
<ul>
<li>Member mem = new Member(); 很小，直接保存在伊甸园；</li>
</ul>
</li>
<li>伊甸园不是无限大的，所以肯定有些对象执行了N次的MinorGC后还会存在，那么这些对象将进入到存货区（存货区有两个，一个负责保存存活对象，一个负责晋升，永远都有一个空内存）</li>
<li>如果经历过若干次的MinorGC回收处理之后发现空间依然不够使用的，那么则进行老年代的GC回收，执行了一个MajorGC(Full GC，性能很差)，如果可以回收空间，则继续进行MinorGC</li>
<li>如果MajorGC失败，则继续内存已经占满，则抛出OOM异常</li>
<li>如果新创建的对象的空间占用过大将直接保存到老年代之中</li>
</ol>
<p>让内存溢出：</p>
<pre><code class="highlight plaintext">package com.lee.configserver;

public class testMain &#123;
    public static void main(String[] args) &#123;
        String str = &quot;hello&quot;;
        for(int x = 0;x&lt;Integer.MAX_VALUE;x++)&#123;
            //str.intern()返回一个字符串，内容与此字符串相同，但一定取自具有唯一字符串的池
            str += str.intern();
        &#125;
    &#125;
&#125;</code></pre>
<h4 id="查看垃圾回收"><a class="markdownIt-Anchor" href="#查看垃圾回收"></a> 查看垃圾回收</h4>
<pre><code class="highlight plaintext">-Xmx20M -Xms20M -XX:+PrintGCDetails     //JDK1.9之后使用-XX:+PrintGCDetails查看垃圾回收详情

-Xmx2M -Xms2M -Xlog:gc*    //JDK1.9之后使用-Xlog:gc* 查看垃圾回收详情</code></pre>
<blockquote>
<p>JDK1.8的时候默认会根据系统的不同而选择不同的GC回收策略</p>
<p>JDK1.9之后，使用的默认GC操作就是G1</p>
</blockquote>
<p><strong>JDK1.8</strong></p>
<pre><code class="highlight plaintext">package com.lee.configserver;

public class testMain &#123;
    public static void main(String[] args) &#123;
        String str = &quot;hello&quot;;
        for(int x = 0;x&lt;Integer.MAX_VALUE;x++)&#123;
            //str.intern()返回一个字符串，内容与此字符串相同，但一定取自具有唯一字符串的池
            str += str.intern();
        &#125;
    &#125;
&#125;</code></pre>
<p>给上述代码加上启动参数：</p>
<pre><code class="highlight plaintext">-Xmx20M -Xms20M -XX:+PrintGCDetails</code></pre>
<p>输出：</p>
<p><strong>JDK1.9之后</strong></p>
<pre><code class="highlight plaintext">package com.lee.configserver;

public class testMain &#123;
    public static void main(String[] args) &#123;
        String str = &quot;hello&quot;;
        for(int x = 0;x&lt;Integer.MAX_VALUE;x++)&#123;
            //str.intern()返回一个字符串，内容与此字符串相同，但一定取自具有唯一字符串的池
            str += str.intern();
        &#125;
    &#125;
&#125;</code></pre>
<p>给上述代码加上启动参数：</p>
<pre><code class="highlight plaintext">-Xmx2M -Xms2M -Xlog:gc*</code></pre>
<p>运行：</p>
<h4 id="内存回收算法"><a class="markdownIt-Anchor" href="#内存回收算法"></a> 内存回收算法</h4>
<p>年轻代回收算法：</p>
<ul>
<li>“复制”清理算法：将保留的对象复制到存货区之中，存货区的内容或保存到老年代之中</li>
<li>伊甸园区总是会有大量的新对象产生，所以HotSpot虚拟机使用了BTP（单核CPU的试带所有的对象依次保存，相当于队列），TLAB（多核CPU，吧队列拆分为不同的块，依据CPU的核心个数拆分）两种技术形式的处理</li>
</ul>
<p>老年代回收算法：</p>
<ul>
<li>“标记-清除”算法：先进性对象的第一次标记，在这段时间之内会暂停程序的执行（如果标记的时间过程或者对象的内容过多），这个暂停的时间就会长
<ul>
<li>串行GC</li>
<li>并行回收GC</li>
<li>并行GC</li>
</ul>
</li>
<li>“标记-压缩”算法：基于“标记-清除”算法，将零散的内存空间进重新整理在进行分配
<ul>
<li>串行GC</li>
<li>并行回收GC</li>
<li>CMS(挂起)
<ul>
<li>STW(Stop-The-World)设计问题，暂时挂起所有的程序的执行线程，进行无用的对象标记</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>没有任何一项合适的GC回收操作能完美的解决完美回收，从JDK1.8开始提供了G1收集器，在JDK11之后提供了ZGC</p>
</blockquote>
<p><strong>G1算法</strong></p>
<ul>
<li>支持大内存（4G-64G），支持有多CPU，减少STW停顿时间，可以保证并发状态下的程序执行</li>
<li>G1算法实际就是把Java内存给分了一堆块，每一个块都包含完整的老年代，年轻代，都是相对独立的内存空间，所以只是单个块的垃圾回收，那么内存不会特别大，对象也不会特别多，只会影响一小部分用户，其他用户不会受到影响</li>
</ul>
<p>jdk1.8之前可以手动的更改为G1算法回收</p>
<pre><code class="highlight plaintext">-XX:+UseG1GC</code></pre>
<blockquote>
<p>jdk11之后默认就是G1回收器，对于其他的回收算法实际上可以忽略掉</p>
</blockquote>
<h3 id="java堆"><a class="markdownIt-Anchor" href="#java堆"></a> Java堆</h3>
<p>Java堆被所有线程共享，在Java虚拟机启动时创建。是虚拟机管理最大的一块内存。</p>
<p><strong>唯一目的是存放对象实例，Java虚拟机规范的描是：所有的对象实例以及数组都要在堆上分配</strong></p>
<p>随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”</p>
<ul>
<li>内存空间在物理上可以不连续，逻辑上连续即可。</li>
<li>Java堆是垃圾回收的主要区域，主要采用分代回收算法。</li>
<li>堆进一步划分主要是为了更好的回收内存或更快的分配内存</li>
</ul>
<h4 id="堆分类"><a class="markdownIt-Anchor" href="#堆分类"></a> 堆分类</h4>
<p><strong>1.8之前</strong></p>
<ul>
<li>新生代（Eden空间[伊甸园]，From Survivor空间，To Survivor空间）</li>
<li>老年代</li>
<li>永久代</li>
</ul>
<p><strong>1.8之后(含1.8)</strong></p>
<ul>
<li>新生代（Eden空间[伊甸园]，From Survivor空间，To Survivor空间）、</li>
<li>老年代</li>
<li>Meta Space</li>
</ul>
<p>在 JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）</p>
<hr />
<p><strong>堆内存划分：</strong></p>
<ul>
<li>堆大小 = 新生代 + 老年代。堆的大小可通过参数–Xms（堆的初始容量）、-Xmx（堆的最大容量） 来指定。</li>
</ul>
<pre><code class="highlight plaintext">java -Xmx大小单位 -Xms大小单位 类文件

示例：
java -Xmx1000M -Xms3G</code></pre>
<ul>
<li>其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。默认的，Edem : from : to = 8 : 1 : 1 。(可以通过参数 –XX:SurvivorRatio 来设定 。</li>
</ul>
<blockquote>
<p>即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。</p>
</blockquote>
<pre><code class="highlight plaintext">–XX:SurvivorRatio大小单位</code></pre>
<ul>
<li>JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。</li>
<li>新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间</li>
</ul>
<h4 id="对象创建"><a class="markdownIt-Anchor" href="#对象创建"></a> 对象创建</h4>
<pre><code class="highlight plaintext">Student stu = new Student();</code></pre>
<h4 id="内存分配"><a class="markdownIt-Anchor" href="#内存分配"></a> 内存分配</h4>
<p><strong>内存分配原则</strong></p>
<table>
<thead>
<tr>
<th>序号</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>优先在Eden分配,如果Eden空间不足虚拟机则会进行一次MinorGC</td>
</tr>
<tr>
<td>2</td>
<td>大对象直接接入老年代,大对象一般指的是很长的字符串或数组</td>
</tr>
<tr>
<td>3</td>
<td>长期存活的对象进入老年代，每个对象都有一个age，当age到达设定的年龄的时候就会进入老年代，默认是15岁</td>
</tr>
</tbody>
</table>
<p><strong>内存分配</strong></p>
<p>内存分配的方法有两种:指针碰撞(Bump the Pointer)和空闲列表(Free List)</p>
<table>
<thead>
<tr>
<th>分配方法</th>
<th>说明</th>
<th>收集器</th>
</tr>
</thead>
<tbody>
<tr>
<td>指针碰撞</td>
<td>内存地址是连续的</td>
<td>Serial和ParNew收集器</td>
</tr>
<tr>
<td>空闲列表</td>
<td>内存地址不连续</td>
<td>CMS收集器和Mark-Sweep收集器</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>内存分配安全问题</strong></p>
<p>在分配内存的同时，存在线程安全的问题，即虚拟机给A线程分配内存过程中，指针未修改，B线程可能同时使用了同样一块内存。</p>
<p>在JVM中有两种解决办法：</p>
<ol>
<li>**CAS，比较和交换（**Compare And Swap）： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</li>
<li><strong>TLAB，本地线程分配缓冲</strong>(Thread Local Allocation Buffer即TLAB)： 为每一个线程预先分配一块内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配。</li>
</ol>
<h4 id="对象的访问"><a class="markdownIt-Anchor" href="#对象的访问"></a> 对象的访问</h4>
<table>
<thead>
<tr>
<th>方式</th>
<th>优点</th>
</tr>
</thead>
<tbody>
<tr>
<td>句柄</td>
<td>稳定，对象被移动只要修改句柄中的地址</td>
</tr>
<tr>
<td>直接指针</td>
<td>访问速度快，节省了一次指针定位的开销</td>
</tr>
</tbody>
</table>
<h4 id="数组内存分析"><a class="markdownIt-Anchor" href="#数组内存分析"></a> 数组内存分析</h4>
<p><strong>一维数组</strong></p>
<pre><code class="highlight plaintext">int[] arr1 = new int[3];</code></pre>
<p>先把 arr1 压进栈，然后在堆空间中开辟一个空间，并把值初始化为0（arr1为引用变量，但是内部数据是int类型，默认值为 0）,最后把 开辟的堆空间地址 赋值给arr1</p>
<pre><code class="highlight plaintext">int[] arr2 = arr1;</code></pre>
<p>把 arr1 中的 地址 赋值给 arr2，此时 arr2 和 arr1 指向同一块空间</p>
<pre><code class="highlight plaintext">arr2[0] = 20;</code></pre>
<p>此时，arr1[0] 值为 20</p>
<hr />
<p><strong>二维数组</strong></p>
<pre><code class="highlight plaintext">int[][] array = new int[3][];</code></pre>
<p>这条语句会先把 array 压栈，然后在堆中开辟一个空间，初始值为 null（array为引用变量，第一维同样是引用类型），最后把开辟的堆空间地址赋值给 array</p>
<pre><code class="highlight plaintext">array[0][] = new int[1]</code></pre>
<p>这条语句会在堆空间中开辟一个 只有一个 int 类型大小的空间，并初始化为 0 ，然后把自己的地址赋值给array<code>[0][]</code></p>
<pre><code class="highlight plaintext">array[1][] = new int[2];
array[2][] = new int[3];</code></pre>
<h3 id="方法区"><a class="markdownIt-Anchor" href="#方法区"></a> 方法区</h3>
<h4 id="永久代-方法区-元空间的关系"><a class="markdownIt-Anchor" href="#永久代-方法区-元空间的关系"></a> 永久代、方法区、元空间的关系</h4>
<p><strong>jdk1.8之前</strong></p>
<p><strong>jdk1.8之后</strong></p>
<ul>
<li>当内存不足的时候需要堆伸缩区进行控制，当内存充足的时候就要考虑将伸缩区的内存释放掉，来回的计算伸缩必会造成额外的计算机性能的影响，导致程序的整体性能下降</li>
</ul>
<p>涉及到JVM内存结构时，往往会提到永久代，那么它和方法区又是什么关系呢？</p>
<p><strong>《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它</strong>。</p>
<p>那么，在不同的 JVM 上方法区的实现肯定是不同的了。 同时大多数用的JVM都是Sun公司的HotSpot。在HotSpot上把GC分代收集扩展至方法区，或者说<strong>使用永久代来实现方法区</strong>。</p>
<p>因此，我们得到了结论，永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现。而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。</p>
<ul>
<li>在1.7之前在(JDK1.2 ~ JDK7)的实现中，HotSpot 使用永久代实现方法区，HotSpot 使用 GC分代来实现方法区内存回收，可以使用如下参数来调节方法区的大小:</li>
</ul>
<pre><code class="highlight plaintext">-XX:PermSize：方法区初始大小
-XX:MaxPermSize：方法区最大大小

超过这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: PermGen</code></pre>
<ul>
<li>对于Java8， HotSpots取消了永久代，那么是不是也就没有方法区了呢？当然不是，方法区是一个规范，规范没变，它就一直在。那么取代永久代的就是元空间</li>
</ul>
<p><strong>元空间和永久代有什么不同的？</strong></p>
<p>存储位置不同，永久代物理是是堆的一部分，和新生代，老年代地址是连续的，而元空间属于本地内存；</p>
<p>存储内容不同，元空间存储类的元信息，[静态变量]和[常量池]等并入堆中。相当于永久代的数据被分到了堆和元空间中</p>
<hr />
<p>通过上面分析，大家应该大致了解了 JVM 的内存划分，也清楚了 JDK 8 中永久代向元空间的转换。不过大家应该都有一个疑问，就是为什么要做这个转换？带着这个疑问，最后给大家总结以下几点原因：</p>
<ol>
<li>字符串存在永久代中，容易出现性能问题和内存溢出。</li>
<li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢</li>
</ol>
<p>出，太大则容易导致老年代溢出。</p>
<ol>
<li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li>
<li>Oracle 可能会将HotSpot 与 JRockit 合二为一。</li>
</ol>
<h4 id="permgen永久代"><a class="markdownIt-Anchor" href="#permgen永久代"></a> PermGen(永久代)</h4>
<p>绝大部分 Java 程序员应该都见过 &quot;java.lang.OutOfMemoryError: PermGen space &quot;这个异常。这里的 “PermGen space”其实指的就是方法区。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出</p>
<p>我们现在通过动态生成类来模拟永久代的内存溢出(本例中使用的 JDK 版本是 1.7，指定的 PermGen区的大小为 8M)：</p>
<pre><code class="highlight plaintext">package com.kkb.test.memory;

public class Test &#123;&#125;</code></pre>
<pre><code class="highlight plaintext">package com.kkb.test.memory;

import java.io.File;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.List;

public class PermGenOomMock&#123;

    public static void main(String[] args) &#123;
        URL url = null;
        List&lt;ClassLoader&gt; classLoaderList = new ArrayList&lt;ClassLoader&gt;();
        try &#123;
             url = new File(&quot;/tmp&quot;).toURI().toURL();
             URL[] urls = &#123;url&#125;;
        while (true)&#123;
            ClassLoader loader = new URLClassLoader(urls);
            classLoaderList.add(loader);
            loader.loadClass(&quot;com.kkb.test.memory.Test&quot;);
        &#125;
        &#125; catch (Exception e) &#123;
           e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>
<p>通过每次生成不同URLClassLoader对象来加载Test类，从而生成不同的类对象，这样就能看到我们熟</p>
<p>悉的 &quot;java.lang.OutOfMemoryError: PermGen space &quot; 异常了。这里之所以采用 JDK 1.7，是因为在JDK 1.8 中， HotSpot 已经没有 “PermGen space”这个区间了，取而代之是一个叫做 Metaspace（元空间） 的东西。下面我们就来看看 Metaspace 与 PermGen space 的区别</p>
<h4 id="metaspace元空间"><a class="markdownIt-Anchor" href="#metaspace元空间"></a> Metaspace(元空间)</h4>
<p>方法区也是所有线程共享。主要用于存储类的信息、常量池、方法数据、方法代码等。</p>
<p><strong>方法区是JVM 的规范，永久代（PermGen space）是HotSpot对这种规范的实现</strong></p>
<p>其实，移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了JavaHeap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。我们可以通过一段程序来比较 JDK 1.6 与 JDK 1.7及 JDK 1.8 的区别，以字符串常量为例：</p>
<pre><code class="highlight plaintext">package com.kkb.test.memory;
import java.util.ArrayList;
import java.util.List;
public class StringOomMock &#123;
	static String base = &quot;string&quot;;
	public static void main(String[] args) &#123;
		List&lt;String&gt; list = new ArrayList&lt;String&gt;();
		for (int i=0;i&lt; Integer.MAX_VALUE;i++)&#123;
			String str = base + base;
			base = str;
			list.add(str.intern());
		&#125;
	&#125;
&#125;</code></pre>
<p>这段程序以2的指数级不断的生成新的字符串，这样可以比较快速的消耗内存。我们通过 JDK 1.6、JDK1.7 和 JDK 1.8 分别运行：</p>
<p>从上述结果可以看出，JDK 1.6下，会出现“PermGen Space”的内存溢出，而在 JDK 1.7和 JDK 1.8 中，会出现堆内存溢出，并且 JDK 1.8中 PermSize 和 MaxPermGen 已经无效。因此，可以大致验证 JDK1.7 和 1.8 将字符串常量由永久代转移到堆中，并且 JDK 1.8 中已经不存在永久代的结论。</p>
<hr />
<p><strong>现在我们看看元空间到底是一个什么东西？</strong></p>
<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：<strong>元空间并不在虚拟机中，而是使用本地内存</strong>。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</p>
<pre><code class="highlight plaintext">-XX:MetaspaceSize：初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。

-XX:MaxMetaspaceSize：最大空间，默认是没有限制的。

除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：

-XX:MinMetaspaceFreeRatio：在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集

-XX:MaxMetaspaceFreeRatio：在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</code></pre>
<p>现在我们在 JDK 8下重新运行一下代码段 4，不过这次不再指定 PermSize 和 MaxPermSize。而是指定MetaSpaceSize 和 MaxMetaSpaceSize的大小。输出结果如下：</p>
<blockquote>
<p>从输出结果，我们可以看出，这次不再出现永久代溢出，而是出现了元空间的溢出。</p>
</blockquote>
<h3 id="运行时常量池字符串常量池"><a class="markdownIt-Anchor" href="#运行时常量池字符串常量池"></a> 运行时常量池/字符串常量池</h3>
<p>运行时常量池存储在哪？</p>
<ul>
<li><strong>&lt;=JDK1.6</strong>，运行时常量池是方法区的一部分。</li>
<li><strong>&gt;=JDK1.7</strong>，运行时常量池在Java 堆（Heap）中</li>
</ul>
<p>class常量池存放编译期生成的字面量和符号引用，这部分将在类加载后放到运行时常量池中。<strong>运行时常量池也是每个类都有一个</strong></p>
<hr />
<p><strong>运行时常量池中存储的内容是什么？</strong></p>
<p><strong>class常量池与运行时常量池区别</strong></p>
<p>运行时常量池具有动态性，java运行期间也可能将新的常量放入池中</p>
<p>它的字面量可以动态的添加(String#intern()),符号引用可以被解析为直接引用</p>
<p><strong>字符串常量池存储在哪？</strong></p>
<p>在JDK6.0及之前版本，字符串常量池是放在Perm Gen区(也就是方法区)中；</p>
<p>在JDK7.0版本，被移到了堆中。大概是由于方法区的内存空间太小了。</p>
<p><strong>String Pool是什么？</strong></p>
<p>在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个Hash表，默认值大小长度是1009；这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。字符串常量由一个一个字符组成，放在了StringTable上。</p>
<p>在JDK6.0中，StringTable的长度是固定的，长度就是1009，因此如果放入String Pool中的String非常多，就会造成hash冲突，导致链表过长，当调用String.intern()时会需要到链表上一个一个找，从而导致性能大幅度下降；</p>
<p>在JDK7.0中，StringTable的长度可以通过参数指定：</p>
<pre><code class="highlight plaintext">-XX:StringTableSize=66666</code></pre>
<p><strong>字符串常量池中存储的是值还是引用？</strong></p>
<p>在JDK6.0及之前版本中，String Pool里放的都是字符串常量</p>
<p>在JDK7.0中，由于String.intern()发生改变，因此也可存放放于堆内的字符串对象的引用</p>
<blockquote>
<p>需要说明的是：字符串常量池中的字符串只存在一份！</p>
</blockquote>
<pre><code class="highlight plaintext">String s1 = &quot;hello,world!&quot;;
String s2 = &quot;hello,world!&quot;;
s1 == s2 // true</code></pre>
<hr />
<p><strong>String和String Pool的关系</strong></p>
<p>1、<strong>不可变的String</strong></p>
<p>String的底层实际上是使用private final char[] value来实现字符串的存储的，就是说String对象一旦创建之后，就不能再修改这个对象存储的字符串内容。正因为如此，也说String类是不可改变的</p>
<p>2、<strong>什么是String Pool</strong></p>
<p>在JVM中存放着一个字符串池，其中保存着很多String对象，这些对象可以被共享使用。当以字符串直接创建String对象时，会首先在字符串池中查找是否存在该常量。如果不存在，则在String</p>
<p>Pool中创建一个，然后将其地址返回。如果在String Pool中查询到已经存在该常量，则不创建对象，直接返回这个对象地址。</p>
<p>3、<strong>String的创建</strong></p>
<p>有了以上两个概念，就可以说说String的创建了。String主要有两种创建方式，如下：</p>
<pre><code class="highlight plaintext">String str1 = new String(“abc”);
String str2 = “abc”;</code></pre>
<p>虽然两个语句都是返回一个String对象的引用，但是JVM对这两种创建的方式是不一样的。对于第一种，JVM会在内部维护的String Pool中存放一个”abc”的对象，并且在heap中创建一个String对象，然后将该heap中的对象的引用返回给用户。第二种，JVM首先会在String Pool中查找是否存在”abc”对象，如果已经有则不创建，没有的话则在String Pool中创建一个对象</p>
<hr />
<p>有了以上概念，列一个经常考的面试题：</p>
<pre><code class="highlight plaintext">String s1 = new String(“abc”);

String s2 = new String(“abc”);</code></pre>
<p>上面创建了几个String对象？（3个）</p>
<hr />
<p><strong>String的Intern方法详解</strong></p>
<p><strong>引言</strong></p>
<p>String 类型的常量池比较特殊。它的主要使用方法有两种：</p>
<ul>
<li>直接使用双引号声明出来的String 对象会直接存储在常量池中。</li>
<li>如果不是用双引号声明的String 对象，可以使用String 提供的intern 方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中</li>
</ul>
<p><strong>intern 的实现原理</strong></p>
<p>String#intern 方法中看到，这个方法是一个 native 的方法，但注释写的非常明了。“如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回”。</p>
<p>它的大体实现结构就是:JAVA 使用 jni 调用c++实现的StringTable 的intern 方法, StringTable的intern 方法跟Java中的HashMap 的实现是差不多的, 只是不能自动扩容。默认大小是1009。</p>
<p>要注意的是，String的String Pool是一个固定大小的Hashtable ，默认值大小长度是1009，如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern 时性能会大幅下降</p>
<ul>
<li>在jdk6中StringTable 是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。</li>
<li>在jdk7中， StringTable 的长度可以通过一个参数指定：</li>
</ul>
<pre><code class="highlight plaintext">-XX:StringTableSize=99991</code></pre>
<hr />
<p><strong>jdk6 和 jdk7 下 intern 的区别</strong></p>
<p>相信很多 JAVA 程序员都做做类似 String s = new String(“abc”) 这个语句创建了几个对象的题目。 这种题目主要就是为了考察程序员对字符串对象的常量池掌握与否。</p>
<p>上述的语句中是创建了2个对象，第一个对象是”abc”字符串存储在常量池中，第二个对象在JAVA Heap中的 String 对象</p>
<pre><code class="highlight plaintext">public static void main(String[] args) &#123;
    String s = new String(&quot;1&quot;);
    s.intern();
    String s2 = &quot;1&quot;;
    System.out.println(s == s2);
    String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);
    s3.intern();
    String s4 = &quot;11&quot;;
    System.out.println(s3 == s4);
&#125;</code></pre>
<p>输出：</p>
<ul>
<li>jdk6 下 <code>false false</code></li>
<li>jdk7 下 <code>false true</code></li>
</ul>
<p>具体为什么稍后再解释，然后将s3.intern(); 语句下调一行，放到String s4 = “11”; 后面。将s.intern(); 放到String s2 = “1”; 后面。是什么结果呢</p>
<pre><code class="highlight plaintext">public static void main(String[] args) &#123;
    String s = new String(&quot;1&quot;);
    String s2 = &quot;1&quot;;
    s.intern();
    System.out.println(s == s2);
    String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);
    String s4 = &quot;11&quot;;
    s3.intern();
    System.out.println(s3 == s4);
&#125;</code></pre>
<p>打印结果为：</p>
<ul>
<li>jdk6 下<code>false false</code></li>
<li>jdk7 下<code>false false</code></li>
</ul>
<p><strong>1.jdk6中的解释</strong></p>
<blockquote>
<p>注：图中绿色线条代表 string 对象的内容指向。 黑色线条代表地址指向。</p>
</blockquote>
<p>如上图所示。首先说一下 jdk6中的情况，在 jdk6中上述的所有打印都是 false 的，因为 jdk6中的常量池是放在 Perm 区中的，Perm区和正常的 JAVA Heap 区域是完全分开的。上面说过如果是使用引号声明的字符串都是会直接在字符串常量池中生成，而 new 出来的 String 对象是放在 JAVA Heap 区域。所以拿一个 JAVA Heap 区域的对象地址和字符串常量池的对象地址进行比较肯定是不相同的，即使调用String.intern 方法也是没有任何关系的</p>
<p><strong>2.jdk7中的解释</strong></p>
<p>在 Jdk6 以及以前的版本中，字符串的常量池是放在堆的Perm区的，Perm区是一个类静态的区域，主要存储一些加载类的信息，常量池，方法片段等内容，默认大小只有4m，一旦常量池中大量使用intern 是会直接产生java.lang.OutOfMemoryError:PermGen space 错误的。在 jdk7 的版本中，字符串常量池已经从Perm区移到正常的Java Heap区域了。为什么要移动，Perm 区域太小是一个主要原因，当然据消息称jdk8已经直接取消了Perm区域，而新建立了一个元区域。应该是jdk开发者认为Perm区域已经不适合现在 JAVA 的发展了。正式因为字符串常量池移动到JAVA Heap区域后，再来解释为什么会有上述的打印结果。</p>
<ul>
<li>
<p>在第一段代码中，先看 s3和s4字符串。String s3 = new String(“1”) + new String(“1”); ，这句代码中现在生成了2最终个对象，是字符串常量池中的“1” 和 JAVA Heap中的s3引用指向的对象。中间还有2个匿名的new String(“1”) 我们不去讨论它们。此时s3引用对象内容是”11″，但此时常量池中是没有 “11”对象的。</p>
</li>
<li>
<p>接下来s3.intern(); 这一句代码，是将 s3中的&quot;11&quot;字符串放入String 常量池中，因为此时常量池中不存在&quot;11&quot;字符串，因此常规做法是跟 jdk6 图中表示的那样，在常量池中生成一个&quot;11&quot;的对象，关键点是 jdk7 中常量池不在Perm区域了，这块做了调整。常量池中不需要再存储一份对象了，可以直接存储堆中的引用。这份引用指向s3引用的对象。 也就是说引用地址是相同的。</p>
</li>
<li>
<p>最后String s4 = “11”; 这句代码中”11″是显示声明的，因此会直接去常量池中创建，创建的时候发现已经有这个对象了，此时也就是指向s3引用对象的一个引用。所以s4引用就指向和s3一样了。因此最后的比较 s3 == s4 是 true。</p>
</li>
<li>
<p>再看s和 s2 对象。String s = new String(“1”); 第一句代码，生成了2个对象。常量池中的“1”和 JAVA Heap 中的字符串对象。s.intern(); 这一句是 s 对象去常量池中寻找后发现 “1” 已经在常量池里了。</p>
</li>
<li>
<p>接下来String s2 = “1”; 这句代码是生成一个 s2的引用指向常量池中的“1”对象。 结果就是 s 和s2 的引用地址明显不同。图中画的很清晰。</p>
</li>
<li>
<p>来看第二段代码，从上边第二幅图中观察。第一段代码和第二段代码的改变就是 s3.intern();的顺序是放在String s4 = “11”; 后了。这样，首先执行String s4 = “11”; 声明 s4 的时候常量池中是不存在“11”对象的，执行完毕后，“11“对象是 s4 声明产生的新对象。然后再执行s3.intern(); 时，常量池中“11”对象已经存在了，因此 s3 和 s4 的引用是不同的。</p>
</li>
<li>
<p>第二段代码中的 s 和 s2 代码中， s.intern(); ，这一句往后放也不会有什么影响了，因为对象池中在执行第一句代码String s = new String(“1”); 的时候已经生成“1”对象了。下边的s2声明都是直接从常量池中取地址引用的。 s 和 s2 的引用地址是不会相等的</p>
</li>
</ul>
<p><strong>小结</strong></p>
<p>从上述的例子代码可以看出 jdk7 版本对 intern 操作和常量池都做了一定的修改。主要包括2点：</p>
<ul>
<li>将String常量池从Perm区移动到了Java Heap区</li>
<li>String#intern 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象</li>
</ul>
<h2 id="jvm如何运行字节码"><a class="markdownIt-Anchor" href="#jvm如何运行字节码"></a> JVM如何运行字节码</h2>
<h2 id="jvm堆溢出分析"><a class="markdownIt-Anchor" href="#jvm堆溢出分析"></a> JVM堆溢出分析</h2>
<h3 id="jconsole内存监控工具"><a class="markdownIt-Anchor" href="#jconsole内存监控工具"></a> jconsole内存监控工具</h3>
<p>该工具可以实时监控正在运行的java程序的一些内存使用情况</p>
<p>工具在java home安装目录的bin目录下，直接双击运行</p>
<h3 id="jmap内存分析工具"><a class="markdownIt-Anchor" href="#jmap内存分析工具"></a> jmap内存分析工具</h3>
<p>jdk自带的jvm内存分析的工具可以查看当前堆内对象的使用情况</p>
<h2 id="jvm远程debug"><a class="markdownIt-Anchor" href="#jvm远程debug"></a> JVM远程debug</h2>
<p><strong>java启动jar包时加入参数</strong></p>
<ul>
<li>指定运行的被调试应用和调试者之间的通信协议，(ie: transport=dt_socket)</li>
<li>远程被调试应用开通的端口，(ie: address=1043)， 可定义其他端口，比如9999</li>
<li>server=y 表示这个 JVM 即将被调试</li>
<li>suspend=n 用来告知 JVM 立即执行，不要等待未来将要附着上/连上（attached）的调试者。如果设成 y, 则应用将暂停不运行，直到有调试者连接上</li>
</ul>
<pre><code class="highlight plaintext">-agentlib:jdwp=transport=dt_socket,address=1043,server=y,suspend=n</code></pre>
<p><s>或者(旧版方式)：</s></p>
<pre><code class="highlight plaintext">-Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=1043,suspend=n</code></pre>
<p><strong>Remote JVM debug</strong></p>
<p>idea配置remote jvm debug即可：</p>
<p><strong>远程JVM调试怎么工作的</strong></p>
<p>一切源于被称作 Agents 的东西。运行着各种编译过的 .class 文件的JVM， 有一种特性，可以允许外部的库（Java或C++写的libraries）在运行时注入到 JVM 中。这些外部的库就称作 Agents, 他们有能力修改运行中 .class 文件的内容。</p>
<p>这些 Agents 拥有的这些 JVM 的功能权限， 是在 JVM 内运行的 Java Code 所无法获取的， 他们能用来做一些有趣的事情，比如修改运行中的源码， 性能分析等。 像 JRebel 工具就是用了这些功能达到魔术般的效果。</p>
<p>传递一个 Agent Lib 给 JVM, 通过添加 agentlib:libname[=options] 格式的启动参数即可办到。像上面的远程调试我们用的就是 **-agentlib:jdwp=… **来引入 jdwp 这个 Agent 的。</p>
<p>jdwp 是一个 JVM 特定的 JDWP（Java Debug Wire Protocol） 可选实现，用来定义调试者与运行JVM之间的通讯，它的是通过 JVM 本地库的 <a target="_blank" rel="noopener" href="http://jdwp.so">jdwp.so</a> 或者 jdwp.dll 支持实现的。</p>
<p><strong>它到底是怎么工作的呢？</strong></p>
<p>简单来说， jdwp agent 会建立运行应用的 JVM 和调试者（本地或者远程）之间的桥梁。既然他是一个Agent Library, 它就有能力拦截运行的代码。</p>
<p>在 JVM 架构里， debugging 功能在 JVM 本身的内部是找不到的，它是一种抽象到外部工具的方式（也称作调试者 debugger）。这些调试工具或者运行在 JVM 的本地 或者在远程。这是一种解耦，模块化的架构。</p>
</main>

</article>


<script src="/js/highlight.js"></script>

  </main>
  <footer class="footer">
  
  <span>Copyright © 2026 Lism Blog | lisisism@qq.com</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>