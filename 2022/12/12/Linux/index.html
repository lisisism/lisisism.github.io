<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    Linux 丨
    

    Lism Blog
  </title>

  
  <link rel="shortcut icon" href="/icon.svg">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="/Lism Blog" type="application/atom+xml">
</head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">/Lism Blog</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <article class="post">
  
  <div class="post-title">Linux</div>
  <div class="post-meta">
    <div class="date">2022 十二月 12日</div>
    <div class="tags">
      
      <div class="tag-item">Linux</div>
      
    </div>
  </div>
  

  <main class="post-content"><h1 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> $Linux</h1>
<h1 id="liunx"><a class="markdownIt-Anchor" href="#liunx"></a> Liunx</h1>
<ul>
<li><a href="">Liunx</a>
<ul>
<li><a href="">简介</a>
<ul>
<li><a href="">常见的Linux系统版本</a></li>
<li><a href="">应用领域</a></li>
<li><a href="">了解红帽认证</a></li>
</ul>
</li>
<li><a href="">系统目录结构</a></li>
<li><a href="">键盘操作技巧</a></li>
<li><a href="">使用命令</a>
<ul>
<li><a href="">识别命令</a>
<ul>
<li><a href="">type 显示命令的类型</a></li>
<li><a href="">which 显示一个可执行命令的位置</a></li>
</ul>
</li>
<li><a href="">得到帮助文档</a>
<ul>
<li><a href="">help 得到shell内部命令帮助文档</a></li>
<li><a href="">–help - 显示用法信息</a></li>
<li><a href="">whatis 显示非常简洁的命令说明</a></li>
</ul>
</li>
<li><a href="">alias 创建自己的命令</a></li>
<li><a href="">命令执行顺序</a></li>
</ul>
</li>
<li><a href="">命令展开</a>
<ul>
<li><a href="">路径名展开</a></li>
<li><a href="">波浪线展开</a></li>
<li><a href="">算数表达式展开</a></li>
<li><a href="">花括号展开</a></li>
<li><a href="">双引号</a></li>
<li><a href="">单引号</a></li>
<li><a href="">转义字符</a></li>
</ul>
</li>
<li><a href="">系统命令</a>
<ul>
<li><a href="">常用系统工作命令</a>
<ul>
<li><a href="">echo</a></li>
<li><a href="">date</a></li>
<li><a href="">reboot重启/poweroff关机</a></li>
<li><a href="">su/sudo</a></li>
<li><a href="">systemctl</a></li>
</ul>
</li>
<li><a href="">系统状态检测命令</a>
<ul>
<li><a href="">ifconfig命令</a></li>
<li><a href="">uname命令</a></li>
<li><a href="">uptime命令</a></li>
<li><a href="">free命令</a></li>
<li><a href="">who</a></li>
<li><a href="">last</a></li>
<li><a href="">history</a></li>
</ul>
</li>
<li><a href="">配置主机名称</a></li>
<li><a href="">配置网卡信息</a></li>
<li><a href="">Yum</a></li>
<li><a href="">计划任务服务程序</a>
<ul>
<li><a href="">一次性计划任务</a></li>
<li><a href="">长期性计划任务</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="">文件权限</a>
<ul>
<li><a href="">文件属主和属组</a>
<ul>
<li><a href="">更改文件属组 chgrp</a></li>
<li><a href="">更改文件属主 chown</a></li>
</ul>
</li>
<li><a href="">文件权限 chmod</a></li>
<li><a href="">文件的特殊权限</a>
<ul>
<li><a href="">SUID</a></li>
<li><a href="">SGID</a></li>
<li><a href="">SBIT</a></li>
</ul>
</li>
<li><a href="">文件的隐藏属性</a>
<ul>
<li><a href="">chattr</a></li>
<li><a href="">lsattr</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="">文件/目录</a>
<ul>
<li><a href="">处理目录常用命令</a>
<ul>
<li><a href="">ls(列出目录)</a></li>
<li><a href="">cd(切换目录)</a></li>
<li><a href="">pwd(显示目前所在的目录)</a></li>
<li><a href="">mkdir(创建新目录)</a></li>
<li><a href="">rmdir(删除空目录)</a></li>
<li><a href="">rm(移除文件或目录)</a></li>
<li><a href="">cp(复制文件或目录)</a></li>
<li><a href="">mv(移动文件与目录，或修改名称)</a></li>
<li><a href="">touch</a></li>
<li><a href="">dd</a></li>
<li><a href="">file(查看文件类型)</a></li>
</ul>
</li>
<li><a href="">软硬方式连接</a>
<ul>
<li><a href="">ln</a></li>
</ul>
</li>
<li><a href="">文件内容查看</a>
<ul>
<li><a href="">cat(由第一行开始显示文件内容)</a></li>
<li><a href="">tac(由最后一行开始显示文件内容)</a></li>
<li><a href="">nl(可以显示行号)</a></li>
<li><a href="">more(一页一页翻动)</a></li>
<li><a href="">less(一页一页翻动)</a></li>
<li><a href="">head(取出文件前几行)</a></li>
<li><a href="">tail(取出文件后几行)</a></li>
<li><a href="">tr(替换文本内容)</a></li>
<li><a href="">wc(统计行数)</a></li>
<li><a href="">stat(查看文件信息)</a></li>
<li><a href="">cut(提取列)</a></li>
<li><a href="">diff(比较)</a></li>
</ul>
</li>
<li><a href="">查找</a>
<ul>
<li><a href="">find</a></li>
<li><a href="">whereis</a></li>
<li><a href="">locate</a></li>
<li><a href="">which</a></li>
<li><a href="">grep</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="">归档备份</a>
<ul>
<li><a href="">解压缩</a>
<ul>
<li><a href="">gzip</a></li>
<li><a href="">bzip2</a></li>
</ul>
</li>
<li><a href="">归档文件</a>
<ul>
<li><a href="">tar 打�</a>�</li>
<li><a href="">zip</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="">用户/用户组管理</a>
<ul>
<li><a href="">用户账号的管理</a>
<ul>
<li><a href="">useradd(添加新用户)</a></li>
<li><a href="">userdel(删除账号)</a></li>
<li><a href="">usermod(修改账号)</a></li>
<li><a href="">passwd(用户口令的管理)</a></li>
</ul>
</li>
<li><a href="">用户组的管理</a>
<ul>
<li><a href="">group(增加用户组)</a></li>
<li><a href="">groupdel(删除用户组)</a></li>
<li><a href="">groupmod(修改用户组)</a></li>
<li><a href="">切换用户组</a></li>
</ul>
</li>
<li><a href="">与用户账号有关的系统文件</a>
<ul>
<li><a href="">/etc/passwd 用户信息</a></li>
<li><a href="">/etc/group 用户组</a></li>
<li><a href="">批量添加用户</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="">管道符/重定向/环境变量</a>
<ul>
<li><a href="">输入输出重定向</a></li>
<li><a href="">管道命令符</a></li>
<li><a href="">命令行的通配符</a></li>
<li><a href="">常用的转义字符</a></li>
<li><a href="">重要的环境变量</a></li>
</ul>
</li>
<li><a href="">存储结构/磁盘划分</a>
<ul>
<li><a href="">物理设备的命名规则</a></li>
<li><a href="">挂载硬件设备</a>
<ul>
<li><a href="">mount</a></li>
<li><a href="">umount</a></li>
</ul>
</li>
<li><a href="">添加硬盘设备</a>
<ul>
<li><a href="">fdisk命令（分区）</a></li>
<li><a href="">mkfs（格式化）</a></li>
<li><a href="">du（查看文件数据占用量）</a></li>
</ul>
</li>
<li><a href="">添加交换分区</a></li>
</ul>
</li>
<li><a href="">vi/vim</a></li>
<li><a href="">进程</a>
<ul>
<li><a href="">ps 查看进程</a></li>
<li><a href="">top 显示任务</a></li>
<li><a href="">进程相关命令</a>
<ul>
<li><a href="">停止/暂停</a></li>
<li><a href="">放置到后台执行</a></li>
<li><a href="">jobs 显示活跃任务</a></li>
<li><a href="">fg/bg</a></li>
<li><a href="">pidof</a></li>
<li><a href="">kill /killall</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="">shell环境变量</a>
<ul>
<li><a href="">查看环境变量</a></li>
<li><a href="">建立环境变量</a></li>
<li><a href="">export命令</a></li>
<li><a href="">修改shell环境</a></li>
</ul>
</li>
<li><a href="">软件包管理</a>
<ul>
<li><a href="">yum命令</a>
<ul>
<li><a href="">yum搜索软件�</a>�</li>
<li><a href="">yum安装软件�</a>�</li>
<li><a href="">yum卸载软件</a></li>
<li><a href="">yum更新软件�</a>�</li>
<li><a href="">配置阿里镜像</a></li>
<li><a href="">查找软件并删除</a></li>
</ul>
</li>
<li><a href="">rpm</a>
<ul>
<li><a href="">通过软件包文件来安装软件</a></li>
<li><a href="">经过软件包来升级软件</a></li>
<li><a href="">列出所安装的软件�</a>�</li>
<li><a href="">删除软件</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="">网络系统</a>
<ul>
<li><a href="">检查和检测网络</a>
<ul>
<li><a href="">ping</a></li>
<li><a href="">netstat</a></li>
</ul>
</li>
<li><a href="">网络中传输文件</a>
<ul>
<li><a href="">ftp</a></li>
<li><a href="">wget 下载</a></li>
<li><a href="">scp远程拷贝</a></li>
</ul>
</li>
<li><a href="">SSH</a></li>
<li><a href="">防火墙</a>
<ul>
<li><a href="">打开防火墙</a></li>
<li><a href="">关闭防火墙</a></li>
<li><a href="">iptables</a>
<ul>
<li><a href="">策略与规则链</a></li>
<li><a href="">基本命令参数</a></li>
<li><a href="">允许某个ip某个端口访问</a></li>
<li><a href="">示例</a></li>
</ul>
</li>
<li><a href="">Firewalld</a>
<ul>
<li><a href="">终端管理工具</a></li>
<li><a href="">示例</a></li>
<li><a href="">图形管理工具</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="">开放指定端口</a></li>
<li><a href="">服务的访问控制列表</a></li>
</ul>
</li>
<li><a href="">常用命令</a>
<ul>
<li><a href="">dirname/basename(截取路径)</a></li>
<li><a href="">w3m</a></li>
<li><a href="">split</a></li>
<li><a href="">cpulimit</a>
<ul>
<li><a href="">安�</a>�</li>
<li><a href="">使用</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<h3 id="常见的linux系统版本"><a class="markdownIt-Anchor" href="#常见的linux系统版本"></a> 常见的Linux系统版本</h3>
<p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、硬盘及文件系统控制及多任务功能的系统核心程序。而Linux发行套件系统是我们常说的Linux操作系统，也即是由Linux内核与各种常用软件的集合产品。全球大约有数百款的Linux系统版本，每个系统版本都有自己的特性和目标人群，下面将可以从用户的角度选出最热门的几款进行介绍。</p>
<ul>
<li>Linux的发行版
<ul>
<li>指将Liunx内核与应用软件做一个打包</li>
<li>知名发行版有：Ubuntu，RedHat，CentOS，Debian，Fedora，SuSE，OpenSUSE，ArchLiunx，SolusOS</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li><strong>redhat</strong> 红帽企业系统（RedHatEnterpriseLinux,RHEL.）</li>
<li><img src="image/.png" alt=".png" />
<ul>
<li>红帽公司是全球最大的开源技术厂商，RHEL是全世界内使用最广泛的Linux系统。</li>
<li>RHEL系统具有极强的性能与稳定性，并且在全球范围内拥有完善的技术支持。</li>
<li>RHEL系统也是本书、红帽认证以及众多生产环境中使用的系统。</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li><strong>CentOS</strong></li>
<li><img src="image/-1.png" alt="-1.png" />
<ul>
<li>通过把RHEL系统重新编译并发布给用户免费使用的Linux系统，具有广泛的使用人群。CentOS当前已被红帽公司“收编”</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li><strong>Fedora</strong></li>
<li><img src="image/-2.png" alt="-2.png" />
<ul>
<li>由红帽公司发布的桌面版系统套件（目前已经不限于桌面版）</li>
<li>用户可免费体验到最新的技术或工具，这些技术或工具在成熟后会被加入到RHEL系统中，因此Fedora也称为RHEL系统的“试验田”。</li>
<li>运维人员如果想时刻保持自己的技术领先，就应该多关注此类Linux系统的发展变化及新特性，不断改变自己的学习方向。</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li><strong>openSUSE</strong></li>
<li><img src="image/-3.png" alt="-3.png" />
<ul>
<li>源自德国的一款著名的Linux系统，在全球范围内有着不错的声誉及市场占有率。</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li><strong>Gentoo</strong></li>
<li><img src="image/-4.png" alt="-4.png" />
<ul>
<li>具有极高的自定制性，操作复杂，因此适合有经验的人员使用。读者可以在学习完本书后尝试一下该系统。</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li><strong>Debian</strong></li>
<li><img src="image/-5.png" alt="-5.png" />
<ul>
<li>稳定性、安全性强，提供了免费的基础支持，可以良好地支持各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li><strong>Ubuntu</strong></li>
<li><img src="image/-6.png" alt="-6.png" />
<ul>
<li>是一款派生自Debian的操作系统，对新款硬件具有极强的兼容能力。Ubuntu与Fedora都是极其出色的Linux桌面系统，而且Ubuntu也可用于服务器领域。</li>
</ul>
</li>
</ul>
<p>现在国内大多数Linux相关的图书都是围绕CentOS系统编写的，作者大多也会给出围绕CentOS进行写作的一系列理由，但是很多理由都站不住脚，根本没有剖析到CentOS系统与RHEL系统的本质关系。CentOS系统是通过把RHEL系统释放出的程序源代码经过二次编译之后生成的一种Linux系统，其命令操作和服务配置方法与RHEL完全相同，但是去掉了很多收费的服务套件功能，而且还不提供任何形式的技术支持，出现问题后只能由运维人员自己解决。经过这般分析基本上可以判断出，选择CentOS的理由只剩下—免费！当人们大举免费、开源、正义的旗帜来宣扬CentOS系统的时候，殊不知CentOS系统其实早在2014年年初就已经被红帽公司“收编”，当前只是战略性的免费而已。再者说，根据GNU GPL许可协议，我们同样也可以免费使用RHEL系统，甚至是修改其代码创建衍生产品。开源系统在自由程度上没有任何差异，更无关道德问题。</p>
<h3 id="应用领域"><a class="markdownIt-Anchor" href="#应用领域"></a> 应用领域</h3>
<ul>
<li>Linux应用领域
<ul>
<li>嵌入设备，超级计算机，服务器</li>
<li>通常服务器使用LAMP（Liunx+Apache+MySQL+PHP）或LNMP（Linux+Nginx+MySQL+PHP）组合</li>
</ul>
</li>
<li>Linux vs Windows</li>
</ul>
<table>
<thead>
<tr>
<th>比较</th>
<th>Windows</th>
<th>Linux</th>
</tr>
</thead>
<tbody>
<tr>
<td>界面</td>
<td>界面统一，外壳程序固定所有Windows程序菜单几乎一致，快捷键也几乎相同</td>
<td>图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux的终端机是从UNIX传承下来，基本命令和操作方法也几乎一致。</td>
</tr>
<tr>
<td>驱动程序</td>
<td>驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的Windows下的驱动，也会比较头痛</td>
<td>由志愿者开发，由Linux核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在Windows下很难支持的也容易找到驱动。HP、Intel、AMD等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解</td>
</tr>
<tr>
<td>使用</td>
<td>使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利</td>
<td>图形界面使用简单，容易入门。文字界面，需要学习才能掌握</td>
</tr>
<tr>
<td>学习</td>
<td>系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难</td>
<td>系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易</td>
</tr>
<tr>
<td>软件</td>
<td>每一种特定功能可能都需要商业软件的支持，需要购买相应的授权</td>
<td>大部分软件都可以自由获取，同样功能的软件选择较少</td>
</tr>
</tbody>
</table>
<h3 id="了解红帽认证"><a class="markdownIt-Anchor" href="#了解红帽认证"></a> 了解红帽认证</h3>
<p>红帽公司成立于1993年，是全球首家收入超10亿美元的开源公司，总部位于美国，分支机构遍布全球。红帽公司作为全球领先的开源和Linux系统提供商，其产品已被业界广泛认可并使用，尤其是RHEL系统在业内拥有超高的Linux系统市场占有率。红帽公司除了提供操作系统之外，还提供了虚拟化、中间件、应用程序、管理和面向服务架构的解决方案。</p>
<p>红帽认证是由红帽公司推出的Linux认证，该认证被认为是Linux行业乃至整个IT领域价值最高的认证之一。红帽认证考试全部采用上机形式，在考察学生基础理论能力的同时还考察了实践动手操作以及排错能力。红帽公司针对红帽认证制定了完善的专业评估与认证标准，其认证主要包括红帽认证系统管理员（RHCSA）、红帽认证工程师（RHCE）与红帽认证架构师（RHCA）。</p>
<p>2014年6月10日，红帽公司在发布新版红帽企业版系统（RHEL 7）的当天即在红帽英文官网更新了其对RHCSA与RHCE培训政策的调整，考生只有先通过红帽RHCSA认证后才能考取红帽RHCE认证。</p>
<p><img src="image/-7.png" alt="-7.png" /></p>
<h2 id="系统目录结构"><a class="markdownIt-Anchor" href="#系统目录结构"></a> 系统目录结构</h2>
<p>登录系统后，在当前命令窗口下输入命令：</p>
<pre><code class="highlight plaintext">ls /</code></pre>
<p>你会看到如下图所示:</p>
<p><img src="image/-8.png" alt="-8.png" /></p>
<p>树状目录结构：</p>
<p><img src="image/-9.png" alt="-9.png" /></p>
<p>系统启动必须：</p>
<ul>
<li><strong>/boot</strong>：这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li>
<li><strong>/etc</strong>：这个目录用来存放所有的系统管理所需要的配置文件和子目录，更改该目录下的文件可能导致系统无法启动。</li>
<li><strong>/lib</strong>：存放基本代码库（比如c++库），其作用类似于Windows的DDL文件，几乎所有的应用程序都需要用到这些共享库。</li>
<li><strong>/sys</strong>：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</li>
</ul>
<p>指令集合：</p>
<ul>
<li><strong>/bin</strong>：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li>
<li><strong>/sbin</strong>：s就是super user的意思，这里存放的是系统管理员使用的系统管理程序。</li>
</ul>
<p>外部文件管理：</p>
<ul>
<li><strong>/dev</strong> ：dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</li>
<li><strong>/media</strong>：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li>
<li><strong>/mnt</strong>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</li>
</ul>
<p>临时文件：</p>
<ul>
<li><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run</li>
<li><strong>/tmp</strong>：这个目录用来存放一些临时文件。</li>
<li><strong>/lost+found</strong>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li>
</ul>
<p>账户：</p>
<ul>
<li><strong>/root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。</li>
<li><strong>/home</strong>：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li>
<li><strong>/usr</strong>：这是一个很重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于Windows的program files目录。</li>
<li><strong>/usr/bin</strong>：系统用户使用的应用程序。</li>
<li><strong>/usr/sbin</strong>：超级用户使用的比较高级的管理程序和系统守护程序。</li>
<li><strong>usr/src</strong>：内核源代码默认的放置位置。</li>
</ul>
<p>运行过程中要用：</p>
<ul>
<li><strong>/var</strong>：这个目录中存放着不断扩充的东西，我们习惯将那些经常被修改的目录存放到这个目录下，包括各种日志文件。</li>
<li><strong>/proc</strong>：管理内存空间！虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。</li>
</ul>
<p>扩展用：</p>
<ul>
<li><strong>/opt</strong>：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</li>
<li><strong>/srv</strong>：该目录存放一些服务启动之后需要提取的数据。</li>
<li><strong>/selinux</strong>：这个目录是Redhat/CentOS所持有的目录，Selinux是一个安全机制，类似于Windows的防火墙，到那时这套机制比较复杂，这个目录就是存放selinux相关文件的。</li>
</ul>
<hr />
<p>在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。</p>
<blockquote>
<p>/etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。</p>
</blockquote>
<blockquote>
<p>/bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在/bin/ls 目录下的。</p>
</blockquote>
<blockquote>
<p>值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给root使用的指令。</p>
</blockquote>
<blockquote>
<p>/var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在/var/log 目录下，另外mail的预设放置也是在这里。</p>
</blockquote>
<h2 id="键盘操作技巧"><a class="markdownIt-Anchor" href="#键盘操作技巧"></a> 键盘操作技巧</h2>
<p>开玩笑地说，我经常把 Unix 描述为“这个操作系统是为喜欢敲键盘的人们服务的。” 当然，Unix 甚至还有一个命令行，这个事实是个确凿的证据，证明了我所说的话。 但是命令行用户不喜欢敲入那么多字。那又为什么如此多的命令会有这样简短的命令名，像 cp，ls，mv，和 rm？事实上，命令行最为珍视的目标之一就是懒惰；用最少的击键次数 来完成最多的工作。另一个目标是你的手指永远不必离开键盘，永不触摸鼠标。在这一 章节，我们将看一下 bash 特性，这些特性使键盘使用起来更加迅速，更加高效。以下命令将会露面：</p>
<ul>
<li>clear － 清空屏幕</li>
<li>history － 显示历史列表内容</li>
</ul>
<p><strong>移动光标</strong></p>
<table>
<thead>
<tr>
<th>按键</th>
<th>行动</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl-a</td>
<td>移动光标到行首。</td>
</tr>
<tr>
<td>Ctrl-e</td>
<td>移动光标到行尾。</td>
</tr>
<tr>
<td>Ctrl-f</td>
<td>光标前移一个字符；和右箭头作用一样。</td>
</tr>
<tr>
<td>Ctrl-b</td>
<td>光标后移一个字符；和左箭头作用一样。</td>
</tr>
<tr>
<td>Alt-f</td>
<td>光标前移一个字。</td>
</tr>
<tr>
<td>Alt-b</td>
<td>光标后移一个字。</td>
</tr>
<tr>
<td>Ctrl-l</td>
<td>清空屏幕，移动光标到左上角。clear 命令完成同样的工作。</td>
</tr>
</tbody>
</table>
<p><strong>修改文本</strong></p>
<table>
<thead>
<tr>
<th>按键</th>
<th>行动</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl-d</td>
<td>删除光标位置的字符。</td>
</tr>
<tr>
<td>Ctrl-t</td>
<td>光标位置的字符和光标前面的字符互换位置。</td>
</tr>
<tr>
<td>Alt-t</td>
<td>光标位置的字和其前面的字互换位置。</td>
</tr>
<tr>
<td>Alt-l</td>
<td>把从光标位置到字尾的字符转换成小写字母。</td>
</tr>
<tr>
<td>Alt-u</td>
<td>把从光标位置到字尾的字符转换成大写字母。</td>
</tr>
</tbody>
</table>
<p><strong>剪切/粘贴文本</strong></p>
<table>
<thead>
<tr>
<th>按键</th>
<th>行动</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl-k</td>
<td>剪切从光标位置到行尾的文本。</td>
</tr>
<tr>
<td>Ctrl-u</td>
<td>剪切从光标位置到行首的文本。</td>
</tr>
<tr>
<td>Alt-d</td>
<td>剪切从光标位置到词尾的文本。</td>
</tr>
<tr>
<td>Alt-Backspace</td>
<td>剪切从光标位置到词头的文本。如果光标在一个单词的开头，剪切前一个单词。</td>
</tr>
<tr>
<td>Ctrl-y</td>
<td>把剪切环中的文本粘贴到光标位置。</td>
</tr>
</tbody>
</table>
<p><strong>搜索历史命令</strong></p>
<p>在任何时候，我们都可以浏览历史列表的内容，通过：</p>
<pre><code class="highlight plaintext">$ history | less</code></pre>
<p>在默认情况下，bash 会存储你所输入的最后 500 个命令。在随后的章节里，我们会知道 怎样调整这个数值。比方说我们想要找到列出目录 /usr/bin 内容的命令。一种方法，我们可以这样做：</p>
<pre><code class="highlight plaintext">$ history | grep /usr/bin</code></pre>
<p>比方说在我们的搜索结果之中，我们得到一行，包含了有趣的命令，像这样；</p>
<pre><code class="highlight plaintext">88  ls -l /usr/bin &gt; ls-output.txt</code></pre>
<p>数字 “88” 是这个命令在历史列表中的行号。随后在使用另一种展开类型时，叫做 历史命令展开，我们会用到这个数字。我们可以这样做，来使用我们所发现的行：</p>
<pre><code class="highlight plaintext">$ !88</code></pre>
<h2 id="使用命令"><a class="markdownIt-Anchor" href="#使用命令"></a> 使用命令</h2>
<p>命令可以是下面四种形式之一：</p>
<ul>
<li><strong>可执行程序</strong>，就像我们所看到的位于目录/usr/bin 中的文件一样。 属于这一类的程序，可以编译成二进制文件，诸如用 C 和 C++语言写成的程序, 也可以是由脚本语言写成的程序，比如说 shell，perl，python，ruby，等等。</li>
<li><strong>内建于 shell 自身的命令</strong>。bash 支持若干命令，内部叫做 shell 内部命令 (builtins)。例如，cd 命令，就是一个 shell 内部命令。</li>
<li><strong>shell 函数</strong>。这些是小规模的 shell 脚本，它们混合到环境变量中。 在后续的章节里，我们将讨论配置环境变量以及书写 shell 函数。但是现在， 仅仅意识到它们的存在就可以了。</li>
<li><strong>命令别名</strong>。我们可以定义自己的命令，建立在其它命令之上。</li>
</ul>
<h3 id="识别命令"><a class="markdownIt-Anchor" href="#识别命令"></a> 识别命令</h3>
<h4 id="type-显示命令的类型"><a class="markdownIt-Anchor" href="#type-显示命令的类型"></a> type 显示命令的类型</h4>
<p>type 命令是 shell 内部命令，它会显示命令的类别，给出一个特定的命令名（做为参数）。 它像这样工作：</p>
<pre><code class="highlight plaintext">type command</code></pre>
<p>例子：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ type type
type is a shell builtins
[me@linuxbox ~]$ type ls
ls is aliased to `ls --color=tty`
[me@linuxbox ~]$ type cp
cp is /bin/cp</code></pre>
<p>我们看到这三个不同命令的检测结果。注意，ls 命令（在 Fedora 系统中）的检查结果，ls 命令实际上 是 ls 命令加上选项”–color=tty”的别名。现在我们知道为什么 ls 的输出结果是有颜色的！</p>
<h4 id="which-显示一个可执行命令的位置"><a class="markdownIt-Anchor" href="#which-显示一个可执行命令的位置"></a> which 显示一个可执行命令的位置</h4>
<p>有时候在一个操作系统中，不只安装了可执行程序的一个版本。然而在桌面系统中，这并不普遍， 但在大型服务器中，却很平常。为了确定所给定的执行程序的准确位置，使用 which 命令：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ which ls
/bin/ls</code></pre>
<p>这个命令只对可执行程序有效，不包括内部命令和命令别名，别名是真正的可执行程序的替代物。 当我们试着使用 shell 内部命令时，例如，cd 命令，我们或者得不到回应，或者是个错误信息：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ which cd
/usr/bin/which: no cd in
(/opt/jre1.6.0_03/bin:/usr/lib/qt-3.3/bin:/usr/kerberos/bin:/opt/jre1
.6.0_03/bin:/usr/lib/ccache:/usr/local/bin:/usr/bin:/bin:/home/me/bin)</code></pre>
<h3 id="得到帮助文档"><a class="markdownIt-Anchor" href="#得到帮助文档"></a> 得到帮助文档</h3>
<h4 id="help-得到shell内部命令帮助文档"><a class="markdownIt-Anchor" href="#help-得到shell内部命令帮助文档"></a> help 得到shell内部命令帮助文档</h4>
<p>bash 有一个内建的帮助工具，可供每一个 shell 内部命令使用。输入“help”，接着是 shell 内部命令名。例如：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ help cd
cd: cd [-L|-P] [dir]
Change ...</code></pre>
<p>注意表示法：出现在命令语法说明中的方括号，表示可选的项目。一个竖杠字符 表示互斥选项。在上面 cd 命令的例子中：</p>
<pre><code class="highlight plaintext">cd [-L|-P] [dir]</code></pre>
<p>这种表示法说明，cd 命令可能有一个“-L”选项或者“-P”选项，进一步，可能有参数“dir”。</p>
<h4 id="help-显示用法信息"><a class="markdownIt-Anchor" href="#help-显示用法信息"></a> –help - 显示用法信息</h4>
<p>许多可执行程序支持一个 --help 选项，这个选项是显示命令所支持的语法和选项说明。例如：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ mkdir --help
Usage: mkdir [OPTION] DIRECTORY...
Create ...</code></pre>
<h4 id="whatis-显示非常简洁的命令说明"><a class="markdownIt-Anchor" href="#whatis-显示非常简洁的命令说明"></a> whatis 显示非常简洁的命令说明</h4>
<p>whatis 程序显示匹配特定关键字的手册页的名字和一行命令说明：</p>
<blockquote>
<p>最晦涩难懂的手册页</p>
<p>正如我们所看到的，Linux 和类 Unix 的系统提供的手册页，只是打算作为参考手册使用， 而不是教材。许多手册页都很难阅读，但是我认为由于阅读难度而能拿到特等奖的手册页应该是 bash 手册页。因为我正在为这本书做我的研究，所以我很仔细地浏览了整个 bash 手册，为的是确保我讲述了 大部分的 bash 主题。当把 bash 参考手册整个打印出来，其篇幅有八十多页且内容极其紧密， 但对于初学者来说，其结构安排毫无意义。</p>
<p>另一方面，bash 参考手册的内容非常简明精确，同时也非常完善。所以，如果你有胆量就查看一下， 并且期望有一天你能读懂它。</p>
</blockquote>
<h3 id="alias-创建自己的命令"><a class="markdownIt-Anchor" href="#alias-创建自己的命令"></a> alias 创建自己的命令</h3>
<p>现在是时候，感受第一次编程经历了！我们将用 alias 命令创建我们自己的命令。但在 开始之前，我们需要展示一个命令行小技巧。<strong>可以把多个命令放在同一行上，命令之间 用”;”分开</strong>。它像这样工作：</p>
<pre><code class="highlight plaintext">command1; command2; command3...</code></pre>
<p>我们会用到下面的例子：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ cd /usr; ls; cd -
bin  games    kerberos  lib64    local  share  tmp
...
[me@linuxbox ~]$</code></pre>
<p>正如我们看到的，我们在一行上联合了三个命令。首先更改目录到/usr，然后列出目录 内容，最后回到原始目录（用命令”cd ~”）,结束在开始的地方。现在，通过 alia 命令 把这一串命令转变为一个命令。我们要做的第一件事就是为我们的新命令构想一个名字。 比方说”test”。在使用”test”之前，查明是否”test”命令名已经存在系统中，是个很不错 的主意。为了查清此事，可以使用 type 命令：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ type test
test is a shell builtin</code></pre>
<p>哦！”test”名字已经被使用了。试一下”foo”:</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ type foo
bash: type: foo: not found</code></pre>
<p>太棒了！”foo”还没被占用。创建命令别名：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ alias foo=&#x27;cd /usr; ls; cd -&#x27;</code></pre>
<p><strong>创建命令</strong> 注意命令结构：</p>
<pre><code class="highlight plaintext">alias name=&#x27;string&#x27;</code></pre>
<blockquote>
<p>在命令”alias”之后，输入“name”，紧接着（没有空格）是一个等号，等号之后是 一串用引号引起的字符串，字符串的内容要赋值给 name。我们定义了别名之后， 这个命令别名可以使用在任何地方。</p>
</blockquote>
<p><strong>删除别名</strong></p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ unalias foo
[me@linuxbox ~]$ type foo
bash: type: foo: not found</code></pre>
<p><strong>查看所有的别名</strong></p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ alias
alias l.=&#x27;ls -d .* --color=tty&#x27;</code></pre>
<h3 id="命令执行顺序"><a class="markdownIt-Anchor" href="#命令执行顺序"></a> 命令执行顺序</h3>
<p>Linux顺序执行共有三种符号：</p>
<ul>
<li><strong>command1 &amp;&amp; command2</strong>: &amp;&amp;左边的command1执行成功(返回0表示成功)后，&amp;&amp;右边的command2才能被执行。</li>
<li><strong>command1 || command2</strong>: 如果||左边的command1执行失败(返回1表示失败)，就执行&amp;&amp;右边的command2。</li>
<li><strong>command1 ; command2</strong>: 命令顺序执行</li>
</ul>
<pre><code class="highlight plaintext">#第一个命令执行不成功,第二个命令才执行
[tough@toughhou shell]cata||touchacat:a:Nosuchfileordirectory
[tough@toughhoushell]  ls
 a  getpath.sh
 
#第一个命令执行成功,第二个命令不执行
[tough@toughhou shell]cata||touchb
[tough@toughhoushell]  ls
 a  getpath.sh
 
#只有第一个命令(touch a)执行成功,才执行第二个命令(touch b)
 [tough@toughhou shell]touch a &amp;&amp; touch b
[tough@toughhou shell] ls
 a  b  getpath.sh
 
#因为第一个命令执行不成功,所以第二个命令没执行
[tough@toughhou shell]cat a1 &amp;&amp; touch c
    cat: a1: No such file or directory
    [tough@toughhou shell] ls
 a  b  getpath.sh
 
#命令顺序执行
[tough@toughhou shell]$ pwd;more a;date
 /home/tough/shell
 123
 Sun Oct 13 10:24:55 CST 2013 &lt;br&gt;&lt;br data-tomark-pass&gt;&lt;br data-tomark-pass&gt;</code></pre>
<h2 id="命令展开"><a class="markdownIt-Anchor" href="#命令展开"></a> 命令展开</h2>
<p>每一次你输入一个命令，然后按下 enter 键，在 bash 执行你的命令之前，bash 会对输入 的字符完成几个步骤处理。我们已经知道两三个案例，怎样一个简单的字符序列，例如<code>“*”</code>, 对 shell 来说，有很多的涵义。</p>
<p>使这个发生的过程叫做（字符）展开。通过展开， 你输入的字符，在 shell 对它起作用之前，会展开成为别的字符。</p>
<h3 id="路径名展开"><a class="markdownIt-Anchor" href="#路径名展开"></a> 路径名展开</h3>
<p>这种通配符工作机制叫做路径名展开。如果我们试一下在之前的章节中使用的技巧， 我们会看到它们真是要展开的字符。给出一个家目录，它看起来像这样：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ ls
Desktop   ls-output.txt   Pictures   Templates
....</code></pre>
<p>我们能够执行以下参数展开模式：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ echo D*
Desktop  Documents</code></pre>
<p>和：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ echo *s
Documents Pictures Templates Videos</code></pre>
<p>甚至是：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ echo [[:upper:]]*
Desktop Documents Music Pictures Public Templates Videos</code></pre>
<p>查看家目录之外的目录：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ echo /usr/*/share
/usr/kerberos/share  /usr/local/share</code></pre>
<h3 id="波浪线展开"><a class="markdownIt-Anchor" href="#波浪线展开"></a> 波浪线展开</h3>
<p>可能你从我们对 cd 命令的介绍中回想起来，波浪线字符(“~”)有特殊的意思。当它用在 一个单词的开头时，它会展开成指定用户的家目录名，如果没有指定用户名，则是当前用户的家目录：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ echo ~
/home/me</code></pre>
<p>如果有用户”foo”这个帐号，然后：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ echo ~foo
/home/foo</code></pre>
<h3 id="算数表达式展开"><a class="markdownIt-Anchor" href="#算数表达式展开"></a> 算数表达式展开</h3>
<p>shell 允许算术表达式通过展开来执行。这允许我们把 shell 提示当作计算器来使用：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ echo $((2 + 2))
4</code></pre>
<p>算术表达式展开使用这种格式：</p>
<pre><code class="highlight plaintext">$((expression))</code></pre>
<p>（以上括号中的）表达式是指算术表达式，它由数值和算术操作符组成。算术表达式只支持整数（全部是数字，不带小数点），但是能执行很多不同的操作。这里是 一些它支持的操作符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
</tr>
<tr>
<td>/</td>
<td>除（但是记住，因为展开只是支持整数除法，所以结果是整数。）</td>
</tr>
<tr>
<td>%</td>
<td>取余，只是简单的意味着，“余数”</td>
</tr>
<tr>
<td>**</td>
<td>取幂</td>
</tr>
</tbody>
</table>
<p>在算术表达式中空格并不重要，并且表达式可以嵌套。例如，5的平方乘以3：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ echo $(($((5**2)) * 3))
75</code></pre>
<p>一对括号可以用来把多个子表达式括起来。通过这个技术，我们可以重写上面的例子， 同时用一个展开代替两个，来得到一样的结果：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ echo $(((5**2) * 3))
75</code></pre>
<p>这是一个使用除法和取余操作符的例子。注意整数除法的结果：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ echo Five divided by two equals $((5/2))
Five divided by two equals 2[me@linuxbox ~]$ echo with $((5%2)) left over.
with 1 left over.</code></pre>
<h3 id="花括号展开"><a class="markdownIt-Anchor" href="#花括号展开"></a> 花括号展开</h3>
<p>可能最奇怪的展开是花括号展开。通过它，你可以从一个包含花括号的模式中 创建多个文本字符串。这是一个例子：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ echo Front-&#123;A,B,C&#125;-Back
Front-A-Back Front-B-Back Front-C-Back</code></pre>
<p>花括号展开模式可能包含一个开头部分叫做报头，一个结尾部分叫做附言。花括号表达式本身可 能包含一个由逗号分开的字符串列表，或者一系列整数，或者单个的字符串。这种模式不能 嵌入空白字符。这个例题使用了一系列整数：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ echo Number_&#123;1..5&#125;
Number_1  Number_2  Number_3  Number_4  Number_5</code></pre>
<p>例如， 如果我们是摄影师，有大量的相片。我们想把这些相片按年月先后组织起来。首先， 我们要创建一系列以数值”年－月”形式命名的目录。通过这种方式，目录名按照 年代顺序排列。我们可以键入整个目录列表，但是工作量太大了，并且易于出错。 反而，我们可以这样做：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ mkdir Pics
[me@linuxbox ~]$ cd Pics
[me@linuxbox Pics]$ mkdir &#123;2007..2009&#125;-0&#123;1..9&#125; &#123;2007..2009&#125;-&#123;10..12&#125;[me@linuxbox Pics]$ ls
2007-01 2007-07 2008-01 2008-07 2009-01 2009-072007-02 2007-08 2008-02 2008-08 2009-02 2009-082007-03 2007-09 2008-03 2008-09 2009-03 2009-092007-04 2007-10 2008-04 2008-10 2009-04 2009-102007-05 2007-11 2008-05 2008-11 2009-05 2009-112007-06 2007-12 2008-06 2008-12 2009-06 2009-12</code></pre>
<h3 id="双引号"><a class="markdownIt-Anchor" href="#双引号"></a> 双引号</h3>
<p>我们将要看一下引用的第一种类型，双引号。如果你把文本放在双引号中， shell 使用的特殊字符，除了 <code>$，\ (反斜杠），和 </code>（倒引号）之外`， 则失去它们的特殊含义，被当作普通字符来看待。这意味着单词分割，路径名展开， 波浪线展开，和花括号展开都被禁止，然而参数展开，算术展开，和命令替换 仍然执行。使用双引号，我们可以处理包含空格的文件名。比方说我们是不幸的 名为 two words.txt 文件的受害者。如果我们试图在命令行中使用这个 文件，单词分割机制会导致这个文件名被看作两个独自的参数，而不是所期望 的单个参数：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ ls -l two words.txt
ls: cannot access two: No such file or directory
ls: cannot access words.txt: No such file or directory</code></pre>
<p>使用双引号，我们可以阻止单词分割，得到期望的结果；进一步，我们甚至可以修复 破损的文件名。</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ ls -l &quot;two words.txt&quot;-rw-rw-r-- 1 me   me   18 2008-02-20 13:03 two words.txt
[me@linuxbox ~]$ mv &quot;two words.txt&quot; two_words.txt</code></pre>
<p>你瞧！现在我们不必一直输入那些讨厌的双引号了。记住，在双引号中，参数展开，算术表达式展开，和命令替换仍然有效：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ echo &quot;$USER $((2+2)) $(cal)&quot;
me 4    February 2008
Su Mo Tu We Th Fr Sa</code></pre>
<p>在默认情况下，单词分割机制会在单词中寻找空格，制表符，和换行符，并把它们看作 单词之间的界定符。它们只作为分隔符使用。因为它们把单词分为不同的参数，在范例中， 命令行包含一个带有四个不同参数的命令。如果我们加上双引号：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ echo this is a   test
this is a test

[me@linuxbox ~]$ echo &quot;this is a    test&quot;
this is a    test</code></pre>
<p>单词分割被禁止，内嵌的空格也不会被当作界定符，它们成为参数的一部分。 一旦加上双引号，我们的命令行就包含一个带有一个参数的命令。</p>
<h3 id="单引号"><a class="markdownIt-Anchor" href="#单引号"></a> 单引号</h3>
<p>如果需要禁止所有的展开，我们使用单引号。以下例子是无引用，双引号，和单引号的比较结果：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ echo text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER
text /home/me/ls-output.txt a b foo 4 me
[me@linuxbox ~]$ echo &quot;text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER&quot;
text ~/*.txt   &#123;a,b&#125; foo 4 me
[me@linuxbox ~]$ echo &#x27;text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER&#x27;
text ~/*.txt  &#123;a,b&#125; $(echo foo) $((2+2)) $USER</code></pre>
<blockquote>
<p>正如我们所看到的，随着引用程度加强，越来越多的展开被禁止。</p>
</blockquote>
<h3 id="转义字符"><a class="markdownIt-Anchor" href="#转义字符"></a> 转义字符</h3>
<p>有时候我们只想引用单个字符。我们可以在字符之前加上一个反斜杠，在这个上下文中叫做转义字符。 经常在双引号中使用转义字符，来有选择地阻止展开。</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ echo &quot;The balance for user $USER is: \$5.00&quot;
The balance for user me is: $5.00</code></pre>
<p>使用转义字符来消除文件名中一个字符的特殊含义，是很普遍的。例如，在文件名中可能使用 一些对于 shell 来说，有特殊含义的字符。这些字符包括”$”, “!”, “ “等字符。在文件名 中包含特殊字符，你可以这样做：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ mv bad\&amp;filename good_filename</code></pre>
<blockquote>
<p>为了允许反斜杠字符出现，输入”\“来转义。注意在单引号中，反斜杠失去它的特殊含义，它 被看作普通字符。</p>
</blockquote>
<h2 id="系统命令"><a class="markdownIt-Anchor" href="#系统命令"></a> 系统命令</h2>
<h3 id="常用系统工作命令"><a class="markdownIt-Anchor" href="#常用系统工作命令"></a> 常用系统工作命令</h3>
<h4 id="echo"><a class="markdownIt-Anchor" href="#echo"></a> echo</h4>
<p>echo命令用于<strong>在终端输出字符串或变量提取后的值</strong>，格式为</p>
<pre><code class="highlight plaintext">echo [字符串 | $变量]</code></pre>
<p>例如，把指定字符串“<a target="_blank" rel="noopener" href="http://Linuxprobe.com">Linuxprobe.com</a>”输出到终端屏幕的命令为：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# echo Linuxprobe.Com</code></pre>
<p>该命令会在终端屏幕上显示如下信息：</p>
<pre><code class="highlight plaintext">Linuxprobe.Com</code></pre>
<p>下面，我们使用$变量的方式提取变量SHELL的值，并将其输出到屏幕上：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# echo $SHELL/bin/bash</code></pre>
<h4 id="date"><a class="markdownIt-Anchor" href="#date"></a> date</h4>
<p>date命令用于<strong>显示及设置系统的时间或日期</strong>，格式为</p>
<pre><code class="highlight plaintext">date [选项] [+指定的格式]</code></pre>
<p>只需在强大的<strong>date命令中输入以“+”号开头的参数，即可按照指定格式来输出系统的时间或日期</strong>，这样在日常工作时便可以把备份数据的命令与指定格式输出的时间信息结合到一起。例如，把打包后的文件自动按照“年-月-日”的格式打包成“backup-2017-9-1.tar.gz”，用户只需要看一眼文件名称就能大概了解到每个文件的备份时间了。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>%t</td>
<td>跳格[Tab键]</td>
</tr>
<tr>
<td>%Y</td>
<td>年</td>
</tr>
<tr>
<td>%m</td>
<td>月</td>
</tr>
<tr>
<td>%d</td>
<td>日</td>
</tr>
<tr>
<td>%H</td>
<td>小时（00～23）</td>
</tr>
<tr>
<td>%I</td>
<td>小时（00～12）</td>
</tr>
<tr>
<td>%M</td>
<td>分钟（00～59）</td>
</tr>
<tr>
<td>%S</td>
<td>秒（00～59）</td>
</tr>
<tr>
<td>%j</td>
<td>今年中的第几天</td>
</tr>
</tbody>
</table>
<p>按照默认格式查看当前系统时间的date命令如下所示：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# date
Mon Aug 24 16:11:23 CST 2017</code></pre>
<p>按照“年-月-日 小时:分钟:秒”的格式查看当前系统时间的date命令如下所示：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# date &quot;+%Y-%m-%d %H:%M:%S&quot;
2017-08-24 16:29:12</code></pre>
<p>将<strong>系统的当前时间设置</strong>为2017年9月1日8点30分的date命令如下所示：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# date -s &quot;20170901 8:30:00&quot;
Fri Sep 1 08:30:00 CST 2017</code></pre>
<p>date命令中的参数%j可用来查看今天是当年中的第几天。这个参数能够很好地区分备份时间的新旧，即数字越大，越靠近当前时间。该参数的使用方式以及显示结果如下所示。</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# date &quot;+%j&quot;
244</code></pre>
<p>设置系统时间命令：</p>
<pre><code class="highlight plaintext">#date –set（月/日/年 时：分：秒）

例：#date –set “10/11/10 10:15”</code></pre>
<p>查看硬件时间的命令：</p>
<pre><code class="highlight plaintext"># hwclock</code></pre>
<p>设置硬件时间的命令：</p>
<pre><code class="highlight plaintext"># hwclock –set –date = （月/日/年 时：分：秒）</code></pre>
<blockquote>
<p>上述提到的是手动设置时间到一个时间点，可能与当前网络的时间有误差。下面介绍一下与时间服务器上的时间同步的方法</p>
</blockquote>
<p><strong>设置系统时间与网络时间同步</strong></p>
<ol>
<li>安装ntpdate工具</li>
</ol>
<pre><code class="highlight plaintext">yum -y install ntp ntpdate</code></pre>
<ol>
<li>设置系统时间与网络时间同步</li>
</ol>
<pre><code class="highlight plaintext">ntpdate cn.pool.ntp.org

or =&gt;   ntpdate -u ntp.api.bz</code></pre>
<ol>
<li>将系统时间写入硬件时间</li>
</ol>
<pre><code class="highlight plaintext">hwclock –w</code></pre>
<ol>
<li>查看硬件时</li>
</ol>
<pre><code class="highlight plaintext">hwclock -show</code></pre>
<h4 id="reboot重启poweroff关机"><a class="markdownIt-Anchor" href="#reboot重启poweroff关机"></a> reboot重启/poweroff关机</h4>
<p><strong>reboot命令</strong>用于<strong>重启系统</strong></p>
<p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此默认只能使用root管理员来重启，其命令如下：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# reboot</code></pre>
<hr />
<p><strong>poweroff命令</strong>用于<strong>关闭系统</strong></p>
<p>该命令与reboot命令相同，都会涉及硬件资源的管理权限，因此默认只有root管理员才可以关闭电脑，其命令如下：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# poweroff</code></pre>
<h4 id="susudo"><a class="markdownIt-Anchor" href="#susudo"></a> su/sudo</h4>
<p><strong>su命令可以解决切换用户身份的需求</strong>，使得当前用户在不退出登录的情况下，顺畅地切换到其他用户，比如从root管理员切换至普通用户：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# id 
uid=0(root) gid=0(root) groups=0(root)
[root@linuxprobe ~]# su - linuxprobe
Last login: Wed Jan 4 01:17:25 EST 2017 on pts/0
[linuxprobe@linuxprobe ~]$ id 
uid=1000(linuxprobe) gid=1000(linuxprobe) groups=1000(linuxprobe) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</code></pre>
<blockquote>
<p>su命令与用户名之间有一个<strong>减号</strong>（-），这意味着完全切换到新的用户，即<strong>把环境变量信息也变更为新用户的相应信息</strong>，而不是保留原始的信息。强烈建议在切换用户身份时添加这个减号（-）</p>
</blockquote>
<blockquote>
<p>当从root管理员切换到普通用户时是不需要密码验证的，而从普通用户切换成root管理员就需要进行密码验证了</p>
</blockquote>
<hr />
<p><strong>使用sudo命令把特定命令的执行权限赋予给指定用户</strong>，这样既可保证普通用户能够完成特定的工作，也可以避免泄露root管理员密码。我们要做的就是合理配置sudo服务，以便兼顾系统的安全性和用户的便捷性。sudo服务的配置原则也很简单—在保证普通用户完成相应工作的前提下，尽可能少地赋予额外的权限。</p>
<p>sudo命令用于给普通用户提供额外的权限来完成原本root管理员才能完成的任务，格式为</p>
<pre><code class="highlight plaintext">sudo [参数] 命令名称</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-h</td>
<td>列出帮助信息</td>
</tr>
<tr>
<td>-l</td>
<td>列出当前用户可执行的命令</td>
</tr>
<tr>
<td>-u</td>
<td>用户名或UID值 以指定的用户身份执行命令</td>
</tr>
<tr>
<td>-k</td>
<td>清空密码的有效时间，下次执行sudo时需要再次进行密码验证</td>
</tr>
<tr>
<td>-b</td>
<td>在后台执行指定的命令</td>
</tr>
<tr>
<td>-p</td>
<td>更改询问密码的提示语</td>
</tr>
</tbody>
</table>
<h4 id="systemctl"><a class="markdownIt-Anchor" href="#systemctl"></a> systemctl</h4>
<p>在RHEL 7系统中是使用systemctl命令来管理服务的。</p>
<p>管理服务RHEL6与RHEL7管理服务的差别：</p>
<table>
<thead>
<tr>
<th>System V init命令（RHEL 6系统）</th>
<th>systemctl命令（RHEL 7系统） 作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>service foo start</td>
<td>systemctl startfoo.service 启动服务</td>
</tr>
<tr>
<td>service foo restart</td>
<td>systemctl restartfoo.service 重启服务</td>
</tr>
<tr>
<td>service foo stop</td>
<td>systemctl stop foo.service 停止服务</td>
</tr>
<tr>
<td>service foo reload</td>
<td>systemctl reload foo.service 重新加载配置文件（不终止服务）</td>
</tr>
<tr>
<td>service foo status</td>
<td>systemctl status foo.service 查看服务状态表</td>
</tr>
<tr>
<td>chkconfig foo on</td>
<td>systemctl enable foo.service 开机自动启动</td>
</tr>
<tr>
<td>chkconfig foo off</td>
<td>systemctl disable foo.service 开机不自动启动</td>
</tr>
<tr>
<td>chkconfig foo</td>
<td>systemctl is-enabled foo.service 查看特定服务是否为开机自启动</td>
</tr>
<tr>
<td>chkconfig —list</td>
<td>systemctl list-unit-files — type=service查看各个级别下服务的启动与禁用情况</td>
</tr>
</tbody>
</table>
<p><strong>自定义systemctl命令启动服务</strong></p>
<p>在/usr/lib/systemd/system路径中自定义一个以.service结尾的脚本。</p>
<ul>
<li>定义完成后即可使用systemctl start sdmclient/systemctl stop sdmclient等命令</li>
</ul>
<p>如 sdmclient.service：</p>
<pre><code class="highlight plaintext">[Unit]
Description=sdmclient
After=network.target

[Service]
Type=forking
ExecStart=/bin/bash /opt/SDM/client/client-cmds/Common/Linux/sdmclient7 start
ExecReload=/bin/bash /opt/SDM/client/client-cmds/Common/Linux/sdmclient7 restart
ExecStop=/bin/bash /opt/SDM/client/client-cmds/Common/Linux/sdmclient7 stop
User=root

[Install]
WantedBy=multi-user.target</code></pre>
<h3 id="系统状态检测命令"><a class="markdownIt-Anchor" href="#系统状态检测命令"></a> 系统状态检测命令</h3>
<p>作为一名合格的运维人员，想要更快、更好地了解Linux服务器，必须具备快速查看Linux系统运行状态的能力，因此接下来会逐个讲解与网卡网络、系统内核、系统负载、内存使用情况、当前启用终端数量、历史登录记录、命令执行记录以及救援诊断等相关命令的使用方法。这些命令都超级实用，还请读者用心学习，加以掌握</p>
<h4 id="ifconfig命令"><a class="markdownIt-Anchor" href="#ifconfig命令"></a> ifconfig命令</h4>
<p>ifconfig命令用于<strong>获取网卡配置与网络状态等信息</strong>，格式为</p>
<pre><code class="highlight plaintext">ifconfig [网络设备] [参数]</code></pre>
<p>使用ifconfig命令来查看本机当前的网卡配置与网络状态等信息时，其实主要查看的就是网卡名称、inet参数后面的IP地址、ether参数后面的网卡物理地址（又称为MAC地址），以及RX、TX的接收数据包与发送数据包的个数及累计流量（即下面加粗的信息内容）：</p>
<p><img src="image/-10.png" alt="-10.png" /></p>
<h4 id="uname命令"><a class="markdownIt-Anchor" href="#uname命令"></a> uname命令</h4>
<p>uname命令用于<strong>查看系统内核与系统版本等信息</strong>，格式</p>
<pre><code class="highlight plaintext">uname [-a]</code></pre>
<p>在使用uname命令时，一般会固定搭配上-a参数来完整地查看当前系统的内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息。</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# uname -a
Linux linuxprobe.com 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2017 x86_64 x86_64 x86_64 GNU/Linux</code></pre>
<p>顺带一提，如果要查看当前系统版本的详细信息，则需要查看redhat-release文件，其命令以及相应的结果如下：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# cat /etc/redhat-releaseRed 
Hat Enterprise Linux Server release 7.0 (Maipo)</code></pre>
<h4 id="uptime命令"><a class="markdownIt-Anchor" href="#uptime命令"></a> uptime命令</h4>
<p>uptime用于<strong>查看系统的负载信息</strong>，格式为</p>
<pre><code class="highlight plaintext">uptime</code></pre>
<p>uptime命令真的很棒，它可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息。平均负载值指的是系统在最近1分钟、5分钟、15分钟内的压力情况（下面加粗的信息部分）；负载值越低越好，尽量不要长期超过1，在生产环境中不要超过5。</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# uptime
22:49:55 up 10 min, 2 users, load average: 0.01, 0.19, 0.18</code></pre>
<h4 id="free命令"><a class="markdownIt-Anchor" href="#free命令"></a> free命令</h4>
<p>free用于<strong>显示当前系统中内存的使用量信息</strong>，格式为</p>
<pre><code class="highlight plaintext">free [-h]</code></pre>
<p>为了保证Linux系统不会因资源耗尽而突然宕机，运维人员需要时刻关注内存的使用量。在使用free命令时，可以结合使用-h参数以更人性化的方式输出当前内存的实时使用量信息。</p>
<p>执行free -h命令后的输出信息</p>
<table>
<thead>
<tr>
<th></th>
<th>内存总量</th>
<th>已用量</th>
<th>可用量</th>
<th>进程共享的内存量</th>
<th>磁盘缓存的内存量</th>
<th>缓存的内存量</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>total</td>
<td>used</td>
<td>free</td>
<td>shared</td>
<td>buffers</td>
<td>cached</td>
</tr>
<tr>
<td>Mem:</td>
<td>1.8G</td>
<td>1.3G</td>
<td>542M</td>
<td>9.8M</td>
<td>1.6M</td>
<td>413M</td>
</tr>
<tr>
<td>Swap:</td>
<td>2.0G</td>
<td>0B</td>
<td>2.0G</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="who"><a class="markdownIt-Anchor" href="#who"></a> who</h4>
<p>who用于<strong>查看当前登入主机的用户终端信息</strong></p>
<pre><code class="highlight plaintext">who [参数]</code></pre>
<p>这三个简单的字母可以快速显示出所有正在登录本机的用户的名称以及他们正在开启的终端信息。</p>
<p>执行who命令的结果：</p>
<table>
<thead>
<tr>
<th>登陆的用户名</th>
<th>终端设备</th>
<th>登陆到系统的时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>root</td>
<td>pts/0</td>
<td>2020-06-04 09:16 (192.168.212.156)</td>
</tr>
<tr>
<td>root</td>
<td>pts/1</td>
<td>2020-06-10 09:35 (192.168.212.165)</td>
</tr>
<tr>
<td>root</td>
<td>pts/2</td>
<td>2020-06-04 09:06 (192.168.212.156)</td>
</tr>
<tr>
<td>root</td>
<td>pts/4</td>
<td>2020-06-09 15:20 (192.168.212.156)</td>
</tr>
<tr>
<td>root</td>
<td>pts/8</td>
<td>2020-06-08 09:55 (192.168.212.189)</td>
</tr>
<tr>
<td>root</td>
<td>pts/9</td>
<td>2020-06-08 10:17 (192.168.212.189)</td>
</tr>
<tr>
<td>root</td>
<td>pts/10</td>
<td>2020-06-08 10:18 (192.168.212.189)</td>
</tr>
</tbody>
</table>
<h4 id="last"><a class="markdownIt-Anchor" href="#last"></a> last</h4>
<p>last命令用于<strong>查看所有系统的登录记录</strong>，格式为</p>
<pre><code class="highlight plaintext">last [参数]</code></pre>
<p>使用last命令可以查看本机的登录记录。但是，由于这些信息都是以日志文件的形式保存在系统中，因此黑客可以很容易地对内容进行篡改。千万不要单纯以该命令的输出信息而判断系统有无被恶意入侵！</p>
<p><img src="image/-11.png" alt="-11.png" /></p>
<h4 id="history"><a class="markdownIt-Anchor" href="#history"></a> history</h4>
<p>history命令用于<strong>显示历史执行过的命令</strong>，格式为</p>
<pre><code class="highlight plaintext">history [-c]</code></pre>
<p>history命令应该是作者最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，还可以自定义/etc/profile文件中的HISTSIZE变量值。在使用history命令时，如果使用-c参数则会清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p>
<p><img src="image/-12.png" alt="-12.png" /></p>
<p>要<strong>清空当前用户在本机上执行的Linux命令历史记录信息</strong>，可执行如下命令：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# history -c</code></pre>
<h3 id="配置主机名称"><a class="markdownIt-Anchor" href="#配置主机名称"></a> 配置主机名称</h3>
<p>为了便于在局域网中查找某台特定的主机，或者对主机进行区分，除了要有IP地址外，还要为主机配置一个主机名，主机之间可以通过这个类似于域名的名称来相互访问。在Linux系统中，主机名大多保存在/etc/hostname文件中，接下来将/etc/hostname文件的内容修改为“<a target="_blank" rel="noopener" href="http://linuxprobe.com">linuxprobe.com</a>”，步骤如下。</p>
<ul>
<li>第1步：使用Vim编辑器修改“/etc/hostname”主机名称文件。</li>
<li>第2步：把原始主机名称删除后追加“<a target="_blank" rel="noopener" href="http://linuxprobe.com">linuxprobe.com</a>”。注意，使用Vim编辑器修改主机名称文件后，要在末行模式下执行:wq!命令才能保存并退出文档。</li>
<li>第3步：保存并退出文档，然后使用hostname命令检查是否修改成功。</li>
</ul>
<pre><code class="highlight plaintext">$ vim /etc/hostname
linuxprobe.com</code></pre>
<p>hostname命令用于查看当前的主机名称，但有时主机名称的改变不会立即同步到系统中，所以如果发现修改完成后还显示原来的主机名称，可重启虚拟机后再行查看：</p>
<pre><code class="highlight plaintext">$ hostname
linuxprobe.com</code></pre>
<h3 id="配置网卡信息"><a class="markdownIt-Anchor" href="#配置网卡信息"></a> 配置网卡信息</h3>
<p>网卡IP地址配置的是否正确是两台服务器是否可以相互通信的前提。在Linux系统中，一切都是文件，因此配置网络服务的工作其实就是在编辑网卡配置文件.</p>
<p>如果您具备一定的运维经验或者熟悉早期的Linux系统，则在学习本书时会遇到一些不容易接受的差异变化。在RHEL 5、RHEL 6中，网卡配置文件的前缀为eth，第1块网卡为eth0，第2块网卡为eth1；以此类推。而在RHEL 7中，网卡配置文件的前缀则以ifcfg开始，加上网卡名称共同组成了网卡配置文件的名字，例如ifcfg-eno16777736；好在除了文件名变化外也没有其他大的区别。</p>
<p>现在有一个名称为ifcfg-eno16777736的网卡设备，我们将其配置为开机自启动，并且IP地址、子网、网关等信息由人工指定，其步骤应该如下所示。</p>
<ul>
<li>第1步：首先<strong>切换到/etc/sysconfig/network-scripts目录</strong>中（存放着网卡的配置文件）。</li>
<li>第2步：使用Vim编辑器修改网卡文件ifcfg-eno16777736，逐项写入下面的配置参数并保存退出。由于每台设备的硬件及架构是不一样的，因此请读者使用ifconfig命令自行确认各自网卡的默认名称。</li>
</ul>
<pre><code class="highlight plaintext">设备类型：TYPE=Ethernet
地址分配模式：BOOTPROTO=static
网卡名称：NAME=eno16777736
是否启动：ONBOOT=yes
IP地址：IPADDR=192.168.10.10
子网掩码：NETMASK=255.255.255.0
网关地址：GATEWAY=192.168.10.1DNS
地址：DNS1=192.168.10.1</code></pre>
<ul>
<li>第3步：重启网络服务并测试网络是否联通。</li>
</ul>
<p>进入到网卡配置文件所在的目录，然后编辑网卡配置文件，在其中填入下面的信息：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# cd /etc/sysconfig/network-scripts/
[root@linuxprobe network-scripts]# vim ifcfg-eno16777736
TYPE=Ethernet
BOOTPROTO=static
NAME=eno16777736
ONBOOT=yes
IPADDR=192.168.10.10
NETMASK=255.255.255.0
GATEWAY=192.168.10.1
DNS1=192.168.10.1</code></pre>
<p>执行<strong>重启网卡设备的命令</strong>（在正常情况下不会有提示信息），然后通过ping命令测试网络能否联通。由于在Linux系统中ping命令不会自动终止，因此需要手动按下Ctrl-c键来强行结束进程。</p>
<pre><code class="highlight plaintext">[root@linuxprobe network-scripts]# systemctl restart network
[root@linuxprobe network-scripts]# ping 192.168.10.10
PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.
64 bytes from 192.168.10.10: icmp_seq=1 ttl=64 time=0.081 ms
64 bytes from 192.168.10.10: icmp_seq=2 ttl=64 time=0.083 ms
64 bytes from 192.168.10.10: icmp_seq=3 ttl=64 time=0.059 ms
64 bytes from 192.168.10.10: icmp_seq=4 ttl=64 time=0.097 ms
^C
--- 192.168.10.10 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 2999ms
rtt min/avg/max/mdev = 0.059/0.080/0.097/0.013 ms</code></pre>
<h3 id="yum"><a class="markdownIt-Anchor" href="#yum"></a> Yum</h3>
<p>yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。</p>
<p>基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p>
<p>yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>
<p>语法:</p>
<pre><code class="highlight plaintext">yum [options] [command] [package ...]</code></pre>
<ul>
<li>options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为&quot;yes&quot;），-q（不显示安装的过程）等等。</li>
<li>command：要进行的操作。</li>
<li>package操作的对象。</li>
</ul>
<hr />
<ul>
<li>1.列出所有可更新的软件清单命令：yum check-update</li>
<li>2.更新所有软件命令：yum update</li>
<li>3.仅安装指定的软件命令：yum install &lt;package_name&gt;</li>
<li>4.仅更新指定的软件命令：yum update &lt;package_name&gt;</li>
<li>5.列出所有可安裝的软件清单命令：yum list</li>
<li>6.删除软件包命令：yum remove &lt;package_name&gt;</li>
<li>7.查找软件包 命令：yum search <keyword></li>
<li>8.清除缓存命令:
<ul>
<li>yum clean packages: 清除缓存目录下的软件包</li>
<li>yum clean headers: 清除缓存目录下的 headers</li>
<li>yum clean oldheaders: 清除缓存目录下旧的 headers</li>
<li>yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers</li>
</ul>
</li>
</ul>
<h3 id="计划任务服务程序"><a class="markdownIt-Anchor" href="#计划任务服务程序"></a> 计划任务服务程序</h3>
<p>经验丰富的系统运维工程师可以使得Linux在无需人为介入的情况下，在指定的时间段自动启用或停止某些服务或命令，从而实现运维的自动化。尽管我们现在已经有了功能彪悍的脚本程序来执行一些批处理工作，但是，如果仍然需要在每天凌晨两点敲击键盘回车键来执行这个脚本程序，这简直太痛苦了（当然，也可以训练您的小猫在半夜按下回车键）。接下来，刘遄老师将向大家讲解如何设置服务器的计划任务服务，把周期性、规律性的工作交给系统自动完成</p>
<p>计划任务分为一次性计划任务与长期性计划任务，大家可以按照如下方式理解</p>
<ul>
<li><strong>一次性计划任务</strong>：今晚11点30分开启网站服务。</li>
<li><strong>长期性计划任务</strong>：每周一的凌晨3点25分把/home/wwwroot目录打包备份为backup.tar.gz。</li>
</ul>
<h4 id="一次性计划任务"><a class="markdownIt-Anchor" href="#一次性计划任务"></a> 一次性计划任务</h4>
<p>一次性计划任务只执行一次，一般用于满足临时的工作需求。我们可以用at命令实现这种功能，只需要写成“<strong>at 时间</strong>”的形式就可以。</p>
<p>如果想要<strong>查看</strong>已设置好但还未执行的一次性计划任务，可以使用“<strong>at -l</strong>”命令；要想将其<strong>删除</strong>，可以用“<strong>atrm</strong> 任务序号”</p>
<p>在使用at命令来设置一次性计划任务时，默认采用的是交互式方法。例如，使用下述命令将系统设置为在今晚23:30分自动重启网站服务。</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# at 23:30
at &gt; systemctl restart httpd
at &gt; 此处请同时按下Ctrl+d来结束编写计划任务
job 3 at Mon Apr 27 23:30:00 2015
[root@linuxprobe ~]# at -l
3 Mon Apr 27 23:30:00 2016 a root</code></pre>
<p>想挑战一下难度更大但简捷性更高的方式，可以把前面学习的管道符（任意门）放到两条命令之间，让at命令接收前面echo命令的输出信息，以达到通过非交互式的方式创建计划一次性任务的目的。</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# echo &quot;systemctl restart httpd&quot; | at 23:30
job 4 at Mon Apr 27 23:30:00 2015
[root@linuxprobe ~]# at -l
3 Mon Apr 27 23:30:00 2016 a root
4 Mon Apr 27 23:30:00 2016 a root
</code></pre>
<p>如果我们不小心设置了两个一次性计划任务，可以使用下面的命令轻松<strong>删除其中一个</strong>：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# atrm 3
[root@linuxprobe ~]# at -l
4 Mon Apr 27 23:30:00 2016 a root</code></pre>
<h4 id="长期性计划任务"><a class="markdownIt-Anchor" href="#长期性计划任务"></a> 长期性计划任务</h4>
<p>如果我们希望Linux系统能够周期性地、有规律地执行某些具体的任务，那么Linux系统中默认启用的crond服务简直再适合不过了。</p>
<ul>
<li>创建、编辑计划任务的命令为“<strong>crontab -e</strong>”</li>
<li>查看当前计划任务的命令为“<strong>crontab -l</strong>”</li>
<li>删除某条计划任务的命令为“<strong>crontab -r</strong>”</li>
</ul>
<p>另外，如果您是以管理员的身份登录的系统，还可以在crontab命令中加上-u参数来编辑他人的计划任务</p>
<p>在正式部署计划任务前，请先跟刘遄老师念一下口诀“分、时、日、月、星期 命令”。这是使用crond服务设置任务的参数格式（其格式见表4-6）。<strong>需要注意的是，如果有些字段没有设置，则需要使用星号<code>（*）</code>占位</strong>，如图所示。</p>
<p><img src="image/-13.png" alt="-13.png" /></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>分钟</td>
<td>取值为0～59的整数</td>
</tr>
<tr>
<td>小时</td>
<td>取值为0～23的任意整数</td>
</tr>
<tr>
<td>日期</td>
<td>取值为1～31的任意整数</td>
</tr>
<tr>
<td>月份</td>
<td>取值为1～12的任意整数</td>
</tr>
<tr>
<td>星期</td>
<td>取值为0～7的任意整数，其中0与7均为星期日</td>
</tr>
<tr>
<td>命令</td>
<td>要执行的命令或程序脚本</td>
</tr>
</tbody>
</table>
<p>假设在每周一、三、五的凌晨3点25分，都需要使用tar命令把某个网站的数据目录进行打包处理，使其作为一个备份文件。我们可以使用crontab -e命令来创建计划任务。为自己创建计划任务无需使用-u参数，具体的实现效果的参数如crontab -l命令结果所示：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# crontab -e
no crontab for root - using an empty one
crontab: installing new crontab</code></pre>
<blockquote>
<p>输入上述命令进入编辑器，键入下列语句即可</p>
</blockquote>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# crontab -l
25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar.gz /home/wwwroot</code></pre>
<p>需要说明的是，<strong>除了用逗号（,）来分别表示多个时间段</strong>，例如“8,9,12”表示8月、9月和12月。</p>
<p><strong>还可以用减号（-）来表示一段连续的时间周期</strong>（例如字段“日”的取值为“12-15”，则表示每月的12～15日）。</p>
<p><strong>以及用除号（/）表示执行任务的间隔时间</strong>（例如“*/2”表示每隔2分钟执行一次任务）。</p>
<p>如果在crond服务中需要同时包含多条计划任务的命令语句，应每行仅写一条。例如我们再添加一条计划任务，它的功能是每周一至周五的凌晨1点钟自动清空/tmp目录内的所有文件。尤其需要注意的是，在crond服务的计划任务参数中，所有命令一定要用绝对路径的方式来写，如果不知道绝对路径，请用whereis命令进行查询，rm命令路径为下面输出信息中加粗部分。</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# whereis rm
rm: /usr/bin/rm /usr/share/man/man1/rm.1.gz /usr/share/man/man1p/rm.1p.gz
[root@linuxprobe ~]# crontab -e
crontab: installing new crontab
[root@linuxprobe ~]# crontab -l
25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar.gz /home/wwwroot
0 1 * * 1-5 /usr/bin/rm -rf /tmp/*</code></pre>
<blockquote>
<p>在crond服务的配置参数中，可以像Shell脚本那样以#号开头写上注释信息，这样在日后回顾这段命令代码时可以快速了解其功能、需求以及编写人员等重要信息。</p>
</blockquote>
<blockquote>
<p><strong>计划任务中的“分”字段必须有数值</strong>，绝对不能为空或是<code>*</code>号，<strong>而“日”和“星期”字段不能同时使用</strong>，否则就会发生冲突</p>
</blockquote>
<h2 id="文件权限"><a class="markdownIt-Anchor" href="#文件权限"></a> 文件权限</h2>
<p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p>
<p>在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如：</p>
<pre><code class="highlight plaintext">[root@www /]# ls -l
total 64
dr-xr-xr-x   2 root root 4096 Dec 14  2012 bin
dr-xr-xr-x   4 root root 4096 Apr 19  2012 boot
……</code></pre>
<p>实例中，bin文件的第一个属性用&quot;d&quot;表示。&quot;d&quot;在Linux中代表该文件是一个目录文件。</p>
<p>在Linux中<strong>第一个字符</strong>代表：</p>
<ul>
<li>当为[ d ]则是目录</li>
<li>当为[ - ]则是文件；</li>
<li>若是[ l ]则表示为链接文档(link file)；</li>
<li>若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li>
<li>若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li>
</ul>
<p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表<strong>可读</strong>(read)、[ w ]代表<strong>可写</strong>(write)、[ x ]代表<strong>可执行</strong>(execute)。</p>
<p>要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。每个文件的属性由左边第一部分的10个字符来确定（如下图）</p>
<p><img src="image/-14.png" alt="-14.png" /></p>
<p>从左至右用0-9这些数字来表示。</p>
<ul>
<li>第0位确定文件类型</li>
<li>第1-3位确定属主（该文件的所有者）拥有该文件的权限。</li>
<li>第4-6位确定属组（所有者的同组用户）拥有该文件的权限</li>
<li>第7-9位确定其他用户拥有该文件的权限。</li>
</ul>
<hr />
<ul>
<li>第1、4、7位表示读权限，如果用&quot;r&quot;字符表示，则有读权限，如果用&quot;-&quot;字符表示，则没有读权限；</li>
<li>第2、5、8位表示写权限，如果用&quot;w&quot;字符表示，则有写权限，如果用&quot;-&quot;字符表示没有写权限；</li>
<li>第3、6、9位表示可执行权限，如果用&quot;x&quot;字符表示，则有执行权限，如果用&quot;-&quot;字符表示，则没有执行权限。</li>
</ul>
<h3 id="文件属主和属组"><a class="markdownIt-Anchor" href="#文件属主和属组"></a> 文件属主和属组</h3>
<pre><code class="highlight plaintext">[root@www /]# ls -l
total 64
drwxr-xr-x 2 root  root  4096 Feb 15 14:46 cron
drwxr-xr-x 3 mysql mysql 4096 Apr 21  2014 mysql
……</code></pre>
<p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p>
<p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p>
<p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p>
<p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p>
<p>在以上实例中，mysql 文件是一个目录文件，属主和属组都为 mysql，属主有可读、可写、可执行的权限；与属主同组的其他用户有可读和可执行的权限；其他用户也有可读和可执行的权限。</p>
<blockquote>
<p>对于 root 用户来说，一般情况下，文件的权限对其不起作用。</p>
</blockquote>
<h4 id="更改文件属组-chgrp"><a class="markdownIt-Anchor" href="#更改文件属组-chgrp"></a> 更改文件属组 chgrp</h4>
<p>语法：</p>
<pre><code class="highlight plaintext">chgrp [-R] 属组名 文件名</code></pre>
<p>参数选项</p>
<ul>
<li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li>
</ul>
<h4 id="更改文件属主-chown"><a class="markdownIt-Anchor" href="#更改文件属主-chown"></a> 更改文件属主 chown</h4>
<p>语法：</p>
<pre><code class="highlight plaintext">chown [–R] 属主名 文件名
chown [-R] 属主名:属组名 文件名</code></pre>
<p>案例：</p>
<ul>
<li>进入 /root 目录（~）将install.log的拥有者改为bin这个账号：</li>
</ul>
<pre><code class="highlight plaintext">[root@www ~] cd ~
[root@www ~]# chown bin install.log
[root@www ~]# ls -l
-rw-r--r--  1 bin  users 68495 Jun 25 08:53 install.log</code></pre>
<ul>
<li>将install.log的拥有者与群组改回为root：</li>
</ul>
<pre><code class="highlight plaintext">[root@www ~]# chown root:root install.log
[root@www ~]# ls -l
-rw-r--r--  1 root root 68495 Jun 25 08:53 install.log</code></pre>
<h3 id="文件权限-chmod"><a class="markdownIt-Anchor" href="#文件权限-chmod"></a> 文件权限 chmod</h3>
<p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p>
<p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p>
<hr />
<p><strong>数字类型更改文件权限</strong></p>
<p>语法：</p>
<pre><code class="highlight plaintext">chmod [-R] xyz 文件名 

// -R 代表递归，即目录下所有文件都会更改属性
// x 代表属主权限
// y 代表属组权限
// z 代表其他权限</code></pre>
<p>文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<ul>
<li>r ：4</li>
<li>w：2</li>
<li>x ：1</li>
</ul>
<p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：</p>
<ul>
<li>owner = rwx = 4+2+1 = 7</li>
<li>group = rwx = 4+2+1 = 7</li>
<li>others= — = 0+0+0 = 0</li>
</ul>
<p>所以等一下我们设定权限的变更时，该文件的权限数字就是770啦！变更权限的指令chmod的语法是这样的：</p>
<pre><code class="highlight plaintext">chmod [-R] xyz 文件或目录</code></pre>
<p>选项与参数：</p>
<ul>
<li>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。</li>
<li>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</li>
</ul>
<p>案例：</p>
<ul>
<li>举例来说，如果要将.bashrc这个文件所有的权限都设定启用，那么命令如下：</li>
</ul>
<pre><code class="highlight plaintext">[root@www ~]# ls -al .bashrc
-rw-r--r--  1 root root 395 Jul  4 11:45 .bashrc
[root@www ~]# chmod 777 .bashrc
[root@www ~]# ls -al .bashrc
-rwxrwxrwx  1 root root 395 Jul  4 11:45 .bashrc</code></pre>
<blockquote>
<p>那如果要将权限变成 -rwxr-xr-- 呢？那么权限的分数就成为 <code>[4+2+1][4+0+1][4+0+0]=754</code>。</p>
</blockquote>
<hr />
<p><strong>符号类型更改文件权限</strong></p>
<p>语法:</p>
<pre><code class="highlight plaintext">chmod [-R] u=rwx,g=rwx,o-rwx 文件名

// -R 代表递归，即目录下所有文件都会更改属性
// u 代表属主
// g 代表属组
// o 代表其他</code></pre>
<p>还有一个改变权限的方法，从之前的介绍中我们可以发现，基本上就九个权限分别是：</p>
<ul>
<li>(1)user</li>
<li>(2)group</li>
<li>(3)others</li>
</ul>
<p>那么我们就可以使用 u, g, o 来代表三种身份的权限！</p>
<p>此外， a 则代表 all，即全部的身份。读写的权限可以写成 r, w, x，也就是可以使用下表的方式来看：</p>
<p><img src="image/-15.png" alt="-15.png" /></p>
<p>案例：</p>
<ul>
<li>如果我们需要将文件权限设置为 -rwxr-xr-- ，可以使用 <code>chmod u=rwx,g=rx,o=r</code> 文件名 来设定:</li>
</ul>
<pre><code class="highlight plaintext">#  touch test1    // 创建 test1 文件
# ls -al test1    // 查看 test1 默认权限
-rw-r--r-- 1 root root 0 Nov 15 10:32 test1
# chmod u=rwx,g=rx,o=r  test1    // 修改 test1 权限
# ls -al test1
-rwxr-xr-- 1 root root 0 Nov 15 10:32 test1</code></pre>
<ul>
<li>而如果是要将权限去掉而不改变其他已存在的权限呢？例如要拿掉全部人的可执行权限，则：</li>
</ul>
<pre><code class="highlight plaintext">#  chmod  a-x test1
# ls -al test1
-rw-r--r-- 1 root root 0 Nov 15 10:32 test1</code></pre>
<h3 id="文件的特殊权限"><a class="markdownIt-Anchor" href="#文件的特殊权限"></a> 文件的特殊权限</h3>
<p>在复杂多变的生产环境中，单纯设置文件的rwx权限无法满足我们对安全和灵活性的需求，因此便有了SUID、SGID与SBIT的特殊权限位。这是一种对文件权限进行设置的特殊功能，可以与一般权限同时使用，以弥补一般权限不能实现的功能。下面具体解释这3个特殊权限位的功能以及用法。</p>
<h4 id="suid"><a class="markdownIt-Anchor" href="#suid"></a> SUID</h4>
<p>SUID是一种对二进制程序进行设置的特殊权限，可以让二进制程序的执行者临时拥有属主的权限（仅对拥有执行权限的二进制程序有效）。</p>
<p>例如，所有用户都可以执行passwd命令来修改自己的用户密码，而用户密码保存在/etc/shadow文件中。仔细查看这个文件就会发现它的默认权限是000，也就是说除了root管理员以外，所有用户都没有查看或编辑该文件的权限。但是，在使用passwd命令时如果加上SUID特殊权限位，就可让普通用户临时获得程序所有者的身份，把变更的密码信息写入到shadow文件中。这很像我们在古装剧中见到的手持尚方宝剑的钦差大臣，他手持的尚方宝剑代表的是皇上的权威，因此可以惩戒贪官，但这并不意味着他永久成为了皇上。因此这只是一种有条件的、临时的特殊权限授权方法。</p>
<p>查看passwd命令属性时发现所有者的权限由rwx变成了rws，其中x改变成s就意味着该文件被赋予了SUID权限。另外有读者会好奇，那么如果原本的权限是rw-呢？如果原先权限位上没有x执行权限，那么被赋予特殊权限后将变成大写的S。</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# ls -l /etc/shadow
----------. 1 root root 1004 Jan 3 06:23 /etc/shadow
[root@linuxprobe ~]# ls -l /bin/passwd
-rwsr-xr-x. 1 root root 27832 Jan 29 2017 /bin/passwd</code></pre>
<h4 id="sgid"><a class="markdownIt-Anchor" href="#sgid"></a> SGID</h4>
<p>SGID的第一种功能是参考SUID而设计的，不同点在于执行程序的用户获取的不再是文件所有者的临时权限，而是获取到文件所属组的权限。举例来说，在早期的Linux系统中，/dev/kmem是一个字符设备文件，用于存储内核程序要访问的数据，权限为：</p>
<ul>
<li>cr—r——- 1 root system 2, 1 Feb 11 2017 kmem</li>
</ul>
<p>大家看出问题了吗？除了root管理员或属于system组成员外，所有用户都没有读取该文件的权限。由于在平时我们需要查看系统的进程状态，为了能够获取到进程的状态信息，可在用于查看系统进程状态的ps命令文件上增加SGID特殊权限位。查看ps命令文件的属性信息：</p>
<pre><code class="highlight plaintext">-r-xr-sr-x 1 bin system 59346 Feb 11 2017 ps</code></pre>
<p>这样一来，由于ps命令被增加了SGID特殊权限位，所以当用户执行该命令时，也就临时获取到了system用户组的权限，从而可以顺利地读取设备文件了</p>
<p>前文提到，每个文件都有其归属的所有者和所属组，当创建或传送一个文件后，这个文件就会自动归属于执行这个操作的用户（即该用户是文件的所有者）。如果现在需要在一个部门内设置共享目录，让部门内的所有人员都能够读取目录中的内容，那么就可以创建部门共享目录后，在该目录上设置SGID特殊权限位。这样，部门内的任何人员在里面创建的任何文件都会归属于该目录的所属组，而不再是自己的基本用户组。此时，我们用到的就是SGID的第二个功能，即在某个目录中创建的文件自动继承该目录的用户组（只可以对目录进行设置）。</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# cd /tmp
[root@linuxprobe tmp]# mkdir testdir
[root@linuxprobe tmp]# ls -ald testdir/
drwxr-xr-x. 2 root root 6 Feb 11 11:50 testdir/
[root@linuxprobe tmp]# chmod -Rf 777 testdir/
[root@linuxprobe tmp]# chmod -Rf g+s testdir/
[root@linuxprobe tmp]# ls -ald testdir/
drwxrwsrwx. 2 root root 6 Feb 11 11:50 testdir/</code></pre>
<p>在使用上述命令设置好目录的777权限（确保普通用户可以向其中写入文件），并为该目录设置了SGID特殊权限位后，就可以切换至一个普通用户，然后尝试在该目录中创建文件，并查看新创建的文件是否会继承新创建的文件所在的目录的所属组名称：</p>
<pre><code class="highlight plaintext">[root@linuxprobe tmp]# su - linuxprobe
Last login: Wed Feb 11 11:49:16 CST 2017 on pts/0
[linuxprobe@linuxprobe ~]$ cd /tmp/testdir/
[linuxprobe@linuxprobe testdir]$ echo &quot;linuxprobe.com&quot; &gt; test
[linuxprobe@linuxprobe testdir]$ ls -al test
-rw-rw-r--. 1 linuxprobe root 15 Feb 11 11:50 test</code></pre>
<h4 id="sbit"><a class="markdownIt-Anchor" href="#sbit"></a> SBIT</h4>
<p>现在，大学里的很多老师都要求学生将作业上传到服务器的特定共享目录中，但总是有几个“破坏分子”喜欢删除其他同学的作业，这时就要设置SBIT（Sticky Bit）特殊权限位了（也可以称之为特殊权限位之粘滞位）。SBIT特殊权限位可确保用户只能删除自己的文件，而不能删除其他用户的文件。换句话说，当对某个目录设置了SBIT粘滞位权限后，那么该目录中的文件就只能被其所有者执行删除操作了。</p>
<p>最初不知道是哪位非资深技术人员将Sticky Bit直译成了“粘滞位”，刘遄老师建议将其称为“保护位”，这既好记，又能立刻让人了解它的作用。RHEL 7系统中的/tmp作为一个共享文件的目录，默认已经设置了SBIT特殊权限位，因此除非是该目录的所有者，否则无法删除这里面的文件。</p>
<p>与前面所讲的SUID和SGID权限显示方法不同，当目录被设置SBIT特殊权限位后，文件的其他人权限部分的x执行权限就会被替换成t或者T，原本有x执行权限则会写成t，原本没有x执行权限则会被写成T。</p>
<pre><code class="highlight plaintext">[root@linuxprobe tmp]# su - linuxprobe
Last login: Wed Feb 11 12:41:20 CST 2017 on pts/0
[linuxprobe@linuxprobe tmp]$ ls -ald /tmp
drwxrwxrwt. 17 root root 4096 Feb 11 13:03 /tmp
[linuxprobe@linuxprobe ~]$ cd /tmp
[linuxprobe@linuxprobe tmp]$ ls -ald
drwxrwxrwt. 17 root root 4096 Feb 11 13:03 .
[linuxprobe@linuxprobe tmp]$ echo &quot;Welcome to linuxprobe.com&quot; &gt; test
[linuxprobe@linuxprobe tmp]$ chmod 777 test
[linuxprobe@linuxprobe tmp]$ ls -al test 
-rwxrwxrwx. 1 linuxprobe linuxprobe 10 Feb 11 12:59 test</code></pre>
<p>其实，文件能否被删除并不取决于自身的权限，而是看其所在目录是否有写入权限（其原理会在下个章节讲到）。为了避免现在很多读者不放心，所以上面的命令还是赋予了这个test文件最大的777权限（rwxrwxrwx）。我们切换到另外一个普通用户，然后尝试删除这个其他人创建的文件就会发现，即便读、写、执行权限全开，但是由于SBIT特殊权限位的缘故，依然无法删除该文件：</p>
<pre><code class="highlight plaintext">[root@linuxprobe tmp]# su - blackshield
Last login: Wed Feb 11 12:41:29 CST 2017 on pts/1
[blackshield@linuxprobe ~]$ cd /tmp
[blackshield@linuxprobe tmp]$ rm -f test
rm: cannot remove ‘test’: Operation not permitted</code></pre>
<p>当然，要是也想对其他目录来设置SBIT特殊权限位，用chmod命令就可以了。对应的参数o+t代表设置SBIT粘滞位权限：</p>
<pre><code class="highlight plaintext">[blackshield@linuxprobe tmp]$ exit
Logout
[root@linuxprobe tmp]# cd ~
[root@linuxprobe ~]# mkdir linux
[root@linuxprobe ~]# chmod -R o+t linux/
[root@linuxprobe ~]# ls -ld linux/
drwxr-xr-t. 2 root root 6 Feb 11 19:34 linux/</code></pre>
<h3 id="文件的隐藏属性"><a class="markdownIt-Anchor" href="#文件的隐藏属性"></a> 文件的隐藏属性</h3>
<p>Linux系统中的文件除了具备一般权限和特殊权限之外，还有一种隐藏权限，即被隐藏起来的权限，默认情况下不能直接被用户发觉。有用户曾经在生产环境和RHCE考试题目中碰到过明明权限充足但却无法删除某个文件的情况，或者仅能在日志文件中追加内容而不能修改或删除内容，这在一定程度上阻止了黑客篡改系统日志的图谋，因此这种“奇怪”的文件也保障了Linux系统的安全性。</p>
<h4 id="chattr"><a class="markdownIt-Anchor" href="#chattr"></a> chattr</h4>
<p>chattr命令用于设置文件的隐藏权限，格式为</p>
<pre><code class="highlight plaintext">chattr [参数] 文件</code></pre>
<p>如果想要把某个隐藏功能添加到文件上，则需要在命令后面追加“+参数”，如果想要把某个隐藏功能移出文件，则需要追加“-参数”</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>无法对文件进行修改；若对目录设置了该参数，则仅能修改其中的子文件内容而不能新建或删除文件</td>
</tr>
<tr>
<td>a</td>
<td>仅允许补充（追加）内容，无法覆盖/删除内容（Append Only）</td>
</tr>
<tr>
<td>S</td>
<td>文件内容在变更后立即同步到硬盘（sync）</td>
</tr>
<tr>
<td>s</td>
<td>彻底从硬盘中删除，不可恢复（用0填充原文件所在硬盘区域）</td>
</tr>
<tr>
<td>A</td>
<td>不再修改这个文件或目录的最后访问时间（atime）</td>
</tr>
<tr>
<td>b</td>
<td>不再修改文件或目录的存取时间</td>
</tr>
<tr>
<td>D</td>
<td>检查压缩文件中的错误</td>
</tr>
<tr>
<td>d</td>
<td>使用dump命令备份时忽略本文件/目录</td>
</tr>
<tr>
<td>c</td>
<td>默认将文件或目录进行压缩</td>
</tr>
<tr>
<td>u</td>
<td>当删除该文件后依然保留其在硬盘中的数据，方便日后恢复</td>
</tr>
<tr>
<td>t</td>
<td>让文件系统支持尾部合并（tail-merging）</td>
</tr>
<tr>
<td>x</td>
<td>可以直接访问压缩文件中的内容</td>
</tr>
</tbody>
</table>
<p>实践是检验真理的唯一标准。如果您没有亲眼见证过隐藏权限强大功能的美妙，就一定不会相信原来Linux系统会如此安全。接下来我们再次新建一个普通文件，并为其设置不允许删除与覆盖（+a参数）权限，然后再尝试将这个文件删除：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# echo &quot;for Test&quot; &gt; linuxprobe
[root@linuxprobe ~]# chattr +a linuxprobe
[root@linuxprobe ~]# rm linuxprobe
rm: remove regular file ‘linuxprobe’? y
rm: cannot remove ‘linuxprobe’: Operation not permitted</code></pre>
<h4 id="lsattr"><a class="markdownIt-Anchor" href="#lsattr"></a> lsattr</h4>
<p>lsattr命令用于显示文件的隐藏权限，格式为</p>
<pre><code class="highlight plaintext">lsattr [参数] 文件</code></pre>
<p>在Linux系统中，文件的隐藏权限必须使用lsattr命令来查看，平时使用的ls之类的命令则看不出端倪：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# ls -al linuxprobe
-rw-r--r--. 1 root root 9 Feb 12 11:42 linuxprobe</code></pre>
<p>一旦使用lsattr命令后，文件上被赋予的隐藏权限马上就会原形毕露。此时可以按照显示的隐藏权限的类型（字母），使用chattr命令将其去掉：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# lsattr linuxprobe
-----a---------- linuxprobe
[root@linuxprobe ~]# chattr -a linuxprobe
[root@linuxprobe ~]# lsattr linuxprobe 
---------------- linuxprobe
[root@linuxprobe ~]# rm linuxprobe 
rm: remove regular file ‘linuxprobe’? y</code></pre>
<h2 id="文件目录"><a class="markdownIt-Anchor" href="#文件目录"></a> 文件/目录</h2>
<p>我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。</p>
<p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。在开始本教程前我们需要先知道什么是绝对路径与相对路径。</p>
<p><strong>绝对路径</strong>：</p>
<ul>
<li>路径的写法，由根目录 / 写起，例如： /usr/share/doc 这个目录。</li>
</ul>
<p><strong>相对路径</strong>：</p>
<ul>
<li>路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： cd …/man 这就是相对路径的写法啦！</li>
</ul>
<h3 id="处理目录常用命令"><a class="markdownIt-Anchor" href="#处理目录常用命令"></a> 处理目录常用命令</h3>
<ul>
<li>ls: 列出目录及文件名</li>
<li>cd：切换目录pwd：显示目前的目录</li>
<li>mkdir：创建一个新的目录</li>
<li>rmdir：删除一个空的目录</li>
<li>cp: 复制文件或目录</li>
<li>rm: 移除文件或目录</li>
<li>mv: 移动文件与目录，或修改文件与目录的名称</li>
</ul>
<h4 id="ls列出目录"><a class="markdownIt-Anchor" href="#ls列出目录"></a> ls(列出目录)</h4>
<p>在Linux系统当中， ls 命令可能是最常被运行的。</p>
<p>语法：</p>
<pre><code class="highlight plaintext">[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称
[root@www ~]# ls [--color=&#123;never,auto,always&#125;] 目录名称[root@www ~]# ls [--full-time] 目录名称</code></pre>
<p>选项与参数：</p>
<ul>
<li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li>
<li>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</li>
<li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li>
</ul>
<p>案例：</p>
<ul>
<li>将家目录下的所有文件列出来(含属性与隐藏档)</li>
</ul>
<pre><code class="highlight plaintext">[root@www ~]# ls -al ~</code></pre>
<h4 id="cd切换目录"><a class="markdownIt-Anchor" href="#cd切换目录"></a> cd(切换目录)</h4>
<p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p>
<p>语法：</p>
<pre><code class="highlight plaintext">cd [相对路径或绝对路径]</code></pre>
<blockquote>
<p>符号 “.” 指的是工作目录，”…” 指的是工作目录的父目录</p>
</blockquote>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>运行结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>cd</td>
<td>更改工作目录到你的家目录</td>
</tr>
<tr>
<td>cd -</td>
<td>更改工作目录到先前的工作目录</td>
</tr>
<tr>
<td>cd ~user_name</td>
<td>更改工作目录到用户家目录。例如, cd ~bob 会更改工作目录到用户“bob”的家目录。</td>
</tr>
</tbody>
</table>
<p>案例：</p>
<pre><code class="highlight plaintext">#使用 mkdir 命令创建 runoob 目录
[root@www ~]# mkdir runoob

#使用绝对路径切换到 runoob 目录
[root@www ~]# cd /root/runoob/

#使用相对路径切换到 runoob 目录
[root@www ~]# cd ./runoob/

# 表示回到自己的家目录，亦即是 /root 这个目录
[root@www runoob]# cd ~

# 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；
[root@www ~]# cd ..</code></pre>
<h4 id="pwd显示目前所在的目录"><a class="markdownIt-Anchor" href="#pwd显示目前所在的目录"></a> pwd(显示目前所在的目录)</h4>
<p>pwd 是 Print Working Directory 的缩写，也就是显示目前所在目录的命令。</p>
<p>语法：</p>
<pre><code class="highlight plaintext">[root@www ~]# pwd [-P]</code></pre>
<p>选项与参数：</p>
<ul>
<li>-P ：显示出确实的路径，而非使用连结 (link) 路径。</li>
</ul>
<blockquote>
<p>当我们首次登录系统（或者启动终端仿真器会话）后，当前工作目录是我们的家目录。 每个用户都有他自己的家目录，当用户以普通用户的身份操控系统时，家目录是唯一 允许用户对文件进行写入的地方</p>
</blockquote>
<p>实例：</p>
<ul>
<li>单纯显示出目前的工作目录：</li>
</ul>
<pre><code class="highlight plaintext">[root@www ~]# pwd
/root   &lt;== 显示出目录啦～</code></pre>
<ul>
<li>实例显示出实际的工作目录，而非连结档本身的目录名而已。</li>
</ul>
<pre><code class="highlight plaintext">[root@www ~]# cd /var/mail   &lt;==注意，/var/mail是一个连结档
[root@www mail]# pwd
/var/mail         &lt;==列出目前的工作目录

[root@www mail]# pwd -P
/var/spool/mail   &lt;==怎么回事？有没有加 -P 差很多～

[root@www mail]# ls -ld /var/mail
lrwxrwxrwx 1 root root 10 Sep  4 17:54 /var/mail -&gt; spool/mail

# 看到这里应该知道为啥了吧？因为 /var/mail 是连结档，连结到 /var/spool/mail 
# 所以，加上 pwd -P 的选项后，会不以连结档的数据显示，而是显示正确的完整路径啊！</code></pre>
<h4 id="mkdir创建新目录"><a class="markdownIt-Anchor" href="#mkdir创建新目录"></a> mkdir(创建新目录)</h4>
<p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p>
<p>语法：</p>
<pre><code class="highlight plaintext">mkdir [-mp] 目录名称 . . .</code></pre>
<p>选项与参数：</p>
<ul>
<li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li>
<li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li>
</ul>
<p>实例：</p>
<ul>
<li>请到/tmp底下尝试创建数个新目录看看：</li>
</ul>
<pre><code class="highlight plaintext">[root@www ~]# cd /tmp
[root@www tmp]# mkdir test    &lt;==创建一名为 test 的新目录
[root@www tmp]# mkdir test1/test2/test3/test4
mkdir: cannot create directory `test1/test2/test3/test4&#x27;: No such file or directory       &lt;== 没办法直接创建此目录啊！

[root@www tmp]# mkdir -p test1/test2/test3/test4</code></pre>
<blockquote>
<p>加了这个 -p 的选项，可以自行帮你创建多层目录！</p>
</blockquote>
<ul>
<li>创建权限为 rwx–x–x 的目录。</li>
</ul>
<pre><code class="highlight plaintext">[root@www tmp]# mkdir -m 711 test2
[root@www tmp]# ls -l
drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test
drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1
drwx--x--x  2 root  root 4096 Jul 18 12:54 test2</code></pre>
<blockquote>
<p>上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx–x–x 的权限。</p>
</blockquote>
<blockquote>
<p><strong>注意表示法</strong>: 在描述一个命令时（如上所示），当有三个圆点跟在一个命令的参数后面， 这意味着那个参数可以重复</p>
</blockquote>
<pre><code class="highlight plaintext">mkdir dir1

mkdir dir1 dir2 dir3</code></pre>
<h4 id="rmdir删除空目录"><a class="markdownIt-Anchor" href="#rmdir删除空目录"></a> rmdir(删除空目录)</h4>
<p>语法：</p>
<pre><code class="highlight plaintext">rmdir [-p] 目录名称</code></pre>
<p>选项与参数：</p>
<ul>
<li>-p ：连同上一级『空的』目录也一起删除</li>
</ul>
<p>案例：</p>
<ul>
<li>删除 runoob 目录</li>
</ul>
<pre><code class="highlight plaintext">[root@www tmp]# rmdir runoob/</code></pre>
<h4 id="rm移除文件或目录"><a class="markdownIt-Anchor" href="#rm移除文件或目录"></a> rm(移除文件或目录)</h4>
<p>语法：</p>
<pre><code class="highlight plaintext">rm [-fir] 文件或目录 . . .</code></pre>
<p>选项与参数：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-i, --interactive</td>
<td>在删除已存在的文件前，提示用户确认信息。 如果不指定这个选项，rm 会默默地删除文件</td>
</tr>
<tr>
<td>-r, --recursive</td>
<td>递归地删除文件，这意味着，如果要删除一个目录，而此目录 又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。</td>
</tr>
<tr>
<td>-f, --force</td>
<td>忽视不存在的文件，不显示提示信息。这选项颠覆了“–interactive”选项。</td>
</tr>
<tr>
<td>-v, --verbose</td>
<td>在执行 rm 命令时，显示翔实的操作信息。</td>
</tr>
</tbody>
</table>
<p>案例：</p>
<p>将刚刚在 cp 的实例中创建的 bashrc 删除掉！</p>
<pre><code class="highlight plaintext">[root@www tmp]# rm -i bashrc
rm: remove regular file `bashrc&#x27;? y</code></pre>
<blockquote>
<p>如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>运行结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>rm file1</td>
<td>默默地删除文件</td>
</tr>
<tr>
<td>rm -i file1</td>
<td>除了在删除文件之前，提示用户确认信息之外，和上面的命令作用一样。</td>
</tr>
<tr>
<td>rm -r file1 dir1</td>
<td>删除文件 file1, 目录 dir1，及 dir1 中的内容。</td>
</tr>
<tr>
<td>rm -rf file1 dir1</td>
<td>同上，除了如果文件 file1，或目录 dir1 不存在的话，rm 仍会继续执行。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>一定要小心rm命令，类 Unix 的操作系统，比如说 Linux，没有复原命令。一旦你用 rm 删除了一些东西， 它就消失了，<strong>尤其要小心通配符</strong></p>
</blockquote>
<blockquote>
<p>小贴士。 无论什么时候，rm 命令用到通配符（除了仔细检查输入的内容外！）， 用 ls 命令来测试通配符。这会让你看到要删除的文件列表。然后按下上箭头按键，重新调用 刚刚执行的命令，用 rm 替换 ls</p>
</blockquote>
<h4 id="cp复制文件或目录"><a class="markdownIt-Anchor" href="#cp复制文件或目录"></a> cp(复制文件或目录)</h4>
<p>cp即拷贝文件和目录</p>
<p>语法：</p>
<pre><code class="highlight plaintext">cp [-adfilprsu] 来源(source) 目标(destination)

cp [options] source1 source2 source3 . . .  directory</code></pre>
<blockquote>
<p>如果目标文件是目录，则会把源文件复制到该目录中；</p>
</blockquote>
<blockquote>
<p>如果目标文件也是普通文件，则会询问是否要覆盖它；</p>
</blockquote>
<blockquote>
<p>如果目标文件不存在，则执行正常的复制操作。</p>
</blockquote>
<p>选项与参数：</p>
<table>
<thead>
<tr>
<th>选 项</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a, --archive</td>
<td>复制文件和目录，以及它们的属性，包括所有权和权限。 通常，复本具有用户所操作文件的默认属性。相当于-pdr</td>
</tr>
<tr>
<td>-i, --interactive</td>
<td>在重写已存在文件之前，提示用户确认。如果这个选项不指定， cp 命令会默认重写文件。</td>
</tr>
<tr>
<td>-r, --recursive</td>
<td>递归地复制目录及目录中的内容。当复制目录时， 需要这个选项（或者-a 选项）。</td>
</tr>
<tr>
<td>-u, --update</td>
<td>当把文件从一个目录复制到另一个目录时，仅复制 目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。</td>
</tr>
<tr>
<td>-v, --verbose</td>
<td>显示翔实的命令操作信息</td>
</tr>
<tr>
<td>-d</td>
<td>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身</td>
</tr>
<tr>
<td>-f</td>
<td>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</td>
</tr>
<tr>
<td>-l</td>
<td>进行硬式连结(hard link)的连结档创建，而非复制文件本身；</td>
</tr>
<tr>
<td>-p</td>
<td>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</td>
</tr>
<tr>
<td>-s</td>
<td>复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</td>
</tr>
</tbody>
</table>
<p>案例：</p>
<p>用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc</p>
<pre><code class="highlight plaintext">[root@www ~]# cp ~/.bashrc /tmp/bashrc
[root@www ~]# cp -i ~/.bashrc /tmp/bashrc
cp: overwrite `/tmp/bashrc&#x27;? n  &lt;==n不覆盖，y为覆盖</code></pre>
<table>
<thead>
<tr>
<th>命令</th>
<th>运行结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>cp file1 file2</td>
<td>复制文件 file1 内容到文件 file2。如果 file2 已经存在， file2 的内容会被 file1 的内容重写。如果 file2 不存在，则会创建 file2。</td>
</tr>
<tr>
<td>cp -i file1 file2</td>
<td>这条命令和上面的命令一样，除了如果文件 file2 存在的话，在文件 file2 被重写之前， 会提示用户确认信息。</td>
</tr>
<tr>
<td>cp file1 file2 dir1</td>
<td>复制文件 file1 和文件 file2 到目录 dir1。目录 dir1 必须存在。</td>
</tr>
<tr>
<td>cp dir1/* dir2</td>
<td>使用一个通配符，在目录 dir1 中的所有文件都被复制到目录 dir2 中。 dir2 必须已经存在。</td>
</tr>
<tr>
<td>cp -r dir1 dir2</td>
<td>复制目录 dir1 中的内容到目录 dir2。如果目录 dir2 不存在， 创建目录 dir2，操作完成后，目录 dir2 中的内容和 dir1 中的一样。 如果目录 dir2 存在，则目录 dir1 (和目录中的内容)将会被复制到 dir2 中。</td>
</tr>
</tbody>
</table>
<h4 id="mv移动文件与目录或修改名称"><a class="markdownIt-Anchor" href="#mv移动文件与目录或修改名称"></a> mv(移动文件与目录，或修改名称)</h4>
<p>语法：</p>
<pre><code class="highlight plaintext">mv [-fiu] source destination

mv [options] source1 source2 source3 .... directory</code></pre>
<p>选项与参数：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-i --interactive</td>
<td>在重写一个已经存在的文件之前，提示用户确认信息。 <strong>如果不指定这个选项，mv 命令会默认重写文件内容</strong>。</td>
</tr>
<tr>
<td>-u --update</td>
<td>当把文件从一个目录移动另一个目录时，只是移动不存在的文件， 或者文件内容新于目标目录相对应文件的内容。</td>
</tr>
<tr>
<td>-f</td>
<td>force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</td>
</tr>
<tr>
<td>-v</td>
<td>显示详细的操作信息；</td>
</tr>
</tbody>
</table>
<p>案例：</p>
<p>复制一文件，创建一目录，将文件移动到目录中</p>
<pre><code class="highlight plaintext">[root@www ~]# cd /tmp
[root@www tmp]# cp ~/.bashrc bashrc
[root@www tmp]# mkdir mvtest
[root@www tmp]# mv bashrc mvtest</code></pre>
<p>将某个文件移动到某个目录去，就是这样做！</p>
<p>将刚刚的目录名称更名为 mvtest2</p>
<pre><code class="highlight plaintext">[root@www tmp]# mv mvtest mvtest2</code></pre>
<table>
<thead>
<tr>
<th>命令</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>mv file1 file2</td>
<td>移动 file1 到 file2。如果 file2 存在，它的内容会被 file1 的内容重写。 如果 file2 不存在，则创建 file2。 每种情况下，file1 不再存在。</td>
</tr>
<tr>
<td>mv -i file1 file2</td>
<td>除了如果 file2 存在的话，在 file2 被重写之前，用户会得到 提示信息外，这个和上面的选项一样。</td>
</tr>
<tr>
<td>mv file1 file2 dir1</td>
<td>移动 file1 和 file2 到目录 dir1 中。dir1 必须已经存在。</td>
</tr>
<tr>
<td>mv dir1 dir2</td>
<td>如果目录 dir2 不存在，创建目录 dir2，并且移动目录 dir1 的内容到 目录 dir2 中，同时删除目录 dir1。如果目录 dir2 存在，移动目录 dir1（及它的内容）到目录 dir2。</td>
</tr>
</tbody>
</table>
<h4 id="touch"><a class="markdownIt-Anchor" href="#touch"></a> touch</h4>
<p>touch命令用于<strong>创建空白文件或设置文件的时间</strong>，格式为</p>
<pre><code class="highlight plaintext">touch [选项] [文件]</code></pre>
<p>在创建空白的文本文件方面，这个touch命令相当简捷，简捷到没有必要铺开去讲。比如，touch linuxprobe命令可以创建出一个名为linuxprobe的空白文本文件。对touch命令来讲，有难度的操作主要是体现在设置文件内容的修改时间（mtime）、文件权限或属性的更改时间（ctime）与文件的读取时间（atime）上面。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>仅修改“读取时间”（atime）</td>
</tr>
<tr>
<td>-m</td>
<td>仅修改“修改时间”（mtime）</td>
</tr>
<tr>
<td>-d</td>
<td>同时修改atime与mtime</td>
</tr>
</tbody>
</table>
<p>接下来，我们先使用ls命令查看一个文件的修改时间，然后修改这个文件，最后再通过touch命令把修改后的文件时间设置成修改之前的时间（很多黑客就是这样做的呢）：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# ls -l anaconda-ks.cfg 
-rw-------. 1 root root 1213 May  4 15:44 anaconda-ks.cfg
[root@linuxprobe ~]# echo &quot;Visit the LinuxProbe.com to learn linux skills&quot; &gt;&gt; anaconda-ks.cfg
[root@linuxprobe ~]# ls -l anaconda-ks.cfg
-rw-------. 1 root root 1260 Aug  2 01:26 anaconda-ks.cfg
[root@linuxprobe ~]# touch -d &quot;2017-05-04 15:44&quot; anaconda-ks.cfg 
[root@linuxprobe ~]# ls -l anaconda-ks.cfg 
-rw-------. 1 root root 1260 May  4 15:44 anaconda-ks.cfg</code></pre>
<h4 id="dd"><a class="markdownIt-Anchor" href="#dd"></a> dd</h4>
<p>dd命令用于<strong>按照指定大小和个数的数据块来复制文件或转换文件</strong>，格式为</p>
<pre><code class="highlight plaintext">dd [参数]</code></pre>
<p>dd命令是一个比较重要而且比较有特色的一个命令，它能够让用户按照指定大小和个数的数据块来复制文件的内容。当然如果愿意的话，还可以在复制过程中转换其中的数据。</p>
<p>Linux系统中有一个名为/dev/zero的设备文件，每次在课堂上解释它时都充满哲学理论的色彩。因为这个文件不会占用系统存储空间，但却可以提供无穷无尽的数据，因此可以使用它作为dd命令的输入文件，来生成一个指定大小的文件。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>if</td>
<td>输入的文件名称</td>
</tr>
<tr>
<td>of</td>
<td>输出的文件名称</td>
</tr>
<tr>
<td>bs</td>
<td>设置每个“块”的大小</td>
</tr>
<tr>
<td>count</td>
<td>设置要复制“块”的个数</td>
</tr>
</tbody>
</table>
<p>例如我们可以用dd命令从/dev/zero设备文件中取出一个大小为560MB的数据块，然后保存成名为560_file的文件。在理解了这个命令后，以后就能随意创建任意大小的文件了：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# dd if=/dev/zero of=560_file count=1 bs=560M
1+0 records in
1+0 records out
587202560 bytes (587 MB) copied, 27.1755 s, 21.6 MB/s</code></pre>
<p>dd命令的功能也绝不仅限于复制文件这么简单。如果您想把光驱设备中的光盘制作成iso格式的镜像文件，在Windows系统中需要借助于第三方软件才能做到，但在Linux系统中可以直接使用dd命令来压制出光盘镜像文件，将它变成一个可立即使用的iso镜像：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# dd if=/dev/cdrom of=RHEL-server-7.0-x86_64-LinuxProbe.Com.iso
7311360+0 records in
7311360+0 records out
3743416320 bytes (3.7 GB) copied, 370.758 s, 10.1 MB/s</code></pre>
<h4 id="file查看文件类型"><a class="markdownIt-Anchor" href="#file查看文件类型"></a> file(查看文件类型)</h4>
<p>file命令用于查看文件的类型，格式为</p>
<pre><code class="highlight plaintext">file 文件名</code></pre>
<p>在Linux系统中，由于文本、目录、设备等所有这些一切都统称为文件，而我们又不能单凭后缀就知道具体的文件类型，这时就需要使用file命令来查看文件类型了</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# file anaconda-ks.cfg
anaconda-ks.cfg: ASCII text
[root@linuxprobe ~]# file /dev/sda
/dev/sda: block special</code></pre>
<h3 id="软硬方式连接"><a class="markdownIt-Anchor" href="#软硬方式连接"></a> 软硬方式连接</h3>
<p>在Windows系统中，快捷方式就是指向原始文件的一个链接文件，可以让用户从不同的位置来访问原始的文件；原文件一旦被删除或剪切到其他地方后，会导致链接文件失效。但是，这个看似简单的东西在Linux系统中可不太一样。</p>
<p>在Linux系统中存在硬链接和软连接两种文件。</p>
<p><strong>硬链接</strong>（hard link）：可以将它理解为一个“指向原始文件inode的指针”，系统不为它分配独立的inode和文件。所以，硬链接文件与原始文件其实是同一个文件，只是名字不同。我们每添加一个硬链接，该文件的inode连接数就会增加1；而且只有当该文件的inode连接数为0时，才算彻底将它删除。换言之，由于硬链接实际上是指向原文件inode的指针，因此即便原始文件被删除，依然可以通过硬链接文件来访问。需要注意的是，由于技术的局限性，我们不能跨分区对目录文件进行链接。</p>
<p><strong>软链接</strong>（也称为符号链接[symbolic link]）：仅仅包含所链接文件的路径名，因此能链接目录文件，也可以跨越文件系统进行链接。但是，当原始文件被删除后，链接文件也将失效，从这一点上来说与Windows系统中的“快捷方式”具有一样的性质。<strong>如果链接目录，则更改软链接目录内文件和更改原始目录文件是相同的效果</strong></p>
<h4 id="ln"><a class="markdownIt-Anchor" href="#ln"></a> ln</h4>
<p>ln命令用于创建链接文件，格式为</p>
<pre><code class="highlight plaintext">ln [选项] 目标 软链接名</code></pre>
<p>其可用的参数以及作用如表6-6所示。在使用ln命令时，是否添加-s参数，将创建出性质不同的两种“快捷方式”。因此如果没有扎实的理论知识和实践经验做铺垫，尽管能够成功完成实验，但永远不会明白为什么会成功。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-s</td>
<td>创建“符号链接”（如果不带-s参数，则默认创建硬链接）</td>
</tr>
<tr>
<td>-f</td>
<td>强制创建文件或目录的链接</td>
</tr>
<tr>
<td>-i</td>
<td>覆盖前先询问</td>
</tr>
<tr>
<td>-v</td>
<td>显示创建链接的过程</td>
</tr>
</tbody>
</table>
<p>为了更好地理解软链接、硬链接的不同性质，接下来创建一个类似于Windows系统中快捷方式的软链接。这样，当原始文件被删除后，就无法读取新建的链接文件了。</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# echo &quot;Welcome to linuxprobe.com&quot; &gt; readme.txt
[root@linuxprobe ~]# ln -s readme.txt readit.txt
[root@linuxprobe ~]# cat readme.txt 
Welcome to linuxprobe.com
[root@linuxprobe ~]# cat readit.txt 
Welcome to linuxprobe.com
[root@linuxprobe ~]# ls -l readme.txt 
-rw-r--r-- 1 root root 26 Jan 11 00:08 readme.txt
[root@linuxprobe ~]# rm -f readme.txt 
[root@linuxprobe ~]# cat readit.txt 
cat: readit.txt: No such file or directory</code></pre>
<p>接下来针对一个原始文件创建一个硬链接，即相当于针对原始文件的硬盘存储位置创建了一个指针，这样一来，新创建的这个硬链接就不再依赖于原始文件的名称等信息，也不会因为原始文件的删除而导致无法读取。同时可以看到创建硬链接后，原始文件的硬盘链接数量增加到了2。</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# echo &quot;Welcome to linuxprobe.com&quot; &gt; readme.txt
[root@linuxprobe ~]# ln readme.txt readit.txt
[root@linuxprobe ~]# cat readme.txt 
Welcome to linuxprobe.com
[root@linuxprobe ~]# cat readit.txt 
Welcome to linuxprobe.com
[root@linuxprobe ~]# ls -l readme.txt 
-rw-r--r-- 2 root root 26 Jan 11 00:13 readme.txt
[root@linuxprobe ~]# rm -f readme.txt 
[root@linuxprobe ~]# cat readit.txt 
Welcome to linuxprobe.com</code></pre>
<p><strong>总结</strong></p>
<p>依此您可以做一些相关的测试，可以得到以下全部结论：</p>
<ul>
<li>1).删除符号连接f3,对f1,f2无影响；</li>
<li>2).删除硬连接f2，对f1,f3也无影响；</li>
<li>3).删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效；</li>
<li>4).同时删除原文件f1,硬连接f2，整个文件会真正的被删除。</li>
</ul>
<h3 id="文件内容查看"><a class="markdownIt-Anchor" href="#文件内容查看"></a> 文件内容查看</h3>
<p>Linux系统中使用以下命令来查看文件的内容：</p>
<ul>
<li>cat  由第一行开始显示文件内容</li>
<li>tac  从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li>
<li>nl   显示的时候，顺道输出行号！</li>
<li>more 一页一页的显示文件内容</li>
<li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li>
<li>head 只看头几行</li>
<li>tail 只看尾巴几行</li>
</ul>
<p>你可以使用man [命令]来查看各个命令的使用文档，如 ：man cp。</p>
<h4 id="cat由第一行开始显示文件内容"><a class="markdownIt-Anchor" href="#cat由第一行开始显示文件内容"></a> cat(由第一行开始显示文件内容)</h4>
<p>cat命令用于查看纯文本文件（内容较少的）</p>
<p>语法：</p>
<pre><code class="highlight plaintext">cat [-AbEnTv]</code></pre>
<p>选项与参数：</p>
<ul>
<li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li>
<li>-b ：<strong>列出行号，仅针对非空白行做行号显示</strong>，空白行不标行号！</li>
<li>-E ：将结尾的断行字节 $ 显示出来；</li>
<li>-n ：<strong>列印出行号</strong>，连同空白行也会有行号，与 -b 的选项不同；</li>
<li>-T ：将 [tab] 按键以 ^I 显示出来；</li>
<li>-v ：列出一些看不出来的特殊字符</li>
</ul>
<p>案例：</p>
<ul>
<li>检看 /etc/issue 这个文件的内容：</li>
</ul>
<pre><code class="highlight plaintext">[root@www ~]# cat /etc/issue

CentOS release 6.4 (Final)
Kernel \r on an \m</code></pre>
<h4 id="tac由最后一行开始显示文件内容"><a class="markdownIt-Anchor" href="#tac由最后一行开始显示文件内容"></a> tac(由最后一行开始显示文件内容)</h4>
<p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p>
<pre><code class="highlight plaintext">[root@www ~]# tac /etc/issue

Kernel \r on an \m
CentOS release 6.4 (Final)</code></pre>
<h4 id="nl可以显示行号"><a class="markdownIt-Anchor" href="#nl可以显示行号"></a> nl(可以显示行号)</h4>
<p>显示行号</p>
<p>语法：</p>
<pre><code class="highlight plaintext">nl [-bnw] 文件</code></pre>
<p>选项与参数：</p>
<ul>
<li>-b ：指定行号指定的方式，主要有两种：
<ul>
<li>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；</li>
<li>-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li>
</ul>
</li>
<li>-n ：列出行号表示的方法，主要有三种：
<ul>
<li>-n ln ：行号在荧幕的最左方显示；</li>
<li>-n rn ：行号在自己栏位的最右方显示，且不加 0 ；</li>
<li>-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li>
</ul>
</li>
<li>-w ：行号栏位的占用的位数。</li>
</ul>
<p>案例：</p>
<ul>
<li>用 nl 列出 /etc/issue 的内容</li>
</ul>
<pre><code class="highlight plaintext">[root@www ~]# nl /etc/issue

     1  CentOS release 6.4 (Final)
     2  Kernel \r on an \m</code></pre>
<h4 id="more一页一页翻动"><a class="markdownIt-Anchor" href="#more一页一页翻动"></a> more(一页一页翻动)</h4>
<p>more命令用于查看纯文本文件（内容较多的）</p>
<p>语法：</p>
<pre><code class="highlight plaintext">more /etc/man_db.config</code></pre>
<p>案例：</p>
<pre><code class="highlight plaintext">
[root@www ~]# more /etc/man_db.config 
#
# Generated automatically from man.conf.in by the
# configure script.
#
# man.conf from man-1.6d
....(中间省略)....
--More--(28%)  &lt;== 重点在这一行喔！你的光标也会在这里等待你的命令</code></pre>
<p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p>
<ul>
<li>空白键 (space)：代表向下翻一页；</li>
<li>Enter：代表向下翻『一行』；</li>
<li>/字串：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li>
<li>:f：立刻显示出档名以及目前显示的行数；</li>
<li>q：代表立刻离开 more ，不再显示该文件内容。</li>
<li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>
</ul>
<h4 id="less一页一页翻动"><a class="markdownIt-Anchor" href="#less一页一页翻动"></a> less(一页一页翻动)</h4>
<p>语法：</p>
<pre><code class="highlight plaintext">less /etc/man.config</code></pre>
<p>案例：</p>
<ul>
<li>一页一页翻动，以下实例输出/etc/man.config文件的内容：</li>
</ul>
<pre><code class="highlight plaintext">[root@www ~]# less /etc/man.config
#
# Generated automatically from man.conf.in by the
# configure script.
#
# man.conf from man-1.6d
....(中间省略)....
:   &lt;== 这里可以等待你输入命令！</code></pre>
<p>less运行时可以输入的命令有：</p>
<ul>
<li>空白键    ：向下翻动一页；</li>
<li>[pagedown]：向下翻动一页；</li>
<li>[pageup]  ：向上翻动一页；</li>
<li>/字串     ：向下搜寻『字串』的功能；</li>
<li>?字串     ：向上搜寻『字串』的功能；</li>
<li>n         ：重复前一个搜寻 (与 / 或 ? 有关！)</li>
<li>N         ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li>
<li>q         ：离开 less 这个程序；</li>
</ul>
<h4 id="head取出文件前几行"><a class="markdownIt-Anchor" href="#head取出文件前几行"></a> head(取出文件前几行)</h4>
<p>取出文件前面几行</p>
<p>语法：</p>
<pre><code class="highlight plaintext">head [-n number] 文件</code></pre>
<p>选项与参数：</p>
<ul>
<li>-n ：后面接数字，代表显示几行的意思</li>
</ul>
<p>案例：</p>
<pre><code class="highlight plaintext">[root@www ~]# head /etc/man.config</code></pre>
<p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p>
<pre><code class="highlight plaintext">[root@www ~]# head -n 20 /etc/man.config</code></pre>
<h4 id="tail取出文件后几行"><a class="markdownIt-Anchor" href="#tail取出文件后几行"></a> tail(取出文件后几行)</h4>
<p>取出文件后面几行</p>
<p>语法：</p>
<pre><code class="highlight plaintext">tail [-n number] 文件</code></pre>
<p>选项与参数：</p>
<ul>
<li>-n ：后面接数字，代表显示几行的意思</li>
<li>-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测</li>
</ul>
<pre><code class="highlight plaintext">[root@www ~]# tail /etc/man.config
# 默认的情况中，显示最后的十行！若要显示最后的 20 行，就得要这样：
[root@www ~]# tail -n 20 /etc/man.config</code></pre>
<h4 id="tr替换文本内容"><a class="markdownIt-Anchor" href="#tr替换文本内容"></a> tr(替换文本内容)</h4>
<p>tr命令用于替换文本文件中的字符，格式为</p>
<pre><code class="highlight plaintext">tr [原始字符] [目标字符]</code></pre>
<p>在很多时候，我们想要快速地替换文本中的一些词汇，又或者把整个文本内容都进行替换，如果进行手工替换，难免工作量太大，尤其是需要处理大批量的内容时，进行手工替换更是不现实。这时，就可以先使用cat命令读取待处理的文本，然后通过管道符（详见第3章）把这些文本内容传递给tr命令进行替换操作即可。例如，把某个文本内容中的英文全部替换为大写：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# cat anaconda-ks.txt | tr [a-z] [A-Z]</code></pre>
<h4 id="wc统计行数"><a class="markdownIt-Anchor" href="#wc统计行数"></a> wc(统计行数)</h4>
<p>wc命令用于统计指定文本的行数、字数、字节数，格式为</p>
<pre><code class="highlight plaintext">wc [参数] 文本</code></pre>
<p>每次我在课堂上讲到这个命令时，总有同学会联想到一种公共设施，其实这两者毫无关联。Linux系统中的wc命令用于统计文本的行数、字数、字节数等。如果为了方便自己记住这个命令的作用，也可以联想到上厕所时好无聊，无聊到数完了手中的如厕读物上有多少行字</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-l</td>
<td>只显示行数</td>
</tr>
<tr>
<td>-w</td>
<td>只显示单词数</td>
</tr>
<tr>
<td>-c</td>
<td>只显示字节数</td>
</tr>
</tbody>
</table>
<p>在Linux系统中，passwd是用于保存系统账户信息的文件，要统计当前系统中有多少个用户，可以使用下面的命令来进行查询，是不是很神奇：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# wc -l /etc/passwd
38 /etc/passwd</code></pre>
<h4 id="stat查看文件信息"><a class="markdownIt-Anchor" href="#stat查看文件信息"></a> stat(查看文件信息)</h4>
<p>stat命令用于查看文件的具体存储信息和时间等信息，格式为</p>
<pre><code class="highlight plaintext">stat 文件名称</code></pre>
<p>stat命令可以用于查看文件的存储信息和时间等信息，命令stat anaconda-ks.cfg会显示出文件的三种时间状态（已加粗）：Access、Modify、Change。这三种时间的区别将在下面的touch命令中详细详解：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# stat anaconda-ks.cfg
File: ‘anaconda-ks.cfg’
Size: 1213 Blocks: 8 IO Block: 4096 regular file
Device: fd00h/64768d Inode: 68912908 Links: 1
Access: (0600/-rw-------) Uid: ( 0/ root) Gid: ( 0/ root)
Context: system_u:object_r:admin_home_t:s0
Access: 2017-07-14 01:46:18.721255659 -0400
Modify: 2017-05-04 15:44:36.916027026 -0400
Change: 2017-05-04 15:44:36.916027026 -0400
Birth: -</code></pre>
<h4 id="cut提取列"><a class="markdownIt-Anchor" href="#cut提取列"></a> cut(提取列)</h4>
<p>命令<strong>cut命令用于按“列”提取文本字符</strong>，格式为</p>
<pre><code class="highlight plaintext">cut [参数] 文本</code></pre>
<p>在Linux系统中，如何准确地提取出最想要的数据，这也是我们应该重点学习的内容。一般而言，按基于“行”的方式来提取数据是比较简单的，只需要设置好要搜索的关键词即可。但是如果按列搜索，不仅要使用-f参数来设置需要看的列数，还需要使用-d参数来设置间隔符号。</p>
<p>passwd在保存用户数据信息时，用户信息的每一项值之间是采用冒号来间隔的，接下来我们使用下述命令尝试提取出passwd文件中的用户名信息，即提取以冒号（：）为间隔符号的第一列内容：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# head -n 2 /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
[root@linuxprobe ~]# cut -d: -f1 /etc/passwd
root
bin
daemon
adm
lp
sync
shutdown
halt
mail
operator
games
ftp
nobody
dbus
polkitd
unbound
colord
usbmuxd
avahi
avahi-autoipd
libstoragemgmt
saslauth</code></pre>
<h4 id="diff比较"><a class="markdownIt-Anchor" href="#diff比较"></a> diff(比较)</h4>
<p>diff命令用于比较多个文本文件的差异，格式为</p>
<pre><code class="highlight plaintext">diff [参数] 文件</code></pre>
<p>在使用diff命令时，不仅可以<strong>使用—brief参数来确认两个文件是否不同</strong>，还可以<strong>使用-c参数来详细比较出多个文件的差异之处</strong>，这绝对是判断文件是否被篡改的有力神器。</p>
<p>接下来使用diff —brief命令显示比较后的结果，判断文件是否相同：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# diff --brief diff_A.txt diff_B.txt
Files diff_A.txt and diff_B.txt differ</code></pre>
<p>最后使用带有-c参数的diff命令来描述文件内容具体的不同：</p>
<pre><code class="highlight plaintext"> [root@linuxprobe ~]# diff -c diff_A.txt diff_B.txt
** diff_A.txt 2017-08-30 18:07:45.230864626 +0800
--- diff_B.txt 2017-08-30 18:08:52.203860389 +0800
*******
** 1,5 **
! Welcome to linuxprobe.com
Red Hat certified
! Free Linux Lessons
Professional guidance
Linux Course
--- 1,7 ----
! Welcome tooo linuxprobe.com
!
Red Hat certified
! Free Linux LeSSonS
! ////////.....////////
Professional guidance
Linux Course</code></pre>
<h3 id="查找"><a class="markdownIt-Anchor" href="#查找"></a> 查找</h3>
<ul>
<li><strong>which</strong>       查看可执行文件的位置</li>
<li><strong>whereis</strong>    查看文件的位置</li>
<li><strong>locate</strong>       配 合数据库查看文件位置</li>
<li><strong>find</strong>          实际搜寻硬盘查询文件名称</li>
</ul>
<h4 id="find"><a class="markdownIt-Anchor" href="#find"></a> find</h4>
<p>find是最常见和最强大的查找命令，你可以用它找到任何你想找的文件</p>
<p>语法：</p>
<ul>
<li>&lt;<strong>指定目录</strong>&gt;： 所要搜索的目录及其所有子目录。默认为当前目录。</li>
<li>&lt;<strong>指定条件</strong>&gt;： 所要搜索的文件的特征。</li>
<li>&lt;<strong>指定动作</strong>&gt;： 对搜索结果进行特定的处理。</li>
</ul>
<pre><code class="highlight plaintext">$ find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;</code></pre>
<p>参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-<strong>name</strong></td>
<td>匹配名称（可以使用通配符）</td>
</tr>
<tr>
<td>-perm</td>
<td>匹配权限（mode为完全匹配，-mode为包含即可）</td>
</tr>
<tr>
<td>-user</td>
<td>匹配所有者</td>
</tr>
<tr>
<td>-group</td>
<td>匹配所有组</td>
</tr>
<tr>
<td>-mtime -n +n</td>
<td>匹配修改内容的时间（-n指n天以内，+n指n天以前）</td>
</tr>
<tr>
<td>-atime -n +n</td>
<td>匹配访问文件的时间（-n指n天以内，+n指n天以前）</td>
</tr>
<tr>
<td>-ctime -n +n</td>
<td>匹配修改文件权限的时间（-n指n天以内，+n指n天以前）</td>
</tr>
<tr>
<td>-nouser</td>
<td>匹配无所有者的文件</td>
</tr>
<tr>
<td>-nogroup</td>
<td>匹配无所有组的文件</td>
</tr>
<tr>
<td>-newer f1 !f2</td>
<td>匹配比文件f1新但比f2旧的文件</td>
</tr>
<tr>
<td>—type b/d/c/p/l/f</td>
<td>匹配文件类型（后面的字幕字母依次表示块设备、目录、字符设备、管道、链接文件、文本文件）</td>
</tr>
<tr>
<td>-size</td>
<td>匹配文件的大小（+50KB为查找超过50KB的文件，而-50KB为查找小于50KB的文件）</td>
</tr>
<tr>
<td>-prune</td>
<td>忽略某个目录</td>
</tr>
<tr>
<td>-exec …… {};</td>
<td>后面可跟用于进一步处理搜索结果的命令，{}表示find命令搜索出的每一个文件，并且命令的结尾必须是“;”</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<ul>
<li>搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。</li>
</ul>
<pre><code class="highlight plaintext">$ find . -name &quot;my*&quot;</code></pre>
<ul>
<li>搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息</li>
</ul>
<pre><code class="highlight plaintext">$ find . -name &quot;my*&quot; -ls</code></pre>
<ul>
<li>在整个文件系统中找出所有归属于linuxprobe用户的文件并复制到/root/findresults目录</li>
</ul>
<pre><code class="highlight plaintext">$ find / -user linuxprobe -exec cp -a &#123;&#125; /root/findresults/ \;</code></pre>
<h4 id="whereis"><a class="markdownIt-Anchor" href="#whereis"></a> whereis</h4>
<p>whereis命令只能用于程序名的搜索</p>
<p>语法：</p>
<pre><code class="highlight plaintext">$ whereis [-bmsu] 文件或者目录名称</code></pre>
<p>参数：</p>
<ul>
<li>-b ： 只找二进制文件</li>
<li>-m： 只找在说明文件manual路径下的文件</li>
<li>-s ： 只找source源文件</li>
<li>-u ： 没有说明文档的文件</li>
</ul>
<blockquote>
<p>和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新</p>
</blockquote>
<p>实例：</p>
<pre><code class="highlight plaintext">$ whereis passwd 
passwd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz /usr/share/man/man5/passwd.5.gz 
#将和passwd文件相关的文件都查找出来 

$ whereis -b passwd 
passwd: /usr/bin/passwd /etc/passwd 
#只将二进制文件 查找出来</code></pre>
<h4 id="locate"><a class="markdownIt-Anchor" href="#locate"></a> locate</h4>
<p>locate命令其实是“find -name”的另一种写法，但是要<strong>比后者快得多</strong>，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。</p>
<p>Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，<strong>可以在使用locate之前，先使用updatedb命令</strong>，手动更新数据库</p>
<p>语法：</p>
<pre><code class="highlight plaintext">$ locate 文件或者目录名称</code></pre>
<p>示例：</p>
<pre><code class="highlight plaintext">[root@redhat ~]# locate passwd</code></pre>
<h4 id="which"><a class="markdownIt-Anchor" href="#which"></a> which</h4>
<p>which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>
<p>which是通过 PATH环境变量到该路径内查找可执行文件，所以基本的功能是寻找可执行文件</p>
<p>语法：</p>
<pre><code class="highlight plaintext">$ which 可执行文件名称</code></pre>
<p>示例：</p>
<pre><code class="highlight plaintext">$ which passwd 
/usr/bin/passwd</code></pre>
<h4 id="grep"><a class="markdownIt-Anchor" href="#grep"></a> grep</h4>
<p>grep（General Regular Expression Parser，通用规则表达式分析程序）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来</p>
<p>语法：</p>
<pre><code class="highlight plaintext">grep [选项] pattern [文件名]</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-b</td>
<td>将可执行文件(binary)当作文本文件（text）来搜索</td>
</tr>
<tr>
<td>-c</td>
<td>仅显示找到的行数</td>
</tr>
<tr>
<td>-i</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>-n</td>
<td><strong>显示搜索到信息的行号</strong></td>
</tr>
<tr>
<td>-v</td>
<td><strong>反选信息</strong>（即没有包含关键词的所有信息行）</td>
</tr>
<tr>
<td>-r</td>
<td>递归搜索文件夹</td>
</tr>
<tr>
<td>-l</td>
<td>只显示搜索出文件的文件名</td>
</tr>
<tr>
<td>–include</td>
<td>指定文件后缀名</td>
</tr>
</tbody>
</table>
<pre><code class="highlight plaintext">#递归搜索当前目录py结尾文件中是否包含xtrabackup
grep -lr &quot;xtrabackup&quot; --include=&quot;*.py&quot; ./</code></pre>
<p>在Linux系统中，/etc/passwd文件是保存着所有的用户信息，而一旦用户的登录终端被设置成/sbin/nologin，则不再允许登录系统，因此可以使用grep命令来查找出当前系统中不允许登录系统的所有用户信息：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# grep /sbin/nologin /etc/passwd
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
………………省略部分输出过程信息………………</code></pre>
<p>为了更好的探究 grep 程序，让我们创建一些文本文件来搜寻：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ ls /bin &gt; dirlist-bin.txt
[me@linuxbox ~]$ ls /usr/bin &gt; dirlist-usr-bin.txt
[me@linuxbox ~]$ ls /sbin &gt; dirlist-sbin.txt
[me@linuxbox ~]$ ls /usr/sbin &gt; dirlist-usr-sbin.txt
[me@linuxbox ~]$ ls dirlist*.txt
dirlist-bin.txt     dirlist-sbin.txt    dirlist-usr-sbin.txt
dirlist-usr-bin.txt</code></pre>
<p>我们能够对我们的文件列表执行简单的搜索，像这样：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ grep bzip dirlist*.txt
dirlist-bin.txt:bzip2
dirlist-bin.txt:bzip2recover</code></pre>
<p><strong>正则匹配</strong></p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ grep -h &#x27;^zip&#x27; dirlist*.txt
zip
zipcloak
zipgrep
zipinfo
zipnote
zipsplit
[me@linuxbox ~]$ grep -h &#x27;zip$&#x27; dirlist*.txt
gunzip
gzip
funzip
gpg-zip
preunzip
prezip
unzip
zip
[me@linuxbox ~]$ grep -h &#x27;^zip$&#x27; dirlist*.txt
zip
[me@linuxbox ~]$ grep -i &#x27;^..j.r$&#x27; /usr/share/dict/words
Major
major
[me@linuxbox ~]$ grep -h &#x27;[bg]zip&#x27; dirlist*.txt
bzip2
bzip2recover
gzip</code></pre>
<h2 id="归档备份"><a class="markdownIt-Anchor" href="#归档备份"></a> 归档备份</h2>
<h3 id="解压缩"><a class="markdownIt-Anchor" href="#解压缩"></a> 解压缩</h3>
<h4 id="gzip"><a class="markdownIt-Anchor" href="#gzip"></a> gzip</h4>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>把输出写入到标准输出，并且保留原始文件。也有可能用–stdout 和–to-stdout 选项来指定。</td>
</tr>
<tr>
<td>-d</td>
<td>解压缩。正如 gunzip 命令一样。也可以用–decompress 或者–uncompress 选项来指定.</td>
</tr>
<tr>
<td>-f</td>
<td>强制压缩，即使原始文件的压缩文件已经存在了，也要执行。也可以用–force 选项来指定。</td>
</tr>
<tr>
<td>-h</td>
<td>显示用法信息。也可用–help 选项来指定。</td>
</tr>
<tr>
<td>-l</td>
<td>列出每个被压缩文件的压缩数据。也可用–list 选项。</td>
</tr>
<tr>
<td>-r</td>
<td>若命令的一个或多个参数是目录，则递归地压缩目录中的文件。也可用–recursive 选项来指定。</td>
</tr>
<tr>
<td>-t</td>
<td>测试压缩文件的完整性。也可用–test 选项来指定。</td>
</tr>
<tr>
<td>-v</td>
<td>显示压缩过程中的信息。也可用–verbose 选项来指定。</td>
</tr>
<tr>
<td>-number</td>
<td>设置压缩指数。number 是一个在1（最快，最小压缩）到9（最慢，最大压缩）之间的整数。 数值1和9也可以各自用–fast 和–best 选项来表示。默认值是整数6。</td>
</tr>
</tbody>
</table>
<p>这个 <strong>gzip</strong> 程序被用来压缩一个或多个文件。当执行 gzip 命令时，则原始文件的压缩版会替代原始文件。 相对应的 <strong>gunzip</strong> 程序被用来把压缩文件复原为没有被压缩的版本。这里有个例子：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ ls -l /etc &gt; foo.txt
[me@linuxbox ~]$ ls -l foo.*-rw-r--r-- 1 me     me 15738 2008-10-14 07:15 foo.txt
[me@linuxbox ~]$ gzip foo.txt
[me@linuxbox ~]$ ls -l foo.*-rw-r--r-- 1 me     me 3230 2008-10-14 07:15 foo.txt.gz
[me@linuxbox ~]$ gunzip foo.txt.gz
[me@linuxbox ~]$ ls -l foo.*-rw-r--r-- 1 me     me 15738 2008-10-14 07:15 foo.txt</code></pre>
<h4 id="bzip2"><a class="markdownIt-Anchor" href="#bzip2"></a> bzip2</h4>
<p>这个 bzip2 程序，由 Julian Seward 开发，与 gzip 程序相似，但是使用了不同的压缩算法， 舍弃了压缩速度，而实现了更高的压缩级别。在大多数情况下，它的工作模式等同于 gzip。 由 bzip2 压缩的文件，用扩展名 .bz2 来表示：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ ls -l /etc &gt; foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw-r--r-- 1 me     me      15738 2008-10-17 13:51 foo.txt
[me@linuxbox ~]$ bzip2 foo.txt
[me@linuxbox ~]$ ls -l foo.txt.bz2
-rw-r--r-- 1 me     me      2792 2008-10-17 13:51 foo.txt.bz2
[me@linuxbox ~]$ bunzip2 foo.txt.bz2</code></pre>
<p>正如我们所看到的，bzip2 程序使用起来和 gzip 程序一样。我们之前讨论的 gzip 程序的所有选项（除了-r） ，bzip2 程序同样也支持。注意，然而，压缩级别选项（-number）对于 bzip2 程序来说，有少许不同的含义。 伴随着 bzip2 程序，有 bunzip2 和 bzcat 程序来解压缩文件。bzip2 文件也带有 bzip2recover 程序，其会 试图恢复受损的 .bz2 文件。</p>
<h3 id="归档文件"><a class="markdownIt-Anchor" href="#归档文件"></a> 归档文件</h3>
<p>一个常见的，与文件压缩结合一块使用的文件管理任务是归档。归档就是收集许多文件，并把它们 捆绑成一个大文件的过程。归档经常作为系统备份的一部分来使用。当把旧数据从一个系统移到某 种类型的长期存储设备中时，也会用到归档程序。</p>
<h4 id="tar-打包"><a class="markdownIt-Anchor" href="#tar-打包"></a> tar 打包</h4>
<p>tar命令用于对文件进行打包压缩或解压，格式为</p>
<pre><code class="highlight plaintext">tar [选项] [文件]</code></pre>
<p>在Linux系统中，常见的文件格式比较多，其中主要使用的是.tar或.tar.gz或.tar.bz2格式，我们不用担心格式太多而记不住，其实这些格式大部分都是由tar命令来生成的。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>创建压缩文件</td>
</tr>
<tr>
<td>-x</td>
<td>解开压缩文件</td>
</tr>
<tr>
<td>-t</td>
<td>查看压缩包内有哪些文件</td>
</tr>
<tr>
<td>-z</td>
<td>用Gzip压缩或解压</td>
</tr>
<tr>
<td>-j</td>
<td>用bzip2压缩或解压</td>
</tr>
<tr>
<td>-v</td>
<td>显示压缩或解压的过程</td>
</tr>
<tr>
<td>-f</td>
<td>目标文件名<strong>必须放在最后</strong></td>
</tr>
<tr>
<td>-p</td>
<td>保留原始的权限与属性</td>
</tr>
<tr>
<td>-P</td>
<td>使用绝对路径来压缩</td>
</tr>
<tr>
<td>-C</td>
<td>指定解压到的目录</td>
</tr>
</tbody>
</table>
<blockquote>
<p>-c参数用于创建压缩文件，-x参数用于解压文件，因此这两个参数不能同时使用</p>
</blockquote>
<blockquote>
<p>-z参数指定使用Gzip格式来压缩或解压文件，-j参数指定使用bzip2格式来压缩或解压文件</p>
</blockquote>
<blockquote>
<p>使用-v参数向用户不断显示压缩或解压的过程</p>
</blockquote>
<blockquote>
<p>-C参数用于指定要解压到哪个指定的目录。</p>
</blockquote>
<blockquote>
<p>-f参数特别重要，它必须放到参数的最后一位，代表要压缩或解压的软件包名称</p>
</blockquote>
<p>一般使用压缩/解压命令组合：</p>
<pre><code class="highlight plaintext">tar -czvf 压缩包名称.tar.gz 要打包的目录

tar -xzvf 压缩包名称.tar.gz -C 要解压到的目录</code></pre>
<p>案例：</p>
<ul>
<li>使用tar命令把/etc目录通过gzip格式进行打包压缩，并把文件命名为etc.tar.gz：</li>
</ul>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# tar czvf etc.tar.gz /etc
tar: Removing leading `/&#x27; from member names
/etc/
/etc/fstab
/etc/crypttab
/etc/mtab
/etc/fonts/
/etc/fonts/conf.d/
/etc/fonts/conf.d/65-0-madan.conf
/etc/fonts/conf.d/59-liberation-sans.conf
/etc/fonts/conf.d/90-ttf-arphic-uming-embolden.conf
/etc/fonts/conf.d/59-liberation-mono.conf
/etc/fonts/conf.d/66-sil-nuosu.conf
………………省略部分压缩过程信息………………</code></pre>
<ul>
<li>接下来将打包后的压缩包文件指定解压到/root/etc目录中（先使用mkdir命令来创建/root/etc目录）：</li>
</ul>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# mkdir /root/etc
[root@linuxprobe ~]# tar xzvf etc.tar.gz -C /root/etc
etc/
etc/fstab
etc/crypttab
etc/mtab
etc/fonts/
etc/fonts/conf.d/
etc/fonts/conf.d/65-0-madan.conf
etc/fonts/conf.d/59-liberation-sans.conf
etc/fonts/conf.d/90-ttf-arphic-uming-embolden.conf
etc/fonts/conf.d/59-liberation-mono.conf
etc/fonts/conf.d/66-sil-nuosu.conf
etc/fonts/conf.d/65-1-vlgothic-gothic.conf
etc/fonts/conf.d/65-0-lohit-bengali.conf
etc/fonts/conf.d/20-unhint-small-dejavu-sans.conf
………………省略部分解压过程信息………………</code></pre>
<h4 id="zip"><a class="markdownIt-Anchor" href="#zip"></a> zip</h4>
<p>这个 zip 程序既是压缩工具，也是一个打包工具。这程序使用的文件格式，Windows 用户比较熟悉， 因为它读取和写入.zip 文件。然而，在 Linux 中 gzip 是主要的压缩程序，而 bzip2则位居第二。</p>
<pre><code class="highlight plaintext">$ zip -r playground.zip playground</code></pre>
<p>使用 unzip 程序，来直接抽取一个 zip 文件的内容。</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ cd foo
[me@linuxbox foo]$ unzip ../playground.zip</code></pre>
<h2 id="用户用户组管理"><a class="markdownIt-Anchor" href="#用户用户组管理"></a> 用户/用户组管理</h2>
<p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p>
<p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p>
<p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p>
<ul>
<li>用户账号的添加、删除与修改。</li>
<li>用户口令的管理。</li>
<li>用户组的管理。</li>
</ul>
<h3 id="用户账号的管理"><a class="markdownIt-Anchor" href="#用户账号的管理"></a> 用户账号的管理</h3>
<p>用户账号的管理工作主要涉及到用户账号的添加、修改和删除。</p>
<p>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。</p>
<h4 id="useradd添加新用户"><a class="markdownIt-Anchor" href="#useradd添加新用户"></a> useradd(添加新用户)</h4>
<p>语法：</p>
<pre><code class="highlight plaintext">useradd 选项 用户名</code></pre>
<p>参数说明：</p>
<ul>
<li>-c comment 指定一段注释性描述。</li>
<li>-d 目录 指定用户主目录(默认为/home/username)，如果此目录不存在，则同时使用-m选项，可以创建主目录。</li>
<li>-g 用户组 指定用户所属的用户组。</li>
<li>-G 用户组，用户组 指定用户所属的附加组。</li>
<li>-s Shell文件 指定用户的登录Shell。</li>
<li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li>
<li>-e 账户的到期时间，格式为YYYY-MM-DD</li>
<li>-N 不创建与用户同名的基本用户组</li>
<li>用户名 : 指定新账号的登录名。</li>
</ul>
<p>案例：</p>
<ul>
<li>此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录 /home/sam（/home为默认的用户主目录所在的父目录）</li>
</ul>
<pre><code class="highlight plaintext"># useradd –d  /home/sam -m sam</code></pre>
<ul>
<li>此命令新建了一个用户gem，该用户的登录Shell是 /bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组</li>
</ul>
<pre><code class="highlight plaintext"># useradd -s /bin/sh -g group –G adm,root gem</code></pre>
<blockquote>
<p>增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。</p>
</blockquote>
<blockquote>
<p>Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理</p>
</blockquote>
<h4 id="userdel删除账号"><a class="markdownIt-Anchor" href="#userdel删除账号"></a> userdel(删除账号)</h4>
<p>如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录</p>
<p>删除一个已有的用户账号使用userdel命令，其格式如下：</p>
<p>语法：</p>
<pre><code class="highlight plaintext">userdel 选项 用户名</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-f</td>
<td>强制删除用户</td>
</tr>
<tr>
<td>-r</td>
<td>同时删除用户及用户家目录</td>
</tr>
</tbody>
</table>
<blockquote>
<p>常用的选项是-r，作用是把主目录一起删除</p>
</blockquote>
<p>例如：</p>
<pre><code class="highlight plaintext"># userdel -r sam</code></pre>
<blockquote>
<p>此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录</p>
</blockquote>
<h4 id="usermod修改账号"><a class="markdownIt-Anchor" href="#usermod修改账号"></a> usermod(修改账号)</h4>
<p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。</p>
<p>修改已有用户的信息使用usermod命令，其格式如下：</p>
<pre><code class="highlight plaintext">usermod 选项 用户名</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>填写用户账户的备注信息</td>
</tr>
<tr>
<td>-d</td>
<td>-m 参数-m与参数-d连用，可重新指定用户的家目录并自动把旧的数据转移过去</td>
</tr>
<tr>
<td>-e</td>
<td>账户的到期时间，格式为YYYY-MM-DD</td>
</tr>
<tr>
<td>-g</td>
<td>变更所属用户组</td>
</tr>
<tr>
<td>-G</td>
<td>变更扩展用户组</td>
</tr>
<tr>
<td>-L</td>
<td>锁定用户禁止其登录系统</td>
</tr>
<tr>
<td>-U</td>
<td>解锁用户，允许其登录系统</td>
</tr>
<tr>
<td>-s</td>
<td>变更默认终端</td>
</tr>
<tr>
<td>-u</td>
<td>修改用户的UID</td>
</tr>
</tbody>
</table>
<p>例子：</p>
<p>此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer</p>
<pre><code class="highlight plaintext"># usermod -s /bin/ksh -d /home/z –g developer sam</code></pre>
<h4 id="passwd用户口令的管理"><a class="markdownIt-Anchor" href="#passwd用户口令的管理"></a> passwd(用户口令的管理)</h4>
<p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p>
<p>指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：</p>
<pre><code class="highlight plaintext">passwd 选项 用户</code></pre>
<p>可使用的选项：</p>
<ul>
<li>-l 锁定口令，即禁用账号。</li>
<li>-u 口令解锁。</li>
<li>-d 使该用户可用空密码登录系统。</li>
<li>-e 强迫用户下次登录时修改口令。</li>
<li>-S 显示用户的密码是否可以被锁定，以及密码所采用的加密算法名称</li>
</ul>
<blockquote>
<p>如果默认用户名，则修改当前用户的口令。</p>
</blockquote>
<p>例子：</p>
<p>假设当前用户是sam，则下面的命令修改该用户自己的口令：</p>
<pre><code class="highlight plaintext">$ passwd 
Old password:****** 
New password:******* 
Re-enter new password:*******</code></pre>
<p>如果是超级用户，可以用下列形式指定任何用户的口令：</p>
<pre><code class="highlight plaintext"># passwd sam 
New password:******* 
Re-enter new password:*******</code></pre>
<blockquote>
<p>普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。</p>
</blockquote>
<p>为用户<strong>指定空口令</strong>时，执行下列形式的命令：</p>
<pre><code class="highlight plaintext"># passwd -d sam</code></pre>
<blockquote>
<p>此命令将用户 sam 的口令删除，这样用户 sam 下一次登录时，系统就不再允许该用户登录了</p>
</blockquote>
<p>passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如：</p>
<pre><code class="highlight plaintext"># pwsswd -l sam</code></pre>
<h3 id="用户组的管理"><a class="markdownIt-Anchor" href="#用户组的管理"></a> 用户组的管理</h3>
<p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<p>用户组的管理涉及用户组的添加、删除和修改。<strong>组的增加、删除和修改实际上就是对/etc/group文件的更新</strong>。</p>
<h4 id="group增加用户组"><a class="markdownIt-Anchor" href="#group增加用户组"></a> group(增加用户组)</h4>
<p>语法：</p>
<pre><code class="highlight plaintext">groupadd 选项 用户组</code></pre>
<p>可以使用的选项有：</p>
<ul>
<li>-g GID 指定新用户组的组标识号（GID）</li>
<li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同</li>
</ul>
<p>实例:</p>
<pre><code class="highlight plaintext"># groupadd group1</code></pre>
<blockquote>
<p>此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。</p>
</blockquote>
<p>实例2：</p>
<pre><code class="highlight plaintext"># groupadd -g 101 group2</code></pre>
<blockquote>
<p>此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101</p>
</blockquote>
<h4 id="groupdel删除用户组"><a class="markdownIt-Anchor" href="#groupdel删除用户组"></a> groupdel(删除用户组)</h4>
<p>语法：</p>
<pre><code class="highlight plaintext">groupdel 用户组</code></pre>
<p>例如：</p>
<p>从命令中删除用户组：</p>
<pre><code class="highlight plaintext"># groupdel group1</code></pre>
<h4 id="groupmod修改用户组"><a class="markdownIt-Anchor" href="#groupmod修改用户组"></a> groupmod(修改用户组)</h4>
<p>语法：</p>
<pre><code class="highlight plaintext">groupmod 选项 用户组</code></pre>
<p>常用选项：</p>
<ul>
<li>-g GID 为用户组指定新的组标识号。</li>
<li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li>
<li>-n新用户组 将用户组的名字改为新名字</li>
</ul>
<p>实例：</p>
<ul>
<li>此命令将组group2的组标识号修改为102</li>
</ul>
<pre><code class="highlight plaintext"># groupmod -g 102 group2</code></pre>
<ul>
<li>此命令将组group2的标识号改为10000，组名修改为group3</li>
</ul>
<pre><code class="highlight plaintext"># groupmod –g 10000 -n group3 group2</code></pre>
<h4 id="切换用户组"><a class="markdownIt-Anchor" href="#切换用户组"></a> 切换用户组</h4>
<p>用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：</p>
<pre><code class="highlight plaintext">$ newgrp root</code></pre>
<p>这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。</p>
<h3 id="与用户账号有关的系统文件"><a class="markdownIt-Anchor" href="#与用户账号有关的系统文件"></a> 与用户账号有关的系统文件</h3>
<p>完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。</p>
<p>与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。下面分别介绍这些文件的内容。</p>
<h4 id="etcpasswd-用户信息"><a class="markdownIt-Anchor" href="#etcpasswd-用户信息"></a> /etc/passwd 用户信息</h4>
<p>Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。这个文件对所有用户都是可读的。它的内容类似下面的例子：</p>
<pre><code class="highlight plaintext">＃ cat /etc/passwd

root:x:0:0:Superuser:/:
daemon:x:1:1:System daemons:/etc:
bin:x:2:2:Owner of system commands:/bin:
sys:x:3:3:Owner of system files:/usr/sys:
adm:x:4:4:System accounting:/usr/adm:
uucp:x:5:5:UUCP administrator:/usr/lib/uucp:
auth:x:7:21:Authentication administrator:/tcb/files/auth:
cron:x:9:16:Cron daemon:/usr/spool/cron:
listen:x:37:4:Network daemon:/usr/net/nls:
lp:x:71:18:Printer administrator:/usr/spool/lp:
sam:x:200:50:Sam san:/home/sam:/bin/sh</code></pre>
<p>含义如下：</p>
<ul>
<li>&quot;用户名&quot;是代表用户账号的字符串</li>
<li>“口令”一些系统中，存放着加密后的用户口令字</li>
<li>“用户标识号”是一个整数，系统内部用它来标识用户</li>
<li>“组标识号”字段记录的是用户所属的用户组</li>
<li>“注释性描述”字段记录着用户的一些个人情况</li>
<li>“主目录”，也就是用户的起始工作目录</li>
<li>用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell</li>
</ul>
<pre><code class="highlight plaintext">用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</code></pre>
<blockquote>
<p>由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件<strong>是/etc/shadow文件</strong>。 有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p>
</blockquote>
<blockquote>
<p>/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生</p>
</blockquote>
<hr />
<p><strong>/etc/shadow文件格式</strong></p>
<ul>
<li>&quot;登录名&quot;是与/etc/passwd文件中的登录名相一致的用户账号</li>
<li>&quot;口令&quot;字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。</li>
<li>&quot;最后一次修改时间&quot;表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。</li>
<li>&quot;最小时间间隔&quot;指的是两次修改口令之间所需的最小天数。</li>
<li>&quot;最大时间间隔&quot;指的是口令保持有效的最大天数。</li>
<li>&quot;警告时间&quot;字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</li>
<li>&quot;不活动时间&quot;表示的是用户没有登录活动但账号仍能保持有效的最大天数。</li>
<li>&quot;失效时间&quot;字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</li>
</ul>
<pre><code class="highlight plaintext">登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</code></pre>
<h4 id="etcgroup-用户组"><a class="markdownIt-Anchor" href="#etcgroup-用户组"></a> /etc/group 用户组</h4>
<p>将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。</p>
<p>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。</p>
<p>当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。</p>
<p>用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。</p>
<p>用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：</p>
<pre><code class="highlight plaintext">组名:口令:组标识号:组内用户列表</code></pre>
<ul>
<li>&quot;组名&quot;是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。</li>
<li>&quot;口令&quot;字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*</li>
<li>&quot;组标识号&quot;与用户标识号类似，也是一个整数，被系统内部用来标识组。</li>
<li>&quot;组内用户列表&quot;是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</li>
</ul>
<p>例子：</p>
<pre><code class="highlight plaintext">root::0:root
bin::2:root,bin
sys::3:root,uucp
adm::4:root,adm
daemon::5:root,daemon
lp::7:root,lp
users::20:root,sam</code></pre>
<h4 id="批量添加用户"><a class="markdownIt-Anchor" href="#批量添加用户"></a> 批量添加用户</h4>
<p>添加和删除用户对每位Linux系统管理员都是轻而易举的事，比较棘手的是如果要添加几十个、上百个甚至上千个用户时，我们不太可能还使用useradd一个一个地添加，必然要找一种简便的创建大量用户的方法。Linux系统提供了创建大量用户的工具，可以让您立即创建大量用户，方法如下：</p>
<ol>
<li><strong>先编辑一个文本用户文件</strong><br />
每一列按照/etc/passwd密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。一个范例文件user.txt内容如下：</li>
</ol>
<pre><code class="highlight plaintext">user001::600:100:user:/home/user001:/bin/bash
user002::601:100:user:/home/user002:/bin/bash
user003::602:100:user:/home/user003:/bin/bash
user004::603:100:user:/home/user004:/bin/bash
user005::604:100:user:/home/user005:/bin/bash
user006::605:100:user:/home/user006:/bin/bash</code></pre>
<ol>
<li><strong>以root身份执行命令</strong> /usr/sbin/newusers，从刚创建的用户文件user.txt中导入数据，创建用户：</li>
</ol>
<pre><code class="highlight plaintext"># newusers &lt; user.txt</code></pre>
<ol>
<li><strong>执行命令</strong>/usr/sbin/pwunconv<br />
将 /etc/shadow 产生的 shadow 密码解码，然后回写到 /etc/passwd 中，并将/etc/shadow的shadow密码栏删掉。这是为了方便下一步的密码转换工作，即先取消 shadow password 功能</li>
</ol>
<pre><code class="highlight plaintext"># pwunconv</code></pre>
<ol>
<li><strong>编辑每个用户的密码对照文件</strong></li>
</ol>
<pre><code class="highlight plaintext">user001:123456
user002:123456
user003:123456
user004:123456
user005:123456
user006:123456</code></pre>
<ol>
<li>以root身份执行命令/usr/sbin/chpasswd<br />
创建用户密码，chpasswd 会将经过 /usr/bin/passwd 命令编码过的密码写入 /etc/passwd 的密码栏</li>
</ol>
<pre><code class="highlight plaintext"># chpasswd &lt; passwd.txt</code></pre>
<ol>
<li>确定密码经编码写入/etc/passwd的密码栏后<br />
执行命令 /usr/sbin/pwconv 将密码编码为 shadow password，并将结果写入 /etc/shadow。</li>
</ol>
<pre><code class="highlight plaintext"># pwconv</code></pre>
<blockquote>
<p>这样就完成了大量用户的创建了，之后您可以到/home下检查这些用户宿主目录的权限设置是否都正确，并登录验证用户密码是否正确。</p>
</blockquote>
<h2 id="管道符重定向环境变量"><a class="markdownIt-Anchor" href="#管道符重定向环境变量"></a> 管道符/重定向/环境变量</h2>
<p>既然我们已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p>
<h3 id="输入输出重定向"><a class="markdownIt-Anchor" href="#输入输出重定向"></a> 输入输出重定向</h3>
<p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。</p>
<p>相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及清空写入与追加写入两种模式</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>标准输入重定向（STDIN，文件描述符为0）</td>
<td>默认从键盘输入，也可从其他文件或命令中输入。</td>
</tr>
<tr>
<td>标准输出重定向（STDOUT，文件描述符为1）</td>
<td>默认输出到屏幕。</td>
</tr>
<tr>
<td>错误输出重定向（STDERR，文件描述符为2）</td>
<td>默认输出到屏幕。</td>
</tr>
</tbody>
</table>
<p>比如我们分别查看两个文件的属性信息，其中第二个文件是不存在的，虽然针对这两个文件的操作都分别会在屏幕上输出一些数据信息，但这两个操作的差异其实很大：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# touch linuxprobe
[root@linuxprobe ~]# ls -l linuxprobe 
-rw-r--r--. 1 root root 0 Aug 5 05:35 linuxprobe
[root@linuxprobe ~]# ls -l xxxxxx
ls: cannot access xxxxxx: No such file or directory</code></pre>
<p>在上述命令中，名为linuxprobe的文件是存在的，输出信息是该文件的一些相关权限、所有者、所属组、文件大小及修改时间等信息，这也是该命令的<strong>标准输出信息</strong>。</p>
<p>而名为xxxxxx的第二个文件是不存在的，因此在执行完ls命令之后显示的报错提示信息也是该命令的<strong>错误输出信息</strong>。</p>
<p>那么，要想把原本输出到屏幕上的数据转而写入到文件当中，就要区别对待这两种输出信息。</p>
<p><strong>输入重定向</strong>中用到的符号及其作用</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令 &lt; 文件</td>
<td>将文件作为命令的标准输入</td>
</tr>
<tr>
<td>命令 &lt;&lt; 分界符</td>
<td>从标准输入中读入，直到遇见分界符才停止</td>
</tr>
<tr>
<td>命令 &lt; 文件1 &gt; 文件2</td>
<td>将文件1作为命令的标准输入并将标准输出到文件2</td>
</tr>
</tbody>
</table>
<p><strong>输出重定向</strong>中用到的符号及其作用</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令 &gt; 文件</td>
<td>将标准输出重定向到一个文件中（清空原有文件的数据）</td>
</tr>
<tr>
<td>命令 2&gt; 文件</td>
<td>将错误输出重定向到一个文件中（清空原有文件的数据）</td>
</tr>
<tr>
<td>命令 &gt;&gt; 文件</td>
<td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td>
</tr>
<tr>
<td>命令 2&gt;&gt; 文件</td>
<td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td>
</tr>
<tr>
<td>命令 &gt;&gt; 文件 2&gt;&amp;1 或命令 &amp;&gt;&gt; 文件</td>
<td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>对于重定向中的标准输出模式，可以省略文件描述符1不写，而错误输出模式的文件描述符2是必须要写的</strong>。</p>
</blockquote>
<p>通过标准输出重定向将man bash命令原本要输出到屏幕的信息写入到文件readme.txt中，然后显示readme.txt文件中的内容。具体命令如下：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# man bash &gt; readme.txt
[root@linuxprobe ~]# cat readme.txt</code></pre>
<p><img src="image/-16.png" alt="-16.png" /></p>
<p>案例：</p>
<p>不同命令的标准输出和错误输出还是有区别的。例如查看当前目录中某个文件的信息，这里以linuxprobe文件为例。因为这个文件是真实存在的，<strong>因此使用标准输出即可将原本要输出到屏幕的信息写入到文件中，而错误的输出重定向则依然把信息输出到了屏幕上</strong>。</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# ls -l linuxprobe 
-rw-r--r--. 1 root root 0 Mar  1 13:30 linuxprobe
[root@linuxprobe ~]# ls -l linuxprobe &gt; /root/stderr.txt 
[root@linuxprobe ~]# ls -l linuxprobe 2&gt; /root/stderr.txt 
-rw-r--r--. 1 root root 0 Mar  1 13:30 linuxprobe</code></pre>
<p>如果想把命令的报错信息写入到文件，该怎么操作呢？当用户在执行一个自动化的Shell脚本时，这个操作会特别有用，而且特别实用，因为它可以把整个脚本执行过程中的报错信息都记录到文件中，便于安装后的排错工作。接下来我们以一个不存在的文件进行实验演示：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# ls -l xxxxxx 
cannot access xxxxxx: No such file or directory
[root@linuxprobe ~]# ls -l xxxxxx &gt; /root/stderr.txt
cannot access xxxxxx: No such file or directory
[root@linuxprobe ~]# ls -l xxxxxx 2&gt; /root/stderr.txt
[root@linuxprobe ~]# cat /root/stderr.txt 
ls: cannot access xxxxxx: No such file or directory</code></pre>
<p>输入重定向相对来说有些冷门，在工作中遇到的概率会小一点。输入重定向的作用是把文件直接导入到命令中。接下来使用输入重定向把readme.txt文件导入给wc -l命令，统计一下文件中的内容行数。</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# wc -l &lt; readme.txt</code></pre>
<h3 id="管道命令符"><a class="markdownIt-Anchor" href="#管道命令符"></a> 管道命令符</h3>
<p>管道是Linux中的一种跨进程通信的机制，和重定向不同，管道用做进程与进程之间传送数据。做为Linux中默认的脚本语言，shell中也是可以使用管道的，在shell中，管道用|表示</p>
<p>格式：</p>
<pre><code class="highlight plaintext">命令A | 命令B | . . .</code></pre>
<p>（1）使用管道进行数据筛选内容中包含root的行</p>
<pre><code class="highlight plaintext">ls -l /|grep root</code></pre>
<p>这个例子中，ls命令输出的内容传给了grep命令进行筛选</p>
<p>（2）也可以同时用多个管道使用多个管道把数据筛选并统计</p>
<pre><code class="highlight plaintext">ls -l / | grep root | wc -l</code></pre>
<p>这个例子中，ls命令输出的内容传给了grep命令进行筛选，然后转给wc命令统计行数。</p>
<p>（3）用翻页的形式查看/etc目录中的文件列表及属性信息</p>
<pre><code class="highlight plaintext">ls -l /etc/ | more</code></pre>
<hr />
<p>为了更好的理解管道，写两个脚本来体验一下：</p>
<p>in.sh文件</p>
<pre><code class="highlight plaintext">#! /bin/bash
read msg
echo &quot;Receive :$&#123;msg&#125;&quot;</code></pre>
<p>out.sh文件</p>
<pre><code class="highlight plaintext">#! /bin/bash
echo &#x27;hello&#x27;</code></pre>
<p>执行：</p>
<pre><code class="highlight plaintext">./out.sh |./in.sh

输出：
Receive :hello</code></pre>
<blockquote>
<p>符合我们预期，<a target="_blank" rel="noopener" href="http://xn--helloout-ue0mp4cm79e503f.xn--shin-rs5fy5a20ner8l.sh">字符串hello从out.sh传送到了in.sh</a></p>
</blockquote>
<h3 id="命令行的通配符"><a class="markdownIt-Anchor" href="#命令行的通配符"></a> 命令行的通配符</h3>
<p>在开始使用命令之前，我们需要介绍一个使命令行如此强大的 shell 特性。因为 shell 频繁地使用 文件名，shell 提供了特殊字符来帮助你快速指定一组文件名。这些特殊字符叫做通配符。 使用通配符（也以文件名代换著称）允许你依据字符类型来选择文件名。下表列出这些通配符 以及它们所选择的对象：</p>
<p><strong>通配符</strong></p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配任意多个字符（包括零个或一个）</td>
</tr>
<tr>
<td>？</td>
<td>匹配任意一个字符（不包括零个）</td>
</tr>
<tr>
<td>[characters]</td>
<td>匹配任意一个属于字符集中的字符</td>
</tr>
<tr>
<td>[!characters]</td>
<td>匹配任意一个不是字符集中的字符</td>
</tr>
<tr>
<td>[[:class:]]</td>
<td>匹配任意一个属于指定字符类中的字符</td>
</tr>
</tbody>
</table>
<p><strong>普遍使用的字符类</strong></p>
<table>
<thead>
<tr>
<th>字符类</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>[:alnum:]</td>
<td>匹配任意一个字母或数字</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>匹配任意一个字母</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>匹配任意一个数字</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>匹配任意一个小写字母</td>
</tr>
<tr>
<td>[:upper]</td>
<td>匹配任意一个大写字母</td>
</tr>
</tbody>
</table>
<p><strong>案例：</strong></p>
<table>
<thead>
<tr>
<th>模式</th>
<th>匹配对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>所有文件</td>
</tr>
<tr>
<td>g*</td>
<td>文件名以“g”开头的文件</td>
</tr>
<tr>
<td>b*.txt</td>
<td>以&quot;b&quot;开头，中间有零个或任意多个字符，并以&quot;.txt&quot;结尾的文件</td>
</tr>
<tr>
<td>Data???</td>
<td>以“Data”开头，其后紧接着3个字符的文件</td>
</tr>
<tr>
<td>[abc]*</td>
<td>文件名以&quot;a&quot;,“b”,或&quot;c&quot;开头的文件</td>
</tr>
<tr>
<td>BACKUP.[0-9][0-9][0-9]</td>
<td>以&quot;BACKUP.&quot;开头，并紧接着3个数字的文件</td>
</tr>
<tr>
<td>[[:upper:]]*</td>
<td>以大写字母开头的文件</td>
</tr>
<tr>
<td>[![:digit:]]*</td>
<td>不以数字开头的文件</td>
</tr>
<tr>
<td><code>*[[:lower:]123]</code></td>
<td>文件名以小写字母结尾，或以 “1”，“2”，或 “3” 结尾的文件</td>
</tr>
</tbody>
</table>
<blockquote>
<p>接受文件名作为参数的任何命令，都可以使用通配符</p>
</blockquote>
<h3 id="常用的转义字符"><a class="markdownIt-Anchor" href="#常用的转义字符"></a> 常用的转义字符</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>反斜杠（\）</td>
<td>使反斜杠后面的一个字符变为单纯的字符。</td>
</tr>
<tr>
<td>单引号（‘’）</td>
<td>单引号里的任何字符都会原样输出，单引号中的变量是无效的，单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</td>
</tr>
<tr>
<td>双引号（“”）</td>
<td>双引号中可以有变量，双引号中可以出现转义字符</td>
</tr>
<tr>
<td><code>反引号（``）</code></td>
<td>把其中的命令执行后返回结果。</td>
</tr>
</tbody>
</table>
<p>我们先定义一个名为PRICE的变量并赋值为5，然后输出以双引号括起来的字符串与变量信息：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# PRICE=5
[root@linuxprobe ~]# echo &quot;Price is $PRICE&quot;
Price is 5

[root@linuxprobe ~]# echo &#x27;Price is $PRICE&#x27;
Price is $PRICE</code></pre>
<p>要想让第一个“$”乖乖地作为美元符号，那么就需要使用反斜杠（\）来进行转义，将这个命令提取符转义成单纯的文本，去除其特殊功能。</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# echo &quot;Price is $$PRICE&quot;
Price is 3767PRICE

[root@linuxprobe ~]# echo &quot;Price is \$$PRICE&quot;
Price is $5</code></pre>
<p>如果只需要某个命令的输出值时，可以像命令这样，将命令用反引号括起来，达到预期的效果。例如，将反引号与uname -a命令结合，然后使用echo命令来查看本机的Linux版本和内核信息：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# echo `uname -a`
Linux linuxprobe.com 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2017 x86_64 x86_64 x86_64 GNU/Linux</code></pre>
<h3 id="重要的环境变量"><a class="markdownIt-Anchor" href="#重要的环境变量"></a> 重要的环境变量</h3>
<p>变量是计算机系统用于保存可变值的数据类型。在Linux系统中，变量名称一般都是大写的，这是一种约定俗成的规范。我们可以直接通过变量名称来提取到对应的变量值。Linux系统中的环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录、邮件存放位置等。</p>
<p>为了通过环境变量帮助Linux系统构建起能够为用户提供服务的工作运行环境，需要数百个变量协同工作才能完成。</p>
<p>前文中曾经讲到，在Linux系统中一切都是文件，Linux命令也不例外。那么，在用户执行了一条命令之后，Linux系统中到底发生了什么事情呢？简单来说，命令在Linux中的执行分为4个步骤。</p>
<ul>
<li><strong>第1步</strong>：判断用户是否以绝对路径或相对路径的方式输入命令（如/bin/ls），如果是的话则直接执行。</li>
<li><strong>第2步</strong>：Linux系统检查用户输入的命令是否为“别名命令”，即用一个自定义的命令名称来替换原本的命令名称。可以<strong>用alias命令来创建一个属于自己的命令别名</strong>，格式为“<strong>alias 别名=命令</strong>”。若要取消一个命令别名，则是用unalias命令，格式为“<strong>unalias 别名</strong>”。我们之前在使用rm命令删除文件时，Linux系统都会要求我们再确认是否执行删除操作，其实这就是Linux系统为了防止用户误删除文件而特意设置的rm别名命令，接下来我们把它取消掉：</li>
</ul>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# ls
anaconda-ks.cfg Documents initial-setup-ks.cfg Pictures Templates
Desktop Downloads Music Public Videos
[root@linuxprobe ~]# rm anaconda-ks.cfg 
rm: remove regular file ‘anaconda-ks.cfg’? y
[root@linuxprobe~]# alias rm
alias rm=&#x27;rm -i&#x27;
[root@linuxprobe ~]# unalias rm
[root@linuxprobe ~]# rm initial-setup-ks.cfg 
[root@linuxprobe ~]#</code></pre>
<ul>
<li><strong>第3步</strong>：Bash解释器判断用户输入的是内部命令还是外部命令。内部命令是解释器内部的指令，会被直接执行；而用户在绝大部分时间输入的是外部命令，这些命令交由步骤4继续处理。可以使用“<strong>type命令名称</strong>”来判断用户输入的命令是内部命令还是外部命令。</li>
<li><strong>第4步</strong>：系统在多个路径中查找用户输入的命令文件，而定义这些路径的变量叫作PATH，可以简单地把它理解成是“解释器的小助手”，作用是告诉Bash解释器待执行的命令可能存放的位置，然后Bash解释器就会乖乖地在这些位置中逐个查找。PATH是由多个路径值组成的变量，每个路径值之间用<strong>冒号</strong>间隔，对这些路径的增加和删除操作将影响到Bash解释器对Linux命令的查找。</li>
</ul>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# echo $PATH
/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin
[root@linuxprobe ~]# PATH=$PATH:/root/bin
[root@linuxprobe ~]# echo $PATH
/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/root/bin</code></pre>
<p>我们可以<strong>使用env命令</strong>来查看到Linux系统中<strong>所有的环境变量</strong>，而最重要的10个环境变量，如表所示：</p>
<table>
<thead>
<tr>
<th>变量名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>HOME</td>
<td>用户的主目录（即家目录）</td>
</tr>
<tr>
<td>SHELL</td>
<td>用户在使用的Shell解释器名称</td>
</tr>
<tr>
<td>HISTSIZE</td>
<td>输出的历史命令记录条数</td>
</tr>
<tr>
<td>HISTFILESIZE</td>
<td>保存的历史命令记录条数</td>
</tr>
<tr>
<td>MAIL</td>
<td>邮件保存路径</td>
</tr>
<tr>
<td>LANG</td>
<td>系统语言、语系名称</td>
</tr>
<tr>
<td>RANDOM</td>
<td>生成一个随机数字</td>
</tr>
<tr>
<td>PS1</td>
<td>Bash解释器的提示符</td>
</tr>
<tr>
<td>PATH</td>
<td>定义解释器搜索用户执行命令的路径</td>
</tr>
<tr>
<td>EDITOR</td>
<td>用户默认的文本编辑器</td>
</tr>
</tbody>
</table>
<p>Linux作为一个多用户多任务的操作系统，能够为每个用户提供独立的、合适的工作运行环境，因此，<strong>一个相同的变量会因为用户身份的不同而具有不同的值</strong>。例如，我们使用下述命令来查看HOME变量在不同用户身份下都有哪些值</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# echo $HOME
/root
[root@linuxprobe ~]# su - linuxprobe
Last login: Fri Feb 27 19:49:57 CST 2017 on pts/0
[linuxprobe@linuxprobe ~]$ echo $HOME
/home/linuxprobe</code></pre>
<p>其实变量是由固定的变量名与用户或系统设置的变量值两部分组成的，我们完全可以自行创建变量，来满足工作需求。例如设置一个名称为WORKDIR的变量，方便用户更轻松地进入一个层次较深的目录：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# mkdir /home/workdir
[root@linuxprobe ~]# WORKDIR=/home/workdir
[root@linuxprobe ~]# cd $WORKDIR 
[root@linuxprobe workdir]# pwd
/home/workdir</code></pre>
<p>但是，这样的变量不具有全局性，作用范围也有限，默认情况下不能被其他用户使用。如果工作需要，<strong>可以使用export命令将其提升为全局变量</strong>，这样其他用户也就可以使用它了：</p>
<pre><code class="highlight plaintext">[root@linuxprobe workdir]# su linuxprobe
Last login: Fri Mar 20 20:52:10 CST 2017 on pts/0
[linuxprobe@linuxprobe ~]$ cd $WORKDIR
[linuxprobe@linuxprobe ~]$ echo $WORKDIR
[linuxprobe@linuxprobe ~]$ exit
[root@linuxprobe ~]# export WORKDIR
[root@linuxprobe ~]# su linuxprobe
Last login: Fri Mar 20 21:52:10 CST 2017 on pts/0
[linuxprobe@linuxprobe ~]$ cd $WORKDIR
[linuxprobe@linuxprobe workdir]$ pwd
/home/workdir</code></pre>
<h2 id="存储结构磁盘划分"><a class="markdownIt-Anchor" href="#存储结构磁盘划分"></a> 存储结构/磁盘划分</h2>
<table>
<thead>
<tr>
<th>目录名称</th>
<th>应放置文件的内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>/boot</td>
<td>开机所需文件—内核、开机菜单以及所需配置文件等</td>
</tr>
<tr>
<td>/dev</td>
<td>以文件形式存放任何设备与接口</td>
</tr>
<tr>
<td>/etc</td>
<td>配置文件</td>
</tr>
<tr>
<td>/home</td>
<td>用户主目录</td>
</tr>
<tr>
<td>/bin</td>
<td>存放单用户模式下还可以操作的命令</td>
</tr>
<tr>
<td>/lib</td>
<td>开机时用到的函数库，以及/bin与/sbin下面的命令要调用的函数</td>
</tr>
<tr>
<td>/sbin</td>
<td>开机过程中需要的命令</td>
</tr>
<tr>
<td>/media</td>
<td>用于挂载设备文件的目录</td>
</tr>
<tr>
<td>/opt</td>
<td>放置第三方的软件</td>
</tr>
<tr>
<td>/root</td>
<td>系统管理员的家目录</td>
</tr>
<tr>
<td>/srv</td>
<td>一些网络服务的数据文件目录</td>
</tr>
<tr>
<td>/tmp</td>
<td>任何人均可使用的“共享”临时目录</td>
</tr>
<tr>
<td>/proc</td>
<td>虚拟文件系统，例如系统内核、进程、外部设备及网络状态等</td>
</tr>
<tr>
<td>/usr/local</td>
<td>用户自行安装的软件</td>
</tr>
<tr>
<td>/usr/sbin</td>
<td>Linux系统开机时不会使用到的软件/命令/脚本</td>
</tr>
<tr>
<td>/usr/share</td>
<td>帮助与说明文件，也可放置共享文件</td>
</tr>
<tr>
<td>/var</td>
<td>主要存放经常变化的文件，如日志</td>
</tr>
<tr>
<td>/lost+found</td>
<td>当文件系统发生错误时，将一些丢失的文件片段存放在这里</td>
</tr>
</tbody>
</table>
<h3 id="物理设备的命名规则"><a class="markdownIt-Anchor" href="#物理设备的命名规则"></a> 物理设备的命名规则</h3>
<p>在Linux系统中一切都是文件，硬件设备也不例外。既然是文件，就必须有文件名称。系统内核中的udev设备管理器会自动把硬件名称规范起来，目的是让用户通过设备文件的名字可以猜出设备大致的属性以及分区信息等；这对于陌生的设备来说特别方便。另外，udev设备管理器的服务会一直以守护进程的形式运行并侦听内核发出的信号来管理/dev目录下的设备文件。</p>
<p>Linux系统中常见的硬件设备的文件名称如表所示</p>
<table>
<thead>
<tr>
<th>硬件设备</th>
<th>文件名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDE设备</td>
<td>/dev/hd[a-d]</td>
</tr>
<tr>
<td>SCSI/SATA/U盘</td>
<td>/dev/sd[a-p]</td>
</tr>
<tr>
<td>软驱</td>
<td>/dev/fd[0-1]</td>
</tr>
<tr>
<td>打印机</td>
<td>/dev/lp[0-15]</td>
</tr>
<tr>
<td>光驱</td>
<td>/dev/cdrom</td>
</tr>
<tr>
<td>鼠标</td>
<td>/dev/mouse</td>
</tr>
<tr>
<td>磁带机</td>
<td>/dev/st0或/dev/ht0</td>
</tr>
</tbody>
</table>
<p>由于现在的IDE设备已经很少见了，所以一般的硬盘设备都会是以“/dev/sd”开头的。而一台主机上可以有多块硬盘，因此系统采用a～p来代表16块不同的硬盘（默认从a开始分配），而且硬盘的分区编号也很有讲究：</p>
<ul>
<li>主分区或扩展分区的编号从1开始，到4结束；</li>
<li>逻辑分区从编号5开始。</li>
</ul>
<p><img src="image/-17.png" alt="-17.png" /></p>
<p>首先，/dev/目录中保存的应当是硬件设备文件；其次，sd表示是存储设备；然后，a表示系统中同类接口中第一个被识别到的设备，最后，5表示这个设备是一个逻辑分区。一言以蔽之，“/dev/sda5”表示的就是“<strong>这是系统中第一块被识别到的硬件设备中分区编号为5的逻辑分区的设备文件</strong>”</p>
<h3 id="挂载硬件设备"><a class="markdownIt-Anchor" href="#挂载硬件设备"></a> 挂载硬件设备</h3>
<h4 id="mount"><a class="markdownIt-Anchor" href="#mount"></a> mount</h4>
<p>我们在用惯了Windows系统后总觉得一切都是理所当然的，平时把U盘插入到电脑后也从来没有考虑过Windows系统做了哪些事情，才使得我们可以访问这个U盘的。接下来我们会逐一学习在Linux系统中挂载和卸载存储设备的方法，以便大家更好地了解Linux系统添加硬件设备的工作原理和流程。前面讲到，在拿到一块全新的硬盘存储设备后要先分区，然后格式化，最后才能挂载并正常使用。“分区”和“格式化”大家以前经常听到，但“挂载”又是什么呢？刘遄老师在这里给您一个最简单、最贴切的解释—<strong>当用户需要使用硬盘设备或分区中的数据时，需要先将其与一个已存在的目录文件进行关联，而这个关联动作就是“挂载”</strong>。</p>
<p><strong>mount命令</strong>用于挂载文件系统，格式为</p>
<pre><code class="highlight plaintext">mount 文件系统 挂载目录</code></pre>
<p>挂载是在使用硬件设备前所执行的最后一步操作。只需使用mount命令把硬盘设备或分区与一个目录文件进行关联，然后就能在这个目录中看到硬件设备中的数据了。对于比较新的Linux系统来讲，一般不需要使用-t参数来指定文件系统的类型，Linux系统会自动进行判断。而mount 中的-a参数则厉害了，它会在执行后自动检查/etc/fstab文件中有无疏漏被挂载的设备文件，如果有，则进行自动挂载操作。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>挂载所有在/etc/fstab中定义的文件系统</td>
</tr>
<tr>
<td>-t</td>
<td>指定文件系统的类型</td>
</tr>
</tbody>
</table>
<p>例如，要把设备/dev/sdb2挂载到/backup目录，只需要在mount命令中填写设备与挂载目录参数就行，系统会自动去判断要挂载文件的类型，因此只需要执行下述命令即可：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# mount /dev/sdb2 /backup</code></pre>
<hr />
<p>虽然按照上面的方法执行mount命令后就能立即使用文件系统了，但系统在<strong>重启后挂载就会失效</strong>，也就是说我们需要每次开机后都手动挂载一下。这肯定不是我们想要的效果，如果想<strong>让硬件设备和目录永久地进行自动关联</strong>，就必须把挂载信息按照指定的填写格式“设备文件 挂载目录 格式类型 权限选项 是否备份 是否自检”写入<strong>到/etc/fstab文件中</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>设备文件</td>
<td>一般为设备的路径+设备名称，也可以写唯一识别码（UUID，Universally Unique Identifier）</td>
</tr>
<tr>
<td>挂载目录</td>
<td>指定要挂载到的目录，需在挂载前创建好</td>
</tr>
<tr>
<td>格式类型</td>
<td>指定文件系统的格式，比如Ext3、Ext4、XFS、SWAP、iso9660（此为光盘设备）等</td>
</tr>
<tr>
<td>权限选项</td>
<td>若设置为defaults，则默认权限为：rw, suid, dev, exec, auto, nouser, async</td>
</tr>
<tr>
<td>是否备份</td>
<td>若为1则开机后使用dump进行磁盘备份，为0则不备份</td>
</tr>
<tr>
<td>是否自检</td>
<td>若为1则开机后自动进行磁盘自检，为0则不自检</td>
</tr>
</tbody>
</table>
<p>如果想将文件系统为ext4的硬件设备/dev/sdb2在开机后自动挂载到/backup目录上，并保持默认权限且无需开机自检，就需要在/etc/fstab文件中写入下面的信息，这样在系统重启后也会成功挂载。</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# vim /etc/fstab
#
# /etc/fstab
# Created by anaconda on Wed May 4 19:26:23 2017
#
# Accessible filesystems, by reference, are maintained under &#x27;/dev/disk&#x27;
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
#
/dev/mapper/rhel-root / xfs defaults 1 1
UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b /boot xfs defaults 1 2
/dev/mapper/rhel-swap swap swap defaults 0 0
/dev/cdrom /media/cdrom iso9660 defaults 0 0 
/dev/sdb2 /backup ext4 defaults 0 0</code></pre>
<hr />
<h4 id="umount"><a class="markdownIt-Anchor" href="#umount"></a> umount</h4>
<p><strong>umount命令用于撤销已经挂载的设备文件</strong>，格式为</p>
<pre><code class="highlight plaintext">umount [挂载点/设备文件]</code></pre>
<p>我们挂载文件系统的目的是为了使用硬件资源，而卸载文件系统就意味不再使用硬件的设备资源；相对应地，挂载操作就是把硬件设备与目录进行关联的动作，因此卸载操作只需要说明想要取消关联的设备文件或挂载目录的其中一项即可，一般不需要加其他额外的参数。我们来尝试手动卸载掉/dev/sdb2设备文件：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# umount /dev/sdb2</code></pre>
<h3 id="添加硬盘设备"><a class="markdownIt-Anchor" href="#添加硬盘设备"></a> 添加硬盘设备</h3>
<ul>
<li>在虚拟机添加一个硬盘</li>
</ul>
<p><img src="image/-18.png" alt="-18.png" /></p>
<p>在虚拟机中模拟添加了硬盘设备后就应该能看到抽象成的硬盘设备文件了。按照前文讲解的udev服务命名规则，第二个被识别的SCSI设备应该会被保存为/dev/sdb，这个就是硬盘设备文件了。但在开始使用该硬盘之前还需要进行分区操作，例如从中取出一个2GB的分区设备以供后面的操作使用。</p>
<h4 id="fdisk命令分区"><a class="markdownIt-Anchor" href="#fdisk命令分区"></a> fdisk命令（分区）</h4>
<p>在Linux系统中，管理硬盘设备最常用的方法就当属fdisk命令了。fdisk命令用于管理磁盘分区，格式为</p>
<pre><code class="highlight plaintext">fdisk [磁盘名称]</code></pre>
<p>它提供了集添加、删除、转换分区等功能于一身的“一站式分区服务”。不过与前面讲解的直接写到命令后面的参数不同，这条命令的参数是交互式的，因此在管理硬盘设备时特别方便，可以根据需求动态调整。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>m</td>
<td>查看全部可用的参数</td>
</tr>
<tr>
<td>n</td>
<td>添加新的分区</td>
</tr>
<tr>
<td>d</td>
<td>删除某个分区信息</td>
</tr>
<tr>
<td>l</td>
<td>列出所有可用的分区类型</td>
</tr>
<tr>
<td>t</td>
<td>改变某个分区的类型</td>
</tr>
<tr>
<td>p</td>
<td>查看分区表信息</td>
</tr>
<tr>
<td>w</td>
<td>保存并退出</td>
</tr>
<tr>
<td>q</td>
<td>不保存直接退出</td>
</tr>
</tbody>
</table>
<ul>
<li>第1步：我们首先使用fdisk命令来尝试管理/dev/sdb硬盘设备<br />
<img src="image/-19.png" alt="-19.png" /></li>
<li>第2步：输入参数n尝试添加新的分区。系统会要求您是选择继续输入参数p来创建主分区，还是输入参数e来创建扩展分区。这里输入参数p来创建一个主分区：<br />
<img src="image/-20.png" alt="-20.png" /></li>
<li>第3步：在确认创建一个主分区后，系统要求您先输入主分区的编号。我们在前文得知，主分区的编号范围是1～4，因此这里输入默认的1就可以了。接下来系统会提示定义起始的扇区位置，这不需要改动，我们敲击回车键保留默认设置即可，系统会自动计算出最靠前的空闲扇区的位置。最后，系统会要求定义分区的结束扇区位置，这其实就是要去定义整个分区的大小是多少。我们不用去计算扇区的个数，只需要输入+2G即可创建出一个容量为2GB的硬盘分区。<br />
<img src="image/-21.png" alt="-21.png" /></li>
<li>第4步：再次使用参数p来查看硬盘设备中的分区信息。果然就能看到一个名称为/dev/sdb1、起始扇区位置为2048、结束扇区位置为4196351的主分区了。这时候千万不要直接关闭窗口，而应该敲击参数w后回车，这样分区信息才是真正的写入成功啦。<br />
<img src="image/-22.png" alt="-22.png" /></li>
<li>第5步：在上述步骤执行完毕之后，Linux系统会自动把这个硬盘主分区抽象成/dev/sdb1设备文件。我们可以使用file命令查看该文件的属性，但是刘遄老师在讲课和工作中发现，有些时候系统并没有自动把分区信息同步给Linux内核，而且这种情况似乎还比较常见（但不能算作是严重的bug）。我们可以输入partprobe命令手动将分区信息同步到内核，而且一般推荐连续两次执行该命令，效果会更好。如果使用这个命令都无法解决问题，那么就重启计算机吧，这个杀手锏百试百灵，一定会有用的。<br />
<img src="image/-23.png" alt="-23.png" /></li>
</ul>
<h4 id="mkfs格式化"><a class="markdownIt-Anchor" href="#mkfs格式化"></a> mkfs（格式化）</h4>
<p>如果硬件存储设备没有进行格式化，则Linux系统无法得知怎么在其上写入数据。因此，在对存储设备进行分区后还需要进行格式化操作。在Linux系统中用于格式化操作的命令是mkfs。这条命令很有意思，因为在Shell终端中输入mkfs名后再敲击两下用于补齐命令的Tab键，会有如下所示的效果：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# mkfs
mkfs mkfs.cramfs mkfs.ext3 mkfs.fat mkfs.msdos mkfs.xfsmkfs.btrfs mkfs.ext2 mkfs.ext4 mkfs.minix mkfs.vfat</code></pre>
<p>对！这个mkfs命令很贴心地把常用的文件系统名称用后缀的方式保存成了多个命令文件，用起来也非常简单—mkfs.文件类型名称。例如要格式分区为XFS的文件系统，则命令应为mkfs.xfs /dev/sdb1。</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# mkfs.xfs /dev/sdb1
meta-data=/dev/sdb1 isize=256 agcount=4, agsize=131072 blks
 = sectsz=512 attr=2, projid32bit=1
 = crc=0
data = bsize=4096 blocks=524288, imaxpct=25
 = sunit=0 swidth=0 blks
naming =version 2 bsize=4096 ascii-ci=0 ftype=0
log =internal log bsize=4096 blocks=2560, version=2
 = sectsz=512 sunit=0 blks, lazy-count=1
realtime =none extsz=4096 blocks=0, rtextents=0</code></pre>
<p>终于完成了存储设备的分区和格式化操作，接下来就是要来挂载并使用存储设备了。与之相关的步骤也非常简单：首先是创建一个用于挂载设备的挂载点目录；然后使用mount命令将存储设备与挂载点进行关联；最后使用df -h命令来查看挂载状态和硬盘使用量信息。</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# mkdir /newFS
[root@linuxprobe ~]# mount /dev/sdb1 /newFS/
[root@linuxprobe ~]# df -h
Filesystem Size Used Avail Use% Mounted on
/dev/mapper/rhel-root 18G 3.5G 15G 20% /
devtmpfs 905M 0 905M 0% /dev
tmpfs 914M 140K 914M 1% /dev/shm
tmpfs 914M 8.8M 905M 1% /run
tmpfs 914M 0 914M 0% /sys/fs/cgroup
/dev/sr0 3.5G 3.5G 0 100% /media/cdrom
/dev/sda1 497M 119M 379M 24% /boot
/dev/sdb1 2.0G 33M 2.0G 2% /newFS</code></pre>
<h4 id="du查看文件数据占用量"><a class="markdownIt-Anchor" href="#du查看文件数据占用量"></a> du（查看文件数据占用量）</h4>
<p>既然存储设备已经顺利挂载，接下来就可以尝试通过挂载点目录向存储设备中写入文件了。在写入文件之前，先介绍一个用于查看文件数据占用量的du命令，其格式为</p>
<pre><code class="highlight plaintext">du [选项] [文件]</code></pre>
<p>简单来说，该命令就是用来查看一个或多个文件占用了多大的硬盘空间。我们还可以使用</p>
<pre><code class="highlight plaintext">du -sh /*</code></pre>
<p>命令来查看在Linux系统根目录下所有一级目录分别占用的空间大小。下面，我们先从某些目录中复制过来一批文件，然后查看这些文件总共占用了多大的容量：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# cp -rf /etc/* /newFS/
[root@linuxprobe ~]# ls /newFS/
abrt hosts pulse
adjtime hosts.allow purple
aliases hosts.deny qemu-ga
aliases.db hp qemu-kvm
alsa idmapd.conf radvd.conf
alternatives init.d rc0.d
anacrontab inittab rc1.d
………………省略部分输入信息………………
[root@linuxprobe ~]# du -sh /newFS/
33M /newFS/</code></pre>
<blockquote>
<p>细心的读者一定还记得，前面在讲解mount命令时提到，使用mount命令挂载的设备文件会在系统下一次重启的时候失效。如果想让这个设备文件的挂载永久有效，则需要把挂载的信息写入到配置文件/etc/fstab中</p>
</blockquote>
<h3 id="添加交换分区"><a class="markdownIt-Anchor" href="#添加交换分区"></a> 添加交换分区</h3>
<p>SWAP（交换）分区是一种通过在硬盘中预先划分一定的空间，然后将把内存中暂时不常用的数据临时存放到硬盘中，以便腾出物理内存空间让更活跃的程序服务来使用的技术，其设计目的是为了解决真实物理内存不足的问题。但由于交换分区毕竟是通过硬盘设备读写数据的，速度肯定要比物理内存慢，所以只有当真实的物理内存耗尽后才会调用交换分区的资源。</p>
<p>交换分区的创建过程与前文讲到的挂载并使用存储设备的过程非常相似。在对/dev/sdb存储设备进行分区操作前，有必要先说一下交换分区的划分建议：在生产环境中，交换分区的大小一般为真实物理内存的1.5～2倍，为了让大家更明显地感受交换分区空间的变化，这里取出一个大小为5GB的主分区作为交换分区资源。在分区创建完毕后保存并退出即可：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# fdisk /dev/sdb
Welcome to fdisk (util-linux 2.23.2).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.
Device does not contain a recognized partition table
Building a new DOS disklabel with disk identifier 0xb3d27ce1.
Command (m for help): n
Partition type:
p primary (1 primary, 0 extended, 3 free)
e extendedSelect (default p): p
Partition number (2-4, default 2): 
First sector (4196352-41943039, default 4196352): 此处敲击回车
Using default value 4196352
Last sector, +sectors or +size&#123;K,M,G&#125; (4196352-41943039, default 41943039): +5G
Partition 2 of type Linux and of size 5 GiB is set
Command (m for help): p
Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0xb0ced57f
 Device Boot Start End Blocks Id System
/dev/sdb1 2048 4196351 2097152 83 Linux
/dev/sdb2 4196352 14682111 5242880 83 Linux
Command (m for help): w
The partition table has been altered!
Calling ioctl() to re-read partition table.
WARNING: Re-reading the partition table failed with error 16: Device or resource busy.
The kernel still uses the old table. The new table will be used at
the next reboot or after you run partprobe(8) or kpartx(8)
Syncing disks.</code></pre>
<p>使用SWAP分区专用的格式化命令<strong>mkswap</strong>，对新建的主分区进行格式化操作：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# mkswap /dev/sdb2
Setting up swapspace version 1, size = 5242876 KiB
no label, UUID=2972f9cb-17f0-4113-84c6-c64b97c40c75</code></pre>
<p><strong>使用swapon命令把准备好的SWAP分区设备正式挂载到系统中</strong>。我们可以使用free -m命令查看交换分区的大小变化（由2047MB增加到7167MB）：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# free -m
total used free shared buffers cached
Mem: 1483 782 701 9 0 254
-/+ buffers/cache: 526 957
Swap: 2047 0 2047
[root@linuxprobe ~]# swapon /dev/sdb2
[root@linuxprobe ~]# free -m
total used free shared buffers cached
Mem: 1483 785 697 9 0 254
-/+ buffers/cache: 530 953
Swap: 7167 0 7167</code></pre>
<p>为了能够让新的交换分区设备在重启后依然生效，需要按照下面的格式将相关信息写入到配置文件中，并记得保存：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# vim /etc/fstab
#
# /etc/fstab
# Created by anaconda on Wed May 4 19:26:23 2017
#
# Accessible filesystems, by reference, are maintained under &#x27;/dev/disk&#x27;
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
#
/dev/mapper/rhel-root / xfs defaults 1 1
UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b /boot xfs defaults 1 2
/dev/mapper/rhel-swap swap swap defaults 0 0
/dev/cdrom /media/cdrom iso9660 defaults 0 0 
/dev/sdb1 /newFS xfs defaults 0 0 
/dev/sdb2 swap swap defaults 0 0</code></pre>
<h2 id="vivim"><a class="markdownIt-Anchor" href="#vivim"></a> vi/vim</h2>
<p>Vim之所以能得到广大厂商与用户的认可，原因在于Vim编辑器中设置了三种模式—命令模式、末行模式和编辑模式，每种模式分别又支持多种不同的命令快捷键，这大大提高了工作效率，而且用户在习惯之后也会觉得相当顺手。要想高效率地操作文本，就必须先搞清这三种模式的操作区别以及模式之间的切换方法</p>
<ul>
<li><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</li>
<li><strong>输入模式</strong>：正常的文本录入。</li>
<li><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</li>
</ul>
<p><img src="image/-24.png" alt="-24.png" /></p>
<p>在每次运行Vim编辑器时，<strong>默认进入命令模式</strong>，此时需要先切换到输入模式后再进行文档编写工作，而每次在<strong>编写完文档后需要先返回命令模式，然后再进入末行模式，执行文档的保存或退出操作</strong>。</p>
<p><strong>命令模式</strong>中最常用的一些命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>dd</td>
<td>删除（剪切）光标所在整行</td>
</tr>
<tr>
<td>5dd</td>
<td>删除（剪切）从光标处开始的5行</td>
</tr>
<tr>
<td>yy</td>
<td>复制光标所在整行</td>
</tr>
<tr>
<td>5yy</td>
<td>复制从光标处开始的5行</td>
</tr>
<tr>
<td>n</td>
<td><strong>显示搜索命令定位到的下一个字符串</strong></td>
</tr>
<tr>
<td>N</td>
<td>显示搜索命令定位到的上一个字符串</td>
</tr>
<tr>
<td>u</td>
<td>撤销上一步的操作</td>
</tr>
<tr>
<td>p</td>
<td>将之前删除（dd）或复制（yy）过的数据粘贴到光标后面</td>
</tr>
<tr>
<td>i</td>
<td><strong>进入输入模式</strong></td>
</tr>
</tbody>
</table>
<p><strong>末行模式</strong>主要用于保存或退出文件，以及设置Vim编辑器的工作环境，还可以让用户执行外部的Linux命令或跳转到所编写文档的特定行数。要想切换到末行模式，在命令模式中输入一个冒号就可以了</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>:w</td>
<td>保存</td>
</tr>
<tr>
<td>:q</td>
<td>退出</td>
</tr>
<tr>
<td>:q!</td>
<td>强制退出（放弃对文档的修改内容）</td>
</tr>
<tr>
<td>:wq!</td>
<td>强制保存退出</td>
</tr>
<tr>
<td>:e!</td>
<td>放弃更改</td>
</tr>
<tr>
<td>:set nu</td>
<td>显示行号</td>
</tr>
<tr>
<td>:set nonu</td>
<td>不显示行号</td>
</tr>
<tr>
<td>:命令</td>
<td>执行该命令</td>
</tr>
<tr>
<td>:整数</td>
<td>跳转到该行</td>
</tr>
<tr>
<td>😒/one/two</td>
<td>将当前光标所在行的第一个one替换成two</td>
</tr>
<tr>
<td>😒/one/two/g</td>
<td>将当前光标所在行的所有one替换成two</td>
</tr>
<tr>
<td>:%s/one/two/g</td>
<td>将全文中的所有one替换成two</td>
</tr>
<tr>
<td>?字符串</td>
<td>在文本中从下至上搜索该字符串,按Enter后用n向下搜索</td>
</tr>
<tr>
<td>/字符串</td>
<td><strong>在文本中从上至下搜索该字符串，按Enter后用n向下搜索</strong></td>
</tr>
</tbody>
</table>
<h2 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h2>
<p>通常，现在的操作系统都支持多任务，意味着操作系统（给用户）造成了一种假象，(让用户觉得) 它同时能够做多件事情，事实上，它是快速地轮换执行这些任务的。Linux 内核通过使用进程，来 管理多任务。通过进程，Linux 安排不同的程序等待使用 CPU。</p>
<p>有时候，计算机变得呆滞，运行缓慢，或者一个应用程序停止响应。在这一章中，我们将看一些 可用的命令行工具，这些工具帮助我们查看程序的执行状态，以及怎样终止行为不当的进程。</p>
<p><strong>进程是怎样工作的</strong></p>
<ul>
<li>当系统启动的时候，内核先把一些它自己的程序初始化为进程，然后运行一个叫做 init 的程序。init， 依次地，再运行一系列的称为 init 脚本的 shell 脚本（位于/etc），它们可以启动所有的系统服务。 其中许多系统服务以守护（daemon）程序的形式实现，守护程序仅在后台运行，没有任何用户接口。 这样，即使我们没有登录系统，至少系统也在忙于执行一些例行事务。</li>
<li>一个程序可以发动另一个程序，这个事实在进程方案中，表述为一个父进程创建了一个子进程。</li>
<li>内核维护每个进程的信息，以此来保持事情有序。例如，系统分配给每个进程一个数字，这个数字叫做 进程 ID 或 PID。PID 号按升序分配，init 进程的 PID 总是1。内核也对分配给每个进程的内存进行跟踪。 像文件一样，进程也有所有者和用户 ID，有效用户 ID，等等。</li>
</ul>
<h3 id="ps-查看进程"><a class="markdownIt-Anchor" href="#ps-查看进程"></a> ps 查看进程</h3>
<p>ps命令用于<strong>查看系统中的进程状态</strong>，格式为</p>
<pre><code class="highlight plaintext">ps [参数]</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>显示所有进程（包括其他用户的进程）</td>
</tr>
<tr>
<td>-u</td>
<td>用户以及其他详细信息</td>
</tr>
<tr>
<td>-x</td>
<td>显示没有控制终端的进程</td>
</tr>
</tbody>
</table>
<p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中，有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p>
<blockquote>
<p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p>
<p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该 状态。</p>
<p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p>
<p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p>
<p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p>
</blockquote>
<p>当执行ps aux命令后通常会看到如表所示的进程状态，表中只是列举了部分输出值，而且正常的输出值中不包括中文注释。</p>
<table>
<thead>
<tr>
<th>USER</th>
<th>PID</th>
<th>%CPU</th>
<th>%MEM</th>
<th>VSZ</th>
<th>RSS</th>
<th>TTY</th>
<th>STAT</th>
<th>START</th>
<th>TIME</th>
<th>COMMAND</th>
</tr>
</thead>
<tbody>
<tr>
<td>进程的所有者</td>
<td>进程ID号</td>
<td>运算器占用率</td>
<td>内存占用率</td>
<td>虚拟内存使用量(单位是KB)</td>
<td>占用的固定内存量(单位是KB)</td>
<td>所在终端</td>
<td>进程状态</td>
<td>被启动的时间</td>
<td>实际使用CPU的时间</td>
<td>命令名称与参数</td>
</tr>
<tr>
<td>root</td>
<td>1</td>
<td>0.0</td>
<td>0.4</td>
<td>53684</td>
<td>7628</td>
<td>?</td>
<td>Ss</td>
<td>07:22</td>
<td>0:02</td>
<td>/usr/lib/systemd/systemd</td>
</tr>
<tr>
<td>root</td>
<td>2</td>
<td>0.0</td>
<td>0.0</td>
<td>0</td>
<td>0</td>
<td>?</td>
<td>S</td>
<td>07:22</td>
<td>0:00</td>
<td>[kthreadd]</td>
</tr>
<tr>
<td>root</td>
<td>3</td>
<td>0.0</td>
<td>0.0</td>
<td>0</td>
<td>0</td>
<td>?</td>
<td>S</td>
<td>07:22</td>
<td>0:00</td>
<td>[ksoftirqd/0]</td>
</tr>
<tr>
<td>root</td>
<td>5</td>
<td>0.0</td>
<td>0.0</td>
<td>0</td>
<td>0</td>
<td>?</td>
<td>S&lt;</td>
<td>07:22</td>
<td>0:00</td>
<td>[kworker/0:0H]</td>
</tr>
<tr>
<td>root</td>
<td>7</td>
<td>0.0</td>
<td>0.0</td>
<td>0</td>
<td>0</td>
<td>?</td>
<td>S</td>
<td>07:22</td>
<td>0:00</td>
<td>[migration/0]</td>
</tr>
</tbody>
</table>
<blockquote>
<p>如前面所提到的，在Linux系统中的命令参数有长短格式之分，<strong>长格式和长格式之间不能合并</strong>，<strong>长格式和短格式之间也不能合并</strong>，但<strong>短格式和短格式之间是可以合并</strong>的，<strong>合并后仅保留一个-（减号）即可</strong>。另外ps命令可<strong>允许参数不加减号（-）</strong>，因此可直接写成ps aux的样子</p>
</blockquote>
<table>
<thead>
<tr>
<th>状态</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>R</td>
<td>运行。这意味着，进程正在运行或准备运行。</td>
</tr>
<tr>
<td>S</td>
<td>正在睡眠。 进程没有运行，而是，正在等待一个事件， 比如说，一个按键或者网络数据包。</td>
</tr>
<tr>
<td>D</td>
<td>不可中断睡眠。进程正在等待 I/O，比方说，一个磁盘驱动器的 I/O。</td>
</tr>
<tr>
<td>T</td>
<td>已停止. 已经指示进程停止运行。稍后介绍更多。</td>
</tr>
<tr>
<td>Z</td>
<td>一个死进程或“僵尸”进程。这是一个已经终止的子进程，但是它的父进程还没有清空它。 （父进程没有把子进程从进程表中删除）</td>
</tr>
<tr>
<td>&lt;</td>
<td>一个高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。 进程的这种属性叫做 niceness。具有高优先级的进程据说是不好的（less nice）， 因为它占用了比较多的 CPU 时间，这样就给其它进程留下很少时间。</td>
</tr>
<tr>
<td>N</td>
<td>低优先级进程。 一个低优先级进程（一个“好”进程）只有当其它高优先级进程执行之后，才会得到处理器时间。</td>
</tr>
</tbody>
</table>
<h3 id="top-显示任务"><a class="markdownIt-Anchor" href="#top-显示任务"></a> top 显示任务</h3>
<p>top命令用于<strong>动态地监视进程活动与系统负载等信息</strong>，其格式为</p>
<pre><code class="highlight plaintext">top</code></pre>
<ul>
<li>M：可以给进程占用内存大小排序</li>
<li>h：显示程序的帮助屏幕</li>
<li>q：退出top程序</li>
<li>x：高亮排序列</li>
<li>shift+&lt;或者&gt;：切换排序列</li>
<li>i：排除僵死和睡眠的进程</li>
</ul>
<p>top命令相当强大，能够动态地查看系统运维状态，完全将它看作Linux中的“强化版的Windows任务管理器”。top命令的运行界面如图所示</p>
<p><img src="image/-25.png" alt="-25.png" /></p>
<p>top命令执行结果的前5行为系统整体的统计信息，其所代表的含义如下</p>
<blockquote>
<p>第1行：系统时间、运行时间、登录终端数、系统负载（三个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低）。</p>
</blockquote>
<blockquote>
<p>第2行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。</p>
</blockquote>
<blockquote>
<p>第3行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。其中数据均为CPU数据并以百分比格式显示，例如“97.1 id”意味着有97.1%的CPU处理器资源处于空闲。</p>
</blockquote>
<blockquote>
<p>第4行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。</p>
</blockquote>
<blockquote>
<p>第5行：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、已被提前加载的内存量。</p>
</blockquote>
<table>
<thead>
<tr>
<th>行号</th>
<th>字段</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>top</td>
<td>程序名。</td>
</tr>
<tr>
<td></td>
<td>14:59:20</td>
<td>当前时间。</td>
</tr>
<tr>
<td></td>
<td>up 6:30</td>
<td>这是正常运行时间。它是计算机从上次启动到现在所运行的时间。 在这个例子里，系统已经运行了六个半小时。</td>
</tr>
<tr>
<td></td>
<td>2users</td>
<td>有两个用户登录系统。</td>
</tr>
<tr>
<td></td>
<td>load average:</td>
<td>加载平均值是指，等待运行的进程数目，也就是说，处于运行状态的进程个数， 这些进程共享 CPU。展示了三个数值，每个数值对应不同的时间周期。第一个是最后60秒的平均值， 下一个是前5分钟的平均值，最后一个是前15分钟的平均值。若平均值低于1.0，则指示计算机 工作不忙碌。</td>
</tr>
<tr>
<td>2</td>
<td>Tasks:</td>
<td>总结了进程数目和各种进程状态。</td>
</tr>
<tr>
<td>3</td>
<td>Cpu(s):</td>
<td>这一行描述了 CPU 正在执行的进程的特性。</td>
</tr>
<tr>
<td></td>
<td>0.7%us</td>
<td>0.7% of the CPU is being used for user processes. 这意味着进程在内核之外。</td>
</tr>
<tr>
<td></td>
<td>1.0%sy</td>
<td>1.0%的 CPU 时间被用于系统（内核）进程。</td>
</tr>
<tr>
<td></td>
<td>0.0%ni</td>
<td>0.0%的 CPU 时间被用于&quot;nice&quot;（低优先级）进程。</td>
</tr>
<tr>
<td></td>
<td>98.3%id</td>
<td>98.3%的 CPU 时间是空闲的。</td>
</tr>
<tr>
<td></td>
<td>0.0%wa</td>
<td>0.0%的 CPU 时间来等待 I/O。</td>
</tr>
<tr>
<td>4</td>
<td>Mem:</td>
<td>展示物理内存的使用情况。</td>
</tr>
<tr>
<td>5</td>
<td>Swap:</td>
<td>展示交换分区（虚拟内存）的使用情况。</td>
</tr>
</tbody>
</table>
<h3 id="进程相关命令"><a class="markdownIt-Anchor" href="#进程相关命令"></a> 进程相关命令</h3>
<h4 id="停止暂停"><a class="markdownIt-Anchor" href="#停止暂停"></a> 停止/暂停</h4>
<p>linux中我们正在运行的程序可以通过下列命令停止或暂停</p>
<ul>
<li>ctrl+c：中断/停止一个程序</li>
<li>ctrl+z：停止一个进程，而没有终止它。这样会把一个前台进程移到后台等待</li>
</ul>
<h4 id="放置到后台执行"><a class="markdownIt-Anchor" href="#放置到后台执行"></a> 放置到后台执行</h4>
<p>比方说，我们想让 shell 提示符返回，却没有终止 xlogo 程序。为达到这个目的，我们把 这个程序放到后台执行。把终端看作是一个有前台（表层放置可见的事物，像 shell 提示符） 和后台（表层之下放置隐藏的事物）（的设备）。</p>
<ul>
<li>启动一个程序，<strong>加上”&amp;”字符</strong>，让它<strong>立即在后台</strong> 运行：</li>
</ul>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ xlogo &amp;
[1] 28236
[me@linuxbox ~]$</code></pre>
<ul>
<li>启动一个程序，也可以使用<strong>ctrl+z</strong>让其在后台运行：</li>
</ul>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ xlogo
[1]+ Stopped                 xlogo
[me@linuxbox ~]$</code></pre>
<p>执行命令之后，这个 xlogo 窗口出现，并且 shell 提示符返回，同时打印一些有趣的数字。 这条信息是 shell 特性的一部分，叫做工作控制。通过这条信息，shell 告诉我们，已经启动了 工作号为1（“［1］”），PID 为28236的程序。如果我们运行 ps 命令，可以看到我们的进程：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ ps
  PID TTY         TIME   CMD
10603 pts/1   00:00:00   bash
28236 pts/1   00:00:00   xlogo
28239 pts/1   00:00:00   ps</code></pre>
<h4 id="jobs-显示活跃任务"><a class="markdownIt-Anchor" href="#jobs-显示活跃任务"></a> jobs 显示活跃任务</h4>
<p>工作控制，这个 shell 功能可以列出从终端中启动的任务。执行 jobs 命令，我们可以看到这个输出列表：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ jobs
[1]+ Running            xlogo &amp;</code></pre>
<blockquote>
<p>结果显示我们有一个任务，编号为“1”，它正在运行，并且这个任务的命令是 xlogo ＆</p>
</blockquote>
<h4 id="fgbg"><a class="markdownIt-Anchor" href="#fgbg"></a> fg/bg</h4>
<p><strong>fg 把一个任务放到前台执行</strong></p>
<p>一个在后台运行的进程对一切来自键盘的输入都免疫，也不能用 Ctrl-c 来中断它。使用 fg 命令，让一个进程返回前台执行：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ jobs
[1]+ Running        xlogo &amp;
[me@linuxbox ~]$ fg %1
xlogo</code></pre>
<p><strong>bg 把一个任务放到后台执行</strong></p>
<p>停止 xlogo 程序之后，通过调整 xlogo 的窗口大小，我们可以证实这个程序已经停止了。 它看起来像死掉了一样。使用 fg 命令，可以恢复程序到前台运行，或者用 bg 命令把程序移到后台。</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ bg %1
[1]+ xlogo &amp;
[me@linuxbox ~]$</code></pre>
<h4 id="pidof"><a class="markdownIt-Anchor" href="#pidof"></a> pidof</h4>
<p>pidof命令用于查询某个指定服务进程的PID值，格式为</p>
<pre><code class="highlight plaintext">pidof [参数] [服务名称]</code></pre>
<p>每个进程的进程号码值（PID）是唯一的，因此可以通过PID来区分不同的进程。例如，可以使用如下命令来查询本机上sshd服务程序的PID：</p>
<pre><code class="highlight plaintext">
[root@linuxprobe ~]# pidof sshd
2156</code></pre>
<h4 id="kill-killall"><a class="markdownIt-Anchor" href="#kill-killall"></a> kill /killall</h4>
<p><strong>kill命令</strong>用于终止某个指定PID的服务进程，格式为</p>
<pre><code class="highlight plaintext">kill [参数] [进程PID]</code></pre>
<p>参数：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>名字</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>HUP</td>
<td>挂起。这是美好往昔的痕迹，那时候终端机通过电话线和调制解调器连接到 远端的计算机。这个信号被用来告诉程序，控制的终端机已经“挂起”。 通过关闭一个终端会话，可以说明这个信号的作用。发送这个信号到终端机上的前台程序，程序会终止。许多守护进程也使用这个信号，来重新初始化。这意味着，当发送这个信号到一个守护进程后， 这个进程会重新启动，并且重新读取它的配置文件。Apache 网络服务器守护进程就是一个例子。</td>
</tr>
<tr>
<td>2</td>
<td>INT</td>
<td>中断。实现和 Ctrl-c 一样的功能，由终端发送。通常，它会终止一个程序。</td>
</tr>
<tr>
<td>3</td>
<td>QUIT</td>
<td>退出</td>
</tr>
<tr>
<td>9</td>
<td>KILL</td>
<td>杀死。这个信号很特别。鉴于进程可能会选择不同的方式，来处理发送给它的 信号，其中也包含忽略信号，这样呢，从不发送 Kill 信号到目标进程。而是内核立即终止 这个进程。当一个进程以这种方式终止的时候，它没有机会去做些“清理”工作，或者是保存劳动成果。 因为这个原因，把 KILL 信号看作杀手锏，当其它终止信号失败后，再使用它。</td>
</tr>
<tr>
<td>11</td>
<td>SEGV</td>
<td>段错误。如果一个程序非法使用内存，就会发送这个信号。也就是说， 程序试图写入内存，而这个内存空间是不允许此程序写入的。</td>
</tr>
<tr>
<td>15</td>
<td>TERM</td>
<td>终止。这是 kill 命令发送的默认信号。如果程序仍然“活着”，可以接受信号，那么 这个信号终止。</td>
</tr>
<tr>
<td>18</td>
<td>CONT</td>
<td>继续。在停止一段时间后，进程恢复运行。</td>
</tr>
<tr>
<td>19</td>
<td>STOP</td>
<td>停止。这个信号导致进程停止运行，而没有终止。像 KILL 信号，它不被 发送到目标进程，因此它不能被忽略。</td>
</tr>
<tr>
<td>20</td>
<td>TSTP</td>
<td>终端停止。当按下 Ctrl-z 组合键后，终端发送这个信号。不像 STOP 信号， TSTP 信号由目标进程接收，且可能被忽略。</td>
</tr>
<tr>
<td>28</td>
<td>WINCH</td>
<td>改变窗口大小。当改变窗口大小时，系统会发送这个信号。 一些程序，像 top 和 less 程序会响应这个信号，按照新窗口的尺寸，刷新显示的内容。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>也可以用 jobspec（例如，“％1”）来代替 PID</p>
</blockquote>
<p>接下来，我们使用kill命令把上面用pidof命令查询到的PID所代表的进程终止掉，其命令如下所示。这种操作的效果等同于强制停止sshd服务</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# kill 2156</code></pre>
<hr />
<p><strong>killall命令</strong>用于终止某个指定名称的服务所对应的全部进程，或者通过 killall 命令，给匹配特定程序或用户名的多个进程发送信号，格式为：</p>
<pre><code class="highlight plaintext">killall [参数] [服务名称]</code></pre>
<p>通常来讲，复杂软件的服务程序会有多个进程协同为用户提供服务，如果逐个去结束这些进程会比较麻烦，此时可以使用killall命令来批量结束某个服务程序带有的全部进程。下面以httpd服务程序为例，来结束其全部进程</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# pidof httpd
13581 13580 13579 13578 13577 13576
[root@linuxprobe ~]# killall httpd
[root@linuxprobe ~]# pidof httpd
[root@linuxprobe ~]#</code></pre>
<blockquote>
<p>如果我们在系统终端中执行一个命令后想立即停止它，可以同时<strong>按下Ctrl + C组合键</strong>（生产环境中比较常用的一个快捷键），这样将<strong>立即终止该命令的进程</strong>。或者，如果有些命令在执行时不断地在屏幕上输出信息，影响到后续命令的输入，则可以在执行命令时在末尾<strong>添加上一个&amp;符号</strong>，这样<strong>命令将进入系统后台</strong>来执行</p>
</blockquote>
<p>为了说明情况，我们将启动一对 xlogo 程序的实例，然后再终止它们：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ xlogo &amp;
[1] 18801
[me@linuxbox ~]$ xlogo &amp;
[2] 18802
[me@linuxbox ~]$ killall xlogo
[1]- Terminated                xlogo
[2]+ Terminated                xlogo</code></pre>
<h2 id="shell环境变量"><a class="markdownIt-Anchor" href="#shell环境变量"></a> shell环境变量</h2>
<p>正如我们之前所讨论到的，shell 在 shell 会话中维护着大量的信息，这些信息称为 (shell) 环境。 存储在 shell 环境中的数据被程序用来确定配置属性。然而大多数程序用配置文件来存储程序设置， 某些程序也会查找存储在 shell 环境中的数值来调整他们的行为。知道了这些，我们就可以用 shell 环境 来自定制 shell 经历。</p>
<p>shell 在环境中存储了两种基本类型的数据，虽然对于 bash 来说，很大程度上这些类型是不可 辨别的。它们是<strong>环境变量</strong>和 <strong>shell 变量</strong>。Shell 变量是由 bash 存放的少量数据，而剩下的基本上 都是环境变量。除了变量，shell 也存储了一些可编程的数据，命名为别名和 shell 函数。</p>
<h3 id="查看环境变量"><a class="markdownIt-Anchor" href="#查看环境变量"></a> 查看环境变量</h3>
<p>我们既可以<strong>用 bash 的内部命令 set</strong>，或者是 <strong>printenv 程序</strong>来查看什么存储在环境当中。set 命令可以 显示 shell 和环境变量两者，而 printenv 只是显示环境变量。</p>
<p>因为环境变量内容列表相当长，所以最好 把每个命令的输出结果管道到 less 命令：</p>
<pre><code class="highlight plaintext">$ printenv | less</code></pre>
<p>执行以上命令之后，我们应该能得到类似以下内容：</p>
<pre><code class="highlight plaintext">KDE_MULTIHEAD=false
SSH_AGENT_PID=6666
HOSTNAME=linuxbox
GPG_AGENT_INFO=/tmp/gpg-PdOt7g/S.gpg-agent:6689:1
SHELL=/bin/bash
TERM=xterm
XDG_MENU_PREFIX=kde-
HISTSIZE=1000
XDG_SESSION_COOKIE=6d7b05c65846c3eaf3101b0046bd2b00-1208521990.996705-1177056199
GTK2_RC_FILES=/etc/gtk-2.0/gtkrc:/home/me/.gtkrc-2.0:/home/me/.kde/sh
are/config/gtkrc-2.0
GTK_RC_FILES=/etc/gtk/gtkrc:/home/me/.gtkrc:/home/me/.kde/share/confi
g/gtkrc
GS_LIB=/home/me/.fonts
WINDOWID=29360136
QTDIR=/usr/lib/qt-3.3
QTINC=/usr/lib/qt-3.3/include
KDE_FULL_SESSION=true
USER=me
LS_COLORS=no=00:fi=00:di=00;34:ln=00;36:pi=40;33:so=00;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=00;32:\*.cmd=00;32:\*.exe:</code></pre>
<p>我们所看到的是环境变量及其数值的列表。例如，我们看到一个叫做 USER 的变量，这个变量值是 “me”。printenv 命令也能够列出特定变量的数值：</p>
<pre><code class="highlight plaintext">$ printenv USER
me</code></pre>
<p>当使用没有带选项和参数的 set 命令时，shell 和环境变量二者都会显示，同时也会显示定义的 shell 函数。不同于 printenv 命令，set 命令的输出结果很礼貌地按照字母顺序排列：</p>
<pre><code class="highlight plaintext">$ set | less</code></pre>
<p>也可以通过 echo 命令来查看一个变量的内容，像这样：</p>
<pre><code class="highlight plaintext">$ echo $HOME
/home/me</code></pre>
<p>如果 shell 环境中的一个成员既不可用 set 命令也不可用 printenv 命令显示，则这个变量是别名。 输入不带参数的 alias 命令来查看它们:</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ alias
alias l.=&#x27;ls -d .* --color=tty&#x27;
alias ll=&#x27;ls -l --color=tty&#x27;
alias ls=&#x27;ls --color=tty&#x27;
alias vi=&#x27;vim&#x27;
alias which=&#x27;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&#x27;</code></pre>
<hr />
<p><strong>一些常见的环境变量</strong></p>
<table>
<thead>
<tr>
<th>变量</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>DISPLAY</td>
<td>如果你正在运行图形界面环境，那么这个变量就是你显示器的名字。通常，它是 “:0”， 意思是由 X 产生的第一个显示器。</td>
</tr>
<tr>
<td>EDITOR</td>
<td>文本编辑器的名字。</td>
</tr>
<tr>
<td>SHELL</td>
<td>shell 程序的名字。</td>
</tr>
<tr>
<td>HOME</td>
<td>用户家目录。</td>
</tr>
<tr>
<td>LANG</td>
<td>定义了字符集以及语言编码方式。</td>
</tr>
<tr>
<td>OLD_PWD</td>
<td>先前的工作目录。</td>
</tr>
<tr>
<td>PAGER</td>
<td>页输出程序的名字。这经常设置为/usr/bin/less。</td>
</tr>
<tr>
<td>PATH</td>
<td>由冒号分开的目录列表，当你输入可执行程序名后，会搜索这个目录列表。</td>
</tr>
<tr>
<td>PS1</td>
<td>Prompt String 1. 这个定义了你的 shell 提示符的内容。随后我们可以看到，这个变量 内容可以全面地定制。</td>
</tr>
<tr>
<td>PWD</td>
<td>当前工作目录。</td>
</tr>
<tr>
<td>TERM</td>
<td>终端类型名。类 Unix 的系统支持许多终端协议；这个变量设置你的终端仿真器所用的协议。</td>
</tr>
<tr>
<td>TZ</td>
<td>指定你所在的时区。大多数类 Unix 的系统按照协调时间时 (UTC) 来维护计算机内部的时钟 ，然后应用一个由这个变量指定的偏差来显示本地时间。</td>
</tr>
<tr>
<td>USER</td>
<td>你的用户名</td>
</tr>
</tbody>
</table>
<h3 id="建立环境变量"><a class="markdownIt-Anchor" href="#建立环境变量"></a> 建立环境变量</h3>
<p>当我们登录系统后，启动 bash 程序，并且会读取一系列称为启动文件的配置脚本， 这些文件定义了默认的可供所有用户共享的 shell 环境。然后是读取更多位于我们自己家目录中 的启动文件，这些启动文件定义了用户个人的 shell 环境。精确的启动顺序依赖于要运行的 shell 会话 类型。有两种 shell 会话类型：一个是登录 shell 会话，另一个是非登录 shell 会话。登录 shell 会话会提示用户输入用户名和密码；例如，我们启动一个虚拟控制台会话。当我们在 GUI 模式下 运行终端会话时，非登录 shell 会话会出现。</p>
<p>登录 shell 会读取一个或多个启动文件，正如表所示：</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>/etc/profile</td>
<td>应用于所有用户的全局配置脚本。</td>
</tr>
<tr>
<td>~/.bash_profile</td>
<td>用户私人的启动文件。可以用来扩展或重写全局配置脚本中的设置。</td>
</tr>
<tr>
<td>~/.bash_login</td>
<td>如果文件 ~/.bash_profile 没有找到，bash 会尝试读取这个脚本。</td>
</tr>
<tr>
<td>~/.profile</td>
<td>如果文件 ~/.bash_profile 或文件 ~/.bash_login 都没有找到，bash 会试图读取这个文件。 这是基于 Debian 发行版的默认设置，比方说 Ubuntu。</td>
</tr>
</tbody>
</table>
<p>非登录 shell 会话会读取以下启动文件：</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>/etc/bash.bashrc</td>
<td>应用于所有用户的全局配置文件。</td>
</tr>
<tr>
<td>~/.bashrc</td>
<td>用户私有的启动文件。可以用来扩展或重写全局配置脚本中的设置。</td>
</tr>
</tbody>
</table>
<p>除了读取以上启动文件之外，非登录 shell 会话也会继承它们父进程的环境设置，通常是一个登录 shell。</p>
<p>在普通用户看来，文件 ~/.bashrc 可能是最重要的启动文件，因为它几乎总是被读取。非登录 shell 默认 会读取它，并且大多数登录 shell 的启动文件会以能读取 ~/.bashrc 文件的方式来书写。</p>
<hr />
<p><strong>启动文件的内容</strong></p>
<p>如果我们看一下典型的 .bash_profile 文件（来自于 CentOS 4 系统），它看起来像这样：</p>
<pre><code class="highlight plaintext"># .bash_profile
# Get the aliases and functions
#下列if的意思是如果.bashrc文件存在，则读取该文件
if [ -f ~/.bashrc ]; then
. ~/.bashrc
fi
# User specific environment and startup programs
PATH=$PATH:$HOME/bin
export PATH</code></pre>
<pre><code class="highlight plaintext">If the file ~/.bashrc exists, then
read the ~/.bashrc file.</code></pre>
<p>我们可以看到这一小段代码就是一个登录 shell 得到 .bashrc 文件内容的方式。在我们启动文件中， 下一件有趣的事与 PATH 变量有关系。</p>
<p>曾经是否感到迷惑 shell 是怎样知道到哪里找到我们在命令行中输入的命令的？</p>
<p>例如，当我们输入 ls 后， shell 不会查找整个计算机系统，来找到 /bin/ls（ls 命令的绝对路径名），而是，它查找一个目录列表， <strong>这些目录包含在 PATH 变量中</strong>。</p>
<p>PATH 变量经常（但不总是，依赖于发行版）<strong>在 /etc/profile 启动文件中设置</strong>，通过这些代码：</p>
<pre><code class="highlight plaintext">PATH=$PATH:$HOME/bin</code></pre>
<p>修改 PATH 变量，添加目录 $HOME/bin 到目录列表的末尾。这是一个参数展开的实例， 参数展开我们在第八章中提到过。为了说明这是怎样工作的，试试下面的例子：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ foo=&quot;This is some&quot;
[me@linuxbox ~]$ echo $foo
This is some
[me@linuxbox ~]$ foo=&quot;$foo text.&quot;
[me@linuxbox ~]$ echo $foo
This is some text.</code></pre>
<p>使用<strong>这种技巧，我们可以把文本附加到一个变量值的末尾</strong>。通过添加字符串 $HOME/bin 到 PATH 变量值 的末尾，则目录 $HOME/bin 就添加到了命令搜索目录列表中。这意味着当我们想要在自己的家目录下， 创建一个目录来存储我们自己的私人程序时，shell 已经给我们准备好了。我们所要做的事就是 把创建的目录叫做 bin，赶快行动吧。</p>
<blockquote>
<p>注意：很多发行版默认地提供了这个 PATH 设置。一些基于 Debian 的发行版，例如 Ubuntu，在登录 的时候，会检测目录 ~/bin 是否存在，若找到目录则把它动态地加到 PATH 变量中。</p>
</blockquote>
<p>最后，有下面一行代码：</p>
<pre><code class="highlight plaintext">export PATH</code></pre>
<p>这个 export 命令告诉 shell 让这个 shell 的子进程可以使用 PATH 变量的内容，即让PATH变量从仅为该用户使用变为全局使用。</p>
<h3 id="export命令"><a class="markdownIt-Anchor" href="#export命令"></a> export命令</h3>
<p>设置或显示环境变量。</p>
<pre><code class="highlight plaintext">export [-fnp][变量名称]=[变量设置值]</code></pre>
<p>参 数：</p>
<ul>
<li>-f 代表[变量名称]中为函数名称。</li>
<li>-n 删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。</li>
<li>-p 列出所有的shell赋予程序的环境变量。</li>
</ul>
<p>一个变量创建时，它不会自动地为在它之后创建的shell进程所知。而命令export可以向后面的shell传递变量的值。当一个shell脚本调用并执行时，它不会自动得到原来脚本（调用者）里定义的变量的访问权，除非这些变量已经被显式地设置为可用。export命令可以用于传递一个或多个变量的值到任何后继脚本。</p>
<p>登录到系统后，系统将启动一个用户shell。在这个shell中，可以使用shell命令或声明变量，也可以创建并运行shell脚本程序。运行shell脚本程序时，系统将创建一个子shell。此时，系统中将有两个shell，一个是登录时系统启动的shell，另一个是系统为运行脚本程序创建的shell。当一个脚本程序运行完毕，它的脚本shell将终止，可以返回到执行该脚本之前的shell。从这种意义上来说，用户可以有许多shell，每个shell都是由某个shell（称为父shell）派生的。</p>
<p>在<strong>子shell中定义的变量只在该子shell内有效</strong>。如果在一个shell脚本程序中定义了一个变量，当该脚本程序运行时，这个定义的变量只是该脚本程序内的一个局部变量，其他的shell不能引用它，要使<strong>某个变量的值可以在其他shell中被改变，可以使用export命令对已定义的变量进行输出</strong>。</p>
<p>export命令将使系统在创建每一个新的shell时定义这个变量的一个拷贝。这个过程称之为变量输出。</p>
<p>#echo $PKG_PATH 在任何时候建立的变量都只是当前shell的局部变量，所以不能被shell运行的其他命令或shell程序所利用。 export ,是把你设置的环境变量传给当前SHELL的子SHELL，使其在子SHELL中有效。</p>
<h3 id="修改shell环境"><a class="markdownIt-Anchor" href="#修改shell环境"></a> 修改shell环境</h3>
<p>按照通常的规则，添加目录到你的 PATH 变量或者是定义额外的环境变量，要把这些更改放置到 .bash_profile 文件中（或者其替代文件中，根据不同的发行版。例如，Ubuntu 使用 .profile 文件）。 对于其它的更改，要放到 .bashrc 文件中。除非你是系统管理员，需要为系统中的所有用户修改 默认设置，那么则限定你只能对自己家目录下的文件进行修改。当然，有可能会更改 /etc 目录中的 文件，比如说 profile 文件，而且在许多情况下，修改这些文件也是明智的，但是现在，我们要 安全起见。</p>
<p>修改之前我们先备份一份：</p>
<pre><code class="highlight plaintext">#该文件在用户的家目录
[me@linuxbox ~]$ cp .bashrc .bashrc.bak</code></pre>
<p>然后我们编辑该文件：</p>
<pre><code class="highlight plaintext">vim .bashrc</code></pre>
<p>在最后面添加：</p>
<pre><code class="highlight plaintext">umask 0002
export HISTCONTROL=ignoredups
export HISTSIZE=1000
alias l.=&#x27;ls -d .* --color=auto&#x27;
alias ll=&#x27;ls -l --color=auto&#x27;</code></pre>
<blockquote>
<p>注意：你的发行版可能已经包含其中的一些行，但是复制没有任何伤害。</p>
</blockquote>
<table>
<thead>
<tr>
<th>按键</th>
<th>行动</th>
</tr>
</thead>
<tbody>
<tr>
<td>文本行</td>
<td>含义</td>
</tr>
<tr>
<td>umask 0002</td>
<td>设置掩码来解决共享目录的问题。</td>
</tr>
<tr>
<td>export HISTCONTROL=ignoredups</td>
<td>使得 shell 的历史记录功能忽略一个命令，如果相同的命令已被记录。</td>
</tr>
<tr>
<td>export HISTSIZE=1000</td>
<td>增加命令历史的大小，从默认的 500 行扩大到 1000 行。</td>
</tr>
<tr>
<td>alias l.=‘ls -d .* --color=auto’</td>
<td>创建一个新命令，叫做’l.'，这个命令会显示所有以点开头的目录项。</td>
</tr>
<tr>
<td>alias ll=‘ls -l --color=auto’</td>
<td>创建一个叫做’ll’的命令，这个命令会显示长格式目录列表。</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>激活我们的修改</strong></p>
<p>我们对于文件 .bashrc 的修改不会生效，直到我们关闭终端会话，再重新启动一个新的会话， 因为 .bashrc 文件只是在刚开始启动终端会话时读取。然而，我们可以强迫 bash 重新读取修改过的 .bashrc 文件，使用下面的命令：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ source .bashrc</code></pre>
<h2 id="软件包管理"><a class="markdownIt-Anchor" href="#软件包管理"></a> 软件包管理</h2>
<p><strong>打包系统</strong></p>
<p>不同的 Linux 发行版使用不同的打包系统，一般而言，大多数发行版分别属于两大包管理技术阵营： Debian 的”.deb”，和红帽的”.rpm”。也有一些重要的例外，比方说 Gentoo， Slackware，和 Foresight，但大多数会使用这两个基本系统中的一个。</p>
<table>
<thead>
<tr>
<th>包管理系统</th>
<th>发行版 (部分列表)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Debian Style (.deb)</td>
<td>Debian, Ubuntu, Xandros, Linspire</td>
</tr>
<tr>
<td>Red Hat Style (.rpm)</td>
<td>Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS</td>
</tr>
</tbody>
</table>
<p><strong>软件包管理系统是怎样工作</strong></p>
<p>在专有软件产业中找到的软件发布方法通常需要买一张安装媒介，比方说”安装盘”，然后运行 “安装向导”，来在系统中安装新的应用程序。</p>
<p>Linux 不是这样。Linux 系统中几乎所有的软件都可以在互联网上找到。其中大多数软件由发行商以 包文件的形式提供，剩下的则以源码形式存在，可以手动安装。在后面章节里，我们将会谈谈怎样 通过编译源码来安装软件。</p>
<p><strong>包文件</strong></p>
<p>在包管理系统中软件的基本单元是包文件。包文件是一个构成软件包的文件压缩集合。一个软件包 可能由大量程序以及支持这些程序的数据文件组成。除了安装文件之外，软件包文件也包括 关于这个包的元数据，如软件包及其内容的文本说明。另外，许多软件包还包括预安装和安装后脚本， 这些脚本用来在软件安装之前和之后执行配置任务。</p>
<p>软件包文件是由软件包维护者创建的，他通常是（但不总是）一名软件发行商的雇员。软件维护者 从上游提供商（程序作者）那里得到软件源码，然后编辑源码，创建软件包元数据以及所需要的 安装脚本。通常，软件包维护者要把所做的修改应用到最初的源码当中，来提高此软件与 Linux 发行版其它部分的融合性。</p>
<p><strong>资源库</strong></p>
<p>虽然某些软件项目选择执行他们自己的打包和发布策略，但是现在大多数软件包是由发行商和感兴趣 的第三方创建的。系统发行版的用户可以在一个中心资源库中得到这些软件包，这个资源库可能 包含了成千上万个软件包，每一个软件包都是专门为这个系统发行版建立和维护的。</p>
<p>因软件开发生命周期不同阶段的需要，一个系统发行版可能维护着几个不同的资源库。例如，通常会 有一个”测试”资源库，其中包含刚刚建立的软件包，它们想要勇敢的用户来使用， 在这些软件包正式发布之前，让用户查找错误。系统发行版经常会有一个”开发”资源库， 这个资源库中保存着注定要包含到下一个主要版本中的半成品软件包。</p>
<p>一个系统发行版可能也会拥有相关第三方的资源库。这些资源库需要支持一些因法律原因， 比如说专利或者是 DRM 反规避问题，而不能被包含到发行版中的软件。可能最著名的案例就是 那个加密的 DVD 支持，在美国这是不合法的。第三方资源库在这些软件专利和反规避法案不 生效的国家中起作用。这些资源库通常完全地独立于它们所支持的资源库，要想使用它们， 你必须了解它们，手动地把它们包含到软件包管理系统的配置文件中。</p>
<p><strong>依赖性</strong></p>
<p>程序很少是”孤立的”，而是依赖于其它软件组件来完成它们的工作。常见活动，以 输入/输出为例，就是由共享程序例程来处理的。这些程序例程存储在共享库中，共享库不只 为一个程序提供基本服务。如果一个软件包需要共享资源，比如说共享库，据说就有一个依赖。 现代的软件包管理系统都提供了一些依赖项解析方法，以此来确保当安装软件包时，也安装了 其所有的依赖程序。</p>
<p><strong>上层和底层软件包工具</strong></p>
<p>软件包管理系统通常由两种工具类型组成：底层工具用来处理这些任务，比方说安装和删除软件包文件， 和上层工具，完成元数据搜索和依赖解析。在这一章中，我们将看一下由 Debian 风格的系统 （比如说 Ubuntu，还有许多其它系统）提供的工具，还有那些由 Red Hat 产品使用的工具。虽然所有基于 Red Hat 风格的发行版都依赖于相同的底层程序（rpm）, 但是它们却使用不同的上层工具。我们将研究上层程序 yum 供我们讨论，Fedora, Red Hat 企业版，和 CentOs 都是使用 yum。其它基于 Red Hat 风格的发行版提供了带有可比较特性的上层工具。</p>
<table>
<thead>
<tr>
<th>发行版</th>
<th>底层工具</th>
<th>上层工具</th>
</tr>
</thead>
<tbody>
<tr>
<td>Debian-Style</td>
<td>dpkg</td>
<td>apt-get, aptitude</td>
</tr>
<tr>
<td>Fedora, Red Hat Enterprise Linux, CentOS</td>
<td>rpm</td>
<td>yum</td>
</tr>
</tbody>
</table>
<h3 id="yum命令"><a class="markdownIt-Anchor" href="#yum命令"></a> yum命令</h3>
<h4 id="yum搜索软件"><a class="markdownIt-Anchor" href="#yum搜索软件"></a> <strong>yum搜索软件�</strong>�</h4>
<p>使用上层工具来搜索资源库元数据，可以根据软件包的名字和说明来定位它。</p>
<table>
<thead>
<tr>
<th>风格</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>Debian</td>
<td>apt-get update; apt-cache search search_string</td>
</tr>
<tr>
<td>Red Hat</td>
<td>yum search search_string</td>
</tr>
</tbody>
</table>
<p>例如：搜索一个 yum 资源库来查找 emacs 文本编辑器，使用以下命令：</p>
<pre><code class="highlight plaintext">yum search emacs</code></pre>
<hr />
<h4 id="yum安装软件"><a class="markdownIt-Anchor" href="#yum安装软件"></a> <strong>yum安装软件�</strong>�</h4>
<p>上层工具允许从一个资源库中下载一个软件包，并经过完全依赖解析来安装它。</p>
<table>
<thead>
<tr>
<th>风格</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>Debian</td>
<td>apt-get update; apt-get install package_name</td>
</tr>
<tr>
<td>Red Ha</td>
<td>yum install package_name</td>
</tr>
</tbody>
</table>
<p>例如：从一个 apt 资源库来安装 emacs 文本编辑器：</p>
<pre><code class="highlight plaintext">yum install emacs</code></pre>
<hr />
<h4 id="yum卸载软件"><a class="markdownIt-Anchor" href="#yum卸载软件"></a> <strong>yum卸载软件</strong></h4>
<p>可以使用上层或者底层工具来卸载软件。下面是可用的上层工具。</p>
<table>
<thead>
<tr>
<th>风格</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>Debian</td>
<td>apt-get remove package_name</td>
</tr>
<tr>
<td>Red Hat</td>
<td>yum erase package_name</td>
</tr>
</tbody>
</table>
<p>例如：从 Red Hat 风格的系统中卸载 emacs 软件包：</p>
<pre><code class="highlight plaintext">yum erase emacs</code></pre>
<h4 id="yum更新软件包"><a class="markdownIt-Anchor" href="#yum更新软件包"></a> yum更新软件包</h4>
<p>最常见的软件包管理任务是保持系统中的软件包都是最新的。上层工具仅需一步就能完成 这个至关重要的任务。</p>
<table>
<thead>
<tr>
<th>风格</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>Debian</td>
<td>apt-get update; apt-get upgrade</td>
</tr>
<tr>
<td>Red Hat</td>
<td>yum update</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<pre><code class="highlight plaintext">yum updata java</code></pre>
<h4 id="配置阿里镜像"><a class="markdownIt-Anchor" href="#配置阿里镜像"></a> 配置阿里镜像</h4>
<ol>
<li>备份</li>
</ol>
<pre><code class="highlight plaintext">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code></pre>
<ol>
<li>下载新的CentOS-Base.repo</li>
</ol>
<pre><code class="highlight plaintext">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</code></pre>
<ol>
<li>生成缓存</li>
</ol>
<pre><code class="highlight plaintext">yum clean all
yum makecache</code></pre>
<h4 id="查找软件并删除"><a class="markdownIt-Anchor" href="#查找软件并删除"></a> 查找软件并删除</h4>
<pre><code class="highlight plaintext">rpm -qa | grep jdk

yum -y remove java-1.5.0-gcj-devel-1.5.0.0-29.1.el6.x86_64</code></pre>
<h3 id="rpm"><a class="markdownIt-Anchor" href="#rpm"></a> rpm</h3>
<hr />
<h4 id="通过软件包文件来安装软件"><a class="markdownIt-Anchor" href="#通过软件包文件来安装软件"></a> <strong>通过软件包文件来安装软件</strong></h4>
<p>如果从某处而不是从资源库中下载了一个软件包文件，可以使用底层工具来直接（没有经过依赖解析）安装它。</p>
<table>
<thead>
<tr>
<th>风格</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>Debian</td>
<td>dpkg --install package_file</td>
</tr>
<tr>
<td>Red Hat</td>
<td>rpm -i package_file</td>
</tr>
</tbody>
</table>
<p>例如：如果已经从一个并非资源库的网站下载了软件包文件 emacs-22.1-7.fc7-i386.rpm， 则可以通过这种方法来安装它：</p>
<pre><code class="highlight plaintext">rpm -i emacs-22.1-7.fc7-i386.rpm</code></pre>
<p><strong>忽略依赖解析方式</strong>：</p>
<pre><code class="highlight plaintext">rpm -ivh MySQL-server-5.5.31-2.el6.i686.rpm --nodeps --force</code></pre>
<blockquote>
<p>注意：因为这项技术使用底层的 rpm 程序来执行安装任务，所以没有运行依赖解析。 如果 rpm 程序发现缺少了一个依赖，则会报错并退出。</p>
</blockquote>
<h4 id="经过软件包来升级软件"><a class="markdownIt-Anchor" href="#经过软件包来升级软件"></a> 经过软件包来升级软件</h4>
<p>如果已经从一个非资源库网站下载了一个软件包的最新版本，可以安装这个版本，用它来 替代先前的版本：</p>
<table>
<thead>
<tr>
<th>风格</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>Debian</td>
<td>dpkg --install package_file</td>
</tr>
<tr>
<td>Red Hat</td>
<td>rpm -U package_file</td>
</tr>
</tbody>
</table>
<p>例如：把 Red Hat 系统中所安装的 emacs 的版本更新到软件包文件 emacs-22.1-7.fc7-i386.rpmz 所包含的 emacs 版本。</p>
<pre><code class="highlight plaintext">rpm -U emacs-22.1-7.fc7-i386.rpm</code></pre>
<h4 id="列出所安装的软件包"><a class="markdownIt-Anchor" href="#列出所安装的软件包"></a> 列出所安装的软件包</h4>
<p>下表中的命令可以用来显示安装到系统中的所有软件包列表：</p>
<table>
<thead>
<tr>
<th>风格</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>Debian</td>
<td>dpkg --list</td>
</tr>
<tr>
<td>Red Hat</td>
<td>rpm -qa</td>
</tr>
</tbody>
</table>
<pre><code class="highlight plaintext">rpm -qa | grep mariadb</code></pre>
<h4 id="删除软件"><a class="markdownIt-Anchor" href="#删除软件"></a> 删除软件</h4>
<pre><code class="highlight plaintext">语句：
rpm -e --nodeps 软件名

实例：
rpm -e --nodeps mariadb-libs-5.5.37-1.el7_0.x86_64

批量删除：
yum -y remove `rpm -qa | grep mariadb`

rpm -e --nodeps `rpm -qa | grep mysql`</code></pre>
<h2 id="网络系统"><a class="markdownIt-Anchor" href="#网络系统"></a> 网络系统</h2>
<p>当谈及到网络系统层面，几乎任何东西都能由 Linux 来实现。Linux 被用来创建各式各样的网络系统和装置， 包括防火墙，路由器，名称服务器，网络连接式存储设备等等。</p>
<h3 id="检查和检测网络"><a class="markdownIt-Anchor" href="#检查和检测网络"></a> 检查和检测网络</h3>
<h4 id="ping"><a class="markdownIt-Anchor" href="#ping"></a> ping</h4>
<p>最基本的网络命令是 ping。这个 ping 命令发送一个特殊的网络数据包，叫做 IMCP ECHO_REQUEST，到 一台指定的主机。大多数接收这个包的网络设备将会回复它，来允许网络连接验证。</p>
<blockquote>
<p>注意：大多数网络设备（包括 Linux 主机）都可以被配置为忽略这些数据包。通常，这样做是出于网络安全 原因，部分地遮蔽一台主机免受一个潜在攻击者地侵袭。配置防火墙来阻塞 IMCP 流量也很普遍。</p>
</blockquote>
<p>一旦启动，ping 命令会持续在特定的时间间隔内（默认是一秒）发送数据包，直到它被中断：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ ping linuxcommand.org
PING linuxcommand.org (66.35.250.210) 56(84) bytes of data.64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=1
ttl=43 time=107 ms
64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=2
ttl=43 time=108 ms
64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=3
ttl=43 time=106 ms
64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=4
ttl=43 time=106 ms
64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=5
ttl=43 time=105 ms
...</code></pre>
<p>按下组合键 Ctrl-c，中断这个命令之后，ping 打印出运行统计信息。一个正常工作的网络会报告 零个数据包丢失。一个成功执行的“ping”命令会意味着网络的各个部件（网卡，电缆，路由，网关） 都处于正常的工作状态。</p>
<h4 id="netstat"><a class="markdownIt-Anchor" href="#netstat"></a> netstat</h4>
<p>netstat 程序被用来检查各种各样的网络设置和统计数据。通过此命令的许多选项，我们 可以看看网络设置中的各种特性。使用“-ie”选项，我们能够查看系统中的网络接口：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ netstat -ie

eth0    Link encap:Ethernet HWaddr 00:1d:09:9b:99:67
        inet addr:192.168.1.2 Bcast:192.168.1.255 Mask:255.255.255.0
        inet6 addr: fe80::21d:9ff:fe9b:9967/64 Scope:Link
        UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
        RX packets:238488 errors:0 dropped:0 overruns:0 frame:0
        TX packets:403217 errors:0 dropped:0 overruns:0 carrier:0
        collisions:0 txqueuelen:100 RX bytes:153098921 (146.0 MB) TX
        bytes:261035246 (248.9 MB) Memory:fdfc0000-fdfe0000

lo      Link encap:Local Loopback
        inet addr:127.0.0.1 Mask:255.0.0.0...</code></pre>
<p>在上述实例中，我们看到我们的测试系统有两个网络接口。第一个，叫做 eth0，是 因特网接口，和第二个，叫做 lo，是内部回环网络接口，它是一个虚拟接口，系统用它来 “自言自语”。</p>
<hr />
<p><strong>查看某端口</strong></p>
<pre><code class="highlight plaintext">netstat -ntlp   //查看当前所有tcp端口·

netstat -ntulp |grep 1935   //查看所有1935端口使用情况·</code></pre>
<h3 id="网络中传输文件"><a class="markdownIt-Anchor" href="#网络中传输文件"></a> 网络中传输文件</h3>
<h4 id="ftp"><a class="markdownIt-Anchor" href="#ftp"></a> ftp</h4>
<p>ftp 命令属于真正的“经典”程序之一，它的名字来源于其所使用的协议，就是文件传输协议。 FTP 被广泛地用来从因特网上下载文件。大多数，并不是所有的，网络浏览器都支持 FTP， 你经常可以看到它们的 URI 以协议 <a href="ftp://%E5%BC%80%E5%A4%B4">ftp://开头</a>。在出现网络浏览器之前，ftp 程序已经存在了。 ftp 程序可用来与 FTP 服务器进行通信，FTP 服务器就是存储文件的计算机，这些文件能够通过 网络下载和上传。</p>
<p>FTP（它的原始形式）并不是安全的，因为它会以明码形式发送帐号的姓名和密码。这就意味着 这些数据没有加密，任何嗅探网络的人都能看到。由于此种原因，几乎因特网中所有 FTP 服务器 都是匿名的。一个匿名服务器能允许任何人使用注册名“anonymous”和无意义的密码登录系统。</p>
<p>在下面的例子中，我们将展示一个典型的会话，从匿名 FTP 服务器，其名字是 fileserver， 的/pub/images/Ubuntu-8.04的目录下，使用 ftp 程序下载一个 Ubuntu 系统映像文件。</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ ftp fileserver
Connected to fileserver.localdomain.220 (vsFTPd 2.0.1)
Name (fileserver:me): anonymous
331 Please specify the password.
Password:230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp&gt; cd pub/cd\_images/Ubuntu-8.04250 Directory successfully changed.
ftp&gt; ls
200 PORT command successful. Consider using PASV.150 Here comes the directory listing.-rw-rw-r-- 1 500 500 733079552 Apr 25 03:53 ubuntu-8.04- desktop-i386.iso
226 Directory send OK.
ftp&gt; lcd Desktop
Local directory now /home/me/Desktop
ftp&gt; get ubuntu-8.04-desktop-i386.iso
local: ubuntu-8.04-desktop-i386.iso remote: ubuntu-8.04-desktop-
i386.iso
200 PORT command successful. Consider using PASV.150 Opening BINARY mode data connection for ubuntu-8.04-desktop-
i386.iso (733079552 bytes).226 File send OK.733079552 bytes received in 68.56 secs (10441.5 kB/s)
ftp&gt; bye</code></pre>
<table>
<thead>
<tr>
<th>命令</th>
<th>意思</th>
</tr>
</thead>
<tbody>
<tr>
<td>ftp fileserver</td>
<td>唤醒 ftp 程序，让它连接到 FTP 服务器，fileserver。</td>
</tr>
<tr>
<td>anonymous</td>
<td>登录名。输入登录名后，将出现一个密码提示。一些服务器将会接受空密码， 其它一些则会要求一个邮件地址形式的密码。如果是这种情况，试着输入 “user@example.com”。</td>
</tr>
<tr>
<td>cd pub/cd_images/Ubuntu-8.04</td>
<td>跳转到远端系统中，要下载文件所在的目录下， 注意在大多数匿名的 FTP 服务器中，支持公共下载的文件都能在目录 pub 下找到</td>
</tr>
<tr>
<td>ls</td>
<td>列出远端系统中的目录。</td>
</tr>
<tr>
<td>lcd Desktop</td>
<td>跳转到本地系统中的 ~/Desktop 目录下。在实例中，ftp 程序在工作目录 ~ 下被唤醒。 这个命令把工作目录改为 ~/Desktop</td>
</tr>
<tr>
<td>get ubuntu-8.04-desktop-i386.iso</td>
<td>告诉远端系统传送文件到本地。因为本地系统的工作目录 已经更改到了 ~/Desktop，所以文件会被下载到此目录。</td>
</tr>
<tr>
<td>bye</td>
<td>退出远端服务器，结束 ftp 程序会话。也可以使用命令 quit 和 exit。</td>
</tr>
</tbody>
</table>
<h4 id="wget-下载"><a class="markdownIt-Anchor" href="#wget-下载"></a> wget 下载</h4>
<p>wget命令用于<strong>在终端中下载网络文件</strong>，格式</p>
<pre><code class="highlight plaintext">wget [参数] 下载地址</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-b</td>
<td>后台下载模式</td>
</tr>
<tr>
<td>-P</td>
<td>下载到指定目录</td>
</tr>
<tr>
<td>-t</td>
<td>最大尝试次数</td>
</tr>
<tr>
<td>-c</td>
<td>断点续传</td>
</tr>
<tr>
<td>-p</td>
<td>下载页面内所有资源，包括图片、视频等</td>
</tr>
<tr>
<td>-r</td>
<td>递归下载</td>
</tr>
</tbody>
</table>
<p><strong>案例：</strong></p>
<p>尝试使用wget命令从本书的配套站点中下载本书的最新pdf格式电子文档，这个文件的完整路径为<a target="_blank" rel="noopener" href="https://www.linuxprobe.com/docs/LinuxProbe.pdf%EF%BC%8C%E6%89%A7%E8%A1%8C%E8%AF%A5%E5%91%BD%E4%BB%A4%E5%90%8E%E7%9A%84%E4%B8%8B%E8%BD%BD%E6%95%88%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">https://www.linuxprobe.com/docs/LinuxProbe.pdf，执行该命令后的下载效果如下：</a></p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# wget https://www.linuxprobe.com/docs/LinuxProbe.pdf</code></pre>
<p>接下来，我们使用wget命令递归下载www.linuxprobe.com网站内的所有页面数据以及文件，下载完后会自动保存到当前路径下一个名为www.linuxprobe.com的目录中。执行该操作的命令为wget -r -p <a target="_blank" rel="noopener" href="https://www.linuxprobe.com">https://www.linuxprobe.com</a>，该命令的执行结果如下。</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# wget -r -p https://www.linuxprobe.com

--2017-08-24 19:31:41-- https://www.linuxprobe.com/
Resolving www.linuxprobe.com... 106.185.25.197
Connecting to www.linuxprobe.com|106.185.25.197|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: unspecified [text/html]
Saving to: &#x27;www.linuxprobe.com/index.html&#x27;</code></pre>
<h4 id="scp远程拷贝"><a class="markdownIt-Anchor" href="#scp远程拷贝"></a> scp远程拷贝</h4>
<p>Linux scp 命令用于 Linux 之间复制文件和目录。</p>
<p>语法：</p>
<pre><code class="highlight plaintext">scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file][-l limit] [-o ssh_option] [-P port] [-S program][[user@]host1:]file1 [...] [[user@]host2:]file2</code></pre>
<p>简易写法</p>
<pre><code class="highlight plaintext">:scp [可选参数] file_source file_target</code></pre>
<p>参数说明：</p>
<ul>
<li>-1： 强制scp命令使用协议ssh1</li>
<li>-2： 强制scp命令使用协议ssh2</li>
<li>-4： 强制scp命令只使用IPv4寻址</li>
<li>-6： 强制scp命令只使用IPv6寻址</li>
<li>-B： 使用批处理模式（传输过程中不询问传输口令或短语）</li>
<li>-C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</li>
<li>-p：保留原文件的修改时间，访问时间和访问权限。</li>
<li>-q： 不显示传输进度条。</li>
<li>-r： 递归复制整个目录。</li>
<li>-v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li>
<li>-c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</li>
<li>-F ssh_config： 指定一个替代的ssh配置文件，此参数直接传递给ssh。</li>
<li>-i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</li>
<li>-l limit： 限定用户所能使用的带宽，以Kbit/s为单位。</li>
<li>-o ssh_option： 如果习惯于使用ssh_config(5)中的参数传递方式，</li>
<li>-P port：<strong>注意是大写的P, port是指定数据传输用到的端口号</strong></li>
<li>-S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</li>
</ul>
<hr />
<p><strong>本机-&gt;远程</strong></p>
<p>目前我们处在IP为“192.168.60.133”的Linux系统下，计划将系统下的/home/ixdba/etc.tar.gz文件拷贝到IP为“192.168.60</p>
<p>168”的远程Linux系统中root用户下的/tmp目录下：</p>
<pre><code class="highlight plaintext">scp /home/etc.tar root@192.168.60.168:/tmp</code></pre>
<p>命令输入完毕，会要求输入“192.168.60.168”服务器root的密码，然后开始远程拷贝数据。</p>
<p><strong>远程-&gt;本机</strong></p>
<p>如果我们处在“192.168.60.168”服务器上，也可以使用下面的命令传输数据：</p>
<pre><code class="highlight plaintext">scp root@192.168.60.133:/home/etc.tar /tmp</code></pre>
<p>命令输入完毕，此时会要求输入“192.168.60.133”服务器root的密码，然后开始远程拷贝数据。</p>
<h3 id="ssh"><a class="markdownIt-Anchor" href="#ssh"></a> SSH</h3>
<p>通过网络来远程操控类 Unix 的操作系统已经有很多年了。早些年，在因特网普遍推广之前，有 一些受欢迎的程序被用来登录远程主机。它们是 rlogin 和 telnet 程序。然而这些程序，拥有和 ftp 程序 一样的致命缺点；它们以明码形式来传输所有的交流信息（包括登录命令和密码）。这使它们完全不 适合使用在因特网时代。</p>
<p>为了解决这个问题，开发了一款新的协议，叫做 SSH（Secure Shell）。 SSH 解决了这两个基本的和远端主机安全交流的问题。首先，它要认证远端主机是否为它 所知道的那台主机（这样就阻止了所谓的“中间人”的攻击），其次，它加密了本地与远程主机之间 所有的通讯信息。</p>
<p>SSH 由两部分组成。SSH 服务器运行在远端主机上运行，在端口号22上监听将要到来的连接，而 SSH 客户端用在本地系统中，用来和远端服务器通信。</p>
<p>大多数 Linux 发行版自带一个提供 SSH 功能的软件包，叫做 OpenSSH，来自于 BSD 项目。一些发行版 默认包含客户端和服务器端两个软件包（例如，Red Hat）,而另一些（比方说 Ubuntu）则只是提供客户端服务。为了能让系统接受远端的连接，它必须 安装 OpenSSH-server 软件包，配置，运行它，并且（如果系统正在运行，或者是在防火墙之后） 它必须允许在 TCP 端口号上接收网络连接。</p>
<p><strong>建立连接</strong></p>
<p>试用下述命令，然后输入正确的密码，即可连接到目标主机。</p>
<p>成功地输入密码之后，我们会接收到远端系统的 shell 提示符：</p>
<pre><code class="highlight plaintext"># ssh root@172.172.30.71
root@172.172.30.71&#x27;s password: 
Last login: Wed Nov  4 09:46:17 2020 from 192.168.211.182

[root@linux71 ~]#</code></pre>
<blockquote>
<p>远端 shell 会话一直存在，直到用户输入 exit 命令后，则关闭了远程连接。这时候，本地的 shell 会话 恢复，本地 shell 提示符重新出现。</p>
</blockquote>
<p>每建立一个新的连接，都会在 ~/.ssh/known_hosts 文件生成如下的一行话：</p>
<pre><code class="highlight plaintext">192.168.211.182 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBAeprXVlg+94HN0SGnFuFl2GdEShQ9sZTD5sDtAKd1ZX6ERPVsHhjoWhZxToY8JDI9Ng02xlc7/kr4Mvbk/tZI4=</code></pre>
<p>ssh 验证远端主机的真实性。如果远端主机不能成功地通过验证，则会提示以下信息：</p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ ssh remote-sys
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@
WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!
@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle
attack)!...</code></pre>
<p>有两种可能的情形会提示这些信息。第一，某个攻击者企图制造“中间人”袭击。这很少见， 因为每个人都知道 ssh 会针对这种状况发出警告。最有可能的罪魁祸首是远端系统已经改变了； 例如，它的操作系统或者是 SSH 服务器重新安装了。然而，为了安全起见，第一个可能性不应该 被轻易否定。当这条消息出现时，总要与远端系统的管理员查对一下。当确定了这条消息归结为一个良性的原因之后，那么在客户端更正问题就很安全了。 使用文本编辑器（可能是 vim）从文件~/.ssh/known_hosts 中删除废弃的钥匙， 就解决了问题。在上面的例子里，我们看到这样一句话：</p>
<pre><code class="highlight plaintext">Offending key in /home/me/.ssh/known_hosts:1</code></pre>
<p>这意味着文件 known_hosts 里面某一行包含攻击型的钥匙。从文件中删除这一行，则 ssh 程序 就能够从远端系统接受新的身份验证凭据。</p>
<hr />
<p><strong>在远端主机执行命令</strong></p>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ ssh root@172.172.30.71 &#x27;ls \*&#x27; &gt; dirlist.txt
me@twin4&#x27;s password:
[me@linuxbox ~]$</code></pre>
<blockquote>
<p>注意，上面的例子中使用了单引号。这样做是因为我们不想路径名展开操作在本地执行 ；而希望 它在远端系统中被执行。同样地，如果我们想要把输出结果重定向到远端主机的文件中，我们可以 把重定向操作符和文件名都放到单引号里面</p>
</blockquote>
<pre><code class="highlight plaintext">[me@linuxbox ~]$ ssh remote-sys &#x27;ls * &gt; dirlist.txt&#x27;</code></pre>
<h3 id="防火墙"><a class="markdownIt-Anchor" href="#防火墙"></a> 防火墙</h3>
<p>在RHEL 7系统中，firewalld防火墙取代了iptables防火墙.</p>
<p>其实，iptables与firewalld都不是真正的防火墙，它们都只是用来定义防火墙策略的防火墙管理工具而已，或者说，它们只是一种服务。</p>
<p>iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。换句话说，当前在Linux系统中其实存在多个防火墙管理工具，旨在方便运维人员管理Linux系统中的防火墙策略，我们只需要配置妥当其中的一个就足够了。</p>
<h4 id="打开防火墙"><a class="markdownIt-Anchor" href="#打开防火墙"></a> 打开防火墙</h4>
<pre><code class="highlight plaintext">systemctl start firewalld
或者
systemctl start Iptables</code></pre>
<h4 id="关闭防火墙"><a class="markdownIt-Anchor" href="#关闭防火墙"></a> 关闭防火墙</h4>
<pre><code class="highlight plaintext">systemctl stop firewalld
或者
systemctl stop Iptables</code></pre>
<h4 id="iptables"><a class="markdownIt-Anchor" href="#iptables"></a> iptables</h4>
<p>在早期的Linux系统中，默认使用的是iptables防火墙管理服务来配置防火墙。尽管新型的firewalld防火墙管理服务已经被投入使用多年，但是大量的企业在生产环境中依然出于各种原因而继续使用iptables。</p>
<h5 id="策略与规则链"><a class="markdownIt-Anchor" href="#策略与规则链"></a> 策略与规则链</h5>
<p>防火墙会从上至下的顺序来读取配置的策略规则，在找到匹配项后就立即结束匹配工作并去执行匹配项中定义的行为（即放行或阻止）。如果在读取完所有的策略规则之后没有匹配项，就去执行默认的策略。</p>
<p>一般而言，防火墙策略规则的设置有两种：一种是“通”（即放行），一种是“堵”（即阻止）。当防火墙的默认策略为拒绝时（堵），就要设置允许规则（通），否则谁都进不来；如果防火墙的默认策略为允许时，就要设置拒绝规则，否则谁都能进来，防火墙也就失去了防范的作用。</p>
<p>iptables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链，而规则链则依据数据包处理位置的不同进行分类，具体如下：</p>
<ul>
<li>在进行路由选择前处理数据包（PREROUTING）</li>
<li>处理流入的数据包（INPUT）</li>
<li>处理流出的数据包（OUTPUT）</li>
<li>处理转发的数据包（FORWARD）</li>
<li>在进行路由选择后处理数据包（POSTROUTING）</li>
</ul>
<p>一般来说，从内网向外网发送的流量一般都是可控且良性的，因此我们使用最多的就是INPUT规则链，该规则链可以增大黑客人员从外网入侵内网的难度。</p>
<blockquote>
<p>比如在您居住的社区内，物业管理公司有两条规定：禁止小商小贩进入社区；各种车辆在进入社区时都要登记。显而易见，这两条规定应该是用于社区的正门的（流量必须经过的地方），而不是每家每户的防盗门上。根据前面提到的防火墙策略的匹配顺序，可能会存在多种情况。比如，来访人员是小商小贩，则直接会被物业公司的保安拒之门外，也就无需再对车辆进行登记。如果来访人员乘坐一辆汽车进入社区正门，则“禁止小商小贩进入社区”的第一条规则就没有被匹配到，因此按照顺序匹配第二条策略，即需要对车辆进行登记。如果是社区居民要进入正门，则这两条规定都不会匹配到，因此会执行默认的放行策略。</p>
</blockquote>
<p>但是，仅有策略规则还不能保证社区的安全，保安还应该知道采用什么样的动作来处理这些匹配的流量，比如“允许”、“拒绝”、“登记”、“不理它”。这些动作对应到iptables服务的术语中分别是<strong>ACCEPT</strong>（允许流量通过）、<strong>REJECT</strong>（拒绝流量通过）、<strong>LOG</strong>（记录日志信息）、<strong>DROP</strong>（拒绝流量通过）。“允许流量通过”和“记录日志信息”都比较好理解，这里需要着重讲解的是REJECT和DROP的不同点。就DROP来说，它是直接将流量丢弃而且不响应；REJECT则会在拒绝流量后再回复一条“您的信息已经收到，但是被扔掉了”信息，从而让流量发送方清晰地看到数据被拒绝的响应信息。</p>
<blockquote>
<p>我们来举一个例子，让各位读者更直观地理解这两个拒绝动作的不同之处。比如有一天您正在家里看电视，突然听到有人敲门，您透过防盗门的猫眼一看是推销商品的，便会在不需要的情况下开门并拒绝他们（REJECT）。但如果您看到的是债主带了十几个小弟来讨债，此时不仅要拒绝开门，还要默不作声，伪装成自己不在家的样子（DROP）</p>
</blockquote>
<p>当把Linux系统中的防火墙策略设置为REJECT拒绝动作后，流量发送方会看到端口不可达的响应：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# ping -c 4 192.168.10.10
PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.
From 192.168.10.10 icmp_seq=1 Destination Port Unreachable
From 192.168.10.10 icmp_seq=2 Destination Port Unreachable
From 192.168.10.10 icmp_seq=3 Destination Port Unreachable
From 192.168.10.10 icmp_seq=4 Destination Port Unreachable
--- 192.168.10.10 ping statistics ---
4 packets transmitted, 0 received, +4 errors, 100% packet loss, time 3002ms</code></pre>
<p>而把Linux系统中的防火墙策略修改成DROP拒绝动作后，流量发送方会看到响应超时的提醒。但是流量发送方无法判断流量是被拒绝，还是接收方主机当前不在线：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# ping -c 4 192.168.10.10
PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.
 
--- 192.168.10.10 ping statistics ---
4 packets transmitted, 0 received, 100% packet loss, time 3000ms</code></pre>
<h5 id="基本命令参数"><a class="markdownIt-Anchor" href="#基本命令参数"></a> 基本命令参数</h5>
<p>iptables命令可以根据流量的源地址、目的地址、传输协议、服务类型等信息进行匹配，一旦匹配成功，iptables就会根据策略规则所预设的动作来处理这些流量。另外，再次提醒一下，防火墙策略规则的匹配顺序是从上至下的，因此要把较为严格、优先级较高的策略规则放到前面，以免发生错误</p>
<p>表总结归纳了常用的iptables命令参数。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-P</td>
<td>设置默认策略</td>
</tr>
<tr>
<td>-F</td>
<td>清空规则链</td>
</tr>
<tr>
<td>-L</td>
<td>查看规则链</td>
</tr>
<tr>
<td>-A</td>
<td>在规则链的末尾加入新规则</td>
</tr>
<tr>
<td>-I num</td>
<td>在规则链的头部加入新规则</td>
</tr>
<tr>
<td>-D num</td>
<td>删除某一条规则</td>
</tr>
<tr>
<td>-s</td>
<td>匹配来源地址IP/MASK，加叹号“!”表示除这个IP外</td>
</tr>
<tr>
<td>-d</td>
<td>匹配目标地址</td>
</tr>
<tr>
<td>-i</td>
<td>网卡名称 匹配从这块网卡流入的数据</td>
</tr>
<tr>
<td>-o</td>
<td>网卡名称 匹配从这块网卡流出的数据</td>
</tr>
<tr>
<td>-p</td>
<td>匹配协议，如TCP、UDP、ICMP</td>
</tr>
<tr>
<td>—dport num</td>
<td>匹配目标端口号</td>
</tr>
<tr>
<td>—sport num</td>
<td>匹配来源端口号</td>
</tr>
</tbody>
</table>
<p><strong>在iptables命令后添加-L参数查看已有的防火墙规则链：</strong></p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -L
Chain INPUT (policy ACCEPT)
target prot opt source destination 
ACCEPT all -- anywhere anywhere ctstate RELATED,ESTABLISHED
ACCEPT all -- anywhere anywhere 
INPUT_direct all -- anywhere anywhere 
INPUT_ZONES_SOURCE all -- anywhere anywhere 
INPUT_ZONES all -- anywhere anywhere 
ACCEPT icmp -- anywhere anywhere 
REJECT all -- anywhere anywhere reject-with icmp-host-prohibited
………………省略部分输出信息………………</code></pre>
<p>在iptables命令后添加-F参数清空已有的防火墙规则链：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -F
[root@linuxprobe ~]# iptables -L
Chain INPUT (policy ACCEPT)
target prot opt source destination 
………………省略部分输出信息………………</code></pre>
<p>把INPUT规则链的默认策略设置为拒绝：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -P INPUT DROP
[root@linuxprobe ~]# iptables -L
Chain INPUT (policy DROP)
target prot opt source destination 
…………省略部分输出信息………………</code></pre>
<p>如前面所提到的防火墙策略设置无非有两种方式，一种是“通”，一种是“堵”，当把INPUT链设置为默认拒绝后，就要往里面写入允许策略了，否则所有流入的数据包都会被默认拒绝掉，同学们需要留意规则链的默认策略拒绝动作只能是DROP，而不能是REJECT。</p>
<p><strong>向INPUT链中添加允许ICMP流量进入的策略规则：</strong></p>
<p>在日常运维工作中，经常会使用ping命令来检查对方主机是否在线，而向防火墙的INPUT规则链中添加一条允许ICMP流量进入的策略规则就默认允许了这种ping命令检测行为。</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -I INPUT -p icmp -j ACCEPT
[root@linuxprobe ~]# ping -c 4 192.168.10.10
PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.
64 bytes from 192.168.10.10: icmp_seq=1 ttl=64 time=0.156 ms
64 bytes from 192.168.10.10: icmp_seq=2 ttl=64 time=0.117 ms
64 bytes from 192.168.10.10: icmp_seq=3 ttl=64 time=0.099 ms
64 bytes from 192.168.10.10: icmp_seq=4 ttl=64 time=0.090 ms
--- 192.168.10.10 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 2999ms
rtt min/avg/max/mdev = 0.090/0.115/0.156/0.027 ms</code></pre>
<p><strong>删除INPUT规则链中刚刚加入的那条策略（允许ICMP流量），并把默认策略设置为允许：</strong></p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -D INPUT 1
[root@linuxprobe ~]# iptables -P INPUT ACCEPT
[root@linuxprobe ~]# iptables -L
Chain INPUT (policy ACCEPT)
target prot opt source destination
………………省略部分输出信息………………</code></pre>
<p><strong>将INPUT规则链设置为只允许指定网段的主机访问本机的22端口，拒绝来自其他所有主机的流量：</strong></p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -I INPUT -s 192.168.10.0/24 -p tcp --dport 22 -j ACCEPT
[root@linuxprobe ~]# iptables -A INPUT -p tcp --dport 22 -j REJECT
[root@linuxprobe ~]# iptables -L
Chain INPUT (policy ACCEPT)
target prot opt source destination 
ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh
REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable
………………省略部分输出信息………………</code></pre>
<p><strong>向INPUT规则链中添加拒绝所有人访问本机12345端口的策略规则：</strong></p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -I INPUT -p tcp --dport 12345 -j REJECT
[root@linuxprobe ~]# iptables -I INPUT -p udp --dport 12345 -j REJECT
[root@linuxprobe ~]# iptables -L
Chain INPUT (policy ACCEPT)
target prot opt source destination 
REJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachable
REJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachable
ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh
REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable
………………省略部分输出信息………………</code></pre>
<p><strong>向INPUT规则链中添加拒绝192.168.10.5主机访问本机80端口（Web服务）的策略规则：</strong></p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT
[root@linuxprobe ~]# iptables -L
Chain INPUT (policy ACCEPT)
target prot opt source destination 
REJECT tcp -- 192.168.10.5 anywhere tcp dpt:http reject-with icmp-port-unreachable
REJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachable
REJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachable
ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh
REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable
………………省略部分输出信息………………</code></pre>
<p><strong>向INPUT规则链中添加拒绝所有主机访问本机1000～1024端口的策略规则：</strong></p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# iptables -A INPUT -p tcp --dport 1000:1024 -j REJECT
[root@linuxprobe ~]# iptables -A INPUT -p udp --dport 1000:1024 -j REJECT
[root@linuxprobe ~]# iptables -L
Chain INPUT (policy ACCEPT)
target prot opt source destination 
REJECT tcp -- 192.168.10.5 anywhere tcp dpt:http reject-with icmp-port-unreachable
REJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachable
REJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachable
ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh
REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable
REJECT tcp -- anywhere anywhere tcp dpts:cadlock2:1024 reject-with icmp-port-unreachable
REJECT udp -- anywhere anywhere udp dpts:cadlock2:1024 reject-with icmp-port-unreachable</code></pre>
<h5 id="允许某个ip某个端口访问"><a class="markdownIt-Anchor" href="#允许某个ip某个端口访问"></a> 允许某个ip某个端口访问</h5>
<pre><code class="highlight plaintext">#拒绝所有
iptables -I INPUT -p TCP --dport 80 -j DROP
#允许46.166.150.22访问80端口
iptables -I INPUT -s 46.166.150.22 -p TCP --dport 80 -j ACCEPT

#--line-number参数会显示策略编号，该编号在删除策略时使用
iptables -L -n --line-number

#2是--line-number查到的，此句会删除第2条策略
iptables -D INPUT 2</code></pre>
<h5 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h5>
<pre><code class="highlight plaintext">#增加，限制进
iptables -A INPUT -p tcp -s 192.168.0.83 --sport 23 -j ACCEPT
#增加，限制出
iptables -A INPUT -p tcp -d 192.168.0.83 --dport 23 -j ACCEPT

#删除
iptables -D INPUT -p tcp -s 192.168.0.83 --sport 23 -j ACCEPT</code></pre>
<h4 id="firewalld"><a class="markdownIt-Anchor" href="#firewalld"></a> Firewalld</h4>
<p>RHEL 7系统中集成了多款防火墙管理工具，其中firewalld（Dynamic Firewall Manager of Linux systems，Linux系统的动态防火墙管理器）服务是默认的防火墙配置管理工具，它拥有基于CLI（命令行界面）和基于GUI（图形用户界面）的两种管理方式。</p>
<p>相较于传统的防火墙管理配置工具，firewalld支持动态更新技术并加入了区域（zone）的概念。简单来说，区域就是firewalld预先准备了几套防火墙策略集合（策略模板），用户可以根据生产场景的不同而选择合适的策略集合，从而实现防火墙策略之间的快速切换。例如，我们有一台笔记本电脑，每天都要在办公室、咖啡厅和家里使用。按常理来讲，这三者的安全性按照由高到低的顺序来排列，应该是家庭、公司办公室、咖啡厅。当前，我们希望为这台笔记本电脑指定如下防火墙策略规则：在家中允许访问所有服务；在办公室内仅允许访问文件共享服务；在咖啡厅仅允许上网浏览。在以往，我们需要频繁地手动设置防火墙策略规则，而现在只需要预设好区域集合，然后只需轻点鼠标就可以自动切换了，从而极大地提升了防火墙策略的应用效率。</p>
<p><strong>firewalld中常用的区域名称及策略规则</strong></p>
<table>
<thead>
<tr>
<th>区域</th>
<th>默认规则策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>trusted</td>
<td>允许所有的数据包</td>
</tr>
<tr>
<td>home</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>internal</td>
<td>等同于home区域</td>
</tr>
<tr>
<td>work</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、ipp-client与dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>public</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>external</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td>
</tr>
<tr>
<td>dmz</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td>
</tr>
<tr>
<td>block</td>
<td>拒绝流入的流量，除非与流出的流量相关</td>
</tr>
<tr>
<td>drop</td>
<td>拒绝流入的流量，除非与流出的流量相关</td>
</tr>
</tbody>
</table>
<h5 id="终端管理工具"><a class="markdownIt-Anchor" href="#终端管理工具"></a> 终端管理工具</h5>
<p>命令行终端是一种极富效率的工作方式，firewall-cmd是firewalld防火墙配置管理工具的CLI（命令行界面）版本。它的参数一般都是以“长格式”来提供的，大家不要一听到长格式就头大，因为RHEL 7系统支持部分命令的参数补齐，其中就包含这条命令（很酷吧）。也就是说，现在除了能用Tab键自动补齐命令或文件名等内容之外，还可以用Tab键来补齐表8-3中所示的长格式参数了。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>—get-default-zone</td>
<td>查询默认的区域名称</td>
</tr>
<tr>
<td>—set-default-zone=&lt;区域名称&gt;</td>
<td>设置默认的区域，使其永久生效</td>
</tr>
<tr>
<td>—get-zones</td>
<td>显示可用的区域</td>
</tr>
<tr>
<td>—get-services</td>
<td>显示预先定义的服务</td>
</tr>
<tr>
<td>—get-active-zones</td>
<td>显示当前正在使用的区域与网卡名称</td>
</tr>
<tr>
<td>—add-source=</td>
<td>将源自此IP或子网的流量导向指定的区域</td>
</tr>
<tr>
<td>—remove-source=</td>
<td>不再将源自此IP或子网的流量导向某个指定区域</td>
</tr>
<tr>
<td>—add-interface=&lt;网卡名称&gt;</td>
<td>将源自该网卡的所有流量都导向某个指定区域</td>
</tr>
<tr>
<td>—change-interface=&lt;网卡名称&gt;</td>
<td>将某个网卡与区域进行关联</td>
</tr>
<tr>
<td>—list-all</td>
<td>显示当前区域的网卡配置参数、资源、端口以及服务等信息</td>
</tr>
<tr>
<td>—list-all-zones</td>
<td>显示所有区域的网卡配置参数、资源、端口以及服务等信息</td>
</tr>
<tr>
<td>—add-service=&lt;服务名&gt;</td>
<td>设置默认区域允许该服务的流量</td>
</tr>
<tr>
<td>—add-port=&lt;端口号/协议&gt;</td>
<td>设置默认区域允许该端口的流量</td>
</tr>
<tr>
<td>—remove-service=&lt;服务名&gt;</td>
<td>设置默认区域不再允许该服务的流量</td>
</tr>
<tr>
<td>—remove-port=&lt;端口号/协议&gt;</td>
<td>设置默认区域不再允许该端口的流量</td>
</tr>
<tr>
<td>—reload</td>
<td>让“永久生效”的配置规则立即生效，并覆盖当前的配置规则</td>
</tr>
<tr>
<td>—panic-on</td>
<td>开启应急状况模式</td>
</tr>
<tr>
<td>—panic-off</td>
<td>关闭应急状况模式</td>
</tr>
</tbody>
</table>
<p>与Linux系统中其他的防火墙策略配置工具一样，使用firewalld配置的防火墙策略默认为运行时（Runtime）模式，又称为当前生效模式，而且随着系统的重启会失效。</p>
<p>如果想让配置策略一直存在，就需要使用永久（Permanent）模式了，方法就是在用firewall-cmd命令正常设置防火墙策略时添加—permanent参数，这样配置的防火墙策略就可以永久生效了。但是，永久生效模式有一个“不近人情”的特点，就是使用它设置的策略只有在系统重启之后才能自动生效。</p>
<p>如果想让配置的策略立即生效，需要手动执行firewall-cmd —reload命令。</p>
<p>查看firewalld服务当前所使用的区域：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --get-default-zone
public</code></pre>
<p>查询eno16777728网卡在firewalld服务中的区域：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --get-zone-of-interface=eno16777728
public</code></pre>
<p>把firewalld服务中eno16777728网卡的默认区域修改为external，并在系统重启后生效。分别查看当前与永久模式下的区域名称：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --permanent --zone=external --change-interface=eno16777728
success
[root@linuxprobe ~]# firewall-cmd --get-zone-of-interface=eno16777728
public
[root@linuxprobe ~]# firewall-cmd --permanent --get-zone-of-interface=eno16777728
external</code></pre>
<p>把firewalld服务的当前默认区域设置为public：</p>
<pre><code class="highlight plaintext">
[root@linuxprobe ~]# firewall-cmd --set-default-zone=public
success
[root@linuxprobe ~]# firewall-cmd --get-default-zone
public</code></pre>
<p>启动/关闭firewalld防火墙服务的应急状况模式，阻断一切网络连接（当远程控制服务器时请慎用）：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --panic-on
success
[root@linuxprobe ~]# firewall-cmd --panic-off
success</code></pre>
<p>查询public区域是否允许请求SSH和HTTPS协议的流量：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=ssh
yes
[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=https
no</code></pre>
<p>把firewalld服务中请求HTTPS协议的流量设置为永久允许，并立即生效：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --zone=public --add-service=https
success
[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-service=https
success
[root@linuxprobe ~]# firewall-cmd --reload
success</code></pre>
<p>把firewalld服务中请求HTTP协议的流量设置为永久拒绝，并立即生效：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --remove-service=http 
success
[root@linuxprobe ~]# firewall-cmd --reload 
success</code></pre>
<p>把在firewalld服务中访问8080和8081端口的流量策略设置为允许，但仅限当前生效：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --zone=public --add-port=8080-8081/tcp
success
[root@linuxprobe ~]# firewall-cmd --zone=public --list-ports 
8080-8081/tcp</code></pre>
<p><strong>把原本访问本机888端口的流量转发到22端口，要且求当前和长期均有效：</strong></p>
<ul>
<li>流量转发命令格式为firewall-cmd —permanent —zone=&lt;区域&gt; —add-forward-port=port=&lt;源端口号&gt;:proto=&lt;协议&gt;:toport=&lt;目标端口号&gt;:toaddr=&lt;目标IP地址&gt;</li>
</ul>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-forward-port=port=888:proto=tcp:toport=22:toaddr=192.168.10.10
success
[root@linuxprobe ~]# firewall-cmd --reload
success</code></pre>
<p>在客户端使用ssh命令尝试访问192.168.10.10主机的888端口：</p>
<pre><code class="highlight plaintext">[root@client A ~]# ssh -p 888 192.168.10.10
The authenticity of host &#x27;[192.168.10.10]:888 ([192.168.10.10]:888)&#x27; can&#x27;t be established.
ECDSA key fingerprint is b8:25:88:89:5c:05:b6:dd:ef:76:63:ff:1a:54:02:1a.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added &#x27;[192.168.10.10]:888&#x27; (ECDSA) to the list of known hosts.
root@192.168.10.10&#x27;s password:此处输入远程root管理员的密码
Last login: Sun Jul 19 21:43:48 2017 from 192.168.10.10</code></pre>
<p>firewalld中的富规则表示更细致、更详细的防火墙策略配置，它可以针对系统服务、端口号、源地址和目标地址等诸多信息进行更有针对性的策略配置。它的优先级在所有的防火墙策略中也是最高的。比如，我们可以在firewalld服务中配置一条富规则，使其拒绝192.168.10.0/24网段的所有用户访问本机的ssh服务（22端口）：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.10.0/24&quot; service name=&quot;ssh&quot; reject&quot;
success
[root@linuxprobe ~]# firewall-cmd --reload
success</code></pre>
<h5 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例</h5>
<pre><code class="highlight plaintext">#增加规则
firewall-cmd --permanent --direct --add-rule ipv4/ipv6 filter OUTPUT 0 
-p tcp --dport 1:65535 -d 0.0.0.0/0 -j DROP

firewall-cmd --permanent --direct --add-rule ipv4/ipv6 filter INPUT 0 -p 
tcp --sport 1:65535 -s 0.0.0.0/0 -j DROP

#删除规则
firewall-cmd --permanent --direct --remove-rule ipv4/ipv6 filter INPUT 0 -p 
tcp --sport 1:65535 -s 0.0.0.0/0 -j DROP</code></pre>
<h5 id="图形管理工具"><a class="markdownIt-Anchor" href="#图形管理工具"></a> 图形管理工具</h5>
<p><strong>firewall-config</strong>是firewalld防火墙配置管理工具的GUI（图形用户界面）版本，几乎可以实现所有以命令行来执行的操作。毫不夸张的说，即使读者没有扎实的Linux命令基础，也完全可以通过它来妥善配置RHEL 7中的防火墙策略。</p>
<pre><code class="highlight plaintext">$ firewall-config</code></pre>
<p><img src="image/-26.png" alt="-26.png" /></p>
<blockquote>
<p>在使用firewall-config工具配置完防火墙策略之后，无须进行二次确认，因为只要有修改内容，它就自动进行保存</p>
</blockquote>
<p>实例（配置8080-8088的http请求允许访问）：</p>
<ul>
<li>我们先将当前区域中请求http服务的流量设置为允许，但仅限当前生效<br />
<img src="image/-27.png" alt="-27.png" /></li>
<li>尝试添加一条防火墙策略规则，使其放行访问8080～8088端口（TCP协议）的流量，并将其设置为永久生效，以达到系统重启后防火墙策略依然生效的目的<br />
<img src="image/-28.png" alt="-28.png" /></li>
<li>配置完毕之后，还需要在Options菜单中单击Reload Firewalld命令，让配置的防火墙策略立即生效<br />
<img src="image/-29.png" alt="-29.png" /></li>
</ul>
<p>实例2（使用SNAT技术处理过的网络）</p>
<ul>
<li>前面在讲解firewall-config工具的功能时，曾经提到了SNAT（Source Network Address Translation，源网络地址转换）技术。SNAT是一种为了解决IP地址匮乏而设计的技术，它可以使得多个内网中的用户通过同一个外网IP接入Internet。</li>
<li>大家可以看一下在网络中不使用SNAT技术（见图1）和使用SNAT技术（见图2）时的情况。
<ul>
<li>在图1所示的局域网中有多台PC，如果网关服务器没有应用SNAT技术，则互联网中的网站服务器在收到PC的请求数据包，并回送响应数据包时，将无法在网络中找到这个私有网络的IP地址，所以PC也就收不到响应数据包了。</li>
<li>在图2所示的局域网中，由于网关服务器应用了SNAT技术，所以互联网中的网站服务器会将响应数据包发给网关服务器，再由后者转发给局域网中的PC。</li>
<li><img src="image/-30.png" alt="-30.png" /></li>
</ul>
</li>
<li>使用iptables命令实现SNAT技术是一件很麻烦的事情，但是在firewall-config中却是小菜一碟了。用户只需按照图8-8进行配置，并选中Masquerade zone复选框，就自动开启了SNAT技术。<img src="image/-31.png" alt="-31.png" /></li>
</ul>
<p>实例3：</p>
<ul>
<li>为了让大家直观查看不同工具在实现相同功能的区别，这里使用firewall-config工具重新演示了前面使用firewall-cmd来配置防火墙策略规则，将本机888端口的流量转发到22端口，且要求当前和长期均有效<img src="image/-32.png" alt="-32.png" /></li>
<li>让防火墙策略立即生效</li>
<li><img src="image/-33.png" alt="-33.png" /></li>
</ul>
<p>实例4：</p>
<ul>
<li>配置富规则，让192.168.10.20主机访问到本机的1234端口号<br />
<img src="image/-34.png" alt="-34.png" /></li>
</ul>
<h3 id="开放指定端口"><a class="markdownIt-Anchor" href="#开放指定端口"></a> 开放指定端口</h3>
<pre><code class="highlight plaintext">1、开启防火墙 
systemctl start firewalld

2、开放指定端口
firewall-cmd --zone=public --add-port=1935/tcp --permanent
 命令含义：
--zone #作用域
--add-port=1935/tcp  #添加端口，格式为：端口/通讯协议
--permanent  #永久生效，没有此参数重启后失效

3、重启防火墙
firewall-cmd --reload

4、查看端口号
netstat -ntlp   //查看当前所有tcp端口·

netstat -ntulp |grep 1935   //查看所有1935端口使用情况·</code></pre>
<h3 id="服务的访问控制列表"><a class="markdownIt-Anchor" href="#服务的访问控制列表"></a> 服务的访问控制列表</h3>
<p>TCP Wrappers是RHEL 7系统中默认启用的一款流量监控程序，它能够根据来访主机的地址与本机的目标服务程序作出允许或拒绝的操作。换句话说，Linux系统中其实有两个层面的防火墙，第一种是前面讲到的基于TCP/IP协议的流量过滤工具，而TCP Wrappers服务则是能允许或禁止Linux系统提供服务的防火墙，从而在更高层面保护了Linux系统的安全运行。</p>
<p>TCP Wrappers服务的防火墙策略由两个控制列表文件所控制，用户可以编辑允许控制列表文件来放行对服务的请求流量，也可以编辑拒绝控制列表文件来阻止对服务的请求流量。控制列表文件修改后会立即生效，系统将会先检查<strong>允许控制列表文件（/etc/hosts.allow）</strong>，如果匹配到相应的允许策略则放行流量；如果没有匹配，则去进一步匹配<strong>拒绝控制列表文件（/etc/hosts.deny）</strong>，若找到匹配项则拒绝该流量。如果这两个文件全都没有匹配到，则默认放行流量。</p>
<table>
<thead>
<tr>
<th>客户端类型</th>
<th>示例</th>
<th>满足示例的客户端列表</th>
</tr>
</thead>
<tbody>
<tr>
<td>单一主机</td>
<td>192.168.10.10</td>
<td>IP地址为192.168.10.10的主机</td>
</tr>
<tr>
<td>指定网段</td>
<td>192.168.10.</td>
<td>IP段为192.168.10.0/24的主机</td>
</tr>
<tr>
<td>指定网段</td>
<td>192.168.10.0/255.255.255.0</td>
<td>IP段为192.168.10.0/24的主机</td>
</tr>
<tr>
<td>指定DNS后缀</td>
<td>.linuxprobe.com</td>
<td>所有DNS后缀为.linuxprobe.com的主机</td>
</tr>
<tr>
<td>指定主机名称</td>
<td><a target="_blank" rel="noopener" href="http://www.linuxprobe.com">www.linuxprobe.com</a></td>
<td>主机名称为www.linuxprobe.com的主机</td>
</tr>
<tr>
<td>指定所有客户端</td>
<td>ALL</td>
<td>所有主机全部包括在内</td>
</tr>
</tbody>
</table>
<p>在配置TCP Wrappers服务时需要遵循两个原则：</p>
<ul>
<li>编写拒绝策略规则时，填写的是服务名称，而非协议名称；</li>
<li>建议先编写拒绝策略规则，再编写允许策略规则，以便直观地看到相应的效果。</li>
</ul>
<p>下面编写拒绝策略规则文件，禁止访问本机sshd服务的所有流量（无须/etc/hosts.deny文件中修改原有的注释信息）</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# vim /etc/hosts.deny
#
# hosts.deny This file contains access rules which are used to
# deny connections to network services that either use
# the tcp_wrappers library or that have been
# started through a tcp_wrappers-enabled xinetd.
#
# The rules in this file can also be set up in
# /etc/hosts.allow with a &#x27;deny&#x27; option instead.
#
# See &#x27;man 5 hosts_options&#x27; and &#x27;man 5 hosts_access&#x27;
# for information on rule syntax.
# See &#x27;man tcpd&#x27; for information on tcp_wrappers
sshd:*
[root@linuxprobe ~]# ssh 192.168.10.10
ssh_exchange_identification: read: Connection reset by peer</code></pre>
<p>接下来，在允许策略规则文件中添加一条规则，使其放行源自192.168.10.0/24网段，访问本机sshd服务的所有流量。可以看到，服务器立刻就放行了访问sshd服务的流量，效果非常直观：</p>
<pre><code class="highlight plaintext">[root@linuxprobe ~]# vim /etc/hosts.allow
#
# hosts.allow This file contains access rules which are used to
# allow or deny connections to network services that
# either use the tcp_wrappers library or that have been
# started through a tcp_wrappers-enabled xinetd.
#
# See &#x27;man 5 hosts_options&#x27; and &#x27;man 5 hosts_access&#x27;
# for information on rule syntax.
# See &#x27;man tcpd&#x27; for information on tcp_wrappers
sshd:192.168.10.
[root@linuxprobe ~]# ssh 192.168.10.10
The authenticity of host &#x27;192.168.10.10 (192.168.10.10)&#x27; can&#x27;t be established.
ECDSA key fingerprint is 70:3b:5d:37:96:7b:2e:a5:28:0d:7e:dc:47:6a:fe:5c.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added &#x27;192.168.10.10&#x27; (ECDSA) to the list of known hosts.
root@192.168.10.10&#x27;s password: 
Last login: Wed May 4 07:56:29 2017
[root@linuxprobe ~]#</code></pre>
<h2 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h2>
<h3 id="dirnamebasename截取路径"><a class="markdownIt-Anchor" href="#dirnamebasename截取路径"></a> dirname/basename(截取路径)</h3>
<p><strong>dirname</strong> 命令去除文件名中的非目录部分，删除最后一个“\”后面的路径，显示父目录。</p>
<p>语法：</p>
<pre><code class="highlight plaintext">dirname [选项] 参数</code></pre>
<p>实例：</p>
<pre><code class="highlight plaintext">[root@adm182 t3]# dirname /opt/data/files/outputfiles/libo/t3/SDM_TEST_NEW_SENSITIVE.txt
/opt/data/files/outputfiles/libo/t3</code></pre>
<hr />
<p><strong>basename</strong> 命令用于打印目录或者文件的基本名称，显示最后的目录名或文件名。</p>
<p>语法：</p>
<pre><code class="highlight plaintext">basename [选项] 参数</code></pre>
<p>实例：</p>
<pre><code class="highlight plaintext">[root@adm182 t3]# basename /opt/data/files/outputfiles/libo/t3/SDM_TEST_NEW_SENSITIVE.txt
SDM_TEST_NEW_SENSITIVE.txt</code></pre>
<h3 id="w3m"><a class="markdownIt-Anchor" href="#w3m"></a> w3m</h3>
<p>安装：</p>
<pre><code class="highlight plaintext">yum -y install epel-release

yum -y install w3m</code></pre>
<p>使用：</p>
<pre><code class="highlight plaintext">w3m www.baidu.com</code></pre>
<p><img src="image/-35.png" alt="-35.png" /></p>
<p>页面操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>向下翻页</strong></td>
<td>Space,C-v</td>
</tr>
<tr>
<td>向上翻页</td>
<td>b,ESC v</td>
</tr>
<tr>
<td>焦点向右</td>
<td>l,C-f</td>
</tr>
<tr>
<td>焦点向左</td>
<td>h,C-b</td>
</tr>
<tr>
<td>焦点向下</td>
<td>j,C-n</td>
</tr>
<tr>
<td>焦点向上</td>
<td>k,C-p</td>
</tr>
<tr>
<td>向下滚动一行</td>
<td>J</td>
</tr>
<tr>
<td>向上滚动一行</td>
<td>K</td>
</tr>
<tr>
<td>到行首</td>
<td>^,C-a</td>
</tr>
<tr>
<td>到行尾</td>
<td>$,C-e</td>
</tr>
<tr>
<td>到下一个单词</td>
<td>w</td>
</tr>
<tr>
<td>到上一个单词</td>
<td>W</td>
</tr>
<tr>
<td>右移一屏</td>
<td>&gt;</td>
</tr>
<tr>
<td>左移一屏</td>
<td>&lt;</td>
</tr>
<tr>
<td>屏幕右移一列</td>
<td>.</td>
</tr>
<tr>
<td>屏幕左移一列</td>
<td>,</td>
</tr>
<tr>
<td>到首行</td>
<td>g,M-&lt;</td>
</tr>
<tr>
<td>到末行</td>
<td>G,M-&gt;</td>
</tr>
<tr>
<td>到指定行</td>
<td>ESC g</td>
</tr>
<tr>
<td>当前行居中</td>
<td>Z</td>
</tr>
<tr>
<td>当前列居中</td>
<td>z</td>
</tr>
<tr>
<td>转到下个超链接</td>
<td>TAB</td>
</tr>
<tr>
<td>到上个超链接</td>
<td>C-u,ESC TAB</td>
</tr>
<tr>
<td>到第一个超链接</td>
<td>[</td>
</tr>
<tr>
<td>到最后一个超链接</td>
<td>]</td>
</tr>
<tr>
<td>询问退出/直接退出</td>
<td>q/Q</td>
</tr>
</tbody>
</table>
<p>超链接操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>打开超链接</td>
<td>Enter</td>
</tr>
<tr>
<td>链接另存为</td>
<td>a, ESC Enter</td>
</tr>
<tr>
<td>查看链接</td>
<td>url u</td>
</tr>
<tr>
<td>查看图片</td>
<td>url i</td>
</tr>
<tr>
<td>查看图片</td>
<td>I</td>
</tr>
<tr>
<td>图片另存为</td>
<td>ESC I</td>
</tr>
<tr>
<td>标记字符串为锚点</td>
<td>:</td>
</tr>
<tr>
<td>查看当前页面的 URL</td>
<td>c</td>
</tr>
<tr>
<td>显示当前页面属性</td>
<td>=</td>
</tr>
<tr>
<td>查看当前行号</td>
<td>C-g</td>
</tr>
<tr>
<td>查看历史记录</td>
<td>C-h</td>
</tr>
<tr>
<td>提交表单</td>
<td>F</td>
</tr>
<tr>
<td>用外部浏览器打开当前页面</td>
<td>M</td>
</tr>
<tr>
<td>用外部浏览器打开链接</td>
<td>ESC M</td>
</tr>
<tr>
<td>标记 ID 串为锚点</td>
<td>ESC</td>
</tr>
</tbody>
</table>
<p>文件流操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>打开 URL</td>
<td>U</td>
</tr>
<tr>
<td>打开文件</td>
<td>V</td>
</tr>
<tr>
<td>执行外部命令并导入</td>
<td>@</td>
</tr>
<tr>
<td>执行外部命令并浏览</td>
<td>#</td>
</tr>
</tbody>
</table>
<p>缓存操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回</td>
<td>B</td>
</tr>
<tr>
<td>查看源代码</td>
<td>v</td>
</tr>
<tr>
<td>选择缓存</td>
<td>s</td>
</tr>
<tr>
<td>编辑缓存代码</td>
<td>E</td>
</tr>
<tr>
<td>重画屏幕</td>
<td>C-l</td>
</tr>
<tr>
<td>刷新</td>
<td>R</td>
</tr>
<tr>
<td>页面另存为</td>
<td>S</td>
</tr>
<tr>
<td>源码另存为</td>
<td>ESC s</td>
</tr>
<tr>
<td>编辑图片</td>
<td>ESC e</td>
</tr>
</tbody>
</table>
<p>标签操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>在新标签页打开链接</td>
<td>Ctrl-t</td>
</tr>
<tr>
<td>关闭当前标签</td>
<td>Ctrl-q</td>
</tr>
<tr>
<td>跳到下一个标签</td>
<td>}</td>
</tr>
<tr>
<td>跳到前一个标签</td>
<td>{</td>
</tr>
</tbody>
</table>
<h3 id="split"><a class="markdownIt-Anchor" href="#split"></a> split</h3>
<p>Linux split命令用于将一个文件分割成数个。该指令将大文件分割成较小的文件，在默认情况下将按照每1000行切割成一个小文件。</p>
<p>语法：</p>
<pre><code class="highlight plaintext">split [--help][--version][-&lt;行数&gt;][-b &lt;字节&gt;][-C &lt;字节&gt;][-l &lt;行数&gt;][要切割的文件][输出文件名]</code></pre>
<p>参数：</p>
<ul>
<li>-&lt;行数&gt; : 指定每多少行切成一个小文件</li>
<li>-b&lt;字节&gt; : 指定每多少字节切成一个小文件</li>
<li>–help : 在线帮助</li>
<li>–version : 显示版本信息</li>
<li>-C&lt;字节&gt; : 与参数&quot;-b&quot;相似，但是在切 割时将尽量维持每行的完整性</li>
<li>[输出文件名] : 设置切割后文件的前置文件名， split会自动在前置文件名后再加上编号</li>
</ul>
<p>示例：</p>
<pre><code class="highlight plaintext">模式一：指定分割后文件行数
对与txt文本文件，可以通过指定分割后文件的行数来进行文件分割。
split -l 300 large_file.txt new_file_prefix

模式二：指定分割后文件大小
split -b 10m server.log waynelog</code></pre>
<p><strong>合并方式</strong></p>
<pre><code class="highlight plaintext">cat small_files* &gt; large_file</code></pre>
<h3 id="cpulimit"><a class="markdownIt-Anchor" href="#cpulimit"></a> cpulimit</h3>
<p>Cpulimit 是一个<strong>限制进程的CPU使用率</strong>的工具</p>
<h4 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h4>
<p><strong>网络安�</strong>�</p>
<p>CPULimit 并不是系统自带的工具，使用前要先安装。在 <strong>Debian 或 Ubuntu</strong> 系列的 Linux 中，可以使用 apt 来安装：</p>
<pre><code class="highlight plaintext">apt-get install cpulimit</code></pre>
<p>若在 <strong>CentOS、RHEL</strong> 或者是 Fedora Linux 中，可在启用 EPEL 套件库后，再以 yum 安装：</p>
<pre><code class="highlight plaintext">yum -y install cpulimit</code></pre>
<p><strong>编译安�</strong>�</p>
<pre><code class="highlight plaintext">wget -O cpulimit.zip https://github.com/opsengine/cpulimit/archive/master.zip
unzip cpulimit.zip
cd cpulimit-master
make
sudo cp src/cpulimit /usr/bin</code></pre>
<h4 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h4>
<pre><code class="highlight plaintext">#限制进程名
cpulimit -e httpd -l 40 #限制httpd（进程名）的cpu使用率为40%
#限制路径
cpulimit -e /usr/local/bin/httpd -l 40
#限制pid
cpulimit -p 2960 -l 55 #限制pid为2960的进程的CPU占用为55%

#直接使用cpulimit启动进程
#md5sum /dev/urandom为测试程序，模拟cpu跑满的场景
cpulimit --limit 50 -- md5sum /dev/urandom

cpulimit --limit 50 -- /opt/adm/sdm/jdk/bin/java -jar /opt/adm/sdm/sdm_server-5.0.0.jar</code></pre>
<p><strong>后台运行</strong></p>
<p>cpulimit 在执行时也会占用一个终端机，若想让 cpulimit 在后台运行，可加上 --background 参数：</p>
<pre><code class="highlight plaintext">cpulimit --pid 21203 --limit 50 --background</code></pre>
<p><strong>过高关闭</strong></p>
<p>cpulimit 配合 --limit 参数可以限制进程的 CPU 用量上限值，如果进程超过这个上限值，预设会调节 CPU 用量，而如果想要在 CPU 用量过高时直接中止进程，可以加上 –-kill 参数：</p>
<pre><code class="highlight plaintext">cpulimit --pid 21203 --limit 50 --kill</code></pre>
<p><strong>自动离开</strong></p>
<p>在默认的状况下，cpulimit 在执行时若没有发现指定的进程（或是指定的进程已经中止了），它还是会持续等待并监控系统的进程，只要有发现符合条件的进程，就会继续进行 CPU 用量的控制。若想让 cpulimit 在找不到目标进程时自动离开，可以加上 --lazy 参数：</p>
<pre><code class="highlight plaintext">cpulimit --exe md5sum --limit 50 --lazy</code></pre>
<p><strong>使用例子</strong></p>
<p>在撰写 bash 脚本时，我们可以先执行一个进程，紧接着从 bash 的 $! 变量读取出前一个执行进程的 PID，这样就可以不需要手动查出进程的 PID 了：</p>
<pre><code class="highlight plaintext"># 运行进程
md5sum /dev/urandom &amp;

# 限制上一个进程的 CPU 用量
cpulimit --pid $! --limit 50</code></pre>
</main>

</article>


<script src="/js/highlight.js"></script>

  </main>
  <footer class="footer">
  
  <span>Copyright © 2026 Lism Blog | lisisism@qq.com</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>