<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    Python 丨
    

    Lism Blog
  </title>

  
  <link rel="shortcut icon" href="/icon.svg">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="/Lism Blog" type="application/atom+xml">
</head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">/Lism Blog</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <article class="post">
  
  <div class="post-title">Python</div>
  <div class="post-meta">
    <div class="date">2022 五月 14日</div>
    <div class="tags">
      
      <div class="tag-item">Python</div>
      
    </div>
  </div>
  

  <main class="post-content"><h1 id="python"><a class="markdownIt-Anchor" href="#python"></a> Python</h1>
<p>[toc]</p>
<h2 id="python解析器"><a class="markdownIt-Anchor" href="#python解析器"></a> Python解析器</h2>
<p><strong>CPython</strong></p>
<ul>
<li>当我们从Python官方网站下载并安装好Python 3.x后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。</li>
</ul>
<p><strong>PyPy</strong></p>
<ul>
<li>PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。</li>
</ul>
<p><strong>Jython</strong></p>
<ul>
<li>Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行</li>
</ul>
<p><strong>IronPython</strong></p>
<ul>
<li>IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。</li>
</ul>
<p><strong>小结</strong></p>
<ul>
<li>Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。</li>
</ul>
<h2 id="第一个python程序"><a class="markdownIt-Anchor" href="#第一个python程序"></a> 第一个Python程序</h2>
<h3 id="python交互模式"><a class="markdownIt-Anchor" href="#python交互模式"></a> Python交互模式</h3>
<ul>
<li>Python程序的后缀为<code> .py</code></li>
<li>在Windows命令行模式下敲命令 <code>python</code> , 输出如下文本，就进入Python交互模式，他的提示符是 <code>&gt;&gt;&gt;</code><br />
*</li>
<li>输入<code>exit()</code>回车，就可以退出Python交互模式，并回到命令行模式</li>
<li>可以使用<code>print()</code>函数，打印指定的文字，把文字用<strong>单引号</strong>或<strong>双引号</strong>括起来</li>
</ul>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;hello,world&#x27;</span>)
hello,world

<span class="meta">&gt;&gt;&gt; </span><span class="number">2</span>**<span class="number">10</span>
<span class="number">1024</span></code></pre>
<p><strong>在命令行执行<code>.py</code>文件</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="http://calc.py">calc.py</a></li>
</ul>
<pre><code class="highlight python"><span class="built_in">print</span>(<span class="number">100</span>+<span class="number">200</span>+<span class="number">300</span>)</code></pre>
<ul>
<li>执行（先进入<code>.py</code>文件所在的文件夹）</li>
</ul>
<pre><code class="highlight python">C:\work&gt;python calc.py
<span class="number">600</span></code></pre>
<ul>
<li>在python交互模式下，可以直接输入代码，然后执行，可以立刻得到结果</li>
<li>在命令模式下，可以直接运行<code>.py</code>文件</li>
</ul>
<h3 id="使用文本编辑器"><a class="markdownIt-Anchor" href="#使用文本编辑器"></a> 使用文本编辑器</h3>
<ul>
<li>使用文本编辑器直接写python程序，然后保存为<code>.py</code>，就可以用python直接运行这个程序了</li>
<li>直接输入<code>python</code>进入交互模式，相当于启动了python解释器，但是等待你一行一行的输入源代码，每输入一行就执行一行</li>
<li>直接运行<code>.py</code>文件相当于启动了python解释器，然后一次性把<code>.py</code>文件的源代码给执行了</li>
</ul>
<p><strong>如何直接运行<code>.py</code>文件</strong></p>
<ul>
<li>Windows：
<ul>
<li>不可以直接运行</li>
</ul>
</li>
<li>Linux：
<ul>
<li>在<code>.py</code>文件第一行加上<code>#!/usr/bin/env python3</code></li>
<li>使用chmod命令加可执行权限</li>
</ul>
</li>
</ul>
<h3 id="输入和输出"><a class="markdownIt-Anchor" href="#输入和输出"></a> 输入和输出</h3>
<h4 id="输出"><a class="markdownIt-Anchor" href="#输出"></a> 输出</h4>
<ul>
<li>用<code>print()</code>在括号中加上字符串，就可以输出指定文字</li>
<li><code>print()</code>函数也可以接受多个字符串，用逗号“,”隔开(&quot;,&quot;就表示一个空格)，就可以连成一串输出</li>
<li><code>print()</code>也可以使用加号，拼接字符串</li>
<li><code>print()</code>也可以打印整数，或者计算结果</li>
</ul>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;hello, world&#x27;</span>)
hello, world

<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;The quick brown fox&#x27;</span>, <span class="string">&#x27;jumps over&#x27;</span>, <span class="string">&#x27;the lazy dog&#x27;</span>)
The quick brown fox jumps over the lazy dog

<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;The quick brown fox&#x27;</span>+<span class="string">&#x27;jumps over&#x27;</span>, <span class="string">&#x27;the lazy dog&#x27;</span>)
The quick brown foxjumps over the lazy dog

<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">300</span>)
<span class="number">300</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">100</span> + <span class="number">200</span>)
<span class="number">300</span>

<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;100 + 200 =&#x27;</span>, <span class="number">100</span> + <span class="number">200</span>)
<span class="number">100</span> + <span class="number">200</span> = <span class="number">300</span></code></pre>
<ul>
<li></li>
</ul>
<h4 id="输入"><a class="markdownIt-Anchor" href="#输入"></a> 输入</h4>
<ul>
<li><code>input()</code>，可以让用户输入字符串</li>
</ul>
<p>当运行下述代码，Python交互式命令就在等待用户的输入，可以输入任意的字符</p>
<pre><code class="highlight python">name = <span class="built_in">input</span>()
<span class="built_in">print</span>(<span class="string">&#x27;hello,&#x27;</span>, name)


输入输出:
Michael
hello, Michael</code></pre>
<p>示例</p>
<pre><code class="highlight py">name = <span class="built_in">input</span>(<span class="string">&quot;Please enter your name: &quot;</span>)
<span class="built_in">print</span>(<span class="string">f&quot;\nHello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)

<span class="comment">##可使用函数int() ，它让Python将输入视为数值</span>
age = <span class="built_in">input</span>(<span class="string">&quot;how old are you ?&quot;</span>)
age = <span class="built_in">int</span>(age)
<span class="built_in">print</span>(<span class="string">f&quot;是否成年：<span class="subst">&#123;age&gt;<span class="number">18</span>&#125;</span>&quot;</span>)


prompt = <span class="string">&quot;\nTell me something, and I will repeat it back to you:&quot;</span>
prompt += <span class="string">&quot;\nEnter &#x27;quit&#x27; to end the program. &quot;</span>
active = <span class="literal">True</span>
message = <span class="string">&quot;&quot;</span>
<span class="keyword">while</span> active:
    message = <span class="built_in">input</span>(prompt)
    <span class="keyword">if</span> message == <span class="string">&#x27;quit&#x27;</span>:
        active = <span class="literal">False</span>
    <span class="keyword">else</span>:
        <span class="built_in">print</span>(message)
<span class="comment">##break退出循环</span>
<span class="keyword">while</span> <span class="literal">True</span>:
    message = <span class="built_in">input</span>(prompt)
    <span class="keyword">if</span> message == <span class="string">&#x27;quit&#x27;</span>:
        <span class="keyword">break</span>;
    <span class="keyword">else</span>:
        <span class="built_in">print</span>(message)
<span class="comment">##continue跳过一次循环</span>
current_number = <span class="number">1</span>
<span class="keyword">while</span> current_number &lt; <span class="number">10</span>:
    current_number+=<span class="number">1</span>
    <span class="keyword">if</span> current_number % <span class="number">2</span> == <span class="number">0</span>:
        <span class="keyword">continue</span>
    <span class="built_in">print</span>(current_number)</code></pre>
<h2 id="python基础"><a class="markdownIt-Anchor" href="#python基础"></a> python基础</h2>
<h3 id="格式"><a class="markdownIt-Anchor" href="#格式"></a> 格式</h3>
<ul>
<li>python的语法比较简单，采用<strong>缩进方式</strong></li>
</ul>
<pre><code class="highlight plaintext">#print absolute value of an integer:
a = 100
if a &gt;= 0:
    print(a)
else:
    print(-a)</code></pre>
<blockquote>
<ul>
<li>以 <code>#</code> 开头的语句是注释，多行注释以’‘‘开头，’’'结束</li>
<li>当语句以冒号 <code>:</code> 结尾时，后面缩进tab的语句为代码块，缩进<strong>强制 4 空格</strong>格式</li>
<li><strong>无“：”符号</strong>的语句，每行为一条语句，可通过‘ /’（续行符）再换行则换行的代码也属于同一条语句</li>
<li><strong>带“：”符号</strong>则缩进区域到下一条语句前为同一语句（代码块）。另外当有括号时，成对括号之间换行仍属于同一条语句（[],（）,{}）</li>
<li><strong>大小写敏感</strong>，严格区分大小写</li>
<li><strong>弱类型</strong>（一般根据输入的内容判断变量类型）</li>
<li>缩进的好处时强迫写出缩进较少的代码，你会倾向于把一段很长的代码拆分成若干个函数，从而得到缩进较少的代码</li>
<li>坏处就是不能复制粘贴，IDE无法格式化Python代码</li>
</ul>
</blockquote>
<h3 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h3>
<h4 id="整数int"><a class="markdownIt-Anchor" href="#整数int"></a> 整数int</h4>
<ul>
<li><strong>Python可以处理任意大小的整数</strong>，负整数，写法与数学一摸一样</li>
<li>计算机由于使用二进制，使用十六进制表示整数比较方便，十六进制用<code>0x</code>前缀和<code>0-9,a-f</code>表示，例如：0xff00，0xa5b4c3d2</li>
<li>对于很大的数，例如10000000000，很难数清楚0的个数。Python允许在数字中间以_分隔，因此，写成10_000_000_000和10000000000是完全一样的。十六进制数也可以写成0xa1b2_c3d4。</li>
</ul>
<h4 id="浮点数float"><a class="markdownIt-Anchor" href="#浮点数float"></a> 浮点数float</h4>
<ul>
<li><strong>浮点数也就是小数</strong>，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10<sup>9和12.3x10</sup>8是完全相等的</li>
<li>对于很大或很小的浮点数，使用科学记数法表示，把10用e表示，1.23x10^9就是1.23e9，或者12.3e8，0.000012就是1.2e-5</li>
<li>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差</li>
</ul>
<hr />
<p>整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; 10 / 3
3.3333333333333335</code></pre>
<p><strong>/除法计算结果是浮点数，即使是两个整数恰好整除</strong>，结果也是浮点数：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; 9 / 3
3.0</code></pre>
<hr />
<p><strong>还有一种除法是//，称为地板除</strong>，两个整数的除法仍然是整数：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; 10 // 3
3</code></pre>
<blockquote>
<p>你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。</p>
</blockquote>
<p>因为//除法只取结果的整数部分，所以Python还提供一个<strong>余数运算</strong>，可以得到两个整数相除的余数：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; 10 % 3
1</code></pre>
<h4 id="字符串str"><a class="markdownIt-Anchor" href="#字符串str"></a> 字符串str</h4>
<ul>
<li><strong>字符串是以单引号’或双引号&quot;括起来的任意文本</strong>，比如’abc’，“xyz&quot;等等。请注意，''或”“本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。如果’本身也是一个字符，那就可以用”&quot;括起来，比如&quot;I’m OK&quot;包含的字符是I，'，m，空格，O，K这6个字符。</li>
<li>如果字符串内部既包含’又包含&quot;怎么办？可以用转义字符\来标识，比如：</li>
</ul>
<pre><code class="highlight plaintext">&#x27;I\&#x27;m \&quot;OK\&quot;!&#x27;

表示
I&#x27;m &quot;OK&quot;!</code></pre>
<ul>
<li><strong>转义字符\可以转义很多字符</strong>，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\表示的字符就是\，可以在Python的交互式命令行用print()打印字符串看看：</li>
</ul>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;I\&#x27;m ok.&#x27;</span>)
I<span class="string">&#x27;m ok.</span>
<span class="string">&gt;&gt;&gt; print(&#x27;</span>I\<span class="string">&#x27;m learning\nPython.&#x27;</span>)
I<span class="string">&#x27;m learning</span>
<span class="string">Python.</span>
<span class="string">&gt;&gt;&gt; print(&#x27;</span>\\\n\\<span class="string">&#x27;)</span>
<span class="string">\</span>
<span class="string">\</span></code></pre>
<ul>
<li>如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还<strong>允许用r’‘表示’'内部的字符串默认不转义</strong>，可以自己试试：</li>
</ul>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;\\\t\\&#x27;</span>)
\       \
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">r&#x27;\\\t\\&#x27;</span>)
\\\t\\</code></pre>
<ul>
<li><strong>如果字符串内部有很多换行</strong>，用\n写在一行里不好阅读，为了简化，Python允许用’‘’…‘’'的格式表示多行内容，可以自己试试：</li>
</ul>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&#x27;&#x27;line1</span>
<span class="string"><span class="meta">... </span>line2</span>
<span class="string"><span class="meta">... </span>line3&#x27;&#x27;&#x27;</span>)
line1
line2
line3</code></pre>
<blockquote>
<p>上面是在交互式命令行内输入，注意在输入多行内容时，提示符由&gt;&gt;&gt;变为…，提示你可以接着上一行输入，注意…是提示符，不是代码的一部分：</p>
</blockquote>
<blockquote>
<p>当输入完结束符’''和括号)后，执行该语句并打印结果。</p>
</blockquote>
<ul>
<li><strong>多行字符串’‘’…‘’'还可以在前面加上r(不转义)使用</strong>，请自行测试：</li>
</ul>
<pre><code class="highlight python"><span class="built_in">print</span>(<span class="string">r&#x27;&#x27;&#x27;hello,\n</span>
<span class="string">world&#x27;&#x27;&#x27;</span>)</code></pre>
<ul>
<li>常用函数</li>
</ul>
<pre><code class="highlight python">message = <span class="string">&quot;this is string&quot;</span>
<span class="comment">#首字母大写</span>
message.title()
<span class="comment">#转大写</span>
message.upper()
<span class="comment">#转小写</span>
message.lower()
<span class="comment">#去除首位空格，lstrip rstrip 删除首/尾空格</span>
message.strip()</code></pre>
<ul>
<li>格式字符串f</li>
</ul>
<p>要在字符串中插入变量的值，可在前引号前加上字母f再将要插入的变量放在花括号内。这样，当Python显示字符串时，将把每个变量都替换为其值。</p>
<p>这种字符串名为f字符串 。f是format（设置格式）的简写，因为Python通过把花括号内的变量替换为其值来设置字符串的格式。</p>
<pre><code class="highlight python">first_name = <span class="string">&quot;lee&quot;</span>
last_name = <span class="string">&quot;bo&quot;</span>
<span class="built_in">print</span>(first_name + <span class="string">&quot; &quot;</span> + last_name)
<span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;first_name&#125;</span> <span class="subst">&#123;last_name&#125;</span>&#x27;</span>)</code></pre>
<h4 id="布尔值"><a class="markdownIt-Anchor" href="#布尔值"></a> 布尔值</h4>
<p>布尔值和布尔代数的表示完全一致，<strong>一个布尔值只有True、False两种值</strong>，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; True
True
&gt;&gt;&gt; False
False
&gt;&gt;&gt; 3 &gt; 2
True
&gt;&gt;&gt; 3 &gt; 5
False</code></pre>
<p><strong>布尔值可以用and、or和not运算</strong>。</p>
<ul>
<li>and运算是与运算，只有所有都为True，and运算结果才是True：</li>
</ul>
<pre><code class="highlight plaintext">&gt;&gt;&gt; True and True
True
&gt;&gt;&gt; True and False
False
&gt;&gt;&gt; False and False
False
&gt;&gt;&gt; 5 &gt; 3 and 3 &gt; 1
True</code></pre>
<ul>
<li>or运算是或运算，只要其中有一个为True，or运算结果就是True：</li>
</ul>
<pre><code class="highlight plaintext">&gt;&gt;&gt; True or True
True
&gt;&gt;&gt; True or False
True
&gt;&gt;&gt; False or False
False
&gt;&gt;&gt; 5 &gt; 3 or 1 &gt; 3
True</code></pre>
<ul>
<li>not运算是非运算，它是一个单目运算符，把True变成False，False变成True：</li>
</ul>
<pre><code class="highlight plaintext">&gt;&gt;&gt; not True
False
&gt;&gt;&gt; not False
True
&gt;&gt;&gt; not 1 &gt; 2
True</code></pre>
<p>布尔值经常用在条件判断中，比如：</p>
<pre><code class="highlight python"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;adult&#x27;</span>)
<span class="keyword">else</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;teenager&#x27;</span>)</code></pre>
<h4 id="空值none"><a class="markdownIt-Anchor" href="#空值none"></a> 空值None</h4>
<p><strong>空值是Python里一个特殊的值，用None</strong>表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</p>
<h4 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h4>
<p>变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</p>
<p>变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如：</p>
<ul>
<li>变量a是一个整数。</li>
</ul>
<pre><code class="highlight plaintext">a = 1</code></pre>
<ul>
<li>变量t_007是一个字符串</li>
</ul>
<pre><code class="highlight plaintext">t_007 = &#x27;T007&#x27;</code></pre>
<ul>
<li>变量Answer是一个布尔值True</li>
</ul>
<pre><code class="highlight plaintext">Answer = True</code></pre>
<ul>
<li>同时给多字段赋值</li>
</ul>
<pre><code class="highlight py"><span class="comment">#同时给多个字段赋值</span>
name,age,adress = <span class="string">&quot;lee bo&quot;</span>,<span class="number">15</span>,<span class="string">&quot;xi&#x27;an&quot;</span></code></pre>
<p>在Python中，<strong>等号=是赋值语句</strong>，可以把任意数据类型赋值给变量，<strong>同一个变量可以反复赋值，而且可以是不同类型的变量</strong>，例如：</p>
<pre><code class="highlight python">a = <span class="number">123</span> <span class="comment"># a是整数</span>
<span class="built_in">print</span>(a)
a = <span class="string">&#x27;ABC&#x27;</span> <span class="comment"># a变为字符串</span>
<span class="built_in">print</span>(a)</code></pre>
<blockquote>
<p>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：</p>
</blockquote>
<pre><code class="highlight java"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">123</span>; <span class="comment">// a是整数类型变量</span>
a = <span class="string">&quot;ABC&quot;</span>; <span class="comment">// 错误：不能把字符串赋给整型变量</span></code></pre>
<hr />
<p>最后，理解变量在计算机内存中的表示也非常重要。当我们写：</p>
<pre><code class="highlight plaintext">a = &#x27;ABC&#x27;</code></pre>
<p>时，Python解释器干了两件事情：</p>
<ul>
<li>在内存中创建了一个’ABC’的字符串；</li>
<li>在内存中创建了一个名为a的变量，并把它指向’ABC’。</li>
</ul>
<p>也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：</p>
<pre><code class="highlight python">a = <span class="string">&#x27;ABC&#x27;</span>
b = a
a = <span class="string">&#x27;XYZ&#x27;</span>
<span class="built_in">print</span>(b)   <span class="comment">#ABC</span></code></pre>
<ol>
<li>执行a = ‘ABC’，解释器创建了字符串’ABC’和变量a，并把a指向’ABC’：</li>
<li>执行b = a，解释器创建了变量b，并把b指向a指向的字符串’ABC’：</li>
<li>执行a = ‘XYZ’，解释器创建了字符串’XYZ’，并把a的指向改为’XYZ’，但b并没有更改：</li>
</ol>
<h4 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h4>
<p>所谓<strong>常量就是不能变的变量</strong>，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：</p>
<pre><code class="highlight python">PI = <span class="number">3.14159265329</span></code></pre>
<blockquote>
<p><strong>但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变</strong>，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。</p>
</blockquote>
<h3 id="字符串编码"><a class="markdownIt-Anchor" href="#字符串编码"></a> 字符串/编码</h3>
<p>字符串也是一种数据类型，但是，字符串比较特殊的是还有一个编码问题。</p>
<p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295</p>
<p>由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。</p>
<p>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。</p>
<p>你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。</p>
<p>因此，Unicode字符集应运而生。<strong>Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了</strong>。</p>
<p>Unicode标准也在不断发展，但最常用的是UCS-16编码，用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p>
<p>现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。</p>
<ul>
<li>字母A用ASCII编码是十进制的65，二进制的01000001；</li>
<li>字符0用ASCII编码是十进制的48，二进制的00110000，注意字符’0’和整数0是不同的；</li>
<li>汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。</li>
</ul>
<p>你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。</p>
<p>新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p>
<p>所以，本着节约的精神，又出现了<strong>把Unicode编码转化为“可变长编码”的UTF-8编码</strong>。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>ASCII</th>
<th>Unicode</th>
<th>UTF-8</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>01000001</td>
<td>00000000 01000001</td>
<td>01000001</td>
</tr>
<tr>
<td>中</td>
<td>x</td>
<td>01001110 00101101</td>
<td>11100100 10111000 10101101</td>
</tr>
</tbody>
</table>
<p>从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。</p>
<p>搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：</p>
<ul>
<li><strong>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</strong></li>
</ul>
<p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：</p>
<p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：</p>
<p>所以你看到很多网页的源码上会有类似<meta charset="UTF-8" />的信息，表示该网页正是用的UTF-8编码。</p>
<h4 id="python的字符串"><a class="markdownIt-Anchor" href="#python的字符串"></a> python的字符串</h4>
<p>在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; print(&#x27;包含中文的str&#x27;)
包含中文的str</code></pre>
<p>对于单个字符的编码，Python提供了</p>
<ul>
<li>ord()函数获取字符的整数表示</li>
<li>chr()函数把编码转换为对应的字符</li>
</ul>
<pre><code class="highlight plaintext">&gt;&gt;&gt; ord(&#x27;A&#x27;)
65
&gt;&gt;&gt; ord(&#x27;中&#x27;)
20013
&gt;&gt;&gt; chr(66)
&#x27;B&#x27;
&gt;&gt;&gt; chr(25991)
&#x27;文&#x27;</code></pre>
<p>如果知道字符的整数编码，还可以用十六进制这么写str：</p>
<ul>
<li>两种写法完全是等价的</li>
</ul>
<pre><code class="highlight plaintext">&gt;&gt;&gt; &#x27;\u4e2d\u6587&#x27;
&#x27;中文&#x27;

&gt;&gt;&gt; &#x27;中文&#x27;
&#x27;中文&#x27;</code></pre>
<p>由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。<strong>如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes</strong>。</p>
<hr />
<p><strong>bytes类型</strong></p>
<ul>
<li>Python对<strong>bytes类型的数据用带b前缀的单引号或双引号表示</strong>：</li>
</ul>
<pre><code class="highlight plaintext">x = b&#x27;ABC&#x27;</code></pre>
<blockquote>
<p>注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。</p>
</blockquote>
<p><strong>encode()</strong></p>
<ul>
<li>以Unicode表示的str通过<strong>encode()方法可以编码为指定的bytes</strong>，例如：</li>
</ul>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;ABC&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>)
<span class="string">b&#x27;ABC&#x27;</span>
<span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)
<span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>
<span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>)
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
UnicodeEncodeError: <span class="string">&#x27;ascii&#x27;</span> codec can<span class="string">&#x27;t encode characters in position 0-1: ordinal not in range(128)</span></code></pre>
<blockquote>
<p>纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。</p>
</blockquote>
<blockquote>
<p>在bytes中，无法显示为ASCII字符的字节，用\x##显示。</p>
</blockquote>
<p><strong>decode()</strong></p>
<ul>
<li>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。<strong>要把bytes变为str，就需要用decode()方</strong>法：</li>
</ul>
<pre><code class="highlight plaintext">
&gt;&gt;&gt; b&#x27;ABC&#x27;.decode(&#x27;ascii&#x27;)
&#x27;ABC&#x27;
&gt;&gt;&gt; b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;.decode(&#x27;utf-8&#x27;)
&#x27;中文&#x27;</code></pre>
<ul>
<li>如果bytes中包含无法解码的字节，decode()方法会报错：</li>
</ul>
<pre><code class="highlight plaintext">&gt;&gt;&gt; b&#x27;\xe4\xb8\xad\xff&#x27;.decode(&#x27;utf-8&#x27;)
Traceback (most recent call last):
  ...
UnicodeDecodeError: &#x27;utf-8&#x27; codec can&#x27;t decode byte 0xff in position 3: invalid start byte</code></pre>
<ul>
<li>如果bytes中只有一小部分无效的字节，可以<strong>传入errors='ignore’忽略错误</strong>的字节：</li>
</ul>
<pre><code class="highlight plaintext">&gt;&gt;&gt; b&#x27;\xe4\xb8\xad\xff&#x27;.decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;)
&#x27;中&#x27;</code></pre>
<p><strong>len()</strong></p>
<ul>
<li>要计算str包含多少个字符，可以用len()函数：</li>
</ul>
<pre><code class="highlight plaintext">&gt;&gt;&gt; len(&#x27;ABC&#x27;)
3
&gt;&gt;&gt; len(&#x27;中文&#x27;)
2</code></pre>
<ul>
<li>len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：</li>
</ul>
<pre><code class="highlight plaintext">&gt;&gt;&gt; len(b&#x27;ABC&#x27;)
3
&gt;&gt;&gt; len(b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;)
6
&gt;&gt;&gt; len(&#x27;中文&#x27;.encode(&#x27;utf-8&#x27;))
6</code></pre>
<blockquote>
<p>可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节</p>
</blockquote>
<blockquote>
<p>在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。</p>
</blockquote>
<p>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在<strong>保存源代码时，就需要务必指定保存为UTF-8编码</strong>。当Python解释器<strong>读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行</strong>：</p>
<ul>
<li>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</li>
<li>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</li>
</ul>
<pre><code class="highlight python"><span class="comment">#!/usr/bin/env python3</span>
<span class="comment"># -*- coding: utf-8 -*-</span></code></pre>
<p>申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码：</p>
<p>如果.py文件本身使用UTF-8编码，并且也申明了<code># -*- coding: utf-8 -*-</code>，打开命令提示符测试就可以正常显示中文：</p>
<h4 id="格式化"><a class="markdownIt-Anchor" href="#格式化"></a> 格式化</h4>
<p>我们经常会输出类似’亲爱的xxx你好！你xx月的话费是xx，余额是xx’之类的字符串，而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。</p>
<p>在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; &#x27;Hello, %s&#x27; % &#x27;world&#x27;
&#x27;Hello, world&#x27;

&gt;&gt;&gt; &#x27;Hi, %s, you have $%d.&#x27; % (&#x27;Michael&#x27;, 1000000)
&#x27;Hi, Michael, you have $1000000.&#x27;</code></pre>
<p>你可能猜到了，%<strong>运算符就是用来格式化字符串的</strong>。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。</p>
<table>
<thead>
<tr>
<th>占位符</th>
<th>替换内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>%d</td>
<td>整数</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数</td>
</tr>
<tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%x</td>
<td>十六进制整数</td>
</tr>
</tbody>
</table>
<p>其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：</p>
<pre><code class="highlight python"><span class="comment"># -*- coding: utf-8 -*-</span>
<span class="built_in">print</span>(<span class="string">&#x27;%2d-%02d&#x27;</span> % (<span class="number">3</span>, <span class="number">1</span>))
<span class="built_in">print</span>(<span class="string">&#x27;%.2f&#x27;</span> % <span class="number">3.1415926</span>)

<span class="comment">#输出</span>
 <span class="number">3</span>-01
<span class="number">3.14</span></code></pre>
<p>如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; &#x27;Age: %s. Gender: %s&#x27; % (25, True)
&#x27;Age: 25. Gender: True&#x27;</code></pre>
<p>有些时候，字符串里面的%是一个普通字符怎么办？这个时候就<strong>需要转义，用%%来表示一个%</strong>：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; &#x27;growth rate: %d %%&#x27; % 7
growth rate: 7 %&#x27;</code></pre>
<p><strong>format()</strong></p>
<ul>
<li>另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多：</li>
</ul>
<pre><code class="highlight plaintext">&gt;&gt;&gt; &#x27;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&#x27;.format(&#x27;小明&#x27;, 17.125)
&#x27;Hello, 小明, 成绩提升了 17.1%&#x27;</code></pre>
<p><strong>f-string</strong></p>
<p>最后一种格式化字符串的方法是使用以f开头的字符串，称之为f-string，它和普通字符串不同之处在于，字符串如果包含{xxx}，就会以对应的变量替换：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; r = 2.5
&gt;&gt;&gt; s = 3.14 * r ** 2
&gt;&gt;&gt; print(f&#x27;The area of a circle with radius &#123;r&#125; is &#123;s:.2f&#125;&#x27;)
The area of a circle with radius 2.5 is 19.62</code></pre>
<blockquote>
<p>上述代码中，{r}被变量r的值替换，{s:.2f}被变量s的值替换，并且:后面的.2f指定了格式化参数（即保留两位小数），因此，{s:.2f}的替换结果是19.62。</p>
</blockquote>
<h3 id="使用list和tuple"><a class="markdownIt-Anchor" href="#使用list和tuple"></a> 使用list和tuple</h3>
<h4 id="list"><a class="markdownIt-Anchor" href="#list"></a> list[]</h4>
<p>Python内置的一种数据类型是列表：list。list是一种<strong>有序的集合</strong>，可以随时添加和删除其中的元素。</p>
<p>比如，列出班里所有同学的名字，就可以用一个list表示：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; classmates = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]
&gt;&gt;&gt; classmates
[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</code></pre>
<p>变量classmates就是一个list。用len()函数可以获得list元素的个数：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; len(classmates)
3</code></pre>
<p>用索引来访问list中每一个位置的元素，记得索引是从0开始的：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; classmates[0]
&#x27;Michael&#x27;
&gt;&gt;&gt; classmates[1]
&#x27;Bob&#x27;
&gt;&gt;&gt; classmates[2]
&#x27;Tracy&#x27;
&gt;&gt;&gt; classmates[3]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
IndexError: list index out of range</code></pre>
<p>当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得<strong>最后一个元素的索引是len(classmates) - 1</strong></p>
<p>如果要取最后一个元素，除了计算索引位置外，还可以<strong>用-1做索引，直接获取最后一个元素</strong>：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; classmates[-1]
&#x27;Tracy&#x27;
&gt;&gt;&gt; classmates[-2]
&#x27;Bob&#x27;
&gt;&gt;&gt; classmates[-3]
&#x27;Michael&#x27;
&gt;&gt;&gt; classmates[-4]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
IndexError: list index out of range</code></pre>
<p><strong>list是一个可变的有序表</strong></p>
<ul>
<li>往list中<strong>追加元素到末尾</strong>：</li>
</ul>
<pre><code class="highlight plaintext">&gt;&gt;&gt; classmates.append(&#x27;Adam&#x27;)
&gt;&gt;&gt; classmates
[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;]</code></pre>
<ul>
<li><strong>插入到指定的位置</strong>，比如索引号为1的位置：</li>
</ul>
<pre><code class="highlight plaintext">&gt;&gt;&gt; classmates.insert(1, &#x27;Jack&#x27;)
&gt;&gt;&gt; classmates
[&#x27;Michael&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;]</code></pre>
<ul>
<li>要<strong>删除list末尾的元素</strong>，用pop()方法：</li>
</ul>
<pre><code class="highlight plaintext">&gt;&gt;&gt; classmates.pop()
&#x27;Adam&#x27;
&gt;&gt;&gt; classmates
[&#x27;Michael&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]
</code></pre>
<p>要<strong>删除指定位置的元素</strong>，用pop(i)方法，其中i是索引位置：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; classmates.pop(1)
&#x27;Jack&#x27;
&gt;&gt;&gt; classmates
[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]

#或者
&gt;&gt;&gt; del motorcycles[1]</code></pre>
<p>删除指定名字的元素</p>
<pre><code class="highlight py"><span class="comment">##删除指定元素的首个</span>
motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]
too_expensive = <span class="string">&quot;yamaha&quot;</span>
motorcycles.remove(too_expensive)</code></pre>
<p>要把某个<strong>元素替换成别的元素</strong>，可以直接赋值给对应的索引位置：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; classmates[1] = &#x27;Sarah&#x27;
&gt;&gt;&gt; classmates
[&#x27;Michael&#x27;, &#x27;Sarah&#x27;, &#x27;Tracy&#x27;]</code></pre>
<p>list里面的<strong>元素的数据类型也可以不同</strong>，比如：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; L = [&#x27;Apple&#x27;, 123, True]</code></pre>
<p><strong>排序</strong></p>
<pre><code class="highlight py"><span class="comment">##排序</span>
cars = [<span class="string">&quot;bmw&quot;</span>,<span class="string">&quot;audi&quot;</span>,<span class="string">&quot;toyota&quot;</span>,<span class="string">&quot;subaru&quot;</span>]
cars_copy = cars
<span class="comment">##默认按照字母顺序排序（永久排序）</span>
cars.sort()
<span class="built_in">print</span>(cars)
<span class="comment">##反向排序</span>
cars.sort(reverse=<span class="literal">True</span>)
<span class="built_in">print</span>(cars)
<span class="comment">##临时排序</span>
cars = [<span class="string">&quot;bmw&quot;</span>,<span class="string">&quot;audi&quot;</span>,<span class="string">&quot;toyota&quot;</span>,<span class="string">&quot;subaru&quot;</span>]
<span class="built_in">print</span>(<span class="string">&quot;here is the original list:&quot;</span>)
<span class="built_in">print</span>(cars)
<span class="built_in">print</span>(<span class="string">&quot;here is the sorted list:&quot;</span>)
<span class="built_in">print</span>(<span class="built_in">sorted</span>(cars))
<span class="built_in">print</span>(<span class="built_in">sorted</span>(cars,reverse=<span class="literal">True</span>))
<span class="built_in">print</span>(<span class="string">&quot;here is the original list again:&quot;</span>)
<span class="built_in">print</span>(cars)
<span class="comment">##反转列表</span>
cars = [<span class="string">&quot;bmw&quot;</span>,<span class="string">&quot;audi&quot;</span>,<span class="string">&quot;toyota&quot;</span>,<span class="string">&quot;subaru&quot;</span>]
<span class="built_in">print</span>(cars)
cars.reverse()
<span class="built_in">print</span>(cars)</code></pre>
<p><strong>list元素也可以是另一个list</strong>，比如：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; s = [&#x27;python&#x27;, &#x27;java&#x27;, [&#x27;asp&#x27;, &#x27;php&#x27;], &#x27;scheme&#x27;]
&gt;&gt;&gt; len(s)
4</code></pre>
<p>要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; p = [&#x27;asp&#x27;, &#x27;php&#x27;]
&gt;&gt;&gt; s = [&#x27;python&#x27;, &#x27;java&#x27;, p, &#x27;scheme&#x27;]</code></pre>
<blockquote>
<p>要拿到’php’可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到。</p>
</blockquote>
<p>如果一个list中一个元素也没有，就是一个空的list，它的长度为0：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; L = []
&gt;&gt;&gt; len(L)
0</code></pre>
<p>边循环边删除元素只能用while</p>
<pre><code class="highlight py"><span class="comment">#for循环是一种遍历列表的有效方式，但不应在for 循环中修改列 表，否则将导致Python难以跟踪其中的元素。要在遍历列表的同时 对其进行修改，可使用while 循环。通过将while 循环同列表和字 典结合起来使用，可收集、存储并组织大量输入，供以后查看和显示。</span>
<span class="comment"># 首先，创建一个待验证用户列表</span>
<span class="comment"># 和一个用于存储已验证用户的空列表。</span>
unconfirmed_users = [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;brian&#x27;</span>, <span class="string">&#x27;candace&#x27;</span>]
confirmed_users = []
<span class="keyword">while</span> unconfirmed_users:
    current_user = unconfirmed_users.pop()
    <span class="built_in">print</span>(<span class="string">f&quot;Verifying user:<span class="subst">&#123;current_user.title()&#125;</span>&quot;</span>)
    confirmed_users.append(current_user)

<span class="comment">##循环删除列表元素</span>
pets = [<span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;goldfish&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;rabbit&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>]
<span class="built_in">print</span>(pets)
<span class="keyword">while</span> <span class="string">&#x27;cat&#x27;</span> <span class="keyword">in</span> pets:
    pets.remove(<span class="string">&#x27;cat&#x27;</span>)
<span class="built_in">print</span>(pets)


<span class="comment">##使用用户输入来填充字典</span>
responses = &#123;&#125;
polling_active = <span class="literal">True</span>
<span class="keyword">while</span> polling_active:
    name = <span class="built_in">input</span>(<span class="string">&quot;\nWhat is your name?&quot;</span>)
    response = <span class="built_in">input</span>(<span class="string">&quot;Which mountain would you like to climb someday&quot;</span>)
    <span class="comment"># 将回答存储在字典中</span>
    responses[name] = response
    <span class="comment"># 看看是否还有人要参与调查。</span>
    repeat = <span class="built_in">input</span>(<span class="string">&quot;Would you like to let another person respond? (yes/ no) &quot;</span>)
    <span class="keyword">if</span> repeat == <span class="string">&#x27;no&#x27;</span>:
        polling_active = <span class="literal">False</span></code></pre>
<h4 id="tuple"><a class="markdownIt-Anchor" href="#tuple"></a> tuple()</h4>
<p>另一种有序列表叫元组：tuple。tuple和list非常类似，但是<strong>tuple一旦初始化就不能修改</strong>，比如同样是列出同学的名字：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; classmates = (&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;)</code></pre>
<p>现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。</p>
<p>不可变的tuple有什么意义？<strong>因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple</strong></p>
<p>tuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来，比如：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; t = (1, 2)
&gt;&gt;&gt; t
(1, 2)</code></pre>
<p>如果要定义一个空的tuple，可以写成()：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; t = ()
&gt;&gt;&gt; t
()</code></pre>
<p>但是，要定义一个只有1个元素的tuple，如果你这么定义：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; t = (1)
&gt;&gt;&gt; t
1</code></pre>
<blockquote>
<p>定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。</p>
</blockquote>
<p>所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; t = (1,)
&gt;&gt;&gt; t
(1,)</code></pre>
<p>Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。</p>
<p><strong>可变的tuple</strong>：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; t = (&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;A&#x27;, &#x27;B&#x27;])
&gt;&gt;&gt; t[2][0] = &#x27;X&#x27;
&gt;&gt;&gt; t[2][1] = &#x27;Y&#x27;
&gt;&gt;&gt; t
(&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;X&#x27;, &#x27;Y&#x27;])</code></pre>
<p>这个tuple定义的时候有3个元素，分别是’a’，'b’和一个list。不是说tuple一旦定义后就不可变了吗？怎么后来又变了？</p>
<p>当我们把list的元素’A’和’B’修改为’X’和’Y’后，tuple变为：</p>
<p>表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！</p>
<h3 id="条件判断"><a class="markdownIt-Anchor" href="#条件判断"></a> 条件判断</h3>
<p>计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。</p>
<p>比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，用if语句实现：</p>
<pre><code class="highlight python">age = <span class="number">20</span>
<span class="keyword">if</span> age &gt;= <span class="number">18</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;your age is&#x27;</span>, age)
    <span class="built_in">print</span>(<span class="string">&#x27;adult&#x27;</span>)</code></pre>
<blockquote>
<p>根据Python的缩进规则，如果if语句判断是True，就把缩进的两行print语句执行了，否则，什么也不做</p>
</blockquote>
<p>也可以给if添加一个else语句，意思是，如果if判断是False，不要执行if的内容，去把else执行了：</p>
<ul>
<li><strong>注意不要少写了冒号</strong></li>
</ul>
<pre><code class="highlight python">age = <span class="number">3</span>
<span class="keyword">if</span> age &gt;= <span class="number">18</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;your age is&#x27;</span>, age)
    <span class="built_in">print</span>(<span class="string">&#x27;adult&#x27;</span>)
<span class="keyword">else</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;your age is&#x27;</span>, age)
    <span class="built_in">print</span>(<span class="string">&#x27;teenager&#x27;</span>)</code></pre>
<p>elif是else if的缩写，完全可以有多个elif，所以if语句的完整形式就是：</p>
<pre><code class="highlight plaintext">if &lt;条件判断1&gt;:
    &lt;执行1&gt;
elif &lt;条件判断2&gt;:
    &lt;执行2&gt;
elif &lt;条件判断3&gt;:
    &lt;执行3&gt;
else:
    &lt;执行4&gt;</code></pre>
<p>if语句执行有个特点，它是从上往下判断，如果在<strong>某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else</strong>，所以，请测试并解释为什么下面的程序打印的是teenager：</p>
<pre><code class="highlight python">age = <span class="number">20</span>
<span class="keyword">if</span> age &gt;= <span class="number">6</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;teenager&#x27;</span>)
<span class="keyword">elif</span> age &gt;= <span class="number">18</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;adult&#x27;</span>)
<span class="keyword">else</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;kid&#x27;</span>)</code></pre>
<p>if判断条件还可以简写，比如写：</p>
<ul>
<li>只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。</li>
</ul>
<pre><code class="highlight python"><span class="keyword">if</span> x:
    <span class="built_in">print</span>(<span class="string">&#x27;True&#x27;</span>)</code></pre>
<blockquote>
<p><strong>如果if条件中是一个list，则列表至少包含一个元素时返回True ，并在列表为空时返回False</strong></p>
</blockquote>
<p>多条件的if：</p>
<pre><code class="highlight py"><span class="comment">##多个条件比较and/or</span>
age = <span class="number">50</span>
<span class="keyword">if</span> (age&gt;=<span class="number">18</span>) <span class="keyword">and</span> (age&lt;=<span class="number">30</span>):
    <span class="built_in">print</span>(<span class="string">&quot;young people!&quot;</span>)
<span class="keyword">elif</span> (age&lt;<span class="number">19</span>) <span class="keyword">or</span> (age&gt;<span class="number">30</span>):
    <span class="built_in">print</span>(<span class="string">&quot;no young people!&quot;</span>)</code></pre>
<p><strong>字符串比较</strong></p>
<pre><code class="highlight py">alien = <span class="string">&quot;yellow&quot;</span>
<span class="keyword">if</span> alien == <span class="string">&#x27;green&#x27;</span>:
    points = <span class="number">5</span>
<span class="keyword">elif</span> alien == <span class="string">&#x27;yellow&#x27;</span>:
    points = <span class="number">10</span>
<span class="keyword">else</span>:
    points = <span class="number">15</span>
<span class="built_in">print</span>(<span class="string">f&quot;Players scored <span class="subst">&#123;points&#125;</span> points!&quot;</span>)</code></pre>
<p><strong>in关键字</strong></p>
<pre><code class="highlight py"><span class="comment">##in包含关键字</span>
requested_toppings = [<span class="string">&#x27;mushrooms&#x27;</span>,<span class="string">&#x27;onions&#x27;</span>,<span class="string">&#x27;pineapple&#x27;</span>]
<span class="keyword">if</span> <span class="string">&#x27;mushrooms&#x27;</span> <span class="keyword">in</span> requested_toppings:
    <span class="built_in">print</span>(<span class="string">f&quot;requested_toppings contain mushrooms!&quot;</span>)
<span class="keyword">else</span>:
    <span class="built_in">print</span>(<span class="string">f&quot;requested_toppings no contain mushrooms!&quot;</span>)
<span class="comment">##不包含</span>
<span class="keyword">if</span> <span class="string">&#x27;mushrooms&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> requested_toppings:
    <span class="built_in">print</span>(<span class="string">f&quot;requested_toppings no contain mushrooms!&quot;</span>)
<span class="keyword">else</span>:
    <span class="built_in">print</span>(<span class="string">f&quot;requested_toppings contain mushrooms!&quot;</span>)</code></pre>
<hr />
<p><strong>再议input</strong></p>
<p>最后看一个有问题的条件判断。很多同学会用input()读取用户的输入，这样可以自己输入，程序运行得更有意思：</p>
<pre><code class="highlight plaintext">birth = input(&#x27;birth: &#x27;)
if birth &lt; 2000:
    print(&#x27;00前&#x27;)
else:
    print(&#x27;00后&#x27;)</code></pre>
<p>输入1982，结果报错：</p>
<pre><code class="highlight plaintext">Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unorderable types: str() &gt; int()</code></pre>
<p>这是<strong>因为input()返回的数据类型是str，str不能直接和整数比较</strong>，必须先把str转换成整数。Python提供了int()函数来完成这件事情：</p>
<pre><code class="highlight python">s = <span class="built_in">input</span>(<span class="string">&#x27;birth: &#x27;</span>)
birth = <span class="built_in">int</span>(s)
<span class="keyword">if</span> birth &lt; <span class="number">2000</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;00前&#x27;</span>)
<span class="keyword">else</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;00后&#x27;</span>)</code></pre>
<p>再次运行，就可以得到正确地结果。但是，如果输入abc呢？又会得到一个错误信息：</p>
<pre><code class="highlight plaintext">Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ValueError: invalid literal for int() with base 10: &#x27;abc&#x27;</code></pre>
<p>原来int()函数发现一个字符串并不是合法的数字时就会报错，程序就退出了。</p>
<h3 id="循环"><a class="markdownIt-Anchor" href="#循环"></a> 循环</h3>
<h4 id="for"><a class="markdownIt-Anchor" href="#for"></a> for</h4>
<p>Python的循环有两种，一种是for…in循环，依次把list或tuple中的每个元素迭代出来</p>
<pre><code class="highlight python">names = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]
<span class="keyword">for</span> name <span class="keyword">in</span> names:
    <span class="built_in">print</span>(name)</code></pre>
<blockquote>
<p>所以for x in …循环就是把每个元素代入变量x，然后执行缩进块的语句。</p>
</blockquote>
<p>再比如我们想计算1-10的整数之和，可以用一个sum变量做累加：</p>
<pre><code class="highlight python"><span class="built_in">sum</span> = <span class="number">0</span>
<span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]:
    <span class="built_in">sum</span> = <span class="built_in">sum</span> + x
<span class="built_in">print</span>(<span class="built_in">sum</span>)</code></pre>
<p><strong>range()</strong></p>
<ul>
<li>如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数：</li>
</ul>
<pre><code class="highlight py"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>))
[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]

<span class="comment">##range函数可以生成数字</span>
<span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):
    <span class="built_in">print</span>(value)
<span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):
    <span class="built_in">print</span>(value)
numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>))
<span class="built_in">print</span>(numbers)
<span class="comment">##第三个参数是步长的意思</span>
even_numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2</span>,<span class="number">11</span>,<span class="number">2</span>))
<span class="built_in">print</span>(even_numbers)

<span class="comment">##列表解析</span>
squares = [value**<span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)]
<span class="built_in">print</span>(squares)</code></pre>
<p>range(101)就可以生成0-100的整数序列，计算如下：</p>
<pre><code class="highlight python"><span class="comment"># -*- coding: utf-8 -*-</span>
<span class="built_in">sum</span> = <span class="number">0</span>
<span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>):
    <span class="built_in">sum</span> = <span class="built_in">sum</span> + x
<span class="built_in">print</span>(<span class="built_in">sum</span>)</code></pre>
<h4 id="while"><a class="markdownIt-Anchor" href="#while"></a> while</h4>
<p>第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：</p>
<pre><code class="highlight plaintext">sum = 0
n = 99
while n &gt; 0:
    sum = sum + n
    n = n - 2
print(sum)</code></pre>
<blockquote>
<p>在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出</p>
</blockquote>
<h4 id="break"><a class="markdownIt-Anchor" href="#break"></a> break</h4>
<p>如果要<strong>提前结束循环</strong>，可以用break语句：</p>
<pre><code class="highlight python">n = <span class="number">1</span>
<span class="keyword">while</span> n &lt;= <span class="number">100</span>:
    <span class="keyword">if</span> n &gt; <span class="number">10</span>: <span class="comment"># 当n = 11时，条件满足，执行break语句</span>
        <span class="keyword">break</span> <span class="comment"># break语句会结束当前循环</span>
    <span class="built_in">print</span>(n)
    n = n + <span class="number">1</span>
<span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</code></pre>
<blockquote>
<p>执行上面的代码可以看到，打印出1~10后，紧接着打印END，程序结束</p>
</blockquote>
<h4 id="continue"><a class="markdownIt-Anchor" href="#continue"></a> continue</h4>
<p>在循环过程中，也可以通过continue语句，<strong>跳过当前的这次循环</strong>，直接开始下一次循环。</p>
<pre><code class="highlight python">n = <span class="number">0</span>
<span class="keyword">while</span> n &lt; <span class="number">10</span>:
    n = n + <span class="number">1</span>
    <span class="built_in">print</span>(n)</code></pre>
<p>上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用continue语句跳过某些循环：</p>
<pre><code class="highlight python">n = <span class="number">0</span><span class="keyword">while</span> n &lt; <span class="number">10</span>:
    n = n + <span class="number">1</span>
    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>: <span class="comment"># 如果n是偶数，执行continue语句</span>
        <span class="keyword">continue</span> <span class="comment"># continue语句会直接继续下一轮循环，后续的print()语句不会执行</span>
    <span class="built_in">print</span>(n)</code></pre>
<blockquote>
<p>执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9</p>
</blockquote>
<h3 id="使用dict和set"><a class="markdownIt-Anchor" href="#使用dict和set"></a> 使用dict和set</h3>
<h4 id="dict"><a class="markdownIt-Anchor" href="#dict"></a> dict{}</h4>
<p>和list比较，dict有以下几个特点：</p>
<ul>
<li>查找和插入的速度极快，不会随着key的增加而变慢；</li>
<li>需要占用大量的内存，内存浪费多。</li>
</ul>
<p>而list相反：</p>
<ul>
<li>查找和插入的时间随着元素的增加而增加；</li>
<li>占用空间小，浪费内存很少。</li>
</ul>
<blockquote>
<p>所以，dict是用空间来换取时间的一种方法。</p>
</blockquote>
<p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用<strong>键-值（key-value）存储，具有极快的查找速度</strong>。</p>
<p>举个例子，假设要根据同学的名字查找对应的成绩，如果用list实现，需要两个list：</p>
<pre><code class="highlight python">names = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]
scores = [<span class="number">95</span>, <span class="number">75</span>, <span class="number">85</span>]</code></pre>
<p>给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，list越长，耗时越长。</p>
<p>如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;Michael&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;Bob&#x27;</span>: <span class="number">75</span>, <span class="string">&#x27;Tracy&#x27;</span>: <span class="number">85</span>&#125;
<span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Michael&#x27;</span>]
<span class="number">95</span></code></pre>
<p>为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。</p>
<p>第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。</p>
<p>dict就是第二种实现方式，给定一个名字，比如’Michael’，dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。</p>
<p>你可以猜到，<strong>这种key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value</strong>。</p>
<p>把<strong>数据放入dict</strong>的方法，除了初始化时指定外，还可以通过key放入：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Adam&#x27;</span>] = <span class="number">67</span>
<span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Adam&#x27;</span>]
<span class="number">67</span></code></pre>
<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Jack&#x27;</span>] = <span class="number">90</span>
<span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Jack&#x27;</span>]
<span class="number">90</span>
<span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Jack&#x27;</span>] = <span class="number">88</span>
<span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Jack&#x27;</span>]
<span class="number">88</span></code></pre>
<p>如果key不存在，dict就会报错：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Thomas&#x27;</span>]
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
KeyError: <span class="string">&#x27;Thomas&#x27;</span></code></pre>
<p><strong>要避免key不存在的错误</strong>，有两种办法</p>
<ul>
<li>一是通过in判断key是否存在：</li>
</ul>
<pre><code class="highlight plaintext">&gt;&gt;&gt; &#x27;Thomas&#x27; in d
False</code></pre>
<ul>
<li>二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：</li>
</ul>
<pre><code class="highlight plaintext">&gt;&gt;&gt; d.get(&#x27;Thomas&#x27;)
&gt;&gt;&gt; d.get(&#x27;Thomas&#x27;, -1)
-1</code></pre>
<blockquote>
<p>注意：返回None的时候Python的交互环境不显示结果</p>
</blockquote>
<p><strong>要删除一个key</strong>，用pop(key)方法，对应的value也会从dict中删除：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>d.pop(<span class="string">&#x27;Bob&#x27;</span>)
<span class="number">75</span>
<span class="meta">&gt;&gt;&gt; </span>d
&#123;<span class="string">&#x27;Michael&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;Tracy&#x27;</span>: <span class="number">85</span>&#125;</code></pre>
<blockquote>
<p>请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。</p>
</blockquote>
<p>dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条<strong>就是dict的key必须是不可变对象</strong>。</p>
<p>这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。</p>
<p>要保证hash的正确性，作为key的对象就不能变。在Python中，<strong>字符串、整数等都是不可变的</strong>，因此，可以放心地作为key。而list是可变的，就不能作为key：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>key = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]
<span class="meta">&gt;&gt;&gt; </span>d[key] = <span class="string">&#x27;a list&#x27;</span>
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></code></pre>
<p>基本操作</p>
<pre><code class="highlight py"><span class="comment">#dict字典，相当于map</span>
<span class="comment">#6.1一个简单的字典</span>
alien = &#123;<span class="string">&#x27;color&#x27;</span>:<span class="string">&#x27;green&#x27;</span>,<span class="string">&#x27;points&#x27;</span>:<span class="number">5</span>&#125;
<span class="built_in">print</span>(alien[<span class="string">&#x27;color&#x27;</span>])
<span class="built_in">print</span>(alien[<span class="string">&#x27;points&#x27;</span>])

<span class="comment">#6.2使用字典，字典用&#123;&#125;表示</span>
<span class="comment">##字典 是一系列键值对 。每个键 都与一个值相关联， 你可使用键来访问相关联的值。与键相关联的值可以是数、字符 串、列表乃至字典。</span>
alien = &#123;<span class="string">&#x27;color&#x27;</span>:<span class="string">&#x27;green&#x27;</span>,<span class="string">&#x27;points&#x27;</span>:<span class="number">5</span>&#125;
new_points = alien[<span class="string">&#x27;points&#x27;</span>]
<span class="built_in">print</span>(<span class="string">f&quot;You just earned <span class="subst">&#123;new_points&#125;</span> points!&quot;</span>)

<span class="comment">##添加</span>
<span class="built_in">print</span>(alien)
alien[<span class="string">&#x27;x_position&#x27;</span>] = <span class="number">0</span>
alien[<span class="string">&#x27;y_position&#x27;</span>] = <span class="number">25</span>
<span class="built_in">print</span>(alien)

<span class="comment">##创建一个空字典</span>
alien = &#123;&#125;
alien[<span class="string">&#x27;color&#x27;</span>] = <span class="string">&#x27;green&#x27;</span>
alien[<span class="string">&#x27;points&#x27;</span>] = <span class="number">5</span>
<span class="built_in">print</span>(alien)

<span class="comment">##修改</span>
alien = &#123;<span class="string">&#x27;color&#x27;</span>:<span class="string">&#x27;green&#x27;</span>&#125;
<span class="built_in">print</span>(<span class="string">f&quot;The alien is <span class="subst">&#123;alien[<span class="string">&#x27;color&#x27;</span>]&#125;</span>.&quot;</span>)
alien[<span class="string">&#x27;color&#x27;</span>] = <span class="string">&#x27;yellow&#x27;</span>
<span class="built_in">print</span>(<span class="string">f&quot;The alien is now <span class="subst">&#123;alien[<span class="string">&#x27;color&#x27;</span>]&#125;</span>.&quot;</span>)

<span class="comment">##删除(注意，删除的键会永远消失)</span>
alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>:<span class="string">&#x27;green&#x27;</span>,<span class="string">&#x27;points&#x27;</span>:<span class="number">5</span>&#125;
<span class="built_in">print</span>(alien_0)

<span class="keyword">del</span> alien_0[<span class="string">&#x27;points&#x27;</span>]
<span class="built_in">print</span>(alien_0)</code></pre>
<p>遍历dict</p>
<pre><code class="highlight py">user_0 = &#123;
    <span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;dfermi&#x27;</span>,
    <span class="string">&#x27;first&#x27;</span>:<span class="string">&#x27;enrico&#x27;</span>,
    <span class="string">&#x27;last&#x27;</span>:<span class="string">&#x27;fermi&#x27;</span>,
&#125;

<span class="keyword">for</span> key,value <span class="keyword">in</span> user_0.items():
    <span class="built_in">print</span>(<span class="string">f&quot;key:<span class="subst">&#123;key&#125;</span>&quot;</span>)
    <span class="built_in">print</span>(<span class="string">f&quot;value:<span class="subst">&#123;value&#125;</span>&quot;</span>)
    
favorite_languages = &#123;
    <span class="string">&#x27;jen&#x27;</span>:<span class="string">&#x27;python&#x27;</span>,
    <span class="string">&#x27;sarah&#x27;</span>:<span class="string">&#x27;c&#x27;</span>,
    <span class="string">&#x27;edward&#x27;</span>:<span class="string">&#x27;ruby&#x27;</span>,
    <span class="string">&#x27;phil&#x27;</span>:<span class="string">&#x27;python&#x27;</span>,
&#125;

<span class="keyword">for</span> name,language <span class="keyword">in</span> favorite_languages.items():
    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name.title()&#125;</span>&#x27;s favorite language is <span class="subst">&#123;language.title()&#125;</span>&quot;</span>)
<span class="keyword">for</span> name <span class="keyword">in</span> favorite_languages.keys():
    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name.title()&#125;</span>&quot;</span>)

<span class="keyword">if</span> <span class="string">&#x27;erin&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> favorite_languages.keys():
    <span class="built_in">print</span>(<span class="string">&quot;Erin, please take our poll!&quot;</span>)

<span class="comment">##排序显示</span>
<span class="keyword">for</span> name <span class="keyword">in</span> <span class="built_in">sorted</span>(favorite_languages.keys()):
    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name.title()&#125;</span> thank youe for taking the poll.&quot;</span>)

<span class="comment">##遍历值</span>
<span class="keyword">for</span> language <span class="keyword">in</span> favorite_languages.values():
    <span class="built_in">print</span>(language.title())
<span class="built_in">print</span>(<span class="string">&quot;(\n&quot;</span>)
<span class="comment">##遍历值时去重</span>
<span class="keyword">for</span> only_language <span class="keyword">in</span> <span class="built_in">set</span>(favorite_languages.values()):
    <span class="built_in">print</span>(only_language.title())
    

<span class="comment">##字典中存储列表</span>
pizza = &#123;
    <span class="string">&#x27;crust&#x27;</span>:<span class="string">&#x27;thick&#x27;</span>,
    <span class="string">&#x27;toppings&#x27;</span>:[<span class="string">&#x27;mushrooms&#x27;</span>,<span class="string">&#x27;extra cheese&#x27;</span>]
&#125;
<span class="built_in">print</span>(<span class="string">f&quot;You ordered a <span class="subst">&#123;pizza[<span class="string">&#x27;crust&#x27;</span>]&#125;</span>-crust pizza&quot;</span>
<span class="string">&quot;with the following toppings:&quot;</span>)
<span class="keyword">for</span> topping <span class="keyword">in</span> pizza[<span class="string">&#x27;toppings&#x27;</span>]:
    <span class="built_in">print</span>(<span class="string">f&quot;\t<span class="subst">&#123;topping&#125;</span>&quot;</span>)
favorite_languages = &#123;
    <span class="string">&#x27;jen&#x27;</span>: [<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;ruby&#x27;</span>],
    <span class="string">&#x27;sarah&#x27;</span>: [<span class="string">&#x27;c&#x27;</span>],
    <span class="string">&#x27;edward&#x27;</span>: [<span class="string">&#x27;ruby&#x27;</span>, <span class="string">&#x27;go&#x27;</span>],
    <span class="string">&#x27;phil&#x27;</span>: [<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;haskell&#x27;</span>],
    &#125;
<span class="keyword">for</span> name,languages <span class="keyword">in</span> favorite_languages.items():
    <span class="keyword">if</span> <span class="built_in">len</span>(languages) &gt; <span class="number">1</span>:
        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name.title()&#125;</span>&#x27;s favorite languages are:&quot;</span>)
        <span class="keyword">for</span> language <span class="keyword">in</span> languages:
            <span class="built_in">print</span>(<span class="string">f&quot;\t<span class="subst">&#123;language.title()&#125;</span>&quot;</span>)
    <span class="keyword">else</span>:
        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name.title()&#125;</span>&#x27;s favorite languages is <span class="subst">&#123;languages[<span class="number">0</span>].title()&#125;</span>&quot;</span>)
        
        
<span class="comment">##字典中嵌套字典</span>
users = &#123;
    <span class="string">&#x27;aeinstein&#x27;</span>:&#123;
        <span class="string">&#x27;first&#x27;</span>:<span class="string">&#x27;albert&#x27;</span>,
        <span class="string">&#x27;last&#x27;</span>:<span class="string">&#x27;einstein&#x27;</span>,
        <span class="string">&#x27;location&#x27;</span>: <span class="string">&#x27;princeton&#x27;</span>,
        &#125;,
    <span class="string">&#x27;mcurie&#x27;</span>: &#123;
        <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;marie&#x27;</span>,
        <span class="string">&#x27;last&#x27;</span>: <span class="string">&#x27;curie&#x27;</span>,
        <span class="string">&#x27;location&#x27;</span>: <span class="string">&#x27;paris&#x27;</span>,
        &#125;,
    &#125;
<span class="keyword">for</span> username,userinfo <span class="keyword">in</span> users.items():
    <span class="built_in">print</span>(<span class="string">f&quot;Username:<span class="subst">&#123;username.title()&#125;</span>&quot;</span>)
    full_name = <span class="string">f&quot;<span class="subst">&#123;userinfo[<span class="string">&#x27;first&#x27;</span>]&#125;</span> <span class="subst">&#123;userinfo[<span class="string">&#x27;last&#x27;</span>]&#125;</span>&quot;</span>
    location = userinfo[<span class="string">&#x27;location&#x27;</span>]
    <span class="built_in">print</span>(<span class="string">f&quot;\tfull_name:<span class="subst">&#123;full_name.title()&#125;</span>&quot;</span>)
    <span class="built_in">print</span>(<span class="string">f&quot;\tlocation:<span class="subst">&#123;location.title()&#125;</span>&quot;</span>)</code></pre>
<h4 id="set"><a class="markdownIt-Anchor" href="#set"></a> set([])</h4>
<p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p>
<p>要创建一个set，需要提供一个list作为输入集合：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])
<span class="meta">&gt;&gt;&gt; </span>s
&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</code></pre>
<blockquote>
<p>注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。</p>
</blockquote>
<p><strong>重复元素在set中自动被过滤</strong>：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])
<span class="meta">&gt;&gt;&gt; </span>s
&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</code></pre>
<p><strong>通过add(key)方法可以添加元素到set中</strong>，可以重复添加，但不会有效果：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)
<span class="meta">&gt;&gt;&gt; </span>s
&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;
<span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)
<span class="meta">&gt;&gt;&gt; </span>s
&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</code></pre>
<p><strong>通过remove(key)方法可以删除元</strong>素：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="number">4</span>)
<span class="meta">&gt;&gt;&gt; </span>s
&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</code></pre>
<p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的<strong>交集、并集</strong>等操作：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])
<span class="meta">&gt;&gt;&gt; </span>s2 = <span class="built_in">set</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])
<span class="meta">&gt;&gt;&gt; </span>s1 &amp; s2
&#123;<span class="number">2</span>, <span class="number">3</span>&#125;
<span class="meta">&gt;&gt;&gt; </span>s1 | s2
&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</code></pre>
<blockquote>
<p>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。</p>
</blockquote>
<h4 id="再议不可变对象"><a class="markdownIt-Anchor" href="#再议不可变对象"></a> 再议不可变对象</h4>
<p>上面我们讲了，str是不变对象，而list是可变对象。</p>
<p>对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]
<span class="meta">&gt;&gt;&gt; </span>a.sort()
<span class="meta">&gt;&gt;&gt; </span>a
[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</code></pre>
<p>而对于不可变对象，比如str，对str进行操作呢：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&#x27;abc&#x27;</span>
<span class="meta">&gt;&gt;&gt; </span>a.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)
<span class="string">&#x27;Abc&#x27;</span>
<span class="meta">&gt;&gt;&gt; </span>a
<span class="string">&#x27;abc&#x27;</span></code></pre>
<p>虽然字符串有个replace()方法，也确实变出了’Abc’，但变量a最后仍是’abc’，应该怎么理解呢？</p>
<p>我们先把代码改成下面这样：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&#x27;abc&#x27;</span>
<span class="meta">&gt;&gt;&gt; </span>b = a.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)
<span class="meta">&gt;&gt;&gt; </span>b
<span class="string">&#x27;Abc&#x27;</span>
<span class="meta">&gt;&gt;&gt; </span>a
<span class="string">&#x27;abc&#x27;</span></code></pre>
<p>要始终牢记的是，a是变量，而’abc’才是字符串对象！有些时候，我们经常说，对象a的内容是’abc’，但其实是指，a本身是一个变量，它指向的对象的内容才是’abc’：</p>
<p>当我们调用a.replace(‘a’, ‘A’)时，实际上调用方法replace是作用在字符串对象’abc’上的，而这个方法虽然名字叫replace，但却没有改变字符串’abc’的内容。相反，replace方法创建了一个新字符串’Abc’并返回，如果我们用变量b指向该新字符串，就容易理解了，变量a仍指向原有的字符串’abc’，但变量b却指向新字符串’Abc’了：</p>
<p>所以，<strong>对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的</strong>。</p>
<h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2>
<p>我们知道圆的面积计算公式为：<br />
S = πr2</p>
<p>当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：</p>
<pre><code class="highlight python">r1 = <span class="number">12.34</span>
r2 = <span class="number">9.08</span>
r3 = <span class="number">73.1</span>
s1 = <span class="number">3.14</span> * r1 * r1
s2 = <span class="number">3.14</span> * r2 * r2
s3 = <span class="number">3.14</span> * r3 * r3</code></pre>
<p>当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 * x * x不仅很麻烦，而且，如果要把3.14改成3.14159265359的时候，得全部替换。</p>
<p>有了函数，我们就不再每次写s = 3.14 * x * x，而是写成更有意义的函数调用s = area_of_circle(x)，而函数area_of_circle本身只需要写一次，就可以多次调用。</p>
<p>基本上所有的高级语言都支持函数，Python也不例外。Python不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。</p>
<p><strong>抽象</strong></p>
<p>抽象是数学中非常常见的概念。举个例子：</p>
<p>计算数列的和，比如：1 + 2 + 3 + … + 100，写起来十分不方便，于是数学家发明了求和符号∑，可以把1 + 2 + 3 + … + 100记作：</p>
<p>这种抽象记法非常强大，因为我们看到 ∑ 就可以理解成求和，而不是还原成低级的加法运算。而且，这种抽象记法是可扩展的，比如：</p>
<p>还原成加法运算就变成了：</p>
<p>(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + … + (100 x 100 + 1)</p>
<p>可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。</p>
<p>写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。</p>
<h3 id="调用函数"><a class="markdownIt-Anchor" href="#调用函数"></a> 调用函数</h3>
<p>Python内置了很多有用的函数，我们可以直接调用。</p>
<p>要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数abs，只有一个参数。可以直接从Python的官方网站查看文档：</p>
<p><a target="_blank" rel="noopener" href="http://docs.python.org/3/library/functions.html#abs">http://docs.python.org/3/library/functions.html#abs</a></p>
<p>也可以在交互式命令行通过help(abs)查看abs函数的帮助信息。</p>
<p>调用abs函数：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(<span class="number">100</span>)
<span class="number">100</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(-<span class="number">20</span>)
<span class="number">20</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(<span class="number">12.34</span>)
<span class="number">12.34</span></code></pre>
<p>调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(<span class="number">1</span>, <span class="number">2</span>)
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
TypeError: <span class="built_in">abs</span>() takes exactly one argument (<span class="number">2</span> given)</code></pre>
<p>如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(<span class="string">&#x27;a&#x27;</span>)
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
TypeError: bad operand <span class="built_in">type</span> <span class="keyword">for</span> <span class="built_in">abs</span>(): <span class="string">&#x27;str&#x27;</span></code></pre>
<p>而max函数max()可以接收任意多个参数，并返回最大的那个：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(<span class="number">1</span>, <span class="number">2</span>)
<span class="number">2</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, -<span class="number">5</span>)
<span class="number">3</span></code></pre>
<h4 id="数据类型转换"><a class="markdownIt-Anchor" href="#数据类型转换"></a> 数据类型转换</h4>
<p>Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;123&#x27;</span>)
<span class="number">123</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="number">12.34</span>)
<span class="number">12</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">float</span>(<span class="string">&#x27;12.34&#x27;</span>)
<span class="number">12.34</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(<span class="number">1.23</span>)
<span class="string">&#x27;1.23&#x27;</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(<span class="number">100</span>)
<span class="string">&#x27;100&#x27;</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="number">1</span>)
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="string">&#x27;&#x27;</span>)
<span class="literal">False</span></code></pre>
<p><strong>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量</strong>，相当于给这个函数起了一个“别名”：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">abs</span> <span class="comment"># 变量a指向abs函数</span>
<span class="meta">&gt;&gt;&gt; </span>a(-<span class="number">1</span>) <span class="comment"># 所以也可以通过a调用abs函数</span>
<span class="number">1</span></code></pre>
<h3 id="定义函数"><a class="markdownIt-Anchor" href="#定义函数"></a> 定义函数</h3>
<p>在Python中，<strong>定义一个函数要使用def语句</strong>，依次写出<strong>函数名、括号、括号中的参数和冒号</strong>:，然后，<strong>在缩进块中编写函数体，函数的返回值用return语句返回</strong>。</p>
<p>我们以自定义一个求绝对值的my_abs函数为例：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">my_abs</span>(<span class="params">x</span>):
    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:
        <span class="keyword">return</span> x
    <span class="keyword">else</span>:
        <span class="keyword">return</span> -x</code></pre>
<blockquote>
<p>请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。</p>
</blockquote>
<p>如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。return None可以简写为return。</p>
<p>在Python交互环境中定义函数时，注意Python会出现…的提示。函数定义结束后需要按两次回车重新回到&gt;&gt;&gt;提示符下：</p>
<h4 id="导入文件函数"><a class="markdownIt-Anchor" href="#导入文件函数"></a> 导入文件/函数</h4>
<p>如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用<strong>from abstest import my_abs来导入my_abs()函数</strong>，注意abstest是文件名（不含.py扩展名）：</p>
<h4 id="空函数"><a class="markdownIt-Anchor" href="#空函数"></a> 空函数</h4>
<p>如果想定义一个什么事也不做的空函数，可以用pass语句：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">nop</span>():
    <span class="keyword">pass</span></code></pre>
<p>pass语句什么都不做，那有什么用？实际上<strong>pass可以用来作为占位符</strong>，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。pass还可以用在其他语句里，比如：</p>
<pre><code class="highlight python"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</code></pre>
<blockquote>
<p>pass缺少了pass，代码运行就会有语法错误。</p>
</blockquote>
<h4 id="参数检查"><a class="markdownIt-Anchor" href="#参数检查"></a> 参数检查</h4>
<p>调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>my_abs(<span class="number">1</span>, <span class="number">2</span>)
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
TypeError: my_abs() takes <span class="number">1</span> positional argument but <span class="number">2</span> were given</code></pre>
<p>但是如果参数类型不对，Python解释器就无法帮我们检查。试试my_abs和内置函数abs的差别：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>my_abs(<span class="string">&#x27;A&#x27;</span>)
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> my_abs
TypeError: unorderable types: <span class="built_in">str</span>() &gt;= <span class="built_in">int</span>()
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(<span class="string">&#x27;A&#x27;</span>)
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
TypeError: bad operand <span class="built_in">type</span> <span class="keyword">for</span> <span class="built_in">abs</span>(): <span class="string">&#x27;str&#x27;</span></code></pre>
<p>当传入了不恰当的参数时，内置函数abs会检查出参数错误，而我们定义的my_abs没有参数检查，会导致if语句出错，出错信息和abs不一样。所以，这个函数定义不够完善。</p>
<p>让我们修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。<strong>数据类型检查可以用内置函数isinstance()实现</strong>：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">my_abs</span>(<span class="params">x</span>):
    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(x, (<span class="built_in">int</span>, <span class="built_in">float</span>)):
        <span class="keyword">raise</span> TypeError(<span class="string">&#x27;bad operand type&#x27;</span>)
    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:
        <span class="keyword">return</span> x
    <span class="keyword">else</span>:
        <span class="keyword">return</span> -x</code></pre>
<p>添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>my_abs(<span class="string">&#x27;A&#x27;</span>)
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> my_abs
TypeError: bad operand <span class="built_in">type</span></code></pre>
<h4 id="返回多个值"><a class="markdownIt-Anchor" href="#返回多个值"></a> 返回多个值</h4>
<p>python是允许返回多个值的。</p>
<p>比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：</p>
<pre><code class="highlight python"><span class="keyword">import</span> math

<span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">x, y, step, angle=<span class="number">0</span></span>):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    <span class="keyword">return</span> nx, ny</code></pre>
<p><strong>import math语句表示导入math包，并允许后续代码引用math包里的sin、cos等函数</strong>。</p>
<p>然后，我们就可以同时获得返回值：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>x, y = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(x, y)
<span class="number">151.96152422706632</span> <span class="number">70.0</span></code></pre>
<p>但其实这只是一种假象，Python<strong>函数返回的仍然是单一值</strong>：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>r = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(r)
(<span class="number">151.96152422706632</span>, <span class="number">70.0</span>)</code></pre>
<p>原来返回值是一个<strong>tuple</strong>！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p>
<h3 id="函数的参数"><a class="markdownIt-Anchor" href="#函数的参数"></a> 函数的参数</h3>
<p>定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。</p>
<p>Python的函数定义非常简单，但灵活度却非常大。<strong>除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数</strong>，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。</p>
<h4 id="位置参数"><a class="markdownIt-Anchor" href="#位置参数"></a> 位置参数</h4>
<p>调用函数时，Python必须将函数调用中的每个实参都关联到函数定义中的一个形参。为此，最简单的关联方式是基于实参的顺序。这种关联方式称为位置实参。</p>
<p>我们先写一个计算x2的函数：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x</span>):
    <span class="keyword">return</span> x * x;</code></pre>
<p>对于power(x)函数，参数x就是一个位置参数。当我们调用power函数时，必须传入有且仅有的一个参数x：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>power(<span class="number">5</span>)
<span class="number">25</span>
<span class="meta">&gt;&gt;&gt; </span>power(<span class="number">15</span>)
<span class="number">225</span></code></pre>
<p>或者我们可以增加一个参数来计算x^n</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x ,n</span>):
    s = <span class="number">1</span>
    <span class="keyword">while</span> n &gt; <span class="number">0</span>:
        n = n - <span class="number">1</span>
        s = s * x
    <span class="keyword">return</span> s</code></pre>
<p>修改后的power(x, n)函数有两个参数：x和n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数x和n</p>
<h4 id="默认参数"><a class="markdownIt-Anchor" href="#默认参数"></a> 默认参数</h4>
<p>新的power(x, n)函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>power(<span class="number">5</span>)
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
TypeError: power() missing <span class="number">1</span> required positional argument: <span class="string">&#x27;n&#x27;</span></code></pre>
<blockquote>
<p>Python的错误信息很明确：调用函数power()缺少了一个位置参数n</p>
</blockquote>
<p>这个时候，默认参数就排上用场了。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x, n=<span class="number">2</span></span>):
    s = <span class="number">1</span>
    <span class="keyword">while</span> n &gt; <span class="number">0</span>:
        n = n - <span class="number">1</span>
        s = s * x
    <span class="keyword">return</span> s</code></pre>
<p>这样，当我们调用power(5)时，相当于调用power(5, 2)：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>power(<span class="number">5</span>)
<span class="number">25</span>
<span class="meta">&gt;&gt;&gt; </span>power(<span class="number">5</span>, <span class="number">2</span>)
<span class="number">25</span></code></pre>
<p>而对于n &gt; 2的其他情况，就必须明确地传入n，比如power(5, 3)</p>
<p>从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意：</p>
<ul>
<li>一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；</li>
<li>二是如何设置默认参数。</li>
<li>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</li>
</ul>
<p>有多个默认参数时，调用的时候，既<strong>可以按顺序提供默认参数</strong>，比如调用enroll(‘Bob’, ‘M’, 7)，意思是，除了name，gender这两个参数外，最后1个参数应用在参数age上，city参数由于没有提供，仍然使用默认值。</p>
<p><strong>也可以不按顺序提供部分默认参数</strong>。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用enroll(‘Adam’, ‘M’, city=‘Tianjin’)，意思是，city参数用传进去的值，其他默认参数继续使用默认值。</p>
<hr />
<p>默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑，演示如下：</p>
<p>先定义一个函数，传入一个list，添加一个END再返回：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">add_end</span>(<span class="params">L=[]</span>):
    L.append(<span class="string">&#x27;END&#x27;</span>)
    <span class="keyword">return</span> L</code></pre>
<p>当你正常调用时，结果似乎不错：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>add_end([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])
[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;END&#x27;</span>]
<span class="meta">&gt;&gt;&gt; </span>add_end([<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>])
[<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;END&#x27;</span>]</code></pre>
<p>当你使用默认参数调用时，一开始结果也是对的：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>add_end()
[<span class="string">&#x27;END&#x27;</span>]</code></pre>
<p>但是，再次调用add_end()时，结果就不对了：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>add_end()
[<span class="string">&#x27;END&#x27;</span>, <span class="string">&#x27;END&#x27;</span>]
<span class="meta">&gt;&gt;&gt; </span>add_end()
[<span class="string">&#x27;END&#x27;</span>, <span class="string">&#x27;END&#x27;</span>, <span class="string">&#x27;END&#x27;</span>]</code></pre>
<p>原因解释如下：</p>
<ul>
<li>Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。</li>
<li><strong>定义默认参数要牢记一点：默认参数必须指向不变对象</strong></li>
</ul>
<p>要修改上面的例子，我们可以用None这个不变对象来实现：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">add_end</span>(<span class="params">L=<span class="literal">None</span></span>):
    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:
        L = []
    L.append(<span class="string">&#x27;END&#x27;</span>)
    <span class="keyword">return</span> L</code></pre>
<p>现在，无论调用多少次，都不会有问题：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>add_end()
[<span class="string">&#x27;END&#x27;</span>]
<span class="meta">&gt;&gt;&gt; </span>add_end()
[<span class="string">&#x27;END&#x27;</span>]</code></pre>
<blockquote>
<p>为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</p>
</blockquote>
<h4 id="可变参数"><a class="markdownIt-Anchor" href="#可变参数"></a> 可变参数</h4>
<p>在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。</p>
<p>我们以数学题为例子，给定一组数字a，b，c……，请计算a^2 + b^2 + c^2 + ……。</p>
<p>要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">numbers</span>):
    <span class="built_in">sum</span> = <span class="number">0</span>
    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:
        <span class="built_in">sum</span> = <span class="built_in">sum</span> + n * n
    <span class="keyword">return</span> <span class="built_in">sum</span></code></pre>
<p>但是调用的时候，需要先组装出一个list或tuple：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>calc([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])
<span class="number">14</span>
<span class="meta">&gt;&gt;&gt; </span>calc((<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>))
<span class="number">84</span></code></pre>
<p>如果利用可变参数，调用函数的方式可以简化成这样：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)
<span class="number">14</span>
<span class="meta">&gt;&gt;&gt; </span>calc(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>)
<span class="number">84</span></code></pre>
<p>所以，<strong>我们把函数的参数改为可变参数</strong>：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">*numbers</span>):
    <span class="built_in">sum</span> = <span class="number">0</span>
    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:
        <span class="built_in">sum</span> = <span class="built_in">sum</span> + n * n
    <span class="keyword">return</span> <span class="built_in">sum</span></code></pre>
<p>定义可变参数和定义一个list或tuple参数相比，<strong>仅仅在参数前面加了一<code>个*号</code>。在函数内部，参数numbers接收到的是一个tuple</strong>，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="number">1</span>, <span class="number">2</span>)
<span class="number">5</span>
<span class="meta">&gt;&gt;&gt; </span>calc()
<span class="number">0</span></code></pre>
<p>如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]
<span class="meta">&gt;&gt;&gt; </span>calc(nums[<span class="number">0</span>], nums[<span class="number">1</span>], nums[<span class="number">2</span>])
<span class="number">14</span></code></pre>
<p>这种写法当然是可行的，问题是太繁琐，所以<strong>Python允许你在list或tuple前面加一<code>个*号</code>，把list或tuple的元素变成可变参数传进去</strong>：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]
<span class="meta">&gt;&gt;&gt; </span>calc(*nums)
<span class="number">14</span></code></pre>
<blockquote>
<p><code>*nums</code>表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见</p>
</blockquote>
<h4 id="关键字参数"><a class="markdownIt-Anchor" href="#关键字参数"></a> 关键字参数</h4>
<p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而<strong>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict</strong>。请看示例：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, **kw</span>):
    <span class="built_in">print</span>(<span class="string">&#x27;name:&#x27;</span>, name, <span class="string">&#x27;age:&#x27;</span>, age, <span class="string">&#x27;other:&#x27;</span>, kw)</code></pre>
<p>函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Michael&#x27;</span>, <span class="number">30</span>)
name: Michael age: <span class="number">30</span> other: &#123;&#125;</code></pre>
<p>也可以传入任意个数的关键字参数：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">35</span>, city=<span class="string">&#x27;Beijing&#x27;</span>)
name: Bob age: <span class="number">35</span> other: &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>&#125;
<span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">45</span>, gender=<span class="string">&#x27;M&#x27;</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)
name: Adam age: <span class="number">45</span> other: &#123;<span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</code></pre>
<p>关键字参数有什么用？</p>
<ul>
<li>它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。</li>
</ul>
<p>和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>extra = &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;
<span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, city=extra[<span class="string">&#x27;city&#x27;</span>], job=extra[<span class="string">&#x27;job&#x27;</span>])
name: Jack age: <span class="number">24</span> other: &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</code></pre>
<p>当然，上面复杂的调用可以用简化的写法：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>extra = &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;
<span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, **extra)
name: Jack age: <span class="number">24</span> other: &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</code></pre>
<blockquote>
<p><code>**extra</code>表示把extra这个dict的所有key-value用关键字参数传入到函数的<code>**kw</code>参数，kw将获得一个dict，<strong>注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra</strong></p>
</blockquote>
<h4 id="命名关键字函数"><a class="markdownIt-Anchor" href="#命名关键字函数"></a> 命名关键字函数</h4>
<p>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查</p>
<p>仍以person()函数为例，我们希望检查是否有city和job参数：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, **kw</span>):
    <span class="keyword">if</span> <span class="string">&#x27;city&#x27;</span> <span class="keyword">in</span> kw:
        <span class="comment"># 有city参数</span>
        <span class="keyword">pass</span>
    <span class="keyword">if</span> <span class="string">&#x27;job&#x27;</span> <span class="keyword">in</span> kw:
        <span class="comment"># 有job参数</span>
        <span class="keyword">pass</span>
    <span class="built_in">print</span>(<span class="string">&#x27;name:&#x27;</span>, name, <span class="string">&#x27;age:&#x27;</span>, age, <span class="string">&#x27;other:&#x27;</span>, kw)</code></pre>
<p>但是调用者仍可以传入不受限制的关键字参数：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, city=<span class="string">&#x27;Beijing&#x27;</span>, addr=<span class="string">&#x27;Chaoyang&#x27;</span>, zipcode=<span class="number">123456</span>)</code></pre>
<p>如果要<strong>限制关键字参数的名字</strong>，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, *, city, job</span>):
    <span class="built_in">print</span>(name, age, city, job)</code></pre>
<p><strong>和关键字参数<code>**kw</code>不同，命名关键字参数需要一个<code>特殊分隔符*，*后面</code>的参数被视为命名关键字参数</strong>。</p>
<p>调用方式如下：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, city=<span class="string">&#x27;Beijing&#x27;</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)
Jack <span class="number">24</span> Beijing Engineer</code></pre>
<p><strong>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个<code>特殊分隔符*了</code>：</strong></p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, *args, city, job</span>):
    <span class="built_in">print</span>(name, age, args, city, job)</code></pre>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;libo&#x27;</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,city=<span class="string">&#x27;xian&#x27;</span>,job=<span class="string">&#x27;cxy&#x27;</span>)
libo <span class="number">13</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) xian cxy</code></pre>
<p><strong>命名关键字参数必须传入参数名</strong>，这和位置参数不同。如果没有传入参数名，调用将报错：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;Engineer&#x27;</span>)
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
TypeError: person() takes <span class="number">2</span> positional arguments but <span class="number">4</span> were given</code></pre>
<blockquote>
<p>由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数</p>
</blockquote>
<p><strong>命名关键字参数可以有缺省值</strong>，从而简化调用：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, *, city=<span class="string">&#x27;Beijing&#x27;</span>, job</span>):
    <span class="built_in">print</span>(name, age, city, job)</code></pre>
<p>由于命名关键字参数city具有默认值，调用时，可不传入city参数：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)
Jack <span class="number">24</span> Beijing Engineer</code></pre>
<hr />
<p>使用<strong>命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数</strong>：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, city, job</span>):
    <span class="comment"># 缺少 *，city和job被视为位置参数</span>
    <span class="keyword">pass</span></code></pre>
<h4 id="参数组合"><a class="markdownIt-Anchor" href="#参数组合"></a> 参数组合</h4>
<p>在Python中定义函数，可以用<strong>必选参数</strong>、<strong>默认参数</strong>、<strong>可变参数</strong>、<strong>关键字参数</strong>和<strong>命名关键字参数</strong>，这5种参数都可以组合使用。</p>
<p>但是请注意，参数定义的顺序必须是：</p>
<ul>
<li>必选参数-&gt;默认参数-&gt;可变参数-&gt;命名关键字参数和关键字参数</li>
</ul>
<p>比如定义一个函数，包含上述若干种参数：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">a, b, c=<span class="number">0</span>, *args, **kw</span>):
    <span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a, <span class="string">&#x27;b =&#x27;</span>, b, <span class="string">&#x27;c =&#x27;</span>, c, <span class="string">&#x27;args =&#x27;</span>, args, <span class="string">&#x27;kw =&#x27;</span>, kw)

<span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">a, b, c=<span class="number">0</span>, *, d, **kw</span>):
    <span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a, <span class="string">&#x27;b =&#x27;</span>, b, <span class="string">&#x27;c =&#x27;</span>, c, <span class="string">&#x27;d =&#x27;</span>, d, <span class="string">&#x27;kw =&#x27;</span>, kw)</code></pre>
<p>在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>)
a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> args = () kw = &#123;&#125;
<span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)
a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = () kw = &#123;&#125;
<span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>)
a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = () kw = &#123;&#125;
<span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)
a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) kw = &#123;&#125;
<span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, x=<span class="number">99</span>)
a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) kw = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">99</span>&#125;
<span class="meta">&gt;&gt;&gt; </span>f2(<span class="number">1</span>, <span class="number">2</span>, d=<span class="number">99</span>, ext=<span class="literal">None</span>)
a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> d = <span class="number">99</span> kw = &#123;<span class="string">&#x27;ext&#x27;</span>: <span class="literal">None</span>&#125;</code></pre>
<p>最神奇的是通过一个tuple和dict，你也可以调用上述函数：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)
<span class="meta">&gt;&gt;&gt; </span>kw = &#123;<span class="string">&#x27;d&#x27;</span>: <span class="number">99</span>, <span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;#&#x27;</span>&#125;
<span class="meta">&gt;&gt;&gt; </span>f1(*args, **kw)
a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="number">4</span>,) kw = &#123;<span class="string">&#x27;d&#x27;</span>: <span class="number">99</span>, <span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;#&#x27;</span>&#125;
<span class="meta">&gt;&gt;&gt; </span>args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)
<span class="meta">&gt;&gt;&gt; </span>kw = &#123;<span class="string">&#x27;d&#x27;</span>: <span class="number">88</span>, <span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;#&#x27;</span>&#125;
<span class="meta">&gt;&gt;&gt; </span>f2(*args, **kw)
a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> d = <span class="number">88</span> kw = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;#&#x27;</span>&#125;</code></pre>
<blockquote>
<p>所以，对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的</p>
</blockquote>
<blockquote>
<p>虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</p>
</blockquote>
<h3 id="递归参数"><a class="markdownIt-Anchor" href="#递归参数"></a> 递归参数</h3>
<p>在函数内部，可以调用其他函数。<strong>如果一个函数在内部调用自身本身，这个函数就是递归函数</strong></p>
<p>举个例子，我们来计算阶乘n! = 1 x 2 x 3 x … x n，用函数fact(n)表示，可以看出：</p>
<p>fact(n)=n!=1×2×3×⋅⋅⋅×(n−1)×n=(n−1)!×n=fact(n−1)×n</p>
<p>所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。</p>
<p>于是，fact(n)用递归的方式写出来就是：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):
    <span class="keyword">if</span> n==<span class="number">1</span>:
        <span class="keyword">return</span> <span class="number">1</span>
    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</code></pre>
<p>上面就是一个递归函数。可以试试：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">1</span>)
<span class="number">1</span>&gt;&gt;&gt; fact(<span class="number">5</span>)
<span class="number">120</span>&gt;&gt;&gt; fact(<span class="number">100</span>)
<span class="number">93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</span></code></pre>
<p>如果我们计算fact(5)，可以根据函数定义看到计算过程如下：</p>
<pre><code class="highlight plaintext">===&gt; fact(5)
===&gt; 5 * fact(4)
===&gt; 5 * (4 * fact(3))
===&gt; 5 * (4 * (3 * fact(2)))
===&gt; 5 * (4 * (3 * (2 * fact(1))))
===&gt; 5 * (4 * (3 * (2 * 1)))
===&gt; 5 * (4 * (3 * 2))
===&gt; 5 * (4 * 6)
===&gt; 5 * 24
===&gt; 120</code></pre>
<blockquote>
<p>递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。</p>
</blockquote>
<p>使用<strong>递归函数需要注意防止栈溢出</strong>。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">1000</span>)
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">4</span>, <span class="keyword">in</span> fact
  ...
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">4</span>, <span class="keyword">in</span> fact
RuntimeError: maximum recursion depth exceeded <span class="keyword">in</span> comparison</code></pre>
<p><strong>解决递归调用栈溢出的方法是通过尾递归优化</strong>，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p>
<blockquote>
<p>尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p>
</blockquote>
<p>上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):
    <span class="keyword">return</span> fact_iter(n, <span class="number">1</span>)

<span class="keyword">def</span> <span class="title function_">fact_iter</span>(<span class="params">num, product</span>):
    <span class="keyword">if</span> num == <span class="number">1</span>:
        <span class="keyword">return</span> product
    <span class="keyword">return</span> fact_iter(num - <span class="number">1</span>, num * product)</code></pre>
<p>可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，num - 1和num * product在函数调用前就会被计算，不影响函数调用。<br />
fact(5)对应的fact_iter(5, 1)的调用如下：</p>
<pre><code class="highlight python">===&gt; fact_iter(<span class="number">5</span>, <span class="number">1</span>)
===&gt; fact_iter(<span class="number">4</span>, <span class="number">5</span>)
===&gt; fact_iter(<span class="number">3</span>, <span class="number">20</span>)
===&gt; fact_iter(<span class="number">2</span>, <span class="number">60</span>)
===&gt; fact_iter(<span class="number">1</span>, <span class="number">120</span>)
===&gt; <span class="number">120</span></code></pre>
<p>尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</p>
<p>遗憾的是，<strong>大多数编程语言没有针对尾递归做优化</strong>，<strong>Python解释器也没有做优化</strong>，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。</p>
<h2 id="高级特性"><a class="markdownIt-Anchor" href="#高级特性"></a> 高级特性</h2>
<h3 id="切片"><a class="markdownIt-Anchor" href="#切片"></a> 切片</h3>
<p>表示取一个list或tuple的部分元素。</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Sarah&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>]</code></pre>
<p>取前3个元素:</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">0</span>:<span class="number">3</span>]
[<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Sarah&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</code></pre>
<blockquote>
<p>L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。</p>
</blockquote>
<p>如果第一个索引是0，还可以省略：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">3</span>]
[<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Sarah&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</code></pre>
<p>也可以从索引1开始，取出2个元素出来：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">1</span>:<span class="number">3</span>]
[<span class="string">&#x27;Sarah&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</code></pre>
<p>类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L[-<span class="number">2</span>:]
[<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>]
<span class="meta">&gt;&gt;&gt; </span>L[-<span class="number">2</span>:-<span class="number">1</span>]
[<span class="string">&#x27;Bob&#x27;</span>]</code></pre>
<blockquote>
<p>记住倒数第一个元素的索引是-1。</p>
</blockquote>
<hr />
<p>实例：</p>
<p>切片操作十分有用。我们先创建一个0-99的数列：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">100</span>))
<span class="meta">&gt;&gt;&gt; </span>L
[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ..., <span class="number">99</span>]</code></pre>
<p>可以通过切片轻松取出某一段数列。比如前10个数：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">10</span>]
[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</code></pre>
<p>后10个数：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L[-<span class="number">10</span>:]
[<span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>]</code></pre>
<p>前11-20个数：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">10</span>:<span class="number">20</span>]
[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>]</code></pre>
<p>前10个数，每两个取一个：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">10</span>:<span class="number">2</span>]
[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</code></pre>
<p>所有数，每5个取一个：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L[::<span class="number">5</span>]
[<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">55</span>, <span class="number">60</span>, <span class="number">65</span>, <span class="number">70</span>, <span class="number">75</span>, <span class="number">80</span>, <span class="number">85</span>, <span class="number">90</span>, <span class="number">95</span>]</code></pre>
<p>甚至什么都不写，只写[:]就可以<strong>原样复制</strong>一个list：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L[:]
[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ..., <span class="number">99</span>]</code></pre>
<p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)[:<span class="number">3</span>]
(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</code></pre>
<p>字符串’xxx’也可以看成是一种list，每个元素就是一个字符。因此，<strong>字符串也可以用切片操作</strong>，只是操作结果仍是字符串：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;ABCDEFG&#x27;</span>[:<span class="number">3</span>]
<span class="string">&#x27;ABC&#x27;</span>
<span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;ABCDEFG&#x27;</span>[::<span class="number">2</span>]
<span class="string">&#x27;ACEG&#x27;</span></code></pre>
<p>在很多编程语言中，针对字符串提供了很多各种截取函数（例如，substring），其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。</p>
<h3 id="迭代"><a class="markdownIt-Anchor" href="#迭代"></a> 迭代</h3>
<p>如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。</p>
<p>在Python中，<strong>迭代是通过for … in来完成</strong>的，而很多语言比如C语言，迭代list是通过下标完成的，比如Java代码：</p>
<pre><code class="highlight java"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;list.length; i++) &#123;
    n = list[i];
&#125;</code></pre>
<p>可以看出，Python的for循环抽象程度要高于C的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。</p>
<p>list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，<strong>只要是可迭代对象，无论有无下标，都可以迭代</strong>，比如dict就可以迭代：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;
<span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> d:
<span class="meta">... </span>    <span class="built_in">print</span>(key)
...
a
c
b</code></pre>
<blockquote>
<p><strong>因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样</strong>。</p>
</blockquote>
<p>默认情况下，dict迭代的是key。</p>
<ul>
<li>如果要<strong>迭代value</strong>，可以用for value in d.values()</li>
<li>如果要同时<strong>迭代key和value</strong>，可以用for k, v in d.items()</li>
</ul>
<p>由于字符串也是可迭代对象，因此，也可以作用于for循环：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span>:
<span class="meta">... </span>    <span class="built_in">print</span>(ch)
...
A
B
C</code></pre>
<p>所以，当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。</p>
<p>那么，如何判断一个对象是可迭代对象呢？</p>
<ul>
<li>方法是<strong>通过collections模块的Iterable类型判断</strong>：</li>
</ul>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">&#x27;abc&#x27;</span>, Iterable) <span class="comment"># str是否可迭代</span>
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], Iterable) <span class="comment"># list是否可迭代</span>
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="number">123</span>, Iterable) <span class="comment"># 整数是否可迭代</span>
<span class="literal">False</span></code></pre>
<p>最后一个小问题，如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]):
<span class="meta">... </span>    <span class="built_in">print</span>(i, value)
...
<span class="number">0</span> A
<span class="number">1</span> B
<span class="number">2</span> C</code></pre>
<p>上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x, y <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">9</span>)]:
<span class="meta">... </span>    <span class="built_in">print</span>(x, y)
...
<span class="number">1</span> <span class="number">12</span> <span class="number">43</span> <span class="number">9</span></code></pre>
<h3 id="列表生成式"><a class="markdownIt-Anchor" href="#列表生成式"></a> 列表生成式</h3>
<p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p>
<p>举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>))
[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</code></pre>
<p>但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L = []
<span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):
<span class="meta">... </span>   L.append(x * x)
...
<span class="meta">&gt;&gt;&gt; </span>L
[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</code></pre>
<p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]
[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</code></pre>
<blockquote>
<p>写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。</p>
</blockquote>
<p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]
[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</code></pre>
<p>还可以使用两层循环，可以生成全排列：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">&#x27;XYZ&#x27;</span>]
[<span class="string">&#x27;AX&#x27;</span>, <span class="string">&#x27;AY&#x27;</span>, <span class="string">&#x27;AZ&#x27;</span>, <span class="string">&#x27;BX&#x27;</span>, <span class="string">&#x27;BY&#x27;</span>, <span class="string">&#x27;BZ&#x27;</span>, <span class="string">&#x27;CX&#x27;</span>, <span class="string">&#x27;CY&#x27;</span>, <span class="string">&#x27;CZ&#x27;</span>]</code></pre>
<blockquote>
<p>三层和三层以上的循环就很少用到了。</p>
</blockquote>
<p><strong>运用列表生成式，可以写出非常简洁的代码</strong>。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os <span class="comment"># 导入os模块，模块的概念后面讲到</span>
<span class="meta">&gt;&gt;&gt; </span>[d <span class="keyword">for</span> d <span class="keyword">in</span> os.listdir(<span class="string">&#x27;.&#x27;</span>)] <span class="comment"># os.listdir可以列出文件和目录</span>
[<span class="string">&#x27;.emacs.d&#x27;</span>, <span class="string">&#x27;.ssh&#x27;</span>, <span class="string">&#x27;.Trash&#x27;</span>, <span class="string">&#x27;Adlm&#x27;</span>, <span class="string">&#x27;Applications&#x27;</span>, <span class="string">&#x27;Desktop&#x27;</span>, <span class="string">&#x27;Documents&#x27;</span>, <span class="string">&#x27;Downloads&#x27;</span>, <span class="string">&#x27;Library&#x27;</span>, <span class="string">&#x27;Movies&#x27;</span>, <span class="string">&#x27;Music&#x27;</span>, <span class="string">&#x27;Pictures&#x27;</span>, <span class="string">&#x27;Public&#x27;</span>, <span class="string">&#x27;VirtualBox VMs&#x27;</span>, <span class="string">&#x27;Workspace&#x27;</span>, <span class="string">&#x27;XCode&#x27;</span>]</code></pre>
<hr />
<p>for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;y&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;z&#x27;</span>: <span class="string">&#x27;C&#x27;</span> &#125;
<span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():
<span class="meta">... </span>    <span class="built_in">print</span>(k, <span class="string">&#x27;=&#x27;</span>, v)
...
y = B
x = A
z = C</code></pre>
<p>因此，列表生成式也可以使用两个变量来生成list：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;y&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;z&#x27;</span>: <span class="string">&#x27;C&#x27;</span> &#125;
<span class="meta">&gt;&gt;&gt; </span>[k + <span class="string">&#x27;=&#x27;</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items()]
[<span class="string">&#x27;y=B&#x27;</span>, <span class="string">&#x27;x=A&#x27;</span>, <span class="string">&#x27;z=C&#x27;</span>]</code></pre>
<p>最后把一个list中所有的字符串变成小写：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>, <span class="string">&#x27;IBM&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>]
<span class="meta">&gt;&gt;&gt; </span>[s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L]
[<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;ibm&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</code></pre>
<hr />
<p><strong>if…else</strong></p>
<p>使用列表生成式的时候，有些童鞋经常搞不清楚if…else的用法。</p>
<p>例如，以下代码正常输出偶数：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]
[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</code></pre>
<p>但是，我们不能在最后的if加上else：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>]
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>
    [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>]
                                              ^
SyntaxError: invalid syntax</code></pre>
<p>这是因为跟在for后面的if是一个筛选条件，不能带else，否则如何筛选？</p>
<p>另一些童鞋发现把if写在for前面必须加else，否则报错：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>
    [x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]
                       ^
SyntaxError: invalid syntax</code></pre>
<p>这是因为for前面的部分是一个表达式，它必须根据x计算出一个结果。因此，考察表达式：x if x % 2 == 0，它无法根据x计算出结果，因为缺少else，必须加上else：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> -x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]
[-<span class="number">1</span>, <span class="number">2</span>, -<span class="number">3</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">6</span>, -<span class="number">7</span>, <span class="number">8</span>, -<span class="number">9</span>, <span class="number">10</span>]</code></pre>
<p>上述for前面的表达式x if x % 2 == 0 else -x才能根据x计算出确定的结果。</p>
<p>可见，在一个列表生成式中，for前面的if … else是表达式，而for后面的if是过滤条件，不能带else。</p>
<h3 id="生成器"><a class="markdownIt-Anchor" href="#生成器"></a> 生成器</h3>
<p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p>
<p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？</p>
<p>这样就不必创建完整的list，从而节省大量的空间。<strong>在Python中，这种一边循环一边计算的机制，称为生成器：generator</strong>。</p>
<p>要创建一个generator，有很多种方法。第一种方法很简单，<strong>只要把一个列表生成式的[]改成()，就创建了一个generator</strong>：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]
<span class="meta">&gt;&gt;&gt; </span>L
[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]
<span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))
<span class="meta">&gt;&gt;&gt; </span>g
&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x1022ef630</span>&gt;</code></pre>
<p>创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。</p>
<p>我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？</p>
<ul>
<li>如果要一个一个打印出来，<strong>可以通过next()函数获得generator的下一个返回值</strong>：</li>
</ul>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)
<span class="number">0</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)
<span class="number">1</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)
<span class="number">4</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)
<span class="number">9</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)
<span class="number">16</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)
<span class="number">25</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)
<span class="number">36</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)
<span class="number">49</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)
<span class="number">64</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)
<span class="number">81</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
StopIteration</code></pre>
<p>我们讲过，<strong>generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误</strong>。</p>
<p>当然，上面这种不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))
<span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> g:
<span class="meta">... </span>    <span class="built_in">print</span>(n)
<span class="meta">... </span>
<span class="number">0</span>
<span class="number">1</span>
<span class="number">4</span>
<span class="number">9</span>
<span class="number">16</span>
<span class="number">25</span>
<span class="number">36</span>
<span class="number">49</span>
<span class="number">64</span>
<span class="number">81</span></code></pre>
<blockquote>
<p>所以，我们创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，并且不需要关心StopIteration的错误</p>
</blockquote>
<p>generator非常强大。<strong>如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现</strong>。</p>
<p>比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：</p>
<pre><code class="highlight plaintext">1, 1, 2, 3, 5, 8, 13, 21, 34, ...</code></pre>
<p>斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params"><span class="built_in">max</span></span>):
    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>
    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:
        <span class="built_in">print</span>(b)
        a, b = b, a + b
        n = n + <span class="number">1</span>
    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></code></pre>
<p>注意，赋值语句：</p>
<pre><code class="highlight python">a, b = b, a + b
<span class="comment">#相当于：</span>
t = (b, a + b) <span class="comment"># t是一个tuple</span>
a = t[<span class="number">0</span>]
b = t[<span class="number">1</span>]</code></pre>
<p>但不必显式写出临时变量t就可以赋值。</p>
<p>上面的函数可以输出斐波那契数列的前N个数：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">6</span>)
<span class="number">1</span>
<span class="number">1</span>
<span class="number">2</span>
<span class="number">3</span>
<span class="number">5</span>
<span class="number">8</span>
<span class="string">&#x27;done&#x27;</span></code></pre>
<p>仔细观察，可以看出，fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。也就是说，</p>
<p><strong>yield关键字</strong></p>
<p>上面的函数和generator仅一步之遥。<strong>要把fib函数变成generator，只需要把print(b)改为yield b就可以</strong>了：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params"><span class="built_in">max</span></span>):
    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>
    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:
        <span class="keyword">yield</span> b
        a, b = b, a + b
        n = n + <span class="number">1</span>
    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></code></pre>
<p>这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = fib(<span class="number">6</span>)
<span class="meta">&gt;&gt;&gt; </span>f
&lt;generator <span class="built_in">object</span> fib at <span class="number">0x104feaaa0</span>&gt;</code></pre>
<p>这里，最难理解的就是generator和函数的执行流程不一样。</p>
<ul>
<li>函数是<strong>顺序执行</strong>，遇到return语句或者最后一行函数语句就返回。</li>
<li>而变成generator的函数，<strong>在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行</strong>。</li>
</ul>
<p>举个简单的例子，定义一个generator，依次返回数字1，3，5：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">odd</span>():
    <span class="built_in">print</span>(<span class="string">&#x27;step 1&#x27;</span>)
    <span class="keyword">yield</span> <span class="number">1</span>
    <span class="built_in">print</span>(<span class="string">&#x27;step 2&#x27;</span>)
    <span class="keyword">yield</span>(<span class="number">3</span>)
    <span class="built_in">print</span>(<span class="string">&#x27;step 3&#x27;</span>)
    <span class="keyword">yield</span>(<span class="number">5</span>)</code></pre>
<p>调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>o = odd()
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)
step <span class="number">11</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)
step <span class="number">23</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)
step <span class="number">35</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
StopIteration</code></pre>
<blockquote>
<p>可以看到，odd不是普通函数，而是generator，在执行过程中，遇到yield就中断，下次又继续执行。执行3次yield后，已经没有yield可以执行了，所以，第4次调用next(o)就报错。</p>
</blockquote>
<p>回到fib的例子，我们在循环过程中不断调用yield，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。</p>
<p>同样的，把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> fib(<span class="number">6</span>):
<span class="meta">... </span>    <span class="built_in">print</span>(n)
...
<span class="number">1</span>
<span class="number">1</span>
<span class="number">2</span>
<span class="number">3</span>
<span class="number">5</span>
<span class="number">8</span></code></pre>
<p>但是用for循环调用generator时，发现拿不到generator的return语句的返回值(每次拿到的值都是yield返回的)。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>g = fib(<span class="number">6</span>)
<span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:
<span class="meta">... </span>    <span class="keyword">try</span>:
<span class="meta">... </span>        x = <span class="built_in">next</span>(g)
<span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;g:&#x27;</span>, x)
<span class="meta">... </span>    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:
<span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;Generator return value:&#x27;</span>, e.value)
<span class="meta">... </span>        <span class="keyword">break</span>
...
g: <span class="number">1</span>
g: <span class="number">1</span>
g: <span class="number">2</span>
g: <span class="number">3</span>
g: <span class="number">5</span>
g: <span class="number">8</span>
Generator <span class="keyword">return</span> value: done</code></pre>
<p>案例：</p>
<p>生成杨辉三角：</p>
<p>方法1：</p>
<pre><code class="highlight python">L = [<span class="number">1</span>]
<span class="keyword">while</span> <span class="literal">True</span>:
    <span class="keyword">yield</span> L
    L = [<span class="built_in">sum</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="number">0</span>]+L, L+[<span class="number">0</span>])]</code></pre>
<p>方法2：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">triangles</span>():
    L = [<span class="number">1</span>]
    <span class="keyword">while</span> <span class="literal">True</span>:
        <span class="keyword">yield</span> L
        L = [([<span class="number">0</span>] + L)[i] + (L + [<span class="number">0</span>])[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(L) + <span class="number">1</span>)]</code></pre>
<p>方法3：</p>
<pre><code class="highlight python">L = [<span class="number">1</span>]
<span class="keyword">while</span> <span class="literal">True</span>:
    <span class="keyword">yield</span> L
    L = [ x+y <span class="keyword">for</span> (x,y) <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="number">0</span>]+L,L+[<span class="number">0</span>])]</code></pre>
<h3 id="迭代器"><a class="markdownIt-Anchor" href="#迭代器"></a> 迭代器</h3>
<p>我们已经知道，可以直接作用于for循环的数据类型有以下几种：</p>
<ul>
<li>一类是集合数据类型，如list、tuple、dict、set、str等；</li>
<li>一类是generator，包括生成器和带yield的generator function。</li>
</ul>
<p>这些可以直接作用于for循环的对象统称为<strong>可迭代对象：Iterable</strong>。</p>
<p>可以使用isinstance()判断一个对象是否是Iterable对象：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>([], Iterable)
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(&#123;&#125;, Iterable)
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">&#x27;abc&#x27;</span>, Iterable)
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>((x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)), Iterable)
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="number">100</span>, Iterable)
<span class="literal">False</span></code></pre>
<p>而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。</p>
<p>可以被next()函数调用并不断返回下一个值的对象称为<strong>迭代器：Iterator</strong>。</p>
<p>可以使用isinstance()判断一个对象是否是Iterator对象：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>((x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)), Iterator)
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>([], Iterator)
<span class="literal">False</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(&#123;&#125;, Iterator)
<span class="literal">False</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">&#x27;abc&#x27;</span>, Iterator)
<span class="literal">False</span></code></pre>
<blockquote>
<p>生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator</p>
</blockquote>
<p>把list、dict、str等<strong>Iterable变成Iterator可以使用iter()函数</strong>：</p>
<pre><code class="highlight python">
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="built_in">iter</span>([]), Iterator)
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="built_in">iter</span>(<span class="string">&#x27;abc&#x27;</span>), Iterator)
<span class="literal">True</span></code></pre>
<p>为什么list、dict、str等数据类型不是Iterator？</p>
<p>这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p>
<p>Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p>
<p>Python的for循环本质上就是通过不断调用next()函数实现的，例如：</p>
<pre><code class="highlight python"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]:</code></pre>
<p>pass实际上完全等价于：</p>
<pre><code class="highlight python"><span class="comment"># 首先获得Iterator对象:</span>
it = <span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])
<span class="comment"># 循环:while True:</span>
    <span class="keyword">try</span>:
        <span class="comment"># 获得下一个值:</span>
        x = <span class="built_in">next</span>(it)
    <span class="keyword">except</span> StopIteration:
        <span class="comment"># 遇到StopIteration就退出循环</span>
        <span class="keyword">break</span></code></pre>
<h2 id="函数式编程"><a class="markdownIt-Anchor" href="#函数式编程"></a> 函数式编程</h2>
<p>函数是Python内建支持的一种封装，<strong>我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计</strong>。函数就是面向过程的程序设计的基本单元。</p>
<p>而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想<strong>更接近数学计算</strong>。</p>
<p>我们首先要搞明白计算机（Computer）和计算（Compute）的概念。</p>
<p>在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。</p>
<p>而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。</p>
<p>对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。</p>
<p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>
<p><strong>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数</strong>！</p>
<p>Python对函数式编程提供<strong>部分支持</strong>。由于Python允许使用变量，因此，<strong>Python不是纯函数式编程语言</strong>。</p>
<h3 id="高阶函数"><a class="markdownIt-Anchor" href="#高阶函数"></a> 高阶函数</h3>
<p>高阶函数英文叫Higher-order function。什么是高阶函数？我们以实际代码为例子，一步一步深入概念。</p>
<p><strong>变量可以指向函数</strong></p>
<p>以Python内置的求绝对值的函数abs()为例，调用该函数用以下代码：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(-<span class="number">10</span>)
<span class="number">10</span></code></pre>
<p>但是，如果只写abs呢？</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>
&lt;built-<span class="keyword">in</span> function <span class="built_in">abs</span>&gt;</code></pre>
<blockquote>
<p>可见，abs(-10)是函数调用，而abs是函数本身。</p>
</blockquote>
<p>要获得函数调用结果，我们可以把结果赋值给变量：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">abs</span>(-<span class="number">10</span>)
<span class="meta">&gt;&gt;&gt; </span>x
<span class="number">10</span></code></pre>
<p>但是，如果把函数本身赋值给变量呢？</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">abs</span>
<span class="meta">&gt;&gt;&gt; </span>f
&lt;built-<span class="keyword">in</span> function <span class="built_in">abs</span>&gt;</code></pre>
<blockquote>
<p>结论：函数本身也可以赋值给变量，即：<strong>变量可以指向函数</strong>。</p>
</blockquote>
<p>如果一个变量指向了一个函数，那么，可否通过该变量来调用这个函数？用代码验证一下：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">abs</span>
<span class="meta">&gt;&gt;&gt; </span>f(-<span class="number">10</span>)
<span class="number">10</span></code></pre>
<blockquote>
<p>成功！说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。</p>
</blockquote>
<p><strong>函数名也是变量</strong></p>
<p>那么函数名是什么呢？<strong>函数名其实就是指向函数的变量</strong>！对于abs()这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数！</p>
<p>如果把abs指向其他对象，会有什么情况发生？</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span> = <span class="number">10</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(-<span class="number">10</span>)
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
TypeError: <span class="string">&#x27;int&#x27;</span> <span class="built_in">object</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">callable</span></code></pre>
<p>把abs指向10后，就无法通过abs(-10)调用该函数了！因为abs这个变量已经不指向求绝对值函数而是指向一个整数10！</p>
<p>当然实际代码绝对不能这么写，这里是为了说明函数名也是变量。要恢复abs函数，请重启Python交互环境。</p>
<blockquote>
<p>注：由于abs函数实际上是定义在import builtins模块中的，所以要让修改abs变量的指向在其它模块也生效，要用import builtins; builtins.abs = 10。</p>
</blockquote>
<p><strong>传入函数</strong></p>
<p>既然变量可以指向函数，函数的参数能接收变量，那么<strong>一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数</strong>。</p>
<p>一个最简单的高阶函数：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y, f</span>):
    <span class="keyword">return</span> f(x) + f(y)</code></pre>
<p>当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，我们可以推导计算过程为：</p>
<pre><code class="highlight python">x = -<span class="number">5</span>
y = <span class="number">6</span>
f = <span class="built_in">abs</span>
f(x) + f(y) ==&gt; <span class="built_in">abs</span>(-<span class="number">5</span>) + <span class="built_in">abs</span>(<span class="number">6</span>) ==&gt; <span class="number">11</span>
<span class="keyword">return</span> <span class="number">11</span></code></pre>
<h4 id="map"><a class="markdownIt-Anchor" href="#map"></a> map</h4>
<p>Python内建了map()和reduce()函数。</p>
<p>我们先看map。<strong>map()函数接收两个参数，一个是函数</strong>，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。</p>
<p>举例说明，比如我们有一个函数f(x)=x2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下：</p>
<p>现在，我们用Python代码实现：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):
<span class="meta">... </span>    <span class="keyword">return</span> x * x
...
<span class="meta">&gt;&gt;&gt; </span>r = <span class="built_in">map</span>(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(r)
[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</code></pre>
<p>map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。</p>
<p>你可能会想，不需要map()函数，写一个循环，也可以计算出结果：</p>
<pre><code class="highlight python">L = []
<span class="keyword">for</span> n <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]:
    L.append(f(n))
<span class="built_in">print</span>(L)</code></pre>
<blockquote>
<p>的确可以，但是，从上面的循环代码，能一眼看明白“把f(x)作用在list的每一个元素并把结果生成一个新的list”吗？</p>
</blockquote>
<p>所以，map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把这个list所有数字转为字符串：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))
[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>]</code></pre>
<h4 id="reduce"><a class="markdownIt-Anchor" href="#reduce"></a> reduce</h4>
<p>reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<pre><code class="highlight python">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code></pre>
<p>比方说对一个序列求和，就可以用reduce实现：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce
<span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):
<span class="meta">... </span>    <span class="keyword">return</span> x + y
...
<span class="meta">&gt;&gt;&gt; </span>reduce(add, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])
<span class="number">25</span></code></pre>
<blockquote>
<p>当然求和运算可以直接用Python内建函数sum()，没必要动用reduce</p>
</blockquote>
<p>但是如果要把序列[1, 3, 5, 7, 9]变换成整数13579，reduce就可以派上用场：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce
<span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fn</span>(<span class="params">x, y</span>):
<span class="meta">... </span>    <span class="keyword">return</span> x * <span class="number">10</span> + y
...
<span class="meta">&gt;&gt;&gt; </span>reduce(fn, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])
<span class="number">13579</span></code></pre>
<p>这个例子本身没多大用处，但是，如果考虑到字符串str也是一个序列，对上面的例子稍加改动，配合map()，我们就可以写出把str转换为int的函数：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce
<span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fn</span>(<span class="params">x, y</span>):
<span class="meta">... </span>    <span class="keyword">return</span> x * <span class="number">10</span> + y
...
<span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">char2num</span>(<span class="params">s</span>):
<span class="meta">... </span>    digits = &#123;<span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;8&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>: <span class="number">9</span>&#125;
<span class="meta">... </span>    <span class="keyword">return</span> digits[s]
...
<span class="meta">&gt;&gt;&gt; </span>reduce(fn, <span class="built_in">map</span>(char2num, <span class="string">&#x27;13579&#x27;</span>))
<span class="number">13579</span></code></pre>
<p>整理成一个str2int的函数就是：</p>
<pre><code class="highlight python"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce

DIGITS = &#123;<span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;8&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>: <span class="number">9</span>&#125;

<span class="keyword">def</span> <span class="title function_">str2int</span>(<span class="params">s</span>):
    <span class="keyword">def</span> <span class="title function_">fn</span>(<span class="params">x, y</span>):
        <span class="keyword">return</span> x * <span class="number">10</span> + y
    <span class="keyword">def</span> <span class="title function_">char2num</span>(<span class="params">s</span>):
        <span class="keyword">return</span> DIGITS[s]
    <span class="keyword">return</span> reduce(fn, <span class="built_in">map</span>(char2num, s))</code></pre>
<p>还可以用lambda函数进一步简化成：</p>
<pre><code class="highlight python"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce

DIGITS = &#123;<span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;8&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>: <span class="number">9</span>&#125;

<span class="keyword">def</span> <span class="title function_">char2num</span>(<span class="params">s</span>):
    <span class="keyword">return</span> DIGITS[s]

<span class="keyword">def</span> <span class="title function_">str2int</span>(<span class="params">s</span>):
    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x * <span class="number">10</span> + y, <span class="built_in">map</span>(char2num, s))</code></pre>
<blockquote>
<p>也就是说，假设Python没有提供int()函数，你完全可以自己写一个把字符串转化为整数的函数，而且只需要几行代码！</p>
</blockquote>
<hr />
<p>练习1：利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：[‘adam’, ‘LISA’, ‘barT’]，输出：[‘Adam’, ‘Lisa’, ‘Bart’]：</p>
<pre><code class="highlight python"><span class="comment"># 测试:</span>
L1 = [<span class="string">&#x27;adam&#x27;</span>, <span class="string">&#x27;LISA&#x27;</span>, <span class="string">&#x27;barT&#x27;</span>]
L2 = <span class="built_in">list</span>(<span class="built_in">map</span>(normalize, L1))
<span class="built_in">print</span>(L2)

<span class="comment">#答案1：</span>
<span class="keyword">def</span> <span class="title function_">normalize</span>(<span class="params">name</span>):
    ii=<span class="string">&#x27;&#x27;</span>
    <span class="keyword">for</span> i,ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(name):
        <span class="keyword">if</span> i==<span class="number">0</span>:
            ii=ii+ch.upper()
        <span class="keyword">else</span>:
            ii=ii+ch.lower()
    <span class="keyword">return</span> ii

答案<span class="number">2</span>：
<span class="keyword">def</span> <span class="title function_">normalize</span>(<span class="params">name</span>):
    <span class="keyword">from</span> functools <span class="keyword">import</span> reduce
    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y: x+y, [ch.upper() <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">else</span> ch.lower() <span class="keyword">for</span> i, ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(name)])</code></pre>
<p>练习2:Python提供的sum()函数可以接受一个list并求和，请编写一个prod()函数，可以接受一个list并利用reduce()求积：</p>
<pre><code class="highlight python"><span class="comment">#测试</span>
<span class="built_in">print</span>(<span class="string">&#x27;3 * 5 * 7 * 9 =&#x27;</span>, prod([<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]))
<span class="keyword">if</span> prod([<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]) == <span class="number">945</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;测试成功!&#x27;</span>)
<span class="keyword">else</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)


<span class="comment"># -*- coding: utf-8 -*-</span>
<span class="keyword">from</span> functools <span class="keyword">import</span> reduce
<span class="keyword">def</span> <span class="title function_">prod</span>(<span class="params">L</span>):
    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y:x*y,L)</code></pre>
<h4 id="filter"><a class="markdownIt-Anchor" href="#filter"></a> filter</h4>
<p>Python内建的<strong>filter()函数用于过滤序列</strong>。</p>
<p>和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，<strong>filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素</strong>。</p>
<p>例如，在一个list中，删掉偶数，只保留奇数，可以这么写：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">is_odd</span>(<span class="params">n</span>):
    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span>

<span class="built_in">list</span>(<span class="built_in">filter</span>(is_odd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>]))
<span class="comment"># 结果: [1, 5, 9, 15]</span></code></pre>
<p>把一个序列中的空字符串删掉，可以这么写：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">not_empty</span>(<span class="params">s</span>):
    <span class="keyword">return</span> s <span class="keyword">and</span> s.strip()

<span class="built_in">list</span>(<span class="built_in">filter</span>(not_empty, [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="literal">None</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;  &#x27;</span>]))
<span class="comment"># 结果: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></code></pre>
<blockquote>
<p>可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。</p>
</blockquote>
<p>注意到<strong>filter()函数返回的是一个Iterator</strong>，也就是一个惰性序列，所以要强迫filter()完成计算结果，<strong>需要用list()函数获得所有结果并返回list</strong>。</p>
<hr />
<p><strong>用filter求素数</strong></p>
<ul>
<li>计算素数的一个方法是埃氏筛法，它的算法理解起来非常简单：</li>
<li>首先，列出从2开始的所有自然数，构造一个序列：2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …</li>
<li>取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉：3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …</li>
<li>取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉：5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …</li>
<li>取新序列的第一个数5，然后用5把序列的5的倍数筛掉：7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …</li>
<li>不断筛下去，就可以得到所有的素数。</li>
</ul>
<p>用Python来实现这个算法，可以先构造一个从3开始的奇数序列：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">_odd_iter</span>():
    n = <span class="number">1</span>
    <span class="keyword">while</span> <span class="literal">True</span>:
        n = n + <span class="number">2</span>
        <span class="keyword">yield</span> n</code></pre>
<blockquote>
<p>注意这是一个生成器，并且是一个无限序列。</p>
</blockquote>
<p>然后定义一个筛选函数：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">_not_divisible</span>(<span class="params">n</span>):
    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x % n &gt; <span class="number">0</span></code></pre>
<p>最后，定义一个生成器，不断返回下一个素数：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">primes</span>():
    <span class="keyword">yield</span> <span class="number">2</span>
    it = _odd_iter() <span class="comment"># 初始序列</span>
    <span class="keyword">while</span> <span class="literal">True</span>:
        n = <span class="built_in">next</span>(it) <span class="comment"># 返回序列的第一个数</span>
        <span class="keyword">yield</span> n
        it = <span class="built_in">filter</span>(_not_divisible(n), it) <span class="comment"># 构造新序列</span></code></pre>
<p>这个生成器先返回第一个素数2，然后，利用filter()不断产生筛选后的新的序列。</p>
<p>由于primes()也是一个无限序列，所以调用时需要设置一个退出循环的条件：</p>
<pre><code class="highlight python"><span class="comment"># 打印1000以内的素数:</span>
<span class="keyword">for</span> n <span class="keyword">in</span> primes():
    <span class="keyword">if</span> n &lt; <span class="number">1000</span>:
        <span class="built_in">print</span>(n)
    <span class="keyword">else</span>:
        <span class="keyword">break</span></code></pre>
<blockquote>
<p>注意到Iterator是惰性计算的序列，所以我们可以用Python表示“全体自然数”，“全体素数”这样的序列，而代码非常简洁。</p>
</blockquote>
<hr />
<p>练习:</p>
<p>回数是指从左向右读和从右向左读都是一样的数，例如12321，909。请利用filter()筛选出回数：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">is_palindrome</span>(<span class="params">n</span>):
    <span class="keyword">return</span> <span class="built_in">str</span>(n)==<span class="built_in">str</span>(n)[::-<span class="number">1</span>]

<span class="comment"># 测试:</span>
output = <span class="built_in">filter</span>(is_palindrome, <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1000</span>))
<span class="built_in">print</span>(<span class="string">&#x27;1~1000:&#x27;</span>, <span class="built_in">list</span>(output))
<span class="keyword">if</span> <span class="built_in">list</span>(<span class="built_in">filter</span>(is_palindrome, <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">200</span>))) == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>, <span class="number">101</span>, <span class="number">111</span>, <span class="number">121</span>, <span class="number">131</span>, <span class="number">141</span>, <span class="number">151</span>, <span class="number">161</span>, <span class="number">171</span>, <span class="number">181</span>, <span class="number">191</span>]:
    <span class="built_in">print</span>(<span class="string">&#x27;测试成功!&#x27;</span>)
<span class="keyword">else</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</code></pre>
<h4 id="sorted"><a class="markdownIt-Anchor" href="#sorted"></a> sorted</h4>
<p>排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个dict呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。</p>
<p>Python内置的sorted()函数就可以对list进行排序：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="number">36</span>, <span class="number">5</span>, -<span class="number">12</span>, <span class="number">9</span>, -<span class="number">21</span>])
[-<span class="number">21</span>, -<span class="number">12</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">36</span>]</code></pre>
<p>此外，sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="number">36</span>, <span class="number">5</span>, -<span class="number">12</span>, <span class="number">9</span>, -<span class="number">21</span>], key=<span class="built_in">abs</span>)
[<span class="number">5</span>, <span class="number">9</span>, -<span class="number">12</span>, -<span class="number">21</span>, <span class="number">36</span>]</code></pre>
<p>key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过key=abs处理过的list：</p>
<pre><code class="highlight python"><span class="built_in">list</span> = [<span class="number">36</span>, <span class="number">5</span>, -<span class="number">12</span>, <span class="number">9</span>, -<span class="number">21</span>]

keys = [<span class="number">36</span>, <span class="number">5</span>,  <span class="number">12</span>, <span class="number">9</span>,  <span class="number">21</span>]


<span class="comment">#然后sorted()函数按照keys进行排序，并按照对应关系返回list相应的元素：</span>
keys排序结果 =&gt; [<span class="number">5</span>, <span class="number">9</span>,  <span class="number">12</span>,  <span class="number">21</span>, <span class="number">36</span>]
最终结果       =&gt; [<span class="number">5</span>, <span class="number">9</span>, -<span class="number">12</span>, -<span class="number">21</span>, <span class="number">36</span>]</code></pre>
<p>我们再看一个字符串排序的例子：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>])
[<span class="string">&#x27;Credit&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>]</code></pre>
<p>默认情况下，对字符串排序，是按照ASCII的大小比较的，由于’Z’ &lt; ‘a’，结果，大写字母Z会排在小写字母a的前面。</p>
<p>现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。<br />
这样，我们给sorted传入key函数，即可实现忽略大小写的排序：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>], key=<span class="built_in">str</span>.lower)
[<span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>]</code></pre>
<p>要进行反向排序，不必改动key函数，可以传入第三个参数</p>
<pre><code class="highlight python">reverse=<span class="literal">True</span>：&gt;&gt;&gt; <span class="built_in">sorted</span>([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>], key=<span class="built_in">str</span>.lower, reverse=<span class="literal">True</span>)
[<span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>]</code></pre>
<p>从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。</p>
<h3 id="返回函数"><a class="markdownIt-Anchor" href="#返回函数"></a> 返回函数</h3>
<p><strong>函数作为返回值</strong></p>
<p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>
<p>我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">calc_sum</span>(<span class="params">*args</span>):
    ax = <span class="number">0</span>
    <span class="keyword">for</span> n <span class="keyword">in</span> args:
        ax = ax + n
    <span class="keyword">return</span> ax</code></pre>
<p>但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">lazy_sum</span>(<span class="params">*args</span>):
    <span class="keyword">def</span> <span class="title function_">sum</span>():
        ax = <span class="number">0</span>
        <span class="keyword">for</span> n <span class="keyword">in</span> args:
            ax = ax + n
        <span class="keyword">return</span> ax
    <span class="keyword">return</span> <span class="built_in">sum</span></code></pre>
<p>当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)
<span class="meta">&gt;&gt;&gt; </span>f
&lt;function lazy_sum.&lt;<span class="built_in">locals</span>&gt;.<span class="built_in">sum</span> at <span class="number">0x101c6ed90</span>&gt;

<span class="comment">#调用函数f时，才真正计算求和的结果：</span>
<span class="meta">&gt;&gt;&gt; </span>f()
<span class="number">25</span></code></pre>
<p>在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“<strong>闭包</strong>（Closure）”的程序结构拥有极大的威力。</p>
<p>请再注意一点，当我们调用lazy_sum()时，<strong>每次调用都会返回一个新的函数，即使传入相同的参数</strong>：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f1 = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)
<span class="meta">&gt;&gt;&gt; </span>f2 = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)
<span class="meta">&gt;&gt;&gt; </span>f1==f2
<span class="literal">False</span></code></pre>
<blockquote>
<p><strong>f1()和f2()的调用结果互不影响</strong>。</p>
</blockquote>
<hr />
<p><strong>闭包</strong></p>
<p>注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。</p>
<p>另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">count</span>():
    fs = []
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):
        <span class="keyword">def</span> <span class="title function_">f</span>():
             <span class="keyword">return</span> i*i
        fs.append(f)
    <span class="keyword">return</span> fs

f1, f2, f3 = count()</code></pre>
<blockquote>
<p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。</p>
</blockquote>
<p>你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f1()
<span class="number">9</span>
<span class="meta">&gt;&gt;&gt; </span>f2()
<span class="number">9</span>
<span class="meta">&gt;&gt;&gt; </span>f3()
<span class="number">9</span></code></pre>
<p>全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。</p>
<blockquote>
<p>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p>
</blockquote>
<p>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">count</span>():
    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">j</span>):
        <span class="keyword">def</span> <span class="title function_">g</span>():
            <span class="keyword">return</span> j*j
        <span class="keyword">return</span> g
    fs = []
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):
        fs.append(f(i)) <span class="comment"># f(i)立刻被执行，因此i的当前值被传入f()</span>
    <span class="keyword">return</span> fs</code></pre>
<p>再看看结果</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f1, f2, f3 = count()
<span class="meta">&gt;&gt;&gt; </span>f1()
<span class="number">1</span>
<span class="meta">&gt;&gt;&gt; </span>f2()
<span class="number">4</span>
<span class="meta">&gt;&gt;&gt; </span>f3()
<span class="number">9</span></code></pre>
<p>缺点是代码较长，可利用lambda函数缩短代码。</p>
<hr />
<p>练习：</p>
<p>利用闭包返回一个计数器函数，每次调用它返回递增整数：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">createCounter</span>():
    <span class="keyword">def</span> <span class="title function_">counter</span>():
        <span class="keyword">return</span> <span class="number">1</span>
    <span class="keyword">return</span> counter


<span class="comment"># 测试:</span>
counterA = createCounter()
<span class="built_in">print</span>(counterA(), counterA(), counterA(), counterA(), counterA()) <span class="comment"># 1 2 3 4 5</span>
counterB = createCounter()
<span class="keyword">if</span> [counterB(), counterB(), counterB(), counterB()] == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]:
    <span class="built_in">print</span>(<span class="string">&#x27;测试通过!&#x27;</span>)
<span class="keyword">else</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</code></pre>
<pre><code class="highlight python"><span class="comment">#方法一：使用nonlocal关键字声明内函数的变量</span>
<span class="keyword">def</span> <span class="title function_">createCounter</span>():
    a=<span class="number">0</span>
    <span class="keyword">def</span> <span class="title function_">counter</span>():
        <span class="keyword">nonlocal</span> a <span class="comment">#nonlocal声明这个变量不是局部变量空间的变量，需要向上一个层级变量空间找这个变量</span>
        a=a+<span class="number">1</span>
        <span class="keyword">return</span> a
    <span class="keyword">return</span> counter

<span class="comment">#方法二：使用可变类型数据的闭包变量，如list。方法一和二本质上是一样的，都是在内函数中修改外函数的闭包变量。有两种方法进行修改，一是使用nonlocal关键字在内函数中进行声明，另一种是使用可变类型的数据作为闭包变量，此时在内函数中可以直接修改这个变量的值</span>
<span class="keyword">def</span> <span class="title function_">createCounter</span>():
    c=[<span class="number">0</span>]
    <span class="keyword">def</span> <span class="title function_">counter</span>():
        c[<span class="number">0</span>]+=<span class="number">1</span>
        <span class="keyword">return</span> c[<span class="number">0</span>]
    <span class="keyword">return</span> counter

<span class="comment">#方法三：使用generator及next()生成一个计数器</span>
<span class="keyword">def</span> <span class="title function_">createCounter</span>():
    <span class="keyword">def</span> <span class="title function_">iterator</span>(): <span class="comment">#定义一个生成器，逐个生成1,2,3...自然数序列</span>
        n=<span class="number">0</span>
        <span class="keyword">while</span> <span class="literal">True</span>:
            n+=<span class="number">1</span>
            <span class="keyword">yield</span> n
    g=iterator() <span class="comment">#需声明一个变量g指向生成器</span>
    <span class="keyword">def</span> <span class="title function_">counter</span>():
        <span class="keyword">return</span> <span class="built_in">next</span>(g)
    <span class="keyword">return</span> counter <span class="comment">#注意外函数返回内函数时，内函数名后不能有()</span></code></pre>
<h3 id="匿名函数-lamdba"><a class="markdownIt-Anchor" href="#匿名函数-lamdba"></a> 匿名函数 lamdba</h3>
<p>当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。</p>
<p>在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))
[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</code></pre>
<p>通过对比可以看出，匿名函数lambda x: x * x实际上就是：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):
    <span class="keyword">return</span> x * x</code></pre>
<p><strong>关键字lambda表示匿名函数，冒号前面的x表示函数参数</strong>。</p>
<blockquote>
<p>匿名函数有个限制，就是<strong>只能有一个表达式</strong>，<strong>不用写return</strong>，返回值就是该表达式的结果。</p>
</blockquote>
<p>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = <span class="keyword">lambda</span> x: x * x
<span class="meta">&gt;&gt;&gt; </span>f
&lt;function &lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x101c6ef28</span>&gt;
<span class="meta">&gt;&gt;&gt; </span>f(<span class="number">5</span>)
<span class="number">25</span></code></pre>
<p>同样，也可以把匿名函数作为返回值返回，比如：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">x, y</span>):
    <span class="keyword">return</span> <span class="keyword">lambda</span>: x * x + y * y</code></pre>
<h3 id="装饰器"><a class="markdownIt-Anchor" href="#装饰器"></a> 装饰器</h3>
<p>由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">now</span>():
<span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;2015-3-25&#x27;</span>)
...
<span class="meta">&gt;&gt;&gt; </span>f = now
<span class="meta">&gt;&gt;&gt; </span>f()
<span class="number">2015</span>-<span class="number">3</span>-<span class="number">25</span></code></pre>
<p><strong>函数对象有一个__name__属性，可以拿到函数的名字</strong>：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>now.__name__
<span class="string">&#x27;now&#x27;</span>
<span class="meta">&gt;&gt;&gt; </span>f.__name__
<span class="string">&#x27;now&#x27;</span></code></pre>
<p>现在，假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种<strong>在代码运行期间动态增加功能的方式，称之为“装饰器”</strong>（Decorator）。</p>
<p><strong>本质上，decorator就是一个返回函数的高阶函数</strong>。所以，我们要定义一个能打印日志的decorator，可以定义如下：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">func</span>):
    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;call %s():&#x27;</span> % func.__name__)
        <span class="keyword">return</span> func(*args, **kw)
    <span class="keyword">return</span> wrapper</code></pre>
<p>观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助<strong>Python的@语法，把decorator置于函数的定义处</strong>：</p>
<pre><code class="highlight python"><span class="meta">@log</span>
<span class="keyword">def</span> <span class="title function_">now</span>():
    <span class="built_in">print</span>(<span class="string">&#x27;2015-3-25&#x27;</span>)</code></pre>
<p>调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>now()
call now():
<span class="number">2015</span>-<span class="number">3</span>-<span class="number">25</span></code></pre>
<p>把@log放到now()函数的定义处，相当于执行了语句：</p>
<pre><code class="highlight python">now = log(now)</code></pre>
<p>由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。</p>
<p>wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。</p>
<hr />
<p><strong>如果decorator本身需要传入参数</strong>，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">text</span>):
    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):
        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):
            <span class="built_in">print</span>(<span class="string">&#x27;%s %s():&#x27;</span> % (text, func.__name__))
            <span class="keyword">return</span> func(*args, **kw)
        <span class="keyword">return</span> wrapper
    <span class="keyword">return</span> decorator</code></pre>
<p>这个3层嵌套的decorator用法如下：</p>
<pre><code class="highlight python"><span class="meta">@log(<span class="params"><span class="string">&#x27;execute&#x27;</span></span>)</span>
<span class="keyword">def</span> <span class="title function_">now</span>():
    <span class="built_in">print</span>(<span class="string">&#x27;2015-3-25&#x27;</span>)

<span class="comment">#执行结果如下：</span>
<span class="meta">&gt;&gt;&gt; </span>now()
execute now():
<span class="number">2015</span>-<span class="number">3</span>-<span class="number">25</span></code></pre>
<p>和两层嵌套的decorator相比，3层嵌套的效果是这样的：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>now = log(<span class="string">&#x27;execute&#x27;</span>)(now)</code></pre>
<blockquote>
<p>我们来剖析上面的语句，首先执行log(‘execute’)，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数</p>
</blockquote>
<p>以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的’now’变成了’wrapper’：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>now.__name__
<span class="string">&#x27;wrapper&#x27;</span></code></pre>
<p>因为返回的那个wrapper()函数名字就是’wrapper’，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。</p>
<p><strong>不需要编写wrapper.__name__ = func.__name__这样的代码，Python内置的functools.wraps就是干这个事的</strong>，所以，一个完整的decorator的写法如下：</p>
<pre><code class="highlight python"><span class="keyword">import</span> functools

<span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">func</span>):
<span class="meta">    @functools.wraps(<span class="params">func</span>)</span>
    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;call %s():&#x27;</span> % func.__name__)
        <span class="keyword">return</span> func(*args, **kw)
    <span class="keyword">return</span> wrapper</code></pre>
<p>或者针对带参数的decorator：</p>
<pre><code class="highlight python"><span class="keyword">import</span> functools

<span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">text</span>):
    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):
<span class="meta">        @functools.wraps(<span class="params">func</span>)</span>
        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):
            <span class="built_in">print</span>(<span class="string">&#x27;%s %s():&#x27;</span> % (text, func.__name__))
            <span class="keyword">return</span> func(*args, **kw)
        <span class="keyword">return</span> wrapper
    <span class="keyword">return</span> decorator</code></pre>
<blockquote>
<p>import functools是导入functools模块。现在，只需记住在定义wrapper()的前面加上@functools.wraps(func)即可。</p>
</blockquote>
<hr />
<p>练习：</p>
<p>请设计一个decorator，它可作用于任何函数上，并打印该函数的执行时间：</p>
<pre><code class="highlight python"><span class="comment"># -*- coding: utf-8 -*-</span>
<span class="keyword">import</span> time, functools
<span class="keyword">def</span> <span class="title function_">metric</span>(<span class="params">fn</span>):
<span class="meta">    @functools.wraps(<span class="params">fn</span>)</span>
    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):
      t0 = time.time()
      result = fn(*args, **kw)
      <span class="built_in">print</span>(<span class="string">&#x27;%s executed in %s ms&#x27;</span> % (fn.__name__, time.time()-t0))
      <span class="keyword">return</span> result
    <span class="keyword">return</span> wrapper


<span class="comment"># 测试</span>
<span class="meta">@metric</span>
<span class="keyword">def</span> <span class="title function_">fast</span>(<span class="params">x, y</span>):
    time.sleep(<span class="number">0.0012</span>)
    <span class="keyword">return</span> x + y;

<span class="meta">@metric</span>
<span class="keyword">def</span> <span class="title function_">slow</span>(<span class="params">x, y, z</span>):
    time.sleep(<span class="number">0.1234</span>)
    <span class="keyword">return</span> x * y * z;

f = fast(<span class="number">11</span>, <span class="number">22</span>)
s = slow(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>)
<span class="keyword">if</span> f != <span class="number">33</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)
<span class="keyword">elif</span> s != <span class="number">7986</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</code></pre>
<h3 id="偏函数"><a class="markdownIt-Anchor" href="#偏函数"></a> 偏函数</h3>
<p>Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。</p>
<p>在介绍函数参数的时候，我们讲到，通<strong>过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点</strong>。</p>
<p>举例如下：int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;12345&#x27;</span>)
<span class="number">12345</span></code></pre>
<p>但int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做N进制的转换：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;12345&#x27;</span>, base=<span class="number">8</span>)
<span class="number">5349</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;12345&#x27;</span>, <span class="number">16</span>)
<span class="number">74565</span></code></pre>
<p>假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">int2</span>(<span class="params">x, base=<span class="number">2</span></span>):
    <span class="keyword">return</span> <span class="built_in">int</span>(x, base)</code></pre>
<p>这样，我们转换二进制就非常方便了：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">&#x27;1000000&#x27;</span>)
<span class="number">64</span>&gt;&gt;&gt; int2(<span class="string">&#x27;1010101&#x27;</span>)
<span class="number">85</span></code></pre>
<p><strong>functools.partial就是帮助我们创建一个偏函数的</strong>，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools
<span class="meta">&gt;&gt;&gt; </span>int2 = functools.partial(<span class="built_in">int</span>, base=<span class="number">2</span>)
<span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">&#x27;1000000&#x27;</span>)
<span class="number">64</span>&gt;&gt;&gt; int2(<span class="string">&#x27;1010101&#x27;</span>)
<span class="number">85</span></code></pre>
<p>所以，简单<strong>总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单</strong>。</p>
<p>注意到上面的新的int2函数，仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">&#x27;1000000&#x27;</span>, base=<span class="number">10</span>)
<span class="number">1000000</span></code></pre>
<p>最后，创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数，当传入：</p>
<pre><code class="highlight python">int2 = functools.partial(<span class="built_in">int</span>, base=<span class="number">2</span>)

<span class="comment">#实际上固定了int()函数的关键字参数base，也就是：</span>
int2(<span class="string">&#x27;10010&#x27;</span>)
<span class="comment">#相当于：</span>
kw = &#123; <span class="string">&#x27;base&#x27;</span>: <span class="number">2</span> &#125;
<span class="built_in">int</span>(<span class="string">&#x27;10010&#x27;</span>, **kw)</code></pre>
<p>当传入：</p>
<pre><code class="highlight python">max2 = functools.partial(<span class="built_in">max</span>, <span class="number">10</span>)

<span class="comment">#实际上会把10作为\*args的一部分自动加到左边，也就是：</span>
max2(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)
<span class="comment">#相当于：</span>
args = (<span class="number">10</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)
<span class="built_in">max</span>(*args)
<span class="comment">#结果为10。</span></code></pre>
<h2 id="模块"><a class="markdownIt-Anchor" href="#模块"></a> 模块</h2>
<p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。</p>
<p><strong>模块</strong></p>
<ul>
<li>
<p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，<strong>一个.py文件就称之为一个模块</strong>（Module）。</p>
</li>
<li>
<p>使用模块最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。</p>
</li>
<li>
<p><strong>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突</strong>。但是也要注意，尽量不要与内置函数名字冲突。点这里 <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/functions.html#built-in-functions">查看</a> Python的所有内置函数。</p>
</li>
</ul>
<p><strong>包</strong></p>
<ul>
<li>为了<strong>避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包</strong>（Package）。</li>
</ul>
<blockquote>
<p>举个例子，一个abc.py的文件就是一个名字叫abc的模块，一个xyz.py的文件就是一个名字叫xyz的模块</p>
</blockquote>
<ul>
<li>
<p>现在，假设我们的abc和xyz这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，比如mycompany，按照如下目录存放：</p>
</li>
<li>
<p>引入了包以后，<strong>只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突</strong>。现在，abc.py模块的名字就变成了mycompany.abc，类似的，xyz.py的模块名变成了mycompany.xyz。</p>
</li>
</ul>
<p>请注意，<strong>每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的</strong>，否则，Python就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是mycompany</p>
<p>类似的，可以有多级目录，组成多级层次的包结构。比如如下的目录结构：</p>
<blockquote>
<p>文件www.py的模块名就是mycompany.web.www，两个文件utils.py的模块名分别是mycompany.utils和mycompany.web.utils。</p>
</blockquote>
<blockquote>
<p><strong>自己创建模块时要注意命名，不能和Python自带的模块名称冲突</strong>。例如，系统自带了sys模块，<a target="_blank" rel="noopener" href="http://xn--sys-628d3h362a9f56aw1q4qn0uezn8b1w7afm7a.py">自己的模块就不可命名为sys.py</a>，否则将无法导入系统自带的sys模块。</p>
</blockquote>
<h3 id="使用模块"><a class="markdownIt-Anchor" href="#使用模块"></a> 使用模块</h3>
<p>Python本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。</p>
<p>我们以内建的sys模块为例，编写一个hello的模块：</p>
<ul>
<li>第1行注释可以让这个hello.py文件直接在Unix/Linux/Mac上运行</li>
<li>第2行注释表示.py文件本身使用标准UTF-8编码</li>
<li>第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释</li>
<li>第6行使用__author__变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名</li>
</ul>
<blockquote>
<p>以上就是Python模块的标准文件模板，当然也可以全部删掉不写，但是，按标准办事肯定没错</p>
</blockquote>
<pre><code class="highlight python"><span class="comment">#!/usr/bin/env python3</span>
<span class="comment"># -*- coding: utf-8 -*-</span>

<span class="string">&#x27; a test module &#x27;</span>

__author__ = <span class="string">&#x27;Michael Liao&#x27;</span>

<span class="keyword">import</span> sys

<span class="keyword">def</span> <span class="title function_">test</span>():
    args = sys.argv
    <span class="keyword">if</span> <span class="built_in">len</span>(args)==<span class="number">1</span>:
        <span class="built_in">print</span>(<span class="string">&#x27;Hello, world!&#x27;</span>)
    <span class="keyword">elif</span> <span class="built_in">len</span>(args)==<span class="number">2</span>:
        <span class="built_in">print</span>(<span class="string">&#x27;Hello, %s!&#x27;</span> % args[<span class="number">1</span>])
    <span class="keyword">else</span>:
        <span class="built_in">print</span>(<span class="string">&#x27;Too many arguments!&#x27;</span>)

<span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:
    test()</code></pre>
<p>使用sys模块的第一步，就是导入该模块：</p>
<pre><code class="highlight python"><span class="keyword">import</span> sys</code></pre>
<p>导入sys模块后，我们就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。</p>
<p>sys模块有一个<strong>argv变量，用list存储了命令行的所有参数</strong>。argv至少有一个元素，因为<strong>第一个参数永远是该.py文件的名称</strong>，例如：</p>
<ul>
<li>运行python3 hello.py获得的sys.argv就是[‘<a target="_blank" rel="noopener" href="http://hello.py">hello.py</a>’]</li>
<li>运行python3 <a target="_blank" rel="noopener" href="http://hello.py">hello.py</a> Michael获得的sys.argv就是[‘<a target="_blank" rel="noopener" href="http://hello.py">hello.py</a>’, ‘Michael’]</li>
</ul>
<hr />
<p>最后，注意到这两行代码：</p>
<pre><code class="highlight python"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:
    test()</code></pre>
<p>当我们在命令行运行hello模块文件时，<strong>Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败</strong>，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p>
<p>我们可以用命令行运行hello.py看看效果：</p>
<pre><code class="highlight plaintext">$ python3 hello.py
Hello, world!
$ python hello.py Michael
Hello, Michael!</code></pre>
<p>如果启动Python交互环境，再导入hello模块：</p>
<pre><code class="highlight python">$ python3
Python <span class="number">3.4</span><span class="number">.3</span> (v3<span class="number">.4</span><span class="number">.3</span>:9b73f1c3e601, Feb <span class="number">23</span> <span class="number">2015</span>, 02:<span class="number">52</span>:03) 
[GCC <span class="number">4.2</span><span class="number">.1</span> (Apple Inc. build <span class="number">5666</span>) (dot <span class="number">3</span>)] on darwin
<span class="type">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.
<span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> hello
&gt;&gt;&gt;</code></pre>
<blockquote>
<p>导入时，没有打印Hello, word!，因为没有执行test()函数。</p>
</blockquote>
<p>调用hello.test()时，才能打印出Hello, word!：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>hello.test()
Hello, world!</code></pre>
<hr />
<p><strong>作用域</strong></p>
<p>在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。</p>
<p>正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等；</p>
<p>类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的__author__，__name__就是特殊变量，hello模块定义的文档注释也可以用特殊变量__doc__访问，我们自己的变量一般不要用这种变量名；</p>
<p>类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等；</p>
<p>之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</p>
<p>private函数或变量不应该被别人引用，那它们有什么用呢？请看例子：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">_private_1</span>(<span class="params">name</span>):
    <span class="keyword">return</span> <span class="string">&#x27;Hello, %s&#x27;</span> % name

<span class="keyword">def</span> <span class="title function_">_private_2</span>(<span class="params">name</span>):
    <span class="keyword">return</span> <span class="string">&#x27;Hi, %s&#x27;</span> % name

<span class="keyword">def</span> <span class="title function_">greeting</span>(<span class="params">name</span>):
    <span class="keyword">if</span> <span class="built_in">len</span>(name) &gt; <span class="number">3</span>:
        <span class="keyword">return</span> _private_1(name)
    <span class="keyword">else</span>:
        <span class="keyword">return</span> _private_2(name)</code></pre>
<p>我们在模块里公开greeting()函数，而把内部逻辑用private函数隐藏起来了，这样，调用greeting()函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即：</p>
<ul>
<li>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</li>
</ul>
<h3 id="安装第三方模块"><a class="markdownIt-Anchor" href="#安装第三方模块"></a> 安装第三方模块</h3>
<p><strong>在Python中，安装第三方模块，是通过包管理工具pip完成的</strong>。</p>
<p>如果你正在使用Mac或Linux，安装pip本身这个步骤就可以跳过了。</p>
<p>如果是Windows，则安装python时勾选pip和add python.exe to path即可</p>
<p>在命令提示符窗口下尝试运行pip，如果Windows提示未找到命令，可以重新运行安装程序添加pip。</p>
<blockquote>
<p>注意：Mac或Linux上有可能并存Python 3.x和Python 2.x，因此对应的pip命令是pip3。</p>
</blockquote>
<p>例如，我们要安装一个第三方库——Python Imaging Library，这是Python下非常强大的处理图像的工具库。不过，PIL目前只支持到Python 2.7，并且有年头没有更新了，因此，基于PIL的Pillow项目开发非常活跃，并且支持最新的Python 3。</p>
<p>一般来说，第三方库都会在Python官方的<a href="pypi.python.org">pypi.python.org</a>网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Pillow的名称叫Pillow，因此，安装Pillow的命令就是：</p>
<pre><code class="highlight python">pip install Pillow</code></pre>
<hr />
<p><strong>安装常用模块</strong></p>
<p>在使用Python时，我们经常需要用到很多第三方库，例如，上面提到的Pillow，以及MySQL驱动程序，Web框架Flask，科学计算Numpy等。用pip一个一个安装费时费力，还需要考虑兼容性。我们推荐直接使用Anaconda，这是一个基于Python的数据处理和科学计算平台，它已经内置了许多非常有用的第三方库，我们装上Anaconda，就相当于把数十个第三方模块自动安装好了，非常简单易用。</p>
<p>可以从Anaconda官网下载GUI安装包，安装包有500~600M，所以需要耐心等待下载。下载后直接安装，Anaconda会把系统Path中的python指向自己自带的Python，并且，Anaconda安装的第三方模块会安装在Anaconda自己的路径下，不影响系统已安装的Python目录。</p>
<p>安装好Anaconda后，重新打开命令行窗口，输入python，可以看到Anaconda的信息：</p>
<blockquote>
<p>可以尝试直接import numpy等已安装的第三方模块。</p>
</blockquote>
<p><strong>模块搜索路径</strong></p>
<p>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mymodule
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
ImportError: No module named mymodule</code></pre>
<p>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys
<span class="meta">&gt;&gt;&gt; </span>sys.path
[<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip&#x27;</span>, <span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6&#x27;</span>, ..., <span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages&#x27;</span>]</code></pre>
<p><strong>如果我们要添加自己的搜索目录</strong>，有两种方法：</p>
<ul>
<li>一是<strong>直接修改sys.path</strong>，添加要搜索的目录（这种方法是在运行时修改，运行结束后失效）：</li>
</ul>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys
<span class="meta">&gt;&gt;&gt; </span>sys.path.append(<span class="string">&#x27;/Users/michael/my_py_scripts&#x27;</span>)</code></pre>
<ul>
<li>第二种方法是<strong>设置环境变量PYTHONPATH</strong>，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。</li>
</ul>
<h4 id="配置其他镜像源"><a class="markdownIt-Anchor" href="#配置其他镜像源"></a> 配置其他镜像源</h4>
<p><a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a></p>
<pre><code class="highlight python">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 包名</code></pre>
<h2 id="面向对象编程"><a class="markdownIt-Anchor" href="#面向对象编程"></a> 面向对象编程</h2>
<p>面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。</p>
<p>面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p>
<p>而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p>
<p>在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。</p>
<hr />
<p>我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处。</p>
<p>假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个dict表示：</p>
<pre><code class="highlight python">std1 = &#123; <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">98</span> &#125;
std2 = &#123; <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">81</span> &#125;</code></pre>
<p>而处理学生成绩可以通过函数实现，比如打印学生的成绩：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">std</span>):
    <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (std[<span class="string">&#x27;name&#x27;</span>], std[<span class="string">&#x27;score&#x27;</span>]))</code></pre>
<p>如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是Student这种数据类型应该被视为一个对象，这个对象拥有name和score这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来。</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):

    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):
        <span class="variable language_">self</span>.name = name
        <span class="variable language_">self</span>.score = score

    <span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (<span class="variable language_">self</span>.name, <span class="variable language_">self</span>.score))</code></pre>
<p>给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：</p>
<pre><code class="highlight python">bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">59</span>)
lisa = Student(<span class="string">&#x27;Lisa Simpson&#x27;</span>, <span class="number">87</span>)
bart.print_score()
lisa.print_score()</code></pre>
<p>面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。Class是一种抽象概念，比如我们定义的Class——Student，是指学生这个概念，而实例（Instance）则是一个个具体的Student，比如，Bart Simpson和Lisa Simpson是两个具体的Student。</p>
<p>所以，面向对象的设计思想是抽象出Class，根据Class创建Instance。</p>
<p>面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法。</p>
<h3 id="类和实例"><a class="markdownIt-Anchor" href="#类和实例"></a> 类和实例</h3>
<p>面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。</p>
<p>仍以Student类为例，在Python中，定义类是通过class关键字：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">pass</span></code></pre>
<p>class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。</p>
<p>定义好了Student类，就可以根据Student类创建出Student的实例，创建实例是通过类名+()实现的：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>bart = Student()
<span class="meta">&gt;&gt;&gt; </span>bart
&lt;__main__.Student <span class="built_in">object</span> at <span class="number">0x10a67a590</span>&gt;
<span class="meta">&gt;&gt;&gt; </span>Student
&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Student&#x27;</span>&gt;</code></pre>
<p>可以看到，变量bart指向的就是一个Student的实例，后面的0x10a67a590是内存地址，每个object的地址都不一样，而Student本身则是一个类。</p>
<p><strong>可以自由地给一个实例变量绑定属性</strong>，比如，给实例bart绑定一个name属性：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>bart.name = <span class="string">&#x27;Bart Simpson&#x27;</span>
<span class="meta">&gt;&gt;&gt; </span>bart.name
<span class="string">&#x27;Bart Simpson&#x27;</span></code></pre>
<h4 id="__init__"><a class="markdownIt-Anchor" href="#__init__"></a> __init__</h4>
<p>由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):

    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):
        <span class="variable language_">self</span>.name = name
        <span class="variable language_">self</span>.score = score</code></pre>
<blockquote>
<p><strong>注意：特殊方法“<strong>init</strong>”前后分别有两个下划线！！！</strong></p>
</blockquote>
<p>注意到__init__方法的<strong>第一个参数永远是self，表示创建的实例本身</strong>，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。</p>
<p>有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">59</span>)
<span class="meta">&gt;&gt;&gt; </span>bart.name
<span class="string">&#x27;Bart Simpson&#x27;</span>
<span class="meta">&gt;&gt;&gt; </span>bart.score
<span class="number">59</span></code></pre>
<p><strong>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数</strong>。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</p>
<hr />
<p><strong>数据封装</strong></p>
<p>面向对象编程的一个重要特点就是数据封装。在上面的Student类中，每个实例就拥有各自的name和score这些数据。我们可以通过函数来访问这些数据，比如打印一个学生的成绩：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">std</span>):
<span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (std.name, std.score))
...
<span class="meta">&gt;&gt;&gt; </span>print_score(bart)
Bart Simpson: <span class="number">59</span></code></pre>
<p>但是，既然Student实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在Student类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和Student类本身是关联起来的，我们称之为类的方法：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):

    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):
        <span class="variable language_">self</span>.name = name
        <span class="variable language_">self</span>.score = score

    <span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (<span class="variable language_">self</span>.name, <span class="variable language_">self</span>.score))</code></pre>
<p>要定义一个方法，除了第一个参数是self外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>bart.print_score()
Bart Simpson: <span class="number">59</span></code></pre>
<p>这样一来，我们从外部看Student类，就只需要知道，创建实例需要给出name和score，而如何打印，都是在Student类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。</p>
<p>封装的另一个好处是可以给Student类增加新的方法，比如get_grade：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):
    ...

    <span class="keyword">def</span> <span class="title function_">get_grade</span>(<span class="params">self</span>):
        <span class="keyword">if</span> <span class="variable language_">self</span>.score &gt;= <span class="number">90</span>:
            <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span>
        <span class="keyword">elif</span> <span class="variable language_">self</span>.score &gt;= <span class="number">60</span>:
            <span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span>
        <span class="keyword">else</span>:
            <span class="keyword">return</span> <span class="string">&#x27;C&#x27;</span></code></pre>
<p>同样的，get_grade方法可以直接在实例变量上调用，不需要知道内部实现细节：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):
        <span class="variable language_">self</span>.name = name
        <span class="variable language_">self</span>.score = score

    <span class="keyword">def</span> <span class="title function_">get_grade</span>(<span class="params">self</span>):
        <span class="keyword">if</span> <span class="variable language_">self</span>.score &gt;= <span class="number">90</span>:
            <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span>
        <span class="keyword">elif</span> <span class="variable language_">self</span>.score &gt;= <span class="number">60</span>:
            <span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span>
        <span class="keyword">else</span>:
            <span class="keyword">return</span> <span class="string">&#x27;C&#x27;</span>


lisa = Student(<span class="string">&#x27;Lisa&#x27;</span>, <span class="number">99</span>)
bart = Student(<span class="string">&#x27;Bart&#x27;</span>, <span class="number">59</span>)
<span class="built_in">print</span>(lisa.name, lisa.get_grade())
<span class="built_in">print</span>(bart.name, bart.get_grade())</code></pre>
<h3 id="访问限制"><a class="markdownIt-Anchor" href="#访问限制"></a> 访问限制</h3>
<p>在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。</p>
<p>但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">59</span>)
<span class="meta">&gt;&gt;&gt; </span>bart.score
<span class="number">59</span>
<span class="meta">&gt;&gt;&gt; </span>bart.score = <span class="number">99</span>
<span class="meta">&gt;&gt;&gt; </span>bart.score
<span class="number">99</span></code></pre>
<p><strong>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线</strong><code>__</code>，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):

    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):
        <span class="variable language_">self</span>.__name = name
        <span class="variable language_">self</span>.__score = score

    <span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (<span class="variable language_">self</span>.__name, <span class="variable language_">self</span>.__score))</code></pre>
<p>改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量.__name和实例变量.__score了：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">59</span>)
<span class="meta">&gt;&gt;&gt; </span>bart.__name
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
AttributeError: <span class="string">&#x27;Student&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;__name&#x27;</span></code></pre>
<p>这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。</p>
<p>但是如果外部代码要获取name和score怎么办？可以给Student类增加get_name和get_score这样的方法：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):
    ...

    <span class="keyword">def</span> <span class="title function_">get_name</span>(<span class="params">self</span>):
        <span class="keyword">return</span> <span class="variable language_">self</span>.__name

    <span class="keyword">def</span> <span class="title function_">get_score</span>(<span class="params">self</span>):
        <span class="keyword">return</span> <span class="variable language_">self</span>.__score</code></pre>
<p>如果又要允许外部代码修改score怎么办？可以再给Student类增加set_score方法：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):
    ...

    <span class="keyword">def</span> <span class="title function_">set_score</span>(<span class="params">self, score</span>):
        <span class="variable language_">self</span>.__score = score
</code></pre>
<p>你也许会问，原先那种直接通过bart.score = 99也可以修改啊，为什么要定义一个方法大费周折？</p>
<ul>
<li><strong>因为在方法中，可以对参数做检查，避免传入无效的参数</strong>：</li>
</ul>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):
    ...

    <span class="keyword">def</span> <span class="title function_">set_score</span>(<span class="params">self, score</span>):
        <span class="keyword">if</span> <span class="number">0</span> &lt;= score &lt;= <span class="number">100</span>:
            <span class="variable language_">self</span>.__score = score
        <span class="keyword">else</span>:
            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;bad score&#x27;</span>)</code></pre>
<p>需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，<strong>特殊变量是可以直接访问的</strong>，不是private变量，所以，不能用__name__、__score__这样的变量名。</p>
<p>有些时候，你会看到以<strong>一个下划线开头的实例变量名</strong>，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“<strong>虽然我可以被访问，但是，请把我视为私有变量，不要随意访问</strong>”。</p>
<p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。<strong>不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name</strong>，所以，仍然可以通过_Student__name来访问__name变量：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>bart._Student__name
<span class="string">&#x27;Bart Simpson&#x27;</span></code></pre>
<blockquote>
<p>但是<strong>强烈建议你不要这么干</strong>，因为不同版本的Python解释器可能会把__name改成不同的变量名。</p>
</blockquote>
<p>总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。</p>
<p>最后注意下面的这种错误写法：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">59</span>)
<span class="meta">&gt;&gt;&gt; </span>bart.get_name()
<span class="string">&#x27;Bart Simpson&#x27;</span>
<span class="meta">&gt;&gt;&gt; </span>bart.__name = <span class="string">&#x27;New Name&#x27;</span> <span class="comment"># 设置__name变量！&gt;&gt;&gt; bart.__name</span>
<span class="string">&#x27;New Name&#x27;</span></code></pre>
<p>表面上看，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量！内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给bart新增了一个__name变量。不信试试：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>bart.get_name() <span class="comment">#get_name()内部返回self.__name&#x27;</span>
Bart Simpson<span class="string">&#x27;</span></code></pre>
<h3 id="继承和多态"><a class="markdownIt-Anchor" href="#继承和多态"></a> 继承和多态</h3>
<p>在OOP程序设计中，<strong>当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类</strong>（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。</p>
<p>比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;Animal is running...&#x27;</span>)</code></pre>
<p>当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):
    <span class="keyword">pass</span>

<span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):
    <span class="keyword">pass</span></code></pre>
<p>对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是它的子类。Cat和Dog类似。</p>
<p>继承有什么好处？<strong>最大的好处是子类获得了父类的全部功能</strong>。由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法：</p>
<pre><code class="highlight python">dog = Dog()
dog.run()

cat = Cat()
cat.run()

<span class="comment">#运行结果如下：</span>
Animal <span class="keyword">is</span> running...
Animal <span class="keyword">is</span> running...</code></pre>
<p>当然，也可以对子类增加一些方法，比如Dog类：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):

    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;Dog is running...&#x27;</span>)

    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;Eating meat...&#x27;</span>)</code></pre>
<p>继承的第二个好处需要我们对代码做一点改进。你看到了，无论是Dog还是Cat，它们run()的时候，显示的都是Animal is running…，符合逻辑的做法是分别显示Dog is running…和Cat is running…，因此，对Dog和Cat类改进如下：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):

    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;Dog is running...&#x27;</span>)

<span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):

    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;Cat is running...&#x27;</span>)
        
<span class="comment">#再次运行，结果如下：</span>
Dog <span class="keyword">is</span> running...
Cat <span class="keyword">is</span> running...</code></pre>
<p><strong>当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run</strong>()。这样，我们就获得了继承的另一个好处：<strong>多态</strong>。</p>
<hr />
<p><strong>多态</strong></p>
<p>要理解什么是多态，我们首先要对数据类型再作一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：</p>
<pre><code class="highlight python">a = <span class="built_in">list</span>() <span class="comment"># a是list类型</span>
b = Animal() <span class="comment"># b是Animal类型</span>
c = Dog() <span class="comment"># c是Dog类型</span></code></pre>
<p>判断一个变量是否是某个类型可以用isinstance()判断：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(a, <span class="built_in">list</span>)
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(b, Animal)
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(c, Dog)
<span class="literal">True</span>
<span class="comment">#看来a、b、c确实对应着list、Animal、Dog这3种类型。</span>

<span class="comment">#看来c不仅仅是Dog，c还是Animal！</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(c, Animal)
<span class="literal">True</span></code></pre>
<blockquote>
<p>不过仔细想想，这是有道理的，因为Dog是从Animal继承下来的，当我们创建了一个Dog的实例c时，我们认为c的数据类型是Dog没错，但c同时也是Animal也没错，Dog本来就是Animal的一种</p>
</blockquote>
<p>所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>b = Animal()
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(b, Dog)
<span class="literal">False</span>
<span class="comment">#Dog可以看成Animal，但Animal不可以看成Dog</span></code></pre>
<p>要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个Animal类型的变量：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">run_twice</span>(<span class="params">animal</span>):
    animal.run()
    animal.run()</code></pre>
<p>当我们传入Animal的实例时，run_twice()就打印出：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>run_twice(Animal())
Animal <span class="keyword">is</span> running...
Animal <span class="keyword">is</span> running...</code></pre>
<p>当我们传入Dog的实例时，run_twice()就打印出：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>run_twice(Dog())
Dog <span class="keyword">is</span> running...
Dog <span class="keyword">is</span> running...</code></pre>
<p>当我们传入Cat的实例时，run_twice()就打印出：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>run_twice(Cat())
Cat <span class="keyword">is</span> running...
Cat <span class="keyword">is</span> running...</code></pre>
<p>看上去没啥意思，但是仔细想想，现在，如果我们再定义一个Tortoise类型，也从Animal派生：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Tortoise</span>(<span class="title class_ inherited__">Animal</span>):
    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;Tortoise is running slowly...&#x27;</span>)</code></pre>
<p>当我们调用run_twice()时，传入Tortoise的实例：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>run_twice(Tortoise())
Tortoise <span class="keyword">is</span> running slowly...
Tortoise <span class="keyword">is</span> running slowly...</code></pre>
<p>你会发现，新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。</p>
<p>多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思：</p>
<p>对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，<strong>这就是多态真正的威力：调用方只管调用，不管细节</strong>，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p>
<ul>
<li>
<p><strong>对扩展开放</strong>：允许新增Animal子类；</p>
</li>
<li>
<p><strong>对修改封闭</strong>：不需要修改依赖Animal类型的run_twice()等函数。</p>
</li>
</ul>
<p>继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系**。而任何类，最终都可以追溯到根类object**，这些继承关系看上去就像一颗倒着的树。比如如下的继承树：</p>
<hr />
<p><strong>静态语言VS动态语言</strong></p>
<p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。</p>
<p>对于Python这样的<strong>动态语言</strong>来说，则<strong>不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了</strong>：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Timer</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;Start...&#x27;</span>)</code></pre>
<p>这就是动态语言的“鸭子类型”，<strong>它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子</strong>。</p>
<p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。</p>
<h3 id="获取对象信息"><a class="markdownIt-Anchor" href="#获取对象信息"></a> 获取对象信息</h3>
<p>当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？</p>
<h4 id="使用type"><a class="markdownIt-Anchor" href="#使用type"></a> <strong>使用type</strong>()</h4>
<p>首先，我们来判断对象类型，使用type()函数：</p>
<p>基本类型都可以用type()判断：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">123</span>)
&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="string">&#x27;str&#x27;</span>)
&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="literal">None</span>)
&lt;<span class="built_in">type</span>(<span class="literal">None</span>) <span class="string">&#x27;NoneType&#x27;</span>&gt;</code></pre>
<p>如果一个变量指向函数或者类，也可以用type()判断：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="built_in">abs</span>)
&lt;<span class="keyword">class</span> <span class="string">&#x27;builtin_function_or_method&#x27;</span>&gt;
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a)
&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Animal&#x27;</span>&gt;</code></pre>
<p><strong>type()函数返回对应的Class类型</strong>。如果我们要在if语句中判断，就需要比较两个变量的type类型是否相同：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">123</span>)==<span class="built_in">type</span>(<span class="number">456</span>)
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">123</span>)==<span class="built_in">int</span>
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="string">&#x27;abc&#x27;</span>)==<span class="built_in">type</span>(<span class="string">&#x27;123&#x27;</span>)
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="string">&#x27;abc&#x27;</span>)==<span class="built_in">str</span>
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="string">&#x27;abc&#x27;</span>)==<span class="built_in">type</span>(<span class="number">123</span>)
<span class="literal">False</span></code></pre>
<p>判断基本数据类型可以直接写int，str等，但如果要判断一个对象是否是函数怎么办？可以<strong>使用types模块中定义的常量</strong>：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> types
<span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fn</span>():
<span class="meta">... </span>    <span class="keyword">pass</span>
...
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(fn)==types.FunctionType
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="built_in">abs</span>)==types.BuiltinFunctionType
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="keyword">lambda</span> x: x)==types.LambdaType
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>((x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)))==types.GeneratorType
<span class="literal">True</span></code></pre>
<h4 id="使用isinstance"><a class="markdownIt-Anchor" href="#使用isinstance"></a> 使用isinstance()</h4>
<p>对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数。</p>
<p>我们回顾上次的例子，如果继承关系是：</p>
<pre><code class="highlight plaintext">object -&gt; Animal -&gt; Dog -&gt; Husky</code></pre>
<p>那么，isinstance()就可以告诉我们，一个对象是否是某种类型。先创建3种类型的对象：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>a = Animal()
<span class="meta">&gt;&gt;&gt; </span>d = Dog()
<span class="meta">&gt;&gt;&gt; </span>h = Husky()</code></pre>
<p>然后，判断：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(h, Husky)
<span class="literal">True</span>
<span class="comment">#没有问题，因为h变量指向的就是Husky对象。</span>

<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(h, Dog)
<span class="literal">True</span></code></pre>
<p>h虽然自身是Husky类型，但由于Husky是从Dog继承下来的，所以，h也还是Dog类型。换句话说，<strong>isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上</strong>。</p>
<p>因此，我们可以确信，h还是Animal类型：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(h, Animal)
<span class="literal">True</span></code></pre>
<p>但是，d不是Husky类型：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(d, Husky)
<span class="literal">False</span></code></pre>
<p>能用type()判断的基本类型也可以用isinstance()判断：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">&#x27;a&#x27;</span>, <span class="built_in">str</span>)
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="number">123</span>, <span class="built_in">int</span>)
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">b&#x27;a&#x27;</span>, <span class="built_in">bytes</span>)
<span class="literal">True</span></code></pre>
<p>并且还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (<span class="built_in">list</span>, <span class="built_in">tuple</span>))
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="built_in">list</span>, <span class="built_in">tuple</span>))
<span class="literal">True</span></code></pre>
<blockquote>
<p><strong>总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”</strong></p>
</blockquote>
<h4 id="使用dir"><a class="markdownIt-Anchor" href="#使用dir"></a> 使用dir()</h4>
<p><strong>如果要获得一个对象的所有属性和方法，可以使用dir()函数</strong>，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(<span class="string">&#x27;ABC&#x27;</span>)
[<span class="string">&#x27;__add__&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>,..., <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;capitalize&#x27;</span>, <span class="string">&#x27;casefold&#x27;</span>,..., <span class="string">&#x27;zfill&#x27;</span>]</code></pre>
<p>类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法，所以，下面的代码是等价的：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="string">&#x27;ABC&#x27;</span>)
<span class="number">3</span>
<span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;ABC&#x27;</span>.__len__()
<span class="number">3</span></code></pre>
<p>我们自己写的类，如果也想用len(myObj)的话，就自己写一个__len__()方法：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">MyDog</span>(<span class="title class_ inherited__">object</span>):
<span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):
<span class="meta">... </span>        <span class="keyword">return</span> <span class="number">100</span>
...
<span class="meta">&gt;&gt;&gt; </span>dog = MyDog()
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(dog)
<span class="number">100</span></code></pre>
<p>剩下的都是普通属性或方法，比如lower()返回小写的字符串：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;ABC&#x27;</span>.lower()
<span class="string">&#x27;abc&#x27;</span></code></pre>
<p>仅仅把属性和方法列出来是不够的，<strong>配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态</strong>：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">MyObject</span>(<span class="title class_ inherited__">object</span>):
<span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):
<span class="meta">... </span>        <span class="variable language_">self</span>.x = <span class="number">9</span>
<span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">self</span>):
<span class="meta">... </span>        <span class="keyword">return</span> <span class="variable language_">self</span>.x * <span class="variable language_">self</span>.x
...
<span class="meta">&gt;&gt;&gt; </span>obj = MyObject()</code></pre>
<p>紧接着，可以测试该对象的属性：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(obj, <span class="string">&#x27;x&#x27;</span>) <span class="comment"># 有属性&#x27;x&#x27;吗？</span>
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span>obj.x
<span class="number">9</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(obj, <span class="string">&#x27;y&#x27;</span>) <span class="comment"># 有属性&#x27;y&#x27;吗？</span>
<span class="literal">False</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">setattr</span>(obj, <span class="string">&#x27;y&#x27;</span>, <span class="number">19</span>) <span class="comment"># 设置一个属性&#x27;y&#x27;</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(obj, <span class="string">&#x27;y&#x27;</span>) <span class="comment"># 有属性&#x27;y&#x27;吗？</span>
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(obj, <span class="string">&#x27;y&#x27;</span>) <span class="comment"># 获取属性&#x27;y&#x27;</span>
<span class="number">19</span>
<span class="meta">&gt;&gt;&gt; </span>obj.y <span class="comment"># 获取属性&#x27;y&#x27;</span>
<span class="number">19</span></code></pre>
<p>如果试图获取不存在的属性，会抛出AttributeError的错误：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(obj, <span class="string">&#x27;z&#x27;</span>) <span class="comment"># 获取属性&#x27;z&#x27;</span>
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
AttributeError: <span class="string">&#x27;MyObject&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;z&#x27;</span></code></pre>
<p>可以传入一个default参数，如果属性不存在，就返回默认值：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(obj, <span class="string">&#x27;z&#x27;</span>, <span class="number">404</span>) <span class="comment"># 获取属性&#x27;z&#x27;，如果不存在，返回默认值404</span>
<span class="number">404</span></code></pre>
<p>也可以获得对象的方法：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(obj, <span class="string">&#x27;power&#x27;</span>) <span class="comment"># 有属性&#x27;power&#x27;吗？</span>
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(obj, <span class="string">&#x27;power&#x27;</span>) <span class="comment"># 获取属性&#x27;power&#x27;</span>
&lt;bound method MyObject.power of &lt;__main__.MyObject <span class="built_in">object</span> at <span class="number">0x10077a6a0</span>&gt;&gt;
<span class="meta">&gt;&gt;&gt; </span>fn = <span class="built_in">getattr</span>(obj, <span class="string">&#x27;power&#x27;</span>) <span class="comment"># 获取属性&#x27;power&#x27;并赋值到变量fn</span>
<span class="meta">&gt;&gt;&gt; </span>fn <span class="comment"># fn指向obj.power</span>
&lt;bound method MyObject.power of &lt;__main__.MyObject <span class="built_in">object</span> at <span class="number">0x10077a6a0</span>&gt;&gt;
<span class="meta">&gt;&gt;&gt; </span>fn() <span class="comment"># 调用fn()与调用obj.power()是一样的</span>
<span class="number">81</span></code></pre>
<p>通过内置的一系列函数，我们可以对任意一个Python对象进行剖析，拿到其内部的数据。要注意的是，只有在不知道对象信息的时候，我们才会去获取对象信息。如果可以直接写：</p>
<pre><code class="highlight python"><span class="built_in">sum</span> = obj.x + obj.y</code></pre>
<p>就不要写：</p>
<pre><code class="highlight python"><span class="built_in">sum</span> = <span class="built_in">getattr</span>(obj, <span class="string">&#x27;x&#x27;</span>) + <span class="built_in">getattr</span>(obj, <span class="string">&#x27;y&#x27;</span>)</code></pre>
<p>一个正确的用法的例子如下：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">readImage</span>(<span class="params">fp</span>):
    <span class="keyword">if</span> <span class="built_in">hasattr</span>(fp, <span class="string">&#x27;read&#x27;</span>):
        <span class="keyword">return</span> readData(fp)
    <span class="keyword">return</span> <span class="literal">None</span></code></pre>
<p>假设我们希望从文件流fp中读取图像，我们首先要判断该fp对象是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取。hasattr()就派上了用场。</p>
<p>请注意，在Python这类动态语言中，根据鸭子类型，有read()方法，不代表该fp对象就是一个文件流，它也可能是网络流，也可能是内存中的一个字节流，但只要read()方法返回的是有效的图像数据，就不影响读取图像的功能。</p>
<h3 id="实例属性和类属性"><a class="markdownIt-Anchor" href="#实例属性和类属性"></a> 实例属性和类属性</h3>
<p>由于Python是动态语言，根据类创建的实例可以任意绑定属性。</p>
<p>给实例绑定属性的方法是通过实例变量，或者通过self变量：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):
        <span class="variable language_">self</span>.name = name

s = Student(<span class="string">&#x27;Bob&#x27;</span>)
s.score = <span class="number">90</span></code></pre>
<p>但是，如果Student类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归Student类所有：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):
    name = <span class="string">&#x27;Student&#x27;</span></code></pre>
<p>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):
<span class="meta">... </span>    name = <span class="string">&#x27;Student&#x27;</span>
...
<span class="meta">&gt;&gt;&gt; </span>s = Student() <span class="comment"># 创建实例s</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.name) <span class="comment"># 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span>
Student
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Student.name) <span class="comment"># 打印类的name属性</span>
Student
<span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">&#x27;Michael&#x27;</span> <span class="comment"># 给实例绑定name属性</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.name) <span class="comment"># 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span>
Michael
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Student.name) <span class="comment"># 但是类属性并未消失，用Student.name仍然可以访问</span>
Student
<span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> s.name <span class="comment"># 如果删除实例的name属性</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.name) <span class="comment"># 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span>
Student</code></pre>
<blockquote>
<p>从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p>
</blockquote>
<p><strong>练习</strong></p>
<p>为了统计学生人数，可以给Student类增加一个类属性，每创建一个实例，该属性自动增加：</p>
<pre><code class="highlight python"><span class="comment"># -*- coding: utf-8 -*-</span>
<span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):
    count = <span class="number">0</span>

    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):
        <span class="variable language_">self</span>.name = name
        Student.count = Student.count+<span class="number">1</span></code></pre>
<h2 id="面向对象高级编程"><a class="markdownIt-Anchor" href="#面向对象高级编程"></a> 面向对象高级编程</h2>
<h3 id="使用__slots__"><a class="markdownIt-Anchor" href="#使用__slots__"></a> 使用__slots__</h3>
<p>正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。先定义class：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">pass</span></code></pre>
<p>然后，尝试给实例绑定一个属性：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s = Student()
<span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">&#x27;Michael&#x27;</span> <span class="comment"># 动态给实例绑定一个属性</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.name)
Michael</code></pre>
<p>还可以尝试给实例绑定一个方法：</p>
<ul>
<li>这里之所以要使用MethodType方法是因为，如果只像赋值类方法一样给实例赋值方法，self参数是无法正常使用的。</li>
</ul>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">set_age</span>(<span class="params">self, age</span>): <span class="comment"># 定义一个函数作为实例方法</span>
<span class="meta">... </span>    <span class="variable language_">self</span>.age = age
...
<span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> MethodType
<span class="meta">&gt;&gt;&gt; </span>s.set_age = MethodType(set_age, s) <span class="comment"># 给实例绑定一个方法</span>
<span class="meta">&gt;&gt;&gt; </span>s.set_age(<span class="number">25</span>) <span class="comment"># 调用实例方法</span>
<span class="meta">&gt;&gt;&gt; </span>s.age <span class="comment"># 测试结果</span>
<span class="number">25</span>

<span class="comment">#错误的示范，提示缺少参数</span>
&gt;&gt;&gt;s.set_age =set_age
&gt;&gt;&gt;s.set_age(<span class="number">15</span>)
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
TypeError: set_age() missing <span class="number">1</span> required positional argument: <span class="string">&#x27;age&#x27;</span>
<span class="comment">#只能这样使用</span>
&gt;&gt;&gt;s.set_age(s,<span class="number">15</span>)
&gt;&gt;&gt;s.age
<span class="number">15</span></code></pre>
<p>但是，给一个实例绑定的方法，对另一个实例是不起作用的：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s2 = Student() <span class="comment"># 创建新的实例</span>
<span class="meta">&gt;&gt;&gt; </span>s2.set_age(<span class="number">25</span>) <span class="comment"># 尝试调用方法</span>
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
AttributeError: <span class="string">&#x27;Student&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;set_age&#x27;</span></code></pre>
<p>为了给所有实例都绑定方法，可以给class绑定方法：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">set_score</span>(<span class="params">self, score</span>):
<span class="meta">... </span>    <span class="variable language_">self</span>.score = score
...
<span class="meta">&gt;&gt;&gt; </span>Student.set_score = set_score</code></pre>
<p>给class绑定方法后，所有实例均可调用：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s.set_score(<span class="number">100</span>)
<span class="meta">&gt;&gt;&gt; </span>s.score
<span class="number">100</span>
<span class="meta">&gt;&gt;&gt; </span>s2.set_score(<span class="number">99</span>)
<span class="meta">&gt;&gt;&gt; </span>s2.score
<span class="number">99</span></code></pre>
<p>通常情况下，上面的set_score方法可以直接定义在class中，但动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。</p>
<hr />
<p><strong>使用__slots__</strong></p>
<p>但是，如果我们想要限制实例的属性怎么办？比如，只允许对Student实例添加name和age属性。</p>
<p>为了达到限制的目的，<strong>Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性</strong>：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):
    __slots__ = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>) <span class="comment"># 用tuple定义允许绑定的属性名称</span></code></pre>
<p>然后，我们试试：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s = Student() <span class="comment"># 创建新的实例</span>
<span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">&#x27;Michael&#x27;</span> <span class="comment"># 绑定属性&#x27;name&#x27;</span>
<span class="meta">&gt;&gt;&gt; </span>s.age = <span class="number">25</span> <span class="comment"># 绑定属性&#x27;age&#x27;</span>
<span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">99</span> <span class="comment"># 绑定属性&#x27;score&#x27;</span>
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
AttributeError: <span class="string">&#x27;Student&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;score&#x27;</span></code></pre>
<p>由于’score’没有被放到__slots__中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。</p>
<blockquote>
<p>使用__slots__要注意，<strong>slots</strong><strong>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的</strong>：</p>
</blockquote>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">GraduateStudent</span>(<span class="title class_ inherited__">Student</span>):
<span class="meta">... </span>    <span class="keyword">pass</span>
...
<span class="meta">&gt;&gt;&gt; </span>g = GraduateStudent()
<span class="meta">&gt;&gt;&gt; </span>g.score = <span class="number">9999</span></code></pre>
<p>除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。</p>
<h3 id="使用property"><a class="markdownIt-Anchor" href="#使用property"></a> 使用@property</h3>
<p>在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改：</p>
<pre><code class="highlight python">s = Student()
s.score = <span class="number">9999</span></code></pre>
<p>这显然不合逻辑。为了限制score的范围，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):

    <span class="keyword">def</span> <span class="title function_">get_score</span>(<span class="params">self</span>):
         <span class="keyword">return</span> <span class="variable language_">self</span>._score

    <span class="keyword">def</span> <span class="title function_">set_score</span>(<span class="params">self, value</span>):
        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):
            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must be an integer!&#x27;</span>)
        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:
            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must between 0 ~ 100!&#x27;</span>)
        <span class="variable language_">self</span>._score = value</code></pre>
<p>现在，对任意的Student实例进行操作，就不能随心所欲地设置score了：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s = Student()
<span class="meta">&gt;&gt;&gt; </span>s.set_score(<span class="number">60</span>) <span class="comment"># ok!</span>
<span class="meta">&gt;&gt;&gt; </span>s.get_score()
<span class="number">60</span>
<span class="meta">&gt;&gt;&gt; </span>s.set_score(<span class="number">9999</span>)
Traceback (most recent call last):
  ...
ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span>!</code></pre>
<p>但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。</p>
<p>有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的Python程序员来说，这是必须要做到的！</p>
<p>还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。<strong>Python内置的@property装饰器就是负责把一个方法变成属性调用的</strong>：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):

<span class="meta">    @property</span>
    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self</span>):
        <span class="keyword">return</span> <span class="variable language_">self</span>._score

<span class="meta">    @score.setter</span>
    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self, value</span>):
        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):
            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must be an integer!&#x27;</span>)
        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:
            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must between 0 ~ 100!&#x27;</span>)
        <span class="variable language_">self</span>._score = value</code></pre>
<p>@property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s = Student()
<span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">60</span> <span class="comment"># OK，实际转化为s.set_score(60)</span>
<span class="meta">&gt;&gt;&gt; </span>s.score <span class="comment"># OK，实际转化为s.get_score()</span>
<span class="number">60</span>
<span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">9999</span>
Traceback (most recent call last):
  ...
ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span>!</code></pre>
<p>注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。</p>
<p>还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):

<span class="meta">    @property</span>
    <span class="keyword">def</span> <span class="title function_">birth</span>(<span class="params">self</span>):
        <span class="keyword">return</span> <span class="variable language_">self</span>._birth

<span class="meta">    @birth.setter</span>
    <span class="keyword">def</span> <span class="title function_">birth</span>(<span class="params">self, value</span>):
        <span class="variable language_">self</span>._birth = value

<span class="meta">    @property</span>
    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):
        <span class="keyword">return</span> <span class="number">2015</span> - <span class="variable language_">self</span>._birth</code></pre>
<p>上面的birth是可读写属性，而age就是一个只读属性，因为age可以根据birth和当前时间计算出来。</p>
<h3 id="多重继承"><a class="markdownIt-Anchor" href="#多重继承"></a> 多重继承</h3>
<p>继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能。<br />
回忆一下Animal类层次的设计，假设我们要实现以下4种动物：</p>
<ul>
<li>Dog - 狗狗；</li>
<li>Bat - 蝙蝠；</li>
<li>Parrot - 鹦鹉；</li>
<li>Ostrich - 鸵鸟。</li>
</ul>
<p>如果按照哺乳动物和鸟类归类，我们可以设计出这样的类的层次：</p>
<p>但是如果按照“能跑”和“能飞”来归类，我们就应该设计出这样的类的层次：</p>
<p>如果要把上面的两种分类都包含进来，我们就得设计更多的层次：</p>
<ul>
<li>哺乳类：能跑的哺乳类，能飞的哺乳类；</li>
<li>鸟类：能跑的鸟类，能飞的鸟类。</li>
</ul>
<p>这么一来，类的层次就复杂了：</p>
<p>如果要再增加“宠物类”和“非宠物类”，这么搞下去，类的数量会呈指数增长，很明显这样设计是不行的。</p>
<p>正确的做法是采用多重继承。首先，主要的类层次仍按照哺乳类和鸟类设计：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">pass</span>

<span class="comment"># 大类:</span>
<span class="keyword">class</span> <span class="title class_">Mammal</span>(<span class="title class_ inherited__">Animal</span>):
    <span class="keyword">pass</span>

<span class="keyword">class</span> <span class="title class_">Bird</span>(<span class="title class_ inherited__">Animal</span>):
    <span class="keyword">pass</span>

<span class="comment"># 各种动物:</span>
<span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Mammal</span>):
    <span class="keyword">pass</span>

<span class="keyword">class</span> <span class="title class_">Bat</span>(<span class="title class_ inherited__">Mammal</span>):
    <span class="keyword">pass</span>

<span class="keyword">class</span> <span class="title class_">Parrot</span>(<span class="title class_ inherited__">Bird</span>):
    <span class="keyword">pass</span>

<span class="keyword">class</span> <span class="title class_">Ostrich</span>(<span class="title class_ inherited__">Bird</span>):
    <span class="keyword">pass</span></code></pre>
<p>现在，我们要给动物再加上Runnable和Flyable的功能，只需要先定义好Runnable和Flyable的类：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Runnable</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;Running...&#x27;</span>)

<span class="keyword">class</span> <span class="title class_">Flyable</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;Flying...&#x27;</span>)</code></pre>
<p>对于需要Runnable功能的动物，就多继承一个Runnable，例如Dog：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Dog</span>(Mammal, Runnable):
    <span class="keyword">pass</span></code></pre>
<p>对于需要Flyable功能的动物，就多继承一个Flyable，例如Bat：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Bat</span>(Mammal, Flyable):
    <span class="keyword">pass</span></code></pre>
<p>通过多重继承，一个子类就可以同时获得多个父类的所有功能。</p>
<h4 id="mixln设计"><a class="markdownIt-Anchor" href="#mixln设计"></a> Mixln设计</h4>
<p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。</p>
<p>为了更好地看出继承关系，我们把Runnable和Flyable改为RunnableMixIn和FlyableMixIn。类似的，你还可以定义出肉食动物CarnivorousMixIn和植食动物HerbivoresMixIn，让某个动物同时拥有好几个MixIn：<br />
MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</p>
<p>Python自带的很多库也使用了MixIn。举个例子，Python自带了TCPServer和UDPServer这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由ForkingMixIn和ThreadingMixIn提供。通过组合，我们就可以创造出合适的服务来。</p>
<p>比如，编写一个多进程模式的TCP服务，定义如下：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">MyTCPServer</span>(TCPServer, ForkingMixIn):
    <span class="keyword">pass</span></code></pre>
<p>编写一个多线程模式的UDP服务，定义如下：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">MyUDPServer</span>(UDPServer, ThreadingMixIn):
    <span class="keyword">pass</span></code></pre>
<p>如果你打算搞一个更先进的协程模型，可以编写一个CoroutineMixIn：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">MyTCPServer</span>(TCPServer, CoroutineMixIn):
    <span class="keyword">pass</span></code></pre>
<p>这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。</p>
<h4 id="多重继承排序原理"><a class="markdownIt-Anchor" href="#多重继承排序原理"></a> 多重继承排序原理</h4>
<p><strong>拓扑排序</strong></p>
<p>在图论中，拓扑排序(Topological Sorting) 是一个 有向无环图(DAG,Directed Acyclic Graph) 的所有顶点的线性序列。且该序列必须满足下面两个条件：</p>
<ul>
<li>每个顶点出现且只出现一次。</li>
<li>若存在一条从顶点A到顶点B的路径，那么在序列中顶点A出现在顶点B的前面。</li>
</ul>
<p>例如，下面这个图：</p>
<p>它是一个DAG图，那么如何写出它的拓扑顺序呢？这里说一种比较常用的方法：</p>
<ul>
<li>从DAG途中选择一个没有前驱(即入度为0)的顶点并输出</li>
<li>从图中删除该顶点和所有以它为起点的有向边。</li>
<li>重复1和2直到当前DAG图为空或当前途中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。</li>
</ul>
<p>于是，得到拓扑排序后的结果是{1,2,4,3,5}</p>
<hr />
<p><strong>python多重继承</strong></p>
<pre><code class="highlight python"><span class="comment">#!/usr/bin/env python3</span>
<span class="comment"># -*- coding: utf-8 -*-</span>
<span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;A foo&#x27;</span>)
    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;A bar&#x27;</span>)

<span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;B foo&#x27;</span>)
    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;B bar&#x27;</span>)

<span class="keyword">class</span> <span class="title class_">C1</span>(A,B):
    <span class="keyword">pass</span>

<span class="keyword">class</span> <span class="title class_">C2</span>(A,B):
    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;C2-bar&#x27;</span>)

<span class="keyword">class</span> <span class="title class_">D</span>(C1,C2):
    <span class="keyword">pass</span>

<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:
    <span class="built_in">print</span>(D.__mro__)
    d=D()
    d.foo()
    d.bar()</code></pre>
<p>首先，我们根据上面的继承关系构成一张图，如下</p>
<ul>
<li>找到入度为0的点，只有一个D，把D拿出来，把D相关的边剪掉</li>
<li>现在有两个入度为0的点(C1,C2)，取最左原则，拿C1，剪掉C1相关的边，这时候的排序是{D,C1}</li>
<li>现在我们看，入度为0的点(C2),拿C2,剪掉C2相关的边，这时候排序是{D,C1,C2}</li>
<li>接着看，入度为0的点(A,B),取最左原则，拿A，剪掉A相关的边，这时候的排序是{D,C1,C2,A}</li>
<li>继续，入度为0的点只有B，拿B，剪掉B相关的边，最后只剩下object</li>
<li>所以最后的排序是{D,C1,C2,A,B,object}</li>
</ul>
<p>我们执行上面的代码，发现print(D.mro)的结果也正是这样，而这也就是多重继承所使用的C3算法啦</p>
<pre><code class="highlight python">(&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.D&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.C1&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.C2&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.A&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.B&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;)A foo
C2-bar</code></pre>
<p>为了进一步熟悉这个拓扑排序的方法，我们再来一张图，试试看排序结果是怎样的，它继承的内容是否如你所想</p>
<pre><code class="highlight python"><span class="comment">#!/usr/bin/env python3</span>
<span class="comment"># -*- coding: utf-8 -*-</span>
<span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;A foo&#x27;</span>)
    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;A bar&#x27;</span>)

<span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;B foo&#x27;</span>)
    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;B bar&#x27;</span>)

<span class="keyword">class</span> <span class="title class_">C1</span>(<span class="title class_ inherited__">A</span>):
    <span class="keyword">pass</span>

<span class="keyword">class</span> <span class="title class_">C2</span>(<span class="title class_ inherited__">B</span>):
    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;C2-bar&#x27;</span>)

<span class="keyword">class</span> <span class="title class_">D</span>(C1,C2):
    <span class="keyword">pass</span>

<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:
    <span class="built_in">print</span>(D.__mro__)
    d=D()
    d.foo()
    d.bar()</code></pre>
<p>还是先根据继承关系构一个继承图</p>
<ul>
<li>找到入度为0的顶点，只有一个D，拿D，剪掉D相关的边</li>
<li>得到两个入度为0的顶点(C1,C2),根据最左原则，拿C1，剪掉C1相关的边，这时候序列为{D,C1}</li>
<li>接着看，入度为0的顶点有两个(A,C1),根据最左原则，拿A，剪掉A相关的边，这时候序列为{D,C1,A}</li>
<li>接着看，入度为0的顶点为C2,拿C2，剪掉C2相关的边，这时候序列为{D,C1,A,C2}</li>
<li>继续，入度为0的顶点为B，拿B，剪掉B相关的边，最后还有一个object</li>
<li>所以最后的序列为{D,C1,A,C2,B,object}</li>
</ul>
<p>最后，我们执行上面的代码，发现print(D.mro)的结果正如上面所计算的结果</p>
<pre><code class="highlight python">(&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.D&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.C1&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.A&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.C2&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.B&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;)A foo
A bar</code></pre>
<blockquote>
<p><strong>python继承顺序遵循C3算法，只要在一个地方找到了所需的内容，就不再继续查找</strong></p>
</blockquote>
<h3 id="定制类"><a class="markdownIt-Anchor" href="#定制类"></a> 定制类</h3>
<p>看到类似__slots__这种形如__xxx__的变量或者函数名就要注意，这些在Python中是有特殊用途的。</p>
<p>__slots__我们已经知道怎么用了，<strong>len</strong>()方法我们也知道是为了能让class作用于len()函数。</p>
<p>除此之外，Python的class中还有许多这样有特殊用途的函数，可以帮助我们定制类。</p>
<h4 id="__str__和__repr__"><a class="markdownIt-Anchor" href="#__str__和__repr__"></a> <strong>__str__和__repr__</strong></h4>
<p>我们先定义一个Student类，打印一个实例：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):
<span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):
<span class="meta">... </span>        <span class="variable language_">self</span>.name = name
...
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Student(<span class="string">&#x27;Michael&#x27;</span>))
&lt;__main__.Student <span class="built_in">object</span> at <span class="number">0x109afb190</span>&gt;</code></pre>
<p>打印出一堆&lt;<strong>main</strong>.Student object at 0x109afb190&gt;，不好看。</p>
<p>怎么才能打印得好看呢？只需要定义好__str__()方法，返回一个好看的字符串就可以了：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):
<span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):
<span class="meta">... </span>        <span class="variable language_">self</span>.name = name
<span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):
<span class="meta">... </span>        <span class="keyword">return</span> <span class="string">&#x27;Student object (name: %s)&#x27;</span> % <span class="variable language_">self</span>.name
...
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Student(<span class="string">&#x27;Michael&#x27;</span>))
Student <span class="built_in">object</span> (name: Michael)</code></pre>
<p>这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。</p>
<p>但是细心的朋友会发现直接敲变量不用print，打印出来的实例还是不好看：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">&#x27;Michael&#x27;</span>)
<span class="meta">&gt;&gt;&gt; </span>s
&lt;__main__.Student <span class="built_in">object</span> at <span class="number">0x109afb310</span>&gt;</code></pre>
<p>这是因为直接显示变量调用的不是__str__()，而是__repr__()，两者的区别是__str__()返回用户看到的字符串，而__repr__()返回程序开发者看到的字符串，也就是说，__repr__()是为调试服务的。</p>
<p>解决办法是再定义一个__repr__()。但是通常__str__()和__repr__()代码都是一样的，所以，有个偷懒的写法：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):
        <span class="variable language_">self</span>.name = name
    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):
        <span class="keyword">return</span> <span class="string">&#x27;Student object (name=%s)&#x27;</span> % <span class="variable language_">self</span>.name
    __repr__ = __str__</code></pre>
<hr />
<h4 id="__iter__"><a class="markdownIt-Anchor" href="#__iter__"></a> <strong>__iter__</strong></h4>
<p>如果一个类想被用于for … in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。</p>
<p>我们以斐波那契数列为例，写一个Fib类，可以作用于for循环：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Fib</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):
        <span class="variable language_">self</span>.a, <span class="variable language_">self</span>.b = <span class="number">0</span>, <span class="number">1</span> <span class="comment"># 初始化两个计数器a，b</span>

    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):
        <span class="keyword">return</span> <span class="variable language_">self</span> <span class="comment"># 实例本身就是迭代对象，故返回自己</span>

    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):
        <span class="variable language_">self</span>.a, <span class="variable language_">self</span>.b = <span class="variable language_">self</span>.b, <span class="variable language_">self</span>.a + <span class="variable language_">self</span>.b <span class="comment"># 计算下一个值</span>
        <span class="keyword">if</span> <span class="variable language_">self</span>.a &gt; <span class="number">100000</span>: <span class="comment"># 退出循环的条件</span>
            <span class="keyword">raise</span> StopIteration()
        <span class="keyword">return</span> <span class="variable language_">self</span>.a <span class="comment"># 返回下一个值</span></code></pre>
<p>现在，试试把Fib实例作用于for循环：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> Fib():
<span class="meta">... </span>    <span class="built_in">print</span>(n)
...
<span class="number">1</span>
<span class="number">1</span>
<span class="number">2</span>
<span class="number">3</span>
<span class="number">5</span>
...
<span class="number">46368</span>
<span class="number">75025</span></code></pre>
<h4 id="__getitem__"><a class="markdownIt-Anchor" href="#__getitem__"></a> <strong>__getitem__</strong></h4>
<p>Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>Fib()[<span class="number">5</span>]
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
TypeError: <span class="string">&#x27;Fib&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support indexing</code></pre>
<p>要表现得像list那样按照下标取出元素，需要实现__getitem__()方法：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Fib</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, n</span>):
        a, b = <span class="number">1</span>, <span class="number">1</span>
        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):
            a, b = b, a + b
        <span class="keyword">return</span> a</code></pre>
<p>现在，就可以按下标访问数列的任意一项了：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = Fib()
<span class="meta">&gt;&gt;&gt; </span>f[<span class="number">0</span>]
<span class="number">1</span>
<span class="meta">&gt;&gt;&gt; </span>f[<span class="number">1</span>]
<span class="number">1</span>
<span class="meta">&gt;&gt;&gt; </span>f[<span class="number">2</span>]
<span class="number">2</span>
<span class="meta">&gt;&gt;&gt; </span>f[<span class="number">3</span>]
<span class="number">3</span>
<span class="meta">&gt;&gt;&gt; </span>f[<span class="number">10</span>]
<span class="number">89</span>
<span class="meta">&gt;&gt;&gt; </span>f[<span class="number">100</span>]
<span class="number">573147844013817084101</span></code></pre>
<p>对于Fib却报错。原因是__getitem__()传入的参数可能是一个int，也可能是一个切片对象slice，所以要做判断：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Fib</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, n</span>):
        <span class="keyword">if</span> <span class="built_in">isinstance</span>(n, <span class="built_in">int</span>): <span class="comment"># n是索引</span>
            a, b = <span class="number">1</span>, <span class="number">1</span>
            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):
                a, b = b, a + b
            <span class="keyword">return</span> a
        <span class="keyword">if</span> <span class="built_in">isinstance</span>(n, <span class="built_in">slice</span>): <span class="comment"># n是切片</span>
            start = n.start
            stop = n.stop
            <span class="keyword">if</span> start <span class="keyword">is</span> <span class="literal">None</span>:
                start = <span class="number">0</span>
            a, b = <span class="number">1</span>, <span class="number">1</span>
            L = []
            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(stop):
                <span class="keyword">if</span> x &gt;= start:
                    L.append(a)
                a, b = b, a + b
            <span class="keyword">return</span> L</code></pre>
<p>现在试试Fib的切片：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = Fib()
<span class="meta">&gt;&gt;&gt; </span>f[<span class="number">0</span>:<span class="number">5</span>]
[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]
<span class="meta">&gt;&gt;&gt; </span>f[:<span class="number">10</span>]
[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>]</code></pre>
<p>但是没有对step参数作处理：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f[:<span class="number">10</span>:<span class="number">2</span>]
[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>]</code></pre>
<p>也没有对负数作处理，所以，要正确实现一个__getitem__()还是有很多工作要做的。</p>
<p>此外，如果把对象看成dict，<strong>getitem</strong>()的参数也可能是一个可以作key的object，例如str。</p>
<p>与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋值。最后，还有一个__delitem__()方法，用于删除某个元素。</p>
<p>总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。</p>
<h4 id="__getattr__"><a class="markdownIt-Anchor" href="#__getattr__"></a> __getattr__</h4>
<p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义Student类：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):
    
    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):
        <span class="variable language_">self</span>.name = <span class="string">&#x27;Michael&#x27;</span></code></pre>
<p>调用name属性，没问题，但是，调用不存在的score属性，就有问题了：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s = Student()
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.name)
Michael
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.score)
Traceback (most recent call last):
  ...
AttributeError: <span class="string">&#x27;Student&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;score&#x27;</span></code></pre>
<p>错误信息很清楚地告诉我们，没有找到score这个attribute。</p>
<p>要避免这个错误，除了可以加上一个score属性外，Python还有另一个机制，那就是写一个__getattr__()方法，动态返回一个属性。修改如下：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):

    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):
        <span class="variable language_">self</span>.name = <span class="string">&#x27;Michael&#x27;</span>

    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):
        <span class="keyword">if</span> attr==<span class="string">&#x27;score&#x27;</span>:
            <span class="keyword">return</span> <span class="number">99</span></code></pre>
<p>当调用不存在的属性时，比如score，Python解释器会试图调用__getattr__(self, ‘score’)来尝试获得属性，这样，我们就有机会返回score的值：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s = Student()
<span class="meta">&gt;&gt;&gt; </span>s.name
<span class="string">&#x27;Michael&#x27;</span>
<span class="meta">&gt;&gt;&gt; </span>s.score
<span class="number">99</span></code></pre>
<p>返回函数也是完全可以的：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):

    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):
        <span class="keyword">if</span> attr==<span class="string">&#x27;age&#x27;</span>:
            <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="number">25</span></code></pre>
<p>只是调用方式要变为：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s.age()
<span class="number">25</span>
</code></pre>
<p>注意，只有在没有找到属性的情况下，才调用__getattr__，已有的属性，比如name，不会在__getattr__中查找。</p>
<p>此外，注意到任意调用如s.abc都会返回None，这是因为我们定义的__getattr__默认返回就是None。要让class只响应特定的几个属性，我们就要按照约定，抛出AttributeError的错误：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):

    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):
        <span class="keyword">if</span> attr==<span class="string">&#x27;age&#x27;</span>:
            <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="number">25</span>
        <span class="keyword">raise</span> AttributeError(<span class="string">&#x27;\&#x27;Student\&#x27; object has no attribute \&#x27;%s\&#x27;&#x27;</span> % attr)</code></pre>
<p>这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。</p>
<p>这种完全动态调用的特性有什么实际作用呢？作用就是，可以针对完全动态的情况作调用。<br />
举个例子：</p>
<p>现在很多网站都搞REST API，比如新浪微博、豆瓣啥的，调用API的URL类似：</p>
<pre><code class="highlight python">http://api.server/user/friends
http://api.server/user/timeline/<span class="built_in">list</span></code></pre>
<p>如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。</p>
<p>利用完全动态的__getattr__，我们可以写出一个链式调用：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Chain</span>(<span class="title class_ inherited__">object</span>):

    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, path=<span class="string">&#x27;&#x27;</span></span>):
        <span class="variable language_">self</span>._path = path

    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, path</span>):
        <span class="keyword">return</span> Chain(<span class="string">&#x27;%s/%s&#x27;</span> % (<span class="variable language_">self</span>._path, path))

    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):
        <span class="keyword">return</span> <span class="variable language_">self</span>._path

    __repr__ = __str__</code></pre>
<p>试试：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>Chain().status.user.timeline.<span class="built_in">list</span>
<span class="string">&#x27;/status/user/timeline/list&#x27;</span></code></pre>
<p>这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变！</p>
<p>还有些REST API会把参数放到URL中，比如GitHub的API：</p>
<pre><code class="highlight python">GET /users/:user/repos</code></pre>
<p>调用时，需要把:user替换为实际用户名。如果我们能写出这样的链式调用：</p>
<pre><code class="highlight python">Chain().users(<span class="string">&#x27;michael&#x27;</span>).repos</code></pre>
<p>就可以非常方便地调用API了。有兴趣的童鞋可以试试写出来。</p>
<ul>
<li>注意.users(‘michael’)分为了两部，先.users调用getattr方法，然后返回Chain的实例，chain()又调用call方法，再返回一个Chain实例。</li>
</ul>
<p>代码如下：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Chain</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, path=<span class="string">&#x27;&#x27;</span></span>):
       <span class="variable language_">self</span>.__path = path

   <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, path</span>):
       <span class="keyword">return</span> Chain(<span class="string">&#x27;%s/%s&#x27;</span> % (<span class="variable language_">self</span>.__path, path))
   
   <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, path</span>):
       <span class="keyword">return</span> Chain(<span class="string">&#x27;%s/%s&#x27;</span> % (<span class="variable language_">self</span>.__path, path))

   <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):
       <span class="keyword">return</span> <span class="variable language_">self</span>.__path

   __repr__ = __str__

   <span class="built_in">print</span>(Chain().users(<span class="string">&#x27;michael&#x27;</span>).repos) <span class="comment"># /users/michael/repos</span></code></pre>
<h4 id="__call__"><a class="markdownIt-Anchor" href="#__call__"></a> __call__</h4>
<p>一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用instance.method()来调用。能不能直接在实例本身上调用呢？在Python中，答案是肯定的。</p>
<p>任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用。请看示例：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):
        <span class="variable language_">self</span>.name = name

    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;My name is %s.&#x27;</span> % <span class="variable language_">self</span>.name)</code></pre>
<p>调用方式如下：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">&#x27;Michael&#x27;</span>)
<span class="meta">&gt;&gt;&gt; </span>s() <span class="comment"># self参数不要传入</span>
My name <span class="keyword">is</span> Michael.</code></pre>
<p>__call__()还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。</p>
<p>如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。</p>
<p>那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个Callable对象，比如函数和我们上面定义的带有__call__()的类实例：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(Student())
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(<span class="built_in">max</span>)
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])
<span class="literal">False</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(<span class="literal">None</span>)
<span class="literal">False</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(<span class="string">&#x27;str&#x27;</span>)
<span class="literal">False</span></code></pre>
<p>通过callable()函数，我们就可以判断一个对象是否是“可调用”对象。</p>
<h3 id="使用枚举类"><a class="markdownIt-Anchor" href="#使用枚举类"></a> 使用枚举类</h3>
<p>当我们需要定义常量时，一个办法是用大写变量通过整数来定义，例如月份：</p>
<pre><code class="highlight python">JAN = <span class="number">1</span>
FEB = <span class="number">2</span>
MAR = <span class="number">3</span>
...
NOV = <span class="number">11</span>
DEC = <span class="number">12</span></code></pre>
<p>好处是简单，缺点是类型是int，并且仍然是变量。</p>
<p>更好的方法是为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了Enum类来实现这个功能：</p>
<pre><code class="highlight python"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum

Month = Enum(<span class="string">&#x27;Month&#x27;</span>, (<span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Mar&#x27;</span>, <span class="string">&#x27;Apr&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;Jun&#x27;</span>, <span class="string">&#x27;Jul&#x27;</span>, <span class="string">&#x27;Aug&#x27;</span>, <span class="string">&#x27;Sep&#x27;</span>, <span class="string">&#x27;Oct&#x27;</span>, <span class="string">&#x27;Nov&#x27;</span>, <span class="string">&#x27;Dec&#x27;</span>))</code></pre>
<p>这样我们就获得了Month类型的枚举类，可以直接使用Month.Jan来引用一个常量，或者枚举它的所有成员：</p>
<pre><code class="highlight python"><span class="keyword">for</span> name, member <span class="keyword">in</span> Month.__members__.items():
    <span class="built_in">print</span>(name, <span class="string">&#x27;=&gt;&#x27;</span>, member, <span class="string">&#x27;,&#x27;</span>, member.value)
    
<span class="comment">#输出</span>
Jan =&gt; Month.Jan , <span class="number">1</span>
Feb =&gt; Month.Feb , <span class="number">2</span>
Mar =&gt; Month.Mar , <span class="number">3</span>
Apr =&gt; Month.Apr , <span class="number">4</span>
May =&gt; Month.May , <span class="number">5</span>
Jun =&gt; Month.Jun , <span class="number">6</span>
Jul =&gt; Month.Jul , <span class="number">7</span>
Aug =&gt; Month.Aug , <span class="number">8</span>
Sep =&gt; Month.Sep , <span class="number">9</span>
Oct =&gt; Month.Oct , <span class="number">10</span>
Nov =&gt; Month.Nov , <span class="number">11</span>
Dec =&gt; Month.Dec , <span class="number">12</span></code></pre>
<blockquote>
<p><strong>value属性则是自动赋给成员的int常量，默认从1开始计数</strong>。</p>
</blockquote>
<p>如果需要更精确地控制枚举类型，<strong>可以从Enum派生出自定义类</strong>：</p>
<pre><code class="highlight python"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique

<span class="meta">@unique</span>
<span class="keyword">class</span> <span class="title class_">Weekday</span>(<span class="title class_ inherited__">Enum</span>):
    Sun = <span class="number">0</span> <span class="comment"># Sun的value被设定为0</span>
    Mon = <span class="number">1</span>
    Tue = <span class="number">2</span>
    Wed = <span class="number">3</span>
    Thu = <span class="number">4</span>
    Fri = <span class="number">5</span>
    Sat = <span class="number">6</span></code></pre>
<p>@<strong>unique装饰器可以帮助我们检查保证没有重复值</strong>。</p>
<p>访问这些枚举类型可以有若干种方法：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>day1 = Weekday.Mon
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(day1)
Weekday.Mon
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Weekday.Tue)
Weekday.Tue
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Weekday[<span class="string">&#x27;Tue&#x27;</span>])
Weekday.Tue
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Weekday.Tue.value)
<span class="number">2</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(day1 == Weekday.Mon)
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(day1 == Weekday.Tue)
<span class="literal">False</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Weekday(<span class="number">1</span>))
Weekday.Mon
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(day1 == Weekday(<span class="number">1</span>))
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span>Weekday(<span class="number">7</span>)
Traceback (most recent call last):
  ...
ValueError: <span class="number">7</span> <span class="keyword">is</span> <span class="keyword">not</span> a valid Weekday
<span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, member <span class="keyword">in</span> Weekday.__members__.items():
<span class="meta">... </span>    <span class="built_in">print</span>(name, <span class="string">&#x27;=&gt;&#x27;</span>, member)
...</code></pre>
<p>输出：</p>
<pre><code class="highlight plaintext">Sun =&gt; Weekday.Sun
Mon =&gt; Weekday.Mon
Tue =&gt; Weekday.Tue
Wed =&gt; Weekday.Wed
Thu =&gt; Weekday.Thu
Fri =&gt; Weekday.Fri
Sat =&gt; Weekday.Sat</code></pre>
<p>可见，既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量。</p>
<h3 id="使用元类"><a class="markdownIt-Anchor" href="#使用元类"></a> 使用元类</h3>
<h4 id="type"><a class="markdownIt-Anchor" href="#type"></a> type()</h4>
<p>比方说我们要定义一个Hello的class，就写一个hello.py模块：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Hello</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self, name=<span class="string">&#x27;world&#x27;</span></span>):
        <span class="built_in">print</span>(<span class="string">&#x27;Hello, %s.&#x27;</span> % name)</code></pre>
<p>当Python解释器载入hello模块时，就会依次执行该模块的所有语句，执行结果就是动态创建出一个Hello的class对象，测试如下：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> hello <span class="keyword">import</span> Hello
<span class="meta">&gt;&gt;&gt; </span>h = Hello()
<span class="meta">&gt;&gt;&gt; </span>h.hello()
Hello, world.
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(Hello))
&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(h))
&lt;<span class="keyword">class</span> <span class="string">&#x27;hello.Hello&#x27;</span>&gt;</code></pre>
<p>type()函数可以查看一个类型或变量的类型，Hello是一个class，它的类型就是type，而h是一个实例，它的类型就是class Hello。</p>
<p>我们说class的定义是运行时动态创建的，而创建class的方法就是使用type()函数。<br />
type()函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过type()函数创建出Hello类，而无需通过class Hello(object)…的定义：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fn</span>(<span class="params">self, name=<span class="string">&#x27;world&#x27;</span></span>): <span class="comment"># 先定义函数</span>
<span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;Hello, %s.&#x27;</span> % name)
...
<span class="meta">&gt;&gt;&gt; </span>Hello = <span class="built_in">type</span>(<span class="string">&#x27;Hello&#x27;</span>, (<span class="built_in">object</span>,), <span class="built_in">dict</span>(hello=fn)) <span class="comment"># 创建Hello class</span>
<span class="meta">&gt;&gt;&gt; </span>h = Hello()
<span class="meta">&gt;&gt;&gt; </span>h.hello()
Hello, world.
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(Hello))
&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(h))
&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Hello&#x27;</span>&gt;</code></pre>
<p>要创建一个class对象，<strong>type()函数依次传入3个参数</strong>：</p>
<ul>
<li>class的名称；</li>
<li>继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；</li>
<li>class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。</li>
</ul>
<p>通过<strong>type()函数创建的类和直接写class是完全一样的</strong>，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。</p>
<p>正常情况下，我们都用class Xxx…来定义类，但是，type()函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。</p>
<h4 id="metaclass"><a class="markdownIt-Anchor" href="#metaclass"></a> metaclass</h4>
<p>除了使用type()动态创建类以外，要<strong>控制类的创建行为，还可以使用metaclass</strong>。</p>
<p>metaclass，直译为<strong>元类</strong>，简单的解释就是：</p>
<ul>
<li>当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。</li>
</ul>
<p>但是如果我们想创建出类呢？那就必须根据metaclass创建出类，所以：先定义metaclass，然后创建类。</p>
<p>连接起来就是：先定义metaclass，就可以创建类，最后创建实例。</p>
<p>所以，metaclass允许你创建类或者修改类。换句话说，<strong>你可以把类看成是metaclass创建出来的“实例”</strong>。</p>
<p>metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用metaclass的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到。</p>
<p>我们先看一个简单的例子，这个metaclass可以给我们自定义的MyList增加一个add方法：</p>
<p>定义ListMetaclass，按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass：</p>
<pre><code class="highlight python"><span class="comment"># metaclass是类的模板，所以必须从`type`类型派生：class ListMetaclass(type):</span>
    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, attrs</span>):
        attrs[<span class="string">&#x27;add&#x27;</span>] = <span class="keyword">lambda</span> <span class="variable language_">self</span>, value: <span class="variable language_">self</span>.append(value)
        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, name, bases, attrs)</code></pre>
<p>我们先看一个简单的例子，这个metaclass可以给我们自定义的MyList增加一个add方法：</p>
<p>定义ListMetaclass，<strong>按照默认习惯，metaclass的类名总是以Metaclass结尾</strong>，以便清楚地表示这是一个metaclass：</p>
<pre><code class="highlight python"><span class="comment"># metaclass是类的模板，所以必须从`type`类型派生：</span>
<span class="keyword">class</span> <span class="title class_">ListMetaclass</span>(<span class="title class_ inherited__">type</span>):
    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, attrs</span>):
        attrs[<span class="string">&#x27;add&#x27;</span>] = <span class="keyword">lambda</span> <span class="variable language_">self</span>, value: <span class="variable language_">self</span>.append(value)
        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, name, bases, attrs)</code></pre>
<p>有了ListMetaclass，我们在定义类的时候还要指示使用ListMetaclass来定制类，传入关键字参数metaclass：</p>
<p>class MyList(list, metaclass=ListMetaclass):<br />
pass</p>
<p>当我们传入关键字参数metaclass时，魔术就生效了，它指示Python解释器在创建MyList时，要通过ListMetaclass.__new__()来创建，在此，<strong>我们可以修改类的定义</strong>，比如，加上新的方法，然后，返回修改后的定义。</p>
<p>__new__()方法<strong>接收到的参数</strong>依次是：</p>
<ol>
<li>当前准备创建的类的对象；</li>
<li>类的名字；</li>
<li>类继承的父类集合；</li>
<li>类的方法集合。</li>
</ol>
<p>测试一下MyList是否可以调用add()方法：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L = MyList()
<span class="meta">&gt;&gt;&gt; </span>L.add(<span class="number">1</span>)
&gt;&gt; L
[<span class="number">1</span>]</code></pre>
<p>而普通的list没有add()方法：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>L2 = <span class="built_in">list</span>()
<span class="meta">&gt;&gt;&gt; </span>L2.add(<span class="number">1</span>)
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
AttributeError: <span class="string">&#x27;list&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;add&#x27;</span></code></pre>
<p>动态修改有什么意义？直接在MyList定义中写上add()方法不是更简单吗？正常情况下，确实应该直接写，通过metaclass修改纯属变态。</p>
<p>但是，总会遇到需要通过metaclass修改类定义的。ORM就是一个典型的例子。</p>
<h4 id="定义orm"><a class="markdownIt-Anchor" href="#定义orm"></a> 定义ORM</h4>
<p>ORM全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。</p>
<p>要编写一个ORM框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。</p>
<p>让我们来尝试编写一个ORM框架。</p>
<p>编写底层模块的第一步，就是先把调用接口写出来。比如，使用者如果使用这个ORM框架，想定义一个User类来操作对应的数据库表User，我们期待他写出这样的代码：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">Model</span>):
    <span class="comment"># 定义类的属性到列的映射：</span>
    <span class="built_in">id</span> = IntegerField(<span class="string">&#x27;id&#x27;</span>)
    name = StringField(<span class="string">&#x27;username&#x27;</span>)
    email = StringField(<span class="string">&#x27;email&#x27;</span>)
    password = StringField(<span class="string">&#x27;password&#x27;</span>)

<span class="comment"># 创建一个实例：</span>
u = User(<span class="built_in">id</span>=<span class="number">12345</span>, name=<span class="string">&#x27;Michael&#x27;</span>, email=<span class="string">&#x27;test@orm.org&#x27;</span>, password=<span class="string">&#x27;my-pwd&#x27;</span>)
<span class="comment"># 保存到数据库：</span>
u.save()</code></pre>
<p>其中，父类Model和属性类型StringField、IntegerField是由ORM框架提供的，剩下的魔术方法比如save()全部由metaclass自动完成。虽然metaclass的编写会比较复杂，但ORM的使用者用起来却异常简单。</p>
<p>现在，我们就按上面的接口来实现该ORM。</p>
<p>首先来定义Field类，它负责保存数据库表的字段名和字段类型：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Field</span>(<span class="title class_ inherited__">object</span>):

    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, column_type</span>):
        <span class="variable language_">self</span>.name = name
        <span class="variable language_">self</span>.column_type = column_type

    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):
        <span class="keyword">return</span> <span class="string">&#x27;&lt;%s:%s&gt;&#x27;</span> % (<span class="variable language_">self</span>.__class__.__name__, <span class="variable language_">self</span>.name)</code></pre>
<p>在Field的基础上，进一步定义各种类型的Field，比如StringField，IntegerField等等：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">StringField</span>(<span class="title class_ inherited__">Field</span>):

    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):
        <span class="built_in">super</span>(StringField, <span class="variable language_">self</span>).__init__(name, <span class="string">&#x27;varchar(100)&#x27;</span>)

<span class="keyword">class</span> <span class="title class_">IntegerField</span>(<span class="title class_ inherited__">Field</span>):

    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):
        <span class="built_in">super</span>(IntegerField, <span class="variable language_">self</span>).__init__(name, <span class="string">&#x27;bigint&#x27;</span>)</code></pre>
<p>下一步，就是编写最复杂的ModelMetaclass了：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">ModelMetaclass</span>(<span class="title class_ inherited__">type</span>):

    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, attrs</span>):
        <span class="keyword">if</span> name==<span class="string">&#x27;Model&#x27;</span>:
            <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, name, bases, attrs)
        <span class="built_in">print</span>(<span class="string">&#x27;Found model: %s&#x27;</span> % name)
        mappings = <span class="built_in">dict</span>()
        <span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.items():
            <span class="keyword">if</span> <span class="built_in">isinstance</span>(v, Field):
                <span class="built_in">print</span>(<span class="string">&#x27;Found mapping: %s ==&gt; %s&#x27;</span> % (k, v))
                mappings[k] = v
        <span class="keyword">for</span> k <span class="keyword">in</span> mappings.keys():
            attrs.pop(k)
        attrs[<span class="string">&#x27;__mappings__&#x27;</span>] = mappings <span class="comment"># 保存属性和列的映射关系</span>
        attrs[<span class="string">&#x27;__table__&#x27;</span>] = name <span class="comment"># 假设表名和类名一致</span>
        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, name, bases, attrs)</code></pre>
<p>以及基类Model：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Model</span>(<span class="built_in">dict</span>, metaclass=ModelMetaclass):

    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kw</span>):
        <span class="built_in">super</span>(Model, <span class="variable language_">self</span>).__init__(**kw)

    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, key</span>):
        <span class="keyword">try</span>:
            <span class="keyword">return</span> <span class="variable language_">self</span>[key]
        <span class="keyword">except</span> KeyError:
            <span class="keyword">raise</span> AttributeError(<span class="string">r&quot;&#x27;Model&#x27; object has no attribute &#x27;%s&#x27;&quot;</span> % key)

    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, key, value</span>):
        <span class="variable language_">self</span>[key] = value

    <span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self</span>):
        fields = []
        params = []
        args = []
        <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="variable language_">self</span>.__mappings__.items():
            fields.append(v.name)
            params.append(<span class="string">&#x27;?&#x27;</span>)
            args.append(<span class="built_in">getattr</span>(<span class="variable language_">self</span>, k, <span class="literal">None</span>))
        sql = <span class="string">&#x27;insert into %s (%s) values (%s)&#x27;</span> % (<span class="variable language_">self</span>.__table__, <span class="string">&#x27;,&#x27;</span>.join(fields), <span class="string">&#x27;,&#x27;</span>.join(params))
        <span class="built_in">print</span>(<span class="string">&#x27;SQL: %s&#x27;</span> % sql)
        <span class="built_in">print</span>(<span class="string">&#x27;ARGS: %s&#x27;</span> % <span class="built_in">str</span>(args))</code></pre>
<p>当用户定义一个class User(Model)时，Python解释器首先在当前类User的定义中查找metaclass，如果没有找到，就继续在父类Model中查找metaclass，找到了，就使用Model中定义的metaclass的ModelMetaclass来创建User类，也就是说，metaclass可以隐式地继承到子类，但子类自己却感觉不到。</p>
<p>在ModelMetaclass中，一共做了几件事情：</p>
<ol>
<li>排除掉对Model类的修改；</li>
<li>在当前类（比如User）中查找定义的类的所有属性，如果找到一个Field属性，就把它保存到一个__mappings__的dict中，同时从类属性中删除该Field属性，否则，容易造成运行时错误（实例的属性会遮盖类的同名属性）；</li>
<li>把表名保存到__table__中，这里简化为表名默认为类名。</li>
</ol>
<p>在Model类中，就可以定义各种操作数据库的方法，比如save()，delete()，find()，update等等。</p>
<p>我们实现了save()方法，把一个实例保存到数据库中。因为有表名，属性到字段的映射和属性值的集合，就可以构造出INSERT语句。</p>
<p>编写代码试试：</p>
<pre><code class="highlight python">u = User(<span class="built_in">id</span>=<span class="number">12345</span>, name=<span class="string">&#x27;Michael&#x27;</span>, email=<span class="string">&#x27;test@orm.org&#x27;</span>, password=<span class="string">&#x27;my-pwd&#x27;</span>)
u.save()</code></pre>
<p>输出如下：</p>
<pre><code class="highlight python">Found model: User
Found mapping: email ==&gt; &lt;StringField:email&gt;
Found mapping: password ==&gt; &lt;StringField:password&gt;
Found mapping: <span class="built_in">id</span> ==&gt; &lt;IntegerField:uid&gt;
Found mapping: name ==&gt; &lt;StringField:username&gt;
SQL: insert into User (password,email,username,<span class="built_in">id</span>) values (?,?,?,?)
ARGS: [<span class="string">&#x27;my-pwd&#x27;</span>, <span class="string">&#x27;test@orm.org&#x27;</span>, <span class="string">&#x27;Michael&#x27;</span>, <span class="number">12345</span>]</code></pre>
<p>可以看到，save()方法已经打印出了可执行的SQL语句，以及参数列表，只需要真正连接到数据库，执行该SQL语句，就可以完成真正的功能。</p>
<p>不到100行代码，我们就通过metaclass实现了一个精简的ORM框架，是不是非常简单？</p>
<h2 id="错误调试测试"><a class="markdownIt-Anchor" href="#错误调试测试"></a> 错误/调试/测试</h2>
<p>在程序运行过程中，总会遇到各种各样的错误。</p>
<p>有的错误是程序编写有问题造成的，比如本来应该输出整数结果输出了字符串，这种错误我们通常称之为bug，bug是必须修复的。</p>
<p>有的错误是用户输入造成的，比如让用户输入email地址，结果得到一个空字符串，这种错误可以通过检查用户输入来做相应的处理。</p>
<p>还有一类错误是完全无法在程序运行过程中预测的，比如写入文件的时候，磁盘满了，写不进去了，或者从网络抓取数据，网络突然断掉了。这类错误也称为异常，在程序中通常是必须处理的，否则，程序会因为各种问题终止并退出。</p>
<p>Python内置了一套异常处理机制，来帮助我们进行错误处理。</p>
<p>此外，我们也需要跟踪程序的执行，查看变量的值是否正确，这个过程称为调试。Python的pdb可以让我们以单步方式执行代码。</p>
<p>最后，编写测试也很重要。有了良好的测试，就可以在程序修改后反复运行，确保程序输出符合我们编写的测试。</p>
<h3 id="错误处理"><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h3>
<p>在程序运行的过程中，如果发生了错误，可以事先约定返回一个错误代码，这样，就可以知道是否有错，以及出错的原因。在操作系统提供的调用中，返回错误码非常常见。比如打开文件的函数open()，成功时返回文件描述符（就是一个整数），出错时返回-1。</p>
<p>用错误码来表示是否出错十分不便，因为函数本身应该返回的正常结果和错误码混在一起，造成调用者必须用大量的代码来判断是否出错：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">foo</span>():
    r = some_function()
    <span class="keyword">if</span> r==(-<span class="number">1</span>):
        <span class="keyword">return</span> (-<span class="number">1</span>)
    <span class="comment"># do something</span>
    <span class="keyword">return</span> r

<span class="keyword">def</span> <span class="title function_">bar</span>():
    r = foo()
    <span class="keyword">if</span> r==(-<span class="number">1</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;Error&#x27;</span>)
    <span class="keyword">else</span>:
        <span class="keyword">pass</span></code></pre>
<p>一旦出错，还要一级一级上报，直到某个函数可以处理该错误（比如，给用户输出一个错误信息）。</p>
<p>所以高级语言通常都内置了一套try…except…finally…的错误处理机制，Python也不例外。</p>
<h4 id="try"><a class="markdownIt-Anchor" href="#try"></a> try</h4>
<p>让我们用一个例子来看看try的机制：</p>
<pre><code class="highlight python"><span class="keyword">try</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;try...&#x27;</span>)
    r = <span class="number">10</span> / <span class="number">0</span>
    <span class="built_in">print</span>(<span class="string">&#x27;result:&#x27;</span>, r)
<span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:
    <span class="built_in">print</span>(<span class="string">&#x27;except:&#x27;</span>, e)
<span class="keyword">finally</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;finally...&#x27;</span>)
<span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</code></pre>
<p>当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果<strong>执行出错</strong>，则<strong>后续代码不会继续执行</strong>，而是<strong>直接跳转</strong>至错误处理代码，即<strong>except语句块</strong>，执行完except后，如果有finally语句块，则<strong>最后执行finally语句块</strong>，至此，执行完毕。</p>
<p>上面的代码在计算10 / 0时会产生一个除法运算错误：</p>
<pre><code class="highlight python"><span class="keyword">try</span>...
<span class="keyword">except</span>: division by zero
<span class="keyword">finally</span>...
END</code></pre>
<p>从输出可以看到，当错误发生时，后续语句print(‘result:’, r)不会被执行，except由于捕获到ZeroDivisionError，因此被执行。最后，finally语句被执行。然后，程序继续按照流程往下走。</p>
<p>如果把除数0改成2，则执行结果如下：</p>
<pre><code class="highlight python"><span class="keyword">try</span>...
result: <span class="number">5</span>
<span class="keyword">finally</span>...
END</code></pre>
<p>由于没有错误发生，所以except语句块不会被执行，但是finally如果有，则一定会被执行（可以没有finally语句）。</p>
<p>你还可以猜测，错误应该有很多种类，如果发生了不同类型的错误，应该由不同的except语句块处理。没错，<strong>可以有多个except来捕获不同类型的错误</strong>：</p>
<pre><code class="highlight python"><span class="keyword">try</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;try...&#x27;</span>)
    r = <span class="number">10</span> / <span class="built_in">int</span>(<span class="string">&#x27;a&#x27;</span>)
    <span class="built_in">print</span>(<span class="string">&#x27;result:&#x27;</span>, r)
<span class="keyword">except</span> ValueError <span class="keyword">as</span> e:
    <span class="built_in">print</span>(<span class="string">&#x27;ValueError:&#x27;</span>, e)
<span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:
    <span class="built_in">print</span>(<span class="string">&#x27;ZeroDivisionError:&#x27;</span>, e)
<span class="keyword">finally</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;finally...&#x27;</span>)
<span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</code></pre>
<p>int()函数可能会抛出ValueError，所以我们用一个except捕获ValueError，用另一个except捕获ZeroDivisionError。</p>
<p>此外，<strong>如果没有错误发生，可以在except语句块后面加一个else</strong>，当没有错误发生时，会自动执行else语句：</p>
<pre><code class="highlight python"><span class="keyword">try</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;try...&#x27;</span>)
    r = <span class="number">10</span> / <span class="built_in">int</span>(<span class="string">&#x27;2&#x27;</span>)
    <span class="built_in">print</span>(<span class="string">&#x27;result:&#x27;</span>, r)
<span class="keyword">except</span> ValueError <span class="keyword">as</span> e:
    <span class="built_in">print</span>(<span class="string">&#x27;ValueError:&#x27;</span>, e)
<span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:
    <span class="built_in">print</span>(<span class="string">&#x27;ZeroDivisionError:&#x27;</span>, e)
<span class="keyword">else</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;no error!&#x27;</span>)
<span class="keyword">finally</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;finally...&#x27;</span>)
<span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</code></pre>
<p>Python的错误其实也是class，所有的错误类型都继承自<strong>BaseException</strong>，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。比如：</p>
<pre><code class="highlight python"><span class="keyword">try</span>:
    foo()
<span class="keyword">except</span> ValueError <span class="keyword">as</span> e:
    <span class="built_in">print</span>(<span class="string">&#x27;ValueError&#x27;</span>)
<span class="keyword">except</span> UnicodeError <span class="keyword">as</span> e:
    <span class="built_in">print</span>(<span class="string">&#x27;UnicodeError&#x27;</span>)</code></pre>
<p>第二个except永远也捕获不到UnicodeError，因为UnicodeError是ValueError的子类，如果有，也被第一个except给捕获了。</p>
<p>Python所有的错误都是从BaseException类派生的，常见的错误类型和继承关系看这里：</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy">https://docs.python.org/3/library/exceptions.html#exception-hierarchy</a></p>
<p><strong>继承树结构如下所示</strong></p>
<p>BaseException</p>
<ul>
<li>SystemExit</li>
<li>KeyboardInterrupt</li>
<li>GeneratorExit</li>
<li>Exception
<ul>
<li>StopIteration</li>
<li>StopAsyncIteration</li>
<li>ArithmeticError
<ul>
<li>FloatingPointError</li>
<li>OverflowError</li>
<li>ZeroDivisionError</li>
</ul>
</li>
<li>AssertionError</li>
<li>AttributeError</li>
<li>BufferError</li>
<li>EOFError</li>
<li>ImportError
<ul>
<li>ModuleNotFoundError</li>
</ul>
</li>
<li>LookupError
<ul>
<li>IndexError</li>
<li>KeyError</li>
</ul>
</li>
<li>MemoryError</li>
<li>NameError
<ul>
<li>UnboundLocalError</li>
</ul>
</li>
<li>OSError
<ul>
<li>BlockingIOError</li>
<li>ChildProcessError</li>
<li>ConnectionError
<ul>
<li>BrokenPipeError</li>
<li>ConnectionAbortedError</li>
<li>ConnectionRefusedError</li>
<li>ConnectionResetError</li>
</ul>
</li>
<li>FileExistsError</li>
<li>FileNotFoundError</li>
<li>InterruptedError</li>
<li>IsADirectoryError</li>
<li>NotADirectoryError</li>
<li>PermissionError</li>
<li>ProcessLookupError</li>
<li>TimeoutError</li>
</ul>
</li>
<li>ReferenceError</li>
<li>RuntimeError
<ul>
<li>NotImplementedError</li>
<li>RecursionError</li>
</ul>
</li>
<li>SyntaxError
<ul>
<li>IndentationError
<ul>
<li>TabError</li>
</ul>
</li>
</ul>
</li>
<li>SystemError</li>
<li>TypeError</li>
<li>ValueError
<ul>
<li>UnicodeError
<ul>
<li>UnicodeDecodeError</li>
<li>UnicodeEncodeError</li>
<li>UnicodeTranslateError</li>
</ul>
</li>
</ul>
</li>
<li>Warning
<ul>
<li>DeprecationWarning</li>
<li>PendingDeprecationWarning</li>
<li>RuntimeWarning</li>
<li>SyntaxWarning</li>
<li>UserWarning</li>
<li>FutureWarning</li>
<li>ImportWarning</li>
<li>UnicodeWarning</li>
<li>BytesWarning</li>
<li>ResourceWarning<br />
使用try…except捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数main()调用bar()，bar()调用foo()，结果foo()出错了，这时，只要main()捕获到了，就可以处理：</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):
    <span class="keyword">return</span> <span class="number">10</span> / <span class="built_in">int</span>(s)

<span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">s</span>):
    <span class="keyword">return</span> foo(s) * <span class="number">2</span>

<span class="keyword">def</span> <span class="title function_">main</span>():
    <span class="keyword">try</span>:
        bar(<span class="string">&#x27;0&#x27;</span>)
    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
        <span class="built_in">print</span>(<span class="string">&#x27;Error:&#x27;</span>, e)
    <span class="keyword">finally</span>:
        <span class="built_in">print</span>(<span class="string">&#x27;finally...&#x27;</span>)</code></pre>
<p>也就是说，<strong>不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以</strong>了。这样一来，就大大减少了写try…except…finally的麻烦。</p>
<h4 id="调用栈"><a class="markdownIt-Anchor" href="#调用栈"></a> 调用栈</h4>
<p>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。<a target="_blank" rel="noopener" href="http://xn--err-o99fu40ea.py">来看看err.py</a>：</p>
<pre><code class="highlight python"><span class="comment"># err.py:</span>
<span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):
    <span class="keyword">return</span> <span class="number">10</span> / <span class="built_in">int</span>(s)

<span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">s</span>):
    <span class="keyword">return</span> foo(s) * <span class="number">2</span>

<span class="keyword">def</span> <span class="title function_">main</span>():
    bar(<span class="string">&#x27;0&#x27;</span>)

main()</code></pre>
<p>执行，结果如下：</p>
<pre><code class="highlight python">$ python3 err.py
Traceback (most recent call last):
  File <span class="string">&quot;err.py&quot;</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;
    main()
  File <span class="string">&quot;err.py&quot;</span>, line <span class="number">9</span>, <span class="keyword">in</span> main
    bar(<span class="string">&#x27;0&#x27;</span>)
  File <span class="string">&quot;err.py&quot;</span>, line <span class="number">6</span>, <span class="keyword">in</span> bar
    <span class="keyword">return</span> foo(s) * <span class="number">2</span>
  File <span class="string">&quot;err.py&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> foo
    <span class="keyword">return</span> <span class="number">10</span> / <span class="built_in">int</span>(s)
ZeroDivisionError: division by zero</code></pre>
<p>出错并不可怕，可怕的是不知道哪里出错了。解读错误信息是定位错误的关键。我们从上往下可以看到整个错误的调用函数链：</p>
<p>错误信息第1行：</p>
<pre><code class="highlight python">Traceback (most recent call last):</code></pre>
<p>告诉我们这是错误的跟踪信息。</p>
<p>第2~3行：</p>
<pre><code class="highlight python">File <span class="string">&quot;err.py&quot;</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;
  main()</code></pre>
<p>调用main()出错了，在代码文件err.py的第11行代码，但原因是第9行：</p>
<pre><code class="highlight python">File <span class="string">&quot;err.py&quot;</span>, line <span class="number">9</span>, <span class="keyword">in</span> main
  bar(<span class="string">&#x27;0&#x27;</span>)</code></pre>
<p>调用bar(‘0’)出错了，在代码文件err.py的第9行代码，但原因是第6行：</p>
<pre><code class="highlight python">File <span class="string">&quot;err.py&quot;</span>, line <span class="number">6</span>, <span class="keyword">in</span> bar
  <span class="keyword">return</span> foo(s) * <span class="number">2</span></code></pre>
<p>原因是return foo(s) * 2这个语句出错了，但这还不是最终原因，继续往下看：</p>
<pre><code class="highlight python">File <span class="string">&quot;err.py&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> foo
  <span class="keyword">return</span> <span class="number">10</span> / <span class="built_in">int</span>(s)</code></pre>
<p>原因是return 10 / int(s)这个语句出错了，这是错误产生的源头，因为下面打印了：</p>
<pre><code class="highlight python">ZeroDivisionError: integer division <span class="keyword">or</span> modulo by zero</code></pre>
<p>根据错误类型ZeroDivisionError，我们判断，int(s)本身并没有出错，但是int(s)返回0，在计算10 / 0时出错，至此，找到错误源头</p>
<blockquote>
<p><strong>出错的时候，一定要分析错误的调用栈信息，才能定位错误的位置</strong>。</p>
</blockquote>
<h4 id="记录错误"><a class="markdownIt-Anchor" href="#记录错误"></a> 记录错误</h4>
<p>如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。</p>
<p>Python内置的<strong>logging模块</strong>可以非常容易地记录错误信息：</p>
<pre><code class="highlight python"><span class="comment"># err_logging.py</span>

<span class="keyword">import</span> logging

<span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):
    <span class="keyword">return</span> <span class="number">10</span> / <span class="built_in">int</span>(s)

<span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">s</span>):
    <span class="keyword">return</span> foo(s) * <span class="number">2</span>

<span class="keyword">def</span> <span class="title function_">main</span>():
    <span class="keyword">try</span>:
        bar(<span class="string">&#x27;0&#x27;</span>)
    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
        logging.exception(e)

main()
<span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</code></pre>
<p>同样是出错，但程序打印完错误信息后会继续执行，并正常退出：</p>
<pre><code class="highlight python">$ python3 err_logging.py
ERROR:root:division by zero
Traceback (most recent call last):
  File <span class="string">&quot;err_logging.py&quot;</span>, line <span class="number">13</span>, <span class="keyword">in</span> main
    bar(<span class="string">&#x27;0&#x27;</span>)
  File <span class="string">&quot;err_logging.py&quot;</span>, line <span class="number">9</span>, <span class="keyword">in</span> bar
    <span class="keyword">return</span> foo(s) * <span class="number">2</span>
  File <span class="string">&quot;err_logging.py&quot;</span>, line <span class="number">6</span>, <span class="keyword">in</span> foo
    <span class="keyword">return</span> <span class="number">10</span> / <span class="built_in">int</span>(s)
ZeroDivisionError: division by zero
END</code></pre>
<p>通过配置，logging还可以把错误记录到日志文件里，方便事后排查。</p>
<h4 id="抛出错误raise"><a class="markdownIt-Anchor" href="#抛出错误raise"></a> 抛出错误raise</h4>
<p>因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。</p>
<p>如果要抛出错误，首先根据需要，可以定义一个错误的class，选择好继承关系，然后，<strong>用raise语句抛出一个错误的实例</strong>：</p>
<pre><code class="highlight python"><span class="comment"># err_raise.py</span>
<span class="keyword">class</span> <span class="title class_">FooError</span>(<span class="title class_ inherited__">ValueError</span>):
    <span class="keyword">pass</span>

<span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):
    n = <span class="built_in">int</span>(s)
    <span class="keyword">if</span> n==<span class="number">0</span>:
        <span class="keyword">raise</span> FooError(<span class="string">&#x27;invalid value: %s&#x27;</span> % s)
    <span class="keyword">return</span> <span class="number">10</span> / n

foo(<span class="string">&#x27;0&#x27;</span>)</code></pre>
<p>执行，可以最后跟踪到我们自己定义的错误：</p>
<pre><code class="highlight python">$ python3 err_raise.py 
Traceback (most recent call last):
  File <span class="string">&quot;err_throw.py&quot;</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;
    foo(<span class="string">&#x27;0&#x27;</span>)
  File <span class="string">&quot;err_throw.py&quot;</span>, line <span class="number">8</span>, <span class="keyword">in</span> foo
    <span class="keyword">raise</span> FooError(<span class="string">&#x27;invalid value: %s&#x27;</span> % s)
__main__.FooError: invalid value: <span class="number">0</span></code></pre>
<p>只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如ValueError，TypeError），尽量使用Python内置的错误类型。</p>
<p>最后，我们来看另一种错误处理的方式：</p>
<pre><code class="highlight python"><span class="comment"># err_reraise.py</span>

<span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):
    n = <span class="built_in">int</span>(s)
    <span class="keyword">if</span> n==<span class="number">0</span>:
        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;invalid value: %s&#x27;</span> % s)
    <span class="keyword">return</span> <span class="number">10</span> / n

<span class="keyword">def</span> <span class="title function_">bar</span>():
    <span class="keyword">try</span>:
        foo(<span class="string">&#x27;0&#x27;</span>)
    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:
        <span class="built_in">print</span>(<span class="string">&#x27;ValueError!&#x27;</span>)
        <span class="keyword">raise</span>

bar()</code></pre>
<p>在bar()函数中，我们明明已经捕获了错误，但是，打印一个ValueError!后，又把错误通过raise语句抛出去了，这不有病么？</p>
<p>其实这种错误处理方式不但没病，而且相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。好比一个员工处理不了一个问题时，就把问题抛给他的老板，如果他的老板也处理不了，就一直往上抛，最终会抛给CEO去处理。</p>
<p>raise语句如果不带参数，就会把当前错误原样抛出。此外，在except中raise一个Error，还可以把一种类型的错误转化成另一种类型：</p>
<pre><code class="highlight python"><span class="keyword">try</span>:
    <span class="number">10</span> / <span class="number">0</span>
<span class="keyword">except</span> ZeroDivisionError:
    <span class="keyword">raise</span> ValueError(<span class="string">&#x27;input error!&#x27;</span>)</code></pre>
<p>只要是合理的转换逻辑就可以，但是，决不应该把一个IOError转换成毫不相干的ValueError。</p>
<h3 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h3>
<p>程序能一次写完并正常运行的概率很小，基本不超过1%。总会有各种各样的bug需要修正。有的bug很简单，看看错误信息就知道，有的bug很复杂，我们需要知道出错时，哪些变量的值是正确的，哪些变量的值是错误的，因此，需要一整套调试程序的手段来修复bug。</p>
<p>第一种方法简单直接粗暴有效，就是用print()把可能有问题的变量打印出来看看：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):
    n = <span class="built_in">int</span>(s)
    <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt; n = %d&#x27;</span> % n)
    <span class="keyword">return</span> <span class="number">10</span> / n

<span class="keyword">def</span> <span class="title function_">main</span>():
    foo(<span class="string">&#x27;0&#x27;</span>)

main()</code></pre>
<p>执行后在输出中查找打印的变量值：</p>
<pre><code class="highlight python">$ python err.py
<span class="meta">&gt;&gt;&gt; </span>n = <span class="number">0</span>
Traceback (most recent call last):
  ...
ZeroDivisionError: integer division <span class="keyword">or</span> modulo by zero</code></pre>
<p>用print()最大的坏处是将来还得删掉它，想想程序里到处都是print()，运行结果也会包含很多垃圾信息。所以，我们又有第二种方法。</p>
<h4 id="断言"><a class="markdownIt-Anchor" href="#断言"></a> 断言</h4>
<p>凡是用print()来辅助查看的地方，都可以用断言（assert）来替代：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):
    n = <span class="built_in">int</span>(s)
    <span class="keyword">assert</span> n != <span class="number">0</span>, <span class="string">&#x27;n is zero!&#x27;</span>
    <span class="keyword">return</span> <span class="number">10</span> / n

<span class="keyword">def</span> <span class="title function_">main</span>():
    foo(<span class="string">&#x27;0&#x27;</span>)</code></pre>
<p><strong>assert的意思是，表达式n != 0应该是True，否则，根据程序运行的逻辑，后面的代码肯定会出错</strong>。</p>
<p>如果断言失败，assert语句本身就会抛出AssertionError：</p>
<pre><code class="highlight python">$ python err.py
Traceback (most recent call last):
  ...
AssertionError: n <span class="keyword">is</span> zero!</code></pre>
<p>程序中如果到处充斥着assert，和print()相比也好不到哪去。不过，启动Python解释器时可以用-O参数来关闭assert：</p>
<pre><code class="highlight python">$ python -O err.py
Traceback (most recent call last):
  ...
ZeroDivisionError: division by zero</code></pre>
<blockquote>
<p>注意：<strong>断言的开关“-O”是英文大写字母O，不是数字0</strong>。</p>
</blockquote>
<p><strong>关闭后，你可以把所有的assert语句当成pass来看</strong>。</p>
<h4 id="logging"><a class="markdownIt-Anchor" href="#logging"></a> logging</h4>
<p>把print()替换为logging是第3种方式，和assert比，<strong>logging不会抛出错误，而且可以输出到文件</strong>：</p>
<pre><code class="highlight python"><span class="keyword">import</span> logging

s = <span class="string">&#x27;0&#x27;</span>
n = <span class="built_in">int</span>(s)
logging.info(<span class="string">&#x27;n = %d&#x27;</span> % n)
<span class="built_in">print</span>(<span class="number">10</span> / n)</code></pre>
<p><a target="_blank" rel="noopener" href="http://logging.info">logging.info</a>()就可以输出一段文本。运行，发现除了ZeroDivisionError，没有任何信息。怎么回事？</p>
<p>别急，在import logging之后添加一行配置再试试：</p>
<pre><code class="highlight python"><span class="keyword">import</span> logging
logging.basicConfig(level=logging.INFO)</code></pre>
<p>看到输出了：</p>
<pre><code class="highlight python">$ python err.py
INFO:root:n = <span class="number">0</span>
Traceback (most recent call last):
  File <span class="string">&quot;err.py&quot;</span>, line <span class="number">8</span>, <span class="keyword">in</span> &lt;module&gt;
    <span class="built_in">print</span>(<span class="number">10</span> / n)
ZeroDivisionError: division by zero</code></pre>
<p>这就是logging的好处，它允许你<strong>指定记录信息的级别</strong>，有<strong>debug，info，warning，error</strong>等几个级别，当我们指定level=INFO时，logging.debug就不起作用了。同理，指定level=WARNING后，debug和info就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</p>
<p>logging的另一个好处是<strong>通过简单的配置，一条语句可以同时输出到不同的地方</strong>，比如console和文件。</p>
<h4 id="pdb"><a class="markdownIt-Anchor" href="#pdb"></a> pdb</h4>
<p>第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。我们先准备好程序：</p>
<pre><code class="highlight python"><span class="comment"># err.py</span>
s = <span class="string">&#x27;0&#x27;</span>
n = <span class="built_in">int</span>(s)
<span class="built_in">print</span>(<span class="number">10</span> / n)</code></pre>
<p>然后启动：</p>
<pre><code class="highlight python">$ python -m pdb err.py
&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(<span class="number">2</span>)&lt;module&gt;()
-&gt; s = <span class="string">&#x27;0&#x27;</span></code></pre>
<p>以参数-m pdb启动后，pdb定位到下一步要执行的代码-&gt; s = ‘0’。输入命令l来查看代码：</p>
<pre><code class="highlight python">(Pdb) l
  <span class="number">1</span>     <span class="comment"># err.py</span>
  <span class="number">2</span>  -&gt; s = <span class="string">&#x27;0&#x27;</span>
  <span class="number">3</span>     n = <span class="built_in">int</span>(s)
  <span class="number">4</span>     <span class="built_in">print</span>(<span class="number">10</span> / n)</code></pre>
<p>输入命令n可以单步执行代码：</p>
<pre><code class="highlight python">(Pdb) n
&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(<span class="number">3</span>)&lt;module&gt;()
-&gt; n = <span class="built_in">int</span>(s)
(Pdb) n
&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(<span class="number">4</span>)&lt;module&gt;()
-&gt; <span class="built_in">print</span>(<span class="number">10</span> / n)</code></pre>
<p>任何时候都可以输入命令p 变量名来查看变量：</p>
<pre><code class="highlight python">(Pdb) p s
<span class="string">&#x27;0&#x27;</span>
(Pdb) p n
<span class="number">0</span></code></pre>
<p>输入命令q结束调试，退出程序：</p>
<pre><code class="highlight python">(Pdb) q</code></pre>
<p>这种通过pdb在命令行调试的方法理论上是万能的，但实在是太麻烦了，如果有一千行代码，要运行到第999行得敲多少命令啊。还好，我们还有另一种调试方法。</p>
<h4 id="pdbset_trace"><a class="markdownIt-Anchor" href="#pdbset_trace"></a> pdb.set_trace()</h4>
<p>这个方法也是用pdb，但是不需要单步执行，我们只需要import pdb，然后，在可能出错的地方放一个pdb.set_trace()，就可以设置一个断点：</p>
<pre><code class="highlight python"><span class="comment"># err.py</span>
<span class="keyword">import</span> pdb

s = <span class="string">&#x27;0&#x27;</span>
n = <span class="built_in">int</span>(s)
pdb.set_trace() <span class="comment"># 运行到这里会自动暂停</span>
<span class="built_in">print</span>(<span class="number">10</span> / n)</code></pre>
<p>运行代码，程序会自动在pdb.set_trace()暂停并进入pdb调试环境，可以用命令p查看变量，或者用命令c继续运行：</p>
<pre><code class="highlight python">$ python err.py 
&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(<span class="number">7</span>)&lt;module&gt;()
-&gt; <span class="built_in">print</span>(<span class="number">10</span> / n)
(Pdb) p n
<span class="number">0</span>
(Pdb) c
Traceback (most recent call last):
  File <span class="string">&quot;err.py&quot;</span>, line <span class="number">7</span>, <span class="keyword">in</span> &lt;module&gt;
    <span class="built_in">print</span>(<span class="number">10</span> / n)
ZeroDivisionError: division by zero</code></pre>
<p>这个方式比直接启动pdb单步调试效率要高很多，但也高不到哪去。</p>
<h4 id="ide"><a class="markdownIt-Anchor" href="#ide"></a> IDE</h4>
<p>如果要比较爽地设置断点、单步执行，就需要一个支持调试功能的IDE。目前比较好的Python IDE有：</p>
<p>Visual Studio Code：<a target="_blank" rel="noopener" href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>，需要安装Python插件。</p>
<p>PyCharm：<a target="_blank" rel="noopener" href="http://www.jetbrains.com/pycharm/">http://www.jetbrains.com/pycharm/</a></p>
<p>另外，Eclipse加上pydev插件也可以调试Python程序。</p>
<h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3>
<p>如果你听说过“测试驱动开发”（TDD：Test-Driven Development），单元测试就不陌生。</p>
<p>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。</p>
<p>比如对函数abs()，我们可以编写出以下几个测试用例：</p>
<ul>
<li>输入正数，比如1、1.2、0.99，期待返回值与输入相同；</li>
<li>输入负数，比如-1、-1.2、-0.99，期待返回值与输入相反；</li>
<li>输入0，期待返回0；</li>
<li>输入非数值类型，比如None、[]、{}，期待抛出TypeError。</li>
</ul>
<p>把上面的测试用例放到一个测试模块里，就是一个完整的单元测试。</p>
<p>如果单元测试通过，说明我们测试的这个函数能够正常工作。如果单元测试不通过，要么函数有bug，要么测试条件输入不正确，总之，需要修复使单元测试能够通过。</p>
<p>单元测试通过后有什么意义呢？如果我们对abs()函数代码做了修改，只需要再跑一遍单元测试，如果通过，说明我们的修改不会对abs()函数原有的行为造成影响，如果测试不通过，说明我们的修改与原有行为不一致，要么修改代码，要么修改测试。</p>
<p>这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。</p>
<p>我们来编写一个Dict类，这个类的行为和dict一致，但是可以通过属性来访问，用起来就像下面这样：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>d = <span class="type">Dict</span>(a=<span class="number">1</span>, b=<span class="number">2</span>)
<span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;a&#x27;</span>]
<span class="number">1</span>
<span class="meta">&gt;&gt;&gt; </span>d.a
<span class="number">1</span></code></pre>
<p>mydict.py代码如下：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">Dict</span>(<span class="title class_ inherited__">dict</span>):

    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kw</span>):
        <span class="built_in">super</span>().__init__(**kw)

    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, key</span>):
        <span class="keyword">try</span>:
            <span class="keyword">return</span> <span class="variable language_">self</span>[key]
        <span class="keyword">except</span> KeyError:
            <span class="keyword">raise</span> AttributeError(<span class="string">r&quot;&#x27;Dict&#x27; object has no attribute &#x27;%s&#x27;&quot;</span> % key)

    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, key, value</span>):
        <span class="variable language_">self</span>[key] = value</code></pre>
<p>为了编写单元测试，我们需要引入Python自带的unittest模块，编写mydict_test.py如下：</p>
<pre><code class="highlight python"><span class="keyword">import</span> unittest

<span class="keyword">from</span> mydict <span class="keyword">import</span> <span class="type">Dict</span>

<span class="keyword">class</span> <span class="title class_">TestDict</span>(unittest.TestCase):

    <span class="keyword">def</span> <span class="title function_">test_init</span>(<span class="params">self</span>):
        d = <span class="type">Dict</span>(a=<span class="number">1</span>, b=<span class="string">&#x27;test&#x27;</span>)
        <span class="variable language_">self</span>.assertEqual(d.a, <span class="number">1</span>)
        <span class="variable language_">self</span>.assertEqual(d.b, <span class="string">&#x27;test&#x27;</span>)
        <span class="variable language_">self</span>.assertTrue(<span class="built_in">isinstance</span>(d, <span class="built_in">dict</span>))

    <span class="keyword">def</span> <span class="title function_">test_key</span>(<span class="params">self</span>):
        d = <span class="type">Dict</span>()
        d[<span class="string">&#x27;key&#x27;</span>] = <span class="string">&#x27;value&#x27;</span>
        <span class="variable language_">self</span>.assertEqual(d.key, <span class="string">&#x27;value&#x27;</span>)

    <span class="keyword">def</span> <span class="title function_">test_attr</span>(<span class="params">self</span>):
        d = <span class="type">Dict</span>()
        d.key = <span class="string">&#x27;value&#x27;</span>
        <span class="variable language_">self</span>.assertTrue(<span class="string">&#x27;key&#x27;</span> <span class="keyword">in</span> d)
        <span class="variable language_">self</span>.assertEqual(d[<span class="string">&#x27;key&#x27;</span>], <span class="string">&#x27;value&#x27;</span>)

    <span class="keyword">def</span> <span class="title function_">test_keyerror</span>(<span class="params">self</span>):
        d = <span class="type">Dict</span>()
        <span class="keyword">with</span> <span class="variable language_">self</span>.assertRaises(KeyError):
            value = d[<span class="string">&#x27;empty&#x27;</span>]

    <span class="keyword">def</span> <span class="title function_">test_attrerror</span>(<span class="params">self</span>):
        d = <span class="type">Dict</span>()
        <span class="keyword">with</span> <span class="variable language_">self</span>.assertRaises(AttributeError):
            value = d.empty</code></pre>
<p>编写单元测试时，我们需要编写一个测试类，从unittest.TestCase继承。</p>
<p><strong>以test开头的方法就是测试方法</strong>，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。</p>
<p>对每一类测试都需要编写一个test_xxx()方法。由于unittest.TestCase提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是assertEqual()：</p>
<pre><code class="highlight python"><span class="variable language_">self</span>.assertEqual(<span class="built_in">abs</span>(-<span class="number">1</span>), <span class="number">1</span>) <span class="comment"># 断言函数返回的结果与1相等</span></code></pre>
<p>另一种重要的断言就是期待抛出指定类型的Error，比如通过d[‘empty’]访问不存在的key时，断言会抛出KeyError：</p>
<pre><code class="highlight python"><span class="keyword">with</span> <span class="variable language_">self</span>.assertRaises(KeyError):
    value = d[<span class="string">&#x27;empty&#x27;</span>]</code></pre>
<p>而通过d.empty访问不存在的key时，我们期待抛出AttributeError：</p>
<pre><code class="highlight python"><span class="keyword">with</span> <span class="variable language_">self</span>.assertRaises(AttributeError):
    value = d.empty</code></pre>
<p><strong>运行单元测试</strong></p>
<p>一旦编写好单元测试，我们就可以运行单元测试。最简单的运行方式是在mydict_test.py的最后加上两行代码：</p>
<pre><code class="highlight python"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:
    unittest.main()</code></pre>
<p>这样就可以把mydict_test.py当做正常的python脚本运行：</p>
<pre><code class="highlight python">$ python mydict_test.py</code></pre>
<p>另一种方法是在命令行通过参数-m unittest直接运行单元测试：</p>
<pre><code class="highlight python">$ python -m unittest mydict_test
.....
----------------------------------------------------------------------
Ran <span class="number">5</span> tests <span class="keyword">in</span> <span class="number">0.000</span>s

OK</code></pre>
<p>这是推荐的做法，因为这样可以一次批量运行很多单元测试，并且，有很多工具可以自动来运行这些单元测试。</p>
<h4 id="setup与teardown"><a class="markdownIt-Anchor" href="#setup与teardown"></a> setUp与tearDown</h4>
<p>可以在单元测试中编写两个特殊的setUp()和tearDown()方法。这两个方法会<strong>分别在每调用一个测试方法的前后分别被执行</strong>。</p>
<p>setUp()和tearDown()方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在setUp()方法中连接数据库，在tearDown()方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码：</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">TestDict</span>(unittest.TestCase):

    <span class="keyword">def</span> <span class="title function_">setUp</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;setUp...&#x27;</span>)

    <span class="keyword">def</span> <span class="title function_">tearDown</span>(<span class="params">self</span>):
        <span class="built_in">print</span>(<span class="string">&#x27;tearDown...&#x27;</span>)</code></pre>
<p>可以再次运行测试看看每个测试方法调用前后是否会打印出setUp…和tearDown…。</p>
<h3 id="文档测试"><a class="markdownIt-Anchor" href="#文档测试"></a> 文档测试</h3>
<p>如果你经常阅读Python的官方文档，可以看到很多文档都有示例代码。比如re模块就带了很多示例代码：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re
<span class="meta">&gt;&gt;&gt; </span>m = re.search(<span class="string">&#x27;(?&lt;=abc)def&#x27;</span>, <span class="string">&#x27;abcdef&#x27;</span>)
<span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">0</span>)
<span class="string">&#x27;def&#x27;</span></code></pre>
<p>可以把这些示例代码在Python的交互式环境下输入并执行，结果与文档中的示例代码显示的一致。</p>
<p>这些代码与其他说明可以写在注释中，然后，由一些工具来自动生成文档。既然这些代码本身就可以粘贴出来直接运行，那么，可不可以自动执行写在注释中的这些代码呢？</p>
<p>答案是肯定的。</p>
<p>当我们编写注释时，如果写上这样的注释：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">abs</span>(<span class="params">n</span>):
    <span class="string">&#x27;&#x27;&#x27;</span>
<span class="string">    Function to get absolute value of number.</span>
<span class="string">    </span>
<span class="string">    Example:</span>
<span class="string">    </span>
<span class="string">    &gt;&gt;&gt; abs(1)</span>
<span class="string">    1</span>
<span class="string">    &gt;&gt;&gt; abs(-1)</span>
<span class="string">    1</span>
<span class="string">    &gt;&gt;&gt; abs(0)</span>
<span class="string">    0</span>
<span class="string">    &#x27;&#x27;&#x27;</span>
    <span class="keyword">return</span> n <span class="keyword">if</span> n &gt;= <span class="number">0</span> <span class="keyword">else</span> (-n)</code></pre>
<p>无疑更明确地告诉函数的调用者该函数的期望输入和输出。</p>
<p>并且，<strong>Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试</strong>。</p>
<p>doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。<strong>只有测试异常的时候，可以用…表示中间一大段烦人的输出</strong>。</p>
<p>让我们用doctest来测试上次编写的Dict类：</p>
<pre><code class="highlight python"><span class="comment"># mydict2.py</span>
<span class="keyword">class</span> <span class="title class_">Dict</span>(<span class="title class_ inherited__">dict</span>):
    <span class="string">&#x27;&#x27;&#x27;</span>
<span class="string">    Simple dict but also support access as x.y style.</span>
<span class="string"></span>
<span class="string">    &gt;&gt;&gt; d1 = Dict()</span>
<span class="string">    &gt;&gt;&gt; d1[&#x27;x&#x27;] = 100</span>
<span class="string">    &gt;&gt;&gt; d1.x</span>
<span class="string">    100</span>
<span class="string">    &gt;&gt;&gt; d1.y = 200</span>
<span class="string">    &gt;&gt;&gt; d1[&#x27;y&#x27;]</span>
<span class="string">    200</span>
<span class="string">    &gt;&gt;&gt; d2 = Dict(a=1, b=2, c=&#x27;3&#x27;)</span>
<span class="string">    &gt;&gt;&gt; d2.c</span>
<span class="string">    &#x27;3&#x27;</span>
<span class="string">    &gt;&gt;&gt; d2[&#x27;empty&#x27;]</span>
<span class="string">    Traceback (most recent call last):</span>
<span class="string">        ...</span>
<span class="string">    KeyError: &#x27;empty&#x27;</span>
<span class="string">    &gt;&gt;&gt; d2.empty</span>
<span class="string">    Traceback (most recent call last):</span>
<span class="string">        ...</span>
<span class="string">    AttributeError: &#x27;Dict&#x27; object has no attribute &#x27;empty&#x27;</span>
<span class="string">    &#x27;&#x27;&#x27;</span>
    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kw</span>):
        <span class="built_in">super</span>(<span class="type">Dict</span>, <span class="variable language_">self</span>).__init__(**kw)

    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, key</span>):
        <span class="keyword">try</span>:
            <span class="keyword">return</span> <span class="variable language_">self</span>[key]
        <span class="keyword">except</span> KeyError:
            <span class="keyword">raise</span> AttributeError(<span class="string">r&quot;&#x27;Dict&#x27; object has no attribute &#x27;%s&#x27;&quot;</span> % key)

    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, key, value</span>):
        <span class="variable language_">self</span>[key] = value

<span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:
    <span class="keyword">import</span> doctest
    doctest.testmod()</code></pre>
<p>运行python <a target="_blank" rel="noopener" href="http://mydict2.py">mydict2.py</a>：</p>
<pre><code class="highlight python">$ python mydict2.py</code></pre>
<p>什么输出也没有。这说明我们编写的doctest运行都是正确的。如果程序有问题，比如把__getattr__()方法注释掉，再运行就会报错：</p>
<pre><code class="highlight python">$ python mydict2.py
**********************************************************************
File <span class="string">&quot;/Users/michael/Github/learn-python3/samples/debug/mydict2.py&quot;</span>, line <span class="number">10</span>, <span class="keyword">in</span> __main__.<span class="type">Dict</span>
Failed example:
    d1.x
Exception raised:
    Traceback (most recent call last):
      ...
    AttributeError: <span class="string">&#x27;Dict&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;x&#x27;</span>
**********************************************************************
File <span class="string">&quot;/Users/michael/Github/learn-python3/samples/debug/mydict2.py&quot;</span>, line <span class="number">16</span>, <span class="keyword">in</span> __main__.<span class="type">Dict</span>
Failed example:
    d2.c
Exception raised:
    Traceback (most recent call last):
      ...
    AttributeError: <span class="string">&#x27;Dict&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;c&#x27;</span>
**********************************************************************
<span class="number">1</span> items had failures:
   <span class="number">2</span> of   <span class="number">9</span> <span class="keyword">in</span> __main__.<span class="type">Dict</span>
***Test Failed*** <span class="number">2</span> failures.</code></pre>
<p>注意到最后3行代码。当模块正常导入时，doctest不会被执行。只有在命令行直接运行时，才执行doctest。所以，不必担心doctest会在非测试环境下执行。</p>
<h2 id="io编程"><a class="markdownIt-Anchor" href="#io编程"></a> IO编程</h2>
<p>IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。</p>
<p>比如你打开浏览器，访问新浪首页，浏览器这个程序就需要通过网络IO获取新浪的网页。浏览器首先会发送数据给新浪服务器，告诉它我想要首页的HTML，这个动作是往外发数据，叫Output，随后新浪服务器把网页发过来，这个动作是从外面接收数据，叫Input。所以，通常，程序完成IO操作会有Input和Output两个数据流。当然也有只用一个的情况，比如，从磁盘读取文件到内存，就只有Input操作，反过来，把数据写到磁盘文件里，就只是一个Output操作。</p>
<p>IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。</p>
<p>由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法：</p>
<ul>
<li>
<p>第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；</p>
</li>
<li>
<p>另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。</p>
</li>
</ul>
<blockquote>
<p><strong>同步和异步的区别就在于是否等待IO执行的结果</strong>。</p>
</blockquote>
<blockquote>
<p>好比你去麦当劳点餐，你说“来个汉堡”，服务员告诉你，对不起，汉堡要现做，需要等5分钟，于是你站在收银台前面等了5分钟，拿到汉堡再去逛商场，这是<strong>同步IO</strong>。<br />
你说“来个汉堡”，服务员告诉你，汉堡需要等5分钟，你可以先去逛商场，等做好了，我们再通知你，这样你可以立刻去干别的事情（逛商场），这是<strong>异步IO</strong>。</p>
</blockquote>
<p>很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步IO的复杂度远远高于同步IO。</p>
<p>操作IO的能力都是由操作系统提供的，每一种编程语言都会把操作系统提供的低级C接口封装起来方便使用，Python也不例外。我们后面会详细讨论Python的IO编程接口。</p>
<h3 id="文件读写"><a class="markdownIt-Anchor" href="#文件读写"></a> 文件读写</h3>
<p>读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。</p>
<p>读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。</p>
<h4 id="读文件"><a class="markdownIt-Anchor" href="#读文件"></a> 读文件</h4>
<p><strong>读文件open()</strong></p>
<p>要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符：</p>
<ul>
<li><strong>标示符’r’表示读</strong>，这样，我们就成功地打开了一个文件。</li>
</ul>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</code></pre>
<p>如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f=<span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/notfound.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
FileNotFoundError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">&#x27;/Users/michael/notfound.txt&#x27;</span></code></pre>
<p><strong>read()</strong></p>
<p>如果文件打开成功，接下来，<strong>调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示</strong>：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f.read()
<span class="string">&#x27;Hello, world!&#x27;</span></code></pre>
<p>调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，<strong>可以反复调用read(size)方法</strong>，每次最多读取size个字节的内容。</p>
<p>另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</p>
<p>如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：</p>
<pre><code class="highlight python"><span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():
    <span class="built_in">print</span>(line.strip()) <span class="comment"># 把末尾的&#x27;\n&#x27;删掉</span></code></pre>
<p><strong>close()</strong></p>
<p>最后一步是<strong>调用close()方法关闭文件</strong>。文件使用完毕后<strong>必须关闭</strong>，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：</p>
<pre><code class="highlight python">f.close()</code></pre>
<p>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现：</p>
<pre><code class="highlight python"><span class="keyword">try</span>:
    f = <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)
    <span class="built_in">print</span>(f.read())
<span class="keyword">finally</span>:
    <span class="keyword">if</span> f:
        f.close()</code></pre>
<p><strong>with语句</strong></p>
<p>但是每次都这么写实在太繁琐，所以，Python引入了<strong>with语句</strong>来自动帮我们调用close()方法：</p>
<pre><code class="highlight python"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:
    <span class="built_in">print</span>(f.read())</code></pre>
<blockquote>
<p>这和前面的try … finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。</p>
</blockquote>
<p>调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</p>
<p><strong>如果文件很小，read()一次性读取最方便</strong>；如果<strong>不能确定文件大小，反复调用read(size)比较保险</strong>；如果是<strong>配置文件，调用readlines()最方便</strong>：</p>
<pre><code class="highlight python"><span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():
    <span class="built_in">print</span>(line.strip()) <span class="comment"># 把末尾的&#x27;\n&#x27;删掉</span></code></pre>
<hr />
<p><strong>file-like Object</strong></p>
<p>像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。</p>
<p>StringIO就是在内存中创建的file-like Object，常用作临时缓冲。</p>
<hr />
<p><strong>二进制文件</strong></p>
<p>前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)
<span class="meta">&gt;&gt;&gt; </span>f.read()
<span class="string">b&#x27;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&#x27;</span> <span class="comment"># 十六进制表示的字节</span></code></pre>
<hr />
<p><strong>字符编码</strong></p>
<p>要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/gbk.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;gbk&#x27;</span>)
<span class="meta">&gt;&gt;&gt; </span>f.read()
<span class="string">&#x27;测试&#x27;</span></code></pre>
<p>遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个<strong>errors参数，表示如果遇到编码错误后如何处理</strong>。最简单的方式是直接忽略：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/gbk.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;gbk&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)
</code></pre>
<h4 id="写文件"><a class="markdownIt-Anchor" href="#写文件"></a> 写文件</h4>
<p>写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符’w’或者’wb’表示写文本文件或写二进制文件：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)
<span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27;Hello, world!&#x27;</span>)
<span class="meta">&gt;&gt;&gt; </span>f.close()</code></pre>
<p>你可以反复调用write()来写入文件，但是<strong>务必要调用f.close()来关闭文件</strong>。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用with语句来得保险：</p>
<pre><code class="highlight python"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:
    f.write(<span class="string">&#x27;Hello, world!&#x27;</span>)</code></pre>
<p>要写入特定编码的文本文件，请给open()函数传入<strong>encoding参数，将字符串自动转换成指定编码</strong>。</p>
<p>细心的童鞋会发现，以’w’模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？<strong>可以传入’a’以追加</strong>（append）模式写入。</p>
<h3 id="stringio和bytesio"><a class="markdownIt-Anchor" href="#stringio和bytesio"></a> StringIO和BytesIO</h3>
<h4 id="stringio"><a class="markdownIt-Anchor" href="#stringio"></a> StringIO</h4>
<p>很多时候，数据读写不一定是文件，也可以在内存中读写。</p>
<p>StringIO顾名思义就是在内存中读写str。</p>
<p>要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO
<span class="meta">&gt;&gt;&gt; </span>f = StringIO()
<span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27;hello&#x27;</span>)
<span class="number">5</span>
<span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27; &#x27;</span>)
<span class="number">1</span>
<span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27;world!&#x27;</span>)
<span class="number">6</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(f.getvalue())
hello world!</code></pre>
<blockquote>
<p><strong>getvalue()方法用于获得写入后的str</strong>。</p>
</blockquote>
<p>要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO
<span class="meta">&gt;&gt;&gt; </span>f = StringIO(<span class="string">&#x27;Hello!\nHi!\nGoodbye!&#x27;</span>)
<span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:
<span class="meta">... </span>    s = f.readline()
<span class="meta">... </span>    <span class="keyword">if</span> s == <span class="string">&#x27;&#x27;</span>:
<span class="meta">... </span>        <span class="keyword">break</span>...     <span class="built_in">print</span>(s.strip())
...
Hello!
Hi!
Goodbye!</code></pre>
<h4 id="byteslo"><a class="markdownIt-Anchor" href="#byteslo"></a> ByteslO</h4>
<p>StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。</p>
<p>BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO
<span class="meta">&gt;&gt;&gt; </span>f = BytesIO()
<span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))
<span class="number">6</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(f.getvalue())
<span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span></code></pre>
<p>请注意，写入的不是str，而是经过UTF-8编码的bytes。和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO
<span class="meta">&gt;&gt;&gt; </span>f = BytesIO(<span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>)
<span class="meta">&gt;&gt;&gt; </span>f.read()
<span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span></code></pre>
<h3 id="操作文件和目录"><a class="markdownIt-Anchor" href="#操作文件和目录"></a> 操作文件和目录</h3>
<p>如果我们要操作文件、目录，可以在命令行下面输入操作系统提供的各种命令来完成。比如dir、cp等命令。</p>
<p>如果要在Python程序中执行这些目录和文件的操作怎么办？其实操作系统提供的命令只是简单地调用了操作系统提供的接口函数，Python内置的os模块也可以直接调用操作系统提供的接口函数。</p>
<p>打开Python交互式命令行，我们来看看如何使用os模块的基本功能：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os
<span class="meta">&gt;&gt;&gt; </span>os.name <span class="comment"># 操作系统类型</span>
<span class="string">&#x27;posix&#x27;</span></code></pre>
<p>如果是posix，说明系统是Linux、Unix或Mac OS X，如果是nt，就是Windows系统。</p>
<p>要<strong>获取详细的系统信息，可以调用uname()函数</strong>：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>os.uname()
posix.uname_result(sysname=<span class="string">&#x27;Darwin&#x27;</span>, nodename=<span class="string">&#x27;MichaelMacPro.local&#x27;</span>, release=<span class="string">&#x27;14.3.0&#x27;</span>, version=<span class="string">&#x27;Darwin Kernel Version 14.3.0: Mon Mar 23 11:59:05 PDT 2015; root:xnu-2782.20.48~5/RELEASE_X86_64&#x27;</span>, machine=<span class="string">&#x27;x86_64&#x27;</span>)</code></pre>
<blockquote>
<p>注意uname()函数在Windows上不提供，也就是说，os模块的某些函数是跟操作系统相关的。</p>
</blockquote>
<h4 id="环境变量"><a class="markdownIt-Anchor" href="#环境变量"></a> 环境变量</h4>
<p>在操作系统中定义的环境变量，全部保存在<strong>os.environ</strong>这个变量中，可以直接查看：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>os.environ
environ(&#123;<span class="string">&#x27;VERSIONER_PYTHON_PREFER_32_BIT&#x27;</span>: <span class="string">&#x27;no&#x27;</span>, <span class="string">&#x27;TERM_PROGRAM_VERSION&#x27;</span>: <span class="string">&#x27;326&#x27;</span>, <span class="string">&#x27;LOGNAME&#x27;</span>: <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;PATH&#x27;</span>: <span class="string">&#x27;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin&#x27;</span>, ...&#125;)</code></pre>
<p>要获取某个环境变量的值，可以调用os.environ.get(‘key’)：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>os.environ.get(<span class="string">&#x27;PATH&#x27;</span>)
<span class="string">&#x27;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin&#x27;</span>
<span class="meta">&gt;&gt;&gt; </span>os.environ.get(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;default&#x27;</span>)
<span class="string">&#x27;default&#x27;</span></code></pre>
<h4 id="操作文件和目录-2"><a class="markdownIt-Anchor" href="#操作文件和目录-2"></a> 操作文件和目录</h4>
<p>操作文件和目录的函数一部分放在<strong>os模块</strong>中，一部分放在<strong>os.path模块</strong>中，这一点要注意一下。查看、创建和删除目录可以这么调用：</p>
<pre><code class="highlight python"><span class="comment"># 查看当前目录的绝对路径:</span>
<span class="meta">&gt;&gt;&gt; </span>os.path.abspath(<span class="string">&#x27;.&#x27;</span>)
<span class="string">&#x27;/Users/michael&#x27;</span>
<span class="comment"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span>
<span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">&#x27;/Users/michael&#x27;</span>, <span class="string">&#x27;testdir&#x27;</span>)
<span class="string">&#x27;/Users/michael/testdir&#x27;</span>
<span class="comment"># 然后创建一个目录:</span>
<span class="meta">&gt;&gt;&gt; </span>os.mkdir(<span class="string">&#x27;/Users/michael/testdir&#x27;</span>)
<span class="comment"># 删掉一个目录:</span>
<span class="meta">&gt;&gt;&gt; </span>os.rmdir(<span class="string">&#x27;/Users/michael/testdir&#x27;</span>)</code></pre>
<p>把<strong>两个路径合成一个</strong>时，不要直接拼字符串，而要通过<strong>os.path.join()函数</strong>，这样可以正确处理不同操作系统的路径分隔符。在Linux/Unix/Mac下，os.path.join()返回这样的字符串：</p>
<pre><code class="highlight python">part-<span class="number">1</span>/part-<span class="number">2</span></code></pre>
<p>而Windows下会返回这样的字符串：</p>
<pre><code class="highlight python">part-<span class="number">1</span>\part-<span class="number">2</span></code></pre>
<p>同样的道理，要<strong>拆分路径</strong>时，也不要直接去拆字符串，而要通过<strong>os.path.split()函数</strong>，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>os.path.split(<span class="string">&#x27;/Users/michael/testdir/file.txt&#x27;</span>)
(<span class="string">&#x27;/Users/michael/testdir&#x27;</span>, <span class="string">&#x27;file.txt&#x27;</span>)</code></pre>
<p><strong>os.path.splitext()可以直接让你得到文件扩展名</strong>，很多时候非常方便：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>os.path.splitext(<span class="string">&#x27;/path/to/file.txt&#x27;</span>)
(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;.txt&#x27;</span>)</code></pre>
<blockquote>
<p><strong>这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作</strong>。</p>
</blockquote>
<p>文件操作使用下面的函数。假定当前目录下有一个test.txt文件：</p>
<pre><code class="highlight python"><span class="comment"># 对文件重命名:</span>
<span class="meta">&gt;&gt;&gt; </span>os.rename(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;test.py&#x27;</span>)
<span class="comment"># 删掉文件:</span>
<span class="meta">&gt;&gt;&gt; </span>os.remove(<span class="string">&#x27;test.py&#x27;</span>)</code></pre>
<p>但是复制文件的函数居然在os模块中不存在！原因是复制文件并非由操作系统提供的系统调用。理论上讲，我们通过上一节的读写文件可以完成文件复制，只不过要多写很多代码。</p>
<p>幸运的是<strong>shutil模块</strong>提供了<strong>copyfile()的函数</strong>，你还可以在shutil模块中找到很多实用函数，它们可以看做是os模块的补充。</p>
<p>最后看看如何利用Python的特性来过滤文件。比如我们要列出当前目录下的所有目录，只需要一行代码：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> os.listdir(<span class="string">&#x27;.&#x27;</span>) <span class="keyword">if</span> os.path.isdir(x)]
[<span class="string">&#x27;.lein&#x27;</span>, <span class="string">&#x27;.local&#x27;</span>, <span class="string">&#x27;.m2&#x27;</span>, <span class="string">&#x27;.npm&#x27;</span>, <span class="string">&#x27;.ssh&#x27;</span>, <span class="string">&#x27;.Trash&#x27;</span>, <span class="string">&#x27;.vim&#x27;</span>, <span class="string">&#x27;Applications&#x27;</span>, <span class="string">&#x27;Desktop&#x27;</span>, ...]</code></pre>
<p>要列出所有的.py文件，也只需一行代码：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> os.listdir(<span class="string">&#x27;.&#x27;</span>) <span class="keyword">if</span> os.path.isfile(x) <span class="keyword">and</span> os.path.splitext(x)[<span class="number">1</span>]==<span class="string">&#x27;.py&#x27;</span>]
[<span class="string">&#x27;apis.py&#x27;</span>, <span class="string">&#x27;config.py&#x27;</span>, <span class="string">&#x27;models.py&#x27;</span>, <span class="string">&#x27;pymonitor.py&#x27;</span>, <span class="string">&#x27;test_db.py&#x27;</span>, <span class="string">&#x27;urls.py&#x27;</span>, <span class="string">&#x27;wsgiapp.py&#x27;</span>]</code></pre>
<p>是不是非常简洁？</p>
<p><strong>练习</strong></p>
<ul>
<li>利用os模块实现dir -l输出的程序</li>
</ul>
<pre><code class="highlight python"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime
<span class="keyword">import</span> os
<span class="comment">#获取当前路径</span>
pwd = os.path.abspath(<span class="string">&#x27;.&#x27;</span>)
<span class="built_in">print</span>(<span class="string">&#x27;      Size     Last Modified  Name&#x27;</span>)
<span class="built_in">print</span>(<span class="string">&#x27;------------------------------------------------------------&#x27;</span>)
<span class="comment">#os.listdir()获取指定路径的所有文件</span>
<span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(pwd):
    fsize = os.path.getsize(f)
    mtime = datetime.fromtimestamp(os.path.getmtime(f)).strftime(<span class="string">&#x27;%Y-%m-%d %H:%M&#x27;</span>)
    flag = <span class="string">&#x27;/&#x27;</span> <span class="keyword">if</span> os.path.isdir(f) <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span>
    <span class="built_in">print</span>(<span class="string">&#x27;%10d  %s  %s%s&#x27;</span> % (fsize, mtime, f, flag))</code></pre>
<p>输出:</p>
<ul>
<li>编写一个程序，能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，并打印出相对路径。</li>
</ul>
<pre><code class="highlight python"><span class="keyword">import</span> os
<span class="keyword">def</span> <span class="title function_">Searchfile</span>(<span class="params"><span class="built_in">str</span></span>):
    pwd = os.path.abspath(<span class="string">&#x27;.&#x27;</span>)
    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(pwd):
        <span class="keyword">for</span> file <span class="keyword">in</span> files:
            <span class="keyword">if</span> <span class="built_in">str</span> <span class="keyword">in</span> file: <span class="comment">#用if in实现子字符串的查找</span>
                <span class="built_in">print</span>(os.path.join(root, file))
<span class="comment">#            if file.find(str) !=-1:    #用find函数实现子字符串的查找</span>
<span class="comment">#                print(os.path.join(root, file))</span></code></pre>
<pre><code class="highlight python"><span class="keyword">import</span> os
<span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">path,key</span>):
    count_dirs = count_files = <span class="number">0</span>
    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(path):
        <span class="keyword">for</span> x <span class="keyword">in</span> files:
            <span class="keyword">if</span> key <span class="keyword">in</span> x:
                <span class="built_in">print</span>(os.path.join(root,x),<span class="string">&#x27;文件&#x27;</span>)
                count_files += <span class="number">1</span>
        <span class="keyword">for</span> y <span class="keyword">in</span> dirs:
            <span class="keyword">if</span> key <span class="keyword">in</span> y:
                <span class="built_in">print</span>(os.path.join(root,y),<span class="string">&#x27;目录&#x27;</span>)
                count_dirs += <span class="number">1</span>
    <span class="built_in">print</span>(<span class="string">&#x27;\n文件数：%d, 目录数：%d&#x27;</span>%(count_files,count_dirs))
find(<span class="string">&quot;D:\ztest&quot;</span>,<span class="string">&quot;xml&quot;</span>)</code></pre>
<h3 id="序列化"><a class="markdownIt-Anchor" href="#序列化"></a> 序列化</h3>
<p>在程序运行的过程中，所有的变量都是在内存中，比如，定义一个dict：</p>
<pre><code class="highlight python">d = <span class="built_in">dict</span>(name=<span class="string">&#x27;Bob&#x27;</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)</code></pre>
<p>可以随时修改变量，比如把name改成’Bill’，但是一旦程序结束，变量所占用的内存就被操作系统全部回收。如果没有把修改后的’Bill’存储到磁盘上，下次重新运行程序，变量又被初始化为’Bob’。</p>
<p><strong>我们把变量从内存中变成可存储或传输的过程称之为序列化</strong>，在Python中叫<strong>pickling</strong>，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</p>
<p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p>
<p>反过来，<strong>把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling</strong>。</p>
<p>Python提供了<strong>pickle模块</strong>来实现序列化。</p>
<p>首先，我们尝试把一个对象序列化并写入文件：</p>
<pre><code class="highlight python">&gt;&gt;&gt; <span class="keyword">import</span> pickle
&gt;&gt;&gt; d = <span class="built_in">dict</span>(name=<span class="string">&#x27;Bob&#x27;</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)
&gt;&gt;&gt; pickle.dumps(d)
<span class="string">b&#x27;\x80\x03&#125;q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.&#x27;</span></code></pre>
<p><strong>pickle.dumps()方法把任意对象序列化成一个bytes</strong>，然后，就可以把这个bytes写入文件。或者用另一个方法pickle.dump()直接把对象序列化后写入一个file-like Object：</p>
<pre><code class="highlight python">&gt;&gt;&gt; f = <span class="built_in">open</span>(<span class="string">&#x27;dump.txt&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)
&gt;&gt;&gt; pickle.dump(d, f)
&gt;&gt;&gt; f.close()</code></pre>
<p>看看写入的dump.txt文件，一堆乱七八糟的内容，这些都是Python保存的对象内部信息。</p>
<p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用<strong>pickle.loads()方法反序列化出对象</strong>，也可以直接用pickle.load()方法从一个file-like Object中直接反序列化出对象。我们打开另一个Python命令行来反序列化刚才保存的对象：</p>
<pre><code class="highlight python">&gt;&gt;&gt; f = <span class="built_in">open</span>(<span class="string">&#x27;dump.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)
&gt;&gt;&gt; d = pickle.load(f)
&gt;&gt;&gt; f.close()
&gt;&gt;&gt; d
&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">88</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>&#125;</code></pre>
<p>变量的内容又回来了！</p>
<blockquote>
<p>当然，这个变量和原来的变量是完全不相干的对象，它们只是内容相同而已。</p>
</blockquote>
<p>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</p>
<h4 id="json"><a class="markdownIt-Anchor" href="#json"></a> JSON</h4>
<p>如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p>
<p>JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：</p>
<table>
<thead>
<tr>
<th>JSON类型</th>
<th>Python类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>{}</td>
<td>dict</td>
</tr>
<tr>
<td>[]</td>
<td>list</td>
</tr>
<tr>
<td>“string”</td>
<td>str</td>
</tr>
<tr>
<td>1234.56</td>
<td>int或float</td>
</tr>
<tr>
<td>true/false</td>
<td>True/False</td>
</tr>
<tr>
<td>null</td>
<td>None</td>
</tr>
</tbody>
</table>
<p>Python内置的json模块提供了非常完善的Python对象到JSON格式的转换。我们先看看如何把<strong>Python对象变成一个JSON</strong>：</p>
<pre><code class="highlight python">&gt;&gt;&gt; <span class="keyword">import</span> json
&gt;&gt;&gt; d = <span class="built_in">dict</span>(name=<span class="string">&#x27;Bob&#x27;</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)
&gt;&gt;&gt; json.dumps(d)
<span class="string">&#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;</span></code></pre>
<p>dumps()方法返回一个str，内容就是标准的JSON。类似的，dump()方法可以直接把JSON写入一个file-like Object。</p>
<p>要把<strong>JSON反序列化为Python对象</strong>，用<strong>loads</strong>()或者对应的<strong>load</strong>()方法，前者把JSON的字符串反序列化，后者从file-like Object中读取字符串并反序列化：</p>
<pre><code class="highlight python">&gt;&gt;&gt; json_str = <span class="string">&#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;</span>
&gt;&gt;&gt; json.loads(json_str)
&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">88</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>&#125;</code></pre>
<p>由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的str与JSON的字符串之间转换。</p>
<h4 id="json进阶"><a class="markdownIt-Anchor" href="#json进阶"></a> JSON进阶</h4>
<p>Python的dict对象可以直接序列化为JSON的{}，不过，很多时候，我们更喜欢用class表示对象，比如定义Student类，然后序列化：</p>
<pre><code class="highlight python"><span class="keyword">import</span> json

<span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, score</span>):
        <span class="variable language_">self</span>.name = name
        <span class="variable language_">self</span>.age = age
        <span class="variable language_">self</span>.score = score

s = Student(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">20</span>, <span class="number">88</span>)
<span class="built_in">print</span>(json.dumps(s))</code></pre>
<p>运行代码，毫不留情地得到一个TypeError：</p>
<pre><code class="highlight python">Traceback (most recent call last):
  ...
TypeError: &lt;__main__.Student <span class="built_in">object</span> at <span class="number">0x10603cc50</span>&gt; <span class="keyword">is</span> <span class="keyword">not</span> JSON serializable</code></pre>
<p>错误的原因是Student对象不是一个可序列化为JSON的对象。</p>
<p>如果连class的实例对象都无法序列化为JSON，这肯定不合理！</p>
<p>别急，我们仔细看看dumps()方法的参数列表，可以发现，除了第一个必须的obj参数外，dumps()方法还提供了一大堆的可选参数：</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/json.html#json.dumps">https://docs.python.org/3/library/json.html#json.dumps</a></p>
<p>这些可选参数就是让我们来定制JSON序列化。前面的代码之所以无法把Student类实例序列化为JSON，是因为默认情况下，dumps()方法不知道如何将Student实例变为一个JSON的{}对象。</p>
<p>可选参数<strong>default就是把任意一个对象变成一个可序列为JSON的对象</strong>，我们只需要为Student专门写一个转换函数，再把函数传进去即可：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">student2dict</span>(<span class="params">std</span>):
    <span class="keyword">return</span> &#123;
        <span class="string">&#x27;name&#x27;</span>: std.name,
        <span class="string">&#x27;age&#x27;</span>: std.age,
        <span class="string">&#x27;score&#x27;</span>: std.score
    &#125;</code></pre>
<p>这样，Student实例首先被student2dict()函数转换成dict，然后再被顺利序列化为JSON：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(json.dumps(s, default=student2dict))
&#123;<span class="string">&quot;age&quot;</span>: <span class="number">20</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="number">88</span>&#125;</code></pre>
<p>对<strong>中文进行JSON序列化</strong>时，json.dumps()提供了一个<strong>ensure_ascii</strong>参数</p>
<pre><code class="highlight python">obj = <span class="built_in">dict</span>(name=<span class="string">&#x27;小明&#x27;</span>, age=<span class="number">20</span>)
s = json.dumps(obj, ensure_ascii=<span class="literal">True</span>)</code></pre>
<p>不过，下次如果遇到一个Teacher类的实例，照样无法序列化为JSON。我们可以偷个懒，把任意class的实例变为dict：</p>
<pre><code class="highlight python"><span class="built_in">print</span>(json.dumps(s, default=<span class="keyword">lambda</span> obj: obj.__dict__))</code></pre>
<p>因为通常class的实例都有一个__dict__属性，它就是一个dict，用来存储实例变量。也有少数例外，比如定义了__slots__的class。</p>
<p>同样的道理，如果我们要把<strong>JSON反序列化为一个Student对象实例</strong>，loads()方法首先转换出一个dict对象，然后，我们传入的<strong>object_hook</strong>函数负责把dict转换为Student实例：</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">dict2student</span>(<span class="params">d</span>):
    <span class="keyword">return</span> Student(d[<span class="string">&#x27;name&#x27;</span>], d[<span class="string">&#x27;age&#x27;</span>], d[<span class="string">&#x27;score&#x27;</span>])</code></pre>
<p>运行结果如下：</p>
<pre><code class="highlight python"><span class="meta">&gt;&gt;&gt; </span>json_str = <span class="string">&#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;</span>
<span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(json.loads(json_str, object_hook=dict2student))
&lt;__main__.Student <span class="built_in">object</span> at <span class="number">0x10cd3c190</span>&gt;</code></pre>
<p>打印出的是反序列化的Student实例对象。</p>
<h2 id="进程和线程"><a class="markdownIt-Anchor" href="#进程和线程"></a> 进程和线程</h2>
<p>很多同学都听说过，现代操作系统比如Mac OS X，UNIX，Linux，Windows等，都是支持“多任务”的操作系统。</p>
<p>什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。</p>
<p>现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？</p>
<p>答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。</p>
<p>真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。</p>
<p>对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p>
<p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</p>
<p>由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。</p>
<p>我们前面编写的所有的Python程序，都是执行单任务的进程，也就是只有一个线程。如果我们要同时执行多个任务怎么办？</p>
<p>有两种解决方案：</p>
<p>一种是启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务。</p>
<p>还有一种方法是启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务。</p>
<p>当然还有第三种方法，就是启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了，当然这种模型更复杂，实际很少采用。</p>
<p>总结一下就是，多任务的实现有3种方式：</p>
<ul>
<li>多进程模式；</li>
<li>多线程模式；</li>
<li>多进程+多线程模式。</li>
</ul>
<p>同时执行多个任务通常各个任务之间并不是没有关联的，而是需要相互通信和协调，有时，任务1必须暂停等待任务2完成后才能继续执行，有时，任务3和任务4又不能同时执行，所以，多进程和多线程的程序的复杂度要远远高于我们前面写的单进程单线程的程序。</p>
<p>因为复杂度高，调试困难，所以，不是迫不得已，我们也不想编写多任务。但是，有很多时候，没有多任务还真不行。想想在电脑上看电影，就必须由一个线程播放视频，另一个线程播放音频，否则，单线程实现的话就只能先把视频播放完再播放音频，或者先把音频播放完再播放视频，这显然是不行的。</p>
<p><strong>Python既支持多进程，又支持多线程</strong></p>
<p><strong>线程是最小的执行单元，而进程由至少一个线程组成</strong>。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。</p>
<h3 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h3>
<p>要让Python程序实现多进程（<strong>multiprocessing</strong>），我们先了解操作系统的相关知识。</p>
<p>Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</p>
<p>子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。</p>
<p>Python的os模块封装了常见的系统调用，其中就包括fork，可以在Python程序中轻松创建子进程：</p>
<pre><code class="highlight python"><span class="keyword">import</span> os

<span class="built_in">print</span>(<span class="string">&#x27;Process (%s) start...&#x27;</span> % os.getpid())
<span class="comment"># Only works on Unix/Linux/Mac:</span>
pid = os.fork()
<span class="keyword">if</span> pid == <span class="number">0</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;I am child process (%s) and my parent is %s.&#x27;</span> % (os.getpid(), os.getppid()))
<span class="keyword">else</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;I (%s) just created a child process (%s).&#x27;</span> % (os.getpid(), pid))</code></pre>
<p>运行结果如下：</p>
<pre><code class="highlight python">Process (<span class="number">876</span>) start...
I (<span class="number">876</span>) just created a child process (<span class="number">877</span>).
I am child process (<span class="number">877</span>) <span class="keyword">and</span> my parent <span class="keyword">is</span> <span class="number">876.</span></code></pre>
<p>由于Windows没有fork调用，上面的代码在Windows上无法运行。而Mac系统是基于BSD（Unix的一种）内核，所以，在Mac下运行是没有问题的，推荐大家用Mac学Python！</p>
<p>有了fork调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。</p>
<h4 id="multiprocessing"><a class="markdownIt-Anchor" href="#multiprocessing"></a> multiprocessing</h4>
<p>如果你打算编写多进程的服务程序，Unix/Linux无疑是正确的选择。由于Windows没有fork调用，难道在Windows上无法用Python编写多进程的程序？</p>
<p>由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持。<strong>multiprocessing模块就是跨平台版本的多进程模块</strong>。</p>
<p>multiprocessing模块提供了一个<strong>Process类来代表一个进程对象</strong>，下面的例子演示了启动一个子进程并等待其结束：</p>
<pre><code class="highlight python"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process
<span class="keyword">import</span> os

<span class="comment"># 子进程要执行的代码</span>
<span class="keyword">def</span> <span class="title function_">run_proc</span>(<span class="params">name</span>):
    <span class="built_in">print</span>(<span class="string">&#x27;Run child process %s (%s)...&#x27;</span> % (name, os.getpid()))

<span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;Parent process %s.&#x27;</span> % os.getpid())
    p = Process(target=run_proc, args=(<span class="string">&#x27;test&#x27;</span>,))
    <span class="built_in">print</span>(<span class="string">&#x27;Child process will start.&#x27;</span>)
    p.start()
    p.join()
    <span class="built_in">print</span>(<span class="string">&#x27;Child process end.&#x27;</span>)</code></pre>
<p>执行结果如下：</p>
<pre><code class="highlight python">Parent process <span class="number">928.</span>
Child process will start.
Run child process test (<span class="number">929</span>)...
Process end.</code></pre>
<p><strong>创建子进程时，只需要传入一个执行函数和函数的参数</strong>，创建一个Process实例，用<strong>start()方法启动</strong>，这样创建进程比fork()还要简单。</p>
<p><strong>join()方法可以等待子进程结束后再继续往下运行</strong>，通常用于进程间的同步。</p>
<h4 id="pool"><a class="markdownIt-Anchor" href="#pool"></a> Pool</h4>
<p><strong>如果要启动大量的子进程，可以用进程池的方式批量创建子进程</strong>：</p>
<pre><code class="highlight python"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool
<span class="keyword">import</span> os, time, random

<span class="keyword">def</span> <span class="title function_">long_time_task</span>(<span class="params">name</span>):
    <span class="built_in">print</span>(<span class="string">&#x27;Run task %s (%s)...&#x27;</span> % (name, os.getpid()))
    start = time.time()
    time.sleep(random.random() * <span class="number">3</span>)
    end = time.time()
    <span class="built_in">print</span>(<span class="string">&#x27;Task %s runs %0.2f seconds.&#x27;</span> % (name, (end - start)))

<span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:
    <span class="built_in">print</span>(<span class="string">&#x27;Parent process %s.&#x27;</span> % os.getpid())
    <span class="comment">#4表示进程池大小为4</span>
    p = Pool(<span class="number">4</span>)
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):
        <span class="comment">#新启动一个进程</span>
        p.apply_async(long_time_task, args=(i,))
    <span class="built_in">print</span>(<span class="string">&#x27;Waiting for all subprocesses done...&#x27;</span>)
    p.close()
    p.join()
    <span class="built_in">print</span>(<span class="string">&#x27;All subprocesses done.&#x27;</span>)</code></pre>
<p>执行结果如下：</p>
<pre><code class="highlight python">Parent process <span class="number">669.</span>
Waiting <span class="keyword">for</span> <span class="built_in">all</span> subprocesses done...
Run task <span class="number">0</span> (<span class="number">671</span>)...
Run task <span class="number">1</span> (<span class="number">672</span>)...
Run task <span class="number">2</span> (<span class="number">673</span>)...
Run task <span class="number">3</span> (<span class="number">674</span>)...
Task <span class="number">2</span> runs <span class="number">0.14</span> seconds.
Run task <span class="number">4</span> (<span class="number">673</span>)...
Task <span class="number">1</span> runs <span class="number">0.27</span> seconds.
Task <span class="number">3</span> runs <span class="number">0.86</span> seconds.
Task <span class="number">0</span> runs <span class="number">1.41</span> seconds.
Task <span class="number">4</span> runs <span class="number">1.91</span> seconds.
All subprocesses done.</code></pre>
<p>代码解读：</p>
<p><strong>对Pool对象调用join()方法会等待所有子进程执行完毕</strong>，<strong>调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了</strong>。</p>
<p>请注意输出的结果，task 0，1，2，3是立刻执行的，而task 4要等待前面某个task完成后才执行，这是因为Pool的默认大小在我的电脑上是4，因此，最多同时执行4个进程。这是Pool有意设计的限制，并不是操作系统的限制。如果改成：</p>
<pre><code class="highlight python">p = Pool(<span class="number">5</span>)</code></pre>
<p>就可以同时跑5个进程。</p>
<p>由于Pool的默认大小是CPU的核数，如果你不幸拥有8核CPU，你要提交至少9个子进程才能看到上面的等待效果。</p>
<h4 id="子进程"><a class="markdownIt-Anchor" href="#子进程"></a> 子进程</h4>
<p>很多时候，子进程并不是自身，而是一个外部进程。我们创建了子进程后，还需要控制子进程的输入和输出。</p>
<p><strong>subprocess模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出</strong>。</p>
<p>下面的例子演示了如何在Python代码中运行命令nslookup <a target="_blank" rel="noopener" href="http://www.python.org">www.python.org</a>，这和命令行直接运行的效果是一样的：</p>
<pre><code class="highlight python"><span class="keyword">import</span> subprocess

<span class="built_in">print</span>(<span class="string">&#x27;$ nslookup www.python.org&#x27;</span>)
r = subprocess.call([<span class="string">&#x27;nslookup&#x27;</span>, <span class="string">&#x27;www.python.org&#x27;</span>])
<span class="built_in">print</span>(<span class="string">&#x27;Exit code:&#x27;</span>, r)</code></pre>
<p>运行结果：</p>
<pre><code class="highlight python">$ nslookup www.python.org
Server:		<span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span>
Address:	<span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span><span class="comment">#53</span>

Non-authoritative answer:
www.python.org	canonical name = python.<span class="built_in">map</span>.fastly.net.
Name:	python.<span class="built_in">map</span>.fastly.net
Address: <span class="number">199.27</span><span class="number">.79</span><span class="number">.223</span>

Exit code: <span class="number">0</span></code></pre>
<p>如果子进程还需要输入，则可以通过communicate()方法输入：</p>
<pre><code class="highlight python"><span class="keyword">import</span> subprocess

<span class="built_in">print</span>(<span class="string">&#x27;$ nslookup&#x27;</span>)
p = subprocess.Popen([<span class="string">&#x27;nslookup&#x27;</span>], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
output, err = p.communicate(<span class="string">b&#x27;set q=mx\npython.org\nexit\n&#x27;</span>)
<span class="built_in">print</span>(output.decode(<span class="string">&#x27;utf-8&#x27;</span>))
<span class="built_in">print</span>(<span class="string">&#x27;Exit code:&#x27;</span>, p.returncode)</code></pre>
<p>上面的代码相当于在命令行执行命令nslookup，然后手动输入：</p>
<pre><code class="highlight python"><span class="built_in">set</span> q=mx
python.org
exit</code></pre>
<p>运行结果如下：</p>
<pre><code class="highlight python">$ nslookup
Server:		<span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span>
Address:	<span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span><span class="comment">#53</span>

Non-authoritative answer:
python.org	mail exchanger = <span class="number">50</span> mail.python.org.

Authoritative answers can be found <span class="keyword">from</span>:
mail.python.org	internet address = <span class="number">82.94</span><span class="number">.164</span><span class="number">.166</span>
mail.python.org	has AAAA address <span class="number">2001</span>:<span class="number">888</span>:<span class="number">2000</span>:d::a6


Exit code: <span class="number">0</span></code></pre>
<h4 id="进程间通信"><a class="markdownIt-Anchor" href="#进程间通信"></a> 进程间通信</h4>
<p>Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的<strong>multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据</strong>。</p>
<p>我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据：</p>
<pre><code class="highlight python"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue
<span class="keyword">import</span> os, time, random

<span class="comment"># 写数据进程执行的代码:</span>
<span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">q</span>):
    <span class="built_in">print</span>(<span class="string">&#x27;Process to write: %s&#x27;</span> % os.getpid())
    <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]:
        <span class="built_in">print</span>(<span class="string">&#x27;Put %s to queue...&#x27;</span> % value)
        q.put(value)
        time.sleep(random.random())

<span class="comment"># 读数据进程执行的代码:</span>
<span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">q</span>):
    <span class="built_in">print</span>(<span class="string">&#x27;Process to read: %s&#x27;</span> % os.getpid())
    <span class="keyword">while</span> <span class="literal">True</span>:
        value = q.get(<span class="literal">True</span>)
        <span class="built_in">print</span>(<span class="string">&#x27;Get %s from queue.&#x27;</span> % value)

<span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:
    <span class="comment"># 父进程创建Queue，并传给各个子进程：</span>
    q = Queue()
    pw = Process(target=write, args=(q,))
    pr = Process(target=read, args=(q,))
    <span class="comment"># 启动子进程pw，写入:</span>
    pw.start()
    <span class="comment"># 启动子进程pr，读取:</span>
    pr.start()
    <span class="comment"># 等待pw结束:</span>
    pw.join()
    <span class="comment"># pr进程里是死循环，无法等待其结束，只能强行终止:</span>
    pr.terminate()</code></pre>
<p>运行结果如下：</p>
<pre><code class="highlight python">Process to write: <span class="number">50563</span>
Put A to queue...
Process to read: <span class="number">50564</span>
Get A <span class="keyword">from</span> queue.
Put B to queue...
Get B <span class="keyword">from</span> queue.
Put C to queue...
Get C <span class="keyword">from</span> queue.</code></pre>
<p>在Unix/Linux下，multiprocessing模块封装了fork()调用，使我们不需要关注fork()的细节。由于Windows没有fork调用，因此，multiprocessing需要“模拟”出fork的效果，父进程所有Python对象都必须通过pickle序列化再传到子进程去，所以，如果multiprocessing在Windows下调用失败了，要先考虑是不是pickle失败了。</p>
<h3 id="多线"><a class="markdownIt-Anchor" href="#多线"></a> 多线</h3>
<p>多任务可以由多进程完成，也可以由一个进程内的多线程完成。</p>
<p>我们前面提到了进程是由若干线程组成的，一个进程至少有一个线程。由于线程是操作系统直接支持的执行单元，</p>
<p>因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。</p>
<p>Python的标准库提供了两个模块：_thread和threading，_thread是低级模块，threading是高级模块，对_thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。</p>
<p><strong>启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始</strong>执行：</p>
</main>

</article>


<script src="/js/highlight.js"></script>

  </main>
  <footer class="footer">
  
  <span>Copyright © 2026 Lism Blog | lisisism@qq.com</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>