<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    Spring MVC 丨
    

    Lism Blog
  </title>

  
  <link rel="shortcut icon" href="/icon.svg">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="/Lism Blog" type="application/atom+xml">
</head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">/Lism Blog</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <article class="post">
  
  <div class="post-title">Spring MVC</div>
  <div class="post-meta">
    <div class="date">2023 三月 16日</div>
    <div class="tags">
      
      <div class="tag-item">Java</div>
      
      <div class="tag-item">Spring</div>
      
    </div>
  </div>
  

  <main class="post-content"><h1 id="spring-mvc"><a class="markdownIt-Anchor" href="#spring-mvc"></a> $Spring MVC</h1>
<h1 id="spring-mvc-2"><a class="markdownIt-Anchor" href="#spring-mvc-2"></a> Spring MVC</h1>
<ul>
<li><a href="">Spring MVC</a>
<ul>
<li><a href="">MVC简介</a>
<ul>
<li><a href="">MVC模式简介</a></li>
<li><a href="">什么是Spring MVC</a></li>
<li><a href="">核心组件/处理流程</a></li>
</ul>
</li>
<li><a href="">springMVC架构</a>
<ul>
<li><a href="">架构流程</a></li>
<li><a href="">组件说明</a></li>
<li><a href="">默认配置文件</a></li>
</ul>
</li>
<li><a href="">spring MVC应用</a>
<ul>
<li><a href="">搭建Spring Web MVC环境（IDEA）</a>
<ul>
<li><a href="">maven创建spring mvc项目</a></li>
<li><a href="">添加依赖的jar�</a>�</li>
</ul>
</li>
<li><a href="">Spring MVC配置文件</a></li>
<li><a href="">配置DispatcherServlet（web.xml）</a></li>
<li><a href="">编写处理器Handler（Controller）</a>
<ul>
<li><a href="">方式一（接口方式）</a></li>
<li><a href="">方式二（注解方式）</a></li>
</ul>
</li>
<li><a href="">创建视图</a>
<ul>
<li><a href="">ModelAndView组件</a>
<ul>
<li><a href="">Model和ModelMap</a></li>
<li><a href="">ModelAndView和Model的区别</a></li>
</ul>
</li>
<li><a href="">ViewResolver组件</a></li>
</ul>
</li>
<li><a href="">配置tomcat部署项目</a></li>
<li><a href="">设置引导页</a></li>
</ul>
</li>
<li><a href="">SpringMVC详解</a>
<ul>
<li><a href="">@RequestMapping注解</a>
<ul>
<li><a href="">属性</a>
<ul>
<li><a href="">value属性</a></li>
<li><a href="">methods/consumes/produces/params/headers/path属性</a></li>
</ul>
</li>
<li><a href="">@RequestMapping源码解析</a></li>
<li><a href="">@RequestMapping快捷方式</a></li>
</ul>
</li>
<li><a href="">@Controller注解应用</a></li>
<li><a href="">请求参数值绑定</a>
<ul>
<li><a href="">什么是请求参数绑定</a></li>
<li><a href="">默认支持的参数类型</a></li>
<li><a href="">直接绑定</a>
<ul>
<li><a href="">绑定基本类型</a></li>
<li><a href="">绑定pojo类型</a></li>
<li><a href="">绑定包装pojo</a></li>
<li><a href="">使用简单类型数组</a></li>
<li><a href="">使用pojo类型集合或者数组</a></li>
<li><a href="">自定义参数绑定</a></li>
</ul>
</li>
<li><a href="">注解绑定</a>
<ul>
<li><a href="">@RequestParam</a></li>
<li><a href="">@PathVariable</a></li>
<li><a href="">@RequestBody</a></li>
</ul>
</li>
<li><a href="">传参校验</a>
<ul>
<li><a href="">使用@Valid</a></li>
<li><a href="">自定义校验标签</a></li>
</ul>
</li>
<li><a href="">自定义参数绑定</a></li>
</ul>
</li>
<li><a href="">向页面传值</a>
<ul>
<li><a href="">1.使用request.setAttribute方法</a></li>
<li><a href="">2.ModeAndView对象</a></li>
<li><a href="">3.ModelMap参数</a></li>
<li><a href="">4.@ModelAttribute</a></li>
<li><a href="">5.Sessioin存储</a></li>
</ul>
</li>
<li><a href="">Controller返回值</a>
<ul>
<li><a href="">不用注解修饰</a>
<ul>
<li><a href="">返回ModelAndView</a></li>
<li><a href="">返回void</a></li>
<li><a href="">返回字符串（推荐）</a>
<ul>
<li><a href="">逻辑视图名</a></li>
<li><a href="">redirect重定向</a></li>
<li><a href="">forward转发</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="">使用注解修饰@ResponseBody</a>
<ul>
<li><a href="">@RestController</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="">@ControllerAdvice</a>
<ul>
<li><a href="">@ExceptionHandler</a></li>
<li><a href="">@InitBinder</a>
<ul>
<li><a href="">防止XSS注入</a></li>
</ul>
</li>
<li><a href="">@ModelAttribute</a></li>
</ul>
</li>
<li><a href="">bmi健康指数案例</a></li>
</ul>
</li>
<li><a href="">集成Filter</a></li>
<li><a href="">使用Interceptor</a>
<ul>
<li><a href="">处理异常</a></li>
</ul>
</li>
<li><a href="">处理CORS</a>
<ul>
<li><a href="">使用@CrossOrigin</a></li>
<li><a href="">使用CorsRegistry</a></li>
<li><a href="">使用CorsFilter</a></li>
</ul>
</li>
<li><a href="">异步处理</a>
<ul>
<li><a href="">Filter处理</a></li>
</ul>
</li>
<li><a href="">使用WebSocket</a>
<ul>
<li><a href="">处理WebSocket连接</a></li>
<li><a href="">客户端开发</a></li>
</ul>
</li>
<li><a href="">使用Scheduler</a>
<ul>
<li><a href="">使用Cron任务</a></li>
<li><a href="">集成Quarz</a></li>
</ul>
</li>
<li><a href="">Spring MVC源码解析</a>
<ul>
<li><a href="">知识储备</a>
<ul>
<li><a href="">Servlet的生命周期方法</a></li>
<li><a href="">DispatcherServlet继承体系</a></li>
<li><a href="">InitializingBean接口介绍</a></li>
</ul>
</li>
<li><a href="">主流程DispatcherServlet</a></li>
<li><a href="">处理器映射器</a></li>
<li><a href="">处理器适配器</a></li>
<li><a href="">视图解析器</a></li>
<li><a href="">mvc:annotation-driver</a></li>
<li><a href="">异常处理流程</a></li>
<li><a href="">文件上传流程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="">SSM整合</a>
<ul>
<li><a href="">系统分层</a>
<ul>
<li><a href="">如何分层</a>
<ul>
<li><a href="">表现层</a></li>
<li><a href="">业务层Service</a></li>
<li><a href="">持久层DAO</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="">SSM框架整合</a>
<ul>
<li><a href="">整合思路</a></li>
<li><a href="">工程搭建（maven依赖）</a></li>
<li><a href="">工程整合（配置文件）</a>
<ul>
<li><a href="">web.xml</a></li>
<li><a href="">整合mapper</a></li>
<li><a href="">整合Service</a></li>
<li><a href="">整合controller</a></li>
</ul>
</li>
<li><a href="">整合测试（编写代码）</a>
<ul>
<li><a href="">数据库</a></li>
<li><a href="">持久层</a>
<ul>
<li><a href="">pojo</a></li>
<li><a href="">mapper</a></li>
</ul>
</li>
<li><a href="">业务层</a></li>
<li><a href="">表现层</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="">实战技巧</a>
<ul>
<li><a href="">中文乱码解决方案</a>
<ul>
<li><a href="">数据库乱码</a></li>
<li><a href="">解决get乱码</a></li>
<li><a href="">解决post乱码</a></li>
<li><a href="">jsp乱码</a></li>
<li><a href="">@responsebody 乱码</a></li>
<li><a href="">html页面编码</a></li>
</ul>
</li>
<li><a href="">拦截器</a>
<ul>
<li><a href="">什么是拦截器</a></li>
<li><a href="">如何写一个拦截器</a></li>
<li><a href="">定义拦截器（实现登陆检查）</a>
<ul>
<li><a href="">先定义拦截器</a></li>
<li><a href="">配置拦截器</a></li>
</ul>
</li>
<li><a href="">session验证案例</a>
<ul>
<li><a href="">Controller</a></li>
<li><a href="">定义与配置拦截器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="">异常处理</a>
<ul>
<li><a href="">异常概念</a></li>
<li><a href="">异常处理思路</a></li>
<li><a href="">使用SimpleMappingExceptionResolver</a></li>
<li><a href="">实现HandlerExceptionResolver接口自定义异常处理器</a></li>
<li><a href="">@ExceptionHandler注解实现异常处理</a></li>
<li><a href="">@ResponseStatus</a></li>
<li><a href="">对于框架内部异常或代码无法捕获的异常</a></li>
</ul>
</li>
<li><a href="">文件上�</a>�
<ul>
<li><a href="">SpringMVC文件上传简介</a></li>
<li><a href="">CommonsMultipartResolver组件</a></li>
<li><a href="">实现步骤</a></li>
<li><a href="">限制文件上传类型</a></li>
</ul>
</li>
<li><a href="">文件下载</a></li>
<li><a href="">JSON数据交互</a>
<ul>
<li><a href="">kv/json</a></li>
<li><a href="">json/json</a></li>
</ul>
</li>
<li><a href="">Mock测试（模拟测试）</a>
<ul>
<li><a href="">Mock各模块介绍</a></li>
<li><a href="">MockMVC使用</a></li>
</ul>
</li>
<li><a href="">RESTful支持</a>
<ul>
<li><a href="">介绍</a></li>
<li><a href="">springMVC对RESTful的支持</a></li>
<li><a href="">静态资源访问``</a></li>
</ul>
</li>
<li><a href="">SpringMVC父子容器</a></li>
<li><a href="">跨域处理</a>
<ul>
<li><a href="">CORS</a></li>
<li><a href="">CORS请求分类</a>
<ul>
<li><a href="">简单请求</a></li>
<li><a href="">非简单请求</a></li>
</ul>
</li>
<li><a href="">CORS实现</a>
<ul>
<li><a href="">跨域提交Cookie</a></li>
<li><a href="">跨域提交Cookie</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="">@PathVariable和@RequestParam的区别</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="mvc简介"><a class="markdownIt-Anchor" href="#mvc简介"></a> MVC简介</h2>
<h3 id="mvc模式简介"><a class="markdownIt-Anchor" href="#mvc模式简介"></a> MVC模式简介</h3>
<p>是一种用于设计创建web应用程序表现层的模式</p>
<ul>
<li>M-<strong>Model</strong>模型
<ul>
<li>模型（Model）的职责是负责业务逻辑，模型包含业务模型和数据模型，数据模型用于封装数据，业务模型用于处理业务</li>
</ul>
</li>
<li>V-<strong>View</strong>视图
<ul>
<li>视图（View）的职责是负责显示界面和用户交互（手机用户信息），属于视图的组件是不包含业务逻辑和控制逻辑的JSP</li>
</ul>
</li>
<li>C-<strong>Controller</strong>控制器
<ul>
<li>控制器是模型层M和视图层V之间的桥梁，用于控制流程，比如：在Servlet项目中的单一控制器ActionServlet</li>
<li>是应用程序中处理用户交互的部分。作用一般就是处理程序逻辑的</li>
</ul>
</li>
<li>
<h2 id="关系图"><a class="markdownIt-Anchor" href="#关系图"></a> 关系图</h2>
</li>
</ul>
<h3 id="什么是spring-mvc"><a class="markdownIt-Anchor" href="#什么是spring-mvc"></a> 什么是Spring MVC</h3>
<ul>
<li>Spring MVC是Spring框架一个非常重要的功能模块，实现了MVC结构，便于简单，快速开发MVC结构的Web程序，Spring Web MVC提供的API封装了Web开发中常用的功能，简化了Web过程。</li>
<li>springMVC是为了解决表现层问题的web框架，他们都是基于MVC设计模式的，表现层的主要职责就是处理前端HTTP请求</li>
<li></li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>轻量</li>
<li>高效</li>
<li>与spring兼容好</li>
<li>功能强大</li>
<li>简洁灵活</li>
</ul>
<p><strong>功能</strong></p>
<p>清晰的角色划分</p>
<ul>
<li>控制器（controller）、验证器（validator）、 命令对象（command object）、表单对象（form object）、模型对象（model object）、 Servlet分发器（DispatcherServlet）、 处理器映射（handler mapping）、视图解析器（view resolver）等等。 每一个角色都可以由一个专门的对象来实现</li>
</ul>
<p>强大而直接的配置方式</p>
<ul>
<li>将框架类和应用程序类都能作为JavaBean配置，支持跨多个context的引用，例如，在web控制器中对业务对象和验证器（validator）的引用</li>
</ul>
<p>可适配，非侵入</p>
<ul>
<li>可以根据不同的应用常见，选择合适的控制器子类（simple型、command型、form型、wizard型、multi-action型或者自定义），而不是从单一控制器 （比如Action/ActionForm）继承</li>
</ul>
<p>可重用的业务代码</p>
<ul>
<li>可以使用现有的业务对象作为命令或表单对象，而不需要去扩展某个特定框架的基类</li>
</ul>
<p>可定制的绑定（binding） 和验证（validation）</p>
<ul>
<li>比如将类型不匹配作为应用级的验证错误， 这可以保存错误的值。再比如本地化的日期和数字绑定等等。在其他某些框架中，你只能使用字符串表单对象， 需要手动解析它并转换到业务对象</li>
</ul>
<p>可定制的handler mapping和view resolution</p>
<ul>
<li>Spring提供从最简单的URL映射， 到复杂的、专用的定制策略。与某些web MVC框架强制开发人员使用单一特定技术相比，Spring显得更加灵活</li>
</ul>
<p>灵活的model转换</p>
<ul>
<li>在Springweb框架中，使用基于Map的 键/值对来达到轻易地与各种视图技术的集成</li>
</ul>
<p>可定制的本地化和主题（theme）解析</p>
<ul>
<li>支持在JSP中可选择地使用Spring标签库、支持JSTL、支持Velocity（不需要额外的中间层）等等</li>
</ul>
<p>简单而强大的JSP标签库（Spring Tag Library）</p>
<ul>
<li>支持包括诸如数据绑定和主题（theme） 之类的许多功能。它提供在标记方面的最大灵活性</li>
</ul>
<p>JSP表单标签库</p>
<ul>
<li>在Spring2.0中引入的表单标签库，使得在JSP中编写 表单更加容易</li>
</ul>
<p>Spring Bean的生命周期可以被限制在当前的HTTP Request或者HTTP Session</p>
<ul>
<li>准确的说，这并非Spring MVC框架本身特性，而应归属于Sping MVC使用的WebApplicationContext容器。</li>
</ul>
<h3 id="核心组件处理流程"><a class="markdownIt-Anchor" href="#核心组件处理流程"></a> 核心组件/处理流程</h3>
<p><strong>核心组件</strong></p>
<ul>
<li><strong>DispatcherServlet</strong>（前端控制器，请求入口）
<ul>
<li>接受请求，依据HandlerMapping的配置调用相应的模型来处理</li>
</ul>
</li>
<li><strong>HandlerMapping</strong>（控制器，请求派发）
<ul>
<li>包含了请求路劲与模型的对应关系</li>
</ul>
</li>
<li><strong>Controller</strong>（处理器，请求处理流程）
<ul>
<li>负责处理业务逻辑</li>
</ul>
</li>
<li><strong>ModelAndView</strong>（模型，封装业务处理结果和视图）
<ul>
<li>封装了处理结果</li>
<li>注：处理结果除了数据之外，可能还有视图名</li>
</ul>
</li>
<li><strong>ViewResolver</strong>（视图解析器，视图显示处理器）
<ul>
<li>DispatcherServlet依据ViewResolver的解析，调用真正的视图对象来生成相应的页面</li>
</ul>
</li>
</ul>
<p><strong>处理流程</strong></p>
<ul>
<li>浏览器向Spring发出请求，请求交给前端控制器<strong>DispatcherServlet</strong>通过<strong>HandlerMapping</strong>找到<strong>Controller</strong>组件处理请求</li>
<li>执行<strong>Controller</strong>组件约定方法处理请求，在约定方法调用模型组件完成业务处理，约定方法可以返回一个<strong>ModelAndView</strong>对象，封装了处理结果数据和视图名称信息</li>
<li><strong>DispatcherServlet</strong>控制器接受<strong>ModelAndView</strong>之后，调用<strong>ViewResolver</strong>组件，定位View(JSP)并传递数据信息，生成响应界面结果</li>
<li></li>
<li></li>
</ul>
<h2 id="springmvc架构"><a class="markdownIt-Anchor" href="#springmvc架构"></a> springMVC架构</h2>
<p>springMVC是基于MVC设计模式的，MVC模式指的就是Model(业务模型)，View(视图)，Controller(控制器)。SpringMVC处理请求就是通过MVC这三种角色实现的</p>
<p>不过千万不要把<strong>MVC设计模式</strong>和<strong>工程的三层结构</strong>混淆，三层结构指的是<strong>表现层</strong>，<strong>业务层</strong>，<strong>数据持久层</strong>；而MVC只针对<strong>表现层</strong>进行设计</p>
<h3 id="架构流程"><a class="markdownIt-Anchor" href="#架构流程"></a> 架构流程</h3>
<ol>
<li>用户发送请求至前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li>
<li>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li>
<li>DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</li>
<li>HandlerAdapter执行处理器(handler，也叫后端控制器)。</li>
<li>Controller执行完成返回ModelAndView</li>
<li>HandlerAdapter将handler执行结果ModelAndView返回给DispatcherServlet</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li>
<li>ViewReslover解析后返回具体View对象</li>
<li>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</li>
<li>DispatcherServlet响应用户</li>
</ol>
<h3 id="组件说明"><a class="markdownIt-Anchor" href="#组件说明"></a> 组件说明</h3>
<p><strong>DispatcherServlet</strong>：前端控制器</p>
<ul>
<li>用户请求到达前端控制器，它就相当于mvc模式中的C，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</li>
</ul>
<p><strong>HandlerMapping</strong>：处理器映射器</p>
<ul>
<li>HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</li>
</ul>
<p><strong>Handler</strong>：处理器</p>
<ul>
<li>Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。</li>
<li>由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</li>
</ul>
<p><strong>HandlAdapter</strong>：处理器适配器</p>
<ul>
<li>通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行</li>
</ul>
<p><strong>View Resolver</strong>：视图解析器</p>
<ul>
<li>View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。</li>
</ul>
<p><strong>View</strong>：视图</p>
<ul>
<li>springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。</li>
<li>一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面</li>
</ul>
<blockquote>
<p>说明：在springmvc的各个组件中，<strong>处理器映射器、处理器适配器、视图解析器</strong>称为springmvc的三大组件。</p>
</blockquote>
<blockquote>
<p>需要用户开发的组件有：处理器、视图</p>
</blockquote>
<h3 id="默认配置文件"><a class="markdownIt-Anchor" href="#默认配置文件"></a> 默认配置文件</h3>
<p>spring-webmvc-xxx.jar包中有一个DispatcherServlet.properties文件，该配置中默认加载了一些springmvc默认的其他组件，其中就包括三大组件</p>
<h2 id="spring-mvc应用"><a class="markdownIt-Anchor" href="#spring-mvc应用"></a> spring MVC应用</h2>
<h3 id="搭建spring-web-mvc环境idea"><a class="markdownIt-Anchor" href="#搭建spring-web-mvc环境idea"></a> 搭建Spring Web MVC环境（IDEA）</h3>
<h5 id="maven创建spring-mvc项目"><a class="markdownIt-Anchor" href="#maven创建spring-mvc项目"></a> maven创建spring mvc项目</h5>
<ul>
<li>
<p>在Idea中新建Maven项目，选择“org.apache.maven.archetypes:maven-archetype-webapp”骨架（模板），创建一个Web项目</p>
</li>
<li>
<p>输入项目的坐标</p>
</li>
<li>
<p>选择仓库位置与配置信息，建议使用默认设置（先使用IDEA的默认设置将Maven配置好）</p>
</li>
<li>
<p>输出项目位置，点完成</p>
</li>
<li>
<p>初始化的项目如下</p>
</li>
<li>
<p>根据Maven规范，需要创建源代码、资源与测试目录</p>
</li>
<li>
<p>在main上右键创建java目录、resources目录，创建与main平级的test测试目录：</p>
</li>
<li>
<p>设置目录的特殊属性</p>
</li>
<li>
<p>设置完成后的结果</p>
</li>
</ul>
<h5 id="添加依赖的jar包"><a class="markdownIt-Anchor" href="#添加依赖的jar包"></a> 添加依赖的jar包</h5>
<ul>
<li>导入Spring Web MVC相关开发包，主要有Spring框架核心库，Spring MVC，JSTL等
<ul>
<li>pom.xml</li>
</ul>
</li>
</ul>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;com.zhangguo.springmvc01&lt;/groupId&gt;
  &lt;artifactId&gt;SpringMVC01&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;war&lt;/packaging&gt;

  &lt;name&gt;SpringMVC01 Maven Webapp&lt;/name&gt;
  &lt;!-- FIXME change it to the project&#x27;s website --&gt;
  &lt;url&gt;http://www.example.com&lt;/url&gt;

  &lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;
    &lt;spring.version&gt;4.3.0.RELEASE&lt;/spring.version&gt;
  &lt;/properties&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;4.11&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!--Spring框架核心库 --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- Spring MVC --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--Servlet核心--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
      &lt;version&gt;3.0.1&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!-- JSTL --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
      &lt;artifactId&gt;jstl&lt;/artifactId&gt;
      &lt;version&gt;1.2&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
    &lt;finalName&gt;SpringMVC01&lt;/finalName&gt;
    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.0.0&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.0.2&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.7.0&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.20.1&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.2.0&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.5.2&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.8.2&lt;/version&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
    &lt;/pluginManagement&gt;
  &lt;/build&gt;
&lt;/project&gt;</code></pre>
<p><strong>详细版pom依赖</strong></p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.lee&lt;/groupId&gt;
    &lt;artifactId&gt;springmvcDemo&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;war&lt;/packaging&gt;

    &lt;name&gt;springmvcDemo Maven Webapp&lt;/name&gt;
    &lt;!-- FIXME change it to the project&#x27;s website --&gt;
    &lt;url&gt;http://www.example.com&lt;/url&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;!-- 持久层：mysql驱动、dbcp连接池、mybatis、mybatis和spring整合依赖、spring依赖 --&gt; &lt;!-- 业务层：aop相关依赖 --&gt;
    &lt;dependencies&gt;
        &lt;!-- spring ioc组件需要的依赖包 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;
            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- 基于AspectJ的aop依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;aopalliance&lt;/groupId&gt;
            &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;
            &lt;version&gt;1.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- spring 事务管理和JDBC依赖包 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- spring 单元测试组件包 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- 单元测试Junit --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- mysql数据库驱动包 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.35&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- dbcp连接池的依赖包 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;
            &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;
            &lt;version&gt;1.4&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- mybatis依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.4.5&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- mybatis和spring的整合依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;1.3.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--spring mvc依赖包--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--Servlet核心--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
            &lt;version&gt;2.5&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!-- JSTL --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;finalName&gt;springmvcDemo&lt;/finalName&gt;
        &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;
            &lt;plugins&gt;
                &lt;!-- 配置Maven的JDK编译级别 --&gt;
                &lt;plugin&gt;
                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.2&lt;/version&gt;
                    &lt;configuration&gt;
                        &lt;source&gt;1.8&lt;/source&gt;
                        &lt;target&gt;1.8&lt;/target&gt;
                        &lt;encoding&gt;UTF-8&lt;/encoding&gt;
                    &lt;/configuration&gt;
                &lt;/plugin&gt;
&lt;!--                &amp;lt;!&amp;ndash; 配置Tomcat插件 &amp;ndash;&amp;gt;--&gt;
&lt;!--                &lt;plugin&gt;--&gt;
&lt;!--                    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;--&gt;
&lt;!--                    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;--&gt;
&lt;!--                    &lt;version&gt;2.2&lt;/version&gt;--&gt;
&lt;!--                    &lt;configuration&gt;--&gt;
&lt;!--                        &lt;port&gt;8080&lt;/port&gt;--&gt;
&lt;!--                        &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt;--&gt;
&lt;!--                    &lt;/configuration&gt;--&gt;
&lt;!--                &lt;/plugin&gt;--&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.1.0&lt;/version&gt;
                &lt;/plugin&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.0.2&lt;/version&gt;
                &lt;/plugin&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.8.0&lt;/version&gt;
                &lt;/plugin&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
                    &lt;version&gt;2.22.1&lt;/version&gt;
                &lt;/plugin&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.2.2&lt;/version&gt;
                &lt;/plugin&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;
                    &lt;version&gt;2.5.2&lt;/version&gt;
                &lt;/plugin&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;
                    &lt;version&gt;2.8.2&lt;/version&gt;
                &lt;/plugin&gt;
            &lt;/plugins&gt;
        &lt;/pluginManagement&gt;
        &lt;!--maven默认不加载xml非resources目录下的xml文件，Mapper文件就无法加载，所以得加上如下配置--&gt;
        &lt;resources&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/java&lt;/directory&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.xml&lt;/include&gt;
                &lt;/includes&gt;
                &lt;filtering&gt;true&lt;/filtering&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<h3 id="spring-mvc配置文件"><a class="markdownIt-Anchor" href="#spring-mvc配置文件"></a> Spring MVC配置文件</h3>
<p>不配置 <code>&lt;mvc:annotation-driven/&gt;</code>也可以正常使用@RequestMapping注解的原因是，spring-webmvc-xxx.jar包中有一个DispatcherServlet.properties文件，该配置中默认加载了一些springmvc默认的其他组件，其中就包括三大组件<strong>HandlerMapping,HandlerAdapter,ViewResolver</strong></p>
<ul>
<li>在resource下添加Spring的XML配置文件
<ul>
<li>名称可自定义，例如spring-mvc.xml</li>
</ul>
</li>
</ul>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!--配置注解扫描,多个包中间使用半角逗号分隔 --&gt;
    &lt;context:component-scan base-package=&quot;com.lee.controller&quot;/&gt;
    &lt;!-- Spring MVC不处理静态资源 --&gt;
    &lt;mvc:default-servlet-handler /&gt;
    &lt;!--在spring中一般采用@RequestMapping注解来完成映射关系， 要想使@RequestMapping注解生效必须向上下文中注册DefaultAnnotationHandlerMapping和一个AnnotationMethodHandlerAdapter 实例，这两个实例分别在类级别和方法级别处理。而annotation-driven配置帮助我们自动完成上述两个实例的注入。--&gt;
    &lt;!--配置注解的适配器和映射器，同时还注入了其他很多的bean--&gt;
    &lt;mvc:annotation-driven/&gt;

    &lt;!-- 视图解析器（该解析器不配置也会默认加载，但是自己配置的话可以注入自定义配置）--&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/item/&quot;/&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<blockquote>
<p>视图解析器中我们把所有的视图都放在/WEB-INF/目录下，这样是为了视图安全，因为这个目录用户端不能直接访问</p>
</blockquote>
<hr />
<p><strong>mvc:annotation-drivern</strong>标签的作用，详见AnnotationDrivenBeanDefinitionParser类的parse方法。</p>
<p>分析得知：mvc:annotation-drivern往spring容器中注册了以下的一些BeanDefinition：</p>
<p><strong>RequestMappingHandlerMapping</strong>：注解式处理器映射器，对类中标记@ResquestMapping的方法进行映射，根据ResquestMapping定义的url匹配ResquestMapping标记的方法，匹配成功返回HandlerMethod对象给前端控制器，HandlerMethod对象中封装url对应的方法Method。</p>
<p><strong>RequestMappingHandlerAdapter</strong>：注解式处理器适配器，对标记@ResquestMapping的方法进行适配</p>
<pre><code class="highlight plaintext">&lt;!--注解映射器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;
&lt;!--注解适配器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;

&lt;!--替换上面两句--&gt;
&lt;mvc:annotation-driven/&gt;</code></pre>
<blockquote>
<p>springmvc.xml配置文件中使用<code>&lt;mvc:annotation-driven/&gt;</code>标签替代bean标签配置的注解处理器和适配器</p>
</blockquote>
<h3 id="配置dispatcherservletwebxml"><a class="markdownIt-Anchor" href="#配置dispatcherservletwebxml"></a> 配置DispatcherServlet（web.xml）</h3>
<ul>
<li>Spring MVC框架像许多其他MVC框架一样, 请求驱动,围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。如下图所示当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者</li>
<li></li>
<li>在web.xml中配置DispatcherServlet前端控制器组件
<ul>
<li>DispatcherServlet组件在spring mvc中已提供，只需配置即可</li>
<li>配置DispatcherServlet时，同时指定xml配置文件</li>
</ul>
</li>
</ul>
<pre><code class="highlight plaintext">&lt;!DOCTYPE web-app PUBLIC
 &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;
 &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;

&lt;web-app&gt;
  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;

  &lt;!--配置前端控制器--&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!--设置spring配置文件路径--&gt;
    &lt;!--如果不设置初始化参数，那么DispatcherServlet会读取默认路径下的配置文件--&gt;
    &lt;!--默认配置文件路径：/WEB-INF/springmvc-servlet.xml--&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
      &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!--指定初始化日期，设置为2，表示tomcat启动时，DispatcherServlet会跟随着初始化--&gt;
    &lt;!--如果未指定初始化日期，DispatcherServlet就会在第一次请求的时候，才会初始化，而且只会被初始化一次--&gt;
    &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;
  &lt;/servlet&gt;

  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;!--url-pattern的配置--&gt;
    &lt;!--不要配置为/*，否则会报错（因为它拦截了jsp请求但是不会去处理）--&gt;
    &lt;!--通俗解释：/*会拦截整个项目中的资源访问，包含jsp和静态资源的访问，对于静态资源的访问springMVC提供了默认的handler处理器--&gt;
    &lt;!--但是对于jsp来讲，springMVC没有提供默认的处理器，我们也没有手动编写对应的处理器，此时按照springMVC的处理流程分析得知，它短路了--&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
</code></pre>
<p><strong>url-pattern匹配顺序详解</strong></p>
<p><strong>web.xml配置内容的加载顺序</strong></p>
<h3 id="编写处理器handlercontroller"><a class="markdownIt-Anchor" href="#编写处理器handlercontroller"></a> 编写处理器Handler（Controller）</h3>
<p>处理器开发方式有多种：实现HttpRequestHandler接口、实现Controller接口、<strong>注解方式</strong>等。</p>
<h4 id="方式一接口方式"><a class="markdownIt-Anchor" href="#方式一接口方式"></a> <s>方式一（接口方式）</s></h4>
<p>不推荐使用</p>
<p><strong>1 HandlerMapping组件（映射器）</strong></p>
<ul>
<li>通过handlerMapping组件，DispatcherServlet控制器可以将客户HTTP请求映射到Controller组件上</li>
<li><strong>SimpleUrlHandlerMapping</strong>
<ul>
<li>维护一个HTTP请求和Controller映射关系表（map）,根据列表对应关系调用Controller</li>
</ul>
</li>
</ul>
<pre><code class="highlight plaintext">       &lt;!-- 配置HandlerMapping --&gt;
       &lt;bean 
class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;
             &lt;property name=&quot;mappings&quot;&gt;
                    &lt;props&gt;
                           &lt;prop key=&quot;/hello.do&quot;&gt;helloController&lt;/prop&gt;
                    &lt;/props&gt;
             &lt;/property&gt;
       &lt;/bean&gt;
       &lt;!-- 配置处理器，这里的id要和上面的prop中的值相等，才能调用 --&gt;
       &lt;bean id=&quot;helloController&quot; class=&quot;controller.HelloController&quot;&gt;&lt;/bean&gt;</code></pre>
<ul>
<li><strong>RequestMappingHandlerMapping</strong></li>
<li><strong>RequestMappingHandlerAdapter</strong>
<ul>
<li>在Controller类和方法上使用@RequestMapping注解指定对应的客户HTTP请求</li>
</ul>
</li>
</ul>
<p><strong>2 Controller组件（处理器）</strong></p>
<ul>
<li>实现Controller有两种方法
<ol>
<li>实现Controller接口,重写handleRequest方法</li>
<li>使用@Controller定义控制器</li>
</ol>
</li>
<li>Controller组件负责执行具体的业务逻辑，可以调用DAO等组件，编写时需要实现Controller接口及约定的方法</li>
</ul>
<blockquote>
<p>这是一种比较古老的方式，缺点是：一个控制器中只有一个Action，如果要多个Action，则需要定义多个Controller，定义方式比较麻烦，推荐<strong>使用注解的方法</strong></p>
</blockquote>
<pre><code class="highlight plaintext">public class HelloController implements Controller&#123;
    public ModelAndView handleRequest(HttpServletRequest req,HttpServletResponse res) throws Exception&#123;
        System.out.println(&quot;hello spring!&quot;);
                     /*
              * ModelAndView有两个构造器
              *     1.ModelAndView(String viewName)
              *     viewName就是视图名
              *  2.ModelAndView(String viewName,Map date)
              *     map用于封装处理结果的数据
              */ 
        return new ModelAndView(&quot;hello&quot;);//下一个ppt
    &#125;
&#125;</code></pre>
<h4 id="方式二注解方式"><a class="markdownIt-Anchor" href="#方式二注解方式"></a> 方式二（注解方式）</h4>
<p><strong>@Controller注解</strong>：在类上添加该注解，指定该类为一个请求处理器，不需要实现任何接口或者继承任何类。</p>
<p><strong>@RequestMapping注解</strong>：在方法上添加该注解，指定请求的url由该方法处理。其中“.do”可以加也可以不加。</p>
<p>处理器的返回值是ModelAndView对象，该对象的具体理解如下：</p>
<p><strong>ModelAndView</strong>：方法返回值对象，该对象包含两个功能：一个是将数据存储到Request域中，一个是设置响应视图，比如将视图设置为“/WEB-INF/jsp/itemList.jsp”</p>
<pre><code class="highlight plaintext">package com.lee.controller;

import com.lee.pojo.Item;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpSession;
import java.util.ArrayList;
import java.util.List;

@Controller
public class ItemController &#123;

    //@RequestMapping此时填写的是URL
    //ModelAndView表示的是数据模型，view就是最终要展示给用户的视图
    @RequestMapping(&quot;queryItem&quot;)
    public ModelAndView queryItem(HttpSession session)&#123;
        List&lt;Item&gt; items = new ArrayList&lt;Item&gt;();

        items.add(new Item(&quot;联想笔记本&quot;, (float) 5000,&quot;ThinkPad T430 联想笔记本电脑&quot;));
        items.add(new Item(&quot;苹果手机&quot;, (float) 8000,&quot;iPhone 11 苹果手机&quot;));

        System.out.println(items.get(0));
        System.out.println(items.get(1));

        ModelAndView modelAndView = new ModelAndView();

        //设置数据模型，相当于request的setAttrbute方法，实质上，底层也确实是转成了request
        //先将k/v数据放入map中，最终根据视图对象不同，在进行后续处理
        modelAndView.addObject(&quot;itemList&quot;,items);

        //设置视图（逻辑路径）
        modelAndView.setViewName(&quot;item-list&quot;);
        return modelAndView;
    &#125;
&#125;</code></pre>
<blockquote>
<p>注解为@<strong>Controller</strong>是为了让Spring IOC容器初始化时自动扫描到；@<strong>RequestMapping</strong>是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/hello/hi；方法中声明Model类型的参数是为了把Action中的数据带到视图中；方法返回的结果是<strong>视图的名称</strong>hi，加上配置文件中的前后缀变成WEB-INF/view/hi.jsp</p>
</blockquote>
<p>pojo类</p>
<pre><code class="highlight plaintext">package com.lee.pojo;

import java.util.Date;
public class Item &#123;
    private Integer id;
    private String name;
    private Float price;
    private String pic;
    private Date createtime;
    private String detail;

    public Item(String name,Float price,String detail)&#123;
        this.id = 1;
        this.name = name;
        this.price = price;
        this.pic = &quot;哈哈&quot;;
        this.createtime = new Date();
        this.detail = detail;
    &#125;
    public Integer getId() &#123;
        return id;
    &#125;
    public void setId(Integer id) &#123;
        this.id = id;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public Float getPrice() &#123;
        return price;
    &#125;
    public void setPrice(Float price) &#123;
        this.price = price;
    &#125;
    public String getPic() &#123;
        return pic;
    &#125;
    public void setPic(String pic) &#123;
        this.pic = pic;
    &#125;
    public Date getCreatetime() &#123;
        return createtime;
    &#125;
    public void setCreatetime(Date createtime) &#123;
        this.createtime = createtime;
    &#125;
    public String getDetail() &#123;
        return detail;
    &#125;
    public void setDetail(String detail) &#123;
        this.detail = detail;
    &#125;
    public String toString() &#123;
        return &quot;Item&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +
                &quot;, price=&quot; + price +
                &quot;, pic=&#x27;&quot; + pic + &#x27;\&#x27;&#x27; +
                &quot;, createtime=&quot; + createtime +
                &quot;, detail=&#x27;&quot; + detail + &#x27;\&#x27;&#x27; +
                &#x27;&#125;&#x27;;    &#125;&#125;</code></pre>
<h3 id="创建视图"><a class="markdownIt-Anchor" href="#创建视图"></a> 创建视图</h3>
<ul>
<li>在WEB-INF/view目录中创建视图，hi.jsp视图将从Action中带回的信息展示，具体内容如下：</li>
</ul>
<p><strong>一定要注意加上<code>&lt;%@page isELIgnored=&quot;false&quot;%&gt;</code>，否则$符号无法使用</strong></p>
<pre><code class="highlight plaintext">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;
&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;
&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot; %&gt;

&lt;%@page isELIgnored=&quot;false&quot;%&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
    &lt;title&gt;查询商品列表&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;$&#123;pageContext.request.contextPath &#125;/itemList.do&quot; method=&quot;post&quot;&gt;
    查询条件：
    &lt;table width=&quot;100%&quot; border=1&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;查询&quot;/&gt;&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
    商品列表：
    &lt;table width=&quot;100%&quot; border=1&gt;
        &lt;tr&gt;
            &lt;td&gt;商品名称&lt;/td&gt;
            &lt;td&gt;商品价格&lt;/td&gt;
            &lt;td&gt;生产日期&lt;/td&gt;
            &lt;td&gt;商品描述&lt;/td&gt;
            &lt;td&gt;操作&lt;/td&gt;
        &lt;/tr&gt;
        &lt;c:forEach items=&quot;$&#123;itemList&#125;&quot; var=&quot;item&quot;&gt;
            &lt;tr&gt;
                &lt;td&gt;$&#123;item.name&#125;&lt;/td&gt;
                &lt;td&gt;$&#123;item.price&#125;&lt;/td&gt;
                &lt;td&gt;&lt;fmt:formatDate value=&quot;$&#123;item.createtime&#125;&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&lt;/td&gt;
                &lt;td&gt;$&#123;item.detail&#125;&lt;/td&gt;

                &lt;td&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/itemEdit.do?id=$&#123;item.id&#125;&quot;&gt;修改&lt;/a&gt;&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/c:forEach&gt;

    &lt;/table&gt;
&lt;/form&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
<h4 id="modelandview组件"><a class="markdownIt-Anchor" href="#modelandview组件"></a> ModelAndView组件</h4>
<ul>
<li>Controller组件约定的handleRequest方法执行后返回一个ModelAndView对象，该对象可封装模型数据和视图名响应信息，ModelAndView构造器如下
<ul>
<li><code>ModelAndView(String viewName)</code></li>
<li><code>ModelAndView(String viewName,Map model)</code></li>
</ul>
</li>
<li>viewName是jsp页面名字</li>
<li>model的数据存储到request的attribute中</li>
</ul>
<pre><code class="highlight plaintext">@RequestMapping(&quot;listCategory&quot;)
public ModelAndView listCategory() &#123; 
    //创建一个模型视图对象 
    ModelAndView mav = new ModelAndView(); 
    //获取到查询的数据 
    List&lt;Category&gt; cs= categoryService.list(); 
    //将数据放置到ModelAndView对象view中,第二个参数可以是任何java类型 
    mav.addObject(&quot;cs&quot;, cs); 
    // 放入jsp路径 ，或者可以new的时候直接绑定路径
    mav.setViewName(&quot;listCategory&quot;); 
    //返回ModelAndView对象mav 
    return mav; 
&#125;</code></pre>
<p><strong>JSP取值</strong></p>
<pre><code class="highlight plaintext">&lt;!-- 使用c标签库，循环遍历出数据 ，命名为c--&gt; 
&lt;c:forEach items=&quot;$&#123;cs&#125;&quot; var=&quot;c&quot; varStatus=&quot;st&quot;&gt; 
    &lt;tr&gt; 
        &lt;td&gt;$&#123;c.id&#125;&lt;/td&gt; 
        &lt;td&gt;$&#123;c.name&#125;&lt;/td&gt; 
    &lt;/tr&gt;
&lt;/c:forEach&gt;</code></pre>
<h5 id="model和modelmap"><a class="markdownIt-Anchor" href="#model和modelmap"></a> Model和ModelMap</h5>
<p>ModelMap对象主要用于传递控制方法处理数据到结果页面，也就是说我们把结果页面上需要的数据放到ModelMap对象中即可；</p>
<p>他的作用类似于request对象的setAttribute方法的作用: 用来在一个请求过程中传递处理的数据。</p>
<p>ModelMap或者Model通过<code>addAttribute</code>方法向页面传递参数.</p>
<p>然后在jsp页面上可以通过el表达式语言$attributeName或者是C标签库下的方法，来获取并展示modelmap中的数据。</p>
<p><strong>modelmap本身不能设置页面跳转的url地址别名或者物理跳转地址</strong>.</p>
<p>那么我们可以通过控制器方法的字符串返回值来设置跳转url地址别名或者物理跳转地址</p>
<pre><code class="highlight plaintext">@RequestMapping(value=&quot;/list-books&quot;)
private String getAllBooks(Model model)&#123;
    logger.error(&quot;/list-books&quot;);
    List&lt;Book&gt; books= bookService.getAllBooks();
    //绑定数据，相当于request.setAttribute()
    //在jsp页面利$&#123;books&#125;即可取出其中的值
    model.addAttribute(&quot;books&quot;, books);
    //返回视图名，即BookList.jsp，这个要看自己具体配置
    return &quot;BookList&quot;;
&#125;</code></pre>
<blockquote>
<p>在jsp页面利<code>$&#123;books&#125;</code>即可取出其中的值</p>
</blockquote>
<h5 id="modelandview和model的区别"><a class="markdownIt-Anchor" href="#modelandview和model的区别"></a> ModelAndView和Model的区别</h5>
<p><strong>Model</strong>是每次请求中都存在的默认参数，利用其addAttribute()方法即可将服务器的值传递到jsp页面中；</p>
<p><strong>ModelAndView</strong>包含model和view两部分，使用时需要自己实例化，利用ModelMap用来传值，也可以设置view的名称，ModelAndView的实例是需要我们手动new的，这也是和ModelMap的一个区别</p>
<p>而且，ModelAndView 可以自己寻址，只需要return 返回其对象即可</p>
<h4 id="viewresolver组件"><a class="markdownIt-Anchor" href="#viewresolver组件"></a> ViewResolver组件</h4>
<ul>
<li>所有Controller组件都返回一个ModelAndView实例，封装了视图名，spring中的视图以名字为标识，视图解析器ViewResolver通过名字来解析视图</li>
<li>Spring提供了多种视图解析器
<blockquote>
<p><strong>UrlBasedViewResolver</strong> <code>将视图名直接解析成对应的URL，不需要显示的映射定义，如果你的视图名和视图资源的名字是一致的，就可以使用该解释器，而无须进行映射</code></p>
<p><strong>InternalResourceViewResolver</strong> <code>UrlBasedViewResolver的子类，它支持InternalResourceView（对Servlet和JSP的包装），以及其子类JstlView和TilesView响应类型</code></p>
<p><strong>XmlViewResolver</strong> <code>支持用XML文件定义具体的响应视图文件</code></p>
<p><strong>VelocityViewResolver/FreeMarkerViewResolver</strong><code>UrlBasedViewResolver的子类，他能支持Velocity和FreeMarker等视图技术</code></p>
</blockquote>
</li>
<li><strong>InternalResourceViewResolver使用实例如下</strong></li>
</ul>
<pre><code class="highlight plaintext">       &lt;!-- 配置ViewResolver视图解析器 --&gt;
       &lt;bean 
class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
             &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot;&gt;&lt;/property&gt;
             &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;
       &lt;/bean&gt;</code></pre>
<blockquote>
<p>如：视图名hello<code>（即new ModelAndView(&quot;hello&quot;)中的参数）</code>通过以上配置可以映射到/WEB-INF/jsp/hello.jsp</p>
</blockquote>
<h3 id="配置tomcat部署项目"><a class="markdownIt-Anchor" href="#配置tomcat部署项目"></a> 配置tomcat部署项目</h3>
<ul>
<li>
<p>点击右上角的Edit Configurations添加对tomcat的配置</p>
</li>
<li>
<p>添加对tomcat的配置，设置名称，添加Deployment</p>
</li>
<li>
<p>可以设置context也可以没有，类似虚拟目录</p>
</li>
</ul>
<h3 id="设置引导页"><a class="markdownIt-Anchor" href="#设置引导页"></a> 设置引导页</h3>
<ul>
<li>使用了spring mvc如果想直接访问控制器下的某个action为引导页，可以通过如下方式实现：<br />
<strong>方法一</strong></li>
<li>删除index.jsp默认引导文件</li>
<li>定义以下Home控制器，如下所示</li>
</ul>
<pre><code class="highlight plaintext">package com.zhangguo.springmvc01.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

/**控制器*/
@Controller
@RequestMapping(&quot;/&quot;)
public class HomeController &#123;

    /**动作，action*/
    @RequestMapping(&quot;&quot;)
    public String index(Model model)&#123;
        //向模型中添加属性msg与值，将与页面模板渲染后输出
        model.addAttribute(&quot;msg&quot;,&quot;Welcome my website!&quot;);
        return &quot;hi&quot;;
    &#125;

&#125;</code></pre>
<p><strong>方法二</strong></p>
<ul>
<li>修改Spring MVC配置文件，增加如下配置：</li>
</ul>
<pre><code class="highlight plaintext">&lt;!--此标签用以在springMVC配置文件中实现路径的转发和资源的请求--&gt;
&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;redirect:/hello/&quot;&gt;&lt;/mvc:view-controller&gt;</code></pre>
<pre><code class="highlight plaintext">package com.zhangguo.springmvc01.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

/**控制器*/
@Controller
@RequestMapping(&quot;/hello&quot;)
public class HelloController &#123;

    /**动作，action*/
    @RequestMapping(&quot;/hi&quot;)
    public String hi(Model model)&#123;
        //向模型中添加属性msg与值，将与页面模板渲染后输出
        model.addAttribute(&quot;msg&quot;,&quot;Hello Spring MVC!&quot;);
        return &quot;hi&quot;;
    &#125;

    /**动作，action*/
    @RequestMapping(&quot;&quot;)
    public String index(Model model)&#123;
        //向模型中添加属性msg与值，将与页面模板渲染后输出
        model.addAttribute(&quot;msg&quot;,&quot;Index Page!&quot;);
        return &quot;hi&quot;;
    &#125;

&#125;</code></pre>
<blockquote>
<p>注意这种方法是使用的重定向方式，需发起两次请求，尽量转发</p>
</blockquote>
<h2 id="springmvc详解"><a class="markdownIt-Anchor" href="#springmvc详解"></a> SpringMVC详解</h2>
<ul>
<li>导包</li>
<li>添加spring的配置文件</li>
<li>配置DispatcherServlet</li>
<li>写Controller</li>
<li>写jsp</li>
<li>在spring配置文件中，添加如下配置
<ul>
<li>a.组件扫描</li>
<li>b.mvc注解扫描</li>
<li>c.视图解析器</li>
<li></li>
</ul>
</li>
</ul>
<h3 id="requestmapping注解"><a class="markdownIt-Anchor" href="#requestmapping注解"></a> @RequestMapping注解</h3>
<p><strong>spring.xml定义</strong></p>
<ul>
<li>开启@RequestMapping注解映射，需要在Spring的xml配置文件中定义<strong>RequestMappingHandlerMapping</strong>（注解映射器）和<strong>RequestMappingHandlerAdapter</strong>（注解适配器）两个bean组件</li>
</ul>
<pre><code class="highlight plaintext">Spring 3.1版本之前需要定义
&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;
&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;

Spring3.2之后可以使用下面xml简化配置
&lt;mvc:annotation-driven/&gt;</code></pre>
<h4 id="属性"><a class="markdownIt-Anchor" href="#属性"></a> 属性</h4>
<h5 id="value属性"><a class="markdownIt-Anchor" href="#value属性"></a> value属性</h5>
<p><strong>基础用法</strong></p>
<ul>
<li>@RequestMapping可以用在类定义和方法定义上
<ul>
<li><strong>用在类上</strong>：表示类中的所有响应请求的方法都是以该地址作为父路径，通过此种方法对url进行分类管理</li>
<li><strong>用在方法上</strong>：URL路径映射</li>
</ul>
</li>
<li>@RequestMapping表明这个<strong>类</strong>或<strong>方法</strong>与哪一个客户请求想对应</li>
<li><strong>方法名不作要求，返回类型可以是ModelAndview，也可以是String</strong></li>
<li>当@<strong>RequestMapping为空</strong>时
<ul>
<li>注解在方法时，表示该方法为类下默认的action</li>
<li>注解在类上时，可表示项目的起始页</li>
</ul>
</li>
</ul>
<pre><code class="highlight plaintext">/*
 * 如何写一个处理器：
 * 1.不用实现Controller接口
 * 2.可以在处理器类当中，添加多个方法，每一个方法处理一种类型的请求
 * 3.方法名不作要求，返回类型可以是ModelAndview，也可以是String
 * 4.使用@Controler，将该处理器纳入容器进行管理（也就是说，spring配置文件不用配置该处理器了）
 * 5.使用@RequestMapping，告诉前端控制器（DispatcherServlet），请求路径与处理器的方法对应关系（spring配置文件不用配置HandlerMapping了）
 * 
 */
@Controller
@RequestMapping(&quot;/login&quot;)
//@RequestMapping(value=&#123;&quot;/item&quot;,&quot;/item2&quot;&#125;)
public class HelloController &#123;
       @RequestMapping(&quot;/hello.do&quot;)                                                                                        // http://localhost:8080/srpingmvc02/login/hello.do
       public String hello() &#123;
             System.out.println(&quot;hello()&quot;);
             return &quot;hello&quot;;
       &#125;
@RequestMapping(&quot;/toLogin.do&quot;)
        // //http://localhost:8080/srpingmvc02/login/toLogin.do
        public String toLogin()&#123;
            System.out.println(&quot;toLogin()&quot;);
            return &quot;login&quot;;
            &#125;
        
    @RequestMapping
   //http://localhost:8087/SpringMVC02/login
    public String action2(Model model)&#123;
        //在模型中添加属性message值为action2，渲染页面时使用
        model.addAttribute(&quot;message&quot;, &quot;action2&quot;);
        return &quot;foo/index&quot;;    
&#125;</code></pre>
<p><strong>路径变量占位URL模板模式</strong></p>
<ul>
<li>可以使用@<strong>PathVariable</strong>注释方法参数的值绑定到一个URL模板变量</li>
</ul>
<pre><code class="highlight plaintext">@RequestMapping(&quot;/action3/&#123;p1&#125;/&#123;p2&#125;&quot;)
    public String action3(@PathVariable int p1,@PathVariable int p2,Model model)&#123;
        model.addAttribute(&quot;message&quot;, p1+p2);
        return &quot;foo/index&quot;;
    &#125;</code></pre>
<blockquote>
<p>使用路径变量的<strong>好处</strong>：使路径变得更加简洁；获得参数更加方便，框架会自动进行类型转换。通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到action，如这里访问是的路径是/action3/1/a，则路径与方法不匹配，而不会是参数转换失败</p>
</blockquote>
<p><strong>正则表达式模式的URL模板</strong></p>
<ul>
<li>案例要求id必须为6位数字，name必须位3位小写字母</li>
</ul>
<pre><code class="highlight plaintext">@RequestMapping(value=&quot;/action4/&#123;id:\\d&#123;6&#125;&#125;-&#123;name:[a-z]&#123;3&#125;&#125;&quot;)
    public String action4(@PathVariable int id,@PathVariable String name,Model model)&#123;
        model.addAttribute(&quot;message&quot;, &quot;id:&quot;+id+&quot; name:&quot;+name);
        return &quot;foo/index&quot;;
    &#125;</code></pre>
<p><strong>矩阵变量@MatrixVariable</strong></p>
<ul>
<li>矩阵变量可以出现在任何路径段,每个矩阵变量用“;”分隔。例如:“/汽车;颜色=红;年=2012”。多个值可以是“,”分隔“颜色=红、绿、蓝”或变量名称可以重复“颜色=红;颜色=绿色;颜色=蓝”，如下所示：</li>
<li>案例1</li>
</ul>
<pre><code class="highlight plaintext">// GET /pets/42;q=11;r=22
    @RequestMapping(value = &quot;/pets/&#123;petId&#125;&quot;)
    public void findPet(@PathVariable String petId, @MatrixVariable int q) &#123;
        // petId == 42
        // q == 11
    &#125;</code></pre>
<ul>
<li>案例2</li>
</ul>
<pre><code class="highlight plaintext">// 矩阵变量
    @RequestMapping(value = &quot;/action5/&#123;name&#125;&quot;)
    public String action5(Model model, 
            @PathVariable String name,   //路径变量，用于获得路径中的变量name的值
            @MatrixVariable String r,
            @MatrixVariable(required = true) String g,  //参数g是必须的
            @MatrixVariable(defaultValue = &quot;99&quot;, required = false) String b) &#123;  //参数b不是必须的，默认值是99
        model.addAttribute(&quot;message&quot;, name + &quot; is #&quot; + r + g + b);
        return &quot;foo/index&quot;;
    &#125;
    //Get http://localhost:8087/SpringMVC02/action5/the%20book%20color;r=33;g=66
    //the book color is #336699</code></pre>
<ul>
<li>默认时不允许使用矩阵变量的，需要设置配置文中的RequestMappingHandlerMapping的属性removeSemicolonContent为false；在annotation-driven中增加属性enable-matrix-variables=“true”，修改后的springmvc-servlet.xml文件如下：</li>
</ul>
<pre><code class="highlight plaintext">&lt;!-- 支持mvc注解驱动 --&gt;
    &lt;mvc:annotation-driven enable-matrix-variables=&quot;true&quot; /&gt;

    &lt;!-- 配置映射媒体类型的策略 --&gt;
    &lt;bean
        class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;&gt;
        &lt;property name=&quot;removeSemicolonContent&quot; value=&quot;false&quot; /&gt;
    &lt;/bean&gt;</code></pre>
<p><strong>Ant风格路径模式</strong></p>
<ul>
<li></li>
<li></li>
<li></li>
<li>@RequestMapping注解也支持ant风格的路径模式，如/myPath/<em>.do，/owners/</em>/pets/{petId}，示例代码如下：</li>
</ul>
<pre><code class="highlight plaintext">//http://localhost:8080/SpringMVC02/action6/ant.do
//Ant风格路径模式
    @RequestMapping(value = &quot;/action6/*.do&quot;)
    public String action6(Model model)&#123; 
        model.addAttribute(&quot;message&quot;,&quot;Ant风格路径模式&quot;);
        return &quot;foo/index&quot;;
    &#125;</code></pre>
<p><strong>处理多个URI</strong></p>
<ul>
<li>你可以将多个请求映射到一个方法上去，只需要添加一个带有请求路径值列表的 @RequestMapping 注解就行了</li>
</ul>
<pre><code class="highlight plaintext">@RestController  
@RequestMapping(&quot;/home&quot;)  
public class IndexController &#123;  
  
    @RequestMapping(value = &#123;&quot;&quot;,&quot;/page&quot;,&quot;page*&quot;,  &quot;view/*&quot;,&quot;**/msg&quot;&#125;)  
    String indexMultipleMapping() &#123;  
        return &quot;Hello from index multiple mapping.&quot;;  
    &#125;  
&#125;

可以匹配路径
localhost:8080/home
localhost:8080/home/
localhost:8080/home/page
localhost:8080/home/pageabc
localhost:8080/home/view/
localhost:8080/home/view/view</code></pre>
<h5 id="methodsconsumesproducesparamsheaderspath属性"><a class="markdownIt-Anchor" href="#methodsconsumesproducesparamsheaderspath属性"></a> methods/consumes/produces/params/headers/path属性</h5>
<p><strong>method属性指定请求类型</strong></p>
<ul>
<li>用于约束请求的谓词类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE，如下代码所示：</li>
</ul>
<pre><code class="highlight plaintext">//谓词类型
    @RequestMapping(value = &quot;/action6&quot;,method=&#123;RequestMethod.POST,RequestMethod.DELETE&#125;)
    public String action6(Model model) &#123;
        model.addAttribute(&quot;message&quot;, &quot;请求谓词只能是POST与DELETE&quot;);
        return &quot;foo/index&quot;;
    &#125;</code></pre>
<p><strong>consumes属性指定请求的Content-Type</strong></p>
<ul>
<li>@RequestMapping 注解的 produces 和 consumes 这两个元素来缩小请求映射类型的范围，达到处理生产和消费对象的目的</li>
<li>指定处理请求的提交内容类型（Content-Type），例如application/json, text/html，收窄请求范围，<strong>如果用户发送的请求内容类型不匹配则方法不会响应请求</strong>，具体使用如下代码所示：</li>
</ul>
<pre><code class="highlight plaintext">package com.zhangguo.springmvc02.controllers;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
@RequestMapping(&quot;/home&quot;)
public class HomeController &#123;
    // 请求内容类型必须为text/html，注意浏览器默认没有指定Content-type
    @RequestMapping(value = &quot;/action8&quot;,consumes=&quot;text/html&quot;)
    public String action8(Model model) &#123;
        model.addAttribute(&quot;message&quot;, &quot;请求的提交内容类型（Content-Type）是text/html&quot;);
        return &quot;foo/index&quot;;
    &#125;
&#125;</code></pre>
<blockquote>
<p>注意：可以使用！号，如consumes=“!text/html”</p>
</blockquote>
<p><strong>produces属性指定响应的Content-Type</strong></p>
<ul>
<li>设置响应体包头中的<strong>Content-Type</strong>属性，常用<strong>来解决乱码</strong></li>
<li>指定返回的内容类型，<strong>仅当request请求头中的(Accept)类型中包含该指定类型才返回</strong>(请求头中的Accept指明浏览器能接受的类型)，方法才处理客户端的请求否则会报406错误，常用设置如下：
<ul>
<li>produces = “text/plain”  //客户端只接收纯文本</li>
<li>produces = {“text/plain”, “application/*”}   //客户端接收纯文本与application/*类型的内容</li>
<li>produces = “application/json; charset=UTF-8”  <strong>设置响应体中Content-Type</strong></li>
</ul>
</li>
</ul>
<pre><code class="highlight plaintext">//设置响应体的包头中Content-Type设置为application/json；charset=utf-8
    @RequestMapping(value = &quot;/action9&quot;,produces=&quot;application/json; charset=UTF-8&quot;)
    public String action9(Model model) &#123;
        model.addAttribute(&quot;message&quot;, &quot;客户端可以接收的类型是application/json; charset=UTF-8&quot;);
        return &quot;foo/index&quot;;
    &#125;</code></pre>
<blockquote>
<p>注意：可以使用！号，如produces=“!text/html”</p>
</blockquote>
<p><strong>params属性指定请求中必须有特定参数与值</strong></p>
<ul>
<li>映射请求的参数，收窄请求范围。可以限制客户端发送到服务器的请求参数为某些特定值或不为某些值，如下代码所示</li>
<li>代码中我们用@RequestMapping 的params 属性指定了三个参数，这些参数都是针对请求参数而言的，它们分别表示参数param1 的值必须等于value1 ，参数param2 必须存在，值无所谓，参数param3 必须不存在，只有当请求/testParams.do 并且满足指定的三个参数条件的时候才能访问到该方法。所以当请求/testParams.do?param1=value1&amp;param2=value2 的时候能够正确访问到该testParams 方法，当请求/testParams.do?param1=value1&amp;param2=value2&amp;param3=value3 的时候就不能够正常的访问到该方法，因为在@RequestMapping 的params 参数里面指定了参数param3 是不能存在的</li>
</ul>
<pre><code class="highlight plaintext">@RequestMapping (value= &quot;testParams&quot; , params=&#123; &quot;param1=value1&quot; , &quot;param2&quot; , &quot;!param3&quot; &#125;)  
public String testParams() &#123;  
   System. out .println( &quot;test Params...........&quot; );  
   return &quot;testParams&quot; ;  
&#125;</code></pre>
<p><strong>headers属性指定请求中必须有特定header值</strong></p>
<ul>
<li>映射请求头部，收窄请求范围。约束客户端发送的请求头部信息中必须包含某个特定的值或不包含某个值，作用范围明显大于前面讲过的几种，示例代码如下：</li>
</ul>
<pre><code class="highlight plaintext">@RequestMapping (value= &quot;testHeaders&quot; , headers=&#123; &quot;host=localhost&quot; , &quot;Accept&quot; &#125;)  
public String testHeaders() &#123;  
	return &quot;headers&quot; ;  
&#125;</code></pre>
<blockquote>
<p>这里同样可以使用！号；可以使用通配符如：Content-Type=“application/*”</p>
</blockquote>
<p><strong>path属性指定路径</strong></p>
<ul>
<li>源码</li>
</ul>
<pre><code class="highlight plaintext">@AliasFor(&quot;path&quot;)
String[] value() default &#123;&#125;;
@AliasFor(&quot;value&quot;)
String[] path() default &#123;&#125;;</code></pre>
<ul>
<li>从Spring 4.2开始引入了@AliasFor注解，可以实现属性的别名，如value本身并没有特定的含义，而path会更加具体，能见名知义，通俗说可以认为<strong>两者使用过程中是一样的</strong>
<ul>
<li>@RequestMapping(“/foo”)} 与 @RequestMapping(path=“/foo”)相同</li>
</ul>
</li>
</ul>
<h4 id="requestmapping源码解析"><a class="markdownIt-Anchor" href="#requestmapping源码解析"></a> @RequestMapping源码解析</h4>
<pre><code class="highlight plaintext">package org.springframework.web.bind.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.util.concurrent.Callable;

import org.springframework.core.annotation.AliasFor;

/**
 * 用于映射url到控制器类或一个特定的处理程序方法.
 */
//该注解只能用于方法或类型上
@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Mapping
public @interface RequestMapping &#123;

    /**
     * 指定映射的名称
     */
    String name() default &quot;&quot;;

    /**
     * 指定请求的路径映射，指定的地址可以是uri模板,别名为path
     */
    @AliasFor(&quot;path&quot;)
    String[] value() default &#123;&#125;;

    /** 别名为value，使用path更加形象
     * 只有用在一个Servlet环境：路径映射URI（例如“/myPath.do”）。
     * Ant风格的路径模式，同时也支持（例如，“/myPath/*.do”）。在方法层面，在主要的映射在类型级别表示相对路径（例如，“edit.do”）
     * 的支持。路径映射的URI可能包含占位符（例如“/$ &#123;&#125;连接”）
     */
    @AliasFor(&quot;value&quot;)
    String[] path() default &#123;&#125;;

    /**
     * 指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE. 收窄请求范围 The
     * HTTP request methods to map to, narrowing the primary mapping: GET, POST,
     * HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE.
     */
    RequestMethod[] method() default &#123;&#125;;

    /**
     * 映射请求的参数，收窄请求范围 The parameters of the mapped request, narrowing the
     * primary mapping.
     */
    String[]params() default &#123;&#125;;

    /**
     * 映射请求头部，收窄请求范围 The headers of the mapped request, narrowing the primary
     * mapping. RequestMapping(value = &quot;/something&quot;, headers =
     * &quot;content-type=text/*&quot;)
     */
    String[] headers() default &#123;&#125;;

    /**
     * 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html，收窄请求范围 The
     * consumable media types of the mapped request, narrowing the primary
     * mapping.
     */
    String[] consumes() default &#123;&#125;;

    /**
     * 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回 The producible media types
     * of the mapped request, narrowing the primary mapping. produces =
     * &quot;text/plain&quot; produces = &#123;&quot;text/plain&quot;, &quot;application/*&quot;&#125; produces =
     * &quot;application/json; charset=UTF-8&quot;
     */
    String[] produces() default &#123;&#125;;
&#125;</code></pre>
<blockquote>
<p>从上面的源码可以发现除了name基本都是数组类型，在设置时我们可以指定单个值，如@RequestMapping(value=“/foo”)；也可以同时指定多个值如：@RequestMapping(value={“/foo”,“/bar”})</p>
</blockquote>
<h4 id="requestmapping快捷方式"><a class="markdownIt-Anchor" href="#requestmapping快捷方式"></a> @RequestMapping快捷方式</h4>
<ul>
<li>Spring 4.3 引入了方法级注解的变体，也被叫做 @RequestMapping 的组合注解。组合注解可以更好的表达被注解方法的语义。它们所扮演的角色就是针对 @RequestMapping 的封装，而且成了定义端点的标准方法。</li>
<li>例如，@GetMapping 是一个组合注解，它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。</li>
</ul>
<pre><code class="highlight plaintext">@GetMapping
@PostMapping
@PutMapping
@DeleteMapping
@PatchMappin

例如
@RequestMapping(value = &quot;/action3&quot;,method = RequestMethod.GET)
等价于
@GetMapping(&quot;/action3&quot;)</code></pre>
<h3 id="controller注解应用"><a class="markdownIt-Anchor" href="#controller注解应用"></a> @Controller注解应用</h3>
<ul>
<li>推荐使用@Controller注解声明Controller组件，这样可以使得Controller定义更加灵活，可以不用实现Controller接口，请求处理的方法也可以灵活定义</li>
</ul>
<pre><code class="highlight plaintext">@Controller
@RequestMapping(&quot;/day01&quot;)
public class HelloController&#123;
    @RequestMapping(&quot;/hello.form&quot;)
    public String execute() throws Exception&#123;
        return &quot;hello&quot;;
    &#125;
&#125;</code></pre>
<ul>
<li>为了使@Controller注解生效，需要在Spring的XML配置文件中开启组件扫描定义，并指定Controller组件所在的包</li>
</ul>
<pre><code class="highlight plaintext">&lt;context:component-scan base-package=&quot;com.tarena.controller&quot;/&gt;</code></pre>
<h3 id="请求参数值绑定"><a class="markdownIt-Anchor" href="#请求参数值绑定"></a> 请求参数值绑定</h3>
<h4 id="什么是请求参数绑定"><a class="markdownIt-Anchor" href="#什么是请求参数绑定"></a> 什么是请求参数绑定</h4>
<p><strong>请求参数格式</strong></p>
<ul>
<li>默认是<strong>key/value</strong>格式，比如：<a target="_blank" rel="noopener" href="http://XXXXX?id=1&amp;type=301">http://XXXXX?id=1&amp;type=301</a></li>
</ul>
<p><strong>请求参数值的数据类型</strong></p>
<ul>
<li>都是<strong>字符串</strong>类型的各种值</li>
</ul>
<p><strong>请求参数值要绑定的目标类型</strong></p>
<ul>
<li><strong>controller类中的方法参数</strong>，比如简单类型，pojo类型，集合类型等</li>
</ul>
<p><strong>springMVC内置的参数解析组件</strong></p>
<ul>
<li>默认内置了<strong>24种</strong>参数解析组件（ArgumentResolver）</li>
</ul>
<p><strong>什么是参数绑定？</strong></p>
<ul>
<li>就是将请求参数串中的<strong>value值获取到之后</strong>，再进行<strong>类型转换</strong>，然后将转换后的值<strong>赋值给controller类中方法的形参</strong>，这个过程就是参数绑定</li>
</ul>
<h4 id="默认支持的参数类型"><a class="markdownIt-Anchor" href="#默认支持的参数类型"></a> 默认支持的参数类型</h4>
<p>Controller方法<strong>形参</strong>中可以<strong>随时添加如下类型的参数</strong>，处理适配器会自动识别并进行赋值。</p>
<hr />
<p><strong>HttpServlet</strong></p>
<p>主要包括HttpServletRequest 、HttpServletResponse 和HttpSession 对象。 这些参数Spring 在调用处理器方法的时候会自动给它们赋值，所以当在处理器方法中需要使用到这些对象的时候，可以直接在方法上给定一个方法参数的申明，然后在方法体里面直接用就可以了。但是有一点需要注意的是在使用HttpSession 对象的时候，如果此时HttpSession 对象还没有建立起来的话就会有问题</p>
<ul>
<li><strong>HttpServletRequest</strong>：通过request对象获取请求信息</li>
</ul>
<pre><code class="highlight plaintext">@RequestMapping(&quot;/login-action1.form&quot;) 
public String checkLogin1(HttpServletRequest req)&#123; 
    String name = req.getParameter(&quot;name&quot;);
&#125;</code></pre>
<ul>
<li><strong>HttpServletResponse</strong>：通过response处理响应信息</li>
<li><strong>HttpSession</strong>：通过session对象得到session中存放的对象</li>
</ul>
<hr />
<p><strong>Spring 自己的WebRequest 对象</strong></p>
<p>使用该对象可以访问到存放在HttpServletRequest 和HttpSession 中的属性值。</p>
<hr />
<p><strong>使用@PathVariable 、@RequestParam 、@CookieValue 和@RequestHeader 标记的参数</strong></p>
<hr />
<p><strong>使用@ModelAttribute 标记的参数</strong></p>
<hr />
<p><strong>java.util.Map 、Spring 封装的Model 和ModelMap</strong></p>
<p>这些都可以用来封装模型数据，用来给视图做展示。</p>
<ul>
<li>ModelMap继承自LinkedHashMap，Model是一个接口，它们的底层实现都是同一个类（BindingAwareModelMap），作用就是向页面传递数据，相当于Request的作用，如下：</li>
</ul>
<pre><code class="highlight plaintext">//调用service查询商品信息
Item item = service.queryItemById(id);
model.addAttribute(&quot;item&quot;, item);</code></pre>
<hr />
<p><strong>InputStream、OutputStream</strong>，<strong>Reader、Writer</strong></p>
<p>InputStream 和Reader 是针对HttpServletRequest 而言的，可以从里面取数据；OutputStream 和Writer 是针对HttpServletResponse 而言的，可以往里面写数据。</p>
<hr />
<p><strong>实体类</strong></p>
<p>可以用来接收上传的参数</p>
<hr />
<p><strong>Spring 封装的MultipartFile</strong></p>
<p>用来接收上传文件的</p>
<hr />
<p><strong>Spring 封装的Errors 和BindingResult 对象</strong></p>
<p>这两个对象参数必须紧接在需要验证的实体对象参数之后，它里面包含了实体对象的验证结果</p>
<h4 id="直接绑定"><a class="markdownIt-Anchor" href="#直接绑定"></a> 直接绑定</h4>
<h5 id="绑定基本类型"><a class="markdownIt-Anchor" href="#绑定基本类型"></a> 绑定基本类型</h5>
<p><strong>使用要求</strong></p>
<p>http请求参数的<strong>key</strong>和controller方法的<strong>形参名称</strong>一致</p>
<p><strong>请求url</strong></p>
<p>请求参数的key为id</p>
<pre><code class="highlight plaintext">http://localhost:8080/xxx/findItem?id=1</code></pre>
<p><strong>controller方法</strong></p>
<p>controller的形参为inteeger id，他和请求参数的key一致，所以直接绑定成功</p>
<pre><code class="highlight plaintext">@RequestMapping(value = &quot;/findItem&quot;)
public String findItem(Integer id) &#123;
     System.out.println(&quot;接收到的请求参数是：&quot;+ id);
    return &quot;success&quot;;
&#125;</code></pre>
<h5 id="绑定pojo类型"><a class="markdownIt-Anchor" href="#绑定pojo类型"></a> 绑定pojo类型</h5>
<p><strong>使用要求</strong></p>
<p>控制器的方法的参数类型是pojo类型</p>
<p>要求表单中<strong>参数名称</strong>和pojo类的<strong>属性名称</strong>保持一致</p>
<p>使用自动机制封装成实体参数实例</p>
<ul>
<li>在Controller组件处理方法定义User类型参数</li>
<li>Spring会自动把请求参数封装new为User类型传入</li>
</ul>
<pre><code class="highlight plaintext">@RequestMapping(&quot;/login-action3.form&quot;)
public String checkLogin3(User user)&#123;
    System.out.println(user.getName());
    System.out.println(user.getPwd());
    User u = userService.login(user.getName(),user.getPwd());
    //...
    return &quot;success&quot;;
&#125;</code></pre>
<p><strong>请求url</strong></p>
<pre><code class="highlight plaintext">http://localhost:8080/xxx/updateItem?id=1&amp;name=iphone&amp;price=1000</code></pre>
<p><strong>controller方法</strong></p>
<ul>
<li>
<p>pojo定义</p>
</li>
<li>
<p>controller方法</p>
</li>
</ul>
<pre><code class="highlight plaintext">@RequestMapping(&quot;/updateItem&quot;)
public String updateItem(Integer id,Item item) &#123;
	
	 System.out.println(&quot;接收到的请求参数是：&quot;+ id);
	 System.out.println(&quot;接收到的请求参数是：&quot;+ item);
	return &quot;success&quot;;
&#125;</code></pre>
<h5 id="绑定包装pojo"><a class="markdownIt-Anchor" href="#绑定包装pojo"></a> 绑定包装pojo</h5>
<p><strong>包装pojo类</strong>，依然是一个pojo类，将POJO中包含另一个pojo的这种类，称之为包装pojo</p>
<p><strong>包装对象</strong></p>
<pre><code class="highlight plaintext">public class ItemQueryVO &#123;
	//商品信息
	private Item item;
&#125;</code></pre>
<p><strong>页面定义</strong></p>
<pre><code class="highlight plaintext">&lt;table width=&quot;100%&quot; border=1&gt;
	&lt;tr&gt;
		&lt;td&gt;商品名称：&lt;input type=&quot;text&quot; name=&quot;item.name&quot; /&gt;&lt;/td&gt;
		&lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;查询&quot; /&gt;&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;</code></pre>
<p><strong>controller方法</strong></p>
<h5 id="使用简单类型数组"><a class="markdownIt-Anchor" href="#使用简单类型数组"></a> 使用简单类型数组</h5>
<p><strong>使用要求</strong></p>
<p>通过HTTP请求<strong>批量传递简单类型数据</strong>的情况，Controller方法中可以用<strong>String</strong>[]或者<strong>pojo的String[]属性</strong>接收（两种方式任选其一），但是<strong>不能使用集合</strong>接收。</p>
<p><strong>请求url</strong></p>
<pre><code class="highlight plaintext">http://localhost:8080/xxx/deleteItem?id=1&amp;id=2&amp;id=3</code></pre>
<p><strong>controller方法</strong></p>
<p>数组类型一定要和url参数类型一致</p>
<pre><code class="highlight plaintext">@RequestMapping(&quot;/deleteItem&quot;)
public String deleteitem(Integer[] Id)&#123;
	
	return &quot;success&quot;;
&#125;</code></pre>
<h5 id="使用pojo类型集合或者数组"><a class="markdownIt-Anchor" href="#使用pojo类型集合或者数组"></a> 使用pojo类型集合或者数组</h5>
<p><strong>使用要求</strong></p>
<p>批量传递的请求参数，最终要使用List<POJO>来接收，那么这个List<POJO>必须放在<strong>另一个POJO类中</strong></p>
<p><strong>接受商品列表的pojo</strong></p>
<pre><code class="highlight plaintext">public class ItemQueryVO &#123;
	// 商品信息
	private Item item;
	// 其他信息
	// 商品信息集合
	private List&lt;Item&gt; itemList;
&#125;</code></pre>
<p><strong>请求URL</strong></p>
<pre><code class="highlight plaintext">http://localhost:8080/xxx/batchUpdateItem?itemList[0].id=1&amp; itemList[0].name=iphone&amp; itemList[0].price=1000&amp;itemList[1].id=2&amp; itemList[1].name=iphone x&amp; itemList[1].price=2000</code></pre>
<p><strong>controller</strong></p>
<pre><code class="highlight plaintext">@RequestMapping(&quot;/batchUpdateItem&quot;)
public String batchUpdateItem(ItemQueryVO vo) &#123;
	return &quot;success&quot;;
&#125;</code></pre>
<h5 id="自定义参数绑定"><a class="markdownIt-Anchor" href="#自定义参数绑定"></a> 自定义参数绑定</h5>
<p><strong>请求url</strong></p>
<pre><code class="highlight plaintext">http://localhost:8080/xxx/saveItem?date=2018-08-12</code></pre>
<p><strong>controller</strong></p>
<pre><code class="highlight plaintext">@RequestMapping(&quot;/saveItem&quot;)
public String saveItem(String date)&#123;
	System.out.println(&quot;接收到的请求参数是：&quot;+ date);
	return &quot;success&quot;;
&#125;</code></pre>
<blockquote>
<p>但是如果将data参数的类型由string改为date，则报错</p>
</blockquote>
<p><strong>自定义Converter</strong></p>
<pre><code class="highlight plaintext">public class DateConverter implements Converter&lt;String, Date&gt; &#123;

	@Override
	public Date convert(String source) &#123;
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
		try &#123;
			return simpleDateFormat.parse(source);
		&#125; catch (ParseException e) &#123;
			e.printStackTrace();
		&#125;
		return null;
	&#125;
&#125;</code></pre>
<p><strong>配置Converter</strong></p>
<p>在springmvc.xml文件中添加如下代码</p>
<pre><code class="highlight plaintext">&lt;!-- 加载注解驱动 --&gt;
&lt;!--处理器适配器会去调用conversionService--&gt;
&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt;
&lt;!-- 转换器配置（配置自定义转换器） --&gt;
&lt;bean id=&quot;conversionService&quot;
	class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;
	&lt;property name=&quot;converters&quot;&gt;
		&lt;set&gt;
			&lt;bean class=&quot;com.kkb.ssm.controller.converter.DateConverter&quot;/&gt;
		&lt;/set&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
<h4 id="注解绑定"><a class="markdownIt-Anchor" href="#注解绑定"></a> 注解绑定</h4>
<h5 id="requestparam"><a class="markdownIt-Anchor" href="#requestparam"></a> @RequestParam</h5>
<hr />
<p>@RequestParam注解只适用与Key/Value的http请求，即浏览器默认的表单类型（如果为json，xml等类型，不可以使用）</p>
<p>@RequestParam用来处理  <strong>Content-Type  为  application/x-www-form-urlencoded</strong>  编码的内容， Content-Type 默认为该属性</p>
<p>@RequestParam也可用于其它类型的请求，例如：POST、DELETE等请求。比如向表中插入单条数据</p>
<p>@RequestParam(value)相当于<code>Request.getParameter(请求参数key)</code></p>
<blockquote>
<p>@RequestParam不支持批量插入数据，如果改用  json  字符串来传值的话，类型设置为  application/json ，点击发送的话，会报错，后台接收不到值，为null</p>
</blockquote>
<blockquote>
<p>如果参数前写了@RequestParam(xxx)，那么前端必须有对应的xxx名字才行(不管其是否有值，当然可以通过设置该注解的required属性来调节是否必须传)，如果没有xxx名的话，那么请求会出错，报400</p>
</blockquote>
<blockquote>
<p>这里与feign消费服务时不同；feign消费服务时，如果参数前什么也不写，那么会被默认是@RequestBody的</p>
</blockquote>
<hr />
<p><strong>使用要求</strong></p>
<p>请求参数的key和controller方法的形参名称不一致时，需要使用@<strong>RequestParam注解</strong>才能将请求参数绑定成功</p>
<ul>
<li><strong>value</strong>：参数名字，即入参的请求参数名字，如value=“itemid”表示请求的参数中的名字为itemid的参数的值将传入；</li>
<li><strong>required</strong>：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报；<code>TTP Status 400 - Required Integer parameter 'XXXX' is not present</code></li>
<li><strong>defaultValue</strong>：默认值，表示如果请求中没有同名参数时的默认值</li>
</ul>
<p><strong>请求url</strong></p>
<p>请求参数的id为itemid=1</p>
<pre><code class="highlight plaintext">http://localhost:8080/xxx/findItem?itemid=1</code></pre>
<p><strong>controller方法</strong></p>
<p>Controller的形参为Integer id,它和请求的参数不一致，要使用@RequestParam注解才能绑定成功</p>
<pre><code class="highlight plaintext"> @RequestMapping(value = &quot;/findItem&quot;)
// 通过@RequestParam注解绑定简单类型
// 学习@RequestParam注解中的value、required、defaultValue属性
public String findItem (
		@RequestParam(value = &quot;itemid&quot;, required = true, defaultValue = &quot;2&quot;) Integer id) &#123;

	 System.out.println(&quot;接收到的请求参数是：&quot;+ id);
	  return &quot;success&quot;;
&#125;</code></pre>
<h5 id="pathvariable"><a class="markdownIt-Anchor" href="#pathvariable"></a> @PathVariable</h5>
<p>@PathVariable只适用于参数再URL路径的绑定情况</p>
<p>通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过@PathVariable(“xxx“) 绑定到操作方法的入参中</p>
<pre><code class="highlight plaintext">@RequestMapping(value = &quot;/hosts/pushInstallClient/&#123;id&#125;&quot;, method = RequestMethod.PUT, consumes = &quot;application/json&quot;)
//@PathVariable直接接收url中的参数值
public void pushInstallClient(@PathVariable(&quot;id&quot;) int id, HttpServletRequest request) &#123;    
    System.out.println(id);
&#125;</code></pre>
<h5 id="requestbody"><a class="markdownIt-Anchor" href="#requestbody"></a> @RequestBody</h5>
<p>注解用于将Controller的方法参数，根据HTTP Request Header的content-Type的内容,<strong>通过适当的HttpMessageConverter转换为JAVA类</strong></p>
<p>@RequestBody只适用与参数在请求体body中，并且请求体数据为json/xml类型的情况（注：框架将json对象转换为Java对象，<strong>故参数必须为引用类型对象</strong>）</p>
<p>注解@RequestBody接收的参数是来自requestBody中，即请求体。一般用于处理非  Content-Type: application/x-www-form-urlencoded 编码格式的数据，比如： application/json 、 application/xml 等类型的数据</p>
<p>就 application/json 类型的数据而言，使用注解@RequestBody可以将body里面所有的json数据传到后端，后端再进行解析</p>
<blockquote>
<p>@RequestBody与@RequestParam()可以同时使用，@RequestBody最多只能有一个，而@RequestParam()可以有多个</p>
</blockquote>
<blockquote>
<p>当，@RequestBody 与@RequestParam()可以同时使用时，原SpringMVC接收参数的机制不变，只不过RequestBody 接收的是请求体里面的数据；而RequestParam接收的是key-value里面的参数，所以它会被切面进行处理从而可以用普通元素、数组、集合、对象等接收</p>
</blockquote>
<hr />
<p>如果后端参数是一个对象，且该参数前是以@RequestBody修饰的，那么前端传递json参数时，必须满足以下要求：</p>
<ul>
<li>后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类(即：@RequestBody后面的类)时，会根据json字符串中的key来匹配对应实体类的属性，如果匹配一致且json中的该key对应的值符合(或可转换为)，实体类的对应属性的类型要求时,会调用实体类的setter方法将值赋给该属性</li>
<li>json字符串中，如果value为&quot;“的话，后端对应属性如果是String类型的，那么接受到的就是”&quot;，如果是后端属性的类型是Integer、Double等类型，那么接收到的就是null</li>
<li>json字符串中，如果value为null的话，后端对应收到的就是null</li>
<li>如果某个参数没有value的话，在传json字符串给后端时，要么干脆就不把该字段写到json字符串中；要么写value时， 必须有值，null  或&quot;“都行。千万不能有类似&quot;stature”:，这样的写法</li>
</ul>
<hr />
<p><strong>@RequestBody与前端传过来的json数据的匹配规则</strong></p>
<p><strong>声明</strong></p>
<ul>
<li>根据不同的Content-Type等情况,Spring-MVC会采取不同的HttpMessageConverter实现来进行信息转换解析。下面介绍的是最常模型接收数据的情况。</li>
</ul>
<p><strong>解析json数据大体流程概述：</strong></p>
<ul>
<li>Http传递请求体信息，最终会被封装进com.fasterxml.jackson.core.json.UTF8StreamJsonParser中(提示：Spring采用CharacterEncodingFilter设置了默认编码为UTF-8)，然后在public class BeanDeserializer extends BeanDeserializerBase implements java.io.Serializable中，通过 public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException方法进行解析。</li>
<li>假设前端传的json串是这样的： {“name1”:“邓沙利文”,“age”:123,“mot”:“我是一只小小小小鸟~”} 后端的模型只有name和age属性，以及对应的setter/getter方法；给出一般用到的deserializeFromObject(JsonParser p, DeserializationContext ctxt)方法的核心逻辑：</li>
</ul>
<p><strong>可以使用@JsonAlias指定模型中的属性对应什么key</strong></p>
<pre><code class="highlight plaintext">public class User&#123;
    @JsonAlias(value=&#123;&quot;Name&quot;,&quot;name123&quot;&#125;)
    private String name;
    private Integer age;
    private String gender;
    @JsonProperty(&quot;MOTTO&quot;)
    private String motto;
    
    ...getter and setter...
    
    public String toString()&#123;
        return age+&quot;岁&quot;+gender+&quot;人[&quot;+name+&quot;]的座右铭居然是：&quot;+motto+&quot;!!!&quot;
    &#125;
&#125;</code></pre>
<ul>
<li><strong>@JsonAlias注解</strong>，实现:json转模型时，使json中的特定key能转化为特定的模型属性;但是模型转json时，对应的转换后的key仍然与属性名一致，见：上图示例中的name字段的请求与响应。以下图进一步说明：</li>
</ul>
<blockquote>
<p>此时，json字符串转换为模型时，json中key为Name或为name123或为name的都能识别</p>
</blockquote>
<ul>
<li><strong>@JsonProperty注解</strong>，实现：json转模型时，使json中的特定key能转化为指定的模型属性；同样的，模型转json时，对应的转换后的key为指定的key，见：示例中的motto字段的请求与响应。以下图进一步说明：</li>
</ul>
<blockquote>
<p>此时，json字符串转换为模型时，key为MOTTO的能识别，但key为motto的不能识别</p>
</blockquote>
<blockquote>
<p>@JsonAlias注解需要依赖于setter、getter，而@JsonProperty注解不需要</p>
</blockquote>
<blockquote>
<p>在不考虑上述两个注解的一般情况下，key与属性匹配时,默认大小写敏感</p>
</blockquote>
<blockquote>
<p>有多个相同的key的json字符串中，转换为模型时，会以相同的几个key中，排在最后的那个key的值给模型属性复制，因为setter会覆盖原来的值。见示例中的gender属性</p>
</blockquote>
<blockquote>
<p>后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类(即:@RequestBody后面的类)时，会根据json字符串中的key来匹配对应实体类的属性，如果匹配一致且json中的该key对应的值符合(或可转换为)实体类的对应属性的类型要求时，会调用实体类的setter方法将值赋给该属性</p>
</blockquote>
<hr />
<p><strong>@RequestBody直接以String接收前端传过来的json数据：</strong></p>
<pre><code class="highlight plaintext">/**
*   直接以String接收前端传来的json数据
*/
@RequestMapping(value = &quot;/testRequestBody&quot;)
public Person testRequestBody(@RequestBody String jsonString) &#123;
    System.out.println(jsonString);
    return jsonString;
&#125;</code></pre>
<hr />
<p><strong>@RequestBody以简单对象接收前端传过来的json数据：</strong></p>
<pre><code class="highlight plaintext">/**
*   以比较简单的user对象接收前端传过来的json数据（SpringMVC会智能的将符合要求的数据装配进User对象中）
*/
@RequestMapping(value = &quot;/testRequestBody&quot;)
public Person testRequestBody(@RequestBody User user) &#123;
    System.out.println(user.toString());
    return user.toString();
&#125;</code></pre>
<pre><code class="highlight plaintext">public class User&#123;
    private String name;
    private Integer age;
    private String gender;
    private String motto;
    
    ...getter and setter...
    
    public String toString()&#123;
        return age+&quot;岁&quot;+gender+&quot;人[&quot;+name+&quot;]的座右铭居然是：&quot;+motto+&quot;!!!&quot;
    &#125;
&#125;</code></pre>
<hr />
<p><strong>@RequestBody以复杂对象接收前端传过来的json数据：</strong></p>
<pre><code class="highlight plaintext">/**
* 以较复杂的Team对象接收前端传过来的json数据（SpringMVC会智能的将符合要求的数据装配进该Team对象中）
* 注：如果后端@RequestBody后的对象，持有了集合等，当前端向传参令该对象持有的该集合为空时，json空字符串中，对象位置应该形如&quot;teamMembers&quot;:[]这么写，即：传递的json字符串中必须要有key，发否则请求出错
*/

@RequestMapping(value = &quot;/testRequestBody&quot;)
public Person testRequestBody(@RequestBody Team team) &#123;
    System.out.println(team.toString());
    return team.toString();
&#125;</code></pre>
<pre><code class="highlight plaintext">public class Team&#123;
    private Integer id;
    //小组名字
    private String teamName;
    //小组所获荣誉
    private List&lt;String&gt; honors;
    //小组成员
    private List&lt;User&gt; teamMembers;
    
    ...getter and setter ...
    
    public String toString()&#123;
        //遍历出小组所获荣耀
        StringBuffer sbHonors = new StringBuffer(&quot;荣耀start----\n&quot;);
        for(String honor:honors)&#123;
            sbHonors.append(honor);
            sbHonors.append(&quot;\n&quot;);
        &#125;
        sbHonors.append(&quot;荣耀end----\n&quot;);
        
        //遍历出小组成员
        StringBuffer sbMembers = new StringBuffer(&quot;成员start----\n&quot;);
        for(User user:sbMembers)&#123;
            sbHonors.append(user.toString());
            sbHonors.append(&quot;\n&quot;);
        &#125;
        sbHonors.append(&quot;成员end----\n&quot;);
        
        return &quot;小组id:&quot;+id+&quot;\n&quot;+&quot;小组名字：&quot;+teamName+&quot;\n&quot;+&quot;小组所获荣耀：&quot;+sbHonors+&quot;\n&quot;+&quot;小组成员：&quot;+sbMembers
    &#125;
    
&#125;</code></pre>
<hr />
<p><strong>@RequestBody与简单的@RequestParam()同时使用：</strong></p>
<pre><code class="highlight plaintext">//@RequestBody与复杂的@RequestParam()同时使用  注：这里以集合或者以数组接收数据都可以
@RequestMapping(value = &quot;/testRequestBody&quot;)
public String myTestController(@RequestBody User user,@RequestParam(&quot;token&quot;) String token)&#123;
    System.out.println(user.toString());
    System.our.println(tijeb);
    return token+&quot;&gt;&gt;&gt;&quot;+user.toString();
&#125;</code></pre>
<hr />
<p><strong>@RequestBody与复杂的@RequestParam()同时使用：</strong></p>
<pre><code class="highlight plaintext">//这里@RequestParam以集合或者数组接收都可以
@RequestMapping(&quot;&quot;)
public String myTestController(@RequestBody User user,@RequestParam(&quot;arrays&quot;) List&lt;String&gt; arrays)&#123;
	System.out.println(user.toString());
	StringBuffer sb = new StringBuffer();
	for(String array:arrays)&#123;
		sb.append(&quot;array&quot;);
		sb.append(&quot; &quot;);
		System.out.println(array);
	&#125;
	return sb.toString()+user.toString();
&#125;</code></pre>
<hr />
<p><strong>@RequestBody接收请求体中的json数据；不加注解接收URL中的数据并组装为对象：</strong></p>
<pre><code class="highlight plaintext">//这里@RequestParam以集合或者数组接收都可以
@RequestMapping(&quot;&quot;)
public String myTestController(@RequestBody User user1,User user2)&#123;
	System.out.println(user1.toString());
	System.out.println(user2.toString());
	return user2.toString()+&quot;\n&quot;+user1.toString();
&#125;</code></pre>
<blockquote>
<p>注：如果在后端方法参数前，指定了@RequestParam()的话，那么前端必须要有对应字段才行(当然可以通过设置该注解的required属性来调节是否必须传)，否者会报错400；如果参数前没有任何该注解，那么前端可以传，也可以不传</p>
</blockquote>
<h4 id="传参校验"><a class="markdownIt-Anchor" href="#传参校验"></a> 传参校验</h4>
<h5 id="使用valid"><a class="markdownIt-Anchor" href="#使用valid"></a> 使用@Valid</h5>
<p>使用该注解的主要目的时减轻表单验证的代码量，使逻辑看起来简单易用</p>
<ul>
<li>增加相关依赖：</li>
</ul>
<pre><code class="highlight plaintext">&lt;dependency&gt;    
    &lt;groupId&gt;javax.validation&lt;/groupId&gt;    
    &lt;artifactId&gt;validation-api&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<ul>
<li>在Controller层的方法的欲校验的参数上添加@Valid注解</li>
</ul>
<pre><code class="highlight plaintext">@PostMapping(&quot;/action/register&quot;)
public Result registerByForm(@Valid @RequestBody RegisterUser registerUser)&#123;
    return userService.register(registerUser);
&#125;</code></pre>
<ul>
<li>在实体类中增加校验标签</li>
</ul>
<p>空检查</p>
<p>@Null 验证对象是否为null</p>
<p>@NotNull 验证对象是否不为null, 无法查检长度为0的字符串</p>
<p>@NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.</p>
<p>@NotEmpty 检查约束元素是否为NULL或者是EMPTY.</p>
<p>Booelan检查</p>
<p>@AssertTrue 验证 Boolean 对象是否为 true</p>
<p>@AssertFalse 验证 Boolean 对象是否为 false</p>
<p>长度检查</p>
<ul>
<li>@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内</li>
<li>@Length(min=, max=) Validates that the annotated string is between min and max included.</li>
</ul>
<p>日期检查</p>
<ul>
<li>@Past 验证 Date 和 Calendar 对象是否在当前时间之前</li>
<li>@Future 验证 Date 和 Calendar 对象是否在当前时间之后</li>
<li>@Pattern 验证 String 对象是否符合正则表达式的规则</li>
</ul>
<p>数值检查</p>
<blockquote>
<p>建议使用在Stirng,Integer类型，不建议使用在int类型上，因为表单值为“”时无法转换为int，但可以转换为Stirng为&quot;&quot;,Integer为null</p>
</blockquote>
<ul>
<li>@Min 验证 Number 和 String 对象是否大等于指定的值</li>
<li>@Max 验证 Number 和 String 对象是否小等于指定的值</li>
<li>@DecimalMax 被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过BigDecimal定义的最大值的字符串表示.小数存在精度</li>
<li>@DecimalMin 被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过BigDecimal定义的最小值的字符串表示.小数存在精度</li>
<li>@Digits 验证 Number 和 String 的构成是否合法</li>
<li>@Digits(integer=,fraction=) 验证字符串是否是符合指定格式的数字，interger指定整数精度，fraction指定小数精度。</li>
<li>@Range(min=, max=) Checks whether the annotated value lies between (inclusive) the specified minimum and maximum. *</li>
<li>@Range(min=10000,max=50000,message=“range.bean.wage”) private BigDecimal wage;</li>
</ul>
<p>其他：</p>
<ul>
<li>@Valid 递归的对关联对象进行校验, 如果关联对象是个集合或者数组,那么对其中的元素进行递归校验,如果是一个map,则对其中的值部分进行校验.(是否进行递归验证)</li>
<li>@CreditCardNumber信用卡验证</li>
<li>@Email 验证是否是邮件地址，如果为null,不进行验证，算通过验证。</li>
<li>@ScriptAssert(lang= ,script=, alias=)</li>
<li>@URL(protocol=,host=, port=,regexp=, flags=)</li>
</ul>
<blockquote>
<p>要注意每个注解对应的数据类型</p>
</blockquote>
<pre><code class="highlight plaintext">@Data
@AllArgsConstructor
@NoArgsConstructor
public class RegisterUser &#123;

@Min(value = 1000000)
@NotNull(message = &quot;ID不能为空&quot;)
private Long userId;

@NotNull(message = &quot;用户名不能为空&quot;)
@Email(message = &quot;邮箱不正确&quot;)
private String username;

/**
* 教师职称
*/
@Pattern(regexp = &quot;^[^&lt;&gt;():=]*$&quot;)
private String position;

/**
* 教师所属教研室
*/
private String office;
&#125;</code></pre>
<ul>
<li>异常处理（两种方式）</li>
</ul>
<ol>
<li>直接在@Valid修饰的对象后增加Errors形参，该形参即可获取相关异常</li>
</ol>
<pre><code class="highlight plaintext">@PostMapping(&quot;/action/register&quot;)
public Result registerByForm(@Valid @RequestBody RegisterUser registerUser, Errors erros)&#123;
       if (errors.hasErrors()) &#123;
            throw new Exception(errors.getAllErrors().get(0).getDefaultMessage());
        &#125;
    return userService.register(registerUser);
&#125;</code></pre>
<ol>
<li>定义全局处理异常类</li>
</ol>
<pre><code class="highlight plaintext">@Slf4j
@ControllerAdvice
public class GlobalExceptionHandler &#123;

    private final static String EXCEPTION_MSG_KEY = &quot;Exception message : &quot;;

    @ResponseBody
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Result handleValidException(MethodArgumentNotValidException e)&#123;
                //日志记录错误信息
                log.error(Objects.requireNonNull(e.getBindingResult().getFieldError()).getDefaultMessage());
                //将错误信息返回给前台
                return Result.error(103, Objects.requireNonNull(e.getBindingResult().getFieldError()).getDefaultMessage());
    &#125;
&#125;

------------------------------------------------------------------------------------------
@Data@JsonInclude(JsonInclude.Include.NON_NULL)public class Result&lt;T&gt; &#123;
    private Integer code;
    private String message;
    private T data;

    public Result() &#123;
        this.code = 200;
        this.message = &quot;操作成功&quot;;
    &#125;

    /**
     * 用于错误处理
     * @param code 错误码 
     * @param message 错误提示信息
     */
    public Result(Integer code,String message)&#123;
        this.code = code;
        this.message = message;
    &#125;

    public static  Result&lt;String&gt; error(Integer code,String msg)&#123;
        return new Result&lt;&gt;(code,msg);
    &#125;&#125;</code></pre>
<p>或者：</p>
<pre><code class="highlight plaintext">@ControllerAdvice
@ResponseBody
public class AppliCationExceptionHandler &#123;
 
	@ExceptionHandler(value=Exception.class)
	public Result&lt;String&gt; exceptionHandler(HttpServletRequest request, Exception e)&#123;
		e.printStackTrace();
		if(e instanceof ApplicationException) &#123;
			ApplicationException ex = (ApplicationException)e;
			return Result.error(ex.getErrorCode()+&quot;:&quot;+ex.getMsg());
		&#125;else if(e instanceof BindException) &#123;
			BindException ex = (BindException)e;
			List&lt;ObjectError&gt; errors = ex.getAllErrors();
			ObjectError error = errors.get(0);
			String msg = error.getDefaultMessage();
			return Result.errorArgs(msg, errors);
		&#125;
		return Result.error(e.getMessage()) ;
	&#125;
&#125;</code></pre>
<h5 id="自定义校验标签"><a class="markdownIt-Anchor" href="#自定义校验标签"></a> 自定义校验标签</h5>
<ul>
<li>编写注解
<ul>
<li>@Constraint注解的值就是我们的自己已注解处理类</li>
</ul>
</li>
</ul>
<pre><code class="highlight plaintext">@Constraint(validatedBy = GeneralNameValidator.class)
@Target(&#123;ElementType.METHOD, ElementType.FIELD&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface GeneralNameCheck &#123;

    String message() default &quot;格式不合法&quot;;

    long min() default 1;

    long max() default 64;

    Class&lt;?&gt;[] groups() default &#123;&#125;;

    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;

&#125;</code></pre>
<ul>
<li>编写处理方法
<ul>
<li>方法必须要实现ConstraintValidator接口</li>
</ul>
</li>
</ul>
<pre><code class="highlight plaintext">public class GeneralNameValidator implements ConstraintValidator&lt;GeneralNameCheck, String&gt; &#123;
   private long max ;
   private long min ;
   private Pattern pattern ;
    
    //初始化
   public void initialize(GeneralNameCheck constraint) &#123;
      max = constraint.max();
      min = constraint.min();
      pattern = Pattern.compile(&quot;^\\w&#123;&quot;+min+&quot;,&quot;+max+&quot;&#125;$&quot;);
   &#125;
   //校验
   public boolean isValid(String value, ConstraintValidatorContext context) &#123;
      return pattern.matcher(value).matches();
   &#125;
&#125;</code></pre>
<ul>
<li>使用</li>
</ul>
<p>使用方式与上述方式一致，@Valid定义在Controller形参上，自定义标签写在对应的pojo类成员变量即可。</p>
<h4 id="自定义参数绑定-2"><a class="markdownIt-Anchor" href="#自定义参数绑定-2"></a> 自定义参数绑定</h4>
<p>如果在参数绑定spring无法满足，我们就可以自定义参数绑定。</p>
<p><strong>自定义注解</strong></p>
<pre><code class="highlight plaintext">import java.lang.annotation.*;

@Target(&#123;ElementType.PARAMETER&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface LoginUserInfo &#123;
&#125;</code></pre>
<p><strong>定义处理类</strong></p>
<pre><code class="highlight plaintext">@Component
public class UserInfoArgumentResolver implements HandlerMethodArgumentResolver &#123;

    @Autowired
    private UserService userService;
    /**
     * 判断是否对参数类型的支持
     * @param methodParameter
     * @return
     */
    @Override
    public boolean supportsParameter(MethodParameter methodParameter) &#123;
        return methodParameter.hasParameterAnnotation(LoginUserInfo.class);
    &#125;

    /**
     * 对参数的处理
     * @param methodParameter
     * @param modelAndViewContainer
     * @param nativeWebRequest
     * @param webDataBinderFactory
     * @return
     * @throws Exception
     */
    @Override
    public Integer resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,
                                NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception &#123;
        HttpServletRequest servletRequest = nativeWebRequest.getNativeRequest(HttpServletRequest.class);
        String userId = servletRequest.getParameter(&quot;userId&quot;);
        if ((userId==null||&quot;&quot;.equals(userId))||//页面未传用户信息
                (CommonConstants.CURRENT_USER_ID.equals(userId) &amp;&amp; CommonUtils.isAjaxReqeust(servletRequest)))&#123;//页面传currentuser用户信息
            int userId1 = SingleLogin.getUserId(servletRequest);
            if (userId1==-1)&#123;
                throw new LoginException(&quot;登录异常，请重新登录&quot;);
            &#125;
            return  userId1;
        &#125;

        //页面传的真实的用户id
        if (IntegerUtils.isNumeric(userId))&#123;
            return  Integer.valueOf(userId);
        &#125;
       throw new LoginException(&quot;登录异常，请重新登录&quot;);
    &#125;
&#125;</code></pre>
<p><strong>添加到Configuration</strong></p>
<pre><code class="highlight plaintext">@Configuration
public class AdmWebMvcConfiguration extends WebMvcConfigurerAdapter &#123;

 /*   @Override
    public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123;
        argumentResolvers.add(new UserInfoArgumentResolver());
    &#125;*/
    @Autowired
    public  void setRequestMappingHandlerAdapter(RequestMappingHandlerAdapter adapter, UserInfoArgumentResolver userInfoArgumentResolver)&#123;
        List&lt;HandlerMethodArgumentResolver&gt; resolvers = new ArrayList(adapter.getArgumentResolvers());
        resolvers.add(0,userInfoArgumentResolver);
        adapter.setArgumentResolvers(resolvers);
    &#125;
&#125;</code></pre>
<p><strong>页面使用</strong></p>
<pre><code class="highlight plaintext">@Override
@RequestMapping(value = &quot;/mysqlSrcs/&#123;id&#125;&quot;, method = RequestMethod.DELETE)
@ResponseStatus(HttpStatus.NO_CONTENT)
public MysqlSrc delete(@PathVariable int id, HttpServletRequest request,@LoginUserInfo Integer userId) &#123;
    return mysqlSrcOperationService.deleteMysqlSrc(id, request);
&#125;</code></pre>
<h3 id="向页面传值"><a class="markdownIt-Anchor" href="#向页面传值"></a> 向页面传值</h3>
<ul>
<li>当Controller组件处理后，需要向JSP传值，用下述步骤</li>
<li>直接使用HttpSerlvetRequest和Session</li>
<li>使用ModeAndView对象</li>
<li>使用ModeMap参数对象</li>
<li>使用@ModelAttribute注解</li>
<li></li>
</ul>
<h5 id="1使用requestsetattribute方法"><a class="markdownIt-Anchor" href="#1使用requestsetattribute方法"></a> 1.使用request.setAttribute方法</h5>
<ul>
<li>将数据绑定到request，然后转发某个jsp</li>
</ul>
<blockquote>
<p>注：springmvc<strong>默认使用转发</strong></p>
</blockquote>
<pre><code class="highlight plaintext">       @RequestMapping(&quot;/login4.do&quot;)
       //页面传值的第一钟方式：使用request
       public String login4(AdminParam ap,HttpServletRequest request) &#123;
             System.out.println(&quot;login4()&quot;);
             String adminCode = ap.getAdminCode();
             System.out.println(adminCode);
             //将数据绑定到request中,就是给request对象存储一个值，用来在jsp页面用getAttribute()方法获取
             request.setAttribute(&quot;adminCode&quot;,adminCode);
             //springmvc默认使用转发
             //框架后台默认调用转发方法 request.getRequestDispatcher(&quot;WEB-INF/findAll2.jsp&quot;).forward(req, res)
             return &quot;index&quot;;
       &#125;</code></pre>
<ul>
<li><strong>共用前端代码</strong></li>
</ul>
<pre><code class="highlight plaintext">login.jsp
&lt;%@page pageEncoding=&quot;utf-8&quot; contentType=&quot;text/html; charset=utf-8&quot;%&gt;
&lt;%@page isELIgnored=&quot;false&quot;%&gt;
&lt;html&gt;
       &lt;head&gt;&lt;u&gt;登陆&lt;/u&gt;&lt;/head&gt;
       &lt;body&gt;
             &lt;form action=&quot;login4.do&quot; method=&quot;post&quot;&gt;
                    账号：&lt;input name=&quot;adminCode&quot;/&gt;
                    密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;/&gt;
                    &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;/&gt;
            &lt;/form&gt;
       &lt;/body&gt;
&lt;/html&gt;

index.jsp
&lt;h1&gt;&lt;u&gt;succes&lt;/u&gt;...&lt;/h1&gt;
&lt;h1&gt;$&#123;adminCode&#125;&lt;/h1&gt;</code></pre>
<h5 id="2modeandview对象"><a class="markdownIt-Anchor" href="#2modeandview对象"></a> 2.ModeAndView对象</h5>
<ul>
<li>在Controller处理方法完成后返回一个ModelAndView对象，包含显示视图名和模型数据</li>
<li>DispatcherServlet对象在收到ModelAndView后分析其携带的参数，然后调用request.setAttribute()方法传入参数，然后调用request.getRequestDispatcher(“WEB-INF/findAll2.jsp”).forward(req, res)方法转发到JSP页面</li>
</ul>
<pre><code class="highlight plaintext">       @RequestMapping(&quot;/login5.do&quot;)
//向页面传值的第二中方式：使用ModelAndView
       public ModelAndView login5(AdminParam ap) &#123;
             System.out.println(&quot;login5()&quot;);
             String adminCode = ap.getAdminCode();
             System.out.println(adminCode);
             Map&lt;String,Object&gt; data = new HashMap&lt;String,Object&gt;();
             //相当于request.setAttribute(&quot;adminCode&quot;,adminCode)
             //虽然这里是吧参数放到了一个map里面，但是框架本身还是要吧参数放到request里面
             data.put(&quot;adminCode&quot;, adminCode);
             //构造ModeAndView对象
             ModelAndView mav = new ModelAndView(&quot;index&quot;,data);
             return mav;
       &#125;</code></pre>
<blockquote>
<p>Model数据会利用HttpServletRequest的Attribute传递到JSP页面中</p>
</blockquote>
<h5 id="3modelmap参数"><a class="markdownIt-Anchor" href="#3modelmap参数"></a> 3.ModelMap参数</h5>
<ul>
<li>将该对象作为方法的参数，然后将数据绑定到该对象</li>
</ul>
<pre><code class="highlight plaintext">       @RequestMapping(&quot;/login6.do&quot;)
//像页面传值的第三种方式：使用ModelMap
       public String login6(AdminParam ap,ModelMap mm) &#123;
             System.out.println(&quot;login6()&quot;);
             String adminCode = ap.getAdminCode();
             System.out.println(adminCode);
             //相当于request。setAttribute...
             mm.addAttribute(&quot;adminCode&quot;,adminCode);
             return &quot;index&quot;;
       &#125;</code></pre>
<blockquote>
<p>ModelMap数据会利用HttpServletRequest的Attribute传递到JSP页面中</p>
</blockquote>
<h5 id="4modelattribute"><a class="markdownIt-Anchor" href="#4modelattribute"></a> 4.@ModelAttribute</h5>
<ul>
<li>在Controller方法的参数部分或Bean属性方法上使用</li>
</ul>
<pre><code class="highlight plaintext"> @RequestMappint(&quot;/login-action6.form&quot;)
 public String checkLogin6(@ModelAttribute(&quot;user&quot;)User user)&#123;
     return &quot;success&quot;;
 &#125;
 
@ModelAttribute(&quot;name&quot;)
public String getName()&#123;
 return name;
&#125;</code></pre>
<blockquote>
<p>ModelMap数据会利用HttpServletRequest的Attribute传递到JSP页面中</p>
</blockquote>
<h5 id="5sessioin存储"><a class="markdownIt-Anchor" href="#5sessioin存储"></a> 5.Sessioin存储</h5>
<ul>
<li>可以利用HttpServletRequest的getSession()方法访问</li>
<li>request的生命周期是一次请求的响应时间内可以使用，session的生命周期多次请求都可以使用，存在时间是30分钟（优先使用生命周期短的）</li>
<li>前端控制器DispatcherServlet会使用反射机制分析这个方法的参数，如果有session则会把session对象传入进来</li>
</ul>
<pre><code class="highlight plaintext">       @RequestMapping(&quot;login7.do&quot;)
       //像页面传值的第四种方式：使用Session
       public String login7(AdminParam ap,HttpSession session) &#123;
             System.out.println(&quot;login7&quot;);
             String adminCode = ap.getAdminCode();
             System.out.println(adminCode);
             session.setAttribute(&quot;adminCode&quot;, adminCode);
             return &quot;index&quot;;
       &#125;</code></pre>
<ul>
<li>案例2：就是每次访问为session中的count+1.</li>
</ul>
<pre><code class="highlight plaintext">    @RequestMapping(&quot;/check&quot;)
    public ModelAndView check(HttpSession session) &#123;
        Integer i = (Integer) session.getAttribute(&quot;count&quot;);
        if (i == null)
            i = 0;
        i++;
        session.setAttribute(&quot;count&quot;, i);
        ModelAndView mav = new ModelAndView(&quot;check&quot;);
        return mav;
    &#125;
</code></pre>
<ul>
<li>check.jsp</li>
</ul>
<pre><code class="highlight plaintext">
&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot; isELIgnored=&quot;false&quot;%&gt;
session中记录的访问次数：$&#123;count&#125;</code></pre>
<h3 id="controller返回值"><a class="markdownIt-Anchor" href="#controller返回值"></a> Controller返回值</h3>
<ul>
<li>一个包含模型和视图的ModelAndView 对象。</li>
<li>一个模型对象，这主要包括Spring 封装好的Model 和ModelMap ，以及java.util.Map ，当没有视图返回的时候视图名称将由RequestToViewNameTranslator 来决定。</li>
<li>一个View 对象。这个时候如果在渲染视图的过程中模型的话就可以给处理器方法定义一个模型参数，然后在方法体里面往模型中添加值。</li>
<li>一个String 字符串。这往往代表的是一个视图名称。这个时候如果需要在渲染视图的过程中需要模型的话就可以给处理器方法一个模型参数，然后在方法体里面往模型中添加值就可以了。</li>
<li>返回值是void 。这种情况一般是我们直接把返回结果写到HttpServletResponse 中了，如果没有写的话，那么Spring 将会利用RequestToViewNameTranslator 来返回一个对应的视图名称。如果视图中需要模型的话，处理方法与返回字符串的情况相同。</li>
<li>如果处理器方法被注解@ResponseBody 标记的话，那么处理器方法的任何返回类型都会通过HttpMessageConverters 转换之后写到HttpServletResponse 中，而不会像上面的那些情况一样当做视图或者模型来处理。</li>
<li>除以上几种情况之外的其他任何返回类型都会被当做模型中的一个属性来处理，而返回的视图还是由RequestToViewNameTranslator 来决定，添加到模型中的属性名称可以在该方法上用@ModelAttribute(“attributeName”) 来定义，否则将使用返回类型的类名称的首字母小写形式来表示。使用@ModelAttribute 标记的方法会在@RequestMapping 标记的方法执行之前执行。</li>
</ul>
<h4 id="不用注解修饰"><a class="markdownIt-Anchor" href="#不用注解修饰"></a> 不用注解修饰</h4>
<h5 id="返回modelandview"><a class="markdownIt-Anchor" href="#返回modelandview"></a> <strong>返回ModelAndView</strong></h5>
<p>controller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定view</p>
<pre><code class="highlight plaintext">@Controller
public class ItemController &#123;

    @Autowired
    ItemService service;

    @RequestMapping(&quot;queryItem&quot;)
    public ModelAndView queryItem()&#123;
        List&lt;Item&gt; items = service.queryItemList();
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.addObject(&quot;itemList&quot;,items);
        //设置视图（逻辑路径）
        modelAndView.setViewName(&quot;item-list&quot;);
        return modelAndView;
    &#125;
&#125;</code></pre>
<h5 id="返回void"><a class="markdownIt-Anchor" href="#返回void"></a> <strong>返回void</strong></h5>
<ul>
<li>request/response</li>
</ul>
<p>在controller<strong>方法形参上可以定义request和response</strong>，使用request或response指定响应结果：</p>
<pre><code class="highlight plaintext">void service(HttpServletRequest request,HttpServletResponse response,Model model)&#123;
    //可以使用request绑定返回值
    request.setAttribute(&quot;itemList&quot;, itemList);
    //也可以使用model绑定返回值
    model.addAttribute(&quot;itemList&quot;, itemList);  
    
    //使用request转发向页面（ModelAndView底层用的其实也是转发）
    request.getRequestDispatcher(&quot;页面路径&quot;).forward(request, response);
    //也可以使用response页面重定向
    response.sendRedirect(&quot;url&quot;)

    //也可以通过response指定响应结果，例如响应json数据如下：
    response.setCharacterEncoding(&quot;utf-8&quot;);
    response.setContentType(&quot;application/json;charset=utf-8&quot;);
    response.getWriter().write(&quot;json串&quot;);
&#125;</code></pre>
<h5 id="返回字符串推荐"><a class="markdownIt-Anchor" href="#返回字符串推荐"></a> <strong>返回字符串（推荐）</strong></h5>
<h6 id="逻辑视图名"><a class="markdownIt-Anchor" href="#逻辑视图名"></a> 逻辑视图名</h6>
<pre><code class="highlight plaintext">return &quot;item/item-list&quot;;</code></pre>
<h6 id="redirect重定向"><a class="markdownIt-Anchor" href="#redirect重定向"></a> <strong>redirect重定向</strong></h6>
<ul>
<li>Spring MVC默认采用转发方式定位视图，如果需要重定向方式可采用下面几种方法
<ul>
<li>使用RedirectView<code>（如果返回值是ModelAndView）</code></li>
<li>使用redirect:前缀<code>（如果返回值是String）</code></li>
</ul>
</li>
</ul>
<p><strong>RedirectView</strong></p>
<ul>
<li>如果Controller的请求处理方法返回的是ModelAndView对象，可以使用RedirectView方法重定向</li>
</ul>
<pre><code class="highlight plaintext">       @RequestMapping(&quot;/login9.do&quot;)
       //重定向第二种方法：使用RedirectView
       public ModelAndView login9() &#123;
             System.out.println(&quot;login9&quot;);
             RedirectView rv = new RedirectView(&quot;toIndex.do&quot;);
             return new ModelAndView(rv);
       &#125;</code></pre>
<p><strong>redirect</strong></p>
<ul>
<li>重定向到其他网址</li>
<li>重定向到其他视图</li>
</ul>
<pre><code class="highlight plaintext">//testRedirect：url，可以是url网址，也可以是其他requestMapping
return &quot;redirect:testRedirect&quot;;

//直接重定向到http://www.baidu.com
return &quot;redirect:http://www.baidu.com&quot;;

//重定向到其他requestMapping,重定向到下面的controller中
return &quot;redirect:testRedirect&quot;;

@RequestMapping(&quot;testRedirect&quot;)
public String testRedirect(HttpServletRequest request) &#123;
&#125;</code></pre>
<blockquote>
<p>相当于<code>response.sendRedirect()</code>，<strong>浏览器URL发生改变，Request域不共享</strong></p>
</blockquote>
<h6 id="forward转发"><a class="markdownIt-Anchor" href="#forward转发"></a> <strong>forward转发</strong></h6>
<p>转发：从Controller转发到jsp然后再返回给浏览器</p>
<pre><code class="highlight plaintext">//testRedirect：url，可以是url网址，也可以是其他requestMapping
return &quot;forward:testForward&quot;;</code></pre>
<blockquote>
<p>相当于<code>request.getRequestDispatcher().forward(request,response)</code>，<strong>浏览器URL不发生改变，Request域可以共享</strong></p>
</blockquote>
<h4 id="使用注解修饰responsebody"><a class="markdownIt-Anchor" href="#使用注解修饰responsebody"></a> 使用注解修饰@ResponseBody</h4>
<p><strong>返回带@ResponseBody注解的值</strong></p>
<p>@<strong>ResponseBody</strong>的作用：</p>
<ul>
<li>将返回的<strong>pojo类型转换为json格式</strong>返回给浏览器（将响应体的Content-Type设置为application/json；charset=utf-8）<br />
将返回的<strong>字符串类型直接返回</strong>给浏览器（将响应体的Content-Type设置为text/plain；charset=utf-8）</li>
<li>ResponseBody注解可以通过内置的9种HttpMessageConverter，匹配<strong>不同的Controller返回值类型</strong>，然后进行不同的<strong>消息转换处理</strong></li>
<li>将转换之后的数据放到HttpServletResponse对象的<strong>响应体</strong>返回到页面，不同的HttpMessageConverter处理的数据，指定的<strong>ContentType值</strong>也不同</li>
</ul>
<pre><code class="highlight plaintext">@RequestMapping(&quot;jsonTest&quot;)
@ResponseBody
public Item jsonTest()&#123;
    Item item = service.queryItemById(1);
    System.out.println(item);
    return item;
&#125;</code></pre>
<p>@<strong>RequestBody</strong></p>
<ul>
<li>注解的作用和@ResponseBody注解正好相反，它是处理<strong>请求参数</strong>的Http消息转换的</li>
</ul>
<hr />
<p><strong>常用的HttpMessageConverter</strong></p>
<ul>
<li><code>MappingJacksonHttpMessageConverter</code>处理POJO类型返回值
<ul>
<li>默认使用MappingJackson的JSON处理能力，将后台返回的Java对象（POJO类型）</li>
<li>转为JSON格式输出到页面,将响应体的Content-Type设置为application/json；charset=utf-8</li>
</ul>
</li>
<li><code>StringHttpMessageConverter</code>处理String类型返回值
<ul>
<li>调用response.getWriter()方法将String类型的字符串写回给调用者。</li>
<li>将响应体的Content-Type设置为text/plain；charset=utf-8</li>
</ul>
</li>
</ul>
<h5 id="restcontroller"><a class="markdownIt-Anchor" href="#restcontroller"></a> @RestController</h5>
<p>@RestController相当于@<strong>Controller和@ResponseBody</strong>的组合</p>
<p>该类所有方法的返回值都将被@ResponseBody注解给修饰</p>
<pre><code class="highlight plaintext">@RestController
public class RestItemController &#123;

&#125;</code></pre>
<h3 id="controlleradvice"><a class="markdownIt-Anchor" href="#controlleradvice"></a> @ControllerAdvice</h3>
<p>ControllerAdvice标注的Class的作用是用来辅助Controller的，我们可以在ControllerAdvice标注的Class中使用@ExceptionHandler、@InitBinder和@ModelAttribute标记对应的方法，以便它们可以对指定范围内的Controller起作用</p>
<ul>
<li>@ExceptionHandler：用来进行异常处理的</li>
<li>@InitBinder：</li>
<li>@ModelAttribute：</li>
</ul>
<p>在没有ControllerAdvice时，我们定义的<code>@ExceptionHandler、@InitBinder和@ModelAttribute</code>都只能在Controller中<strong>对当前Controller生效</strong>，如果需要让更多的Controller应用相同的逻辑，只能把它们定义在共同的父类中。有了ControllerAdvice后则可以把它们定义在使用@ControllerAdvice标注的Class中</p>
<p><strong>ControllerAdvice定义的Class是有作用范围的</strong>，默认情况下，什么参数都不指定时它的作用范围是所有的范围。ControllerAdvice提供了一些可以缩小它的处理范围的参数。</p>
<ul>
<li>value：数组类型，用来指定可以作用的基包，即将对指定的包下面的Controller及其子包下面的Controller起作用。</li>
<li>basePackages：数组类型，等价于value。</li>
<li>basePackageClasses：数组类型，此时的基包将以指定的Class所在的包为准。</li>
<li>assignableTypes：数组类型，用来指定具体的Controller类型，它可以是一个共同的接口或父类等。</li>
<li>annotations：数组类型，用来指定Class上拥有指定的注解的Controller。</li>
</ul>
<ol>
<li>下面的ControllerAdvice将对定义在com.elim.app.mvc.controller包及其子包中的Controller起作用</li>
</ol>
<pre><code class="highlight plaintext">
@ControllerAdvice(value=&quot;com.elim.app.mvc.controller&quot;)
//@ControllerAdvice(basePackages=&quot;com.elim.app.mvc.controller&quot;)
public class DefaultExceptionHandler &#123;
    //...
&#125;</code></pre>
<ol>
<li>下面的ControllerAdvice也将对定义在com.elim.app.mvc.controller包及其子包中的Controller起作用。它通过basePackageClasses指定了需要作为基包的Class，此时基包将以basePackageClasses指定的Class所在的包为准，即com.elim.app.mvc.controller</li>
</ol>
<pre><code class="highlight plaintext">@ControllerAdvice(basePackageClasses=com.elim.app.mvc.controller.Package.class)
public class DefaultExceptionHandler &#123;
    //...
&#125;</code></pre>
<ol>
<li>下面的ControllerAdvice将对FooController及其子类型的Controller起作用。</li>
</ol>
<pre><code class="highlight plaintext">@ControllerAdvice(assignableTypes=FooController.class)
public class DefaultExceptionHandler &#123;
    //...
&#125;</code></pre>
<ol>
<li>下面的ControllerAdvice将对所有Class上使用了RestController注解标注的Controller起作用。</li>
</ol>
<pre><code class="highlight plaintext">@ControllerAdvice(annotations=RestController.class)
public class DefaultExceptionHandler &#123;
    //...
&#125;</code></pre>
<ol>
<li>也可以同时指定多个属性，比如下面的ControllerAdvice将对FooController及其子类型的Controller起作用，同时也将对com.elim.app.mvc.controller包及其子包下面的Controller起作用。</li>
</ol>
<pre><code class="highlight plaintext">@ControllerAdvice(assignableTypes=FooController.class, basePackages=&quot;com.elim.app.mvc.controller&quot;)
public class DefaultExceptionHandler &#123;
    //...
&#125;</code></pre>
<blockquote>
<p>当一个异常可以同时被多个ControllerAdvice的@ExceptionHandler标注的方法处理时只有第一个匹配的处理器方法可以处理。</p>
</blockquote>
<h4 id="exceptionhandler"><a class="markdownIt-Anchor" href="#exceptionhandler"></a> @ExceptionHandler</h4>
<p>springMVC提供的异常处理主要有两种方式，一种是直接实现自己的HandlerExceptionResolver，当然这也包括使用Spring已经为我们提供好的SimpleMappingExceptionResolver和DefaultHandlerExceptionResolver，另一种是使用注解的方式实现一个专门用于处理异常的Controller——ExceptionHandler</p>
<p>比如下面的示例中就在ControllerAdvice标注的Class中定义了两个使用ExceptionHandler标注的方法以处理对应的异常，其中handleException()方法将用来处理除java.lang.IllegalStateException以外的所有其它异常，它的处理结果是转到一个固定的视图上。而handleIllegalStateException()将用来处理java.lang.IllegalStateException，它的处理结果是以JSON的形式响应的。</p>
<ul>
<li>在@ExceptionHandler标注的处理方法中如果希望获取到当前抛出的异常，则可以在方法参数中声明一个需要处理的异常类型的参数，SpringMVC在调用对应的处理方法处理异常时将传递当前的异常对象。</li>
<li>@ExceptionHandler标注的处理方法可以声明任何正常的处理器方法可以声明的参数类型，比如HttpServletRequest、HttpServletResponse、java.util.Map、Model等。</li>
<li>@ExceptionHandler标注的处理方法的返回结果也可以跟正常的Controller处理方法拥有一样的返回类型，比如String、Model、ModelAndView、void、Object等，所以我们可以把它看作是和Controller处理方法等价的方法定义的这么一个方法。</li>
</ul>
<pre><code class="highlight plaintext">@ControllerAdvice
public class DefaultExceptionHandler &#123;

    /**     
    * 该方法将处理SpringMVC处理过程中抛出的所有的异常，     
    * 将使用该方法的返回值来替换正常的Controller方法的返回值     
    * @param e     
    * @return     
    */
    @ExceptionHandler(Exception.class)
    public ModelAndView handleException(Exception e) &#123;
        return new ModelAndView(&quot;viewName&quot;);
    &#125;
    
    /**     
    * 该方法将处理SpringMVC过程中抛出的所有的java.lang.IllegalStateException，     
    * 而其它异常的处理还由上面定义的handleException()处理。当抛出了一个异常可以同时被     
    * 多个@ExceptionHandler标注的方法处理时，对应的异常将交由更精确的异常处理方法处理。     
    *      
    * 且抛出该异常时将把处理结果以@ResponseBody的形式返回，此时将被当作JSON返回。     
    * @param e     
    * @return     
    */
    @ExceptionHandler(IllegalStateException.class)
    @ResponseBody
    public Object handleIllegalStateException(IllegalStateException e) &#123;
        Map&lt;String, Object&gt; jsonObj = new HashMap&lt;&gt;();
        jsonObj.put(&quot;errorMessage&quot;, e.getMessage());
        return jsonObj;
    &#125;
    
&#125;</code></pre>
<p><strong>使用@ExceptionHandler进行处理有一个不好的地方是进行异常处理的方法必须与出错的方法在同一个Controller里面</strong></p>
<pre><code class="highlight plaintext">import org.springframework.stereotype.Controller;  
import org.springframework.web.bind.annotation.ExceptionHandler;  
import org.springframework.web.bind.annotation.RequestMapping;  

import com.tiantian.blog.web.servlet.MyException;  

@Controller  
public class GlobalController &#123;  
	/** 
	 * 用于处理异常的 
	 * @return 
	 */  
	@ExceptionHandler(&#123;MyException.class&#125;)  
	public String exception(MyException e) &#123;  
	    System.out.println(e.getMessage());  
	    e.printStackTrace();  
	    return &quot;exception&quot;;  
	&#125;  
	  
	@RequestMapping(&quot;test&quot;)  
	public void test() &#123;  
	    throw new MyException(&quot;出错了！&quot;);  
	&#125;    
&#125;</code></pre>
<h4 id="initbinder"><a class="markdownIt-Anchor" href="#initbinder"></a> @InitBinder</h4>
<p>在通过处理器方法参数接收 request 请求参数绑定数据的时候，对于一些简单的数据类型 Spring 会帮我们自动进行类型转换，而对于一些复杂的类型由于 Spring 没法识别，所以也就不能帮助我们进行自动转换了，这个时候如果我们需要 Spring 来帮我们自动转换的话就需要我们给 Spring 注册一个对特定类型的识别转换器。 Spring 允许我们提供两种类型的识别转换器，一种是注册在 Controller 中的，一种是注册在 SpringMVC 的配置文件中。聪明的读者看到这里应该可以想到它们的区别了，定义在 Controller 中的是局部的，只在当前 Controller 中有效，而放在 SpringMVC 配置文件中的是全局的，所有 Controller 都可以拿来使用</p>
<p>自定义springMVC的属性编辑器主要有两种方式，</p>
<ul>
<li>一种是使用@InitBinder标签在运行期注册一个属性编辑器，这种编辑器只在当前Controller里面有效；</li>
<li>还有一种是实现自己的 WebBindingInitializer，然后定义一个 AnnotationMethodHandlerAdapter的bean，在此bean里面进行注册 ，这种属性编辑器是全局的</li>
</ul>
<p>我们可以使用 @InitBinder 注解标注在 Controller 方法上，然后在方法体里面注册数据绑定的转换器，这主要是通过 WebDataBinder 进行的。我们可以给需要注册数据绑定的转换器的方法一个 WebDataBinder 参数，然后给该方法加上 @InitBinder 注解，这样当该 Controller 中在处理请求方法时如果发现有不能解析的对象的时候，就会看该类中是否有使用 @InitBinder 标记的方法，如果有就会执行该方法，然后看里面定义的类型转换器是否与当前需要的类型匹配</p>
<p>使用示例一：</p>
<pre><code class="highlight plaintext">@Controller  
@RequestMapping ( &quot;/myTest&quot; )  
public class MyController &#123;  
  
    @InitBinder  
    public void dataBinder(WebDataBinder binder) &#123;  
       DateFormat dateFormat = new SimpleDateFormat( &quot;yyyyMMdd&quot; );  
       PropertyEditor propertyEditor = new CustomDateEditor(dateFormat, true ); // 第二个参数表示是否允许为空  
       binder.registerCustomEditor(Date. class , propertyEditor);  
    &#125;  
  
    @RequestMapping ( &quot;dataBinder/&#123;date&#125;&quot; )  
    public void testDate( @PathVariable Date date, Writer writer) throws IOException &#123;  
       writer.write(String.valueOf (date.getTime()));  
    &#125;  
&#125;</code></pre>
<p>在上面的代码中当我们请求 /myTest/dataBinder/20121212.do 的时候， Spring 就会利用 @InitBinder 标记的方法里面定义的类型转换器把字符串 20121212 转换为一个 Date 对象。这样定义的类型转换器是局部的类型转换器，一旦出了这个 Controller 就不会再起作用。类型转换器是通过 WebDataBinder 对象的 registerCustomEditor 方法来注册的，要实现自己的类型转换器就要实现自己的 PropertyEditor 对象。 Spring 已经给我们提供了一些常用的属性编辑器，如 CustomDateEditor 、 CustomBooleanEditor 等</p>
<p>PropertyEditor 是一个接口，要实现自己的 PropertyEditor 类我们可以实现这个接口，然后实现里面的方法。但是 PropertyEditor 里面定义的方法太多了，这样做比较麻烦。在 java 中有一个封装类是实现了 PropertyEditor 接口的，它是 PropertyEditorSupport 类。所以如果需要实现自己的 PropertyEditor 的时候只需要继承 PropertyEditorSupport 类，然后重写其中的一些方法。一般就是重写 setAsText 和 getAsText 方法就可以了， setAsText 方法是用于把字符串类型的值转换为对应的对象的，而 getAsText 方法是用于把对象当做字符串来返回的。在 setAsText 中我们一般先把字符串类型的对象转为特定的对象，然后利用 PropertyEditor 的 setValue 方法设定转换后的值。在 getAsText 方法中一般先使用 getValue 方法取代当前的对象，然后把它转换为字符串后再返回给 getAsText 方法。下面是一个示例：</p>
<pre><code class="highlight plaintext">@InitBinder  
public void dataBinder(WebDataBinder binder) &#123;  
// 定义一个 User 属性编辑器  
PropertyEditor userEditor = new PropertyEditorSupport() &#123;  

   @Override  
   public String getAsText() &#123;  
      // TODO Auto-generated method stub  
      User user = (User) getValue();  
      return user.getUsername();  
   &#125;  

   @Override  
   public void setAsText(String userStr) throws IllegalArgumentException &#123;  
      // TODO Auto-generated method stub  
      User user = new User(1, userStr);  
      setValue(user);  
   &#125;  
&#125;;  
// 使用 WebDataBinder 注册 User 类型的属性编辑器  
binder.registerCustomEditor(User. class , userEditor);  
&#125;</code></pre>
<p>使用示例二：</p>
<pre><code class="highlight plaintext">import java.beans.PropertyEditorSupport;  
import java.io.IOException;  
import java.text.SimpleDateFormat;  
import java.util.Date;  
import javax.servlet.http.HttpServletResponse;  
import org.springframework.beans.propertyeditors.CustomDateEditor;  
import org.springframework.stereotype.Controller;  
import org.springframework.web.bind.WebDataBinder;  
import org.springframework.web.bind.annotation.InitBinder;  
import org.springframework.web.bind.annotation.PathVariable;  
import org.springframework.web.bind.annotation.RequestMapping;  

@Controller  
public class GlobalController &#123;  
  
	@RequestMapping(&quot;test/&#123;date&#125;&quot;)  
	public void test(@PathVariable Date date, HttpServletResponse response) throws IOException  
	    response.getWriter().write( date);  

	&#125;  
	  
	@InitBinder//必须有一个参数WebDataBinder  
	public void initBinder(WebDataBinder binder) &#123;  
	    binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;), false));  

		binder.registerCustomEditor(int.class, new PropertyEditorSupport() &#123;  

		@Override  
		public String getAsText() &#123;  
		    // TODO Auto-generated method stub  
		    return getValue().toString();  
		&#125;  

		@Override  
		public void setAsText(String text) throws IllegalArgumentException &#123;  
		    // TODO Auto-generated method stub  
		    System.out.println(text + &quot;...........................................&quot;);  
		    setValue(Integer.parseInt(text));  
		&#125;  
		  
	    &#125;);  
	&#125;				
  
&#125;</code></pre>
<hr />
<p>第二种属性编辑器的方式：</p>
<p>如果需要定义全局的类型转换器就需要实现自己的 WebBindingInitializer 对象，然后把该对象注入到 AnnotationMethodHandlerAdapter 中，这样 Spring 在遇到自己不能解析的对象的时候就会到全局的 WebBindingInitializer 的 initBinder 方法中去找，每次遇到不认识的对象时， initBinder 方法都会被执行一遍</p>
<ol>
<li>定义自己的WebBindingInitializer</li>
</ol>
<pre><code class="highlight plaintext">public class MyWebBindingInitializer implements WebBindingInitializer &#123;  
  
    @Override  
    public void initBinder(WebDataBinder binder, WebRequest request) &#123;  
       // TODO Auto-generated method stub  
       DateFormat dateFormat = new SimpleDateFormat( &quot;yyyyMMdd&quot; );  
       PropertyEditor propertyEditor = new CustomDateEditor(dateFormat, true );  
       binder.registerCustomEditor(Date. class , propertyEditor);  
    &#125;  
&#125;</code></pre>
<blockquote>
<p>定义了这么一个 WebBindingInitializer 对象之后 Spring 还是不能识别其中指定的对象，这是因为我们只是定义了 WebBindingInitializer 对象，还没有把它交给 Spring ， Spring 不知道该去哪里找解析器。要让 Spring 能够识别还需要我们在 SpringMVC 的配置文件中定义一个 AnnotationMethodHandlerAdapter 类型的 bean 对象，然后利用自己定义的 WebBindingInitializer 覆盖它的默认属性 webBindingInitializer</p>
</blockquote>
<ol>
<li>在springMVC的配置文件里面定义一个AnnotationMethodHandlerAdapter，并设置其WebBindingInitializer属性为我们自己定义的WebBindingInitializer对象</li>
</ol>
<pre><code class="highlight plaintext">&lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;&gt;  
    &lt;property name=&quot;cacheSeconds&quot; value=&quot;0&quot;/&gt;  
    &lt;property name=&quot;webBindingInitializer&quot;&gt;  
	&lt;bean class=&quot;com.xxx.blog.util.MyWebBindingInitializer&quot;/&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;</code></pre>
<blockquote>
<p>注意：当使用了&lt;mvc:annotation-driven /&gt;的时候，它 会自动注册DefaultAnnotationHandlerMapping与AnnotationMethodHandlerAdapter 两个bean。这时候第二种方式指定的全局属性编辑器就不会起作用了，解决办法就是手动的添加上述bean，并把它们加在<code>&lt;mvc:annotation-driven/&gt;</code>的前面。如果不生效，则将手动注册AnnotationMethodHandlerAdapter改为手动注册RequestMappingHandlerAdapter</p>
</blockquote>
<hr />
<p>3.触发数据绑定方法的时间</p>
<p>当Controller处理器方法参数使用@RequestParam、@PathVariable、@RequestHeader、@CookieValue和@ModelAttribute标记的时候都会触发initBinder方法的执行，这包括使用WebBindingInitializer定义的全局方法和在Controller中使用@InitBinder标记的局部方法。而且每个使用了这几个注解标记的参数都会触发一次initBinder方法的执行，这也意味着有几个参数使用了上述注解就会触发几次initBinder方法的执行。</p>
<h5 id="防止xss注入"><a class="markdownIt-Anchor" href="#防止xss注入"></a> 防止XSS注入</h5>
<pre><code class="highlight plaintext">@InitBinder
protected void initBinder(WebDataBinder binder) &#123;
    // String类型转换，将所有传递进来的String进行HTML编码，防止XSS攻击
    binder.registerCustomEditor(String.class, new PropertyEditorSupport() &#123;
        @Override
        public void setAsText(String text) &#123;
            setValue(text == null ? null : StringEscapeUtils.escapeJavaScript(text.trim()));
        &#125;
        @Override
        public String getAsText() &#123;
            Object value = getValue();
            return value != null ? value.toString() : &quot;&quot;;
        &#125;
    &#125;);
&#125;</code></pre>
<h4 id="modelattribute"><a class="markdownIt-Anchor" href="#modelattribute"></a> @ModelAttribute</h4>
<p>使用 @ModelAttribute 和 @SessionAttributes 传递和保存数据</p>
<p>SpringMVC 支持使用 @ModelAttribute 和 @SessionAttributes 在不同的模型和控制器之间共享数据</p>
<p>@ModelAttribute 主要有两种使用方式，一种是标注在方法上，一种是标注在 Controller 方法参数上</p>
<p>当 @ModelAttribute 标记在方法上的时候，该方法将在处理器方法执行之前执行，然后把返回的对象存放在 session 或模型属性中，属性名称可以使用 @ModelAttribute(“attributeName”) 在标记方法的时候指定，若未指定，则使用返回类型的类名称（首字母小写）作为属性名称。关于 @ModelAttribute 标记在方法上时对应的属性是存放在 session 中还是存放在模型中，我们来做一个实验，看下面一段代码。</p>
<pre><code class="highlight plaintext">@Controller  
@RequestMapping ( &quot;/myTest&quot; )  
public class MyController &#123;  
  
    @ModelAttribute ( &quot;hello&quot; )  
    public String getModel() &#123;  
       System. out .println( &quot;-------------Hello---------&quot; );  
       return &quot;world&quot; ;  
    &#125;  
  
    @ModelAttribute ( &quot;intValue&quot; )  
    public int getInteger() &#123;  
       System. out .println( &quot;-------------intValue---------------&quot; );  
       return 10;  
    &#125;  
  
    @RequestMapping ( &quot;sayHello&quot; )  
    public void sayHello( @ModelAttribute ( &quot;hello&quot; ) String hello, @ModelAttribute ( &quot;intValue&quot; ) int num, @ModelAttribute ( &quot;user2&quot; ) User user, Writer writer, HttpSession session) throws IOException &#123;  
       writer.write( &quot;Hello &quot; + hello + &quot; , Hello &quot; + user.getUsername() + num);  
       writer.write( &quot;\r&quot; );  
       Enumeration enume = session.getAttributeNames();  
       while (enume.hasMoreElements())  
           writer.write(enume.nextElement() + &quot;\r&quot; );  
    &#125;  
  
    @ModelAttribute ( &quot;user2&quot; )  
    public User getUser() &#123;  
       System. out .println( &quot;---------getUser-------------&quot; );  
       return new User(3, &quot;user2&quot; );  
    &#125;  
&#125;</code></pre>
<p>当我们请求 /myTest/sayHello.do 的时候使用 @ModelAttribute 标记的方法会先执行，然后把它们返回的对象存放到模型中。最终访问到 sayHello 方法的时候，使用 @ModelAttribute 标记的方法参数都能被正确的注入值。</p>
<p>由执行结果我们可以看出来，此时 session 中没有包含任何属性，也就是说上面的那些对象都是存放在模型属性中，而不是存放在 session 属性中。那要如何才能存放在 session 属性中呢？这个时候我们先引入一个新的概念 @SessionAttributes ，它的用法会在讲完 @ModelAttribute 之后介绍，这里我们就先拿来用一下。我们在 MyController 类上加上 @SessionAttributes 属性标记哪些是需要存放到 session 中的。看下面的代码：</p>
<pre><code class="highlight plaintext">@Controller  
@RequestMapping ( &quot;/myTest&quot; )  
@SessionAttributes (value=&#123; &quot;intValue&quot; , &quot;stringValue&quot; &#125;, types=&#123;User. class &#125;)  
public class MyController &#123;  
  
    @ModelAttribute ( &quot;hello&quot; )  
    public String getModel() &#123;  
       System. out .println( &quot;-------------Hello---------&quot; );  
       return &quot;world&quot; ;  
    &#125;  
  
    @ModelAttribute ( &quot;intValue&quot; )  
    public int getInteger() &#123;  
       System. out .println( &quot;-------------intValue---------------&quot; );  
       return 10;  
    &#125;  
     
    @RequestMapping ( &quot;sayHello&quot; )  
    public void sayHello(Map&lt;String, Object&gt; map, @ModelAttribute ( &quot;hello&quot; ) String hello, @ModelAttribute ( &quot;intValue&quot; ) int num, @ModelAttribute ( &quot;user2&quot; ) User user, Writer writer, HttpServletRequest request) throws IOException &#123;  
       map.put( &quot;stringValue&quot; , &quot;String&quot; );  
       writer.write( &quot;Hello &quot; + hello + &quot; , Hello &quot; + user.getUsername() + num);  
       writer.write( &quot;\r&quot; );  
       HttpSession session = request.getSession();  
       Enumeration enume = session.getAttributeNames();  
       while (enume.hasMoreElements())  
           writer.write(enume.nextElement() + &quot;\r&quot; );  
       System. out .println(session);  
    &#125;  
  
    @ModelAttribute ( &quot;user2&quot; )  
    public User getUser() &#123;  
       System. out .println( &quot;---------getUser-------------&quot; );  
       return new User(3, &quot;user2&quot; );  
    &#125;  
&#125;</code></pre>
<p>在上面代码中我们指定了属性为 intValue 或 stringValue 或者类型为 User 的都会放到 Session 中，利用上面的代码当我们访问 /myTest/sayHello.do 的时候</p>
<p>仍然没有打印出任何 session 属性，这是怎么回事呢？怎么定义了把模型中属性名为 intValue 的对象和类型为 User 的对象存到 session 中，而实际上没有加进去呢？难道我们错啦？我们当然没有错，只是在第一次访问 /myTest/sayHello.do 的时候 @SessionAttributes 定义了需要存放到 session 中的属性，而且这个模型中也有对应的属性，但是这个时候还没有加到 session 中，所以 session 中不会有任何属性，等处理器方法执行完成后 Spring 才会把模型中对应的属性添加到 session 中。</p>
<p>当 @ModelAttribute 标记在处理器方法参数上的时候，表示该参数的值将从模型或者 Session 中取对应名称的属性值，该名称可以通过 @ModelAttribute(“attributeName”) 来指定，若未指定，则使用参数类型的类名称（首字母小写）作为属性名称。</p>
<pre><code class="highlight plaintext">@Controller  
@RequestMapping ( &quot;/myTest&quot; )  
public class MyController &#123;  
  
    @ModelAttribute ( &quot;hello&quot; )  
    public String getModel() &#123;  
       return &quot;world&quot; ;  
    &#125;  
  
    @RequestMapping ( &quot;sayHello&quot; )  
    public void sayHello( @ModelAttribute ( &quot;hello&quot; ) String hello, Writer writer) throws IOException &#123;  
       writer.write( &quot;Hello &quot; + hello);  
    &#125;     
&#125;</code></pre>
<p>在上面代码中，当我们请求/myTest/sayHello.do 的时候，由于MyController 中的方法getModel 使用了注解@ModelAttribute 进行标记，所以在执行请求方法sayHello 之前会先执行getModel 方法，这个时候getModel 方法返回一个字符串world 并把它以属性名hello 保存在模型中，接下来访问请求方法sayHello 的时候，该方法的hello 参数使用@ModelAttribute(“hello”) 进行标记，这意味着将从session 或者模型中取属性名称为hello 的属性值赋给hello 参数，所以这里hello 参数将被赋予值world ，所以请求完成后将会在页面上看到Hello world 字符串</p>
<p>@SessionAttributes 用于标记需要在Session 中使用到的数据，包括从Session 中取数据和存数据。@SessionAttributes 一般是标记在Controller 类上的，可以通过名称、类型或者名称加类型的形式来指定哪些属性是需要存放在session 中的。</p>
<pre><code class="highlight plaintext">@Controller  
@RequestMapping ( &quot;/myTest&quot; )  
@SessionAttributes (value=&#123; &quot;user1&quot; , &quot;blog1&quot; &#125;, types=&#123;User. class , Blog. class &#125;)  
public class MyController &#123;  
  
    @RequestMapping ( &quot;setSessionAttribute&quot; )  
    public void setSessionAttribute(Map&lt;String, Object&gt; map, Writer writer) throws IOException &#123;  
       User user = new User(1, &quot;user&quot; );  
       User user1 = new User(2, &quot;user1&quot; );  
       Blog blog = new Blog(1, &quot;blog&quot; );  
       Blog blog1 = new Blog(2, &quot;blog1&quot; );  
       map.put( &quot;user&quot; , user);  
       map.put( &quot;user1&quot; , user1);  
       map.put( &quot;blog&quot; , blog);  
       map.put( &quot;blog1&quot; , blog1);  
       writer.write( &quot;over.&quot; );  
    &#125;  

    @RequestMapping ( &quot;useSessionAttribute&quot; )  
    public void useSessionAttribute(Writer writer, @ModelAttribute ( &quot;user1&quot; ) User user1, @ModelAttribute ( &quot;blog1&quot; ) Blog blog1) throws IOException &#123;  
       writer.write(user1.getId() + &quot;--------&quot; + user1.getUsername());  
       writer.write( &quot;\r&quot; );  
       writer.write(blog1.getId() + &quot;--------&quot; + blog1.getTitle());  
    &#125;  
  
    @RequestMapping ( &quot;useSessionAttribute2&quot; )  
    public void useSessionAttribute(Writer writer, @ModelAttribute ( &quot;user1&quot; ) User user1, @ModelAttribute ( &quot;blog1&quot; ) Blog blog1, @ModelAttribute User user, HttpSession session) throws IOException &#123;  
       writer.write(user1.getId() + &quot;--------&quot; + user1.getUsername());  
       writer.write( &quot;\r&quot; );  
       writer.write(blog1.getId() + &quot;--------&quot; + blog1.getTitle());  
       writer.write( &quot;\r&quot; );  
       writer.write(user.getId() + &quot;---------&quot; + user.getUsername());  
       writer.write( &quot;\r&quot; );  
       Enumeration enume = session.getAttributeNames();  
       while (enume.hasMoreElements())  
           writer.write(enume.nextElement() + &quot; \r&quot; );  
    &#125;  
  
    @RequestMapping ( &quot;useSessionAttribute3&quot; )  
    public void useSessionAttribute( @ModelAttribute ( &quot;user2&quot; ) User user) &#123;  
  
    &#125;  
&#125;</code></pre>
<p>在上面代码中我们可以看到在MyController 上面使用了@SessionAttributes 标记了需要使用到的Session 属性。可以通过名称和类型指定需要存放到Session 中的属性，对应@SessionAttributes 注解的value 和types 属性。当使用的是types 属性的时候，那么使用的Session 属性名称将会是对应类型的名称（首字母小写）。当value 和types 两个属性都使用到了的时候，这时候取的是它们的并集，而不是交集，所以上面代码中指定要存放在Session 中的属性有名称为user1 或blog1 的对象，或类型为User 或Blog 的对象。在上面代码中我们首先访问/myTest/setSessionAttribute.do ，该请求将会请求到MyController 的setSessionAttribute 方法，在该方法中，我们往模型里面添加了user 、user1 、blog 和blog1 四个属性，因为它们或跟类上的@SessionAttributes 定义的需要存到session 中的属性名称相同或类型相同，所以在请求完成后这四个属性都将添加到session 属性中。接下来访问/myTest/useSessionAttribute.do ，该请求将会请求MyController 的useSessionAttribute(Writer writer, @ModelAttribute(“user1”) User user1, @ModelAttribute(“blog1”) Blog blog) 方法，该方法参数中用@ModelAttribute 指定了参数user1 和参数blog1 是需要从session 或模型中绑定的，恰好这个时候session 中已经有了这两个属性，所以这个时候在方法执行之前会先绑定这两个参数。</p>
<p>接下来访问/myTest/useSessionAttribute2.do ，这个时候请求的是上面代码中对应的第二个useSessionAttribute 方法，方法参数user 、user1 和blog1 用@ModelAttribute 声明了需要session 或模型属性注入，我们知道在请求/myTest/setSessionAttribute.do 的时候这些属性都已经添加到了session 中</p>
<p>接下来访问/myTest/useSessionAttribute3.do ，这个时候请求的是上面代码中对应的第三个useSessionAttribute 方法，我们可以看到该方法的方法参数user 使用了@ModelAttribute(“user2”) 进行标记，表示user 需要session 中的user2 属性来注入，但是这个时候我们知道session 中是不存在user2 属性的，所以这个时候就会报错了。</p>
<h3 id="bmi健康指数案例"><a class="markdownIt-Anchor" href="#bmi健康指数案例"></a> bmi健康指数案例</h3>
<ul>
<li>
<h2 id="目录结构"><a class="markdownIt-Anchor" href="#目录结构"></a> 目录结构</h2>
</li>
<li>pom.xml</li>
</ul>
<pre><code class="highlight plaintext">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; 
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 
http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;com.lee.bmi&lt;/groupId&gt;
  &lt;artifactId&gt;spring-bmi&lt;/artifactId&gt;
  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;war&lt;/packaging&gt;
      &lt;dependencies&gt;
              &lt;dependency&gt;
                      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
                      &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
              &lt;/dependency&gt;
              &lt;dependency&gt;
                     &lt;groupId&gt;junit&lt;/groupId&gt;
                     &lt;artifactId&gt;junit&lt;/artifactId&gt;
                     &lt;version&gt;4.10&lt;/version&gt;
              &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;</code></pre>
<ul>
<li>web.xml</li>
</ul>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; 
xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee 
http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; version=&quot;2.5&quot;&gt;
       &lt;servlet&gt;
             &lt;servlet-name&gt;&lt;u&gt;springmvc&lt;/u&gt;&lt;/servlet-name&gt;
             &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
             &lt;!-- DispatcherServlet在初始化方法里面，会读取该初始化参数的值来获取spring配置文件的位置，然后启动spring容器 --&gt;
             &lt;init-param&gt;
                    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
                    &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;
             &lt;/init-param&gt;
             &lt;!-- 表示启动&lt;u&gt;tomcat&lt;/u&gt;立即启动容器实例化参数 --&gt;
             &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
       &lt;/servlet&gt;
       &lt;servlet-mapping&gt;
             &lt;servlet-name&gt;&lt;u&gt;springmvc&lt;/u&gt;&lt;/servlet-name&gt;
             &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
       &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</code></pre>
<ul>
<li>springmvc.xml</li>
</ul>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; 
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; 
xmlns:task=&quot;http://www.springframework.org/schema/task&quot;
       xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx-3.1.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop-3.1.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context-3.1.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd
        http://www.springframework.org/schema/task
        http://www.springframework.org/schema/task/spring-task-3.1.xsd&quot;&gt;
      
       &lt;!-- 配置组件扫描 --&gt;
       &lt;context:component-scan base-package=&quot;bmi&quot;/&gt;
       &lt;!-- 配置mvc注解扫描 --&gt;
       &lt;mvc:annotation-driven/&gt;
       &lt;!-- 配置ViewResolver视图解析器 --&gt;
       &lt;bean 
class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
             &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot;&gt;&lt;/property&gt;
             &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;
       &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
<ul>
<li>前端页面bmi_form.jsp/result.jsp</li>
</ul>
<pre><code class="highlight plaintext">bmi_form.jsp
&lt;%@page pageEncoding=&quot;utf-8&quot; contentType=&quot;text/html; charset=utf-8&quot;%&gt;
&lt;html&gt;
       &lt;head&gt;bmi&lt;/head&gt;
       &lt;body&gt;
             &lt;form action=&quot;bmiContro.do&quot; method=&quot;post&quot;&gt;
                    体重：&lt;input name=&quot;height&quot;/&gt;
                    身高：&lt;input type=&quot;password&quot; name=&quot;weight&quot;/&gt;
                    &lt;input type=&quot;submit&quot; value=&quot;测量&quot;/&gt;
             &lt;/form&gt;
       &lt;/body&gt;
&lt;/html&gt;

result.sjp
&lt;%@page pageEncoding=&quot;utf-8&quot; contentType=&quot;text/html; charset=utf-8&quot;%&gt;
&lt;html&gt;
       &lt;head&gt;&lt;u&gt;bmi&lt;/u&gt;&lt;/head&gt;
       &lt;body&gt;
             &lt;h1&gt;$&#123;bmi&#125;&lt;/h1&gt;
       &lt;/body&gt;
&lt;/html&gt;</code></pre>
<ul>
<li>HeightAndWeight.java</li>
</ul>
<pre><code class="highlight plaintext">package bmi;
public class HeightAndWeigh &#123;
       private int height;
       private int weight;
       
       public int getHeight() &#123;
             return height;
       &#125;
       public void setHeight(int height) &#123;
             this.height = height;
       &#125;
       public int getWeight() &#123;
             return weight;
       &#125;
       public void setWeight(int weight) &#123;
             this.weight = weight;
       &#125;
&#125;</code></pre>
<ul>
<li>bmiController.java</li>
</ul>
<pre><code class="highlight plaintext">package bmi;

import org.springframework.stereotype.Controller;
import org.springframework.ui.ModelMap;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class BmiController &#123;

	@RequestMapping(&quot;/toBmi.do&quot;)
	public String toBmi() &#123;
		System.out.println(&quot;toBmi&quot;);
		return &quot;bmi_form&quot;;
	&#125;
	@RequestMapping(&quot;/bmiContro.do&quot;)
    //框架会自动吧from表单的参数封装成我们自定义的bean对象HeightAdnWeigh传入进来
	public String bmiContro(HeightAndWeigh haw,ModelMap mm) &#123;
		System.out.println(&quot;bmiContro&quot;);
		int bmi = haw.getWeight()/haw.getHeight()/haw.getHeight();
		if(bmi&gt;23) &#123;
			mm.addAttribute(&quot;bmi&quot;, &quot;过重&quot;);
		&#125;else if(bmi&lt;19) &#123;
			mm.addAttribute(&quot;bmi&quot;, &quot;过轻&quot;);
		&#125;else &#123;
			mm.addAttribute(&quot;bmi&quot;, &quot;正常&quot;);
		&#125;		
		return &quot;result&quot;;
	&#125;
&#125;</code></pre>
<h2 id="集成filter"><a class="markdownIt-Anchor" href="#集成filter"></a> 集成Filter</h2>
<p>有的童鞋在上一节的Web应用中可能发现了，如果注册时输入中文会导致乱码，因为Servlet默认按非UTF-8编码读取参数。为了修复这一问题，我们可以简单地使用一个EncodingFilter，在全局范围类给HttpServletRequest和HttpServletResponse强制设置为UTF-8编码。</p>
<p>可以自己编写一个EncodingFilter，也可以直接使用Spring MVC自带的一个CharacterEncodingFilter。配置Filter时，只需在web.xml中声明即可：</p>
<pre><code class="highlight plaintext">&lt;web-app&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
            &lt;param-value&gt;true&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;

    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    ...
&lt;/web-app&gt;</code></pre>
<p>因为这种Filter和我们业务关系不大，注意到CharacterEncodingFilter其实和Spring的IoC容器没有任何关系，两者均互不知晓对方的存在，因此，配置这种Filter十分简单。</p>
<p>我们再考虑这样一个问题：如果允许用户使用Basic模式进行用户验证，即在HTTP请求中添加头Authorization: Basic email:password，这个需求如何实现？</p>
<pre><code class="highlight plaintext">
@Componentpublic class AuthFilter implements Filter &#123;
    @Autowired
    UserService userService;

    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException &#123;
        HttpServletRequest req = (HttpServletRequest) request;
        // 获取Authorization头:
        String authHeader = req.getHeader(&quot;Authorization&quot;);
        if (authHeader != null &amp;&amp; authHeader.startsWith(&quot;Basic &quot;)) &#123;
            // 从Header中提取email和password:
            String email = prefixFrom(authHeader);
            String password = suffixFrom(authHeader);
            // 登录:
            User user = userService.signin(email, password);
            // 放入Session:
            req.getSession().setAttribute(UserController.KEY_USER, user);
        &#125;
        // 继续处理请求:
        chain.doFilter(request, response);
    &#125;
&#125;</code></pre>
<p>现在问题来了：在Spring中创建的这个AuthFilter是一个普通Bean，Servlet容器并不知道，所以它不会起作用。</p>
<p>如果我们直接在web.xml中声明这个AuthFilter，注意到AuthFilter的实例将由Servlet容器而不是Spring容器初始化，因此，@Autowire根本不生效，用于登录的UserService成员变量永远是null。</p>
<p>所以，得通过一种方式，让Servlet容器实例化的Filter，间接引用Spring容器实例化的AuthFilter。Spring MVC提供了一个DelegatingFilterProxy，专门来干这个事情：</p>
<pre><code class="highlight plaintext">&lt;web-app&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;authFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;
    &lt;/filter&gt;

    &lt;filter-mapping&gt;
        &lt;filter-name&gt;authFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    ...
&lt;/web-app&gt;</code></pre>
<p>我们来看实现原理：</p>
<ol>
<li>Servlet容器从web.xml中读取配置，实例化DelegatingFilterProxy，注意命名是authFilter；</li>
<li>Spring容器通过扫描@Component实例化AuthFilter。</li>
</ol>
<p>当DelegatingFilterProxy生效后，它会自动查找注册在ServletContext上的Spring容器，再试图从容器中查找名为authFilter的Bean，也就是我们用@Component声明的AuthFilter。</p>
<p>DelegatingFilterProxy将请求代理给AuthFilter，核心代码如下：</p>
<pre><code class="highlight plaintext">public class DelegatingFilterProxy implements Filter &#123;
    private Filter delegate;
    public void doFilter(...) throws ... &#123;
        if (delegate == null) &#123;
            delegate = findBeanFromSpringContainer();
        &#125;
        delegate.doFilter(req, resp, chain);
    &#125;
&#125;</code></pre>
<p>这就是一个代理模式的简单应用。我们画个图表示它们之间的引用关系如下：</p>
<p>如果在web.xml中配置的Filter名字和Spring容器的Bean的名字不一致，那么需要指定Bean的名字：</p>
<pre><code class="highlight plaintext">&lt;filter&gt;
    &lt;filter-name&gt;basicAuthFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;
    &lt;!-- 指定Bean的名字 --&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;targetBeanName&lt;/param-name&gt;
        &lt;param-value&gt;authFilter&lt;/param-value&gt;
    &lt;/init-param&gt;&lt;/filter&gt;</code></pre>
<h2 id="使用interceptor"><a class="markdownIt-Anchor" href="#使用interceptor"></a> 使用Interceptor</h2>
<p>在Web程序中，注意到使用Filter的时候，Filter由Servlet容器管理，它在Spring MVC的Web应用程序中作用范围如下：</p>
<p>上图虚线框就是Filter2的拦截范围，Filter组件实际上并不知道后续内部处理是通过Spring MVC提供的DispatcherServlet还是其他Servlet组件，因为Filter是Servlet规范定义的标准组件，它可以应用在任何基于Servlet的程序中。</p>
<p>如果只基于Spring MVC开发应用程序，还可以使用Spring MVC提供的一种功能类似Filter的拦截器：Interceptor。和Filter相比，Interceptor拦截范围不是后续整个处理流程，而是仅针对Controller拦截：</p>
<p>上图虚线框就是Interceptor的拦截范围，注意到Controller的处理方法一般都类似这样：</p>
<pre><code class="highlight plaintext">@Controller
public class Controller1 &#123;
    @GetMapping(&quot;/path/to/hello&quot;)
    ModelAndView hello() &#123;
        ...
    &#125;
&#125;</code></pre>
<p>所以，Interceptor的拦截范围其实就是Controller方法，它实际上就相当于基于AOP的方法拦截。因为Interceptor只拦截Controller方法，所以要注意，返回ModelAndView并渲染后，后续处理就脱离了Interceptor的拦截范围。</p>
<p>使用Interceptor的好处是Interceptor本身是Spring管理的Bean，因此注入任意Bean都非常简单。此外，可以应用多个Interceptor，并通过简单的@Order指定顺序。我们先写一个LoggerInterceptor：</p>
<pre><code class="highlight plaintext">
@Order(1)
@Componentpublic class LoggerInterceptor implements HandlerInterceptor &#123;

    final Logger logger = LoggerFactory.getLogger(getClass());

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        logger.info(&quot;preHandle &#123;&#125;...&quot;, request.getRequestURI());
        if (request.getParameter(&quot;debug&quot;) != null) &#123;
            PrintWriter pw = response.getWriter();
            pw.write(&quot;&lt;p&gt;DEBUG MODE&lt;/p&gt;&quot;);
            pw.flush();
            return false;
        &#125;
        return true;
    &#125;

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        logger.info(&quot;postHandle &#123;&#125;.&quot;, request.getRequestURI());
        if (modelAndView != null) &#123;
            modelAndView.addObject(&quot;__time__&quot;, LocalDateTime.now());
        &#125;
    &#125;

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        logger.info(&quot;afterCompletion &#123;&#125;: exception = &#123;&#125;&quot;, request.getRequestURI(), ex);
    &#125;
&#125;</code></pre>
<p>一个Interceptor<strong>必须实现HandlerInterceptor接口</strong>，可以<strong>选择实现preHandle()、postHandle()和afterCompletion()方法</strong>。preHandle()是Controller方法调用<strong>前执行</strong>，postHandle()是Controller方法正常返回<strong>后执行</strong>，而afterCompletion()无论Controller方法是否抛异常都会执行，参数ex就是Controller方法抛出的异常（未抛出异常是null）。</p>
<p>在preHandle()中，也可以直接处理响应，然后返回false表示无需调用Controller方法继续处理了，通常在认证或者安全检查失败时直接返回错误响应。在postHandle()中，因为捕获了Controller方法返回的ModelAndView，所以可以继续往ModelAndView里添加一些通用数据，很多页面需要的全局数据如Copyright信息等都可以放到这里，无需在每个Controller方法中重复添加。</p>
<p>我们再继续添加一个AuthInterceptor，用于替代上一节使用AuthFilter进行Basic认证的功能：</p>
<pre><code class="highlight plaintext">
@Order(2)
@Componentpublic class AuthInterceptor implements HandlerInterceptor &#123;

    final Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    UserService userService;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
            throws Exception &#123;
        logger.info(&quot;pre authenticate &#123;&#125;...&quot;, request.getRequestURI());
        try &#123;
            authenticateByHeader(request);
        &#125; catch (RuntimeException e) &#123;
            logger.warn(&quot;login by authorization header failed.&quot;, e);
        &#125;
        return true;
    &#125;

    private void authenticateByHeader(HttpServletRequest req) &#123;
        String authHeader = req.getHeader(&quot;Authorization&quot;);
        if (authHeader != null &amp;&amp; authHeader.startsWith(&quot;Basic &quot;)) &#123;
            logger.info(&quot;try authenticate by authorization header...&quot;);
            String up = new String(Base64.getDecoder().decode(authHeader.substring(6)), StandardCharsets.UTF_8);
            int pos = up.indexOf(&#x27;:&#x27;);
            if (pos &gt; 0) &#123;
                String email = URLDecoder.decode(up.substring(0, pos), StandardCharsets.UTF_8);
                String password = URLDecoder.decode(up.substring(pos + 1), StandardCharsets.UTF_8);
                User user = userService.signin(email, password);
                req.getSession().setAttribute(UserController.KEY_USER, user);
                logger.info(&quot;user &#123;&#125; login by authorization header ok.&quot;, email);
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>这个AuthInterceptor是由Spring容器直接管理的，因此注入UserService非常方便。</p>
<p>最后，要让拦截器生效，我们在WebMvcConfigurer中注册所有的Interceptor：</p>
<pre><code class="highlight plaintext">@Bean
WebMvcConfigurer createWebMvcConfigurer(@Autowired HandlerInterceptor[] interceptors) &#123;
    return new WebMvcConfigurer() &#123;
        public void addInterceptors(InterceptorRegistry registry) &#123;
            for (var interceptor : interceptors) &#123;
                registry.addInterceptor(interceptor);
            &#125;
        &#125;
        ...
    &#125;;
&#125;</code></pre>
<h3 id="处理异常"><a class="markdownIt-Anchor" href="#处理异常"></a> 处理异常</h3>
<p>在Controller中，Spring MVC还允许定义基于@ExceptionHandler注解的异常处理方法。我们来看具体的示例代码：</p>
<pre><code class="highlight plaintext">
@Controllerpublic class UserController &#123;
    @ExceptionHandler(RuntimeException.class)
    public ModelAndView handleUnknowException(Exception ex) &#123;
        return new ModelAndView(&quot;500.html&quot;, Map.of(&quot;error&quot;, ex.getClass().getSimpleName(), &quot;message&quot;, ex.getMessage()));
    &#125;
    ...
&#125;</code></pre>
<p>异常处理方法没有固定的方法签名，可以传入Exception、HttpServletRequest等，返回值可以是void，也可以是ModelAndView，上述代码通过@ExceptionHandler(RuntimeException.class)表示当发生RuntimeException的时候，就自动调用此方法处理。</p>
<p>注意到我们返回了一个新的ModelAndView，这样在应用程序内部如果发生了预料之外的异常，可以给用户显示一个出错页面，而不是简单的500 Internal Server Error或404 Not Found。例如B站的错误页：</p>
<p>可以编写多个错误处理方法，每个方法针对特定的异常。例如，处理LoginException使得页面可以自动跳转到登录页。</p>
<p>使用ExceptionHandler时，要注意它仅作用于当前的Controller，即ControllerA中定义的一个ExceptionHandler方法对ControllerB不起作用。如果我们有很多Controller，每个Controller都需要处理一些通用的异常，例如LoginException，思考一下应该怎么避免重复代码？</p>
<h2 id="处理cors"><a class="markdownIt-Anchor" href="#处理cors"></a> 处理CORS</h2>
<p>在JavaScript与REST交互的时候，有很多安全限制。默认情况下，浏览器按同源策略放行JavaScript调用API，即：</p>
<ul>
<li>如果A站在域名a.com页面的JavaScript调用A站自己的API时，没有问题；</li>
<li>如果A站在域名a.com页面的JavaScript调用B站b.com的API时，将被浏览器拒绝访问，因为不满足同源策略。</li>
</ul>
<p>同源要求域名要完全相同（a.com和www.a.com不同），协议要相同（http和https不同），端口要相同 。</p>
<p>那么，在域名a.com页面的JavaScript要调用B站b.com的API时，还有没有办法？</p>
<p>办法是有的，那就是CORS，全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。如果A站的JavaScript访问B站API的时候，B站能够返回响应头<strong>Access-Control-Allow-Origin: <a target="_blank" rel="noopener" href="http://a.com">http://a.com</a></strong>，那么，浏览器就允许A站的JavaScript访问B站的API。</p>
<p>注意到跨域访问能否成功，取决于B站是否愿意给A站返回一个正确的Access-Control-Allow-Origin响应头，所以决定权永远在提供API的服务方手中。</p>
<p>使用Spring的@RestController开发REST应用时，同样会面对跨域问题。如果我们允许指定的网站通过页面JavaScript访问这些REST API，就必须正确地设置CORS。</p>
<h3 id="使用crossorigin"><a class="markdownIt-Anchor" href="#使用crossorigin"></a> 使用@CrossOrigin</h3>
<p>第一种方法是使用@CrossOrigin注解，可以在@RestController的class级别或方法级别定义一个@CrossOrigin，例如</p>
<pre><code class="highlight plaintext">@CrossOrigin(origins = &quot;http://local.liaoxuefeng.com:8080&quot;)
@RestController@RequestMapping(&quot;/api&quot;)
public class ApiController &#123;
    ...
&#125;</code></pre>
<p>上述定义在ApiController处的@CrossOrigin指定了只允许来自local.liaoxuefeng.com跨域访问，允许多个域访问需要写成数组形式，例如origins = {“<a target="_blank" rel="noopener" href="http://a.com">http://a.com</a>”, “<a target="_blank" rel="noopener" href="https://www.b.com">https://www.b.com</a>”})。如果要允许任何域访问，写成<code>origins = &quot;*&quot;</code>即可。</p>
<p>如果有多个REST Controller都需要使用CORS，那么，每个Controller都必须标注@CrossOrigin注解。</p>
<h3 id="使用corsregistry"><a class="markdownIt-Anchor" href="#使用corsregistry"></a> 使用CorsRegistry</h3>
<p>第二种方法是在WebMvcConfigurer中定义一个全局CORS配置，下面是一个示例：</p>
<pre><code class="highlight plaintext">@Bean
WebMvcConfigurer createWebMvcConfigurer() &#123;
    return new WebMvcConfigurer() &#123;
        @Override
        public void addCorsMappings(CorsRegistry registry) &#123;
            registry.addMapping(&quot;/api/**&quot;)
                    .allowedOrigins(&quot;http://local.liaoxuefeng.com:8080&quot;)
                    .allowedMethods(&quot;GET&quot;, &quot;POST&quot;)
                    .maxAge(3600);
            // 可以继续添加其他URL规则:
            // registry.addMapping(&quot;/rest/v2/**&quot;)...
        &#125;
    &#125;;
&#125;</code></pre>
<p>这种方式可以创建一个全局CORS配置，如果仔细地设计URL结构，那么可以一目了然地看到各个URL的CORS规则，推荐使用这种方式配置CORS。</p>
<h3 id="使用corsfilter"><a class="markdownIt-Anchor" href="#使用corsfilter"></a> 使用CorsFilter</h3>
<p>第三种方法是使用Spring提供的CorsFilter，我们在集成Filter中详细介绍了将Spring容器内置的Bean暴露为Servlet容器的Filter的方法，由于这种配置方式需要修改web.xml，也比较繁琐，所以推荐使用第二种方式。</p>
<h2 id="异步处理"><a class="markdownIt-Anchor" href="#异步处理"></a> 异步处理</h2>
<p>在Servlet模型中，<strong>每个请求都是由某个线程处理</strong>，然后，将响应写入IO流，发送给客户端。从开始处理请求，到写入响应完成，都是在同一个线程中处理的。</p>
<p>实现Servlet容器的时候，只要每处理一个请求，就创建一个新线程处理它，就能保证正确实现了Servlet线程模型。在实际产品中，例如Tomcat，总是通过线程池来处理请求，它仍然符合一个请求从头到尾都由某一个线程处理。</p>
<p>这种线程模型非常重要，因为<strong>Spring的JDBC事务是基于ThreadLocal实现的</strong>，如果在处理过程中，一会由线程A处理，一会又由线程B处理，那事务就全乱套了。此外，很多安全认证，也是基于ThreadLocal实现的，可以保证在处理请求的过程中，各个线程互不影响。</p>
<p>但是，如果一个请求处理的时间较长，例如几秒钟甚至更长，那么，这种基于线程池的同步模型很快就会把所有线程耗尽，导致服务器无法响应新的请求。如果把长时间处理的请求改为异步处理，那么线程池的利用率就会大大提高。Servlet从3.0规范开始添加了异步支持，允许对一个请求进行异步处理。</p>
<p>我们先来看看在Spring MVC中如何实现对请求进行异步处理的逻辑。首先建立一个Web工程，然后编辑web.xml文件如下：</p>
<pre><code class="highlight plaintext">
&lt;web-app&gt;
    &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextClass&lt;/param-name&gt;
            &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;com.itranswarp.learnjava.AppConfig&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;
        &lt;async-supported&gt;true&lt;/async-supported&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre>
<p>和前面普通的MVC程序相比，这个web.xml主要对DispatcherServlet的配置多了一个&lt;<strong>async-supported</strong>&gt;，默认值是false，必须明确写成true，这样Servlet容器才会支持async处理。</p>
<p>下一步就是在Controller中编写async处理逻辑。我们以ApiController为例，演示如何异步处理请求。</p>
<p>第一种async处理方式是返回一个Callable，Spring MVC自动把返回的Callable放入线程池执行，等待结果返回后再写入响应：</p>
<pre><code class="highlight plaintext">@GetMapping(&quot;/users&quot;)
public Callable&lt;List&lt;User&gt;&gt; users() &#123;
    return () -&gt; &#123;
        // 模拟3秒耗时:
        try &#123;
            Thread.sleep(3000);
        &#125; catch (InterruptedException e) &#123;
        &#125;
        return userService.getUsers();
    &#125;;
&#125;</code></pre>
<p>第二种async处理方式是返回一个DeferredResult对象，然后在另一个线程中，设置此对象的值并写入响应：</p>
<pre><code class="highlight plaintext">@GetMapping(&quot;/users/&#123;id&#125;&quot;)
public DeferredResult&lt;User&gt; user(@PathVariable(&quot;id&quot;) long id) &#123;
    DeferredResult&lt;User&gt; result = new DeferredResult&lt;&gt;(3000L); // 3秒超时
    new Thread(() -&gt; &#123;
        // 等待1秒:
        try &#123;
            Thread.sleep(1000);
        &#125; catch (InterruptedException e) &#123;
        &#125;
        try &#123;
            User user = userService.getUserById(id);
            // 设置正常结果并由Spring MVC写入Response:
            result.setResult(user);
        &#125; catch (Exception e) &#123;
            // 设置错误结果并由Spring MVC写入Response:
            result.setErrorResult(Map.of(&quot;error&quot;, e.getClass().getSimpleName(), &quot;message&quot;, e.getMessage()));
        &#125;
    &#125;).start();
    return result;
&#125;</code></pre>
<p>使用DeferredResult时，可以设置超时，超时会自动返回超时错误响应。在另一个线程中，可以调用setResult()写入结果，也可以调用setErrorResult()写入一个错误结果。</p>
<p>运行程序，当我们访问<a target="_blank" rel="noopener" href="http://localhost:8080/api/users/1%E6%97%B6%EF%BC%8C%E5%81%87%E5%AE%9A%E7%94%A8%E6%88%B7%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%A81%E7%A7%92%E5%90%8E%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8080/api/users/1时，假定用户存在，则浏览器在1秒后返回结果：</a></p>
<p>访问一个不存在的User ID，则等待1秒后返回错误结果：</p>
<h3 id="filter处理"><a class="markdownIt-Anchor" href="#filter处理"></a> Filter处理</h3>
<p>当我们使用async模式处理请求时，原有的Filter也可以工作，但我们必须在web.xml中添加<async-supported>并设置为true。我们用两个Filter：SyncFilter和AsyncFilter分别测试：</p>
<pre><code class="highlight plaintext">&lt;web-app ...&gt;
    ...
    &lt;filter&gt;
        &lt;filter-name&gt;sync-filter&lt;/filter-name&gt;
        &lt;filter-class&gt;com.itranswarp.learnjava.web.SyncFilter&lt;/filter-class&gt;
    &lt;/filter&gt;

    &lt;filter&gt;
        &lt;filter-name&gt;async-filter&lt;/filter-name&gt;
        &lt;filter-class&gt;com.itranswarp.learnjava.web.AsyncFilter&lt;/filter-class&gt;
        &lt;async-supported&gt;true&lt;/async-supported&gt;
    &lt;/filter&gt;

    &lt;filter-mapping&gt;
        &lt;filter-name&gt;sync-filter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/api/version&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

    &lt;filter-mapping&gt;
        &lt;filter-name&gt;async-filter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/api/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    ...
&lt;/web-app&gt;</code></pre>
<p>一个声明为支持<async-supported>的Filter既可以过滤async处理请求，也可以过滤正常的同步处理请求，而未声明<async-supported>的Filter无法支持async请求，如果一个普通的Filter遇到async请求时，会直接报错，因此，务必<strong>注意普通Filter的<url-pattern>不要匹配async请求路径</strong>。</p>
<p>在logback.xml配置文件中，我们把输出格式加上[%thread]，可以输出当前线程的名称：</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt;
    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;
            &lt;Pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/Pattern&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;
    ...
&lt;/configuration&gt;</code></pre>
<p>对于同步请求，例如/api/version，我们可以看到如下输出：</p>
<pre><code class="highlight plaintext">2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.SyncFilter - start SyncFilter...
2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.AsyncFilter - start AsyncFilter...
2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.ApiController - get version...
2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.AsyncFilter - end AsyncFilter.
2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.SyncFilter - end SyncFilter.</code></pre>
<p>可见，每个Filter和ApiController都是由同一个线程执行。</p>
<p>对于异步请求，例如/api/users，我们可以看到如下输出：</p>
<pre><code class="highlight plaintext">
2020-05-16 11:23:49 [http-nio-8080-exec-4] INFO  c.i.learnjava.web.AsyncFilter - start AsyncFilter...
2020-05-16 11:23:49 [http-nio-8080-exec-4] INFO  c.i.learnjava.web.ApiController - get users...
2020-05-16 11:23:49 [http-nio-8080-exec-4] INFO  c.i.learnjava.web.AsyncFilter - end AsyncFilter.
2020-05-16 11:23:52 [MvcAsync1] INFO  c.i.learnjava.web.ApiController - return users...</code></pre>
<p>可见，AsyncFilter和ApiController是由同一个线程执行的，但是，返回响应的是另一个线程。</p>
<p>对DeferredResult测试，可以看到如下输出：</p>
<pre><code class="highlight plaintext">2020-05-16 11:25:24 [http-nio-8080-exec-8] INFO  c.i.learnjava.web.AsyncFilter - start AsyncFilter...
2020-05-16 11:25:24 [http-nio-8080-exec-8] INFO  c.i.learnjava.web.AsyncFilter - end AsyncFilter.
2020-05-16 11:25:25 [Thread-2] INFO  c.i.learnjava.web.ApiController - deferred result is set.</code></pre>
<p>同样，返回响应的是另一个线程。</p>
<p>在实际使用时，经常用到的就是DeferredResult，因为返回DeferredResult时，可以设置超时、正常结果和错误结果，易于编写比较灵活的逻辑。</p>
<p>使用async异步处理响应时，要时刻牢记，在另一个异步线程中的事务和Controller方法中执行的事务不是同一个事务，在Controller中绑定的ThreadLocal信息也无法在异步线程中获取。</p>
<p>此外，Servlet 3.0规范添加的异步支持是针对同步模型打了一个“补丁”，虽然可以异步处理请求，但高并发异步请求时，它的处理效率并不高，因为这种异步模型并没有用到真正的“原生”异步。Java标准库提供了封装操作系统的异步IO包java.nio，是真正的多路复用IO模型，可以用少量线程支持大量并发。使用NIO编程复杂度比同步IO高很多，因此我们很少直接使用NIO。相反，大部分需要高性能异步IO的应用程序会选择Netty这样的框架，它基于NIO提供了更易于使用的API，方便开发异步应用程序。</p>
<h2 id="使用websocket"><a class="markdownIt-Anchor" href="#使用websocket"></a> 使用WebSocket</h2>
<p>WebSocket是一种基于HTTP的长链接技术。传统的HTTP协议是一种请求-响应模型，如果浏览器不发送请求，那么服务器无法主动给浏览器推送数据。如果需要定期给浏览器推送数据，例如股票行情，或者不定期给浏览器推送数据，例如在线聊天，基于HTTP协议实现这类需求，只能依靠浏览器的JavaScript定时轮询，效率很低且实时性不高。</p>
<p>因为HTTP本身是基于TCP连接的，所以，WebSocket在HTTP协议的基础上做了一个简单的升级，即建立TCP连接后，浏览器发送请求时，附带几个头：</p>
<pre><code class="highlight plaintext">GET /chat HTTP/1.1
Host: www.example.com
Upgrade: websocket
Connection: Upgrade</code></pre>
<p>就表示客户端希望升级连接，变成长连接的WebSocket，服务器返回升级成功的响应：</p>
<pre><code class="highlight plaintext">HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade</code></pre>
<p>收到成功响应后表示WebSocket“握手”成功，这样，代表WebSocket的这个TCP连接将不会被服务器关闭，而是一直保持，服务器可随时向浏览器推送消息，浏览器也可随时向服务器推送消息。双方推送的消息既可以是文本消息，也可以是二进制消息，一般来说，绝大部分应用程序会推送基于JSON的文本消息。</p>
<p>现代浏览器都已经支持WebSocket协议，服务器则需要底层框架支持。Java的Servlet规范从3.1开始支持WebSocket，所以，必须选择支持Servlet 3.1或更高规范的Servlet容器，才能支持WebSocket。最新版本的Tomcat、Jetty等开源服务器均支持WebSocket。</p>
<p>我们以实际代码演示如何在Spring MVC中实现对WebSocket的支持。首先，我们需要在pom.xml中加入以下依赖：</p>
<pre><code class="highlight plaintext">org.apache.tomcat.embed:tomcat-embed-websocket:10.1.1
org.springframework:spring-websocket:6.0.0</code></pre>
<p>第一项是嵌入式Tomcat支持WebSocket的组件，第二项是Spring封装的支持WebSocket的接口。</p>
<p>接下来，我们需要在AppConfig中加入Spring Web对WebSocket的配置，此处我们需要创建一个WebSocketConfigurer实例：</p>
<pre><code class="highlight plaintext">
@Bean
WebSocketConfigurer createWebSocketConfigurer(
        @Autowired ChatHandler chatHandler,
        @Autowired ChatHandshakeInterceptor chatInterceptor)
&#123;
    return new WebSocketConfigurer() &#123;
        public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123;
            // 把URL与指定的WebSocketHandler关联，可关联多个:
            registry.addHandler(chatHandler, &quot;/chat&quot;).addInterceptors(chatInterceptor);
        &#125;
    &#125;;
&#125;</code></pre>
<p>此实例在内部通过WebSocketHandlerRegistry注册能处理WebSocket的WebSocketHandler，以及可选的WebSocket拦截器HandshakeInterceptor。我们注入的这两个类都是自己编写的业务逻辑，后面我们详细讨论如何编写它们，这里只需关注浏览器连接到WebSocket的URL是/chat</p>
<h3 id="处理websocket连接"><a class="markdownIt-Anchor" href="#处理websocket连接"></a> 处理WebSocket连接</h3>
<p>和处理普通HTTP请求不同，没法用一个方法处理一个URL。Spring提供了TextWebSocketHandler和BinaryWebSocketHandler分别处理文本消息和二进制消息，这里我们选择文本消息作为聊天室的协议，因此，ChatHandler需要继承自TextWebSocketHandler：</p>
<pre><code class="highlight plaintext">@Componentpublic class ChatHandler extends TextWebSocketHandler &#123;
    ...
&#125;</code></pre>
<p>当浏览器请求一个WebSocket连接后，如果成功建立连接，Spring会自动调用afterConnectionEstablished()方法，任何原因导致WebSocket连接中断时，Spring会自动调用afterConnectionClosed方法，因此，覆写这两个方法即可处理连接成功和结束后的业务逻辑：</p>
<pre><code class="highlight plaintext">@Component
public class ChatHandler extends TextWebSocketHandler &#123;
    // 保存所有Client的WebSocket会话实例:
    private Map&lt;String, WebSocketSession&gt; clients = new ConcurrentHashMap&lt;&gt;();

    @Override
    public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123;
        // 新会话根据ID放入Map:
        clients.put(session.getId(), session);
        session.getAttributes().put(&quot;name&quot;, &quot;Guest1&quot;);
    &#125;

    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception &#123;
        clients.remove(session.getId());
    &#125;
&#125;</code></pre>
<p>每个WebSocket会话以WebSocketSession表示，且已分配唯一ID。和WebSocket相关的数据，例如用户名称等，均可放入关联的getAttributes()中。</p>
<p>用实例变量clients持有当前所有的WebSocketSession是为了广播，即向所有用户推送同一消息时，可以这么写：</p>
<pre><code class="highlight plaintext">String json = ...
TextMessage message = new TextMessage(json);
for (String id : clients.keySet()) &#123;
    WebSocketSession session = clients.get(id);
    session.sendMessage(message);
&#125;</code></pre>
<p>我们发送的消息是序列化后的JSON，可以用ChatMessage表示：</p>
<pre><code class="highlight plaintext">public class ChatMessage &#123;
        public long timestamp;
        public String name;
    public String text;
&#125;</code></pre>
<p>每收到一个用户的消息后，我们就需要广播给所有用户：</p>
<pre><code class="highlight plaintext">@Component
public class ChatHandler extends TextWebSocketHandler &#123;
    ...
    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception &#123;
        String s = message.getPayload();
        String r = ... // 根据输入消息构造待发送消息
        broadcastMessage(r); // 推送给所有用户
    &#125;
&#125;</code></pre>
<p>如果要推送给指定的几个用户，那就需要在clients中根据条件查找出某些WebSocketSession，然后发送消息。</p>
<p>注意到我们在注册WebSocket时还传入了一个ChatHandshakeInterceptor，这个类实际上可以从HttpSessionHandshakeInterceptor继承，它的主要作用是在WebSocket建立连接后，把HttpSession的一些属性复制到WebSocketSession，例如，用户的登录信息等：</p>
<pre><code class="highlight plaintext">@Componentpublic class ChatHandshakeInterceptor extends HttpSessionHandshakeInterceptor &#123;
    public ChatHandshakeInterceptor() &#123;
        // 指定从HttpSession复制属性到WebSocketSession:
        super(List.of(UserController.KEY_USER));
    &#125;
&#125;</code></pre>
<p>这样，在ChatHandler中，可以从WebSocketSession.getAttributes()中获取到复制过来的属性。</p>
<h3 id="客户端开发"><a class="markdownIt-Anchor" href="#客户端开发"></a> 客户端开发</h3>
<p>在完成了服务器端的开发后，我们还需要在页面编写一点JavaScript逻辑：</p>
<pre><code class="highlight plaintext">// 创建WebSocket连接:var ws = new WebSocket(&#x27;ws://&#x27; + location.host + &#x27;/chat&#x27;);
// 连接成功时:
ws.addEventListener(&#x27;open&#x27;, function (event) &#123;
    console.log(&#x27;websocket connected.&#x27;);
&#125;);
// 收到消息时:
ws.addEventListener(&#x27;message&#x27;, function (event) &#123;
    console.log(&#x27;message: &#x27; + event.data);
    var msgs = JSON.parse(event.data);
    // TODO:
&#125;);
// 连接关闭时:
ws.addEventListener(&#x27;close&#x27;, function () &#123;
    console.log(&#x27;websocket closed.&#x27;);
&#125;);
// 绑定到全局变量:
window.chatWs = ws;</code></pre>
<p>用户可以在连接成功后任何时候给服务器发送消息：</p>
<pre><code class="highlight plaintext">
var inputText = &#x27;Hello, WebSocket.&#x27;;
window.chatWs.send(JSON.stringify(&#123;text: inputText&#125;));</code></pre>
<h2 id="使用scheduler"><a class="markdownIt-Anchor" href="#使用scheduler"></a> 使用Scheduler</h2>
<p>我们还是以实际代码为例，建立工程spring-integration-schedule，无需额外的依赖，我们可以直接在AppConfig中加上@<strong>EnableScheduling</strong>就开启了定时任务的支持：</p>
<pre><code class="highlight plaintext">@Configuration
@ComponentScan
@EnableWebMvc
@EnableScheduling
@EnableTransactionManagement
@PropertySource(&#123; &quot;classpath:/jdbc.properties&quot;, &quot;classpath:/task.properties&quot; &#125;)
public class AppConfig &#123;
    ...
&#125;</code></pre>
<p>接下来，我们可以直接在一个Bean中编写一个public void无参数方法，然后加上@Scheduled注解：</p>
<pre><code class="highlight plaintext">@Component
public class TaskService &#123;
    final Logger logger = LoggerFactory.getLogger(getClass());

    @Scheduled(initialDelay = 60_000, fixedRate = 60_000)
    public void checkSystemStatusEveryMinute() &#123;
        logger.info(&quot;Start check system status...&quot;);
    &#125;
&#125;</code></pre>
<p>上述注解指定了启动延迟60秒，并以60秒的间隔执行任务。现在，我们直接运行应用程序，就可以在控制台看到定时任务打印的日志：</p>
<pre><code class="highlight plaintext">2020-06-03 18:47:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start check system status...
2020-06-03 18:48:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start check system status...
2020-06-03 18:49:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start check system status...</code></pre>
<p>如果没有看到定时任务的日志，需要检查：</p>
<ul>
<li>是否忘记了在AppConfig中标注@EnableScheduling；</li>
<li>是否忘记了在定时任务的方法所在的class标注@Component。</li>
</ul>
<p>除了可以使用fixedRate外，还可以使用fixedDelay，两者的区别我们已经在使用线程池一节中讲过，这里不再重复。</p>
<p>有的童鞋在实际开发中会遇到一个问题，因为Java的注解全部是常量，写死了fixedDelay=30000，如果根据实际情况要改成60秒怎么办，只能重新编译？</p>
<p>我们可以把定时任务的配置放到配置文件中，例如task.properties：</p>
<pre><code class="highlight plaintext">task.checkDiskSpace=30000</code></pre>
<p>这样就可以随时修改配置文件而无需动代码。但是在代码中，我们需要用fixedDelayString取代fixedDelay：</p>
<pre><code class="highlight plaintext">@Component
public class TaskService &#123;
    ...

    @Scheduled(initialDelay = 30_000, fixedDelayString = &quot;$&#123;task.checkDiskSpace:30000&#125;&quot;)
    public void checkDiskSpaceEveryMinute() &#123;
        logger.info(&quot;Start check disk space...&quot;);
    &#125;
&#125;</code></pre>
<p>注意到上述代码的注解参数fixedDelayString是一个属性占位符，并配有默认值30000，Spring在处理@Scheduled注解时，如果遇到String，会根据占位符自动用配置项替换，这样就可以灵活地修改定时任务的配置。</p>
<p>此外，fixedDelayString还可以使用更易读的Duration，例如：</p>
<pre><code class="highlight plaintext">@Scheduled(initialDelay = 30_000, fixedDelayString = &quot;$&#123;task.checkDiskSpace:PT2M30S&#125;&quot;)</code></pre>
<p>以字符串PT2M30S表示的Duration就是2分30秒，请参考LocalDateTime一节的Duration相关部分。</p>
<p>多个@Scheduled方法完全可以放到一个Bean中，这样便于统一管理各类定时任务。</p>
<h3 id="使用cron任务"><a class="markdownIt-Anchor" href="#使用cron任务"></a> 使用Cron任务</h3>
<p>还有一类定时任务，它不是简单的重复执行，而是按时间触发，我们把这类任务称为Cron任务，例如：</p>
<ul>
<li>每天凌晨2:15执行报表任务；</li>
<li>每个工作日12:00执行特定任务；</li>
<li>……<br />
Cron源自Unix/Linux系统自带的crond守护进程，以一个简洁的表达式定义任务触发时间。在Spring中，也可以使用Cron表达式来执行Cron任务，在Spring中，它的格式是：</li>
</ul>
<pre><code class="highlight plaintext">秒 分 小时 天 月份 星期 年</code></pre>
<p>年是可以忽略的，通常不写。每天凌晨2:15执行的Cron表达式就是：</p>
<pre><code class="highlight plaintext">0 15 2 * * *</code></pre>
<p>每个工作日12:00执行的Cron表达式就是：</p>
<pre><code class="highlight plaintext">0 0 12 * * MON-FRI</code></pre>
<p>每个月1号，2号，3号和10号12:00执行的Cron表达式就是：</p>
<pre><code class="highlight plaintext">0 0 12 1-3,10 * *</code></pre>
<p>在Spring中，我们定义一个每天凌晨2:15执行的任务：</p>
<pre><code class="highlight plaintext">@Component
public class TaskService &#123;
    ...

    @Scheduled(cron = &quot;$&#123;task.report:0 15 2 * * *&#125;&quot;)
    public void cronDailyReport() &#123;
        logger.info(&quot;Start daily report task...&quot;);
    &#125;
&#125;</code></pre>
<p>Cron任务同样可以使用属性占位符，这样修改起来更加方便。</p>
<p>Cron表达式还可以表达每10分钟执行，例如：</p>
<pre><code class="highlight plaintext">0 */10 * * * *</code></pre>
<p>这样，在每个小时的0:00，10:00，20:00，30:00，40:00，50:00均会执行任务，实际上它可以取代fixedRate类型的定时任务。</p>
<h3 id="集成quarz"><a class="markdownIt-Anchor" href="#集成quarz"></a> 集成Quarz</h3>
<p>在Spring中使用定时任务和Cron任务都十分简单，但是要注意到，这些任务的调度都是在每个JVM进程中的。如果在本机启动两个进程，或者在多台机器上启动应用，这些进程的定时任务和Cron任务都是独立运行的，互不影响。</p>
<p>如果一些定时任务要以集群的方式运行，例如每天23:00执行检查任务，只需要集群中的一台运行即可，这个时候，可以考虑使用Quartz。</p>
<p>Quartz可以配置一个JDBC数据源，以便存储所有的任务调度计划以及任务执行状态。也可以使用内存来调度任务，但这样配置就和使用Spring的调度没啥区别了，额外集成Quartz的意义就不大。</p>
<h2 id="spring-mvc源码解析"><a class="markdownIt-Anchor" href="#spring-mvc源码解析"></a> Spring MVC源码解析</h2>
<h3 id="知识储备"><a class="markdownIt-Anchor" href="#知识储备"></a> 知识储备</h3>
<h4 id="servlet的生命周期方法"><a class="markdownIt-Anchor" href="#servlet的生命周期方法"></a> Servlet的生命周期方法</h4>
<p>init：Servlet对象创建之后调用</p>
<p>service：Servlet对象被HTTP请求访问时调用</p>
<p>destroy：Servlet对象销毁之前调用</p>
<h4 id="dispatcherservlet继承体系"><a class="markdownIt-Anchor" href="#dispatcherservlet继承体系"></a> DispatcherServlet继承体系</h4>
<h4 id="initializingbean接口介绍"><a class="markdownIt-Anchor" href="#initializingbean接口介绍"></a> InitializingBean接口介绍</h4>
<p>Spring有两种Bean的初始化（不是实例化）方法：</p>
<ul>
<li>一种时实现InitializingBean接口</li>
<li>一种是通过反射调用Bean标签中的init-method属性指定的方法</li>
</ul>
<blockquote>
<p>不同点：接口比配置效率高，但是配置消除了对spring的依赖</p>
</blockquote>
<p><strong>InitializingBean</strong>接口为bean提供了初始化方法的方式</p>
<ul>
<li>它只包括<strong>afterPropertiesSet</strong>方法</li>
<li>凡是实现该接口的类，在<strong>初始化bean</strong>的时候会执行该方法</li>
</ul>
<p>实现InitializingBean接口与在配置文件中指定init-method有什么不同？</p>
<ul>
<li>系统先调用afterPropertiesSet方法</li>
<li>然后再调用init-method方法</li>
</ul>
<h3 id="主流程dispatcherservlet"><a class="markdownIt-Anchor" href="#主流程dispatcherservlet"></a> 主流程DispatcherServlet</h3>
<h3 id="处理器映射器"><a class="markdownIt-Anchor" href="#处理器映射器"></a> 处理器映射器</h3>
<h3 id="处理器适配器"><a class="markdownIt-Anchor" href="#处理器适配器"></a> 处理器适配器</h3>
<h3 id="视图解析器"><a class="markdownIt-Anchor" href="#视图解析器"></a> 视图解析器</h3>
<h3 id="mvcannotation-driver"><a class="markdownIt-Anchor" href="#mvcannotation-driver"></a> mvc:annotation-driver</h3>
<h3 id="异常处理流程"><a class="markdownIt-Anchor" href="#异常处理流程"></a> 异常处理流程</h3>
<h3 id="文件上传流程"><a class="markdownIt-Anchor" href="#文件上传流程"></a> 文件上传流程</h3>
<h1 id="ssm整合"><a class="markdownIt-Anchor" href="#ssm整合"></a> SSM整合</h1>
<h2 id="系统分层"><a class="markdownIt-Anchor" href="#系统分层"></a> 系统分层</h2>
<h3 id="如何分层"><a class="markdownIt-Anchor" href="#如何分层"></a> 如何分层</h3>
<ul>
<li>把MVC中的VC合并为表示层，M拆分为业务层和持久层</li>
<li>上一层通过接口调用下一层提供的服务</li>
<li>
<h2 id="下一层发生变化不影响上层的代码方便代码的维护"><a class="markdownIt-Anchor" href="#下一层发生变化不影响上层的代码方便代码的维护"></a> 下一层发生变化，不影响上层的代码，方便代码的维护</h2>
</li>
</ul>
<h4 id="表现层"><a class="markdownIt-Anchor" href="#表现层"></a> 表现层</h4>
<ul>
<li>数据展现和控制逻辑（请求分发），表示层也就是web层，负责http响应</li>
<li>表现曾包括展示层和控制层，控制层负责接受请求，展示层负责结果的展示</li>
<li><strong>表现层的设计一般都使用MVC模型（MVC是表现层的设计模型，和其他层没有关系）</strong></li>
</ul>
<h4 id="业务层service"><a class="markdownIt-Anchor" href="#业务层service"></a> 业务层Service</h4>
<ul>
<li>业务逻辑的处理，和开发项目的需求息息相关</li>
<li>业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的， 事务应该放到业务层来控制）</li>
</ul>
<h4 id="持久层dao"><a class="markdownIt-Anchor" href="#持久层dao"></a> 持久层DAO</h4>
<ul>
<li>数据访问，负责数据持久化，就是和数据库交互，对数据库表进行增上改查的</li>
</ul>
<h2 id="ssm框架整合"><a class="markdownIt-Anchor" href="#ssm框架整合"></a> SSM框架整合</h2>
<h3 id="整合思路"><a class="markdownIt-Anchor" href="#整合思路"></a> 整合思路</h3>
<p>将工程的三层结构中的JavaBean分别使用Spring容器（通过XML方式）进行管理。</p>
<ol>
<li>整合持久层mapper，包括数据源、会话工程及mapper代理对象的整合；</li>
<li>整合业务层Service，包括事务及service的bean的配置；</li>
<li>整合表现层Controller，直接使用springmvc的配置。</li>
<li>Web.xml加载spring容器（包含多个XML文件）</li>
</ol>
<h3 id="工程搭建maven依赖"><a class="markdownIt-Anchor" href="#工程搭建maven依赖"></a> 工程搭建（maven依赖）</h3>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.lee&lt;/groupId&gt;
    &lt;artifactId&gt;ssmDemo&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;war&lt;/packaging&gt;

    &lt;name&gt;ssmDemo Maven Webapp&lt;/name&gt;
    &lt;!-- FIXME change it to the project&#x27;s website --&gt;
    &lt;url&gt;http://www.example.com&lt;/url&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;!-- 持久层依赖 开始 --&gt;
        &lt;!-- spring ioc组件需要的依赖包 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;
            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- spring 事务管理和JDBC依赖包 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- mysql数据库驱动包 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.35&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- dbcp连接池的依赖包 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;
            &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;
            &lt;version&gt;1.4&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- mybatis依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.4.5&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- mybatis和spring的整合依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;1.3.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- 持久层依赖 结束 --&gt;

        &lt;!-- 业务层依赖 开始 --&gt;
        &lt;!-- 基于AspectJ的aop依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;aopalliance&lt;/groupId&gt;
            &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;
            &lt;version&gt;1.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- 业务层依赖 结束 --&gt;

        &lt;!-- 表现层依赖 开始 --&gt;
        &lt;!-- spring MVC依赖包 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- jstl 取决于视图对象是否是JSP --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- 使用Mock测试需要使用该高版本的servlet-api --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;3.1.0&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;!--@ResponsBody相关注解需要的jar包--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--@ResponsBody相关注解需要的jar包--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
            &lt;version&gt;2.9.6&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- 表现层依赖 结束 --&gt;
        &lt;!-- spring 单元测试组件包 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- 单元测试Junit --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- 文件上传 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
            &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
            &lt;version&gt;1.3.1&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;finalName&gt;ssmDemo&lt;/finalName&gt;
        &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;
            &lt;plugins&gt;
                &lt;!-- 配置Maven的JDK编译级别 --&gt;
                &lt;plugin&gt;
                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.2&lt;/version&gt;
                    &lt;configuration&gt;
                        &lt;source&gt;1.8&lt;/source&gt;
                        &lt;target&gt;1.8&lt;/target&gt;
                        &lt;encoding&gt;UTF-8&lt;/encoding&gt;
                    &lt;/configuration&gt;
                &lt;/plugin&gt;

                &lt;plugin&gt;
                    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
                    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
                    &lt;version&gt;2.2&lt;/version&gt;
                    &lt;configuration&gt;
                        &lt;port&gt;8080&lt;/port&gt;
                    &lt;/configuration&gt;
                &lt;/plugin&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.1.0&lt;/version&gt;
                &lt;/plugin&gt;
                &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.0.2&lt;/version&gt;
                &lt;/plugin&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.8.0&lt;/version&gt;
                &lt;/plugin&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
                    &lt;version&gt;2.22.1&lt;/version&gt;
                &lt;/plugin&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.2.2&lt;/version&gt;
                &lt;/plugin&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;
                    &lt;version&gt;2.5.2&lt;/version&gt;
                &lt;/plugin&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;
                    &lt;version&gt;2.8.2&lt;/version&gt;
                &lt;/plugin&gt;
            &lt;/plugins&gt;
        &lt;/pluginManagement&gt;
        &lt;!--maven默认不加载xml非resources目录下的xml文件，Mapper文件就无法加载，所以得加上如下配置--&gt;
        &lt;resources&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/java&lt;/directory&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.xml&lt;/include&gt;
                &lt;/includes&gt;
                &lt;filtering&gt;true&lt;/filtering&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<h3 id="工程整合配置文件"><a class="markdownIt-Anchor" href="#工程整合配置文件"></a> 工程整合（配置文件）</h3>
<h4 id="webxml"><a class="markdownIt-Anchor" href="#webxml"></a> web.xml</h4>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;
         version=&quot;2.5&quot;&gt;

  &lt;!-- 配置前端控制器加载spring子容器 --&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;ssm&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
      &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ssm&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;

  &lt;!-- 配置ContextLoaderListener监听器加载spring父容器 --&gt;
  &lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;
      classpath:spring/applicationContext-*.xml
    &lt;/param-value&gt;
  &lt;/context-param&gt;

  &lt;!-- 监听器 --&gt;
  &lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
  &lt;/listener&gt;

  &lt;!-- POST乱码过滤器 --&gt;
  &lt;filter&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;encoding&lt;/param-name&gt;
      &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;

&lt;/web-app&gt;</code></pre>
<h4 id="整合mapper"><a class="markdownIt-Anchor" href="#整合mapper"></a> 整合mapper</h4>
<p>applicationContext-dao.xml</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
	xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
	xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

	&lt;!-- 读取java配置文件，替换占位符数据 --&gt;
	&lt;context:property-placeholder
		location=&quot;classpath:db.properties&quot; /&gt;

	&lt;!-- 配置数据源 --&gt;
	&lt;bean id=&quot;dataSource&quot;
		class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;
		&lt;property name=&quot;driverClassName&quot;
			value=&quot;$&#123;db.driverClassName&#125;&quot; /&gt;
		&lt;property name=&quot;url&quot; value=&quot;$&#123;db.url&#125;&quot; /&gt;
		&lt;property name=&quot;username&quot; value=&quot;$&#123;db.username&#125;&quot; /&gt;
		&lt;property name=&quot;password&quot; value=&quot;$&#123;db.password&#125;&quot; /&gt;
	&lt;/bean&gt;
	&lt;!-- 配置SqlSessionFactory --&gt;
	&lt;bean id=&quot;sqlSessionFactory&quot;
		class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
		&lt;!-- 注入dataSource --&gt;
		&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;

		&lt;!-- mybatis批量别名配置 --&gt;
		&lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.lee.pojo&quot;&gt;&lt;/property&gt;

	&lt;/bean&gt;

	&lt;!-- 批量代理对象的生成 --&gt;
	&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
		&lt;!-- 指定需要生成代理的接口所在的包名 --&gt;
		&lt;property name=&quot;basePackage&quot; value=&quot;com.lee.mapper&quot;&gt;&lt;/property&gt;
		&lt;!--使用下面配置会报错，因为使用ref会没等到$占位符号赋值就直接创建sqlSessionFactory--&gt;
		&lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;
		&lt;!--使用下面配置就不会报错sql,SessionFactory属性可以不用指定，会以Autowired方式自动注入
--&gt;
		&lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;
	&lt;/bean&gt;
&lt;/beans&gt;</code></pre>
<p>db.properties</p>
<pre><code class="highlight plaintext">db.driverClassName=com.mysql.jdbc.Driver
db.url=jdbc:mysql://localhost:3306/leessm?characterEncoding=UTF-8
db.username=root
db.password=123456</code></pre>
<p>log4j.properties</p>
<pre><code class="highlight plaintext">#dev env [debug] product env [info]
log4j.rootLogger=DEBUG, stdout
# Console output...
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</code></pre>
<h4 id="整合service"><a class="markdownIt-Anchor" href="#整合service"></a> 整合Service</h4>
<p>applicationContext-service.xml</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
	xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
	xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

	&lt;!-- 扫描业务bean --&gt;
	&lt;context:component-scan base-package=&quot;com.lee.service&quot;&gt;&lt;/context:component-scan&gt;
	
&lt;/beans&gt;</code></pre>
<p>applicationContext-tx.xml（事务相关）</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
	xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
	xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

	&lt;!-- 配置平台事务管理器 --&gt;
	&lt;bean id=&quot;transactionManager&quot;
		class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
		&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
	&lt;/bean&gt;

	&lt;!-- 事务通知 --&gt;
	&lt;!-- tx:advice：对应的处理器类就是TransactionInterceptor类（实现了MethodInterceptor） --&gt;
	&lt;!-- TransactionInterceptor类实现事务是通过transaction-manager属性指定的值进行事务管理 --&gt;
	&lt;tx:advice id=&quot;txAdvice&quot;
		transaction-manager=&quot;transactionManager&quot;&gt;
		&lt;!-- 设置事务管理信息 --&gt;
		&lt;tx:attributes&gt;
			&lt;!-- 增删改使用REQUIRED事务传播行为 --&gt;
			&lt;!-- 查询使用read-only --&gt;
			&lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt;
			&lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot;/&gt;
			&lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot;/&gt;
			&lt;tx:method name=&quot;create*&quot; propagation=&quot;REQUIRED&quot;/&gt;
			&lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot;/&gt;
			&lt;tx:method name=&quot;remove*&quot; propagation=&quot;REQUIRED&quot;/&gt;
			&lt;tx:method name=&quot;del*&quot; propagation=&quot;REQUIRED&quot;/&gt;
			&lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt;
			&lt;tx:method name=&quot;modify*&quot; propagation=&quot;REQUIRED&quot;/&gt;
			&lt;tx:method name=&quot;edit*&quot; propagation=&quot;REQUIRED&quot;/&gt;
			&lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot;/&gt;
			&lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;
			&lt;tx:method name=&quot;select*&quot; read-only=&quot;true&quot;/&gt;
		&lt;/tx:attributes&gt;
	&lt;/tx:advice&gt;

	&lt;!-- 基于AspectJ + XML方式实现声明式事务 --&gt;
	&lt;aop:config&gt;
		&lt;!-- aop:advisor标签使用的是传统spring aop开发方式实现的 --&gt;
		&lt;!-- spring已经实现了该增强功能，spring使用的是实现MethodInterceptor接口的方式实现的 --&gt;
		&lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* *..*.*ServiceImpl.*(..))&quot; /&gt;
	&lt;/aop:config&gt;

&lt;/beans&gt;</code></pre>
<h4 id="整合controller"><a class="markdownIt-Anchor" href="#整合controller"></a> 整合controller</h4>
<p>springmvc.xml</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
	xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
	xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
	xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

	&lt;!-- 处理器类的扫描 --&gt;
	&lt;context:component-scan
		base-package=&quot;com.lee.controller&quot; /&gt;

	&lt;!-- 配置注解的适配器和映射器，同时还注入了很多其他的bean --&gt;
	&lt;!-- 处理器适配器会去调用conversion-service --&gt;
	&lt;mvc:annotation-driven/&gt;
    
	&lt;!-- 显式的配置视图解析器 --&gt;
	&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
		&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/item/&quot;&gt;&lt;/property&gt;
		&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;
	&lt;/bean&gt;

&lt;/beans&gt;</code></pre>
<h3 id="整合测试编写代码"><a class="markdownIt-Anchor" href="#整合测试编写代码"></a> 整合测试（编写代码）</h3>
<h4 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h4>
<pre><code class="highlight plaintext">CREATE TABLE `leessm`.`Untitled`  (
  `id` int(10),
  `name` varchar(20) ,
  `price` float,
  `pic` varchar(20) ,
  `createtime` datetime ,
  `detail` varchar(100) 
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;</code></pre>
<h4 id="持久层"><a class="markdownIt-Anchor" href="#持久层"></a> 持久层</h4>
<p>持久层相关代码使用mybatis逆向工程生成</p>
<h5 id="pojo"><a class="markdownIt-Anchor" href="#pojo"></a> pojo</h5>
<p>Item.java</p>
<pre><code class="highlight plaintext">package com.lee.pojo;

import java.util.Date;

public class Item &#123;
    private Integer id;

    private String name;

    private Float price;

    private String pic;

    private Date createtime;

    private String detail;

    public Integer getId() &#123;
        return id;
    &#125;

    public void setId(Integer id) &#123;
        this.id = id;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name == null ? null : name.trim();
    &#125;

    public Float getPrice() &#123;
        return price;
    &#125;

    public void setPrice(Float price) &#123;
        this.price = price;
    &#125;

    public String getPic() &#123;
        return pic;
    &#125;

    public void setPic(String pic) &#123;
        this.pic = pic == null ? null : pic.trim();
    &#125;

    public Date getCreatetime() &#123;
        return createtime;
    &#125;

    public void setCreatetime(Date createtime) &#123;
        this.createtime = createtime;
    &#125;

    public String getDetail() &#123;
        return detail;
    &#125;

    public void setDetail(String detail) &#123;
        this.detail = detail == null ? null : detail.trim();
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Item&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +
                &quot;, price=&quot; + price +
                &quot;, pic=&#x27;&quot; + pic + &#x27;\&#x27;&#x27; +
                &quot;, createtime=&quot; + createtime +
                &quot;, detail=&#x27;&quot; + detail + &#x27;\&#x27;&#x27; +
                &#x27;&#125;&#x27;;
    &#125;
&#125;</code></pre>
<p>ItemExample.java</p>
<pre><code class="highlight plaintext">package com.lee.pojo;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class ItemExample &#123;
    protected String orderByClause;

    protected boolean distinct;

    protected List&lt;Criteria&gt; oredCriteria;

    public ItemExample() &#123;
        oredCriteria = new ArrayList&lt;Criteria&gt;();
    &#125;

    public void setOrderByClause(String orderByClause) &#123;
        this.orderByClause = orderByClause;
    &#125;

    public String getOrderByClause() &#123;
        return orderByClause;
    &#125;

    public void setDistinct(boolean distinct) &#123;
        this.distinct = distinct;
    &#125;

    public boolean isDistinct() &#123;
        return distinct;
    &#125;

    public List&lt;Criteria&gt; getOredCriteria() &#123;
        return oredCriteria;
    &#125;

    public void or(Criteria criteria) &#123;
        oredCriteria.add(criteria);
    &#125;

    public Criteria or() &#123;
        Criteria criteria = createCriteriaInternal();
        oredCriteria.add(criteria);
        return criteria;
    &#125;

    public Criteria createCriteria() &#123;
        Criteria criteria = createCriteriaInternal();
        if (oredCriteria.size() == 0) &#123;
            oredCriteria.add(criteria);
        &#125;
        return criteria;
    &#125;

    protected Criteria createCriteriaInternal() &#123;
        Criteria criteria = new Criteria();
        return criteria;
    &#125;

    public void clear() &#123;
        oredCriteria.clear();
        orderByClause = null;
        distinct = false;
    &#125;

    protected abstract static class GeneratedCriteria &#123;
        protected List&lt;Criterion&gt; criteria;

        protected GeneratedCriteria() &#123;
            super();
            criteria = new ArrayList&lt;Criterion&gt;();
        &#125;

        public boolean isValid() &#123;
            return criteria.size() &gt; 0;
        &#125;

        public List&lt;Criterion&gt; getAllCriteria() &#123;
            return criteria;
        &#125;

        public List&lt;Criterion&gt; getCriteria() &#123;
            return criteria;
        &#125;

        protected void addCriterion(String condition) &#123;
            if (condition == null) &#123;
                throw new RuntimeException(&quot;Value for condition cannot be null&quot;);
            &#125;
            criteria.add(new Criterion(condition));
        &#125;

        protected void addCriterion(String condition, Object value, String property) &#123;
            if (value == null) &#123;
                throw new RuntimeException(&quot;Value for &quot; + property + &quot; cannot be null&quot;);
            &#125;
            criteria.add(new Criterion(condition, value));
        &#125;

        protected void addCriterion(String condition, Object value1, Object value2, String property) &#123;
            if (value1 == null || value2 == null) &#123;
                throw new RuntimeException(&quot;Between values for &quot; + property + &quot; cannot be null&quot;);
            &#125;
            criteria.add(new Criterion(condition, value1, value2));
        &#125;

        public Criteria andIdIsNull() &#123;
            addCriterion(&quot;id is null&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andIdIsNotNull() &#123;
            addCriterion(&quot;id is not null&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andIdEqualTo(Integer value) &#123;
            addCriterion(&quot;hljs-string&quot; style=&quot;color: #d69d85; line-height: 160%; box-sizing: content-box;&quot;&gt;&quot;id&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andIdNotEqualTo(Integer value) &#123;
            addCriterion(&quot;id &lt;&gt;&quot;, value, &quot;id&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andIdGreaterThan(Integer value) &#123;
            addCriterion(&quot;id &gt;&quot;, value, &quot;id&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andIdGreaterThanOrEqualTo(Integer value) &#123;
            addCriterion(&quot;id &gt;=&quot;, value, &quot;id&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andIdLessThan(Integer value) &#123;
            addCriterion(&quot;id &lt;&quot;, value, &quot;id&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andIdLessThanOrEqualTo(Integer value) &#123;
            addCriterion(&quot;id &lt;=&quot;, value, &quot;id&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andIdIn(List&lt;Integer&gt; values) &#123;
            addCriterion(&quot;id in&quot;, values, &quot;id&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andIdNotIn(List&lt;Integer&gt; values) &#123;
            addCriterion(&quot;id not in&quot;, values, &quot;id&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andIdBetween(Integer value1, Integer value2) &#123;
            addCriterion(&quot;id between&quot;, value1, value2, &quot;id&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andIdNotBetween(Integer value1, Integer value2) &#123;
            addCriterion(&quot;id not between&quot;, value1, value2, &quot;id&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andNameIsNull() &#123;
            addCriterion(&quot;name is null&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andNameIsNotNull() &#123;
            addCriterion(&quot;name is not null&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andNameEqualTo(String value) &#123;
            addCriterion(&quot;name =&quot;, value, &quot;name&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andNameNotEqualTo(String value) &#123;
            addCriterion(&quot;name &lt;&gt;&quot;, value, &quot;name&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andNameGreaterThan(String value) &#123;
            addCriterion(&quot;name &gt;&quot;, value, &quot;name&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andNameGreaterThanOrEqualTo(String value) &#123;
            addCriterion(&quot;name &gt;=&quot;, value, &quot;name&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andNameLessThan(String value) &#123;
            addCriterion(&quot;name &lt;&quot;, value, &quot;name&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andNameLessThanOrEqualTo(String value) &#123;
            addCriterion(&quot;name &lt;=&quot;, value, &quot;name&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andNameLike(String value) &#123;
            addCriterion(&quot;name like&quot;, value, &quot;name&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andNameNotLike(String value) &#123;
            addCriterion(&quot;name not like&quot;, value, &quot;name&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andNameIn(List&lt;String&gt; values) &#123;
            addCriterion(&quot;name in&quot;, values, &quot;name&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andNameNotIn(List&lt;String&gt; values) &#123;
            addCriterion(&quot;name not in&quot;, values, &quot;name&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andNameBetween(String value1, String value2) &#123;
            addCriterion(&quot;name between&quot;, value1, value2, &quot;name&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andNameNotBetween(String value1, String value2) &#123;
            addCriterion(&quot;name not between&quot;, value1, value2, &quot;name&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPriceIsNull() &#123;
            addCriterion(&quot;price is null&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPriceIsNotNull() &#123;
            addCriterion(&quot;price is not null&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPriceEqualTo(Float value) &#123;
            addCriterion(&quot;price =&quot;, value, &quot;price&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPriceNotEqualTo(Float value) &#123;
            addCriterion(&quot;price &lt;&gt;&quot;, value, &quot;price&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPriceGreaterThan(Float value) &#123;
            addCriterion(&quot;price &gt;&quot;, value, &quot;price&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPriceGreaterThanOrEqualTo(Float value) &#123;
            addCriterion(&quot;price &gt;=&quot;, value, &quot;price&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPriceLessThan(Float value) &#123;
            addCriterion(&quot;price &lt;&quot;, value, &quot;price&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPriceLessThanOrEqualTo(Float value) &#123;
            addCriterion(&quot;price &lt;=&quot;, value, &quot;price&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPriceIn(List&lt;Float&gt; values) &#123;
            addCriterion(&quot;price in&quot;, values, &quot;price&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPriceNotIn(List&lt;Float&gt; values) &#123;
            addCriterion(&quot;price not in&quot;, values, &quot;price&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPriceBetween(Float value1, Float value2) &#123;
            addCriterion(&quot;price between&quot;, value1, value2, &quot;price&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPriceNotBetween(Float value1, Float value2) &#123;
            addCriterion(&quot;price not between&quot;, value1, value2, &quot;price&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPicIsNull() &#123;
            addCriterion(&quot;pic is null&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPicIsNotNull() &#123;
            addCriterion(&quot;pic is not null&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPicEqualTo(String value) &#123;
            addCriterion(&quot;pic =&quot;, value, &quot;pic&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPicNotEqualTo(String value) &#123;
            addCriterion(&quot;pic &lt;&gt;&quot;, value, &quot;pic&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPicGreaterThan(String value) &#123;
            addCriterion(&quot;pic &gt;&quot;, value, &quot;pic&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPicGreaterThanOrEqualTo(String value) &#123;
            addCriterion(&quot;pic &gt;=&quot;, value, &quot;pic&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPicLessThan(String value) &#123;
            addCriterion(&quot;pic &lt;&quot;, value, &quot;pic&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPicLessThanOrEqualTo(String value) &#123;
            addCriterion(&quot;pic &lt;=&quot;, value, &quot;pic&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPicLike(String value) &#123;
            addCriterion(&quot;pic like&quot;, value, &quot;pic&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPicNotLike(String value) &#123;
            addCriterion(&quot;pic not like&quot;, value, &quot;pic&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPicIn(List&lt;String&gt; values) &#123;
            addCriterion(&quot;pic in&quot;, values, &quot;pic&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPicNotIn(List&lt;String&gt; values) &#123;
            addCriterion(&quot;pic not in&quot;, values, &quot;pic&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPicBetween(String value1, String value2) &#123;
            addCriterion(&quot;pic between&quot;, value1, value2, &quot;pic&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andPicNotBetween(String value1, String value2) &#123;
            addCriterion(&quot;pic not between&quot;, value1, value2, &quot;pic&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andCreatetimeIsNull() &#123;
            addCriterion(&quot;createtime is null&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andCreatetimeIsNotNull() &#123;
            addCriterion(&quot;createtime is not null&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andCreatetimeEqualTo(Date value) &#123;
            addCriterion(&quot;createtime =&quot;, value, &quot;createtime&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andCreatetimeNotEqualTo(Date value) &#123;
            addCriterion(&quot;createtime &lt;&gt;&quot;, value, &quot;createtime&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andCreatetimeGreaterThan(Date value) &#123;
            addCriterion(&quot;createtime &gt;&quot;, value, &quot;createtime&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andCreatetimeGreaterThanOrEqualTo(Date value) &#123;
            addCriterion(&quot;createtime &gt;=&quot;, value, &quot;createtime&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andCreatetimeLessThan(Date value) &#123;
            addCriterion(&quot;createtime &lt;&quot;, value, &quot;createtime&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andCreatetimeLessThanOrEqualTo(Date value) &#123;
            addCriterion(&quot;createtime &lt;=&quot;, value, &quot;createtime&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andCreatetimeIn(List&lt;Date&gt; values) &#123;
            addCriterion(&quot;createtime in&quot;, values, &quot;createtime&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andCreatetimeNotIn(List&lt;Date&gt; values) &#123;
            addCriterion(&quot;createtime not in&quot;, values, &quot;createtime&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andCreatetimeBetween(Date value1, Date value2) &#123;
            addCriterion(&quot;createtime between&quot;, value1, value2, &quot;createtime&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andCreatetimeNotBetween(Date value1, Date value2) &#123;
            addCriterion(&quot;createtime not between&quot;, value1, value2, &quot;createtime&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andDetailIsNull() &#123;
            addCriterion(&quot;detail is null&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andDetailIsNotNull() &#123;
            addCriterion(&quot;detail is not null&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andDetailEqualTo(String value) &#123;
            addCriterion(&quot;detail =&quot;, value, &quot;detail&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andDetailNotEqualTo(String value) &#123;
            addCriterion(&quot;detail &lt;&gt;&quot;, value, &quot;detail&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andDetailGreaterThan(String value) &#123;
            addCriterion(&quot;detail &gt;&quot;, value, &quot;detail&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andDetailGreaterThanOrEqualTo(String value) &#123;
            addCriterion(&quot;detail &gt;=&quot;, value, &quot;detail&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andDetailLessThan(String value) &#123;
            addCriterion(&quot;detail &lt;&quot;, value, &quot;detail&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andDetailLessThanOrEqualTo(String value) &#123;
            addCriterion(&quot;detail &lt;=&quot;, value, &quot;detail&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andDetailLike(String value) &#123;
            addCriterion(&quot;detail like&quot;, value, &quot;detail&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andDetailNotLike(String value) &#123;
            addCriterion(&quot;detail not like&quot;, value, &quot;detail&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andDetailIn(List&lt;String&gt; values) &#123;
            addCriterion(&quot;detail in&quot;, values, &quot;detail&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andDetailNotIn(List&lt;String&gt; values) &#123;
            addCriterion(&quot;detail not in&quot;, values, &quot;detail&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andDetailBetween(String value1, String value2) &#123;
            addCriterion(&quot;detail between&quot;, value1, value2, &quot;detail&quot;);
            return (Criteria) this;
        &#125;

        public Criteria andDetailNotBetween(String value1, String value2) &#123;
            addCriterion(&quot;detail not between&quot;, value1, value2, &quot;detail&quot;);
            return (Criteria) this;
        &#125;
    &#125;

    public static class Criteria extends GeneratedCriteria &#123;

        protected Criteria() &#123;
            super();
        &#125;
    &#125;

    public static class Criterion &#123;
        private String condition;

        private Object value;

        private Object secondValue;

        private boolean noValue;

        private boolean singleValue;

        private boolean betweenValue;

        private boolean listValue;

        private String typeHandler;

        public String getCondition() &#123;
            return condition;
        &#125;

        public Object getValue() &#123;
            return value;
        &#125;

        public Object getSecondValue() &#123;
            return secondValue;
        &#125;

        public boolean isNoValue() &#123;
            return noValue;
        &#125;

        public boolean isSingleValue() &#123;
            return singleValue;
        &#125;

        public boolean isBetweenValue() &#123;
            return betweenValue;
        &#125;

        public boolean isListValue() &#123;
            return listValue;
        &#125;

        public String getTypeHandler() &#123;
            return typeHandler;
        &#125;

        protected Criterion(String condition) &#123;
            super();
            this.condition = condition;
            this.typeHandler = null;
            this.noValue = true;
        &#125;

        protected Criterion(String condition, Object value, String typeHandler) &#123;
            super();
            this.condition = condition;
            this.value = value;
            this.typeHandler = typeHandler;
            if (value instanceof List&lt;?&gt;) &#123;
                this.listValue = true;
            &#125; else &#123;
                this.singleValue = true;
            &#125;
        &#125;

        protected Criterion(String condition, Object value) &#123;
            this(condition, value, null);
        &#125;

        protected Criterion(String condition, Object value, Object secondValue, String typeHandler) &#123;
            super();
            this.condition = condition;
            this.value = value;
            this.secondValue = secondValue;
            this.typeHandler = typeHandler;
            this.betweenValue = true;
        &#125;

        protected Criterion(String condition, Object value, Object secondValue) &#123;
            this(condition, value, secondValue, null);
        &#125;
    &#125;
&#125;</code></pre>
<h5 id="mapper"><a class="markdownIt-Anchor" href="#mapper"></a> mapper</h5>
<p>ItemMapper.java</p>
<pre><code class="highlight plaintext">package com.lee.mapper;

import java.util.List;

import com.lee.pojo.Item;
import com.lee.pojo.ItemExample;
import org.apache.ibatis.annotations.Param;

public interface ItemMapper &#123;
    int countByExample(ItemExample example);

    int deleteByExample(ItemExample example);

    int insert(Item record);

    int insertSelective(Item record);

    List&lt;Item&gt; selectByExample(ItemExample example);

    int updateByExampleSelective(@Param(&quot;record&quot;) Item record, @Param(&quot;example&quot;) ItemExample example);

    int updateByExample(@Param(&quot;record&quot;) Item record, @Param(&quot;example&quot;) ItemExample example);
&#125;</code></pre>
<p>ItemMapper.xml</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.lee.mapper.ItemMapper&quot; &gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.lee.pojo.Item&quot; &gt;
    &lt;result column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;name&quot; property=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;price&quot; property=&quot;price&quot; jdbcType=&quot;REAL&quot; /&gt;
    &lt;result column=&quot;pic&quot; property=&quot;pic&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
    &lt;result column=&quot;detail&quot; property=&quot;detail&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
  &lt;/resultMap&gt;
  &lt;sql id=&quot;Example_Where_Clause&quot; &gt;
    &lt;where &gt;
      &lt;foreach collection=&quot;oredCriteria&quot; item=&quot;criteria&quot; separator=&quot;or&quot; &gt;
        &lt;if test=&quot;criteria.valid&quot; &gt;
          &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; prefixOverrides=&quot;and&quot; &gt;
            &lt;foreach collection=&quot;criteria.criteria&quot; item=&quot;criterion&quot; &gt;
              &lt;choose &gt;
                &lt;when test=&quot;criterion.noValue&quot; &gt;
                  and $&#123;criterion.condition&#125;
                &lt;/when&gt;
                &lt;when test=&quot;criterion.singleValue&quot; &gt;
                  and $&#123;criterion.condition&#125; #&#123;criterion.value&#125;
                &lt;/when&gt;
                &lt;when test=&quot;criterion.betweenValue&quot; &gt;
                  and $&#123;criterion.condition&#125; #&#123;criterion.value&#125; and #&#123;criterion.secondValue&#125;
                &lt;/when&gt;
                &lt;when test=&quot;criterion.listValue&quot; &gt;
                  and $&#123;criterion.condition&#125;
                  &lt;foreach collection=&quot;criterion.value&quot; item=&quot;listItem&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot; &gt;
                    #&#123;listItem&#125;
                  &lt;/foreach&gt;
                &lt;/when&gt;
              &lt;/choose&gt;
            &lt;/foreach&gt;
          &lt;/trim&gt;
        &lt;/if&gt;
      &lt;/foreach&gt;
    &lt;/where&gt;
  &lt;/sql&gt;
  &lt;sql id=&quot;Update_By_Example_Where_Clause&quot; &gt;
    &lt;where &gt;
      &lt;foreach collection=&quot;example.oredCriteria&quot; item=&quot;criteria&quot; separator=&quot;or&quot; &gt;
        &lt;if test=&quot;criteria.valid&quot; &gt;
          &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; prefixOverrides=&quot;and&quot; &gt;
            &lt;foreach collection=&quot;criteria.criteria&quot; item=&quot;criterion&quot; &gt;
              &lt;choose &gt;
                &lt;when test=&quot;criterion.noValue&quot; &gt;
                  and $&#123;criterion.condition&#125;
                &lt;/when&gt;
                &lt;when test=&quot;criterion.singleValue&quot; &gt;
                  and $&#123;criterion.condition&#125; #&#123;criterion.value&#125;
                &lt;/when&gt;
                &lt;when test=&quot;criterion.betweenValue&quot; &gt;
                  and $&#123;criterion.condition&#125; #&#123;criterion.value&#125; and #&#123;criterion.secondValue&#125;
                &lt;/when&gt;
                &lt;when test=&quot;criterion.listValue&quot; &gt;
                  and $&#123;criterion.condition&#125;
                  &lt;foreach collection=&quot;criterion.value&quot; item=&quot;listItem&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot; &gt;
                    #&#123;listItem&#125;
                  &lt;/foreach&gt;
                &lt;/when&gt;
              &lt;/choose&gt;
            &lt;/foreach&gt;
          &lt;/trim&gt;
        &lt;/if&gt;
      &lt;/foreach&gt;
    &lt;/where&gt;
  &lt;/sql&gt;
  &lt;sql id=&quot;Base_Column_List&quot; &gt;
    id, name, price, pic, createtime, detail
  &lt;/sql&gt;
  &lt;select id=&quot;selectByExample&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;com.lee.pojo.ItemExample&quot; &gt;
    select
    &lt;if test=&quot;distinct&quot; &gt;
      distinct
    &lt;/if&gt;
    &lt;include refid=&quot;Base_Column_List&quot; /&gt;
    from item
    &lt;if test=&quot;_parameter != null&quot; &gt;
      &lt;include refid=&quot;Example_Where_Clause&quot; /&gt;
    &lt;/if&gt;
    &lt;if test=&quot;orderByClause != null&quot; &gt;
      order by $&#123;orderByClause&#125;
    &lt;/if&gt;
  &lt;/select&gt;
  &lt;delete id=&quot;deleteByExample&quot; parameterType=&quot;com.lee.pojo.ItemExample&quot; &gt;
    delete from item
    &lt;if test=&quot;_parameter != null&quot; &gt;
      &lt;include refid=&quot;Example_Where_Clause&quot; /&gt;
    &lt;/if&gt;
  &lt;/delete&gt;
  &lt;insert id=&quot;insert&quot; parameterType=&quot;com.lee.pojo.Item&quot; &gt;
    insert into item (id, name, price, 
      pic, createtime, detail
      )
    values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;name,jdbcType=VARCHAR&#125;, #&#123;price,jdbcType=REAL&#125;, 
      #&#123;pic,jdbcType=VARCHAR&#125;, #&#123;createtime,jdbcType=TIMESTAMP&#125;, #&#123;detail,jdbcType=VARCHAR&#125;
      )
  &lt;/insert&gt;
  &lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.lee.pojo.Item&quot; &gt;
    insert into item
    &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot; &gt;
      &lt;if test=&quot;id != null&quot; &gt;
        id,
      &lt;/if&gt;
      &lt;if test=&quot;name != null&quot; &gt;
        name,
      &lt;/if&gt;
      &lt;if test=&quot;price != null&quot; &gt;
        price,
      &lt;/if&gt;
      &lt;if test=&quot;pic != null&quot; &gt;
        pic,
      &lt;/if&gt;
      &lt;if test=&quot;createtime != null&quot; &gt;
        createtime,
      &lt;/if&gt;
      &lt;if test=&quot;detail != null&quot; &gt;
        detail,
      &lt;/if&gt;
    &lt;/trim&gt;
    &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot; &gt;
      &lt;if test=&quot;id != null&quot; &gt;
        #&#123;id,jdbcType=INTEGER&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;name != null&quot; &gt;
        #&#123;name,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;price != null&quot; &gt;
        #&#123;price,jdbcType=REAL&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;pic != null&quot; &gt;
        #&#123;pic,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;createtime != null&quot; &gt;
        #&#123;createtime,jdbcType=TIMESTAMP&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;detail != null&quot; &gt;
        #&#123;detail,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
    &lt;/trim&gt;
  &lt;/insert&gt;
  &lt;select id=&quot;countByExample&quot; parameterType=&quot;com.lee.pojo.ItemExample&quot; resultType=&quot;java.lang.Integer&quot; &gt;
    select count(*) from item
    &lt;if test=&quot;_parameter != null&quot; &gt;
      &lt;include refid=&quot;Example_Where_Clause&quot; /&gt;
    &lt;/if&gt;
  &lt;/select&gt;
  &lt;update id=&quot;updateByExampleSelective&quot; parameterType=&quot;map&quot; &gt;
    update item
    &lt;set &gt;
      &lt;if test=&quot;record.id != null&quot; &gt;
        id = #&#123;record.id,jdbcType=INTEGER&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;record.name != null&quot; &gt;
        name = #&#123;record.name,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;record.price != null&quot; &gt;
        price = #&#123;record.price,jdbcType=REAL&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;record.pic != null&quot; &gt;
        pic = #&#123;record.pic,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;record.createtime != null&quot; &gt;
        createtime = #&#123;record.createtime,jdbcType=TIMESTAMP&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;record.detail != null&quot; &gt;
        detail = #&#123;record.detail,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
    &lt;/set&gt;
    &lt;if test=&quot;_parameter != null&quot; &gt;
      &lt;include refid=&quot;Update_By_Example_Where_Clause&quot; /&gt;
    &lt;/if&gt;
  &lt;/update&gt;
  &lt;update id=&quot;updateByExample&quot; parameterType=&quot;map&quot; &gt;
    update item
    set id = #&#123;record.id,jdbcType=INTEGER&#125;,
      name = #&#123;record.name,jdbcType=VARCHAR&#125;,
      price = #&#123;record.price,jdbcType=REAL&#125;,
      pic = #&#123;record.pic,jdbcType=VARCHAR&#125;,
      createtime = #&#123;record.createtime,jdbcType=TIMESTAMP&#125;,
      detail = #&#123;record.detail,jdbcType=VARCHAR&#125;
    &lt;if test=&quot;_parameter != null&quot; &gt;
      &lt;include refid=&quot;Update_By_Example_Where_Clause&quot; /&gt;
    &lt;/if&gt;
  &lt;/update&gt;
&lt;/mapper&gt;</code></pre>
<h4 id="业务层"><a class="markdownIt-Anchor" href="#业务层"></a> 业务层</h4>
<p>ItemService.java</p>
<pre><code class="highlight plaintext">package com.lee.service;

import com.lee.pojo.Item;

import java.util.List;

public interface ItemService &#123;
    List&lt;Item&gt; queryItemList();

    Item queryItemById(Integer id);

    void updateItem(Item item);
&#125;
</code></pre>
<p>ItemServiceImpl.java</p>
<pre><code class="highlight plaintext">package com.lee.service;

import com.lee.mapper.ItemMapper;
import com.lee.pojo.Item;
import com.lee.pojo.ItemExample;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class ItemServiceImpl implements ItemService &#123;
    @Autowired
    ItemMapper mapper;

    @Override
    public List&lt;Item&gt; queryItemList() &#123;
        // 使用逆向工程代码完成持久层查询
        ItemExample example = new ItemExample();
        // Criteria criteria = example.createCriteria();
        // criteria.andIdEqualTo(1);
        List&lt;Item&gt; list = mapper.selectByExample(example);
        return list;
    &#125;

    @Override
    public Item queryItemById(Integer id) &#123;
        return null;
    &#125;

    @Override
    public void updateItem(Item item) &#123;

    &#125;
&#125;
</code></pre>
<h4 id="表现层-2"><a class="markdownIt-Anchor" href="#表现层-2"></a> 表现层</h4>
<p>ItemController.java</p>
<pre><code class="highlight plaintext">package com.lee.controller;

import com.lee.pojo.Item;
import com.lee.service.ItemService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

import java.util.List;

@Controller
public class ItemController &#123;

    @Autowired
    ItemService service;

    @RequestMapping(&quot;queryItem&quot;)
    public ModelAndView queryItem()&#123;
        List&lt;Item&gt; items = service.queryItemList();

        ModelAndView modelAndView = new ModelAndView();

        //设置数据模型，相当于request的setAttrbute方法，实质上，底层也确实是转成了request
        //先将k/v数据放入map中，最终根据视图对象不同，在进行后续处理
        modelAndView.addObject(&quot;itemList&quot;,items);

        //设置视图（逻辑路径）
        modelAndView.setViewName(&quot;item-list&quot;);
        return modelAndView;
    &#125;
&#125;
</code></pre>
<p>item-list.jsp</p>
<pre><code class="highlight plaintext">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
         pageEncoding=&quot;UTF-8&quot; %&gt;
&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;
&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot; %&gt;
&lt;%@page isELIgnored=&quot;false&quot; %&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
    &lt;title&gt;查询商品列表&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;$&#123;pageContext.request.contextPath &#125;/itemList.do&quot; method=&quot;post&quot;&gt;
    查询条件：
    &lt;table width=&quot;100%&quot; border=1&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;查询&quot;/&gt;&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
    商品列表：
    &lt;table width=&quot;100%&quot; border=1&gt;
        &lt;tr&gt;
            &lt;td&gt;商品名称&lt;/td&gt;
            &lt;td&gt;商品价格&lt;/td&gt;
            &lt;td&gt;生产日期&lt;/td&gt;
            &lt;td&gt;商品描述&lt;/td&gt;
            &lt;td&gt;操作&lt;/td&gt;
        &lt;/tr&gt;
        &lt;c:forEach items=&quot;$&#123;itemList &#125;&quot; var=&quot;item&quot; varStatus=&quot;status&quot;&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;itemList[$&#123;status.index &#125;].name&quot; value=&quot;$&#123;item.name &#125;&quot;/&gt;&lt;/td&gt;
                &lt;td&gt;$&#123;item.price &#125;&lt;/td&gt;
                &lt;td&gt;&lt;fmt:formatDate value=&quot;$&#123;item.createtime&#125;&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&lt;/td&gt;
                &lt;td&gt;$&#123;item.detail &#125;&lt;/td&gt;

                &lt;td&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/itemEdit.do?id=$&#123;item.id&#125;&quot;&gt;修改&lt;/a&gt;&lt;/td&gt;

            &lt;/tr&gt;
        &lt;/c:forEach&gt;

    &lt;/table&gt;
&lt;/form&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
<p><strong>测试运行结果</strong></p>
<h2 id="实战技巧"><a class="markdownIt-Anchor" href="#实战技巧"></a> 实战技巧</h2>
<h3 id="中文乱码解决方案"><a class="markdownIt-Anchor" href="#中文乱码解决方案"></a> 中文乱码解决方案</h3>
<ul>
<li>以前使用方法
<ul>
<li>表单方式要使用post方式提交</li>
<li>request.setCharacterEncoding(“utf-8”)</li>
</ul>
</li>
<li>服务端要和浏览器端编码规则一致才可以解决乱码问题
<ul>
<li>浏览器编码在返回报文的表头中，你给浏览器发送的页面是什么编码，浏览器就返回什么编码</li>
</ul>
</li>
</ul>
<h4 id="数据库乱码"><a class="markdownIt-Anchor" href="#数据库乱码"></a> 数据库乱码</h4>
<ul>
<li>设置mysql编码为utf-8</li>
</ul>
<pre><code class="highlight plaintext">CREATE TABLE hero (
    id int(11) AUTO_INCREMENT,
    name varchar(30) , 
    hp float ,
    damage int(11) ,
PRIMARY KEY (id) )  DEFAULT CHARSET=utf8;
</code></pre>
<h4 id="解决get乱码"><a class="markdownIt-Anchor" href="#解决get乱码"></a> 解决get乱码</h4>
<p><strong>方式一</strong></p>
<ul>
<li>修改tomcat配置文件添加编码与工程一致</li>
</ul>
<pre><code class="highlight plaintext">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; 
              connectionTimeout=&quot;20000&quot; 
              redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot; /&gt;</code></pre>
<p><strong>方式二</strong></p>
<ul>
<li>对参数进行重新编码</li>
</ul>
<pre><code class="highlight plaintext">String username = new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;);</code></pre>
<h4 id="解决post乱码"><a class="markdownIt-Anchor" href="#解决post乱码"></a> 解决post乱码</h4>
<p><strong>方式一</strong></p>
<ul>
<li>在表单提交时，如果遇到中文字符会出现乱码现象，String提供了一个<strong>CharacterEncodingFilter</strong>过滤器，可用来解决乱码问题</li>
<li>使用CharacterEncodingFilter需要<strong>注意</strong>以下问题
<ul>
<li>表单数据以post方式提交</li>
<li>在web.xml中配置CharacterEncodingFilter过滤器</li>
<li>页面编码和过滤器指定编码要保持一致</li>
</ul>
</li>
<li>修改web.xml文件</li>
</ul>
<pre><code class="highlight plaintext">&lt;filter&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;!--/*表示所有的页面进行拦截--&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></pre>
<p><strong>方式二</strong></p>
<p>使用@RequestMapping注解中的consumes属性，指定响应体的编码</p>
<h4 id="jsp乱码"><a class="markdownIt-Anchor" href="#jsp乱码"></a> jsp乱码</h4>
<p>在jsp首行添加</p>
<pre><code class="highlight plaintext">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;</code></pre>
<h4 id="responsebody-乱码"><a class="markdownIt-Anchor" href="#responsebody-乱码"></a> @responsebody 乱码</h4>
<p><strong>方式一</strong></p>
<p>在springMVC中添加</p>
<pre><code class="highlight plaintext">&lt;mvc:annotation-driven&gt;
		&lt;!-- 消息转换器,解决responseBody返回中外乱码问题 --&gt;
		&lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;
			&lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
				&lt;property name=&quot;supportedMediaTypes&quot; value=&quot;text/plain;charset=UTF-8&quot; /&gt;
			&lt;/bean&gt;
		&lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;</code></pre>
<p><strong>方式二</strong></p>
<p>使用@RequestMapping注解中的produce属性，指定响应体的编码</p>
<h4 id="html页面编码"><a class="markdownIt-Anchor" href="#html页面编码"></a> html页面编码</h4>
<pre><code class="highlight plaintext">&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
    &lt;title&gt;用AJAX以JSON方式提交数据&lt;/title&gt;
&lt;/head&gt;</code></pre>
<h3 id="拦截器"><a class="markdownIt-Anchor" href="#拦截器"></a> 拦截器</h3>
<p>SpringMVC的拦截器主要是针对特定处理器进行拦截的</p>
<h4 id="什么是拦截器"><a class="markdownIt-Anchor" href="#什么是拦截器"></a> 什么是拦截器</h4>
<p>SpringMVC拦截器（<strong>Interceptor</strong>）实现对每一个请求处理前后进行相关的业务处理，类似与servlet中的<strong>Filter</strong></p>
<p>spring提供的一个特殊的的组件，当DispatcherServlet收到请求后，如果有拦截器，会先调用拦截器，然后调用相应的处理器（Controller）</p>
<blockquote>
<p>过滤器属于servlet规范，过滤器在DispatcherServlet之前；</p>
<p>而拦截器属于spring框架，在dispatcherServlet之后</p>
</blockquote>
<h4 id="如何写一个拦截器"><a class="markdownIt-Anchor" href="#如何写一个拦截器"></a> 如何写一个拦截器</h4>
<p>SpringMVC 中的Interceptor 拦截请求是通过HandlerInterceptor来实现的</p>
<p>在SpringMVC中定义一个Interceptor非常简单，主要有4种方式：</p>
<ol>
<li><strong>实现Spring的HandlerInterceptor接口</strong>；</li>
<li>继承实现了HandlerInterceptor接口的类，比如Spring 已经提供的实现了HandlerInterceptor 接口的抽象类HandlerInterceptorAdapter；</li>
<li>实现Spring的WebRequestInterceptor接口；</li>
<li>继承实现了WebRequestInterceptor的类；</li>
</ol>
<p>写一个Java类，实现HandlerInterceptor接口实现具体的拦截处理逻辑，比如：session验证配置拦截器</p>
<h4 id="定义拦截器实现登陆检查"><a class="markdownIt-Anchor" href="#定义拦截器实现登陆检查"></a> 定义拦截器（实现登陆检查）</h4>
<h5 id="先定义拦截器"><a class="markdownIt-Anchor" href="#先定义拦截器"></a> 先定义拦截器</h5>
<ul>
<li>Spring的HandlerMapping处理器支持拦截器应用，当需要为某些请求提供特殊功能时，例如对用户进行身份认证</li>
<li><strong>拦截器必须实现HandlerInterceptor接口</strong>，这个接口有三个方法
<ul>
<li><strong>preHandle(…)</strong>
<ul>
<li><strong>处理器执行前</strong>被调用，方法返回true标识会继续调用其他拦截器核处理器，返回<strong>false</strong>表示中断流程，不会执行后续拦截器和处理器</li>
</ul>
</li>
<li><strong>postHandle(…)</strong>
<ul>
<li><strong>处理器执行后，视图处理前</strong>调用，此时可以通过modelAndView对象对模型数据进行处理或对视图进行处理</li>
</ul>
</li>
<li><strong>afterCompletion(…)</strong>
<ul>
<li><strong>整个请求处理完毕后调用</strong>，如果性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，只有preHandle返回true时才会执行afterCompletion方法</li>
</ul>
</li>
</ul>
</li>
<li>自定义拦截器示例代码</li>
</ul>
<pre><code class="highlight plaintext">public class SomeInterceptor implements HandlerInterceptor&#123;
   
     /** 
     * 在业务处理器处理请求之前被调用 
     * 如果返回false 
     *     从当前的拦截器往回执行所有拦截器的afterCompletion(),再退出拦截器链
     * 如果返回true 
     *    执行下一个拦截器,直到所有的拦截器都执行完毕 
     *    再执行被拦截的Controller 
     *    然后进入拦截器链, 
     *    从最后一个拦截器往回执行所有的postHandle() 
     *    接着再从最后一个拦截器往回执行所有的afterCompletion() 
     */  
//应用场景：登录认证、身份授权
   public boolean preHandle(HttpServletRequest req,HttpServletResponse res,Object handler) throws Exception&#123;
        //处理器执行前调用
        System.out.println(&quot;preHandle()&quot;);
        return true;
    &#125;

    /**
     * 在业务处理器处理请求执行完成后,生成视图之前执行的动作   
     * 可在modelAndView中加入数据，比如当前时间，可以把公共模型数据传到前台，可以统一指定视图
 * 
     */ 
    
    public void postHandle(HttpServletRequest req,HttpServletResponse res,Object handler,ModelAndView mv) throws Exception&#123;
     System.out.println(&quot;postHandler&quot;);
        //处理器执行后调用
    &#125;

    /** 
     * 在DispatcherServlet完全处理完请求后被调用,可用于清理资源等  
     *  
     * 当有拦截器抛出异常时,会从当前拦截器往回执行所有的拦截器的afterCompletion() 
 * 访问视图之后调用
     */
    //应用场景：统一异常处理、统一日志处理
    public void afterCompletion(HttpServletRequest req,HttpServletResponse res,Object handler,Exception e)&#123;
    System.out.println(&quot;afterCompletion()&quot;);
        //请求完成处理后调用
    &#125;
&#125;</code></pre>
<blockquote>
<p>提示：自定义拦截器时，实现HandlerInterceptor接口需要实现接口定义的所有方法，如果只需要某一个方法可以继承HandlerInterceptorAdapter</p>
<p><strong>方法执行顺序</strong></p>
</blockquote>
<h5 id="配置拦截器"><a class="markdownIt-Anchor" href="#配置拦截器"></a> 配置拦截器</h5>
<p>如果有多个拦截器，那么配置到springmvc.xml中<strong>最上面的拦截器，拦截优先级最高</strong></p>
<p><strong>全局拦截器配置（推荐）</strong></p>
<p>自定义连接器的spring.xml配置如下</p>
<ul>
<li>如果要拦截其他路径：
<ul>
<li>/** 拦截所有</li>
<li>/* 只拦截一层，如只拦截/hello.do，不拦截/demo/hello.do</li>
<li>/category/** 拦截/category路径下的所有</li>
</ul>
</li>
</ul>
<blockquote>
<p>SpringMVC的全局拦截器配置，其实是把配置的拦截器注入到每个已初始化的HandlerMapping中了</p>
</blockquote>
<pre><code class="highlight plaintext">&lt;!-- 配置全局mapping的拦截器 --&gt;
&lt;mvc:interceptors&gt;
     &lt;!-- 公共拦截器可以拦截所有请求，而且可以有多个 --&gt;
     &lt;!-- 当设置多个拦截器时，先按顺序调用preHandle方法，然后逆序调用每个拦截器的postHandle和afterCompletion方法 --&gt;
     &lt;bean class=&quot;com.kkb.ssm.interceptor.MyHandlerInterceptor1&quot; /&gt;
    &lt;bean class=&quot;com.kkb.ssm.interceptor.MyHandlerInterceptor2&quot; /&gt;
	&lt;!-- 如果有多个拦截器，则按照顺序进行配置 --&gt;
    &lt;!-- 定义在mvc:interceptor下面的表示是对特定的请求才进行拦截的 --&gt; 
	&lt;mvc:interceptor&gt;
		&lt;!-- /**表示所有URL和子URL路径 --&gt;
		&lt;mvc:mapping path=&quot;/test/**&quot; /&gt;
        &lt;!--exclude-mapping配置表示此路径不拦截--&gt;
        &lt;mvc:exclude-mapping path=&quot;/login/*&quot;/&gt;
         &lt;!-- 特定请求的拦截器只能有一个 --&gt;
		&lt;bean class=&quot;com.kkb.ssm.interceptor.MyHandlerInterceptor3&quot; /&gt;
	&lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;</code></pre>
<p><strong>针对单个handlerMapping配置</strong></p>
<p>只有通过该处理器映射器查找到的处理器，才能使用该拦截器。</p>
<p>如果现在有两个处理器映射器：其中一个设置了处理器拦截器，另外一个没有设置，如果通过第二个映射器查找到的处理器，是无法使用拦截器的</p>
<pre><code class="highlight plaintext">&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&gt;
	&lt;property name=&quot;interceptors&quot;&gt;
		&lt;list&gt;
			&lt;ref bean=&quot;interceptor&quot; /&gt;
		&lt;/list&gt;
	&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;interceptor&quot; class=&quot;com.kkb.ssm.interceptor.MyHandlerInterceptor&quot; /&gt;</code></pre>
<h4 id="session验证案例"><a class="markdownIt-Anchor" href="#session验证案例"></a> session验证案例</h4>
<ul>
<li>session需要手动用<code>httpSession.setAttribute(&quot;admin&quot;,adminCode);</code>方法放值，session中有值后才可以用来session验证</li>
</ul>
<h5 id="controller"><a class="markdownIt-Anchor" href="#controller"></a> Controller</h5>
<ul>
<li>loginController</li>
</ul>
<pre><code class="highlight plaintext">@RequestMapping(&quot;/toLogin.do&quot;)
public String toLogin() &#123;
	System.out.println(&quot;toLogin()&quot;);

	return &quot;login&quot;;
&#125;	
@RequestMapping(&quot;/login.do&quot;)
public String login(HttpServletRequest request, HttpSession httpSession) &#123;
	String adminCode = request.getParameter(&quot;adminCode&quot;);
	String password = request.getParameter(&quot;pwd&quot;);
	System.out.println(adminCode);
	try &#123;
		Admin admin = loginService.checkLogin(adminCode, password);
		//登陆成功，将用户名存储到session对象中，方便以后session验证
		httpSession.setAttribute(&quot;admin&quot;,adminCode);
	&#125; catch (Exception e) &#123;
		if(e instanceof ApplicationException) &#123;
			request.setAttribute(&quot;admin_flag&quot;, e.getMessage());
			return &quot;login&quot;;
		&#125;
		return &quot;error&quot;;
	&#125;
	return &quot;redirect:toIndex.do&quot;;
&#125;
</code></pre>
<h5 id="定义与配置拦截器"><a class="markdownIt-Anchor" href="#定义与配置拦截器"></a> 定义与配置拦截器</h5>
<ul>
<li><strong>定义拦截器</strong></li>
</ul>
<pre><code class="highlight plaintext">package com.lee.netctoss.interceptors;
/**
 * 用于session验证的拦截器
 */

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

public class SomeInterceptor implements HandlerInterceptor &#123;

    /*
        DispatcherServlet收到请求之后，会先调用parHandle方法
        返回true:则继续向后调用
        返回false:则不在向后调用
        第三个参数：表示处理器方法的反射对象
     */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        System.out.println(&quot;preHandle()&quot;);
        HttpSession httpSession = request.getSession();
        Object obj = httpSession.getAttribute(&quot;admin&quot;);
        if (obj == null)&#123;
            //没有登陆，重定向到登陆页面
            response.sendRedirect(&quot;toLogin.do&quot;);
            return false;
        &#125;
        //已经登陆过则允许访问
        return true;
    &#125;

    /*
        Controller的方法已经执行完毕，正准备处理结果(ModelAndView)返回给DisPatcherServlet之前，执行postHandler方法，可以在改方法里面修改处理结果
     */
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        System.out.println(&quot;postHandler&quot;);
    &#125;
    /*
        最后执行的方法
        注意：只有当perHandle方法返回值为true时，该方法才会执行
        ex:是处理器所抛出的异常，可以写一个拦截器，用来处理这些异常
        比如：我们可以使用拦截器处理所有处理器抛出的异常
     */
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        System.out.println(&quot;afterCompletion()&quot;);

    &#125;
&#125;
</code></pre>
<ul>
<li><strong>配置拦截器</strong></li>
</ul>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; 
	xmlns:context=&quot;http://www.springframework.org/schema/context&quot; 
	xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; 
	xmlns:task=&quot;http://www.springframework.org/schema/task&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
	xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; 
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 
    xmlns:util=&quot;http://www.springframework.org/schema/util&quot;
    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;
    xmlns:cache=&quot;http://www.springframework.org/schema/cache&quot;
    xsi:schemaLocation=&quot;
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/tx
    http://www.springframework.org/schema/tx/spring-tx.xsd
    http://www.springframework.org/schema/jdbc
    http://www.springframework.org/schema/jdbc/spring-jdbc-3.1.xsd
    http://www.springframework.org/schema/cache
    http://www.springframework.org/schema/cache/spring-cache-3.1.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop.xsd
    http://www.springframework.org/schema/util
    http://www.springframework.org/schema/util/spring-util.xsd
    http://www.springframework.org/schema/mvc
    http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd
    http://www.springframework.org/schema/task
    http://www.springframework.org/schema/task/spring-task-3.1.xsd&quot;&gt;	
    
	&lt;!-- 配置组件扫描 --&gt;
	&lt;context:component-scan base-package=&quot;com.lee.netctoss&quot;/&gt;
	&lt;!-- 配置mvc注解扫描 --&gt;
	&lt;mvc:annotation-driven/&gt;
	&lt;!-- 配置ViewResolver视图解析器 --&gt;
	&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
		&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot;&gt;&lt;/property&gt;
		&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;
	&lt;/bean&gt;
	&lt;!-- 读取配置文件 --&gt;
	&lt;util:properties id=&quot;config&quot; location=&quot;classpath:db.properties&quot;/&gt;
	&lt;!-- 数据库连接池 --&gt;
	&lt;bean id=&quot;ds&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;
		&lt;property name=&quot;driverClassName&quot; value=&quot;#&#123;config.driverClassName&#125;&quot;&gt;&lt;/property&gt;
		&lt;property name=&quot;url&quot; value=&quot;#&#123;config.url&#125;&quot;&gt;&lt;/property&gt;
		&lt;property name=&quot;username&quot; value=&quot;#&#123;config.username&#125;&quot;&gt;&lt;/property&gt;
		&lt;property name=&quot;password&quot; value=&quot;#&#123;config.password&#125;&quot;&gt;&lt;/property&gt;
	&lt;/bean&gt;

	&lt;!--拦截器配置--&gt;
	&lt;!--如果有多个拦截器，会按照配置的先后顺序执行--&gt;
	&lt;mvc:interceptors&gt;
		&lt;mvc:interceptor&gt;
			&lt;!--哪些请求拦截--&gt;
			&lt;!--拦截所有的要用/** ，/* 只能拦截/hello.do，不能拦截/demo/hello.do--&gt;
			&lt;mvc:mapping path=&quot;/**&quot;/&gt;
			&lt;!--哪些请求不拦截--&gt;
			 &lt;mvc:exclude-mapping path=&quot;/toLogin.do&quot;/&gt;
			&lt;mvc:exclude-mapping path=&quot;/login.do&quot;/&gt;
			&lt;!--拦截器的类名--&gt;
			&lt;bean class=&quot;com.lee.netctoss.interceptors.SomeInterceptor&quot;/&gt;
		&lt;/mvc:interceptor&gt;
	&lt;/mvc:interceptors&gt;
&lt;/beans&gt;</code></pre>
<h3 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h3>
<p>springmvc在处理请求过程中出现异常信息交由异常处理器进行处理，自定义异常处理器可以实现一个系统的异常处理逻辑</p>
<p>可以将异常抛给spring，由spring来处理这些异常</p>
<ul>
<li>Spring MVC处理异常的方式有以下三种
<ol>
<li>使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver</li>
<li>实现HandlerExceptionResolver接口自定义异常处理器</li>
<li>使用@ExceptionHandler注解实现异常处理</li>
</ol>
</li>
</ul>
<p>当发生异常的时候，SpringMVC会如下处理：</p>
<p>（1）SpringMVC会先从配置文件找异常解析器HandlerExceptionResolver</p>
<p>（2）如果找到了异常异常解析器，那么接下来就会判断该异常解析器能否处理当前发生的异常</p>
<p>（3）如果可以处理的话，那么就进行处理，然后给前台返回对应的异常视图</p>
<p>（4）如果没有找到对应的异常解析器或者是找到的异常解析器不能处理当前的异常的时候，就看当前的Controller中有没有提供对应的异常处理器，如果提供了就由Controller自己进行处理并返回对应的视图</p>
<p>（5）如果配置文件里面没有定义对应的异常解析器，而当前Controller中也没有定义的话，那么该异常就会被抛出来。</p>
<h4 id="异常概念"><a class="markdownIt-Anchor" href="#异常概念"></a> 异常概念</h4>
<p>异常包含<strong>编译时异常</strong>和<strong>运行时异常</strong>，其中编译时异常也叫预期异常。运行时异常只有在项目运行的情况下才会发现，编译的时候不需要关心。</p>
<ul>
<li><strong>运行时异常</strong>，比如：空指针异常、数组越界异常，对于这样的异常，只能通过程序员丰富的经验来解决和测试人员不断的严格测试来解决。</li>
<li><strong>编译时异常</strong>，比如：数据库异常、文件读取异常、自定义异常等。对于这样的异常，必须使用try catch代码块或者throws关键字来处理异常</li>
</ul>
<h4 id="异常处理思路"><a class="markdownIt-Anchor" href="#异常处理思路"></a> 异常处理思路</h4>
<p>系统中异常包括两类：预期异常（编译时异常）和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。</p>
<p>系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理，如下图：</p>
<h4 id="使用simplemappingexceptionresolver"><a class="markdownIt-Anchor" href="#使用simplemappingexceptionresolver"></a> 使用SimpleMappingExceptionResolver</h4>
<ul>
<li>使用只需要在Spring的XML配置文件中定义就可以了</li>
<li><strong>异常处理页面获取异常对象名exception适合全局处理简单异常</strong></li>
<li>TimeoutException为异常类型</li>
<li>login为视图页面</li>
</ul>
<pre><code class="highlight plaintext">    &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;
    &lt;property name=&quot;exceptionMapping&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;java.lang.Exception&quot;&gt;error&lt;/prop&gt;
            &lt;prop key=&quot;com.tarena.TimeoutException&quot;&gt;login&lt;/prop&gt;
        &lt;props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
<h4 id="实现handlerexceptionresolver接口自定义异常处理器"><a class="markdownIt-Anchor" href="#实现handlerexceptionresolver接口自定义异常处理器"></a> 实现HandlerExceptionResolver接口自定义异常处理器</h4>
<p>为了区别不同的异常通常根据异常类型自定义异常类，这里我们创建一个自定义系统异常，如果controller、service、dao抛出此类异常说明是系统预期处理的异常信息</p>
<pre><code class="highlight plaintext">public class BusinessException extends Exception &#123;
	
	private static final long serialVersionUID = 1L;

	//异常信息
	private String message;
	
	public BusinessException(String message) &#123;
		super(message);
		this.message = message;
	&#125;

	public String getMessage() &#123;
		return message;
	&#125;

	public void setMessage(String message) &#123;
		this.message = message;
	&#125;
&#125;</code></pre>
<p>自定义异常处理器</p>
<pre><code class="highlight plaintext">public class BusinessExceptionResolver implements HandlerExceptionResolver &#123;

	@Override
	public ModelAndView resolveException(HttpServletRequest request,
			HttpServletResponse response, Object handler, Exception ex) &#123;
		
		//自定义预期异常
		BusinessException businessException = null; 
		//如果抛出的是系统自定义的异常
		if(ex instanceof BusinessException)&#123;
			businessException = (BusinessException) ex;
		&#125;else&#123;
			businessException = new BusinessException(&quot;未知错误&quot;);
		&#125;
		
		ModelAndView modelAndView = new ModelAndView();
		//把错误信息传递到页面
		modelAndView.addObject(&quot;message&quot;, businessException.getMessage());
		//指向错误页面
		modelAndView.setViewName(&quot;error&quot;);
		return modelAndView;
	&#125;
&#125;</code></pre>
<p>错误页面</p>
<pre><code class="highlight plaintext">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;错误信息&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
$&#123;message &#125;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>自定义的异常处理器需要在Spring的XML配置文件中定义下才可以使用</p>
<pre><code class="highlight plaintext">&lt;!--自定义异常处理器（全局）--&gt;
&lt;bean id=&quot;exceptionHandler&quot; class=&quot;com.kkb.ssm.resolver.BusinessExceptionResolver&quot;/&gt;</code></pre>
<p>异常测试</p>
<pre><code class="highlight plaintext">@RequestMapping(value = &quot;/showItemEdit&quot;)
public String showItemEdit(Integer id,Model model) throws Exception&#123;

	// 查询要显示的商品内容
	Item item = itemService.queryItemById(id);

	if(item == null) throw new BusinessException(&quot;查询不到商品无法修改&quot;);

	model.addAttribute(&quot;item&quot;, item);
	// 由于配置了ViewResolver，所以此处只写逻辑视图名称即可
	return &quot;item/item-edit&quot;;
&#125;</code></pre>
<h4 id="exceptionhandler注解实现异常处理"><a class="markdownIt-Anchor" href="#exceptionhandler注解实现异常处理"></a> @ExceptionHandler注解实现异常处理</h4>
<ul>
<li>首先编写一个BaseController类</li>
<li>适合局部处理有“处理过程”的异常</li>
<li>然后其他的Controller继承BaseController类即可</li>
</ul>
<pre><code class="highlight plaintext">//该注解可以对Controller进行增强
@ControllerAdvice
  public class BaseController&#123;
         //应用到所有@RequestMapping注解的方法，在其执行之前把返回值放入ModelMap中
         public Map&lt;String,Map&gt;  ma()&#123;
            Map&lt;String,Map&gt; map = new HashMap();
            map.put(&quot;name&quot;,&quot;tom&quot;);
            return map;
         &#125;              
        
        //应用到所有带参数的@RequestMapping的方法，在其执行之前初始化数据绑定
	@InitBinder
	public void initBinder(WebDataBinder dataBinder)&#123;
	   DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-mm-dd&quot;);
	   dataBinder.registerCustomEditor(Date.class,new CustomDateEditor(dateFormat));
	   System.out.println(&quot;...initBider...&quot;);
	&#125;
        
        
        //应用到所有@RequestMapping注解的方法，在其有抛出指定异常时执行
        @ExceptionHandler(Exception.class)
        public String execute(HttpServletRequest request,Exception ex)&#123;
            request.setAttribute(&quot;ex&quot;,ex);
            //可以根据异常类型返回不同的视图名
        &#125;
    &#125;</code></pre>
<h4 id="responsestatus"><a class="markdownIt-Anchor" href="#responsestatus"></a> @ResponseStatus</h4>
<p>带有@ResponseStatus注解的异常类会被ResponseStatusExceptionResolver 解析。可以实现自定义的一些异常,同时在页面上进行显示。具体的使用方法如下:</p>
<ul>
<li>value属性：指定状态码</li>
<li>code属性：指定状态码</li>
<li>reason属性：错误描述（注：如果期望返回状态码为2XX，则一定不要填写reason属性，reason属性只要不为空，返回的状态码就错误状态码）</li>
</ul>
<blockquote>
<p><strong>注解底层还是通过设置  response.setStatus来实现.</strong></p>
</blockquote>
<blockquote>
<p>该注解在@RequestMapping方法执行完成，Spring解析返回值之前，进行了responseStatus设置</p>
</blockquote>
<hr />
<p><strong>定义在自定义异常类上</strong></p>
<ul>
<li>如果定义在自定义异常类上，如果controller抛出这个异常，则springMVC会把返回的状态码设置为@ResponseStatus中指定的状态码</li>
<li>在SpringMvc中如果有某个 @RequestMapping方法抛出该异常,  只要开启<a href="">mvc:annotation-driven/</a></li>
</ul>
<ol>
<li>首先自定义一个异常类</li>
</ol>
<pre><code class="highlight plaintext">@ResponseStatus(value = HttpStatus.FORBIDDEN,reason = &quot;用户名和密码不匹配!&quot;)
public class UserNameNotMatchPasswordException extends RuntimeException&#123;
        
&#125;</code></pre>
<ol>
<li>人为抛出一个异常:</li>
</ol>
<pre><code class="highlight plaintext">@RequestMapping(&quot;/testResponseStatusExceptionResolver&quot;)
  public String testResponseStatusExceptionResolver(@RequestParam(&quot;i&quot;) int i)&#123;
      if (i==13)&#123;
          throw new UserNameNotMatchPasswordException();
      &#125;
      System.out.println(&quot;testResponseStatusExceptionResolver....&quot;);
      return &quot;success&quot;;
  &#125;</code></pre>
<ol>
<li>输入如下额路径:</li>
</ol>
<p><a href="">http://localhost:8090/testResponseStatusExceptionResolver?i=13</a></p>
<hr />
<p><strong>定义在Controller方法上</strong></p>
<ul>
<li>定义在Controller方法上时，每次访问返回的状态码都为你指定的状态码</li>
<li>@ResponseStatus(code=A,reason=B)标注在 @RequestMapping方法上，作用效果与 response.sendError(A,B)是一样的.</li>
</ul>
<pre><code class="highlight plaintext">@ResponseStatus(reason = &quot;测试&quot;,value = HttpStatus.NOT_FOUND)
@RequestMapping(&quot;/testResponseStatusExceptionResolver&quot;)
public String testResponseStatusExceptionResolver(@RequestParam(&quot;i&quot;) int i)&#123;
    if (i==13)&#123;
        throw new UserNameNotMatchPasswordException();
    &#125;
    System.out.println(&quot;testResponseStatusExceptionResolver....&quot;);
    return &quot;success&quot;;
&#125;</code></pre>
<p>每次访问都会返回你指定的状态码</p>
<blockquote>
<p>如果只是为了指示返回状态码，最好不要添加reason属性（如果添加了reason属性，且reason不为&quot;&quot;，且code &gt; 0(哪怕状态码是200)，会对当前请求走错误处理）</p>
</blockquote>
<hr />
<p><strong>定义在@ControllerAdvice中</strong></p>
<ul>
<li>@ControllerAdvice标注初衷我想就是程序运行过程中发生异常，对异常如何处理？  而@ResponseStatus标注在@ControllerAdvice类或者该类下的@ExceptionHandler上，区别大概就是，原来比如请求程序抛出异常，异常被捕获，走@ExceptionHandler，正常走完状态码是200.</li>
<li>@ControllerAdvice或者 @ExceptionHandler标注了@ReponseStatus，那走完状态码就是500.如果你再给@ResponseStatus添加了reason属性，不管捕获异常方法咋返回，都是服务器的错误码捕获界面，比如上面我的例子，给@ResponseStatus添加reason=”your defined message”.不管怎么说，下面界面比一大堆异常堆栈信息看起来更简洁，但我还是不推荐使用诶,原因啊，界面不友好.</li>
</ul>
<pre><code class="highlight plaintext">@ControllerAdvice
@ResponseStatus
public class MyControllerAdvice &#123;
 
    @ExceptionHandler(&#123;ArithmeticException.class&#125;)
    public ModelAndView fix(Exception e)&#123;
        Map map=new HashMap();
        map.put(&quot;ex&quot;,e.getMessage());
        return new ModelAndView(&quot;error&quot;,map);
    &#125;
 
&#125;
</code></pre>
<h4 id="对于框架内部异常或代码无法捕获的异常"><a class="markdownIt-Anchor" href="#对于框架内部异常或代码无法捕获的异常"></a> 对于框架内部异常或代码无法捕获的异常</h4>
<ul>
<li>对于此种异常，可以再web.xml通过<error-page>定义，目前绝大多数服务器都支持此配置，配置示例如下</li>
</ul>
<pre><code class="highlight plaintext">&lt;error-page&gt;
        &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt;
        &lt;location&gt;/WEB-INF/views/error/500.jsp&lt;/location&gt;
&lt;/error-page&gt;
&lt;error-page&gt;
       &lt;error-code&gt;404&lt;/error-code&gt;
       &lt;location&gt;/WEB-INF/views/error/404.jsp&lt;/location&gt;
&lt;/error-page&gt;</code></pre>
<h3 id="文件上传"><a class="markdownIt-Anchor" href="#文件上传"></a> 文件上传</h3>
<h4 id="springmvc文件上传简介"><a class="markdownIt-Anchor" href="#springmvc文件上传简介"></a> SpringMVC文件上传简介</h4>
<ul>
<li>再springMVC中，文件上传功能可以由即插即用的CommonsMultipartResolver解析器组件实现，它定义再org.springframework.web.multipart包里，Spring提供的CommonsMultipartResolver解析器可以支持Commons FileUpload和COS FileUpload两种上传组件</li>
</ul>
<h4 id="commonsmultipartresolver组件"><a class="markdownIt-Anchor" href="#commonsmultipartresolver组件"></a> CommonsMultipartResolver组件</h4>
<ul>
<li>CommonsMultipartResolver解析器可以调用common-fileupload.jar的功能，将请求提交的文件信息结息出来，该组件使用步骤如下
<ul>
<li>引入common-fileupload.jar和<br />
common-io.jar开发包</li>
<li>再spring配置文件中添加CommonsMultipartResolver组件的bean定义</li>
</ul>
</li>
</ul>
<pre><code class="highlight plaintext">&lt;!--这个bean的id不能修改，是底层写死的，写错了就找不到改类了--&gt;
&lt;bean id=&quot;multipartReslver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;</code></pre>
<h4 id="实现步骤"><a class="markdownIt-Anchor" href="#实现步骤"></a> 实现步骤</h4>
<p><strong>maven依赖</strong></p>
<pre><code class="highlight plaintext">&lt;dependency&gt;
	&lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
	&lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
	&lt;version&gt;1.3.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<p><strong>jsp页面（上传）</strong></p>
<ul>
<li>再JSP视图表单中，<form>标记必须追加<strong>enctype=&quot;multipart/form-data&quot;设置</strong>，指定表单数据的提交格式，默认情况，提交格式是application/x-www-form-urlencoded（key/value格式），不能用于文件上传
<ul>
<li>
<h2 id="enctypemultipartform-data格式表单"><a class="markdownIt-Anchor" href="#enctypemultipartform-data格式表单"></a> enctype=&quot;multipart/form-data&quot;格式表单</h2>
</li>
<li>
<h2 id="enctypeapplicationx-www-form-urlencoded格式表单"><a class="markdownIt-Anchor" href="#enctypeapplicationx-www-form-urlencoded格式表单"></a> enctype=&quot;application/x-www-form-urlencoded&quot;格式表单</h2>
</li>
</ul>
</li>
<li>method属性也必须设置为<strong>post方式</strong>提交</li>
</ul>
<pre><code class="highlight plaintext">&lt;form action=&quot;upload.from&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
     &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;
     &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;/&gt;
&lt;/form&gt;</code></pre>
<p><strong>Controller实现</strong></p>
<ul>
<li>再Controller处理方法中，可以使用@RequestParam注解将CommonsMultipartResolver解析出的文件赋值给MultipartFile参数对象，该对象包含了上传的文件信息</li>
</ul>
<pre><code class="highlight plaintext">@RequestMapping(value=&quot;/upload.from&quot;)
//@RequestParam写不写都可以
public String upload( @RequestParam(value=&quot;file&quot;,required=false)MultipartFile file,HttpServletRequest request,ModelMao model)&#123;
        //获取10位的随机数
        String name = RandomStringUtils.randomAlphanumeric(10);
        //创建文件名
    String newFileName = name + &quot;.jpg&quot;;
    //获取到WEB目录下的image目录，用于存放上传后的文件
        File newFile = new File(request.getServletContext().getRealPath(&quot;/image&quot;), newFileName);
    //调用file.getImage().transferTo(newFile); 复制文件
    file.getImage().transferTo(newFile);
    
    //一般将文件全路径名存放到数据库中
    
    //把生成的随机文件名提交给视图
        ModelAndView mav = new ModelAndView(&quot;showUploadedFile&quot;);
        mav.addObject(&quot;imageName&quot;, newFileName);
        return mav;

&#125;</code></pre>
<hr />
<p>另一个controller处理逻辑</p>
<pre><code class="highlight plaintext">@RequestMapping(value = &quot;/updateItem&quot;)
public String updateItem(Model model,Item item,
				MultipartFile pictureFile) throws Exception &#123;
		
	if(pictureFile != null)&#123;
		System.out.println(pictureFile.getOriginalFilename());
		//原始图片名称
		String originalFilename = pictureFile.getOriginalFilename();
		//如果没有图片名称，则上传不成功
		if(originalFilename != null &amp;&amp; originalFilename.length()&gt;0)
		&#123;
			//存放图片的物理路径
			String picPath = &quot;E:\\03-teach\\07-upload\\temp\\&quot;;
			//新文件的名称，substring是对文件扩展名的截取 
			String newFileName = UUID.randomUUID()+originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));
			//确保目录是否存在
			File dirFile = new File(picPath);
			if(!dirFile.exists())&#123;
			      dirFile.mkdirs();
			&#125;
			//新的文件
			File newFile = new File(picPath+newFileName);
			//把上传的文件保存成一个新的文件
			pictureFile.transferTo(newFile);
			//同时需要把新的文件名更新到数据库中
			item.setPic(newFileName);
		&#125;else&#123;
			throw new BusinessException(&quot;图片名称不存在，上传不成功&quot;);
		&#125;
	&#125;
		
	// 根据页面传入的商品信息，调用修改方法，进行修改（此时还没有讲参数绑定，暂时无法进行）
	itemService.updateItem(item);
	return &quot;success&quot;;
&#125;
</code></pre>
<p><strong>showUploadedFile.jsp显示图片界面</strong></p>
<pre><code class="highlight plaintext">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot; isELIgnored=&quot;false&quot;%&gt;
 
&lt;img src=&quot;image/$&#123;imageName&#125;&quot;/&gt;</code></pre>
<p><strong>限制上传文件大小</strong></p>
<ul>
<li>CommonsMultipartResolver解析器可以设置对上传文件大小的限定，配置示例如下</li>
</ul>
<pre><code class="highlight plaintext">&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;property name=&quot;maxUploadSize&quot; value=&quot;102400&quot;/&gt;
&lt;/bean&gt;</code></pre>
<ul>
<li>当设置maxUploadSize大小限制后，如果上传文件大于指定大小，会抛出MaxUploadSizeExceededException异常，可以采用异常处理给客户显示友好提示</li>
<li>在处理上传的Controller组件中定义@ExceptionHandler异常处理方法</li>
<li><strong>@ExceptionHandler异常处理示例</strong></li>
</ul>
<pre><code class="highlight plaintext">    @ExceptionHandler
    public ModelAndView doException(Exception ex)&#123;
        Map&lt;String,Object&gt;model = new HashMap&lt;String,Object&gt;();
        if(ex instanceof MaxUploadSizeExceededException)&#123;
            long size = ((MaxUploadSizeExceededException)ex).getMaxUploadSize();
            model.put(&quot;errors&quot;,&quot;文件应小于&quot;+ex.getMessage());
        &#125;else&#123;
            model.put(&quot;errors&quot;,&quot;未知错误：&quot;+ex.getMessage());
        &#125;
        return new ModelAndView(&quot;upload&quot;,model);
    &#125;
    
提示:CommonsMultipartResolver的resolveLazily属性指定为true，将文件解析演出加载，才能出发上面的异常处理</code></pre>
<h4 id="限制文件上传类型"><a class="markdownIt-Anchor" href="#限制文件上传类型"></a> 限制文件上传类型</h4>
<pre><code class="highlight plaintext">public enum FileType &#123;
        /** 
         * JEPG. 
         */  
        JPEG(&quot;FFD8FF&quot;),  
      
        /** 
         * PNG. 
         */  
        PNG(&quot;89504E47&quot;),  
      
        /** 
         * GIF. 
         */  
        GIF(&quot;47494638&quot;),  
      
        /** 
         * TIFF. 
         */  
        TIFF(&quot;49492A00&quot;),  
      
        /** 
         * Windows Bitmap. 
         */  
        BMP(&quot;424D&quot;),  
      
        /** 
         * CAD. 
         */  
        DWG(&quot;41433130&quot;),  
      
        /** 
         * Adobe Photoshop. 
         */  
        PSD(&quot;38425053&quot;),  
      
        /** 
         * Rich Text Format. 
         */  
        RTF(&quot;7B5C727466&quot;),  
      
        /** 
         * XML. 
         */  
        XML(&quot;3C3F786D6C&quot;),  
      
        /** 
         * HTML. 
         */  
        HTML(&quot;68746D6C3E&quot;),  
        /** 
         * CSS. 
         */  
        CSS(&quot;48544D4C207B0D0A0942&quot;),  
        /** 
         * JS. 
         */  
        JS(&quot;696B2E71623D696B2E71&quot;),  
        /** 
         * Email [thorough only]. 
         */  
        EML(&quot;44656C69766572792D646174653A&quot;),  
      
        /** 
         * Outlook Express. 
         */  
        DBX(&quot;CFAD12FEC5FD746F&quot;),  
      
        /** 
         * Outlook (pst). 
         */  
        PST(&quot;2142444E&quot;),  
      
        /** 
         * MS Word/Excel. 
         */  
        XLS_DOC(&quot;D0CF11E0&quot;), XLSX_DOCX(&quot;504B030414000600080000002100&quot;),  
        /** 
         * Visio 
         */  
        VSD(&quot;d0cf11e0a1b11ae10000&quot;),  
        /** 
         * MS Access. 
         */  
        MDB(&quot;5374616E64617264204A&quot;),  
        /** 
         * WPS文字wps、表格et、演示dps都是一样的 
         */  
        WPS(&quot;d0cf11e0a1b11ae10000&quot;),  
        /** 
         * torrent 
         */  
        TORRENT(&quot;6431303A637265617465&quot;),  
        /** 
         * WordPerfect. 
         */  
        WPD(&quot;FF575043&quot;),  
      
        /** 
         * Postscript. 
         */  
        EPS(&quot;252150532D41646F6265&quot;),  
      
        /** 
         * Adobe Acrobat. 
         */  
        PDF(&quot;255044462D312E&quot;),  
      
        /** 
         * Quicken. 
         */  
        QDF(&quot;AC9EBD8F&quot;),  
      
        /** 
         * Windows Password. 
         */  
        PWL(&quot;E3828596&quot;),  
      
        /** 
         * ZIP Archive. 
         */  
        ZIP(&quot;504B0304&quot;),  
      
        /** 
         * RAR Archive. 
         */  
        RAR(&quot;52617221&quot;),  
        /** 
         * JSP Archive. 
         */  
        JSP(&quot;3C2540207061676520&quot;),  
        /** 
         * JAVA Archive. 
         */  
        JAVA(&quot;7061636B61676520&quot;),  
        /** 
         * CLASS Archive. 
         */  
        CLASS(&quot;CAFEBABE0000002E00&quot;),  
        /** 
         * JAR Archive. 
         */  
        JAR(&quot;504B03040A000000&quot;),  
        /** 
         * MF Archive. 
         */  
        MF(&quot;4D616E69666573742D56&quot;),  
        /** 
         *EXE Archive. 
         */  
        EXE(&quot;4D5A9000030000000400&quot;),  
        /** 
         *CHM Archive. 
         */  
        CHM(&quot;49545346030000006000&quot;),  
        /* 
         * INI(&quot;235468697320636F6E66&quot;), SQL(&quot;494E5345525420494E54&quot;), BAT( 
         * &quot;406563686F206f66660D&quot;), GZ(&quot;1F8B0800000000000000&quot;), PROPERTIES( 
         * &quot;6C6F67346A2E726F6F74&quot;), MXP( 
         * &quot;04000000010000001300&quot;), 
         */  
        /** 
         * Wave. 
         */  
        WAV(&quot;57415645&quot;),  
      
        /** 
         * AVI. 
         */  
        AVI(&quot;41564920&quot;),  
      
        /** 
         * Real Audio. 
         */  
        RAM(&quot;2E7261FD&quot;),  
      
        /** 
         * Real Media. 
         */  
        RM(&quot;2E524D46&quot;),  
      
        /** 
         * MPEG (mpg). 
         */  
        MPG(&quot;000001BA&quot;),  
      
        /** 
         * Quicktime. 
         */  
        MOV(&quot;6D6F6F76&quot;),  
      
        /** 
         * Windows Media. 
         */  
        ASF(&quot;3026B2758E66CF11&quot;),  
      
        /** 
         * MIDI. 
         */  
        MID(&quot;4D546864&quot;),  
        /** 
         * MP4. 
         */  
        MP4(&quot;00000020667479706d70&quot;),  
        /** 
         * MP3. 
         */  
        MP3(&quot;49443303000000002176&quot;),  
        /** 
         * FLV. 
         */  
        FLV(&quot;464C5601050000000900&quot;);  
        private String value = &quot;&quot;;  
      
        /** 
         * Constructor. 
         *  
         * @param type 
         */  
        private FileType(String value) &#123;  
            this.value = value;  
        &#125;  
      
        public String getValue() &#123;  
            return value;  
        &#125;  
      
        public void setValue(String value) &#123;  
            this.value = value;  
        &#125;
&#125;</code></pre>
<pre><code class="highlight plaintext">public final class FileTypeJudge &#123;  
  
    /** 
     * Constructor 
     */  
    private FileTypeJudge() &#123;  
    &#125;  
  
    /** 
     * 将文件头转换成16进制字符串 
     *  
     * @param 原生byte 
     * @return 16进制字符串 
     */  
    private static String bytesToHexString(byte[] src) &#123;  
  
        StringBuilder stringBuilder = new StringBuilder();  
        if (src == null || src.length &lt;= 0) &#123;  
            return null;  
        &#125;  
        for (int i = 0; i &lt; src.length; i++) &#123;  
            int v = src[i] &amp; 0xFF;  
            String hv = Integer.toHexString(v);  
            if (hv.length() &lt; 2) &#123;  
                stringBuilder.append(0);  
            &#125;  
            stringBuilder.append(hv);  
        &#125;  
        return stringBuilder.toString();  
    &#125;  
  
    /** 
     * 得到文件头 
     *  
     * @param filePath 
     *            文件路径 
     * @return 文件头 
     * @throws IOException 
     */  
    private static String getFileContent(InputStream is) throws IOException &#123;  
  
        byte[] b = new byte[28];  
  
        InputStream inputStream = null;  
  
        try &#123;  
            is.read(b, 0, 28);  
        &#125; catch (IOException e) &#123;  
            e.printStackTrace();  
            throw e;  
        &#125; finally &#123;  
            if (inputStream != null) &#123;  
                try &#123;  
                    inputStream.close();  
                &#125; catch (IOException e) &#123;  
                    e.printStackTrace();  
                    throw e;  
                &#125;  
            &#125;  
        &#125;  
        return bytesToHexString(b);  
    &#125;  
  
    /** 
     * 判断文件类型 
     *  
     * @param filePath 
     *            文件路径 
     * @return 文件类型 
     */  
    public static FileType getType(InputStream is) throws IOException &#123;  
  
        String fileHead = getFileContent(is);  
        if (fileHead == null || fileHead.length() == 0) &#123;  
            return null;  
        &#125;  
        fileHead = fileHead.toUpperCase();  
        FileType[] fileTypes = FileType.values();  
  
        for (FileType type : fileTypes) &#123;  
            if (fileHead.startsWith(type.getValue())) &#123;  
                return type;  
            &#125;  
        &#125;  
  
        return null;  
    &#125;  
    /**
     * 
     * @param value 表示文件类型
     * @return 1 表示图片,2 表示文档,3 表示视频,4 表示种子,5 表示音乐,6 表示其它
     * @return
     */
    public static Integer isFileType(FileType value) &#123;  
        Integer type = 6;// 其他  
        // 图片  
        FileType[] pics = &#123; FileType.JPEG, FileType.PNG, FileType.GIF, FileType.TIFF, FileType.BMP, FileType.DWG, FileType.PSD &#125;;  
  
        FileType[] docs = &#123; FileType.RTF, FileType.XML, FileType.HTML, FileType.CSS, FileType.JS, FileType.EML, FileType.DBX, FileType.PST, FileType.XLS_DOC, FileType.XLSX_DOCX, FileType.VSD,  
                FileType.MDB, FileType.WPS, FileType.WPD, FileType.EPS, FileType.PDF, FileType.QDF, FileType.PWL, FileType.ZIP, FileType.RAR, FileType.JSP, FileType.JAVA, FileType.CLASS,  
                FileType.JAR, FileType.MF, FileType.EXE, FileType.CHM &#125;;  
  
        FileType[] videos = &#123; FileType.AVI, FileType.RAM, FileType.RM, FileType.MPG, FileType.MOV, FileType.ASF, FileType.MP4, FileType.FLV, FileType.MID &#125;;  
  
        FileType[] tottents = &#123; FileType.TORRENT &#125;;  
  
        FileType[] audios = &#123; FileType.WAV, FileType.MP3 &#125;;  
  
        FileType[] others = &#123;&#125;;  
  
        // 图片  
        for (FileType fileType : pics) &#123;  
            if (fileType.equals(value)) &#123;  
                type = 1;  
            &#125;  
        &#125;  
        // 文档  
        for (FileType fileType : docs) &#123;  
            if (fileType.equals(value)) &#123;  
                type = 2;  
            &#125;  
        &#125;  
        // 视频  
        for (FileType fileType : videos) &#123;  
            if (fileType.equals(value)) &#123;  
                type = 3;  
            &#125;  
        &#125;  
        // 种子  
        for (FileType fileType : tottents) &#123;  
            if (fileType.equals(value)) &#123;  
                type = 4;  
            &#125;  
        &#125;  
        // 音乐  
        for (FileType fileType : audios) &#123;  
            if (fileType.equals(value)) &#123;  
                type = 5;  
            &#125;  
        &#125;  
        return type;  
    &#125;  
  
    public static void main(String args[]) throws Exception &#123;  
         System.out.println(
                 FileTypeJudge.isFileType(
                         FileTypeJudge.getType(
                                 new FileInputStream(
                                         new File(&quot;C:\\Users\\ituser1\\Desktop\\123.pptx&quot;)))));
        for (FileType type : FileType.values()) &#123;  
            System.out.print(type + &quot;\t&quot;);  
        &#125;  
    &#125;  
&#125;</code></pre>
<h3 id="文件下载"><a class="markdownIt-Anchor" href="#文件下载"></a> 文件下载</h3>
<p>方式一：</p>
<ul>
<li>使用apache.commons包中的FileUtils工具类</li>
</ul>
<pre><code class="highlight plaintext">public void downloadTemplate(HttpServletRequest request, HttpServletResponse response) &#123;
    String dataDirectory = request.getServletContext().getRealPath(&quot;/WEB-INF/download&quot;);
    String fileName = &quot;HostBatchTemplate.xlsx&quot;;
    File file = new File(dataDirectory, fileName);

    response.setCharacterEncoding(&quot;UTF-8&quot;);
    response.setContentType(&quot;application/vnd.ms-excel&quot;);
    response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot;+fileName);
    //response.setContentType(&quot;application/msexcel&quot;);//定义输出类型
    
    try(OutputStream os = response.getOutputStream()) &#123;
        byte[] bytes = FileUtils.readFileToByteArray(file);
        os.write(bytes);
        os.flush();
    &#125; catch (IOException e) &#123;
        logger.error(e.getMessage());
    &#125;
&#125;</code></pre>
<p>方式二：</p>
<pre><code class="highlight plaintext">
@RequestMapping(value = &quot;getUeditorImg/&#123;imgname&#125;/&#123;imgType&#125;&quot;, method = RequestMethod.GET)  
    public void getUeditorImg(@PathVariable String imgname, @PathVariable String imgType,  
            HttpServletResponse response) &#123;  
        if (&quot;null&quot;.equals(imgname) || &quot;null&quot;.equals(imgType) || StringUtils.isBlank(imgname)  
                || StringUtils.isNotBlank(imgType)) &#123;  
            return;  
        &#125;  
        BufferedInputStream in = null;  
        BufferedOutputStream out = null;  
        try &#123;  
            DateFormat df = new SimpleDateFormat(&quot;yyyyMMdd&quot;);  
            String timeStr = imgname.substring(0, imgname.length() - 6);  
            String dateFile = df.format(new Date(Long.parseLong(timeStr)));  
            File file = new File(UEDITOR_IMG_PATH + &quot;/&quot; + dateFile + &quot;/&quot; + imgname + &quot;.&quot; + imgType);  
            in = new BufferedInputStream(new FileInputStream(file));  
            out = new BufferedOutputStream(response.getOutputStream());  
            response.setContentType(new MimetypesFileTypeMap().getContentType(file));// 设置response内容的类型  
            response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename=&quot; + imgname + &quot;.&quot; + imgType);// 设置头部信息  
            byte[] buffer = new byte[10240];  
            int length = 0;  
            while ((length = in.read(buffer)) &gt; 0) &#123;  
                out.write(buffer, 0, length);  
            &#125;  
            out.flush();  
        &#125; catch (IOException e) &#123;  
            getLogger().error(e.getMessage(), e);  
            writeError500(response, e);  
        &#125; finally &#123;  
            try &#123;  
                if (in != null) &#123;  
                    in.close();  
                &#125;  
                if (out != null) &#123;  
                    out.close();  
                &#125;  
            &#125; catch (IOException e) &#123;  
                e.printStackTrace();  
            &#125;  
        &#125;  
    &#125;
</code></pre>
<h3 id="json数据交互"><a class="markdownIt-Anchor" href="#json数据交互"></a> JSON数据交互</h3>
<p>JSON数据格式比较简单，解析比较方便，在接口调用及html页面Ajax调用时比较常用</p>
<p><strong>JSON交互方式</strong></p>
<ul>
<li>请求时K/V，响应是JSON（推荐）</li>
<li>请求时JSON，响应是JSON</li>
</ul>
<p><strong>加入依赖</strong></p>
<pre><code class="highlight plaintext">&lt;dependency&gt;
	&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
	&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
	&lt;version&gt;2.9.6&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<h4 id="kvjson"><a class="markdownIt-Anchor" href="#kvjson"></a> kv/json</h4>
<p><strong>JSP页面</strong></p>
<pre><code class="highlight plaintext">function responseKV()&#123;
	$.ajax(&#123;
		type:&quot;post&quot;,
		url:&#x27;$&#123;pageContext.request.contextPath &#125;/responseKV&#x27;,
		//输入是key/value时，默认就指定好了contentType了，不需要再指定了
		//contentType:&#x27;application/json;charset=utf-8&#x27;,
		//data为key/value形式
		data:&#x27;name=json测试&amp;price=999&#x27;,
		success:function(data)&#123;
			alert(data);
		&#125;
	&#125;);
&#125;</code></pre>
<p><strong>controller类</strong></p>
<pre><code class="highlight plaintext">// 输入是key/value，输出是json
// @ResponseBody 将返回值转成json串响应给前台
@RequestMapping(&quot;/responseKV&quot;)
@ResponseBody
public Item responseKV(Item item) &#123;
	return item;
&#125;</code></pre>
<h4 id="jsonjson"><a class="markdownIt-Anchor" href="#jsonjson"></a> json/json</h4>
<p><strong>jsp页面</strong></p>
<pre><code class="highlight plaintext">function requestJson()&#123;
	$.ajax(&#123;
		type:&quot;post&quot;,
		url:&#x27;$&#123;pageContext.request.contextPath &#125;/requestJson&#x27;,
		//输入是json是 ，需要指定contentType为application/json
		contentType:&#x27;application/json;charset=utf-8&#x27;,
		data:&#x27;&#123;&quot;name&quot;:&quot;json测试&quot;,&quot;price&quot;:999&#125;&#x27;,
		success:function(data)&#123;
			alert(data.name);
		&#125;
	&#125;);
&#125;</code></pre>
<p><strong>controller类</strong></p>
<p>@RequestBody的作用是将返回值转成json串响应给前台</p>
<pre><code class="highlight plaintext">@Controller
public class JsonController &#123;

	// 输入是json，输出是json
	// @RequestBody 将请求的json串转成java对象
	// @ResponseBody 将返回值转成json串响应给前台
	@RequestMapping(&quot;/requestJson&quot;)
    @ResponseBody
	public Item requestJson(@RequestBody Item item) &#123;

		return item;
	&#125;
&#125;</code></pre>
<h3 id="mock测试模拟测试"><a class="markdownIt-Anchor" href="#mock测试模拟测试"></a> Mock测试（模拟测试）</h3>
<p>在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个<strong>虚拟的对象</strong>来创建以便测试的测试方法，就是<strong>mock测试</strong></p>
<blockquote>
<p>Servlet、Request、Response等Servlet API相关对象本来是由Servlet容器（tomcat）创建的</p>
</blockquote>
<p>这个虚拟的对象就是mock对象，mock对象就是真实对象在调试期间的代替品</p>
<h4 id="mock各模块介绍"><a class="markdownIt-Anchor" href="#mock各模块介绍"></a> Mock各模块介绍</h4>
<p>基于RESTful风格的springMVC的测试，我们可以测试完整的springMVC流程，即从<strong>URL请求到控制器处理，在到视图渲染都可以测试</strong></p>
<p><strong>MockMVCBuilder</strong></p>
<ul>
<li>MockMVCBuilder是用来构造MockMVC的构造器</li>
<li>其主要有两个实现：StandaloneMockMvcBuilder和DefaultMockMvcBuilder，分别对应之前的两种测试方式。</li>
<li>对于我们来说直接使用静态工厂MockMvcBuilders创建即可</li>
</ul>
<p><strong>MockMVCBuilders</strong></p>
<ul>
<li>负责创建MockMVCBuilder对象</li>
<li>两种创建方式
<ul>
<li><code>standaloneSetup(Object... controllers)</code>:通过参数指定一组控制器，这样就不需要从上下文获取了</li>
<li><code>webAppContextSetup(WebApplicationContext wac)</code>：指定WebApplicationContext，将会从该上下文获取相应的控制器并得到相应的MockMvc</li>
</ul>
</li>
</ul>
<p><strong>MockMVC</strong></p>
<ul>
<li>对于服务端的spring MVC测试支持主入口点</li>
<li>通过MockMVCBuilder构造</li>
<li>MockMVCBuilder由MockMVCBuilders建造者的静态方法去构建</li>
<li>核心方法：
<ul>
<li>perform(RequestBuilder rb) ：执行一个RequestBuilder请求，会自动执行SpringMVC的流程并映射到相应的控制器执行处理，该方法的返回值是一个ResultActions；</li>
<li>ResultActions
<ul>
<li>andExpect()：添加ResultMatcher验证规则，验证控制器执行完成后结果是否正确；</li>
<li>andDo()：添加ResultHandler结果处理器，比如调试时打印结果到控制台；</li>
<li>andReturn()：最后返回相应的MvcResult；然后进行自定义验证/进行下一步的异步处理；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>MockMvcRequestBuilders</strong></p>
<ul>
<li>用来构建请求的</li>
<li>其主要有两个子类MockHttpServletRequestBuilder和MockMultipartHttpServletRequestBuilder（如文件上传使用），即用来Mock客户端请求需要的所有数据。</li>
</ul>
<p><strong>MockMvcResultMatchers</strong></p>
<ul>
<li>用来匹配执行完请求后的<strong>结果验证</strong></li>
<li>如果匹配失败将抛出相应的异常</li>
<li>包含了很多验证API方法</li>
</ul>
<p><strong>MockMvcResultHandlers</strong></p>
<ul>
<li>结果处理器，表示要对结果做点什么事情</li>
<li>比如此处使用MockMvcResultHandlers.print()输出整个响应结果信息。<br />
<strong>MvcResult</strong></li>
<li>单元测试执行结果，可以针对执行结果进行<strong>自定义验证逻辑。</strong></li>
</ul>
<h4 id="mockmvc使用"><a class="markdownIt-Anchor" href="#mockmvc使用"></a> MockMVC使用</h4>
<p><strong>maven依赖</strong></p>
<pre><code class="highlight plaintext">&lt;!-- spring 单元测试组件包 --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.springframework&lt;/groupId&gt;
	&lt;artifactId&gt;spring-test&lt;/artifactId&gt;
	&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- 单元测试Junit --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;junit&lt;/groupId&gt;
	&lt;artifactId&gt;junit&lt;/artifactId&gt;
	&lt;version&gt;4.12&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Mock测试使用的json-path依赖 --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;com.jayway.jsonpath&lt;/groupId&gt;
	&lt;artifactId&gt;json-path&lt;/artifactId&gt;
	&lt;version&gt;2.2.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<p><strong>测试类</strong></p>
<ul>
<li>@WebAppConfiguration：用于声明一个ApplicationContext集成测试加载WebApplicationContext</li>
</ul>
<pre><code class="highlight plaintext">import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
import org.springframework.test.web.servlet.result.MockMvcResultHandlers;
import org.springframework.test.web.servlet.result.MockMvcResultMatchers;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;
//@WebAppConfiguration：可以在单元测试的时候，不用启动Servlet容器，就可以获取一个Web应用上下文

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &quot;classpath:spring/*.xml&quot;)
@WebAppConfiguration
public class TestMockMVC &#123;

	@Autowired
	private WebApplicationContext wac;

	private MockMvc mockMvc;

	@Before
	public void setup() &#123;
		// 初始化一个MockMVC对象的方式有两种：单独设置、web应用上下文设置
		// 建议使用Web应用上下文设置
		mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();
	&#125;

	@Test
	public void test() throws Exception &#123;
		// 通过perform去发送一个HTTP请求
		// andExpect：通过该方法，判断请求执行是否成功
		// andDo :对请求之后的结果进行输出
		MvcResult result = mockMvc.perform(MockMvcRequestBuilders.get(&quot;/item/showEdit&quot;).param(&quot;id&quot;, &quot;1&quot;))
				.andExpect(MockMvcResultMatchers.view().name(&quot;item/item-edit&quot;))
				.andExpect(MockMvcResultMatchers.status().isOk())
				.andDo(MockMvcResultHandlers.print())
				.andReturn();
		
		System.out.println(&quot;================================&quot;);
		System.out.println(result.getHandler());
	&#125;
	
	@Test
	public void test2() throws Exception &#123;
		// 通过perform去发送一个HTTP请求
		// andExpect：通过该方法，判断请求执行是否成功
		// andDo :对请求之后的结果进行输出
		MvcResult result = mockMvc.perform(get(&quot;/item/findItem&quot;).param(&quot;id&quot;, &quot;1&quot;).accept(MediaType.APPLICATION_JSON))
				.andExpect(status().isOk())
				.andExpect(content().contentTypeCompatibleWith(MediaType.APPLICATION_JSON))
				.andExpect(jsonPath(&quot;$.id&quot;).value(1))
				.andExpect(jsonPath(&quot;$.name&quot;).value(&quot;台式机123&quot;))
				.andDo(print())
				.andReturn();
		
		System.out.println(&quot;================================&quot;);
		System.out.println(result.getHandler());
	&#125;
&#125;
</code></pre>
<h3 id="restful支持"><a class="markdownIt-Anchor" href="#restful支持"></a> RESTful支持</h3>
<h4 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h4>
<p><strong>什么是REST</strong></p>
<p>REST（英文：Representational State Transfer，简称 REST，意思是：（资源）<strong>表述性状态转化</strong>）描述了一个架构样式的网络系统， 比如 web 应用程序。</p>
<p>它是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于<strong>客户端和服务器</strong>交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<p>它本身并没有什么实用性，其核心价值在于如何设计出符合 REST 风格的网络接口</p>
<p><strong>什么是RESTful</strong></p>
<p>REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful</p>
<p><strong>RESTful的特性</strong></p>
<ul>
<li><strong>资源</strong>（Resources）：网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个 URI（统一资源定位符）指向它，每种资源对应一个特定的 URI 。要获取这个资源，访问它的 URI 就可以，因此 URI 即为每一个资源的独一无二的识别符。</li>
<li><strong>表现层</strong>（Representation）：把资源具体呈现出来的形式，叫做它的表现层<br />
（Representation）。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式。</li>
<li><strong>状态转化</strong>（State Transfer）：每发出一个请求，就代表了客户端和服务器的一次交互过程。HTTP协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器， 必须通过某种手段，让服务器端发生“状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是 “ 表现层状态转化” 。具体说， 就是 HTTP 协议里面，四个表示操作方式的动词：GET 、POST 、PUT 、DELETE 。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源</li>
</ul>
<p><strong>如何设计RESTful应用程序的API</strong></p>
<ul>
<li><strong>路径设计</strong>：数据库设计完毕之后，基本上就可以确定有哪些资源要进行操作，相对于的路径也可以设计出来</li>
<li><strong>动词设计</strong>：也就是针对资源的具体操作类型，由HTTP动词表示，常用的HTTP动词如下：POST、DELETE、PUT、GET</li>
</ul>
<p><strong>RESTful的示例</strong></p>
<pre><code class="highlight plaintext">/account/1  HTTP GET ：   得到 id = 1 的 account
/account/1  HTTP DELETE： 删除 id = 1 的 account
/account/1  HTTP PUT：    更新 id = 1 的 account</code></pre>
<h4 id="springmvc对restful的支持"><a class="markdownIt-Anchor" href="#springmvc对restful的支持"></a> springMVC对RESTful的支持</h4>
<p><strong>@PathVariable</strong></p>
<ul>
<li><strong>URL-PATTERN</strong> ：设置为/，方便拦截RESTful 请求。</li>
<li>@<strong>PathVariable</strong>：可以解析出来URL中的模板变量（{id}）</li>
</ul>
<pre><code class="highlight plaintext">URL:	http://localhost:8080/ssm/item/1/zhangsan

Controller:
	@RequestMapping(“&#123;id&#125;/&#123;name&#125;”)
	@ResponseBody
	public Item queryItemById(@PathVariable Integer id, @PathVariable String name)</code></pre>
<hr />
<p><strong>使用@PathVariable接收数组</strong></p>
<pre><code class="highlight plaintext">http://127.0.0.1:8088/years/1,2,3/districtId/1</code></pre>
<pre><code class="highlight plaintext">@RestControllerpublic class IndexController &#123;

    @RequestMapping(&quot;/years/&#123;years&#125;/districtId/&#123;districtId&#125;&quot;)
    public String testMethod(@PathVariable String[] years, @PathVariable int districtId) &#123;
        String myStr = &quot;&quot;;
        for (String temp : years) &#123;
            myStr += temp;
        &#125;
        return &quot;Years is :&quot; + myStr + &quot;&lt;br&gt; districtId is :&quot; + districtId;
    &#125;&#125;</code></pre>
<hr />
<p><strong>RESTful的CRUD</strong></p>
<ul>
<li>@<strong>RequestMapping</strong>：通过设置method属性的CRUD，可以将同一个URL映射到不同的HandlerMethod方法上</li>
<li>@<strong>GetMapping</strong>、@<strong>PostMapping</strong>、@<strong>PutMapping</strong>、@<strong>DeleteMapping</strong>注解等价@RequestMapping注解的method属性设置</li>
</ul>
<p><strong>RESTful的资源表述</strong></p>
<ul>
<li>RESTful服务中一个重要的特性就是<strong>一种资源可以有多种表现形式</strong>，在SpringMVC中可以使用<strong>ContentNegotiatingManager</strong>这个<strong>内容协商管理器</strong>来实现这种方式。</li>
<li>内容协商的方式有三种：
<ul>
<li><strong>扩展名</strong>,比如.json表示我要JSON格式数据、.xml表示我要XML格式数据</li>
<li><strong>请求参数</strong>：默认是”format”</li>
<li><strong>请求头设置Accept参数</strong>，比如设置Accept为application/json表示要JSON格式数据</li>
</ul>
</li>
<li>不过现在RESTful响应的数据一般都是<strong>JSON格式</strong>，所以一般也不使用内容协商管理器，直接使用**@ResponseBody**注解将数据按照JSON格式返回</li>
</ul>
<h4 id="静态资源访问mvcresources"><a class="markdownIt-Anchor" href="#静态资源访问mvcresources"></a> 静态资源访问<code>&lt;mvc:resources&gt;</code></h4>
<p>以前页面可以显示图片是通过servlet跳转到jsp，jsp访问的本地图片，通过配置<a href="">mvc:resources</a>可以直接通过url方法服务器的图片</p>
<p><strong>如果在DispatcherServlet中设置url-pattern为/则必须对静态资源进行访问处理</strong></p>
<p>在springmvc.xml文件中，使用mvc:resources标签，具体如下：</p>
<pre><code class="highlight plaintext">&lt;!--配置静态资源chu&#x27;li--&gt;
&lt;!--location：本地资源路径--&gt;
&lt;!--mapping：拦截到的网路资源路径--&gt;
&lt;!-- 当DispatcherServlet配置为/来拦截请求的时候，需要配置静态资源的访问映射 --&gt;
&lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot;/&gt;
&lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot;/&gt;
&lt;mvc:resources location=&quot;/img/&quot; mapping=&quot;/img/**&quot;/&gt;</code></pre>
<p>Springmvc会把mapping映射到ResourceHttpRequestHandler，这样静态资源在经过DispatcherServlet转发时就可以找到对应的Handler了</p>
<h3 id="springmvc父子容器"><a class="markdownIt-Anchor" href="#springmvc父子容器"></a> SpringMVC父子容器</h3>
<p>springMVC。xml是通过子容器DispatcherServlet加载的，所以为子容器，父容器为ApplicationContext</p>
<h3 id="跨域处理"><a class="markdownIt-Anchor" href="#跨域处理"></a> 跨域处理</h3>
<p>由于浏览器对于Javascript的<strong>同源策略</strong>的限制，导致A网站不能通过JS（主要就是Ajax请求）去访问B网站的数据，于是跨域问题就出现了。</p>
<p>跨域指的是<strong>域名、端口、协议</strong>的组合不同就是跨域。</p>
<pre><code class="highlight plaintext">http://www.kkb.com/
https://www.kkb.com
http://www.kkb.cn
http://www.kkb.com:8080/</code></pre>
<p><strong>为什么要有同源策略？</strong></p>
<p>我们举例说明：比如一个黑客程序，他利用IFrame把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了</p>
<h4 id="cors"><a class="markdownIt-Anchor" href="#cors"></a> CORS</h4>
<p>CORS是一个<strong>W3C</strong>标准，全称是&quot;<strong>跨域资源共享</strong>&quot;（Cross-origin resource</p>
<p>sharing）。</p>
<p>它允许浏览器向跨源服务器，发出<strong>XMLHttpRequest</strong>请求，从而克服了AJAX只能同源使用的限制。</p>
<p>CORS需要<strong>浏览器和服务器同时支持</strong>。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<p>CORS原理：只需要向响应头header中注入<strong>Access-Control-Allow-Origin</strong>，这样浏览器检测到header中的Access-Control-Allow-Origin，则就可以跨域操作了</p>
<h4 id="cors请求分类"><a class="markdownIt-Anchor" href="#cors请求分类"></a> CORS请求分类</h4>
<p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）</p>
<p>只要同时满足以下两大条件，就属于<strong>简单请求</strong></p>
<p>凡是不同时满足上面两个条件，就属于<strong>非简单请求</strong>。</p>
<p>浏览器对这两种请求的处理，是不一样的</p>
<h5 id="简单请求"><a class="markdownIt-Anchor" href="#简单请求"></a> 简单请求</h5>
<p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<strong>Origin</strong>字段</p>
<p><strong>请求信息</strong></p>
<p><strong>响应信息</strong></p>
<p><strong>字段说明</strong></p>
<ul>
<li>Access-Control-Allow-Origin
<ul>
<li>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</li>
</ul>
</li>
<li>Access-Control-Allow-Credentials
<ul>
<li>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可</li>
</ul>
</li>
</ul>
<h5 id="非简单请求"><a class="markdownIt-Anchor" href="#非简单请求"></a> 非简单请求</h5>
<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p>
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;<strong>预检</strong>&quot;请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错</p>
<p><strong>请求信息</strong></p>
<p>HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。</p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个&quot;预检&quot;请求，要求服务器确认可以这样请求。下面是这个&quot;预检&quot;请求的HTTP头信息</p>
<p>&quot;预检&quot;请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。</p>
<p>除了Origin字段，&quot;预检&quot;请求的头信息包括两个特殊字段。</p>
<ul>
<li><strong>Access-Control-Request-Method</strong><br />
该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</li>
<li><strong>Access-Control-Request-Headers</strong><br />
该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header</li>
</ul>
<blockquote>
<p><strong>一旦服务器通过了&quot;预检&quot;请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样</strong>，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段</p>
</blockquote>
<h4 id="cors实现"><a class="markdownIt-Anchor" href="#cors实现"></a> CORS实现</h4>
<p>使用<strong>springmvc的拦截器</strong>实现</p>
<h5 id="跨域提交cookie"><a class="markdownIt-Anchor" href="#跨域提交cookie"></a> 跨域提交Cookie</h5>
<pre><code class="highlight plaintext">public class AllowOriginInterceptor implements HandlerInterceptor &#123;
 
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object arg2) throws Exception &#123;
       // 有跨域行为时参考网址 http://namezhou.iteye.com/blog/2384434
       if (request.getHeader(&quot;Origin&quot;) != null) &#123;
           response.setContentType(&quot;text/html;charset=UTF-8&quot;);
           // 允许哪一个URL
          response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);
           // 允许那种请求方法
          response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE&quot;);
          response.setHeader(&quot;XDomainRequestAllowed&quot;, &quot;1&quot;);
           System.out.println(&quot;正在跨域&quot;);
       &#125;
       return true;
    &#125;
 &#125;</code></pre>
<blockquote>
<p>然后配置拦截器</p>
</blockquote>
<h5 id="跨域提交cookie-2"><a class="markdownIt-Anchor" href="#跨域提交cookie-2"></a> 跨域提交Cookie</h5>
<p><strong>注意事项</strong></p>
<ul>
<li><strong>Access-Control-Allow-Credentials</strong> 为 <strong>true</strong>的时候，Access-Control-Allow-Origin一定不能设置为”* ”，否则<strong>报错</strong></li>
<li>如果有多个拦截器，一定要把处理跨域请求的拦截器放到<strong>首位</strong></li>
</ul>
<p><strong>js代码</strong></p>
<ul>
<li>jquery Ajax</li>
</ul>
<pre><code class="highlight plaintext">$.ajax(&#123;
url: &#x27;自己要请求的url&#x27;,
method:&#x27;请求方式&#x27;,  //GET POST PUT DELETE
xhrFields:&#123;withCredentials:true&#125;,
success:function(data)&#123;
   //自定义请求成功做什么
&#125;,
error:function()&#123;
//自定义请求失败做什么
&#125;
&#125;)</code></pre>
<ul>
<li>angular JS</li>
</ul>
<pre><code class="highlight plaintext">
1. 全局 在模块配置中添加
app.config([&#x27;$httpProvider&#x27;,function($httpProvider) &#123; 
  $httpProvider.defaults.withCredentials = true; 
&#125; 
]);

2. 单个请求
$http.get(url, &#123;withCredentials: true&#125;);
$http.post(url,data, &#123;withCredentials: true&#125;);
		$httpProvider.defaults.withCredentials = true;</code></pre>
<p><strong>java代码</strong></p>
<pre><code class="highlight plaintext">public class AllowOriginInterceptor implements HandlerInterceptor &#123;
 
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object arg2) throws Exception &#123;
       // 有跨域行为时参考网址 http://namezhou.iteye.com/blog/2384434
       if (request.getHeader(&quot;Origin&quot;) != null) &#123;
           response.setContentType(&quot;text/html;charset=UTF-8&quot;);
           // 允许哪一个URL 访问 request.getHeader(&quot;Origin&quot;) 根据请求来的url动态允许
          response.setHeader(&quot;Access-Control-Allow-Origin&quot;, request.getHeader(&quot;Origin&quot;));
           // 允许那种请求方法
          response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE,HEAD&quot;);
           response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;0&quot;);
           // 允许请求头里的参数列表
           response.setHeader(&quot;Access-Control-Allow-Headers&quot;,
                  &quot;Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With,userId,token&quot;);
           // 允许对方带cookie访问
     response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);
          response.setHeader(&quot;XDomainRequestAllowed&quot;, &quot;1&quot;);
           System.out.println(&quot;正在跨域&quot;);
       &#125;
       return true;
    &#125;
&#125;</code></pre>
<h3 id="pathvariable和requestparam的区别"><a class="markdownIt-Anchor" href="#pathvariable和requestparam的区别"></a> @PathVariable和@RequestParam的区别</h3>
<p><strong>用法上的不同</strong>：从名字上可以看出来，PathVariable只能用于接收url路径上的参数，而RequestParam只能用于接收请求带的params</p>
<p>看下面一个例子：</p>
<pre><code class="highlight plaintext">package com.lrm.springbootdemo.web;

import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping(&quot;/api/v1&quot;)
public class HelloController &#123;

    @GetMapping(&quot;/books/&#123;username&#125;&quot;)
    public Object testPathVariable(@PathVariable String username)&#123;
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;username&quot;,username);
        return map;
    &#125;

    @PostMapping(&quot;/books2&quot;)
    public Object testRequestParam(@RequestParam(&quot;name&quot;) String name,
                       @RequestParam(&quot;author&quot;) String author,
                       @RequestParam(&quot;isbn&quot;) String isbn) &#123;
        Map&lt;String, Object&gt; book = new HashMap&lt;String, Object&gt;();
        book.put(&quot;name&quot;, name);
        book.put(&quot;author&quot;, author);
        book.put(&quot;isbn&quot;, isbn);
        return book;
    &#125;

    @PostMapping(&quot;/books2/&#123;id&#125;&quot;)
    public Object test(@PathVariable(&quot;id&quot;) long id,@RequestParam(&quot;name&quot;) String name,
                       @RequestParam(&quot;author&quot;) String author,
                       @RequestParam(&quot;isbn&quot;) String isbn) &#123;
        Map&lt;String, Object&gt; book = new HashMap&lt;String, Object&gt;();
        book.put(&quot;id&quot;,id);
        book.put(&quot;name&quot;, name);
        book.put(&quot;author&quot;, author);
        book.put(&quot;isbn&quot;, isbn);
        return book;
    &#125;
&#125;</code></pre>
<p>其中testPathVariable这个方法中的username参数只能使用@PathVariable来接收，因为username参数是url的path上携带的参数。username是无法使用RequestParam来接受的。</p>
<p>testRequestParam这个方法只能用于</p>
<pre><code class="highlight plaintext">localhost:8080/api/v1/books2/12?name=java in action&amp;author=ric&amp;isbn=dsdas2334</code></pre>
<p>这种模式的请求，因为RequestParam只能用于接收请求上带的params，testPathVariable是无法接收上面的name、author、isbn参数的。</p>
<p><strong>内部参数不同</strong></p>
<p>PathVariable有value，name，required这三个参数，而RequestParam也有这三个参数，并且比PathVariable多一个参数defaultValue（该参数用于当请求体中不包含对应的参数变量时，参数变量使用defaultValue指定的默认值）</p>
<p><strong>PathVariable一般用于get和delete请求，RequestParam一般用于post请求</strong></p>
</main>

</article>


<script src="/js/highlight.js"></script>

  </main>
  <footer class="footer">
  
  <span>Copyright © 2026 Lism Blog | lisisism@qq.com</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>