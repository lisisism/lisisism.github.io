<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    Redis 丨
    

    Lism Blog
  </title>

  
  <link rel="shortcut icon" href="/icon.svg">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="/Lism Blog" type="application/atom+xml">
</head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">/Lism Blog</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <article class="post">
  
  <div class="post-title">Redis</div>
  <div class="post-meta">
    <div class="date">2023 一月 4日</div>
    <div class="tags">
      
      <div class="tag-item">Redis</div>
      
    </div>
  </div>
  

  <main class="post-content"><h1 id="redis"><a class="markdownIt-Anchor" href="#redis"></a> Redis</h1>
<p>[toc]</p>
<h2 id="redis下载安装"><a class="markdownIt-Anchor" href="#redis下载安装"></a> Redis下载安装</h2>
<h3 id="什么是redis"><a class="markdownIt-Anchor" href="#什么是redis"></a> 什么是Redis</h3>
<ul>
<li><strong>Redis</strong>是一个开源的使用ANSI <strong>C语言</strong>编写、支持网络、可基于内存亦可持久化的日志型、<strong>Key-Value</strong> <strong>内存数据库</strong></li>
<li>它提供了<strong>五种数据类型</strong>来存储，<strong>字符串类型，散列类型，列表类型，集合类型，有序集合类型</strong></li>
<li>换句话说，Redis就像是一个HashMap，不过不是在JVM中运行，而是以一个独立进程的形式运行。</li>
<li>一般说来，会被当作缓存使用。 因为它比数据库(mysql)快，所以常用的数据，可以考虑放在这里，这样就提高了性能。</li>
<li>redis是一种<strong>NoSQL</strong>数据库</li>
</ul>
<h3 id="什么是nosql"><a class="markdownIt-Anchor" href="#什么是nosql"></a> 什么是NoSQL?</h3>
<p>NoSQL，即Not-Only-SQL(不仅仅是SQL)，泛指非关系型的数据库</p>
<p>NoSQL数据库是为了解决<strong>高并发，高可用，高扩展，大数据存储</strong>问题而产生的数据库解决方案</p>
<p>NoSQL可以作为关系型数据库的良好补充，但是<strong>不能替代关系型数据库</strong></p>
<blockquote>
<p>关系型数据库指：数据结构是一种有行有列的数据库</p>
</blockquote>
<h3 id="nosql数据库分类"><a class="markdownIt-Anchor" href="#nosql数据库分类"></a> NoSQL数据库分类</h3>
<p><strong>key-value</strong>存储数据库</p>
<ul>
<li>相关产品：Tokyo Cabinet/Tyrant，Redis，Voldemort，Berkeley DB</li>
<li>典型应用：内容缓存，主要用于处理大量数据的高访问负载</li>
<li>数据模型：一系列键值对</li>
<li>优势：快速查询</li>
<li>劣势：存储的数据缺少结构化</li>
</ul>
<p><strong>列存储数据库</strong></p>
<ul>
<li>相关产品：Cassandra, HBase, Riak</li>
<li>典型应用：分布式的文件系统</li>
<li>数据模型：以列簇式存储，将同一列数据存在一起</li>
<li>优势：查找速度快，可扩展性强，更容易进行分布式扩展</li>
<li>劣势：功能相对局限</li>
</ul>
<p><strong>文档型数据库</strong></p>
<ul>
<li>相关产品：CouchDB、MongoDB</li>
<li>典型应用：Web应用（与Key-Value类似，Value是结构化的）</li>
<li>数据模型： 一系列键值对</li>
<li>优势：数据结构要求不严格</li>
<li>劣势：</li>
</ul>
<p><strong>图形(Graph)数据库</strong></p>
<ul>
<li>相关数据库：Neo4J、InfoGrid、Infinite Graph</li>
<li>典型应用：社交网络</li>
<li>数据模型：图结构</li>
<li>优势：利用图结构相关算法。</li>
<li>劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案</li>
</ul>
<h3 id="redis的应用场景"><a class="markdownIt-Anchor" href="#redis的应用场景"></a> Redis的应用场景</h3>
<ul>
<li>
<p>内存数据库（登录信息、购物车信息、用户浏览记录等）</p>
</li>
<li>
<p>缓存服务器（商品数据、广告数据等等）。（最多使用）</p>
</li>
<li>
<p>解决分布式集群架构中的session分离问题（session共享）。</p>
</li>
<li>
<p>任务队列。（秒杀、抢购、12306等等）</p>
</li>
<li>
<p>支持发布订阅的消息模式</p>
</li>
<li>
<p>应用排行榜。</p>
</li>
<li>
<p>网站访问统计。</p>
</li>
<li>
<p>数据过期处理（可以精确到毫秒）</p>
</li>
</ul>
<h2 id="redis运行"><a class="markdownIt-Anchor" href="#redis运行"></a> Redis运行</h2>
<h3 id="windows版本"><a class="markdownIt-Anchor" href="#windows版本"></a> Windows版本</h3>
<h4 id="下载安装"><a class="markdownIt-Anchor" href="#下载安装"></a> 下载安装</h4>
<p>下载Redis Windows版本解压即可</p>
<h4 id="运行服务端"><a class="markdownIt-Anchor" href="#运行服务端"></a> 运行服务端</h4>
<ul>
<li>通过cmd运行命令行</li>
</ul>
<pre><code class="highlight plaintext">d:
cd software
cd D:\software\redis-64.3.0.503
redis-server.exe</code></pre>
<ul>
<li>这样就启动了服务端</li>
</ul>
<h4 id="运行客户端"><a class="markdownIt-Anchor" href="#运行客户端"></a> 运行客户端</h4>
<ul>
<li>cmd命令行运行</li>
</ul>
<pre><code class="highlight plaintext">d:
cd software
cd D:\software\redis-64.3.0.503
redis-cli.exe</code></pre>
<ul>
<li>可以使用如图所示的命令行访问redis服务器</li>
</ul>
<h3 id="linux版本"><a class="markdownIt-Anchor" href="#linux版本"></a> Linux版本</h3>
<h4 id="redis下载"><a class="markdownIt-Anchor" href="#redis下载"></a> Redis下载</h4>
<ul>
<li>官网地址：<u><a target="_blank" rel="noopener" href="http://redis.io/">http://redis.io/</a></u></li>
<li>中文官网地址：<u><a target="_blank" rel="noopener" href="http://www.redis.cn/">http://www.redis.cn/</a></u></li>
<li>下载地址：<u><a target="_blank" rel="noopener" href="http://download.redis.io/releases/">http://download.redis.io/releases/</a></u></li>
</ul>
<h4 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h4>
<ol>
<li>
<p>将redis-3.0.0.tar.gz包用ftp工具拷贝到服务器</p>
</li>
<li>
<p>安装c语言需要的GCC环境</p>
</li>
</ol>
<pre><code class="highlight shell">yum install gcc-c++</code></pre>
<ol start="3">
<li>解压缩Redis源码压缩包</li>
</ol>
<pre><code class="highlight linux">tar -zxf redis-3.2.9.tar.gz</code></pre>
<ol start="4">
<li>编译Redis源码，进入redis-3.0.0目录，执行编译命令</li>
</ol>
<pre><code class="highlight plaintext">mike</code></pre>
<ol start="5">
<li>安装Redis，通过PREFIX指定安装目录(在redis-3.0.0目录)</li>
</ol>
<pre><code class="highlight plaintext">make install PREFIX=/usr/local/redis</code></pre>
<h4 id="redis启动"><a class="markdownIt-Anchor" href="#redis启动"></a> Redis启动</h4>
<p><strong>前端启动</strong></p>
<p>进入redis安装目录</p>
<pre><code class="highlight plaintext">./redis-server</code></pre>
<blockquote>
<p>启动缺点：客户端窗口<code>ctrl+c</code>关闭则redis-server程序结束，不推荐使用此方法</p>
</blockquote>
<p><strong>后端启动（守护进程启动）</strong></p>
<ol>
<li>拷贝redis-3.2.9/redis.conf配置文件到Redis安装目录的bin目录</li>
</ol>
<pre><code class="highlight plaintext">cp /home/leeboer/leeftp/redis-3.0.0/redis.conf /usr/local/redis/bin/</code></pre>
<ol start="2">
<li>修改redis.conf，将daemonize由no改为yes</li>
</ol>
<pre><code class="highlight plaintext">vim redis.conf</code></pre>
<blockquote>
<p>进入vim编辑器，可以使用“/”键进行搜索</p>
</blockquote>
<ol start="3">
<li>
<p>修改redis.conf中的61行代码，<code>bind 127.0.0.1</code> 改为 <code>bind &lt;redis实例所在机器的真实IP&gt;</code></p>
<ul>
<li>这里指定了ip后，就只有指定的ip可以访问redis</li>
</ul>
</li>
<li>
<p>执行命令</p>
</li>
</ol>
<pre><code class="highlight plaintext">./redis-server redis.conf</code></pre>
<p><strong>后端启动的关闭方式</strong></p>
<p>非正常关闭</p>
<pre><code class="highlight plaintext">kill 5586</code></pre>
<p>正常关闭</p>
<pre><code class="highlight plaintext">./redis-cli shutdown</code></pre>
<p><strong>其他命令</strong></p>
<pre><code class="highlight plaintext">redis-server ：启动redis服务

redis-cli ：进入redis命令客户

redis-benchmark： 性能测试的工具

redis-check-aof ： aof文件进行检查的工具

redis-check-dump ：  rdb文件进行检查的工具

redis-sentinel ：  启动哨兵监控服务</code></pre>
<h3 id="简单运用"><a class="markdownIt-Anchor" href="#简单运用"></a> 简单运用</h3>
<ul>
<li>输入指令</li>
</ul>
<pre><code class="highlight plaintext">set hero gareen
get hero</code></pre>
<ul>
<li>如图就实现了向服务器设置hero这个键值，并从服务器获取hero对应的值</li>
</ul>
<h2 id="redis客户端"><a class="markdownIt-Anchor" href="#redis客户端"></a> Redis客户端</h2>
<h3 id="自带命令行客户端"><a class="markdownIt-Anchor" href="#自带命令行客户端"></a> 自带命令行客户端</h3>
<p><strong>命令格式</strong></p>
<ul>
<li>-h ：redis服务器的ip地址</li>
<li>-p ：redis实例的端口号</li>
</ul>
<pre><code class="highlight plaintext">./redis-cli -h 127.0.0.1 -p 6379</code></pre>
<p><strong>修改redis.conf配置文件（解决IP绑定问题）</strong></p>
<p><code>bind 127.0.0.1</code>     绑定的IP才能访问redis服务器，注释掉该配置</p>
<p><code>protected-mode yes</code>  是否开启保护模式，由yes该为no</p>
<p><strong>默认方式</strong></p>
<p>如果不指定主机和端口也可以</p>
<ul>
<li>默认主机地址是127.0.0.1</li>
<li>默认端口是6379</li>
</ul>
<pre><code class="highlight plaintext">./redis-cli</code></pre>
<h3 id="图形客户端"><a class="markdownIt-Anchor" href="#图形客户端"></a> 图形客户端</h3>
<p>前提：需要安装图形界面管理器</p>
<h4 id="关闭防火墙命令"><a class="markdownIt-Anchor" href="#关闭防火墙命令"></a> 关闭防火墙命令</h4>
<p>永久关闭</p>
<pre><code class="highlight plaintext">chkconfig iptables off/on</code></pre>
<p>本次关闭</p>
<pre><code class="highlight plaintext">service iptables stop</code></pre>
<h4 id="多数据库支持"><a class="markdownIt-Anchor" href="#多数据库支持"></a> 多数据库支持</h4>
<p>默认一共是16个数据库，每个数据库之间是相互隔离（但是可以使用flushall一次清空所有的库）。数据库的数量是在redis.conf中配置的。</p>
<p>切换数据库使用命令：select 数据库编号（0-15）</p>
<pre><code class="highlight plaintext">例如：select 1</code></pre>
<h3 id="程序客户端java"><a class="markdownIt-Anchor" href="#程序客户端java"></a> 程序客户端（java）</h3>
<p>在实际工作中却需要用到Java代码才能访问，使用第三方jar包 ：Jedis就能方便地访问Redis的各种服务了</p>
<h4 id="jedis介绍"><a class="markdownIt-Anchor" href="#jedis介绍"></a> Jedis介绍</h4>
<p>Redis不仅使用命令客户端来操作，而且可以使用<strong>程序客户端</strong>操作</p>
<p>现在基本上主流的语言都有客户端支持，比如<strong>Java</strong>、C、C#、C++、php、Node.js、Go等。</p>
<p>在官方网站里列一些Java的客户端，有<strong>Jedis</strong>、Redisson、Jredis、JDBC-Redis、等其中官方推荐使用Jedis和Redisson。</p>
<p>在<strong>企业中用的最多的就是Jedis</strong>，下面我们就重点学习下Jedis。</p>
<p>Jedis同样也是托管在github上，地址：<u><a target="_blank" rel="noopener" href="https://github.com/xetorthio/jedis">https://github.com/xetorthio/jedis</a></u></p>
<h4 id="添加jar包"><a class="markdownIt-Anchor" href="#添加jar包"></a> 添加jar包</h4>
<pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>
<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre>
<h4 id="单实例连接"><a class="markdownIt-Anchor" href="#单实例连接"></a> 单实例连接</h4>
<p>注意事项：需要去设置redis服务器的防火墙策略（临时关闭、永久关闭、端口暴露）</p>
<pre><code class="highlight java"><span class="meta">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJedis</span><span class="params">()</span> &#123;
	<span class="comment">//创建一个Jedis的连接</span>
	<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);
	<span class="comment">//执行redis命令</span>
	jedis.set(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;hello world&quot;</span>);
	<span class="comment">//从redis中取值</span>
	<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;key1&quot;</span>);
	<span class="comment">//打印结果</span>
	System.out.println(result);
	<span class="comment">//关闭连接</span>
	jedis.close();
	
&#125;</code></pre>
<blockquote>
<p>注意：使用Windows版本的redis，要保持redis 的cmd窗口一直打开，服务运行</p>
</blockquote>
<p><strong>详细使用案例</strong></p>
<pre><code class="highlight java"><span class="keyword">package</span> redis;
<span class="keyword">import</span> java.util.HashMap;
<span class="keyword">import</span> java.util.Iterator;
<span class="keyword">import</span> java.util.List;
<span class="keyword">import</span> java.util.Map;
 
<span class="keyword">import</span> org.junit.Before;
<span class="keyword">import</span> org.junit.Test;
 
<span class="keyword">import</span> redis.clients.jedis.Jedis;
<span class="keyword">import</span> redis.clients.jedis.JedisPool; 
 
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRedisManyCommands</span> &#123; 
    JedisPool pool; 
    Jedis jedis; 
    <span class="meta">@Before</span> 
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123; 
   
        jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>); 
           
    &#125; 
 
    <span class="comment">/**</span>
<span class="comment">     * Redis存储初级的字符串</span>
<span class="comment">     * CRUD</span>
<span class="comment">     */</span> 
    <span class="meta">@Test</span> 
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBasicString</span><span class="params">()</span>&#123; 
        <span class="comment">//-----添加数据---------- </span>
        jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;meepo&quot;</span>);<span class="comment">//向key--&gt;name中放入了value--&gt;meepo </span>
        System.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));<span class="comment">//执行结果：meepo </span>
 
        <span class="comment">//-----修改数据----------- </span>
        <span class="comment">//1、在原来基础上修改 </span>
        jedis.append(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;dota&quot;</span>);   <span class="comment">//很直观，类似map 将dota append到已经有的value之后 </span>
        System.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));<span class="comment">//执行结果:meepodota </span>
 
        <span class="comment">//2、直接覆盖原来的数据 </span>
        jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;poofu&quot;</span>); 
        System.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));<span class="comment">//执行结果：poofu </span>
 
        <span class="comment">//删除key对应的记录 </span>
        jedis.del(<span class="string">&quot;name&quot;</span>); 
        System.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));<span class="comment">//执行结果：null </span>
 
        <span class="comment">/**</span>
<span class="comment">         * mset相当于</span>
<span class="comment">         * jedis.set(&quot;name&quot;,&quot;meepo&quot;);</span>
<span class="comment">         * jedis.set(&quot;dota&quot;,&quot;poofu&quot;);</span>
<span class="comment">         */</span> 
        jedis.mset(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;meepo&quot;</span>,<span class="string">&quot;dota&quot;</span>,<span class="string">&quot;poofu&quot;</span>); 
        System.out.println(jedis.mget(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;dota&quot;</span>)); 
 
    &#125; 
 
    <span class="comment">/**</span>
<span class="comment">     * jedis操作Map</span>
<span class="comment">     */</span> 
    <span class="meta">@Test</span> 
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMap</span><span class="params">()</span>&#123; 
        Map&lt;String,String&gt; user=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;(); 
        user.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;meepo&quot;</span>); 
        user.put(<span class="string">&quot;pwd&quot;</span>,<span class="string">&quot;password&quot;</span>); 
        jedis.hmset(<span class="string">&quot;user&quot;</span>,user); 
        <span class="comment">//取出user中的name，执行结果:[meepo]--&gt;注意结果是一个泛型的List </span>
        <span class="comment">//第一个参数是存入redis中map对象的key，后面跟的是放入map中的对象的key，后面的key可以跟多个，是可变参数 </span>
        List&lt;String&gt; rsmap = jedis.hmget(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;name&quot;</span>); 
        System.out.println(rsmap); 
 
        <span class="comment">//删除map中的某个键值 </span>
<span class="comment">//        jedis.hdel(&quot;user&quot;,&quot;pwd&quot;); </span>
        System.out.println(jedis.hmget(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;pwd&quot;</span>)); <span class="comment">//因为删除了，所以返回的是null </span>
        System.out.println(jedis.hlen(<span class="string">&quot;user&quot;</span>)); <span class="comment">//返回key为user的键中存放的值的个数1 </span>
        System.out.println(jedis.exists(<span class="string">&quot;user&quot;</span>));<span class="comment">//是否存在key为user的记录 返回true </span>
        System.out.println(jedis.hkeys(<span class="string">&quot;user&quot;</span>));<span class="comment">//返回map对象中的所有key  [pwd, name] </span>
        System.out.println(jedis.hvals(<span class="string">&quot;user&quot;</span>));<span class="comment">//返回map对象中的所有value  [meepo, password] </span>
 
        Iterator&lt;String&gt; iter=jedis.hkeys(<span class="string">&quot;user&quot;</span>).iterator(); 
        <span class="keyword">while</span> (iter.hasNext())&#123; 
            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> iter.next(); 
            System.out.println(key+<span class="string">&quot;:&quot;</span>+jedis.hmget(<span class="string">&quot;user&quot;</span>,key)); 
        &#125; 
 
    &#125; 
 
    <span class="comment">/**</span>
<span class="comment">     * jedis操作List</span>
<span class="comment">     */</span> 
    <span class="meta">@Test</span> 
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123; 
        <span class="comment">//开始前，先移除所有的内容 </span>
        jedis.del(<span class="string">&quot;java framework&quot;</span>); 
        <span class="comment">// 第一个是key，第二个是起始位置，第三个是结束位置，jedis.llen获取长度 -1表示取得所有</span>
        System.out.println(jedis.lrange(<span class="string">&quot;java framework&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>)); 
       <span class="comment">//先向key java framework中存放三条数据 </span>
       jedis.lpush(<span class="string">&quot;java framework&quot;</span>,<span class="string">&quot;spring&quot;</span>); 
       jedis.lpush(<span class="string">&quot;java framework&quot;</span>,<span class="string">&quot;struts&quot;</span>); 
       jedis.lpush(<span class="string">&quot;java framework&quot;</span>,<span class="string">&quot;hibernate&quot;</span>); 
       <span class="comment">//再取出所有数据jedis.lrange是按范围取出， </span>
       <span class="comment">// 第一个是key，第二个是起始位置，第三个是结束位置，jedis.llen获取长度 -1表示取得所有 </span>
       System.out.println(jedis.lrange(<span class="string">&quot;java framework&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>)); 
    &#125; 
 
    <span class="comment">/**</span>
<span class="comment">     * jedis操作Set</span>
<span class="comment">     */</span> 
    <span class="meta">@Test</span> 
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span>&#123; 
        <span class="comment">//添加 </span>
        jedis.sadd(<span class="string">&quot;sname&quot;</span>,<span class="string">&quot;meepo&quot;</span>); 
        jedis.sadd(<span class="string">&quot;sname&quot;</span>,<span class="string">&quot;dota&quot;</span>); 
        jedis.sadd(<span class="string">&quot;sname&quot;</span>,<span class="string">&quot;poofu&quot;</span>); 
        jedis.sadd(<span class="string">&quot;sname&quot;</span>,<span class="string">&quot;noname&quot;</span>);
        <span class="comment">//移除noname </span>
        jedis.srem(<span class="string">&quot;sname&quot;</span>,<span class="string">&quot;noname&quot;</span>); 
        System.out.println(jedis.smembers(<span class="string">&quot;sname&quot;</span>));<span class="comment">//获取所有加入的value </span>
        System.out.println(jedis.sismember(<span class="string">&quot;sname&quot;</span>, <span class="string">&quot;meepo&quot;</span>));<span class="comment">//判断 meepo 是否是sname集合的元素 </span>
        System.out.println(jedis.srandmember(<span class="string">&quot;sname&quot;</span>)); 
        System.out.println(jedis.scard(<span class="string">&quot;sname&quot;</span>));<span class="comment">//返回集合的元素个数 </span>
    &#125; 
 
    <span class="meta">@Test</span> 
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123; 
        <span class="comment">//keys中传入的可以用通配符 </span>
        System.out.println(jedis.keys(<span class="string">&quot;*&quot;</span>)); <span class="comment">//返回当前库中所有的key  [sose, sanme, name, dota, foo, sname, java framework, user, braand] </span>
        System.out.println(jedis.keys(<span class="string">&quot;*name&quot;</span>));<span class="comment">//返回的sname   [sname, name] </span>
        System.out.println(jedis.del(<span class="string">&quot;sanmdde&quot;</span>));<span class="comment">//删除key为sanmdde的对象  删除成功返回1 删除失败（或者不存在）返回 0 </span>
        System.out.println(jedis.ttl(<span class="string">&quot;sname&quot;</span>));<span class="comment">//返回给定key的有效时间，如果是-1则表示永远有效 </span>
        jedis.setex(<span class="string">&quot;timekey&quot;</span>, <span class="number">10</span>, <span class="string">&quot;min&quot;</span>);<span class="comment">//通过此方法，可以指定key的存活（有效时间） 时间为秒 </span>
        Thread.sleep(<span class="number">5000</span>);<span class="comment">//睡眠5秒后，剩余时间将为&lt;=5 </span>
        System.out.println(jedis.ttl(<span class="string">&quot;timekey&quot;</span>));   <span class="comment">//输出结果为5 </span>
        jedis.setex(<span class="string">&quot;timekey&quot;</span>, <span class="number">1</span>, <span class="string">&quot;min&quot;</span>);        <span class="comment">//设为1后，下面再看剩余时间就是1了 </span>
        System.out.println(jedis.ttl(<span class="string">&quot;timekey&quot;</span>));  <span class="comment">//输出结果为1 </span>
        System.out.println(jedis.exists(<span class="string">&quot;key&quot;</span>));<span class="comment">//检查key是否存在 </span>
        System.out.println(jedis.rename(<span class="string">&quot;timekey&quot;</span>,<span class="string">&quot;time&quot;</span>)); 
        System.out.println(jedis.get(<span class="string">&quot;timekey&quot;</span>));<span class="comment">//因为移除，返回为null </span>
        System.out.println(jedis.get(<span class="string">&quot;time&quot;</span>)); <span class="comment">//因为将timekey 重命名为time 所以可以取得值 min </span>
 
        <span class="comment">//jedis 排序 </span>
        <span class="comment">//注意，此处的rpush和lpush是List的操作。是一个双向链表（但从表现来看的） </span>
        jedis.del(<span class="string">&quot;a&quot;</span>);<span class="comment">//先清除数据，再加入数据进行测试 </span>
        jedis.rpush(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;1&quot;</span>); 
        jedis.lpush(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;6&quot;</span>); 
        jedis.lpush(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;3&quot;</span>); 
        jedis.lpush(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;9&quot;</span>); 
        System.out.println(jedis.lrange(<span class="string">&quot;a&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));<span class="comment">// [9, 3, 6, 1] </span>
        System.out.println(jedis.sort(<span class="string">&quot;a&quot;</span>)); <span class="comment">//[1, 3, 6, 9]  //输入排序后结果 </span>
        System.out.println(jedis.lrange(<span class="string">&quot;a&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>)); 
 
    &#125; 
&#125;</code></pre>
<h4 id="连接池连接"><a class="markdownIt-Anchor" href="#连接池连接"></a> 连接池连接</h4>
<pre><code class="highlight java"><span class="meta">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJedisPool</span><span class="params">()</span> &#123;
	<span class="comment">//创建一连接池对象</span>
	<span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);
	<span class="comment">//从连接池中获得连接</span>
	<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource();
	<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;key1&quot;</span>) ;
	System.out.println(result);
	<span class="comment">//关闭连接</span>
	jedis.close();
	
	<span class="comment">//关闭连接池</span>
	jedisPool.close();
&#125;</code></pre>
<h4 id="spring整合jedispool"><a class="markdownIt-Anchor" href="#spring整合jedispool"></a> Spring整合JedisPool</h4>
<p>添加spring和jedis相关jar包的jar包</p>
<p><strong>配置spring配置文件</strong></p>
<pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span>
<span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span>
<span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span>
<span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span>
<span class="tag">	<span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span>
<span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span>
<span class="string"><span class="tag">		http://www.springframework.org/schema/beans/spring-beans.xsd </span></span>
<span class="string"><span class="tag">		http://www.springframework.org/schema/mvc </span></span>
<span class="string"><span class="tag">		http://www.springframework.org/schema/mvc/spring-mvc.xsd </span></span>
<span class="string"><span class="tag">		http://www.springframework.org/schema/context </span></span>
<span class="string"><span class="tag">		http://www.springframework.org/schema/context/spring-context.xsd </span></span>
<span class="string"><span class="tag">		http://www.springframework.org/schema/aop </span></span>
<span class="string"><span class="tag">		http://www.springframework.org/schema/aop/spring-aop.xsd </span></span>
<span class="string"><span class="tag">		http://www.springframework.org/schema/tx </span></span>
<span class="string"><span class="tag">		http://www.springframework.org/schema/tx/spring-tx.xsd &quot;</span>&gt;</span>

	<span class="comment">&lt;!-- 连接池配置 --&gt;</span>
	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisPoolConfig&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisPoolConfig&quot;</span>&gt;</span>
		<span class="comment">&lt;!-- 最大连接数 --&gt;</span>
		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxTotal&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span> /&gt;</span>
		<span class="comment">&lt;!-- 最大空闲连接数 --&gt;</span>
		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span>
		<span class="comment">&lt;!-- 每次释放连接的最大数目 --&gt;</span>
		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;numTestsPerEvictionRun&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1024&quot;</span> /&gt;</span>
		<span class="comment">&lt;!-- 释放连接的扫描间隔（毫秒） --&gt;</span>
		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30000&quot;</span> /&gt;</span>
		<span class="comment">&lt;!-- 连接最小空闲时间 --&gt;</span>
		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1800000&quot;</span> /&gt;</span>
		<span class="comment">&lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt;</span>
		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;softMinEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span>
		<span class="comment">&lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt;</span>
		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWaitMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1500&quot;</span> /&gt;</span>
		<span class="comment">&lt;!-- 在获取连接的时候检查有效性, 默认false --&gt;</span>
		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span>
		<span class="comment">&lt;!-- 在空闲时检查有效性, 默认false --&gt;</span>
		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span>
		<span class="comment">&lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt;</span>
		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;blockWhenExhausted&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span>
	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span>

	<span class="comment">&lt;!-- redis单机 通过连接池 --&gt;</span>
	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisPool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisPool&quot;</span></span>
<span class="tag">		<span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span>
		<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;poolConfig&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jedisPoolConfig&quot;</span> /&gt;</span>
		<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;host&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.242.130&quot;</span> /&gt;</span>
		<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;port&quot;</span> <span class="attr">value</span>=<span class="string">&quot;6379&quot;</span> /&gt;</span>
	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span>
<span class="tag">&lt;/<span class="name">beans</span>&gt;</span></code></pre>
<p>测试代码</p>
<pre><code class="highlight java"><span class="meta">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJedisPool</span><span class="params">()</span> &#123;
	<span class="type">JedisPool</span> <span class="variable">pool</span> <span class="operator">=</span> (JedisPool) applicationContext.getBean(<span class="string">&quot;jedisPool&quot;</span>);
	<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="literal">null</span>;
	<span class="keyword">try</span> &#123;
		jedis = pool.getResource();

		jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lisi&quot;</span>);
		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);
		System.out.println(name);
	&#125; <span class="keyword">catch</span> (Exception ex) &#123;
		ex.printStackTrace();
	&#125; <span class="keyword">finally</span> &#123;
		<span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;
			<span class="comment">// 关闭连接</span>
			jedis.close();
		&#125;
	&#125;
&#125;</code></pre>
<h2 id="redis数据类型"><a class="markdownIt-Anchor" href="#redis数据类型"></a> Redis数据类型</h2>
<p>官方命令大全网址：<u><a target="_blank" rel="noopener" href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></u></p>
<p>Redis中存储数据是通过<strong>key-value</strong>格式存储数据的，其中value可以定义五种数据类型：</p>
<ul>
<li>
<p><strong>String（字符类型）</strong></p>
</li>
<li>
<p><strong>Hash（散列类型）</strong></p>
</li>
<li>
<p><strong>List（列表类型）</strong></p>
</li>
<li>
<p><strong>Set（集合类型）</strong></p>
</li>
<li>
<p><strong>SortedSet（有序集合类型，简称zset）</strong></p>
</li>
</ul>
<blockquote>
<p>注意：在redis中的命令语句中，命令是忽略大小写的，而key是不忽略大小写的</p>
</blockquote>
<h3 id="string-字符串"><a class="markdownIt-Anchor" href="#string-字符串"></a> String 字符串</h3>
<table>
<thead>
<tr>
<th>代码</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SET key value</strong></td>
<td><strong>赋值</strong>，设置key=value</td>
</tr>
<tr>
<td><strong>GET key</strong></td>
<td><strong>取值</strong>，获得键key对应的值</td>
</tr>
<tr>
<td>GETRANGE key start end</td>
<td>得到字符串的子字符串存放在一个键</td>
</tr>
<tr>
<td><strong>GETSET key value</strong></td>
<td><strong>取值并赋值</strong>，设置键的字符串值，并返回旧值</td>
</tr>
<tr>
<td>GETBIT key offset</td>
<td>返回存储在键位值的字符串值的偏移</td>
</tr>
<tr>
<td><strong>MGET key1 [key2…]</strong></td>
<td><strong>同时获取多个键值</strong>，得到所有的给定键的值</td>
</tr>
<tr>
<td>SETBIT key offset value</td>
<td>设置或清除该位在存储在键的字符串值偏移</td>
</tr>
<tr>
<td>SETEX key seconds value</td>
<td>键到期时设置值</td>
</tr>
<tr>
<td><strong>SETNX key value</strong></td>
<td><strong>仅当不存在时赋值</strong>，设置键的值，只有当该键不存在，<strong>该命令可以实现分布式锁的功能</strong></td>
</tr>
<tr>
<td>SETRANGE key offset value</td>
<td>覆盖字符串的一部分从指定键的偏移</td>
</tr>
<tr>
<td><strong>STRLEN key</strong></td>
<td><strong>获取字符串长度</strong>，得到存储在键的值的长度</td>
</tr>
<tr>
<td><strong>MSET key value [key value…]</strong></td>
<td><strong>同时设置多个键值</strong>设置多个键和多个值</td>
</tr>
<tr>
<td>MSETNX key value [key value…]</td>
<td>设置多个键多个值，只有在当没有按键的存在时</td>
</tr>
<tr>
<td>PSETEX key milliseconds value</td>
<td>设置键的毫秒值和到期时间</td>
</tr>
<tr>
<td><strong>INCR key</strong></td>
<td><strong>递增数字</strong>，增加键的整数值一次</td>
</tr>
<tr>
<td><strong>INCRBY key increment</strong></td>
<td><strong>增加指定的整数</strong>，由给定的数量递增键的整数值</td>
</tr>
<tr>
<td>INCRBYFLOAT key increment</td>
<td>由给定的数量递增键的浮点值</td>
</tr>
<tr>
<td><strong>DECR key</strong></td>
<td><strong>递减数字</strong>，递减键一次的整数值</td>
</tr>
<tr>
<td><strong>DECRBY key decrement</strong></td>
<td><strong>减少指定整数</strong>，由给定数目递减键的整数值</td>
</tr>
<tr>
<td><strong>APPEND key value</strong></td>
<td><strong>向尾部追加值</strong>，追加值到一个键</td>
</tr>
<tr>
<td>DEL key</td>
<td>如果存在删除键</td>
</tr>
<tr>
<td>DUMP key</td>
<td>返回存储在指定键的值的序列化版本</td>
</tr>
<tr>
<td>EXISTS key</td>
<td>此命令检查该键是否存在</td>
</tr>
<tr>
<td>EXPIRE key seconds</td>
<td>指定键的过期时间</td>
</tr>
<tr>
<td>EXPIREAT key timestamp</td>
<td>指定的键过期时间。在这里，时间是在Unix时间戳格式</td>
</tr>
<tr>
<td>PEXPIRE key milliseconds</td>
<td>设置键以毫秒为单位到期</td>
</tr>
<tr>
<td>PEXPIREAT key milliseconds-timestemp</td>
<td>设置键在Unix时间戳指定为毫秒到期</td>
</tr>
<tr>
<td>KEYS pattern</td>
<td>查找与指定模式匹配的所有键</td>
</tr>
<tr>
<td>MOVE key db</td>
<td>移动键到另一个数据库</td>
</tr>
<tr>
<td>PERSIST key</td>
<td>移除过期的键</td>
</tr>
<tr>
<td>PTTL key</td>
<td>以毫秒为单位获取剩余时间的到期键。</td>
</tr>
<tr>
<td>TTL key</td>
<td>获取键到期的剩余时间。</td>
</tr>
<tr>
<td>RANDOMKEY</td>
<td>从Redis返回随机键</td>
</tr>
<tr>
<td>RENAME key newkey</td>
<td>更改键的名称</td>
</tr>
<tr>
<td>RENAMENX key newkey</td>
<td>重命名键，如果新的键不存在</td>
</tr>
<tr>
<td>TYPE key</td>
<td>返回存储在键的数据类型的值。</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>使用示例</strong></li>
</ul>
<p><strong>赋值</strong><br />
语法：SET key value</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; set test 123
OK</code></pre>
<p><strong>取值</strong><br />
语法：GET key</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; get test
&quot;123“</code></pre>
<p><strong>取值并赋值</strong><br />
语法：GETSET key value</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; getset s2 222
&quot;111&quot;
127.0.0.1:6379&gt; get s2
&quot;222&quot;</code></pre>
<p><strong>数值增减</strong><br />
注意实现：</p>
<ol>
<li>当value为<strong>整数数据</strong>时，才能使用以下命令操作数值的增减。</li>
<li>数值递增都是<strong>原子</strong>操作。</li>
</ol>
<pre><code class="highlight plaintext">非原子性操作示例：可能多个线程同时访问时会得到相同的i，但我们期望每次访问都+1
int i = 1;
i++;
System.out.println(i)</code></pre>
<ul>
<li><strong>递增数字</strong><br />
语法：INCR key</li>
</ul>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; incr num
(integer) 1
127.0.0.1:6379&gt; incr num
(integer) 2
127.0.0.1:6379&gt; incr num
(integer) 3</code></pre>
<ul>
<li><strong>增加指定的整数</strong><br />
语法：INCRBY key increment</li>
</ul>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; incrby num 2
(integer) 5
127.0.0.1:6379&gt; incrby num 2
(integer) 7
127.0.0.1:6379&gt; incrby num 2
(integer) 9</code></pre>
<ul>
<li><strong>递减数值</strong><br />
语法：DECR key</li>
</ul>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; decr num
(integer) 9
127.0.0.1:6379&gt; decr num
(integer) 8</code></pre>
<ul>
<li><strong>减少指定的整数</strong><br />
语法：DECRBY key decrement</li>
</ul>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; decr num
(integer) 6
127.0.0.1:6379&gt; decr num
(integer) 5
127.0.0.1:6379&gt; decrby num 3
(integer) 2
127.0.0.1:6379&gt; decrby num 3
(integer) -1</code></pre>
<p><strong>仅当不存在时赋值</strong><br />
语法：setnx key value</p>
<pre><code class="highlight plaintext">redis&gt; EXISTS job                # job 不存在
(integer) 0
redis&gt; SETNX job &quot;programmer&quot;    # job 设置成功
(integer) 1
redis&gt; SETNX job &quot;code-farmer&quot;   # 尝试覆盖 job ，失败
(integer) 0
redis&gt; GET job                   # 没有被覆盖
&quot;programmer&quot;</code></pre>
<p><strong>向尾部追加值</strong><br />
APPEND命令，向键值的末尾追加value。如果键不存在则将该键的值设置为value，即相当于 SET key value。返回值是追加后字符串的总长度。</p>
<p>语法：APPEND key value</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; set str hello
OK
127.0.0.1:6379&gt; append str &quot; world!&quot;
(integer) 12
127.0.0.1:6379&gt; get str 
&quot;hello world!&quot;</code></pre>
<p><strong>获取字符串长度</strong><br />
STRLEN命令，返回键值的长度，如果键不存在则返回0。</p>
<p>语法：STRLEN key</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; strlen str 
(integer) 0
127.0.0.1:6379&gt; set str hello
OK
127.0.0.1:6379&gt; strlen str 
(integer) 5</code></pre>
<p><strong>同时设置/获取多个键值</strong><br />
语法：<br />
MSET key value [key value …]<br />
MGET key [key …]</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3
OK
127.0.0.1:6379&gt; get k1
&quot;v1&quot;
127.0.0.1:6379&gt; mget k1 k3
1) &quot;v1&quot;
2) &quot;v3&quot;</code></pre>
<p><strong>应用场景之自增主键</strong></p>
<ul>
<li>需求：商品编号、订单号采用INCR命令生成。</li>
<li>设计：key命名要有一定的设计</li>
<li>实现：定义商品编号key：items:id</li>
</ul>
<pre><code class="highlight plaintext">192.168.101.3:7003&gt; INCR items:id
(integer) 2
192.168.101.3:7003&gt; INCR items:id
(integer) 3</code></pre>
<h3 id="list-列表"><a class="markdownIt-Anchor" href="#list-列表"></a> List 列表</h3>
<p><strong>ArrayList和LinkedList的区别</strong></p>
<p>ArrayList使用<strong>数组方式</strong>存储数据，所以根据索引查询数据速度快，而新增或者删除元素时需要设计到位移操作，所以比较慢。</p>
<p>LinkedList使用<strong>双向链表</strong>方式存储数据，每个元素都记录前后元素的指针，所以插入、删除数据时只是更改前后元素的指针指向即可，速度非常快。然后通过下标查询元素时需要从头开始索引，所以比较慢，但是如果查询前几个元素或后几个元素速度比较快</p>
<hr />
<p>Redis的列表类型（list）可以存储一个有序的字符串列表，常用的操作是<strong>向列表两端添加元素，或者获得列表的某一个片段</strong>。</p>
<p>列表类型内部是使用<strong>双向链表（double linked list）实现</strong>的，所以向列表两端添加元素的时间复杂度为0(1)，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>BLPOP key1 [key2 ] timeout</td>
<td>取出并获取列表中的第一个元素，或阻塞，直到有可用</td>
</tr>
<tr>
<td>BRPOP key1 [key2 ] timeout</td>
<td>取出并获取列表中的最后一个元素，或阻塞，直到有可用</td>
</tr>
<tr>
<td><strong>BRPOPLPUSH source destination timeout</strong></td>
<td><strong>将元素从一个列表转移到另一个列表中</strong>，从列表中弹出一个值，它推到另一个列表并返回它;或阻塞，直到有可用</td>
</tr>
<tr>
<td><strong>LINDEX key index</strong></td>
<td><strong>获取指定索引的元素值</strong>从一个列表其索引获取对应的元素</td>
</tr>
<tr>
<td><strong>LINSERT key BEFORE/AFTER pivot value</strong></td>
<td><strong>向列表中插入元素</strong>，在列表中的其他元素之后或之前插入一个元素</td>
</tr>
<tr>
<td><strong>LLEN key</strong></td>
<td><strong>获取列表的长度</strong></td>
</tr>
<tr>
<td><strong>LPOP key</strong></td>
<td><strong>获取并取出列表中的第一个元素，弹出元素</strong></td>
</tr>
<tr>
<td><strong>LPUSH key value1 [value2]</strong></td>
<td><strong>向列表左边增加元素</strong>,在前面加上一个或多个值的列表</td>
</tr>
<tr>
<td>LPUSHX key value</td>
<td>在前面加上一个值列表，仅当列表中存在</td>
</tr>
<tr>
<td><strong>LRANGE key start stop</strong></td>
<td>从一个列表获取各种元素</td>
</tr>
<tr>
<td><strong>LREM key count value</strong></td>
<td><strong>LREM命令会删除列表中前count个值为value的元素，返回实际删除的元素个数</strong>从列表中删除元素</td>
</tr>
<tr>
<td><strong>LSET key index value</strong></td>
<td><strong>指定一个索引的元素值</strong>，在列表中的索引设置一个元素的值</td>
</tr>
<tr>
<td><strong>LTRIM key start stop</strong></td>
<td><strong>只保留列表的指定片段</strong>，修剪列表到指定的范围内</td>
</tr>
<tr>
<td><strong>RPOP key</strong></td>
<td><strong>取出并获取列表中的最后一个元素，弹出元素</strong></td>
</tr>
<tr>
<td>RPOPLPUSH source destination</td>
<td>删除最后一个元素的列表，将其附加到另一个列表并返回它</td>
</tr>
<tr>
<td><strong>RPUSH key value1 [value2]</strong></td>
<td><strong>向列表右边增加元素</strong>，添加一个或多个值到列表</td>
</tr>
<tr>
<td>RPUSHX key value</td>
<td>添加一个值列表，仅当列表中存在</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>使用示例</strong></li>
</ul>
<p><strong>向列表两端增加元素</strong></p>
<ul>
<li><strong>向列表左边增加元素</strong><br />
语法：LPUSH key value [value …]</li>
</ul>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; lpush list:1 1 2 3
(integer) 3</code></pre>
<ul>
<li><strong>向列表右边增加元素</strong><br />
语法：RPUSH key value [value …]</li>
</ul>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; rpush list:1 4 5 6
(integer) 3</code></pre>
<p><strong>查看列表</strong><br />
语法：LRANGE key start stop<br />
LRANGE命令是列表类型最常用的命令之一，获取列表中的某一片段，将返回start、stop之间的所有元素（包含两端的元素），索引从0开始。索引可以是负数，如：“-1”代表最后边的一个元素。</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; lrange list:1 0 2
1) &quot;2&quot;
2) &quot;1&quot;
3) &quot;4&quot;</code></pre>
<p><strong>从列表两端弹出元素</strong><br />
LPOP命令从列表左边弹出一个元素，会分两步完成：</p>
<ol>
<li>第一步是将列表左边的元素从列表中移除</li>
<li>第二步是返回被移除的元素值。</li>
</ol>
<p>语法：<br />
LPOP key<br />
RPOP key</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; lpop list:1
&quot;3“
127.0.0.1:6379&gt; rpop list:1
&quot;6“</code></pre>
<p><strong>获取列表中元素的个数</strong><br />
语法：LLEN key</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; llen list:1
(integer) 2</code></pre>
<p><strong>删除列表中指定个数的值</strong><br />
LREM命令会删除列表中前count个值为value的元素，返回实际删除的元素个数。根据count值的不同，该命令的执行方式会有所不同：</p>
<ol>
<li>当count&gt;0时， LREM会从列表左边开始删除。</li>
<li>当count&lt;0时， LREM会从列表后边开始删除。</li>
<li>当count=0时， LREM删除所有值为value的元素。</li>
</ol>
<p>语法：LREM key count value</p>
<p><strong>获得/设置指定索引的元素值</strong></p>
<ul>
<li><strong>获得指定索引的元素值</strong><br />
语法：LINDEX key index</li>
</ul>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; lindex l:list 2
&quot;1&quot;</code></pre>
<ul>
<li><strong>设置指定索引的元素值</strong><br />
语法：LSET key index value</li>
</ul>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; lset l:list 2 2
OK
127.0.0.1:6379&gt; lrange l:list 0 -1
1) &quot;6&quot;
2) &quot;5&quot;
3) &quot;2&quot;
4) &quot;2&quot;</code></pre>
<p><strong>只保留列表指定片段</strong><br />
指定范围和LRANGE一致</p>
<p>语法：LTRIM key start stop</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; lrange l:list 0 -1
1) &quot;6&quot;
2) &quot;5&quot;
3) &quot;0&quot;
4) &quot;2&quot;
127.0.0.1:6379&gt; ltrim l:list 0 2
OK
127.0.0.1:6379&gt; lrange l:list 0 -1
1) &quot;6&quot;
2) &quot;5&quot;
3) &quot;0&quot;</code></pre>
<p><strong>向列表中插入元素</strong><br />
该命令首先会在列表中从左到右查找值为pivot的元素，然后根据第二个参数是BEFORE还是AFTER来决定将value插入到该元素的前面还是后面。</p>
<p>语法：LINSERT key BEFORE|AFTER pivot value</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; lrange list 0 -1
1) &quot;3&quot;
2) &quot;2&quot;
3) &quot;1&quot;
127.0.0.1:6379&gt; linsert list after 3 4
(integer) 4
127.0.0.1:6379&gt; lrange list 0 -1
1) &quot;3&quot;
2) &quot;4&quot;
3) &quot;2&quot;
4) &quot;1&quot;</code></pre>
<p><strong>将元素从一个列表转移到另一个列表中</strong><br />
语法：RPOPLPUSH source destination</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; rpoplpush list newlist 
&quot;1&quot;
127.0.0.1:6379&gt; lrange newlist 0 -1
1) &quot;1&quot;
127.0.0.1:6379&gt; lrange list 0 -1
1) &quot;3&quot;
2) &quot;4&quot;
3) &quot;2&quot;
</code></pre>
<p><strong>应用之商品评论列表</strong></p>
<ul>
<li>需求1：用户针对某一商品发布评论，一个商品会被不同的用户进行评论，存储商品评论时，要按时间顺序排序。</li>
<li>需求2：用户在前端页面查询该商品的评论，需要安装时间顺序降序排序。</li>
</ul>
<p>思路：</p>
<ol>
<li>使用list存储商品评论信息，KEY是该商品的ID，VALUE是商品评论信息列表</li>
<li>商品编号为1001的商品评论key【items: comment:1001】</li>
</ol>
<pre><code class="highlight plaintext">192.168.101.3:7001&gt; LPUSH items:comment:1001 &#x27;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;商品不错，很好！！&quot;,&quot;date&quot;:1430295077289&#125;&#x27;</code></pre>
<h3 id="hash-哈希表"><a class="markdownIt-Anchor" href="#hash-哈希表"></a> Hash 哈希表</h3>
<p>hash叫<strong>散列类型</strong>，它提供了字段和字段值的映射。字段值只能是字符串类型，不支持散列类型、集合类型等其它类型</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>HDEL key field[field…]</strong></td>
<td><strong>删除一个或多个字段，返回值是被删除的字段个数</strong>，删除对象的一个或几个属性域，不存在的属性将被忽略</td>
</tr>
<tr>
<td><strong>HEXISTS key field</strong></td>
<td><strong>判断字段是否存在</strong>，查看对象是否存在该属性域</td>
</tr>
<tr>
<td><strong>HGET key field</strong></td>
<td><strong>一次获取一个字段值</strong>，获取对象中该field属性域的值</td>
</tr>
<tr>
<td><strong>HGETALL key</strong></td>
<td><strong>获取所有字段的key和value</strong>，获取对象的所有属性域和值</td>
</tr>
<tr>
<td><strong>HINCRBY key field value increment</strong></td>
<td><strong>增加数字</strong>，将该对象中指定域的值增加给定的value，原子自增操作，只能是integer的属性值可以使用</td>
</tr>
<tr>
<td>HINCRBYFLOAT key field increment</td>
<td>将该对象中指定域的值增加给定的浮点数</td>
</tr>
<tr>
<td><strong>HKEYS key</strong></td>
<td><strong>只获取字段名</strong>，获取对象的所有属性字段</td>
</tr>
<tr>
<td><strong>HVALS key</strong></td>
<td><strong>只获取字段值</strong>，获取对象的所有属性值</td>
</tr>
<tr>
<td><strong>HLEN key</strong></td>
<td><strong>获取字段数量</strong>，获取对象的所有属性字段的总数</td>
</tr>
<tr>
<td><strong>HMGET key field[field…]</strong></td>
<td><strong>一次获取多个字段的值</strong>，获取对象的一个或多个指定字段的值</td>
</tr>
<tr>
<td><strong>HSET key field value</strong></td>
<td><strong>设置一个字段的值</strong>，设置对象指定字段的值</td>
</tr>
<tr>
<td><strong>HMSET key field value [field value …]</strong></td>
<td><strong>设置多个字段的值</strong>，同时设置对象中一个或多个字段的值</td>
</tr>
<tr>
<td><strong>HSETNX key field value</strong></td>
<td><strong>当字段不存在时赋值</strong>，只在对象不存在指定的字段时才设置字段的值</td>
</tr>
<tr>
<td>HSTRLEN key field</td>
<td>返回对象指定field的value的字符串长度，如果该对象或者field不存在，返回0.</td>
</tr>
<tr>
<td>HSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td>类似SCAN命令</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>使用示例</strong></li>
</ul>
<p><strong>赋值</strong><br />
HSET命令不区分插入和更新操作，当执行插入操作时HSET命令返回1，当执行更新操作时返回0。</p>
<ul>
<li><strong>一次只能设置一个字段值</strong><br />
语法：HSET key field value</li>
</ul>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; hset user username zhangsan 
(integer) 1</code></pre>
<ul>
<li><strong>一次可以设置多个字段值</strong><br />
语法：HMSET key field value [field value …]</li>
</ul>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; hmset user age 20 username lisi 
OK</code></pre>
<ul>
<li><strong>当字段不存在时赋值</strong>，类似HSET，区别在于如果字段存在，该命令不执行任何操作<br />
语法：HSETNX key field value</li>
</ul>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; hsetnx user age 30	如果user中没有age字段则设置age值为30，否则不做任何操作
(integer) 0</code></pre>
<p><strong>取值</strong></p>
<ul>
<li><strong>一次只能获取一个字段值</strong><br />
语法：HGET key field</li>
</ul>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; hget user username
&quot;zhangsan“</code></pre>
<ul>
<li><strong>一次可以获取多个字段值</strong><br />
语法：HMGET key field [field …]</li>
</ul>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; hmget user age username
1) &quot;20&quot;
2) &quot;lisi&quot;</code></pre>
<ul>
<li><strong>获取所有字段值</strong><br />
语法：HGETALL key</li>
</ul>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; hgetall user
1) &quot;age&quot;
2) &quot;20&quot;
3) &quot;username&quot;
4) &quot;lisi&quot;</code></pre>
<p><strong>删除字段</strong><br />
可以删除一个或多个字段，返回值是被删除的字段个数</p>
<p>语法：HDEL key field [field …]</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; hdel user age
(integer) 1
127.0.0.1:6379&gt; hdel user age name
(integer) 0
127.0.0.1:6379&gt; hdel user age username
(integer) 1</code></pre>
<p><strong>增加数字</strong><br />
语法：HINCRBY key field increment</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; hincrby user age 2	将用户的年龄加2
(integer) 22
127.0.0.1:6379&gt; hget user age		获取用户的年龄
&quot;22“</code></pre>
<p><strong>判断字段是否存在</strong><br />
语法：HEXISTS key field</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; hexists user age		查看user中是否有age字段
(integer) 1
127.0.0.1:6379&gt; hexists user name	查看user中是否有name字段
(integer) 0</code></pre>
<p><strong>只获取字段名或字段值</strong><br />
语法：<br />
HKEYS key<br />
HVALS key</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; hmset user age 20 name lisi 
OK
127.0.0.1:6379&gt; hkeys user
1) &quot;age&quot;
2) &quot;name&quot;
127.0.0.1:6379&gt; hvals user
1) &quot;20&quot;
2) &quot;lisi&quot;</code></pre>
<p><strong>获取字段数量</strong><br />
语法：HLEN key</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; hlen user
(integer) 2</code></pre>
<p><strong>获取所有字段</strong><br />
作用：获得hash的所有信息，包括key和value<br />
语法：hgetall key</p>
<p><strong>应用之存储商品信息</strong><br />
注意事项：存储那些对象数据，特别是对象属性经常发生增删改操作的数据。</p>
<ul>
<li>
<p>商品信息字段<br />
【商品id、商品名称、商品描述、商品库存、商品好评】</p>
</li>
<li>
<p>定义商品信息的key<br />
商品ID为1001的信息在 Redis中的key为：[items:1001]</p>
</li>
</ul>
<p>存储商品信息</p>
<pre><code class="highlight plaintext">192.168.101.3:7003&gt; HMSET items:1001 id 3 name apple price 999.9
OK</code></pre>
<p>获取商品信息</p>
<pre><code class="highlight plaintext">192.168.101.3:7003&gt; HGET items:1001 id
&quot;3&quot;
192.168.101.3:7003&gt; HGETALL items:1001
1) &quot;id&quot;
2) &quot;3&quot;
3) &quot;name&quot;
4) &quot;apple&quot;
5) &quot;price&quot;
6) &quot;999.9&quot;</code></pre>
<h3 id="set-集合"><a class="markdownIt-Anchor" href="#set-集合"></a> set 集合</h3>
<p>set类型即<strong>集合类型</strong>，其中的数据是<strong>不重复且没有顺序</strong></p>
<p>集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型的Redis内部是使用值为空的散列表实现，所有这些操作的时间复杂度都为0(1)。</p>
<p>Redis还提供了多个集合之间的交集、并集、差集的运算。</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SADD key member [member …]</strong></td>
<td><strong>增加元素</strong>，添加一个或者多个元素到集合(set)里，已存在的元素忽略</td>
</tr>
<tr>
<td><strong>SCARD key</strong></td>
<td><strong>获取集合里面的元素数量</strong></td>
</tr>
<tr>
<td><strong>SDIFF key [key …]</strong></td>
<td><strong>属于A并且不属于B的元素构成的集合</strong>，获得队列不存在的元素</td>
</tr>
<tr>
<td>SDIFFSTORE destination key [key …]</td>
<td>获得队列不存在的元素，并存储在一个关键的结果集</td>
</tr>
<tr>
<td><strong>SINTER key [key …]</strong></td>
<td><strong>获得两个集合的交集</strong></td>
</tr>
<tr>
<td>SINTERSTORE destination key [key …]</td>
<td>获得两个集合的交集，并存储在一个集合中</td>
</tr>
<tr>
<td><strong>SISMEMBER key member</strong></td>
<td><strong>判断元素是否再集合中</strong>，确定一个给定的值是一个集合的成员</td>
</tr>
<tr>
<td><strong>SMEMBERS key</strong></td>
<td><strong>获取集合里面的所有元素</strong></td>
</tr>
<tr>
<td>SMOVE source destination member</td>
<td>移动集合里面的一个key到另一个集合</td>
</tr>
<tr>
<td><strong>SPOP key [count]</strong></td>
<td><strong>从集合中弹出一个元素</strong>，获取并删除一个集合里面的元素，注意：由于集合是无序的，所有SPOP命令会从集合中随机选择一个元素弹出</td>
</tr>
<tr>
<td>SRANDMEMBER key [count]</td>
<td>从集合里面随机获取一个元素</td>
</tr>
<tr>
<td><strong>SREM key member [member …]</strong></td>
<td><strong>删除元素</strong>，从集合里删除一个或多个元素，不存在的元素会被忽略</td>
</tr>
<tr>
<td><strong>SUNION key [key …]</strong></td>
<td><strong>A和B的并集，属于A或者属于B的元素构成的集合</strong>，添加多个set元素</td>
</tr>
<tr>
<td>SUNIONSTORE destination key [key …]</td>
<td>合并set元素，并将结果存入新的set里面</td>
</tr>
<tr>
<td>SSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td>迭代set里面的元素</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>使用示例</strong></li>
</ul>
<p><strong>增加/删除元素</strong><br />
语法：SADD key member [member …]</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; sadd set a b c
(integer) 3
127.0.0.1:6379&gt; sadd set a
(integer) 0</code></pre>
<p>语法：SREM key member [member …]</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; srem set c d
(integer) 1</code></pre>
<p><strong>获得集合中的所有元素</strong><br />
语法：SMEMBERS key</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; smembers set
1) &quot;b&quot;
2) &quot;a”</code></pre>
<p><strong>判断元素是否在集合中</strong><br />
语法：SISMEMBER key member</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; sismember set a
(integer) 1
127.0.0.1:6379&gt; sismember set h
(integer) 0</code></pre>
<p><strong>集合运算命令</strong></p>
<ul>
<li><strong>集合的差集运算 A-B</strong><br />
属于A并且不属于B的元素构成的集合。</li>
</ul>
<p>语法：SDIFF key [key …]</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; sadd setA 1 2 3
(integer) 3
127.0.0.1:6379&gt; sadd setB 2 3 4
(integer) 3
127.0.0.1:6379&gt; sdiff setA setB 
1) &quot;1&quot;
127.0.0.1:6379&gt; sdiff setB setA 
1) &quot;4&quot;</code></pre>
<ul>
<li><strong>集合的交集运算 A ∩ B</strong><br />
属于A且属于B的元素构成的集合。</li>
</ul>
<p>语法：SINTER key [key …]</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; sinter setA setB 
1) &quot;2&quot;
2) &quot;3&quot;</code></pre>
<ul>
<li><strong>集合的并集运算 A ∪ B</strong><br />
属于A或者属于B的元素构成的集合（结果也无重复值）</li>
</ul>
<p>语法：SUNION key [key …]</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; sunion setA setB
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
4) &quot;4&quot;</code></pre>
<p><strong>获得集合中元素的个数</strong><br />
语法：SCARD key</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; smembers setA 
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
127.0.0.1:6379&gt; scard setA 
(integer) 3</code></pre>
<p><strong>从集合中弹出一个元素</strong><br />
注意：由于集合是无序的，所有SPOP命令会从集合中随机选择一个元素弹出</p>
<p>语法：SPOP key</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; spop setA 
&quot;1“</code></pre>
<h3 id="zsetsorted-set有序集合"><a class="markdownIt-Anchor" href="#zsetsorted-set有序集合"></a> Zset(Sorted Set)有序集合</h3>
<p>在集合类型的基础上，有序集合类型为集合中的<strong>每个元素都关联一个分数</strong>，这使得我们不仅可以完成插入、删除和判断元素是否存在在集合中，还能够获得分数最高或最低的前N个元素、获取指定分数范围内的元素等与分数有关的操作。</p>
<p>在某些方面有序集合和列表类型有些<strong>相似</strong>。</p>
<ol>
<li>
<p>二者都是有序的。</p>
</li>
<li>
<p>二者都可以获得某一范围的元素。</p>
</li>
</ol>
<p>但是，二者有着很大<strong>区别</strong>：</p>
<ol>
<li>
<p>列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会变慢。</p>
</li>
<li>
<p>有序集合类型使用散列表实现，所有即使读取位于中间部分的数据也很快。</p>
</li>
<li>
<p>列表中不能简单的调整某个元素的位置，但是有序集合可以（通过更改分数实现）</p>
</li>
<li>
<p>有序集合要比列表类型更耗内存。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>代码</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ZADD key score1 member1 [score2 member2]</strong></td>
<td><strong>增加元素</strong>，添加一个或多个成员到有序集合，或者如果它已经存在更新其分数</td>
</tr>
<tr>
<td><strong>ZCARD key</strong></td>
<td><strong>得到的有序集合成员的数量</strong></td>
</tr>
<tr>
<td><strong>ZCOUNT key min max</strong></td>
<td><strong>获得指定分数范围内的元素个数</strong>，计算一个有序集合成员与给定值范围内的分数</td>
</tr>
<tr>
<td><strong>ZINCRBY key increment member</strong></td>
<td><strong>增加某个元素的分数</strong>，在有序集合增加成员的分数</td>
</tr>
<tr>
<td>ZINTERSTORE destination numkeys key [key …]</td>
<td>多重交叉排序集合，并存储生成一个新的键有序集合。</td>
</tr>
<tr>
<td>ZLEXCOUNT key min max</td>
<td>计算一个给定的字典范围之间的有序集合成员的数量</td>
</tr>
<tr>
<td><strong>ZRANGE key start stop [WITHSCORES]</strong></td>
<td><strong>获取排名再某个范围内的元素列表</strong>，由索引返回一个成员范围的有序集合（从低到高）</td>
</tr>
<tr>
<td>ZRANGEBYLEX key min max [LIMIT offset count]</td>
<td>返回一个成员范围的有序集合（由字典范围）</td>
</tr>
<tr>
<td><strong>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</strong></td>
<td><strong>获取指定分数范围内的元素</strong>，返回有序集key中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员，有序集成员按 score 值递增(从小到大)次序排列</td>
</tr>
<tr>
<td><strong>ZRANK key member</strong></td>
<td><strong>获取元素的排名（从小到大）</strong>，确定成员的索引中有序集合</td>
</tr>
<tr>
<td><strong>ZREM key member [member …]</strong></td>
<td><strong>删除元素</strong>，从有序集合中删除一个或多个成员，不存在的成员将被忽略</td>
</tr>
<tr>
<td>ZREMRANGEBYLEX key min max</td>
<td>删除所有成员在给定的字典范围之间的有序集合</td>
</tr>
<tr>
<td><strong>ZREMRANGEBYRANK key start stop</strong></td>
<td><strong>按照排名范围删除元素</strong>，在给定的索引之内删除所有成员的有序集合</td>
</tr>
<tr>
<td><strong>ZREMRANGEBYSCORE key min max</strong></td>
<td><strong>按照分数范围删除元素</strong>，在给定的分数之内删除所有成员的有序集合</td>
</tr>
<tr>
<td>ZREVRANGE key start stop [WITHSCORES]</td>
<td>返回一个成员范围的有序集合，通过索引，以分数排序，从高分到低分</td>
</tr>
<tr>
<td>ZREVRANGEBYSCORE key max min [WITHSCORES]</td>
<td>返回一个成员范围的有序集合，以socre排序从高到低</td>
</tr>
<tr>
<td><strong>ZREVRANK key member</strong></td>
<td><strong>获取元素的排名（）从大到小</strong>，确定一个有序集合成员的索引，以分数排序，从高分到低分</td>
</tr>
<tr>
<td><strong>ZSCORE key member</strong></td>
<td><strong>获取元素的分数</strong>，获取给定成员相关联的分数在一个有序集合</td>
</tr>
<tr>
<td>ZUNIONSTORE destination numkeys key [key …]</td>
<td>添加多个集排序，所得排序集合存储在一个新的键</td>
</tr>
<tr>
<td>ZSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td>增量迭代排序元素集和相关的分数</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>使用示例</strong></li>
</ul>
<p><strong>增加元素</strong><br />
向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。</p>
<p>语法：ZADD key score member [score member …]</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; zadd scoreboard 80 zhangsan 89 lisi 94 wangwu 
(integer) 3
127.0.0.1:6379&gt; zadd scoreboard 97 lisi 
(integer) 0</code></pre>
<p><strong>获得排名在某个范围的元素列表</strong></p>
<ul>
<li>按照元素分数<strong>从小到大</strong>的顺序返回索引从start到stop之间的所有元素（包含两端的元素）</li>
</ul>
<p>语法：ZRANGE key start stop [WITHSCORES]</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; zrange scoreboard 0 2
1) &quot;zhangsan&quot;
2) &quot;wangwu&quot;
3) &quot;lisi“</code></pre>
<ul>
<li>按照元素分数<strong>从大到小</strong>的顺序返回索引从start到stop之间的所有元素（包含两端的元素）</li>
</ul>
<p>语法：ZREVRANGE key start stop [WITHSCORES]</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; zrevrange scoreboard 0 2
1) &quot; lisi &quot;
2) &quot;wangwu&quot;
3) &quot; zhangsan “</code></pre>
<blockquote>
<p>如果需要获得元素的分数的可以在命令尾部加上WITHSCORES参数</p>
</blockquote>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; zrange scoreboard 0 1 WITHSCORES
1) &quot;zhangsan&quot;
2) &quot;80&quot;
3) &quot;wangwu&quot;
4) &quot;94&quot;</code></pre>
<p><strong>获取元素的分数</strong><br />
语法：ZSCORE key member</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; zscore scoreboard lisi 
&quot;97&quot;</code></pre>
<p><strong>删除元素</strong><br />
移除有序集key中的一个或多个成员，不存在的成员将被忽略。<br />
当key存在但不是有序集类型时，返回一个错误。</p>
<p>语法：ZREM key member [member …]</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; zrem scoreboard lisi
(integer) 1</code></pre>
<p><strong>获得指定分数范围的元素</strong><br />
语法：ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 90 97 WITHSCORES
1) &quot;wangwu&quot;
2) &quot;94&quot;
3) &quot;lisi&quot;
4) &quot;97&quot;
127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 70 100 limit 1 2
1) &quot;wangwu&quot;
2) &quot;lisi&quot;</code></pre>
<p><strong>增加某个元素的分数</strong><br />
返回值是更改后的分数</p>
<p>语法：ZINCRBY  key increment member</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; ZINCRBY scoreboard 4 lisi 
&quot;101“</code></pre>
<p><strong>获得集合中元素的数量</strong><br />
语法：ZCARD key</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; ZCARD scoreboard
(integer) 3</code></pre>
<p><strong>获得指定分数范围内的元素个数</strong><br />
语法：ZCOUNT key min max</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; ZCOUNT scoreboard 80 90
(integer) 1</code></pre>
<p><strong>按照排名范围删除元素</strong><br />
语法：ZREMRANGEBYRANK key start stop</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; ZREMRANGEBYRANK scoreboard 0 1
(integer) 2 

127.0.0.1:6379&gt; ZRANGE scoreboard 0 -1
1) &quot;lisi&quot;</code></pre>
<p><strong>按照分数范围删除元素</strong><br />
语法：ZREMRANGEBYSCORE key min max</p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; zadd scoreboard 84 zhangsan	
(integer) 1
127.0.0.1:6379&gt; ZREMRANGEBYSCORE scoreboard 80 100
(integer) 1</code></pre>
<p><strong>获取元素的排名</strong></p>
<ul>
<li><strong>从小到大</strong><br />
语法：ZRANK key member</li>
</ul>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; ZRANK scoreboard lisi 
(integer) 0
</code></pre>
<ul>
<li><strong>从大到小</strong><br />
语法：ZREVRANK key member</li>
</ul>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; ZREVRANK scoreboard zhangsan 
(integer) 1</code></pre>
<p><strong>应用之商品销售排行榜</strong></p>
<ul>
<li>需求：根据商品销售量对商品进行排行显示</li>
<li>思路：定义商品销售排行榜（sorted set集合），Key为items:sellsort，分数为商品销售量。</li>
</ul>
<p>写入商品销售量：</p>
<ul>
<li>商品编号1001的销量是9，商品编号1002的销量是10</li>
</ul>
<pre><code class="highlight plaintext">192.168.101.3:7007&gt; ZADD items:sellsort 9 1001 10 1002</code></pre>
<ul>
<li>商品编号1001的销量加1</li>
</ul>
<pre><code class="highlight plaintext">192.168.101.3:7001&gt; ZINCRBY items:sellsort 1 1001</code></pre>
<ul>
<li>商品销量前10名：</li>
</ul>
<pre><code class="highlight plaintext">192.168.101.3:7001&gt; ZRANGE items:sellsort 0 9 withscores</code></pre>
<h3 id="通用命令"><a class="markdownIt-Anchor" href="#通用命令"></a> 通用命令</h3>
<p><strong>keys pattern</strong></p>
<p>返回满足给定pattern的所有key</p>
<pre><code class="highlight redis">redis 127.0.0.1:6379&gt; keys mylist*
1) &quot;mylist&quot;
2) &quot;mylist5&quot;
3) &quot;mylist6&quot;
4) &quot;mylist7&quot;
5) &quot;mylist8&quot;</code></pre>
<p><strong>DEL key</strong></p>
<pre><code class="highlight plaintext">127.0.0.1:6379&gt; del test
(integer) 1</code></pre>
<p><strong>exists key</strong></p>
<p>确认一个key是否存在</p>
<pre><code class="highlight plaintext">redis 127.0.0.1:6379&gt; exists HongWan
(integer) 0

redis 127.0.0.1:6379&gt; exists age
(integer) 1</code></pre>
<p><strong>expire</strong></p>
<p>Redis在实际使用过程中更多的用作缓存，然而缓存的数据一般都是需要设置生存时间的，即：到期后数据销毁</p>
<ul>
<li><strong>expire key seconds</strong> 设置key的生存实践（单位：秒）key再多少秒之后会自动删除</li>
<li><strong>ttl key</strong> 查看key剩余的生存时间</li>
<li><strong>persist key</strong> 清除生存时间</li>
<li><strong>pexpire key milliseconds</strong> 设置时间单位为毫秒</li>
</ul>
<pre><code class="highlight plaintext">192.168.101.3:7002&gt; set test 1             设置test的值为1
OK

192.168.101.3:7002&gt; get test                获取test的值
&quot;1&quot;

192.168.101.3:7002&gt; EXPIRE test 5     设置test的生存时间为5秒
(integer) 1

192.168.101.3:7002&gt; TTL test                     查看test的生于生成时间还有1秒删除
(integer) 1

192.168.101.3:7002&gt; TTL test
(integer) -2

192.168.101.3:7002&gt; get test                获取test的值，已经删除
(nil)</code></pre>
<p><strong>rename oldkey  newkey</strong></p>
<p>重命名key</p>
<pre><code class="highlight plaintext">redis 127.0.0.1:6379[1]&gt; keys *

1) &quot;age&quot;

redis 127.0.0.1:6379[1]&gt; rename age age_new

OK

redis 127.0.0.1:6379[1]&gt; keys *

1) &quot;age_new&quot;

redis 127.0.0.1:6379[1]&gt;
</code></pre>
<p><strong>type key</strong></p>
<p>显示指定key的数据类型</p>
<pre><code class="highlight plaintext">redis 127.0.0.1:6379&gt; type addr
string

redis 127.0.0.1:6379&gt; type myzset2
zset

redis 127.0.0.1:6379&gt; type mylist
list</code></pre>
<h2 id="redis-spring-集成"><a class="markdownIt-Anchor" href="#redis-spring-集成"></a> Redis Spring 集成</h2>
<h3 id="导入相关jar包"><a class="markdownIt-Anchor" href="#导入相关jar包"></a> 导入相关jar包</h3>
<ul>
<li>spring相关jar包</li>
<li>Jedis相关jar包</li>
</ul>
<h3 id="redisproperties"><a class="markdownIt-Anchor" href="#redisproperties"></a> redis.properties</h3>
<ul>
<li>指定连接Redis服务器的相关信息</li>
</ul>
<pre><code class="highlight properties"><span class="comment">#ip地址</span>
<span class="attr">redis.hostName</span>=<span class="string">127.0.0.1</span>
<span class="comment">#端口号</span>
<span class="attr">redis.port</span>=<span class="string">6379</span>
<span class="comment">#如果有密码</span>
<span class="attr">redis.password</span>=<span class="string"></span>
<span class="comment">#客户端超时时间单位是毫秒 默认是2000</span>
<span class="attr">redis.timeout</span>=<span class="string">2000</span>
<span class="comment"> </span>
<span class="comment">#最大空闲数</span>
<span class="attr">redis.maxIdle</span>=<span class="string">10</span>
<span class="comment">#连接池的最大数据库连接数。设为0表示无限制,如果是jedis 2.4以后用redis.maxTotal</span>
<span class="attr">redis.maxActive</span>=<span class="string">10</span>
<span class="comment">#控制一个pool可分配多少个jedis实例,用来替换上面的redis.maxActive,如果是jedis 2.4以后用该属性</span>
<span class="attr">redis.maxTotal</span>=<span class="string">10</span>
<span class="comment">#最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制。</span>
<span class="attr">redis.maxWaitMillis</span>=<span class="string">1000</span>
<span class="comment">#连接的最小空闲时间 默认1800000毫秒(30分钟)</span>
<span class="attr">redis.minEvictableIdleTimeMillis</span>=<span class="string">300000</span>
<span class="comment">#每次释放连接的最大数目,默认3</span>
<span class="attr">redis.numTestsPerEvictionRun</span>=<span class="string">1024</span>
<span class="comment">#逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1</span>
<span class="attr">redis.timeBetweenEvictionRunsMillis</span>=<span class="string">30000</span>
<span class="comment">#是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个</span>
<span class="attr">redis.testOnBorrow</span>=<span class="string">false</span>
<span class="comment">#在空闲时检查有效性, 默认false</span>
<span class="attr">redis.testWhileIdle</span>=<span class="string">false</span></code></pre>
<h3 id="applicationcontextxml"><a class="markdownIt-Anchor" href="#applicationcontextxml"></a> applicationContext.xml</h3>
<ul>
<li>配置连接池，连接工厂等，以上都是为了<br />
RedisTemplate服务，这个类就是提供常用的Redis方法</li>
<li>然后又把这个 RedisTemplate 类的实例，注入到 RedisUtil 工具类里，方便调用</li>
</ul>
<pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span> 
<span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>   </span>
<span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span>   </span>
<span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span>   </span>
<span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span>   </span>
<span class="tag">    <span class="attr">xmlns:cache</span>=<span class="string">&quot;http://www.springframework.org/schema/cache&quot;</span> </span>
<span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans     </span></span>
<span class="string"><span class="tag">                        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd     </span></span>
<span class="string"><span class="tag">                        http://www.springframework.org/schema/context     </span></span>
<span class="string"><span class="tag">                        http://www.springframework.org/schema/context/spring-context-4.2.xsd     </span></span>
<span class="string"><span class="tag">                        http://www.springframework.org/schema/mvc     </span></span>
<span class="string"><span class="tag">                        http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd </span></span>
<span class="string"><span class="tag">                        http://www.springframework.org/schema/cache  </span></span>
<span class="string"><span class="tag">                        http://www.springframework.org/schema/cache/spring-cache-4.2.xsd&quot;</span>&gt;</span>
 
    <span class="comment">&lt;!-- 加载配置文件 --&gt;</span>
    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:*.properties&quot;</span> /&gt;</span>
    <span class="comment">&lt;!-- redis连接池配置--&gt;</span> 
    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisPoolConfig&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisPoolConfig&quot;</span> &gt;</span> 
        <span class="comment">&lt;!--最大空闲数--&gt;</span> 
        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.maxIdle&#125;&quot;</span> /&gt;</span> 
        <span class="comment">&lt;!--连接池的最大数据库连接数  --&gt;</span>
        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxTotal&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.maxTotal&#125;&quot;</span> /&gt;</span>
        <span class="comment">&lt;!--最大建立连接等待时间--&gt;</span> 
        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWaitMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.maxWaitMillis&#125;&quot;</span> /&gt;</span> 
        <span class="comment">&lt;!--逐出连接的最小空闲时间 默认1800000毫秒(30分钟)--&gt;</span>
        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.minEvictableIdleTimeMillis&#125;&quot;</span> /&gt;</span>
        <span class="comment">&lt;!--每次逐出检查时 逐出的最大数目 如果为负数就是 : 1/abs(n), 默认3--&gt;</span>
        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;numTestsPerEvictionRun&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.numTestsPerEvictionRun&#125;&quot;</span> /&gt;</span>
        <span class="comment">&lt;!--逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1--&gt;</span>
        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.timeBetweenEvictionRunsMillis&#125;&quot;</span> /&gt;</span>
        <span class="comment">&lt;!--是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个--&gt;</span> 
        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.testOnBorrow&#125;&quot;</span> /&gt;</span> 
        <span class="comment">&lt;!--在空闲时检查有效性, 默认false  --&gt;</span>
        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.testWhileIdle&#125;&quot;</span> /&gt;</span> 
    &lt;/bean &gt;
     
    <span class="comment">&lt;!--redis连接工厂 --&gt;</span>
    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisConnectionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span>
        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;poolConfig&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jedisPoolConfig&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>
        <span class="comment">&lt;!--IP地址 --&gt;</span>
        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hostName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.hostName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>
        <span class="comment">&lt;!--端口号  --&gt;</span>
        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;port&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.port&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>
        <span class="comment">&lt;!--如果Redis设置有密码  --&gt;</span>
        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.password&#125;&quot;</span> /&gt;</span>
        <span class="comment">&lt;!--客户端超时时间单位是毫秒  --&gt;</span>
        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.timeout&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>
    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> 
     
    <span class="comment">&lt;!--redis操作模版,使用该对象可以操作redis  --&gt;</span>
    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;redisTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.core.RedisTemplate&quot;</span></span>
<span class="tag">        <span class="attr">p:connection-factory-ref</span>=<span class="string">&quot;jedisConnectionFactory&quot;</span> &gt;</span> 
        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;keySerializer&quot;</span>&gt;</span>
            <span class="tag">&lt;<span class="name">bean</span></span>
<span class="tag">                <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;</span> /&gt;</span>
        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>
        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hashKeySerializer&quot;</span>&gt;</span>
            <span class="tag">&lt;<span class="name">bean</span></span>
<span class="tag">                <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;</span> /&gt;</span>
        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>
        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;valueSerializer&quot;</span>&gt;</span>
            <span class="tag">&lt;<span class="name">bean</span></span>
<span class="tag">                <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.serializer.JdkSerializationRedisSerializer&quot;</span> /&gt;</span>
        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>
        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hashValueSerializer&quot;</span>&gt;</span>
            <span class="tag">&lt;<span class="name">bean</span></span>
<span class="tag">                <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.serializer.JdkSerializationRedisSerializer&quot;</span> /&gt;</span>
        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>
    &lt;/bean &gt; 
     
    <span class="comment">&lt;!--自定义redis工具类,在需要缓存的地方注入此类  --&gt;</span>
    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;redisUtil&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.how2java.RedisUtil&quot;</span>&gt;</span>
        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;redisTemplate&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;redisTemplate&quot;</span> /&gt;</span>
    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>
     
<span class="tag">&lt;/<span class="name">beans</span>&gt;</span></code></pre>
<h3 id="redisutil"><a class="markdownIt-Anchor" href="#redisutil"></a> RedisUtil</h3>
<ul>
<li>RedisUtil工具类，封装了Redis Template这个类，以提供更为便利的对于Redis的访问</li>
</ul>
<pre><code class="highlight java"><span class="keyword">package</span> com.how2java;
 
<span class="keyword">import</span> java.util.List;
<span class="keyword">import</span> java.util.Map;
<span class="keyword">import</span> java.util.Set;
<span class="keyword">import</span> java.util.concurrent.TimeUnit;
 
<span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;
<span class="keyword">import</span> org.springframework.util.CollectionUtils;
 
<span class="comment">/**</span>
<span class="comment"> * 基于spring和redis的redisTemplate工具类</span>
<span class="comment"> * 针对所有的hash 都是以h开头的方法</span>
<span class="comment"> * 针对所有的Set 都是以s开头的方法                    不含通用方法</span>
<span class="comment"> * 针对所有的List 都是以l开头的方法</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisUtil</span> &#123;
    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;
     
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRedisTemplate</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;
        <span class="built_in">this</span>.redisTemplate = redisTemplate;
    &#125;
    <span class="comment">//=============================common============================</span>
    <span class="comment">/**</span>
<span class="comment">     * 指定缓存失效时间</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span>
<span class="comment">     * <span class="doctag">@return</span></span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">expire</span><span class="params">(String key,<span class="type">long</span> time)</span>&#123;
        <span class="keyword">try</span> &#123;
            <span class="keyword">if</span>(time&gt;<span class="number">0</span>)&#123;
                redisTemplate.expire(key, time, TimeUnit.SECONDS);
            &#125;
            <span class="keyword">return</span> <span class="literal">true</span>;
        &#125; <span class="keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            <span class="keyword">return</span> <span class="literal">false</span>;
        &#125;
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 根据key 获取过期时间</span>
<span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span>
<span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getExpire</span><span class="params">(String key)</span>&#123;
        <span class="keyword">return</span> redisTemplate.getExpire(key,TimeUnit.SECONDS);
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 判断key是否存在</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKey</span><span class="params">(String key)</span>&#123;
        <span class="keyword">try</span> &#123;
            <span class="keyword">return</span> redisTemplate.hasKey(key);
        &#125; <span class="keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            <span class="keyword">return</span> <span class="literal">false</span>;
        &#125;
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 删除缓存</span>
<span class="comment">     * <span class="doctag">@param</span> key 可以传一个值 或多个</span>
<span class="comment">     */</span>
    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(String ... key)</span>&#123;
        <span class="keyword">if</span>(key!=<span class="literal">null</span>&amp;&amp;key.length&gt;<span class="number">0</span>)&#123;
            <span class="keyword">if</span>(key.length==<span class="number">1</span>)&#123;
                redisTemplate.delete(key[<span class="number">0</span>]);
            &#125;<span class="keyword">else</span>&#123;
                redisTemplate.delete(CollectionUtils.arrayToList(key));
            &#125;
        &#125;
    &#125;
     
    <span class="comment">//============================String=============================</span>
    <span class="comment">/**</span>
<span class="comment">     * 普通缓存获取</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@return</span> 值</span>
<span class="comment">     */</span>
    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span>&#123;
        <span class="keyword">return</span> key==<span class="literal">null</span>?<span class="literal">null</span>:redisTemplate.opsForValue().get(key);
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 普通缓存放入</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@param</span> value 值</span>
<span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key,Object value)</span> &#123;
         <span class="keyword">try</span> &#123;
            redisTemplate.opsForValue().set(key, value);
            <span class="keyword">return</span> <span class="literal">true</span>;
        &#125; <span class="keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            <span class="keyword">return</span> <span class="literal">false</span>;
        &#125;
         
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 普通缓存放入并设置时间</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@param</span> value 值</span>
<span class="comment">     * <span class="doctag">@param</span> time 时间(秒) time要大于0 如果time小于等于0 将设置无限期</span>
<span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key,Object value,<span class="type">long</span> time)</span>&#123;
        <span class="keyword">try</span> &#123;
            <span class="keyword">if</span>(time&gt;<span class="number">0</span>)&#123;
                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);
            &#125;<span class="keyword">else</span>&#123;
                set(key, value);
            &#125;
            <span class="keyword">return</span> <span class="literal">true</span>;
        &#125; <span class="keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            <span class="keyword">return</span> <span class="literal">false</span>;
        &#125;
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 递增</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@param</span> by 要增加几(大于0)</span>
<span class="comment">     * <span class="doctag">@return</span></span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">incr</span><span class="params">(String key, <span class="type">long</span> delta)</span>&#123; 
        <span class="keyword">if</span>(delta&lt;<span class="number">0</span>)&#123;
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递增因子必须大于0&quot;</span>);
        &#125;
        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 递减</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@param</span> by 要减少几(小于0)</span>
<span class="comment">     * <span class="doctag">@return</span></span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">decr</span><span class="params">(String key, <span class="type">long</span> delta)</span>&#123; 
        <span class="keyword">if</span>(delta&lt;<span class="number">0</span>)&#123;
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递减因子必须大于0&quot;</span>);
        &#125;
        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta); 
    &#125; 
     
    <span class="comment">//================================Map=================================</span>
    <span class="comment">/**</span>
<span class="comment">     * HashGet</span>
<span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span>
<span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span>
<span class="comment">     * <span class="doctag">@return</span> 值</span>
<span class="comment">     */</span>
    <span class="keyword">public</span> Object <span class="title function_">hget</span><span class="params">(String key,String item)</span>&#123;
        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 获取hashKey对应的所有键值</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@return</span> 对应的多个键值</span>
<span class="comment">     */</span>
    <span class="keyword">public</span> Map&lt;Object,Object&gt; <span class="title function_">hmget</span><span class="params">(String key)</span>&#123;
        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * HashSet</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span>
<span class="comment">     * <span class="doctag">@return</span> true 成功 false 失败</span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String,Object&gt; map)</span>&#123; 
        <span class="keyword">try</span> &#123;
            redisTemplate.opsForHash().putAll(key, map);
            <span class="keyword">return</span> <span class="literal">true</span>;
        &#125; <span class="keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            <span class="keyword">return</span> <span class="literal">false</span>;
        &#125;
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * HashSet 并设置时间</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span>
<span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span>
<span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String,Object&gt; map, <span class="type">long</span> time)</span>&#123; 
        <span class="keyword">try</span> &#123;
            redisTemplate.opsForHash().putAll(key, map);
            <span class="keyword">if</span>(time&gt;<span class="number">0</span>)&#123;
                expire(key, time);
            &#125;
            <span class="keyword">return</span> <span class="literal">true</span>;
        &#125; <span class="keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            <span class="keyword">return</span> <span class="literal">false</span>;
        &#125;
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@param</span> item 项</span>
<span class="comment">     * <span class="doctag">@param</span> value 值</span>
<span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key,String item,Object value)</span> &#123;
         <span class="keyword">try</span> &#123;
            redisTemplate.opsForHash().put(key, item, value);
            <span class="keyword">return</span> <span class="literal">true</span>;
        &#125; <span class="keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            <span class="keyword">return</span> <span class="literal">false</span>;
        &#125;
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@param</span> item 项</span>
<span class="comment">     * <span class="doctag">@param</span> value 值</span>
<span class="comment">     * <span class="doctag">@param</span> time 时间(秒)  注意:如果已存在的hash表有时间,这里将会替换原有的时间</span>
<span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key,String item,Object value,<span class="type">long</span> time)</span> &#123;
         <span class="keyword">try</span> &#123;
            redisTemplate.opsForHash().put(key, item, value);
            <span class="keyword">if</span>(time&gt;<span class="number">0</span>)&#123;
                expire(key, time);
            &#125;
            <span class="keyword">return</span> <span class="literal">true</span>;
        &#125; <span class="keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            <span class="keyword">return</span> <span class="literal">false</span>;
        &#125;
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 删除hash表中的值</span>
<span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span>
<span class="comment">     * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hdel</span><span class="params">(String key, Object... item)</span>&#123; 
        redisTemplate.opsForHash().delete(key,item);
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 判断hash表中是否有该项的值</span>
<span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span>
<span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span>
<span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hHasKey</span><span class="params">(String key, String item)</span>&#123;
        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@param</span> item 项</span>
<span class="comment">     * <span class="doctag">@param</span> by 要增加几(大于0)</span>
<span class="comment">     * <span class="doctag">@return</span></span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hincr</span><span class="params">(String key, String item,<span class="type">double</span> by)</span>&#123; 
        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * hash递减</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@param</span> item 项</span>
<span class="comment">     * <span class="doctag">@param</span> by 要减少记(小于0)</span>
<span class="comment">     * <span class="doctag">@return</span></span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hdecr</span><span class="params">(String key, String item,<span class="type">double</span> by)</span>&#123; 
        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item,-by); 
    &#125; 
     
    <span class="comment">//============================set=============================</span>
    <span class="comment">/**</span>
<span class="comment">     * 根据key获取Set中的所有值</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@return</span></span>
<span class="comment">     */</span>
    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sGet</span><span class="params">(String key)</span>&#123;
        <span class="keyword">try</span> &#123;
            <span class="keyword">return</span> redisTemplate.opsForSet().members(key);
        &#125; <span class="keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            <span class="keyword">return</span> <span class="literal">null</span>;
        &#125;
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 根据value从一个set中查询,是否存在</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@param</span> value 值</span>
<span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sHasKey</span><span class="params">(String key,Object value)</span>&#123;
        <span class="keyword">try</span> &#123;
            <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);
        &#125; <span class="keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            <span class="keyword">return</span> <span class="literal">false</span>;
        &#125;
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 将数据放入set缓存</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span>
<span class="comment">     * <span class="doctag">@return</span> 成功个数</span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSet</span><span class="params">(String key, Object...values)</span> &#123;
        <span class="keyword">try</span> &#123;
            <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);
        &#125; <span class="keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            <span class="keyword">return</span> <span class="number">0</span>;
        &#125;
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 将set数据放入缓存</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span>
<span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span>
<span class="comment">     * <span class="doctag">@return</span> 成功个数</span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSetAndTime</span><span class="params">(String key,<span class="type">long</span> time,Object...values)</span> &#123;
        <span class="keyword">try</span> &#123;
            <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().add(key, values);
            <span class="keyword">if</span>(time&gt;<span class="number">0</span>) expire(key, time);
            <span class="keyword">return</span> count;
        &#125; <span class="keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            <span class="keyword">return</span> <span class="number">0</span>;
        &#125;
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 获取set缓存的长度</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@return</span></span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sGetSetSize</span><span class="params">(String key)</span>&#123;
        <span class="keyword">try</span> &#123;
            <span class="keyword">return</span> redisTemplate.opsForSet().size(key);
        &#125; <span class="keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            <span class="keyword">return</span> <span class="number">0</span>;
        &#125;
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 移除值为value的</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span>
<span class="comment">     * <span class="doctag">@return</span> 移除的个数</span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">setRemove</span><span class="params">(String key, Object ...values)</span> &#123;
        <span class="keyword">try</span> &#123;
            <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().remove(key, values);
            <span class="keyword">return</span> count;
        &#125; <span class="keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            <span class="keyword">return</span> <span class="number">0</span>;
        &#125;
    &#125;
    <span class="comment">//===============================list=================================</span>
     
    <span class="comment">/**</span>
<span class="comment">     * 获取list缓存的内容</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@param</span> start 开始</span>
<span class="comment">     * <span class="doctag">@param</span> end 结束  0 到 -1代表所有值</span>
<span class="comment">     * <span class="doctag">@return</span></span>
<span class="comment">     */</span>
    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">lGet</span><span class="params">(String key,<span class="type">long</span> start, <span class="type">long</span> end)</span>&#123;
        <span class="keyword">try</span> &#123;
            <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);
        &#125; <span class="keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            <span class="keyword">return</span> <span class="literal">null</span>;
        &#125;
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 获取list缓存的长度</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@return</span></span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lGetListSize</span><span class="params">(String key)</span>&#123;
        <span class="keyword">try</span> &#123;
            <span class="keyword">return</span> redisTemplate.opsForList().size(key);
        &#125; <span class="keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            <span class="keyword">return</span> <span class="number">0</span>;
        &#125;
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 通过索引 获取list中的值</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@param</span> index 索引  index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span>
<span class="comment">     * <span class="doctag">@return</span></span>
<span class="comment">     */</span>
    <span class="keyword">public</span> Object <span class="title function_">lGetIndex</span><span class="params">(String key,<span class="type">long</span> index)</span>&#123;
        <span class="keyword">try</span> &#123;
            <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);
        &#125; <span class="keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            <span class="keyword">return</span> <span class="literal">null</span>;
        &#125;
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 将list放入缓存</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@param</span> value 值</span>
<span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span>
<span class="comment">     * <span class="doctag">@return</span></span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value)</span> &#123;
        <span class="keyword">try</span> &#123;
            redisTemplate.opsForList().rightPush(key, value);
            <span class="keyword">return</span> <span class="literal">true</span>;
        &#125; <span class="keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            <span class="keyword">return</span> <span class="literal">false</span>;
        &#125;
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 将list放入缓存</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@param</span> value 值</span>
<span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span>
<span class="comment">     * <span class="doctag">@return</span></span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;
        <span class="keyword">try</span> &#123;
            redisTemplate.opsForList().rightPush(key, value);
            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) expire(key, time);
            <span class="keyword">return</span> <span class="literal">true</span>;
        &#125; <span class="keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            <span class="keyword">return</span> <span class="literal">false</span>;
        &#125;
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 将list放入缓存</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@param</span> value 值</span>
<span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span>
<span class="comment">     * <span class="doctag">@return</span></span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> &#123;
        <span class="keyword">try</span> &#123;
            redisTemplate.opsForList().rightPushAll(key, value);
            <span class="keyword">return</span> <span class="literal">true</span>;
        &#125; <span class="keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            <span class="keyword">return</span> <span class="literal">false</span>;
        &#125;
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 将list放入缓存</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@param</span> value 值</span>
<span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span>
<span class="comment">     * <span class="doctag">@return</span></span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value, <span class="type">long</span> time)</span> &#123;
        <span class="keyword">try</span> &#123;
            redisTemplate.opsForList().rightPushAll(key, value);
            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) expire(key, time);
            <span class="keyword">return</span> <span class="literal">true</span>;
        &#125; <span class="keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            <span class="keyword">return</span> <span class="literal">false</span>;
        &#125;
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 根据索引修改list中的某条数据</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@param</span> index 索引</span>
<span class="comment">     * <span class="doctag">@param</span> value 值</span>
<span class="comment">     * <span class="doctag">@return</span></span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lUpdateIndex</span><span class="params">(String key, <span class="type">long</span> index,Object value)</span> &#123;
        <span class="keyword">try</span> &#123;
            redisTemplate.opsForList().set(key, index, value);
            <span class="keyword">return</span> <span class="literal">true</span>;
        &#125; <span class="keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            <span class="keyword">return</span> <span class="literal">false</span>;
        &#125;
    &#125;
     
    <span class="comment">/**</span>
<span class="comment">     * 移除N个值为value</span>
<span class="comment">     * <span class="doctag">@param</span> key 键</span>
<span class="comment">     * <span class="doctag">@param</span> count 移除多少个</span>
<span class="comment">     * <span class="doctag">@param</span> value 值</span>
<span class="comment">     * <span class="doctag">@return</span> 移除的个数</span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lRemove</span><span class="params">(String key,<span class="type">long</span> count,Object value)</span> &#123;
        <span class="keyword">try</span> &#123;
            <span class="type">Long</span> <span class="variable">remove</span> <span class="operator">=</span> redisTemplate.opsForList().remove(key, count, value);
            <span class="keyword">return</span> remove;
        &#125; <span class="keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            <span class="keyword">return</span> <span class="number">0</span>;
        &#125;
    &#125;
     
&#125;</code></pre>
<h3 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h3>
<pre><code class="highlight java"><span class="keyword">package</span> com.how2java;
 
<span class="keyword">import</span> java.util.HashMap;
<span class="keyword">import</span> java.util.Map;
 
<span class="keyword">import</span> org.springframework.context.ApplicationContext;
<span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;
 
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRedis</span> &#123;
     
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;
        ApplicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);
 
        RedisUtil redisUtil=(RedisUtil) context.getBean(<span class="string">&quot;redisUtil&quot;</span>);
         
        <span class="comment">//=====================testString======================</span>
        redisUtil.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;how2java&quot;</span>);
        System.out.println(redisUtil.get(<span class="string">&quot;name&quot;</span>));
        redisUtil.del(<span class="string">&quot;name&quot;</span>);
        System.out.println(redisUtil.get(<span class="string">&quot;name&quot;</span>));
         
        <span class="comment">//=====================testNumber======================</span>
        <span class="type">long</span> <span class="variable">incr</span> <span class="operator">=</span> redisUtil.incr(<span class="string">&quot;number&quot;</span>, <span class="number">1</span>);
        System.out.println(incr);
        incr =redisUtil.incr(<span class="string">&quot;number&quot;</span>, <span class="number">1</span>);
        System.out.println(incr);
         
        <span class="comment">//=====================testMap======================       </span>
        Map&lt;String,Object&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();
        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;meepo&quot;</span>);
        map.put(<span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;password&quot;</span>);
        redisUtil.hmset(<span class="string">&quot;user&quot;</span>, map);
        System.out.println(redisUtil.hget(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;name&quot;</span>));
    &#125;
     
&#125;</code></pre>
<h2 id="redis事务"><a class="markdownIt-Anchor" href="#redis事务"></a> Redis事务</h2>
<h3 id="redis事务介绍"><a class="markdownIt-Anchor" href="#redis事务介绍"></a> Redis事务介绍</h3>
<p>Redis的事务是通过<strong>MULTI，EXEC，DISCARD和WATCH</strong>这四个命令来完成的。</p>
<p>Redis的单个命令都是<strong>原子性</strong>的，所以这里确保事务性的对象是<strong>命令集合</strong>。</p>
<p>Redis将命令集合序列化并确保处于同一事务的<strong>命令集合连续且不被打断</strong>的执行</p>
<p>Redis<strong>不支持回滚</strong>操作</p>
<h3 id="相关命令"><a class="markdownIt-Anchor" href="#相关命令"></a> 相关命令</h3>
<p><strong>multi</strong></p>
<p>用于标记事务块的开始</p>
<p>Redis会将后续的命令逐个放入队列中，然后使用<u>EXEC命令</u>原子化的执行这个命令序列</p>
<p><strong>exec</strong></p>
<p><u>在一个事务中执行所有先前放入队列的命令</u>，然后恢复正常的连接状态</p>
<p><strong>discard</strong></p>
<p><u>清除所有先前在一个事务中放入队列的命令</u>，然后恢复正常的连接状态</p>
<p><strong>watch key [key…]</strong></p>
<p>当某个<strong>事务需要按条件执行时</strong>，就要使用这个命令将给定的<strong>键设置为受监控的状态</strong></p>
<p>注意事项：使用该命令可以实现redis的<strong>乐观锁</strong></p>
<p><strong>unwatch</strong></p>
<p>清除所有先前为一个事务监控的键</p>
<h3 id="事务失败处理"><a class="markdownIt-Anchor" href="#事务失败处理"></a> 事务失败处理</h3>
<p><strong>Redis语法错误</strong>（可以理解为编译期错误）</p>
<ul>
<li>整个事务都不会执行</li>
</ul>
<p><strong>Redis类型错误</strong>（可以理解为运行期错误）</p>
<ul>
<li>正确的命令执行</li>
</ul>
<p>Redis不支持事务回滚</p>
<ul>
<li>大多数事务失败是因为<strong>语法错误或者类型错误</strong>，这两种错误，在开发阶段都是可以预见的</li>
<li>redis为了<strong>性能方面</strong>就忽略了事务回滚</li>
</ul>
<h2 id="redis修改密码"><a class="markdownIt-Anchor" href="#redis修改密码"></a> Redis修改密码</h2>
<p><code>vim /redis-4.0.11/redis.conf</code>中修改下列代码即可</p>
<pre><code class="highlight plaintext">requirepass foobared</code></pre>
<p>保护模式</p>
<pre><code class="highlight plaintext">protected-mode yes</code></pre>
<p>端口</p>
<pre><code class="highlight plaintext">port 6379</code></pre>
<h2 id="redis实现分布式锁"><a class="markdownIt-Anchor" href="#redis实现分布式锁"></a> Redis实现分布式锁</h2>
<h3 id="锁的处理"><a class="markdownIt-Anchor" href="#锁的处理"></a> 锁的处理</h3>
<p>单应用中使用锁：单进程多线程</p>
<ul>
<li><strong>synchronize，lock</strong></li>
</ul>
<p>分布式应用中使用锁，多进程</p>
<h3 id="分布式锁的实现方式"><a class="markdownIt-Anchor" href="#分布式锁的实现方式"></a> 分布式锁的实现方式</h3>
<p>基于数据库的乐观锁实现分布式锁</p>
<p>基于zookeeper临时节点的分布式锁</p>
<p>基于redis的分布式锁</p>
<h3 id="分布式锁的注意事项"><a class="markdownIt-Anchor" href="#分布式锁的注意事项"></a> 分布式锁的注意事项</h3>
<p><strong>互斥性</strong></p>
<p>在任意时刻，只有一个客户端能持有锁</p>
<p><strong>同一性</strong></p>
<p>加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了</p>
<p><strong>可重入性</strong></p>
<p>即使有一个客户端在持有锁的期间奔溃而没有主动解锁，也能保证后续其他客户端能加锁</p>
<h3 id="实现分布式锁"><a class="markdownIt-Anchor" href="#实现分布式锁"></a> 实现分布式锁</h3>
<h4 id="组件依赖"><a class="markdownIt-Anchor" href="#组件依赖"></a> 组件依赖</h4>
<p>首先我们要通过Maven引入Jedis开源组件，在pom.xml文件加入下面的代码：</p>
<pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;<span class="name">version</span>&gt;</span>
<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre>
<h4 id="获取锁"><a class="markdownIt-Anchor" href="#获取锁"></a> 获取锁</h4>
<p><strong>方式一：使用set命令实现</strong>（推荐）</p>
<p>这个set()方法一共有五个形参：</p>
<ul>
<li><strong>第一个为key</strong>，我们使用key来当锁，因为key是唯一的。</li>
<li><strong>第二个为value</strong>，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。</li>
<li><strong>第三个为nxxx</strong>，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li>
<li><strong>第四个为expx</strong>，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</li>
<li><strong>第五个为time</strong>，与第四个参数相呼应，代表key的过期时间。</li>
</ul>
<p>总的来说，执行上面的set()方法就只会导致两种结果：</p>
<ol>
<li>当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。</li>
<li>已有锁存在，不做任何操作。</li>
</ol>
<p>心细的童鞋就会发现了，我们的加锁代码满足我们可靠性里描述的三个条件。</p>
<ul>
<li>首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。</li>
<li>其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。</li>
<li>最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。</li>
</ul>
<blockquote>
<p>由于我们只考虑Redis单机部署的场景，所以容错性我们暂不考虑。</p>
</blockquote>
<pre><code class="highlight java"><span class="comment">/**</span>
<span class="comment"> * 使用redis的set命令实现获取分布式锁</span>
<span class="comment"> * <span class="doctag">@param</span> lockKey   	可以就是锁</span>
<span class="comment"> * <span class="doctag">@param</span> requestId		请求ID，保证同一性</span>
<span class="comment"> * <span class="doctag">@param</span> expireTime	过期时间，避免死锁</span>
<span class="comment"> * <span class="doctag">@return</span></span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">getLock</span><span class="params">(String lockKey,String requestId,<span class="type">int</span> expireTime)</span> &#123;
	<span class="comment">//NX:保证互斥性</span>
    <span class="comment">//参数三：NX/XX  存在设置键/不存在设置建</span>
    <span class="comment">//参数四：EX/PX  秒/毫秒</span>
    <span class="comment">//参数五：毫秒时间</span>
	<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, expireTime);
	<span class="keyword">if</span>(<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;
		<span class="keyword">return</span> <span class="literal">true</span>;
	&#125;
	
	<span class="keyword">return</span> <span class="literal">false</span>;
&#125;
</code></pre>
<p><strong>方式二：使用setnx命令实现</strong></p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">getLock</span><span class="params">(String lockKey,String requestId,<span class="type">int</span> expireTime)</span> &#123;
	<span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> jedis.setnx(lockKey, requestId);
	<span class="keyword">if</span>(result == <span class="number">1</span>) &#123;
        <span class="comment">//设置有效期</span>
		jedis.expire(lockKey, expireTime);
		<span class="keyword">return</span> <span class="literal">true</span>;
	&#125;
	
	<span class="keyword">return</span> <span class="literal">false</span>;
&#125;</code></pre>
<h4 id="释放锁"><a class="markdownIt-Anchor" href="#释放锁"></a> 释放锁</h4>
<p><strong>方式一：del命令实现</strong></p>
<pre><code class="highlight java"><span class="comment">/**</span>
<span class="comment"> * 释放分布式锁</span>
<span class="comment"> * <span class="doctag">@param</span> lockKey</span>
<span class="comment"> * <span class="doctag">@param</span> requestId</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">(String lockKey,String requestId)</span> &#123;
    <span class="keyword">if</span> (requestId.equals(jedis.get(lockKey))) &#123;
	jedis.del(lockKey);
    &#125;
&#125;
</code></pre>
<p><strong>方式二：redis+lua脚本实现</strong>（推荐）</p>
<p>可以看到，我们解锁只需要两行代码就搞定了！</p>
<ul>
<li>第一行代码，我们写了一个简单的Lua脚本代码，上一次见到这个编程语言还是在《黑客与画家》里，没想到这次居然用上了。</li>
<li>第二行代码，我们将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。eval()方法是将Lua代码交给Redis服务端执行。</li>
</ul>
<p>那么这段Lua代码的功能是什么呢？</p>
<ul>
<li>其实很简单，首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。</li>
</ul>
<p>那么为什么要使用Lua语言来实现呢？</p>
<ul>
<li>因为要确保上述操作是原子性的。<br />
那么为什么执行eval()方法可以确保原子性，源于Redis的特性，下面是官网对eval命令的部分解释：简单来说，就是在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。</li>
</ul>
<pre><code class="highlight java">   <span class="comment">/**</span>
<span class="comment">     * 释放分布式锁</span>
<span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span>
<span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span>
<span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span>
<span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span>
<span class="comment">     */</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">releaseLock</span><span class="params">(String lockKey, String requestId)</span> &#123;
	<span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;
	<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));

	<span class="keyword">if</span> (result.equals(<span class="number">1L</span>)) &#123;
		<span class="keyword">return</span> <span class="literal">true</span>;
	&#125;
	<span class="keyword">return</span> <span class="literal">false</span>;
&#125;</code></pre>
<h2 id="redis持久化方案"><a class="markdownIt-Anchor" href="#redis持久化方案"></a> Redis持久化方案</h2>
<p>Redis是一个<strong>内存</strong>数据库，为了保证数据的持久新，它提供了两种持久化方案</p>
<ul>
<li>REB方式（默认）</li>
<li>AOF方式</li>
</ul>
<h3 id="rdb方式"><a class="markdownIt-Anchor" href="#rdb方式"></a> RDB方式</h3>
<p>RDB是Redis<strong>默认</strong>采用的持久化方式。</p>
<p>RDB方式是通过<strong>快照</strong>（snapshotting）完成的，当<strong>符合一定条件</strong>时Redis会自动将内存中的数据进行快照并持久化到硬盘</p>
<p>Redis会在<strong>指定的情况</strong>下触发快照</p>
<ul>
<li><strong>符合自定义配置的快照规则</strong></li>
<li><strong>执行save或者bgsave命令</strong></li>
<li><strong>执行flushall命令</strong></li>
<li><strong>执行主从复制操作</strong></li>
</ul>
<h4 id="配置步骤"><a class="markdownIt-Anchor" href="#配置步骤"></a> 配置步骤</h4>
<p>在<strong>redis.conf</strong>中设置自定义快照规则</p>
<p><strong>1.RDB持久化条件</strong></p>
<pre><code class="highlight plaintext">save &lt;seconds&gt; &lt;changes&gt;</code></pre>
<p>示例：</p>
<ul>
<li>save 900 1  ： 表示15分钟（900秒钟）内至少1个键被更改则进行快照。</li>
<li>save 300 10 ： 表示5分钟（300秒）内至少10个键被更改则进行快照。</li>
<li>save 60 10000 ：表示1分钟内至少10000个键被更改则进行快照</li>
</ul>
<blockquote>
<p>可以<strong>配置多个条件</strong>（每行配置一个条件），每个条件之间是“<strong>或</strong>”的关系</p>
</blockquote>
<p><strong>2.配置dir指定rdb快照文件的位置</strong></p>
<pre><code class="highlight plaintext"># Note that you must specify a directory here, not a file name.

dir ./</code></pre>
<p><strong>3.配置dbfilename指定rdb快照文件的名称</strong></p>
<pre><code class="highlight plaintext"># The filename where to dump the DB

dbfilename dump.rdb</code></pre>
<blockquote>
<p>Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。</p>
</blockquote>
<blockquote>
<p>根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟</p>
</blockquote>
<p><strong>关闭方式</strong></p>
<p>注释掉下面的三行代码即可</p>
<pre><code class="highlight plaintext">save 900 1
save 300 10
save 60 10000</code></pre>
<h4 id="快照的实现原理"><a class="markdownIt-Anchor" href="#快照的实现原理"></a> 快照的实现原理</h4>
<p><strong>快照过程</strong></p>
<p>redis使用fork函数<strong>复制</strong>一份当前进程的<strong>副本</strong>(子进程)</p>
<p><strong>父进程</strong>继续接收并处理客户端发来的命令，而<strong>子进程</strong>开始将内存中的数据写入硬盘中的临时文件。</p>
<p>当子进程写入完所有数据后会<strong>用该临时文件替换旧的RDB文件</strong>，至此，一次快照操作完成</p>
<p><strong>注意事项</strong></p>
<blockquote>
<p>redis在进行<strong>快照的过程中不会修改RDB文件</strong>，只有快照结束后才会将旧的文件替换成新的，也就是说任何时候RDB文件都是完整的。</p>
</blockquote>
<blockquote>
<p>这就使得我们可以通过定时备份RDB文件来实现redis数据库的备份，<strong>RDB文件是经过压缩的二进制文件</strong>，占用的空间会小于内存中的数据，更加利于传输</p>
</blockquote>
<h4 id="rdb的优缺点"><a class="markdownIt-Anchor" href="#rdb的优缺点"></a> RDB的优缺点</h4>
<p><strong>缺点</strong></p>
<p>使用RDB方式实现持久化，一旦Redis异常退出，就会<strong>丢失最后一次快照以后更改的所有数据</strong>。这个时候我们就需要根据具体的应用场景，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受范围。如果数据相对来说比较重要，希望将损失降到最小，则可以使用<strong>AOF</strong>方式进行持久化</p>
<p><strong>优点</strong></p>
<p>RDB可以最大化Redis的性能：父进程在保存RDB文件时唯一要做的就是fork出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无序执行任何磁盘I/O操作。同时这个也是一个缺点，如果数据集比较大的时候，fork可以能比较耗时，造成服务器在一段时间内停止处理客户端的请求</p>
<h3 id="aof方式"><a class="markdownIt-Anchor" href="#aof方式"></a> AOF方式</h3>
<p>默认情况下Redis没有开启AOF（append only file）方式的持久化</p>
<p>开启AOF持久化后每执行一条<strong>会更改Redis中的数据的命令</strong>，Redis就会将该命令写入硬盘中的AOF文件，这一过程显然会<strong>降低Redis的性能</strong>，但大部分情况下这个影响是能够接受的，另外使<strong>用较快的硬盘可以提高AOF的性能</strong></p>
<h4 id="开启方式"><a class="markdownIt-Anchor" href="#开启方式"></a> 开启方式</h4>
<p>可以通过修改<strong>redis.conf</strong>配置文件中的appendonly参数开启</p>
<pre><code class="highlight plaintext">appendonly yes</code></pre>
<p>AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的</p>
<pre><code class="highlight plaintext">dir ./</code></pre>
<p>默认的文件名是appendonly.aof，可以通过appendfilename参数修改</p>
<pre><code class="highlight plaintext">appendfilename appendonly.aof</code></pre>
<h4 id="aof重写原理优化aof文件"><a class="markdownIt-Anchor" href="#aof重写原理优化aof文件"></a> AOF重写原理（优化AOF文件）</h4>
<p>Redis 可以在 AOF<strong>文件体积变得过大</strong>时，自动地在后台对 AOF 进行<strong>重写</strong></p>
<p>重写后的新 AOF 文件包含了恢复当前数据集所需的<strong>最小命令集合</strong>。</p>
<p>整个重写操作是绝对安全的，因为 Redis 在创建<strong>新 AOF 文件的</strong>过程中，会继续将命令追加到<strong>现有的 AOF 文件</strong>里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦<strong>新 AOF 文件</strong>创建完毕，Redis 就会从旧 AOF 文件<strong>切换</strong>到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</p>
<p>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松</p>
<p><strong>参数说明</strong></p>
<p>表示当前aof文件大小超过上一次aof文件大小的百分之多少的时候会进行重写。如果之前没有重写过，以启动时aof文件大小为准</p>
<pre><code class="highlight plaintext"># auto-aof-rewrite-percentage 100</code></pre>
<p>限制允许重写最小aof文件大小，也就是文件大小小于64mb的时候，不需要进行优化</p>
<pre><code class="highlight plaintext"># auto-aof-rewrite-min-size 64mb</code></pre>
<h4 id="同步磁盘数据"><a class="markdownIt-Anchor" href="#同步磁盘数据"></a> 同步磁盘数据</h4>
<p>Redis每次更改数据的时候， aof机制都会将命令记录到aof文件，但是实际上由于操作系统的缓存机制，数据并没有实时写入到硬盘，而是进入硬盘缓存。再通过硬盘缓存机制去刷新到保存到文件</p>
<p><strong>参数说明</strong></p>
<p>每次执行写入都会进行同步  ， 这个是最安全但是是效率比较低的方式</p>
<pre><code class="highlight plaintext">appendfsync always</code></pre>
<p>每一秒执行（推荐）</p>
<pre><code class="highlight plaintext">appendfsync everysec</code></pre>
<p>不主动进行同步操作，由操作系统去执行，这个是最快但是最不安全的方式</p>
<pre><code class="highlight plaintext">appendfsync no</code></pre>
<h4 id="aof文件损坏后如何修复"><a class="markdownIt-Anchor" href="#aof文件损坏后如何修复"></a> AOF文件损坏后如何修复</h4>
<p>服务器可能在程序正在对 AOF 文件进行写入时停机， 如果停机造成了 AOF 文件出错（corrupt）， 那么 Redis 在重启时会拒绝载入这个 AOF 文件， 从而确保数据的一致性不会被破坏</p>
<p><strong>当发生这种情况时， 可以用以下方法来修复出错的 AOF 文件：</strong></p>
<ol>
<li>
<p>为现有的 AOF 文件创建一个备份。</p>
</li>
<li>
<p>使用 Redis 附带的 redis-check-aof 程序，对原来的 AOF 文件进行修复。</p>
</li>
</ol>
<pre><code class="highlight plaintext">redis-check-aof --fix readonly.aof</code></pre>
<ol start="3">
<li>重启 Redis 服务器，等待服务器载入修复后的 AOF 文件，并进行数据恢复</li>
</ol>
<h3 id="如何选择rdb和aof"><a class="markdownIt-Anchor" href="#如何选择rdb和aof"></a> 如何选择RDB和AOF</h3>
<p>一般来说,如果对数据的安全性要求非常高的话，应该同时使用两种持久化功能。</p>
<p>如果可以承受数分钟以内的数据丢失，那么可以只使用 RDB 持久化。</p>
<p>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快 。</p>
<p>两种持久化策略可以同时使用，也可以使用其中一种。如果同时使用的话， 那么Redis重启时，会优先使用AOF文件来还原数据</p>
<h2 id="redis主从复制"><a class="markdownIt-Anchor" href="#redis主从复制"></a> Redis主从复制</h2>
<p><strong>从机 只可以读，不可以写</strong></p>
<p>持久化保证了即使redis服务重启也不会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，不过通过redis的主从复制机制就可以避免这种单点故障</p>
<p>说明：</p>
<ul>
<li>
<p>主redis中的数据有两个副本（replication）即从redis1和从redis2，即使一台redis服务器宕机其它两台redis服务也可以继续提供服务。</p>
</li>
<li>
<p>主redis中的数据和从redis上的数据保持实时同步，当<strong>主redis写入数据时通过主从复制机制会复制到两个从redis服务上</strong>。</p>
</li>
<li>
<p>只有一个主redis，可以有多个从redis。</p>
</li>
<li>
<p>主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求</p>
</li>
<li>
<p>一个redis可以即是主又是从，如下图：</p>
</li>
</ul>
<h3 id="主从配置"><a class="markdownIt-Anchor" href="#主从配置"></a> 主从配置</h3>
<p><strong>主redis配置</strong></p>
<p>无需特殊的配置</p>
<p><strong>从redis配置（从机只可读）</strong></p>
<p>修改从服务器上的redis.conf文件</p>
<pre><code class="highlight plaintext"># slaveof &lt;masterip&gt; &lt;masterport&gt;

slaveof 192.168.101.3 6379</code></pre>
<blockquote>
<p>上边的配置说明当前【从服务器】对应的【主服务器】的IP是192.168.101.3，端口是6379</p>
</blockquote>
<h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3>
<ol>
<li>
<p>slave第一次或者重连到master上以后，会向master发送一个<strong>SYNC</strong>的命令</p>
</li>
<li>
<p>master收到SYNC的时候，会做两件事<br />
a)    执行<strong>bgsave</strong>（rdb的快照文件）<br />
b)    master会把新收到的修改命令存入到缓冲区</p>
</li>
</ol>
<blockquote>
<p>缺点：<strong>没有办法对master进行动态选举</strong>(使用哨兵实现)</p>
</blockquote>
<hr />
<p>Redis的主从同步，分为<strong>全量同步</strong>和<strong>增量同步</strong>。</p>
<p>只有从机第一次连接上主机是全量同步</p>
<p>断线重连有可能触发全量同步也有可能是增量同步（master判断runid是否一致）</p>
<p>除此之外的情况都是增量同步</p>
<h4 id="全量同步"><a class="markdownIt-Anchor" href="#全量同步"></a> 全量同步</h4>
<p>Redis的全量同步过程主要分三个阶段：</p>
<ul>
<li>
<p>同步快照阶段：Master创建并发送<strong>快照</strong>给Slave,Slave载入并解析快照。Master同时将此阶段所产生的新的写命令存储到缓冲区。</p>
</li>
<li>
<p>同步写缓冲阶段：Master向Slave同步存储在缓冲区的写操作命令。</p>
</li>
<li>
<p>同步增量阶段：Master向Slave同步写操作命令。</p>
</li>
</ul>
<h4 id="增量同步"><a class="markdownIt-Anchor" href="#增量同步"></a> 增量同步</h4>
<ul>
<li>
<p>Redis增量同步主要指<strong>Slave完成初始化后开始正常工作</strong>时，<strong>Master发生的写操作同步到Slave的过程</strong>。</p>
</li>
<li>
<p>通常情况下，Master每执行一个写命令就会向Slave发送相同的<strong>写命令</strong>，然后Slave接收并执行。</p>
</li>
</ul>
<h2 id="redis-sentinel哨兵机制"><a class="markdownIt-Anchor" href="#redis-sentinel哨兵机制"></a> Redis Sentinel哨兵机制</h2>
<p><strong>Redis主从复制的缺点：没有办法对master进行动态选举，需要使用Sentinel机制完成动态选举</strong></p>
<p>Sentinel(哨兵)进程是用于<strong>监控redis集群中Master主服务器工作的状态</strong></p>
<p>在Master主服务器发生故障的时候，可以实现Master和Slave服务器的切换，保证系统的高可用（HA）</p>
<p>其已经被集成在redis2.6+的版本中，Redis的哨兵模式到了2.8版本之后就稳定了下来</p>
<h3 id="哨兵进程的作用"><a class="markdownIt-Anchor" href="#哨兵进程的作用"></a> 哨兵进程的作用</h3>
<p><strong>监控(Monitoring）</strong>: 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。</p>
<p><strong>提醒(Notification）</strong>： 当被监控的某个Redis节点出现问题时, 哨兵(sentinel) 可以通过API 向管理员或者其他应用程序发送通知。</p>
<p><strong>自动故障迁移(Automatic failover）</strong>：当一个Master不能正常工作时，哨兵(sentinel)<br />
会开始一次自动故障迁移操作。</p>
<ul>
<li>
<p>它会将失效Master的其中一个Slave升级为新的Master, 并让失效Master的其他Slave改为复制新的Master；</p>
</li>
<li>
<p>当客户端试图连接失效的Master时，集群也会向客户端返回新Master的地址，使得集群可以使用现在的Master替换失效Master。</p>
</li>
<li>
<p>Master和Slave服务器切换后，Master的redis.conf、Slave的redis.conf和sentinel.conf的配置文件的内容都会发生相应的改变，即，Master主服务器的redis.conf配置文件中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换。</p>
</li>
</ul>
<h3 id="哨兵进程的工作原理"><a class="markdownIt-Anchor" href="#哨兵进程的工作原理"></a> 哨兵进程的工作原理</h3>
<ol>
<li>
<p>每个Sentinel（哨兵）进程以<strong>每秒钟一次</strong>的频率向整个集群中的<strong>Master主服务器</strong>，<strong>Slave从服务器以及其他Sentinel（哨兵）进程</strong>发送一个 <strong>PING</strong> 命令。</p>
</li>
<li>
<p>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过<br />
<code>down-after-milliseconds</code> 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进<strong>程标记为主观下线（SDOWN）</strong>。</p>
</li>
<li>
<p>如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的<strong>所有 Sentinel（哨兵）<strong>进程要以每秒一次的频率</strong>确认Master主服务器</strong>的确<strong>进入了主观下线状态</strong>。</p>
</li>
<li>
<p>当<strong>有足够数量的 Sentinel（哨兵）进程</strong>（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为<strong>客观下线（ODOWN）</strong>。</p>
</li>
<li>
<p>在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。</p>
</li>
<li>
<p>当Master主服务器被 Sentinel（哨兵）进程标记为**客观下线（ODOWN）**时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</p>
</li>
<li>
<p>若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。</p>
</li>
</ol>
<h3 id="开启方式-2"><a class="markdownIt-Anchor" href="#开启方式-2"></a> 开启方式</h3>
<p><strong>修改从机(从机主机都可以)的sentinel.conf</strong></p>
<blockquote>
<p>sentinel.conf该文件需要从redis解压包中找到并拷贝到redis安装目录</p>
</blockquote>
<blockquote>
<p>哨兵的端口默认26379</p>
</blockquote>
<p><code>master ip</code>：主机的ip地址<br />
<code>master-name</code>：reids的名字（非必须）<br />
<code>quorum</code>：表示投票后，执行命令的最少人数</p>
<pre><code class="highlight shell"><span class="meta prompt_">#</span><span class="language-bash">sentinel monitor &lt;master-name&gt; &lt;master ip&gt; &lt;master port&gt; &lt;quorum&gt;</span>

sentinel monitor mymaster 192.168.10.133 6379 1</code></pre>
<p>其他配置项说明</p>
<pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">Example sentinel.conf</span>
<span class="meta prompt_"></span>
<span class="meta prompt_"># </span><span class="language-bash">哨兵sentinel实例运行的端口 默认26379</span>
port 26379
<span class="meta prompt_"></span>
<span class="meta prompt_"># </span><span class="language-bash">哨兵sentinel的工作目录</span>
dir /tmp
<span class="meta prompt_"></span>
<span class="meta prompt_"># </span><span class="language-bash">哨兵sentinel监控的redis主节点的 ip port</span> 
<span class="meta prompt_"># </span><span class="language-bash">master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符<span class="string">&quot;.-_&quot;</span>组成。</span>
<span class="meta prompt_"># </span><span class="language-bash">quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span>
<span class="meta prompt_"># </span><span class="language-bash">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span>
  sentinel monitor mymaster 127.0.0.1 6379 2
<span class="meta prompt_"></span>
<span class="meta prompt_"># </span><span class="language-bash">当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span>
<span class="meta prompt_"># </span><span class="language-bash">设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span>
<span class="meta prompt_"># </span><span class="language-bash">sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span>
sentinel auth-pass mymaster MySUPER--secret-0123passw0rd
<span class="meta prompt_"></span>
<span class="meta prompt_"></span>
<span class="meta prompt_"># </span><span class="language-bash">指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span>
<span class="meta prompt_"># </span><span class="language-bash">sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span>
sentinel down-after-milliseconds mymaster 30000

<span class="meta prompt_"> </span>
<span class="meta prompt_"></span>
<span class="meta prompt_"># </span><span class="language-bash">这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span>
<span class="meta prompt_"># </span><span class="language-bash">sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span>
sentinel parallel-syncs mymaster 1
<span class="meta prompt_"></span>
<span class="meta prompt_"></span>
<span class="meta prompt_"># </span><span class="language-bash">故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span> 
<span class="meta prompt_">#</span><span class="language-bash">1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span>
<span class="meta prompt_">#</span><span class="language-bash">2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span>
<span class="meta prompt_">#</span><span class="language-bash">3.当想要取消一个正在进行的failover所需要的时间。</span>  
<span class="meta prompt_">#</span><span class="language-bash">4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span>
<span class="meta prompt_"># </span><span class="language-bash">默认三分钟</span>
<span class="meta prompt_"># </span><span class="language-bash">sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span>
sentinel failover-timeout mymaster 180000
<span class="meta prompt_"></span>
<span class="meta prompt_"># </span><span class="language-bash">SCRIPTS EXECUTION</span>
<span class="meta prompt_">#</span><span class="language-bash">配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span>
<span class="meta prompt_">#</span><span class="language-bash">对于脚本的运行结果有以下规则：</span>
<span class="meta prompt_">#</span><span class="language-bash">若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span>
<span class="meta prompt_">#</span><span class="language-bash">若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span>
<span class="meta prompt_">#</span><span class="language-bash">如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span>
<span class="meta prompt_">#</span><span class="language-bash">一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span>
<span class="meta prompt_"></span>
<span class="meta prompt_">#</span><span class="language-bash">通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span>
<span class="meta prompt_"></span>
<span class="meta prompt_">#</span><span class="language-bash">通知脚本</span>
<span class="meta prompt_"># </span><span class="language-bash">sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span>
  sentinel notification-script mymaster /var/redis/notify.sh
<span class="meta prompt_"></span>
<span class="meta prompt_"># </span><span class="language-bash">客户端重新配置主节点参数脚本</span>
<span class="meta prompt_"># </span><span class="language-bash">当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span>
<span class="meta prompt_"># </span><span class="language-bash">以下参数将会在调用脚本时传给脚本:</span>
<span class="meta prompt_"># </span><span class="language-bash">&lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span>
<span class="meta prompt_"># </span><span class="language-bash">目前&lt;state&gt;总是“failover”,</span>
<span class="meta prompt_"># </span><span class="language-bash">&lt;role&gt;是“leader”或者“observer”中的一个。</span> 
<span class="meta prompt_"># </span><span class="language-bash">参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span>
<span class="meta prompt_"># </span><span class="language-bash">这个脚本应该是通用的，能被多次调用，不是针对性的。</span>
<span class="meta prompt_"># </span><span class="language-bash">sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span>
 sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</code></pre>
<p><strong>通过redis-sentinel启动</strong>哨兵服务</p>
<pre><code class="highlight plaintext">./redis-sentinel sentinel.conf</code></pre>
<blockquote>
<p>可以使用<code>info replication</code>命令查看当前主机redis的属性</p>
</blockquote>
<h2 id="redis-cluster集群"><a class="markdownIt-Anchor" href="#redis-cluster集群"></a> Redis Cluster集群</h2>
<p>redis3.0以后推出的redis cluster 集群方案，redis cluster集群保证了高可用、高性能、高可扩展性</p>
<p>redis cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份，当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点(<strong>Redis Cluster有内置复用哨兵的部分代码，不用单独开启哨兵进程</strong>)，从而保证集群不会挂掉</p>
<blockquote>
<p>Redis Cluster不用单独的配置主从，也不用单独的配置哨兵</p>
</blockquote>
<h3 id="redis-cluster架构图"><a class="markdownIt-Anchor" href="#redis-cluster架构图"></a> Redis Cluster架构图</h3>
<p>架构细节:<br />
(1) 所有的redis节点彼此互联(<strong>PING-PONG机制</strong>),内部使用二进制协议优化传输速度和带宽.<br />
(2) 节点的fail是通过集群中超过半数的节点检测失效时才生效.<br />
(3) 客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可<br />
(4) redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护<br />
<strong>node &lt; -&gt; slot&lt;-&gt;value</strong><br />
redis节点&lt;-&gt;槽&lt;-&gt;值</p>
<blockquote>
<p><strong>在创建redis cluster的时候，需要根据redis的节点数分配槽</strong></p>
</blockquote>
<blockquote>
<p>Redis 集群中内置了 <strong>16384 个哈希槽</strong>，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点</p>
</blockquote>
<h3 id="redis-cluster投票容错"><a class="markdownIt-Anchor" href="#redis-cluster投票容错"></a> Redis Cluster投票：容错</h3>
<p>最小节点数：<strong>3台</strong></p>
<p>(1)<strong>节点失效判断</strong>：集群中所有master参与投票,如果<u>半数以上master节点</u>与其中一个master节点通信超过(<u>cluster-node-timeout</u>超时时间    ),认为该master节点挂掉.<br />
(2)<strong>集群失效判断</strong>:什么时候整个集群不可用(cluster_state:fail)?</p>
<ul>
<li>如果集群任意master挂掉,且当前master没有slave，则集群进入fail状态。也可以理解成集群的[0-16383]slot映射不完全时进入fail状态。</li>
<li>如果集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态</li>
</ul>
<h3 id="安装ruby环境"><a class="markdownIt-Anchor" href="#安装ruby环境"></a> 安装Ruby环境</h3>
<p>redis集群需要使用集群<strong>管理脚本redis-trib.rb</strong>，它的执行相应依赖ruby环境</p>
<ol>
<li>安装ruby</li>
</ol>
<pre><code class="highlight plaintext">yum install ruby
yum install rubygems</code></pre>
<ol start="2">
<li>安装ruby和redis的接口程序redis-3.2.2.gem</li>
</ol>
<pre><code class="highlight plaintext">gem install redis -V 3.2.2</code></pre>
<ol start="3">
<li>复制redis-3.2.9/src/redis-trib.rb文件到/usr/local/redis目录</li>
</ol>
<pre><code class="highlight plaintext">cp redis-3.2.9/src/redis-trib.rb /usr/local/redis-cluster/ -r</code></pre>
<h3 id="安装redis集群"><a class="markdownIt-Anchor" href="#安装redis集群"></a> 安装Redis集群</h3>
<p>Redis集群最少需要<strong>三台主服务器，三台从服务器</strong>。</p>
<p><em>因为我们没有6太服务器，所以就是用一台机器的不同端口号来演示，实际上是6太机器，端口号相同，ip地址不同</em></p>
<p>端口号分别为：<strong>7001~7006</strong></p>
<blockquote>
<p><strong>注意事项</strong>：6个节点必须是空的，没有任何的数据</p>
</blockquote>
<p><strong>第一步</strong>：创建7001实例，并编辑redis.conf文件，修改port为7001。</p>
<blockquote>
<p>注意：创建实例，即拷贝单机版安装时，生成的bin目录，为7001目录</p>
</blockquote>
<p><strong>第二步</strong>：修改redis.conf配置文件，打开<code>Cluster-enable yes</code></p>
<p><strong>第三步</strong>：复制7001，创建7002~7006实例，<strong>注意端口修改</strong>。</p>
<p><strong>第四步</strong>：启动所有的实例</p>
<ul>
<li>可以写一个一键启动的脚本<code>start-all.sh</code></li>
</ul>
<p><strong>第五步</strong>：创建Redis集群（在redis-cluster<br />
目录下）</p>
<ul>
<li>create表示创建集群</li>
<li>–replicas表示主从复制的副本数，1表示一主一从，2表示一主两从，3表示一主三从</li>
<li>该示例前边三个是主节点，后面三个是从节点</li>
<li>执行命令后<code>./redis-trib.rb create --replicas 1</code> 后续还需输入 <code>yes</code></li>
</ul>
<pre><code class="highlight plaintext">./redis-trib.rb create --replicas 1 192.168.10.133:7001 192.168.10.133:7002 192.168.10.133:7003 192.168.10.133:7004 192.168.10.133:7005  192.168.10.133:7006
&gt;&gt;&gt; Creating cluster
Connecting to node 192.168.10.133:7001: OK
Connecting to node 192.168.10.133:7002: OK
Connecting to node 192.168.10.133:7003: OK
Connecting to node 192.168.10.133:7004: OK
Connecting to node 192.168.10.133:7005: OK
Connecting to node 192.168.10.133:7006: OK
&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...
Using 3 masters:
192.168.10.133:7001
192.168.10.133:7002
192.168.10.133:7003
Adding replica 192.168.10.133:7004 to 192.168.10.133:7001
Adding replica 192.168.10.133:7005 to 192.168.10.133:7002
Adding replica 192.168.10.133:7006 to 192.168.10.133:7003
M: d8f6a0e3192c905f0aad411946f3ef9305350420 192.168.10.133:7001
   slots:0-5460 (5461 slots) master
M: 7a12bc730ddc939c84a156f276c446c28acf798c 192.168.10.133:7002
   slots:5461-10922 (5462 slots) master
M: 93f73d2424a796657948c660928b71edd3db881f 192.168.10.133:7003
   slots:10923-16383 (5461 slots) master
S: f79802d3da6b58ef6f9f30c903db7b2f79664e61 192.168.10.133:7004
   replicates d8f6a0e3192c905f0aad411946f3ef9305350420
S: 0bc78702413eb88eb6d7982833a6e040c6af05be 192.168.10.133:7005
   replicates 7a12bc730ddc939c84a156f276c446c28acf798c
S: 4170a68ba6b7757e914056e2857bb84c5e10950e 192.168.10.133:7006
   replicates 93f73d2424a796657948c660928b71edd3db881f
Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes
&gt;&gt;&gt; Nodes configuration updated
&gt;&gt;&gt; Assign a different config epoch to each node
&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster
Waiting for the cluster to join....
&gt;&gt;&gt; Performing Cluster Check (using node 192.168.10.133:7001)
M: d8f6a0e3192c905f0aad411946f3ef9305350420 192.168.10.133:7001
   slots:0-5460 (5461 slots) master
M: 7a12bc730ddc939c84a156f276c446c28acf798c 192.168.10.133:7002
   slots:5461-10922 (5462 slots) master
M: 93f73d2424a796657948c660928b71edd3db881f 192.168.10.133:7003
   slots:10923-16383 (5461 slots) master
M: f79802d3da6b58ef6f9f30c903db7b2f79664e61 192.168.10.133:7004
   slots: (0 slots) master
   replicates d8f6a0e3192c905f0aad411946f3ef9305350420
M: 0bc78702413eb88eb6d7982833a6e040c6af05be 192.168.10.133:7005
   slots: (0 slots) master
   replicates 7a12bc730ddc939c84a156f276c446c28acf798c
M: 4170a68ba6b7757e914056e2857bb84c5e10950e 192.168.10.133:7006
   slots: (0 slots) master
   replicates 93f73d2424a796657948c660928b71edd3db881f
[OK] All nodes agree about slots configuration.
&gt;&gt;&gt; Check for open slots...
&gt;&gt;&gt; Check slots coverage...
[OK] All 16384 slots covered.
[root@localhost-0723 redis]#</code></pre>
<h3 id="命令客户端连接集群"><a class="markdownIt-Anchor" href="#命令客户端连接集群"></a> 命令客户端连接集群</h3>
<pre><code class="highlight plaintext">./redis-cli –h 127.0.0.1 –p 7001 –c</code></pre>
<blockquote>
<p>注意：-c 表示是以redis集群方式进行连接</p>
</blockquote>
<pre><code class="highlight shell">./redis-cli -p 7006 -c
127.0.0.1:7006&gt; set key1 123
<span class="meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [9189] located at 127.0.0.1:7002</span>
OK
127.0.0.1:7002&gt;</code></pre>
<h3 id="查看集群命令"><a class="markdownIt-Anchor" href="#查看集群命令"></a> 查看集群命令</h3>
<p>查看集群状态</p>
<pre><code class="highlight plaintext">127.0.0.1:7003&gt; cluster info
cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:6
cluster_size:3
cluster_current_epoch:6
cluster_my_epoch:3
cluster_stats_messages_sent:926
cluster_stats_messages_received:926</code></pre>
<p>查看集群中的节点</p>
<pre><code class="highlight plaintext">127.0.0.1:7003&gt; cluster nodes
7a12bc730ddc939c84a156f276c446c28acf798c 127.0.0.1:7002 master - 0 1443601739754 2 connected 5461-10922
93f73d2424a796657948c660928b71edd3db881f 127.0.0.1:7003 myself,master - 0 0 3 connected 10923-16383
d8f6a0e3192c905f0aad411946f3ef9305350420 127.0.0.1:7001 master - 0 1443601741267 1 connected 0-5460
4170a68ba6b7757e914056e2857bb84c5e10950e 127.0.0.1:7006 slave 93f73d2424a796657948c660928b71edd3db881f 0 1443601739250 6 connected
f79802d3da6b58ef6f9f30c903db7b2f79664e61 127.0.0.1:7004 slave d8f6a0e3192c905f0aad411946f3ef9305350420 0 1443601742277 4 connected
0bc78702413eb88eb6d7982833a6e040c6af05be 127.0.0.1:7005 slave 7a12bc730ddc939c84a156f276c446c28acf798c 0 1443601740259 5 connected
127.0.0.1:7003&gt;</code></pre>
<h3 id="维护节点"><a class="markdownIt-Anchor" href="#维护节点"></a> 维护节点</h3>
<p>集群创建成功后可以继续向集群中添加节点</p>
<p><strong>添加主节点</strong></p>
<p>先创建7007节点，添加7007结点作为新节点</p>
<pre><code class="highlight plaintext">./redis-trib.rb add-node 127.0.0.1:7007 127.0.0.1:7001</code></pre>
<p>查看集群节点发现7007已经添加到集群中了</p>
<p><strong>hash槽重新分配（数据迁移）</strong></p>
<p>添加完主节点需要对主节点进行hash槽分配，这样该主节才可以存储数据</p>
<p>查看集群中槽占用情况</p>
<ul>
<li>redis集群有16384个槽，集群中的每个结点分配自已槽，通过查看集群结点可以看到槽占用情况</li>
</ul>
<p>给刚添加的7007节点分配槽</p>
<ol>
<li>连接上集群（连接集群中任意一个可用节点都行）</li>
</ol>
<pre><code class="highlight plaintext">./redis-trib.rb reshard 192.168.10.133:7001</code></pre>
<ol start="2">
<li>输入要分配的槽数量</li>
</ol>
<blockquote>
<p>输入：3000，表示要给目标节点分配3000个槽</p>
</blockquote>
<ol start="3">
<li>输入接受槽点的节点id</li>
</ol>
<blockquote>
<p>PS：这里准备给7007分配槽，通过cluster nodes查看7007结点id为：<code>15b809eadae88955e36bcdbb8144f61bbbaf38fb</code></p>
</blockquote>
<ol start="4">
<li>输入源节点id</li>
</ol>
<pre><code class="highlight plaintext">输入：all</code></pre>
<ol start="5">
<li>输入yes开始移动槽到目标节点</li>
</ol>
<p><strong>添加从节点</strong></p>
<p>语法：</p>
<pre><code class="highlight plaintext">./redis-trib.rb add-node --slave --master-id  主节点id   新节点的ip和端口   旧节点ip和端口（集群中任一节点都可以）</code></pre>
<p>添加7008从节点，将7008作为7007的从节点，执行如下命令</p>
<pre><code class="highlight plaintext">./redis-trib.rb add-node --slave --master-id  35da64607a02c9159334a19164e68dd95a3b943c 192.168.10.103:7008 192.168.10.103:7001</code></pre>
<blockquote>
<p><code>35da64607a02c9159334a19164e68dd95a3b943c</code>是7007结点的id，可通过<code>cluster nodes</code>查看</p>
</blockquote>
<blockquote>
<p>注意：如果原来该结点在集群中的配置信息已经生成到cluster-config-file指定的配置文件中（如果cluster-config-file没有指定则默认为nodes.conf），这时可能会报错：<code>[ERR] Node XXXXXX is not empty. Either the node already knows other nodes (check with  CLUSTER NODES) or contains some key in database 0</code></p>
</blockquote>
<blockquote>
<p>解决方法是删除生成的配置文件<code>nodes.conf</code>，删除后再执行<code>./redis-trib.rb add-node</code>指令</p>
</blockquote>
<p>查看集群中的结点，刚添加的7008为7007的从节点：</p>
<p><strong>删除节点</strong></p>
<pre><code class="highlight plaintext">./redis-trib.rb del-node 127.0.0.1:7005 
4b45eb75c8b428fbd77ab979b85080146a9bc017</code></pre>
<p>删除已经占有hash槽的结点会失败，报错如下：</p>
<p><code>[ERR] Node 127.0.0.1:7005 is not empty! Reshard data away and try again.</code></p>
<p>需要将该结点占用的hash槽分配出去（参考hash槽重新分配章节）</p>
<h3 id="jedis连接集群"><a class="markdownIt-Anchor" href="#jedis连接集群"></a> Jedis连接集群</h3>
<p>需要开启防火墙，或者直接关闭防火墙</p>
<pre><code class="highlight plaintext">service iptables stop</code></pre>
<h4 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h4>
<pre><code class="highlight java"><span class="meta">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJedisCluster</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;
	<span class="comment">//创建一连接，JedisCluster对象,在系统中是单例存在</span>
	Set&lt;HostAndPort&gt; nodes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();
	nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.10.133&quot;</span>, <span class="number">7001</span>));
	nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.10.133&quot;</span>, <span class="number">7002</span>));
	nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.10.133&quot;</span>, <span class="number">7003</span>));
	nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.10.133&quot;</span>, <span class="number">7004</span>));
	nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.10.133&quot;</span>, <span class="number">7005</span>));
	nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.10.133&quot;</span>, <span class="number">7006</span>));
	<span class="type">JedisCluster</span> <span class="variable">cluster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisCluster</span>(nodes);
	<span class="comment">//执行JedisCluster对象中的方法，方法和redis一一对应。</span>
	cluster.set(<span class="string">&quot;cluster-test&quot;</span>, <span class="string">&quot;my jedis cluster test&quot;</span>);
	<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> cluster.get(<span class="string">&quot;cluster-test&quot;</span>);
	System.out.println(result);
	<span class="comment">//程序结束时需要关闭JedisCluster对象</span>
	cluster.close();
&#125;</code></pre>
<h4 id="使用spring"><a class="markdownIt-Anchor" href="#使用spring"></a> 使用spring</h4>
<p>配置applicationContext.xml</p>
<pre><code class="highlight xml"><span class="comment">&lt;!-- 连接池配置 --&gt;</span>
<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisPoolConfig&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisPoolConfig&quot;</span>&gt;</span>
	<span class="comment">&lt;!-- 最大连接数 --&gt;</span>
	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxTotal&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span> /&gt;</span>
	<span class="comment">&lt;!-- 最大空闲连接数 --&gt;</span>
	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span>
	<span class="comment">&lt;!-- 每次释放连接的最大数目 --&gt;</span>
	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;numTestsPerEvictionRun&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1024&quot;</span> /&gt;</span>
	<span class="comment">&lt;!-- 释放连接的扫描间隔（毫秒） --&gt;</span>
	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30000&quot;</span> /&gt;</span>
	<span class="comment">&lt;!-- 连接最小空闲时间 --&gt;</span>
	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1800000&quot;</span> /&gt;</span>
	<span class="comment">&lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt;</span>
	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;softMinEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span>
	<span class="comment">&lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt;</span>
	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWaitMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1500&quot;</span> /&gt;</span>
	<span class="comment">&lt;!-- 在获取连接的时候检查有效性, 默认false --&gt;</span>
	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span>
	<span class="comment">&lt;!-- 在空闲时检查有效性, 默认false --&gt;</span>
	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span>
	<span class="comment">&lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt;</span>
	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;blockWhenExhausted&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span>
<span class="tag">&lt;/<span class="name">bean</span>&gt;</span>
<span class="comment">&lt;!-- redis集群 --&gt;</span>
<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisCluster&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisCluster&quot;</span>&gt;</span>
	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>&gt;</span>
		<span class="tag">&lt;<span class="name">set</span>&gt;</span>
			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span>
				<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.101.3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>
				<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7001&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>
			<span class="tag">&lt;/<span class="name">bean</span>&gt;</span>
			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span>
				<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.101.3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>
				<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7002&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>
			<span class="tag">&lt;/<span class="name">bean</span>&gt;</span>
			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span>
				<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.101.3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>
				<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7003&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>
			<span class="tag">&lt;/<span class="name">bean</span>&gt;</span>
			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span>
				<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.101.3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>
				<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7004&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>
			<span class="tag">&lt;/<span class="name">bean</span>&gt;</span>
			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span>
				<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.101.3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>
				<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7005&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>
			<span class="tag">&lt;/<span class="name">bean</span>&gt;</span>
			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span>
				<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;192.168.101.3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>
				<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7006&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>
			<span class="tag">&lt;/<span class="name">bean</span>&gt;</span>
		<span class="tag">&lt;/<span class="name">set</span>&gt;</span>
	<span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>
	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jedisPoolConfig&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>
<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre>
<p>测试代码</p>
<pre><code class="highlight java"><span class="keyword">private</span> ApplicationContext applicationContext;
<span class="meta">@Before</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;
	applicationContext = <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(
			<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);
&#125;

<span class="comment">// redis集群</span>
<span class="meta">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJedisCluster</span><span class="params">()</span> &#123;
	<span class="type">JedisCluster</span> <span class="variable">jedisCluster</span> <span class="operator">=</span> (JedisCluster) applicationContext
			.getBean(<span class="string">&quot;jedisCluster&quot;</span>);

	jedisCluster.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);
	<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> jedisCluster.get(<span class="string">&quot;name&quot;</span>);
	System.out.println(value);
&#125;</code></pre>
<h2 id="redislua整合使用"><a class="markdownIt-Anchor" href="#redislua整合使用"></a> Redis+LUA整合使用</h2>
<p>Lua 是一种轻量小巧的<strong>脚本语言</strong>，用标准<strong>C语言</strong>编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能</p>
<h3 id="redis中使用lua的好处"><a class="markdownIt-Anchor" href="#redis中使用lua的好处"></a> Redis中使用LUA的好处</h3>
<ol>
<li>
<p><strong>减少网络开销</strong>，在Lua脚本中可以把多个命令放在同一个脚本中运行</p>
</li>
<li>
<p><strong>原子操作</strong>，redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。换句话说，编写脚本的过程中无需担心会出现竞态条件</p>
</li>
<li>
<p><strong>复用性</strong>，客户端发送的脚本会永远存储在redis中，这意味着其他客户端可以复用这一脚本来完成同样的逻辑</p>
</li>
</ol>
<h3 id="lua的安装学习lua时安装"><a class="markdownIt-Anchor" href="#lua的安装学习lua时安装"></a> <s>LUA的安装（学习lua时安装）</s></h3>
<p><strong>下载</strong></p>
<p>地址：<u><a target="_blank" rel="noopener" href="http://www.lua.org/download.html">http://www.lua.org/download.html</a></u></p>
<p>可以本地下载上传到linux，也可以使用curl命令在linux系统中进行在线下载</p>
<pre><code class="highlight plaintext">curl -R -O http://www.lua.org/ftp/lua-5.3.5.tar.gz</code></pre>
<p><strong>安装</strong></p>
<pre><code class="highlight plaintext">yum -y install readline-devel ncurses-devel

tar -zxvf lua-5.3.5.tar.gz

make linux

make install</code></pre>
<p>如果报错，说找不到readline/readline.h, 可以通过yum命令安装</p>
<pre><code class="highlight plaintext">yum -y install readline-devel ncurses-devel</code></pre>
<p>安装完以后再make linux  / make install</p>
<p>最后，直接输入 lua命令即可进入lua的控制台</p>
<h3 id="lua常见语法"><a class="markdownIt-Anchor" href="#lua常见语法"></a> LUA常见语法</h3>
<p>详见：<u><a target="_blank" rel="noopener" href="http://www.runoob.com/lua/lua-tutorial.html">http://www.runoob.com/lua/lua-tutorial.html</a></u></p>
<h3 id="redis-lua整合使用"><a class="markdownIt-Anchor" href="#redis-lua整合使用"></a> Redis + LUA整合使用</h3>
<p><u><em>在redis中使用LUA不需要安装LUA，redis内置了</em></u></p>
<p>从Redis2.6.0版本开始，通过<strong>内置的Lua解释器</strong>，可以使用EVAL命令对Lua脚本进行求值</p>
<h4 id="相关命令-2"><a class="markdownIt-Anchor" href="#相关命令-2"></a> 相关命令</h4>
<p><strong>eval命令</strong></p>
<pre><code class="highlight plaintext">EVAL script numkeys key [key ...] arg [arg ...]</code></pre>
<p>命令说明：</p>
<ul>
<li>
<p><code>script参数</code>：是一段Lua脚本程序，它会被运行在Redis服务器上下文中，这段脚本不必(也不应该)定义为一个Lua函数。</p>
</li>
<li>
<p><code>numkeys参数</code>：用于指定键名参数的个数。</p>
</li>
<li>
<p><code>key [key ...]参数</code>： 从EVAL的第三个参数开始算起，使用了numkeys个键（key），表示在脚本中所用到的那些Redis键(key)，这些键名参数可以在Lua中通过全局变量KEYS数组，用1为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。</p>
</li>
<li>
<p><code>arg [arg ...]参数</code>：，可以在Lua中通过全局变量ARGV数组访问，访问的形式和KEYS变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。</p>
</li>
</ul>
<p>例如</p>
<pre><code class="highlight plaintext">&gt; eval &quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot; 2 key1 key2 first second

1) &quot;key1&quot;
2) &quot;key2&quot;
3) &quot;first&quot;
4) &quot;second&quot;</code></pre>
<p><strong>lua脚本中调用redis命令</strong></p>
<pre><code class="highlight plaintext">redis.call()：
redis.pcall()：
这两个函数的唯一区别在于它们使用不同的方式处理执行命令所产生的错误

示例：
&gt; eval &quot;return redis.call(&#x27;set&#x27;,KEYS[1],&#x27;bar&#x27;)&quot; 1 foo
OK</code></pre>
<p><strong>evalsha</strong></p>
<ul>
<li>
<p>EVAL 命令要求你在<strong>每次执行脚本</strong>的时候都<strong>发送一次脚本主体</strong>(script body)。</p>
</li>
<li>
<p>Redis 有一个<strong>内部的缓存机制</strong>，因此它不会每次都重新编译脚本，不过在很多场合，付出无谓的带宽来传送脚本主体并不是最佳选择。</p>
</li>
<li>
<p>为了<strong>减少带宽的消耗</strong>， Redis 实现了 <strong>EVALSHA 命令</strong>，它的作用和 EVAL 一样，都用于对脚本求值，但它接受的第一个参数不是脚本，而是脚本的 SHA1 校验和(sum)</p>
</li>
</ul>
<p>EVALSHA 命令的表现如下</p>
<ul>
<li>
<p>如果服务器还记得给定的 SHA1 校验和所指定的脚本，那么执行这个脚本</p>
</li>
<li>
<p>如果服务器不记得给定的 SHA1 校验和所指定的脚本，那么它返回一个特殊的错误，提醒用户使用 EVAL 代替 EVALSHA</p>
</li>
</ul>
<pre><code class="highlight plaintext">&gt; evalsha 6b1bf486c81ceb7edf3c093f4c48582e38c0e791 0

&quot;bar&quot;</code></pre>
<p><strong>script命令</strong></p>
<p><code>SCRIPT FLUSH</code> ：清除所有脚本缓存</p>
<p><code>SCRIPT EXISTS</code> ：根据给定的脚本校验和，检查指定的脚本是否存在于脚本缓存</p>
<p><code>SCRIPT LOAD</code> ：将一个脚本装入脚本缓存，<strong>返回SHA1摘要</strong>，但并不立即运行它</p>
<p><code>SCRIPT KILL</code> ：杀死当前正在运行的脚本</p>
<p><strong>redis-cli --eval</strong></p>
<p>可以使用redis-cli命令直接执行脚本</p>
<pre><code class="highlight plaintext">$ redis-cli --eval script KEYS[1] KEYS[2] , ARGV[1] ARGV[2] ...</code></pre>
<hr />
<p>或者可以执行一个脚本文件</p>
<pre><code class="highlight plaintext">$ redis-cli --eval redis.lua</code></pre>
<p>redis.lua</p>
<pre><code class="highlight lua"><span class="keyword">local</span> value=redis.clal(<span class="string">&quot;get&quot;</span>,<span class="string">&quot;s2&quot;</span>)
<span class="keyword">return</span> value</code></pre>
<h4 id="java种使用"><a class="markdownIt-Anchor" href="#java种使用"></a> Java种使用</h4>
<h2 id="redis消息模式"><a class="markdownIt-Anchor" href="#redis消息模式"></a> Redis消息模式</h2>
<h3 id="队列模式"><a class="markdownIt-Anchor" href="#队列模式"></a> 队列模式</h3>
<p>使用<strong>list类型</strong>的<code>lpush和rpop</code>实现消息队列(一般的抢购秒杀都使用该种技术)</p>
<p>注意事项：</p>
<ul>
<li>
<p>消息接收方如果不知道队列中是否有消息，会一直发送rpop命令，如果这样的话，会每一次都建立一次连接，这样显然不好。</p>
</li>
<li>
<p>可以使用<strong>brpop</strong>命令，它如果从队列中取不出来数据，会一直阻塞，在一定范围内没有取出则返回null、</p>
</li>
</ul>
<h3 id="发布订阅模式"><a class="markdownIt-Anchor" href="#发布订阅模式"></a> 发布订阅模式</h3>
<p><strong>订阅消息（<u>subscribe</u>）</strong></p>
<p>示例：</p>
<pre><code class="highlight plaintext">subscribe kkb-channel</code></pre>
<p><strong>发布消息（<u>publish</u>）</strong></p>
<p>示例：</p>
<pre><code class="highlight plaintext">publish kkb-channel “我是灭霸詹”</code></pre>
<p><strong>Redis发布订阅命令</strong></p>
<h2 id="缓存穿透缓存击穿缓存失效"><a class="markdownIt-Anchor" href="#缓存穿透缓存击穿缓存失效"></a> 缓存穿透,缓存击穿,缓存失效</h2>
<h3 id="缓存数据的步骤"><a class="markdownIt-Anchor" href="#缓存数据的步骤"></a> 缓存数据的步骤</h3>
<ol>
<li>
<p>查询缓存，如果没有数据，则查询数据库</p>
</li>
<li>
<p>查询数据库，如果数据不为空，将结果写入缓存</p>
</li>
</ol>
<h3 id="缓存穿透"><a class="markdownIt-Anchor" href="#缓存穿透"></a> 缓存穿透</h3>
<p><strong>什么叫缓存穿透？</strong></p>
<p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。如果key对应的value是一定不存在的，并且对该key并发请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p>
<p><strong>如何解决？</strong></p>
<p>1：<strong>对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存</strong>。</p>
<p>2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。（<strong>布隆表达式</strong>）</p>
<h3 id="缓存雪崩"><a class="markdownIt-Anchor" href="#缓存雪崩"></a> 缓存雪崩</h3>
<p><strong>什么叫缓存雪崩？</strong></p>
<p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。</p>
<p><strong>如何解决？</strong></p>
<p>1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<p>2：<strong>不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀</strong>。</p>
<p>3：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期（此点为补充）</p>
<h3 id="缓存击穿"><a class="markdownIt-Anchor" href="#缓存击穿"></a> 缓存击穿</h3>
<p><strong>什么叫缓存击穿？</strong></p>
<ul>
<li>
<p>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。</p>
</li>
<li>
<p>缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
</li>
</ul>
<p><strong>如何解决？</strong></p>
<p>使用redis的setnx互斥锁先进行判断，这样其他线程就处于等待状态，保证不会有大并发操作去操作数据库。</p>
<pre><code class="highlight plaintext">if(redis.sexnx()==1)&#123;
       //查询数据库
       //加入线程
&#125;</code></pre>
<h2 id="缓存淘汰策略之lru"><a class="markdownIt-Anchor" href="#缓存淘汰策略之lru"></a> 缓存淘汰策略之LRU</h2>
<h3 id="redis内置缓存淘汰策略"><a class="markdownIt-Anchor" href="#redis内置缓存淘汰策略"></a> redis内置缓存淘汰策略</h3>
<p><strong>最大缓存</strong></p>
<ul>
<li>
<p>在 redis 中，允许用户设置最大使用内存大小<u>maxmemory</u>，默认为0，没有指定最大缓存，如果有新的数据添加，超过最大内存，则会使redis崩溃，所以一定要设置。</p>
</li>
<li>
<p>redis 内存数据集大小上升到一定大小的时候，就会实行<u>数据淘汰策略</u>。</p>
</li>
</ul>
<p><strong>淘汰策略</strong></p>
<p>redis淘汰策略配置：maxmemory-policy voltile-lru，支持热配置</p>
<p><strong>redis 提供 6种数据淘汰策略：</strong></p>
<p>voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p>
<p>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p>
<p>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p>
<p>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</p>
<p>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</p>
<p>no-enviction（驱逐）：禁止驱逐数据</p>
<h3 id="lru原理"><a class="markdownIt-Anchor" href="#lru原理"></a> LRU原理</h3>
<p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”</p>
<h3 id="lru实现"><a class="markdownIt-Anchor" href="#lru实现"></a> LRU实现</h3>
<p>最常见的实现是使用一个链表保存缓存数据，详细算法实现如下：</p>
<p>1. 新数据插入到链表头部；</p>
<p>2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</p>
<p>3. 当链表满的时候，将链表尾部的数据丢弃。</p>
<blockquote>
<p>在Java中可以使用LinkHashMap去实现LRU</p>
</blockquote>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p><strong>【命中率】</strong></p>
<p>当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。</p>
<p><strong>【复杂度】</strong></p>
<p>实现简单。</p>
<p><strong>【代价】</strong></p>
<p>命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部</p>
</main>

</article>


<script src="/js/highlight.js"></script>

  </main>
  <footer class="footer">
  
  <span>Copyright © 2026 Lism Blog | lisisism@qq.com</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>