<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    Java基础 丨
    

    Lism Blog
  </title>

  
  <link rel="shortcut icon" href="/icon.svg">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="/Lism Blog" type="application/atom+xml">
</head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">/Lism Blog</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <article class="post">
  
  <div class="post-title">Java基础</div>
  <div class="post-meta">
    <div class="date">2019 十一月 9日</div>
    <div class="tags">
      
      <div class="tag-item">Java</div>
      
    </div>
  </div>
  

  <main class="post-content"><h1 id="java基础"><a class="markdownIt-Anchor" href="#java基础"></a> $JAVA基础</h1>
<h1 id="java"><a class="markdownIt-Anchor" href="#java"></a> JAVA</h1>
<ul>
<li><a href="">JAVA</a>
<ul>
<li><a href="">Java基础</a>
<ul>
<li><a href="">命名规范</a></li>
<li><a href="">变量/数据类型</a>
<ul>
<li><a href="">变量</a></li>
<li><a href="">数据类型</a></li>
<li><a href="">自动类型转换</a></li>
</ul>
</li>
<li><a href="">运算符</a>
<ul>
<li><a href="">整数运算</a></li>
<li><a href="">浮点数运算</a></li>
<li><a href="">布尔运算</a></li>
</ul>
</li>
<li><a href="">常量</a></li>
<li><a href="">字符和字符串</a>
<ul>
<li><a href="">字符类型</a></li>
<li><a href="">字符串类型</a></li>
</ul>
</li>
<li><a href="">数组</a>
<ul>
<li><a href="">数组类型</a></li>
<li><a href="">操作数组</a>
<ul>
<li><a href="">遍历数组</a></li>
<li><a href="">数组排序</a></li>
<li><a href="">多维数组</a></li>
<li><a href="">命令行参数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="">流程控制</a>
<ul>
<li><a href="">输入输出</a>
<ul>
<li><a href="">输出</a></li>
<li><a href="">输入</a></li>
</ul>
</li>
<li><a href="">if</a></li>
<li><a href="">switch</a></li>
<li><a href="">while</a></li>
<li><a href="">de while 循环</a></li>
<li><a href="">for循环</a></li>
<li><a href="">break和continue</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="">面向对象</a>
<ul>
<li><a href="">类</a></li>
<li><a href="">方法</a>
<ul>
<li><a href="">this变量</a></li>
</ul>
</li>
<li><a href="">构造方法</a></li>
<li><a href="">重写/重载</a>
<ul>
<li><a href="">方法重载</a></li>
<li><a href="">方法重写</a></li>
</ul>
</li>
<li><a href="">继承</a>
<ul>
<li><a href="">protected</a></li>
<li><a href="">super</a></li>
<li><a href="">上下转型</a></li>
<li><a href="">区分继承和组合</a></li>
</ul>
</li>
<li><a href="">多态</a></li>
<li><a href="">抽象类</a></li>
<li><a href="">接口</a></li>
<li><a href="">静态字段和静态方法</a></li>
<li><a href="">�</a>�</li>
<li><a href="">作用域</a>
<ul>
<li><a href="">修饰符</a></li>
<li><a href="">局部变量</a></li>
<li><a href="">final</a></li>
</ul>
</li>
<li><a href="">内部类</a>
<ul>
<li><a href="">非静态内部类</a></li>
<li><a href="">静态内部类</a></li>
<li><a href="">匿名内部类</a></li>
<li><a href="">局部（方法）内部类</a></li>
</ul>
</li>
<li><a href="">自动装箱</a></li>
<li><a href="">classpath/jar</a></li>
<li><a href="">模块</a></li>
</ul>
</li>
<li><a href="">内存分析</a>
<ul>
<li><a href="">内存分析一</a></li>
<li><a href="">内存分析二</a></li>
<li><a href="">内存机制</a></li>
<li><a href="">垃圾回收装置</a></li>
</ul>
</li>
<li><a href="">Java关键字</a>
<ul>
<li><a href="">Native</a>
<ul>
<li><a href="">JNI:Java Native Interface</a></li>
<li><a href="">用C语言编写程序本地方法</a></li>
<li><a href="">JNI调用C流程图</a></li>
<li><a href="">native关键字</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="">Java核心类(java.lang)</a>
<ul>
<li><a href="">字符串和编码</a>
<ul>
<li><a href="">String</a></li>
<li><a href="">字符编码</a></li>
<li><a href="">版本问题</a></li>
</ul>
</li>
<li><a href="">StringBuilder(非线程安全的)</a></li>
<li><a href="">StringJoiner</a></li>
<li><a href="">包装类型</a>
<ul>
<li><a href="">Auto Boxing 自动装箱</a></li>
<li><a href="">不变类</a></li>
<li><a href="">进制转换</a></li>
<li><a href="">无符号整数</a></li>
<li><a href="">包装类型与基本类型比较问题</a></li>
</ul>
</li>
<li><a href="">JavaBean</a></li>
<li><a href="">枚举类</a>
<ul>
<li><a href="">enum</a></li>
</ul>
</li>
<li><a href="">BigInteger</a></li>
<li><a href="">BigDecimal</a></li>
<li><a href="">常用工具类</a>
<ul>
<li><a href="">Math</a></li>
<li><a href="">Random</a></li>
<li><a href="">SecureRandom</a></li>
</ul>
</li>
<li><a href="">Runtime</a></li>
</ul>
</li>
<li><a href="">异常/日志</a>
<ul>
<li><a href="">Java异常</a></li>
<li><a href="">捕获异常</a></li>
<li><a href="">抛出异常</a></li>
<li><a href="">自定义异常</a></li>
<li><a href="">使用JDK Logging</a></li>
<li><a href="">使用Commons Logging</a></li>
<li><a href="">使用Log4j</a></li>
<li><a href="">使用SLF4J和Logback</a></li>
</ul>
</li>
<li><a href="">注解</a>
<ul>
<li><a href="">使用注解</a></li>
<li><a href="">定义注解</a>
<ul>
<li><a href="">元注解</a></li>
<li><a href="">定义Annotation</a></li>
</ul>
</li>
<li><a href="">处理注解</a></li>
</ul>
</li>
<li><a href="">泛型</a>
<ul>
<li><a href="">什么是泛型</a></li>
<li><a href="">使用泛型</a></li>
<li><a href="">编写泛型</a></li>
<li><a href="">擦拭法</a></li>
<li><a href="">extends通配符</a></li>
<li><a href="">super通配符</a></li>
<li><a href="">泛型和反射</a></li>
</ul>
</li>
<li><a href="">日期与时间</a>
<ul>
<li><a href="">基本概念</a>
<ul>
<li><a href="">夏令时</a></li>
<li><a href="">本地化</a></li>
</ul>
</li>
<li><a href="">Date和Calendar</a>
<ul>
<li><a href="">标准库API</a></li>
<li><a href="">Date</a></li>
<li><a href="">SimpleDateFormat时间格式化</a></li>
<li><a href="">Calendar时间计算</a></li>
<li><a href="">TimeZone时区转换</a></li>
</ul>
</li>
<li><a href="">LocalDateTime</a>
<ul>
<li><a href="">LocalDateTime</a></li>
<li><a href="">DataTimeFormatter</a></li>
<li><a href="">Duration和Period</a></li>
</ul>
</li>
<li><a href="">ZonedDateTime</a></li>
<li><a href="">DateTimeFormatter</a></li>
<li><a href="">Instant</a></li>
</ul>
</li>
<li><a href="">函数式编程</a>
<ul>
<li><a href="">Lambda表达式</a>
<ul>
<li><a href="">语法</a></li>
<li><a href="">实例</a></li>
<li><a href="">变量作用域</a></li>
</ul>
</li>
<li><a href="">全新的Stream API</a></li>
</ul>
</li>
<li><a href="">JDK9新特性</a></li>
<li><a href="">JDK11新特性</a>
<ul>
<li><a href="">Local Var</a></li>
<li><a href="">HttpClient</a></li>
<li><a href="">List API</a></li>
<li><a href="">读写文件</a></li>
<li><a href="">String API</a></li>
<li><a href="">新增GC</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="java基础-2"><a class="markdownIt-Anchor" href="#java基础-2"></a> Java基础</h2>
<h3 id="命名规范"><a class="markdownIt-Anchor" href="#命名规范"></a> 命名规范</h3>
<ol>
<li>只能以广义字母（采用Unicode字符集/可以为汉字，日文，阿拉伯文等），下划线，$开头</li>
<li>其余部分  可以为数字</li>
<li>不能为关键字</li>
</ol>
<p><strong>变量/方法名</strong>：首字母小写-驼峰原则：age，my，myName，run()，runRun()</p>
<p><strong>常量</strong>：大写字母和下划线：MAX_VALUE，MIN_VALUE</p>
<p><strong>类名</strong>：首字母大写-驼峰原则：Man，GoodMan</p>
<h3 id="变量数据类型"><a class="markdownIt-Anchor" href="#变量数据类型"></a> 变量/数据类型</h3>
<h4 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h4>
<p><strong>局部变脸</strong></p>
<p>方法内或语句块内，从属于方法或语句块执行完，变量自然也消失，必须手动初始化</p>
<p><strong>成员变量</strong></p>
<p>类里面方法外，从属于对象，自动初始化;</p>
<p><strong>静态变量</strong>（类变量）</p>
<p>类里面方法外，从属于类，使用static修饰，可以直接使用类名调用   自动初始化</p>
<pre><code class="highlight plaintext">public class Test &#123;
     static int i;//不用赋值，也可以输出

     public static void main(String[] args) &#123;
           int y = 0;  //必须赋值，否则无法输出
           System.out.println(i);
           System.out.println(y);
     &#125;
&#125;</code></pre>
<h4 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h4>
<p>Java 的两大数据类型:</p>
<ul>
<li><strong>内置数据类型（8种）</strong></li>
<li><strong>引用数据类型</strong></li>
</ul>
<hr />
<p><strong>内置数据类型</strong></p>
<p>不同的数据类型占用的字节数不一样。我们看一下Java基本数据类型占用的字节数：</p>
<p><strong>byte</strong> (1字节)</p>
<ul>
<li>byte 数据类型是8位、有符号的，以二进制补码表示的整数；</li>
<li>最小值是 -128（-2^7）；</li>
<li>最大值是 127（2^7-1）；</li>
<li>默认值是 0；</li>
<li>byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；例子：byte a = 100，byte b = -50。</li>
</ul>
<p><strong>short</strong> (2字节)</p>
<ul>
<li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li>
<li>最小值是 -32768（-2^15）；</li>
<li>最大值是 32767（2^15 - 1）；</li>
<li>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；</li>
<li>默认值是 0；例子：short s = 1000，short r = -20000。</li>
</ul>
<p><strong>int</strong> (4字节)<strong>整形常量默认该类型</strong></p>
<ul>
<li>int 数据类型是32位、有符号的以二进制补码表示的整数；</li>
<li>最小值是 -2,147,483,648（-2^31）；</li>
<li>最大值是 2,147,483,647（2^31 - 1）；</li>
<li>一般地整型变量默认为 int 类型；默认值是 0 ；</li>
<li>例子：int a = 100000, int b = -200000。</li>
</ul>
<p><strong>long</strong> (8字节)</p>
<ul>
<li>long 数据类型是 64 位、有符号的以二进制补码表示的整数；</li>
<li>最小值是 -9,223,372,036,854,775,808（-2^63）；</li>
<li>最大值是 9,223,372,036,854,775,807（2^63 -1）；</li>
<li>这种类型主要使用在需要比较大整数的系统上；</li>
<li>默认值是 0L；</li>
<li>例子： long a = 100000L，Long b = -200000L。<br />
&quot;L&quot;理论上不分大小写，但是若写成&quot;l&quot;容易与数字&quot;1&quot;混淆，不容易分辩。所以最好大写。</li>
</ul>
<p><strong>float</strong> (4字节)</p>
<ul>
<li>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li>
<li>float 在储存大型浮点数组的时候可节省内存空间；</li>
<li>默认值是 0.0f；<br />
浮点数不能用来表示精确的值，如货币；</li>
<li>例子：float f1 = 234.5f。</li>
</ul>
<p><strong>double</strong> (8字节)<strong>浮点数常量默认该类型</strong></p>
<ul>
<li>double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；</li>
<li>浮点数的默认类型为double类型；</li>
<li>double类型同样不能表示精确的值，如货币；</li>
<li>默认值是 0.0d；</li>
<li>例子：double d1 = 123.4。</li>
</ul>
<blockquote>
<p><strong>金额计算一定不可以使用float/double，而是要使用BigDecimal</strong></p>
</blockquote>
<p><strong>boolean</strong> (1位)</p>
<ul>
<li>boolean数据类型表示一位的信息；</li>
<li>只有两个取值：true 和 false；</li>
<li>这种类型只作为一种标志来记录 true/false 情况；</li>
<li>默认值是 false；</li>
<li>例子：boolean one = true。</li>
</ul>
<p><strong>char</strong> (2个字节)</p>
<ul>
<li>char类型是一个单一的 16 位 Unicode 字符；</li>
<li>最小值是 \u0000（即为0）；</li>
<li>最大值是 \uffff（即为65,535）；</li>
<li>char 数据类型可以储存任何字符；例子：char letter = ‘A’;。</li>
</ul>
<blockquote>
<p>byte/short/char可以自动转为int</p>
</blockquote>
<blockquote>
<p>long转int需要强制转型</p>
</blockquote>
<hr />
<p><strong>引用类型</strong> (4字节)</p>
<ul>
<li>引用类型默认值null</li>
<li>引用&quot;说白了就是&quot;引用了堆里面的一个地址</li>
<li>数组引用类型的变量的默认值为 null。当数组变量的实例后，如果没有没有显示的为每个元素赋值，Java 就会把该数组的所有元素初始化为其相应类型的默认值</li>
</ul>
<h4 id="自动类型转换"><a class="markdownIt-Anchor" href="#自动类型转换"></a> 自动类型转换</h4>
<p>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</p>
<pre><code class="highlight plaintext">低  ------------------------------------&gt;  高

byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double</code></pre>
<p>数据类型转换必须满足如下规则：</p>
<ol>
<li>不能对boolean类型进行类型转换。</li>
<li>不能把对象类型转换成不相关类的对象。</li>
<li>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</li>
<li>转换过程中可能导致溢出或损失精度</li>
<li>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入</li>
</ol>
<p><strong>自动类型转换</strong></p>
<p>必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。</p>
<pre><code class="highlight plaintext">public class ZiDongLeiZhuan&#123;
        public static void main(String[] args)&#123;
            char c1=&#x27;a&#x27;;//定义一个char类型
            int i1 = c1;//char自动类型转换为int
            System.out.println(&quot;char自动类型转换为int后的值等于&quot;+i1);
            char c2 = &#x27;A&#x27;;//定义一个char类型
            int i2 = c2+1;//char 类型和 int 类型计算
            System.out.println(&quot;char类型和int计算后的值等于&quot;+i2);
        &#125;
&#125;</code></pre>
<p>输出：</p>
<blockquote>
<p>c1 的值为字符 a ,查 ASCII 码表可知对应的 int 类型值为 97， A 对应值为 65，所以 i2=65+1=66</p>
</blockquote>
<pre><code class="highlight plaintext">char自动类型转换为int后的值等于97
char类型和int计算后的值等于66</code></pre>
<p><strong>强制类型转换</strong></p>
<ol>
<li>条件是转换的数据类型必须是兼容的。</li>
<li>格式：(type)value type是要强制类型转换后的数据类型 实例：</li>
</ol>
<pre><code class="highlight plaintext">public class QiangZhiZhuanHuan&#123;
    public static void main(String[] args)&#123;
        int i1 = 123;
        byte b = (byte)i1;//强制类型转换为byte
        System.out.println(&quot;int强制类型转换为byte后的值等于&quot;+b);
    &#125;
&#125;</code></pre>
<h3 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h3>
<p><strong>表达式</strong></p>
<ul>
<li>类型的自动提升
<ul>
<li>表达式中有long,结果就是long类型</li>
<li>表达式如果有double，结果就是double</li>
<li>转的时候必须要转整体</li>
</ul>
</li>
</ul>
<p><strong>运算符</strong></p>
<ol>
<li>关系运算符
<ul>
<li>常见错误写法：<s>1&lt;a&lt;5</s>   正解：1&lt;a&amp;&amp;a&lt;3</li>
</ul>
</li>
<li>逻辑运算符
<ul>
<li>&amp;&amp;(与)/||(或)  ：短路，只可以运算boolean</li>
<li>&amp;/|（逻辑于/或）：3&amp;4表示逻辑与，即011&amp;100结果为false</li>
</ul>
</li>
<li>位运算符
<ul>
<li>&lt;&lt;（左移一位相当于乘2），&gt;&gt;（右移一位相当于除以2）</li>
<li>eg：3*4最快的算法/3左移两位</li>
</ul>
</li>
<li>扩展运算符
<ul>
<li>+=，-=，*=，/=，%=</li>
</ul>
</li>
<li>三目运算符
<ul>
<li>（布尔表达式）？A：B     “布尔表达式位true，返回A,否则返回B”</li>
</ul>
</li>
<li>赋值运算符
<ul>
<li>~~错误写法 if(b=true)     if(c=3)   ~~</li>
<li>正确写法 if(b)    if(3==c)   //这样写容易找出错误</li>
</ul>
</li>
</ol>
<h4 id="整数运算"><a class="markdownIt-Anchor" href="#整数运算"></a> 整数运算</h4>
<p><strong>溢出</strong></p>
<p>要特别注意，整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出不会出错，却会得到一个奇怪的结果：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        int x = 2147483640;
        int y = 15;
        int sum = x + y;
        System.out.println(sum); // -2147483641
    &#125;
&#125;</code></pre>
<p>要解释上述结果，我们把整数2147483640和15换成二进制做加法：</p>
<p>由于最高位计算结果为1，因此，加法结果变成了一个负数。</p>
<p>要解决上面的问题，可以把int换成long类型，由于long可表示的整型范围更大，所以结果就不会溢出：</p>
<pre><code class="highlight plaintext">long x = 2147483640;
long y = 15;
long sum = x + y;
System.out.println(sum); // 2147483655</code></pre>
<p>还有一种简写的运算符，即+=，-=，*=，/=，它们的使用方法如下：</p>
<pre><code class="highlight plaintext">n += 100; // 3409, 相当于 n = n + 100;
n -= 100; // 3309, 相当于 n = n - 100;</code></pre>
<hr />
<p><strong>自增/自减</strong></p>
<p>Java还提供了++运算和–运算，它们可以对一个整数进行加1和减1的操作：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        int n = 3300;
        n++; // 3301, 相当于 n = n + 1;
        n--; // 3300, 相当于 n = n - 1;
        int y = 100 + (++n); // 不要这么写
        System.out.println(y);
    &#125;
&#125;</code></pre>
<blockquote>
<p>注意<ins>写在前面和后面计算结果是不同的，<ins>n表示先加1再引用n，n</ins>表示先引用n再加1。不建议把</ins>运算混入到常规运算中，容易自己把自己搞懵了</p>
</blockquote>
<hr />
<p><strong>移位运算</strong></p>
<p>在计算机中，整数总是以二进制的形式表示。例如，int类型的整数7使用4字节表示的二进制如下：</p>
<p>可以对整数进行移位运算。对整数7左移1位将得到整数14，左移两位将得到整数28：</p>
<pre><code class="highlight plaintext">
int n = 7;       // 00000000 00000000 00000000 00000111 = 7
int a = n &lt;&lt; 1;  // 00000000 00000000 00000000 00001110 = 14int b = n &lt;&lt; 2;  // 00000000 00000000 00000000 00011100 = 28int c = n &lt;&lt; 28; // 01110000 00000000 00000000 00000000 = 1879048192int d = n &lt;&lt; 29; // 11100000 00000000 00000000 00000000 = -536870912</code></pre>
<p>类似的，对整数7进行右移，结果如下：</p>
<pre><code class="highlight plaintext">int n = 7;       // 00000000 00000000 00000000 00000111 = 7int a = n &gt;&gt; 1;  // 00000000 00000000 00000000 00000011 = 3int b = n &gt;&gt; 2;  // 00000000 00000000 00000000 00000001 = 1int c = n &gt;&gt; 3;  // 00000000 00000000 00000000 00000000 = 0</code></pre>
<p>如果对一个负数进行右移，最高位的1不动，结果仍然是一个负数：</p>
<pre><code class="highlight plaintext">int n = -536870912;
int a = n &gt;&gt; 1;  // 11110000 00000000 00000000 00000000 = -268435456int b = n &gt;&gt; 2;  // 10111000 00000000 00000000 00000000 = -134217728int c = n &gt;&gt; 28; // 11111111 11111111 11111111 11111110 = -2int d = n &gt;&gt; 29; // 11111111 11111111 11111111 11111111 = -1</code></pre>
<p>还有一种不带符号的右移运算，使用&gt;&gt;&gt;，它的特点是符号位跟着动，因此，对一个负数进行&gt;&gt;&gt;右移，它会变成正数，原因是最高位的1变成了0：</p>
<pre><code class="highlight plaintext">int n = -536870912;
int a = n &gt;&gt;&gt; 1;  // 01110000 00000000 00000000 00000000 = 1879048192int b = n &gt;&gt;&gt; 2;  // 00111000 00000000 00000000 00000000 = 939524096int c = n &gt;&gt;&gt; 29; // 00000000 00000000 00000000 00000111 = 7int d = n &gt;&gt;&gt; 31; // 00000000 00000000 00000000 00000001 = 1</code></pre>
<blockquote>
<p>对byte和short类型进行移位时，会首先转换为int再进行位移。</p>
<p>仔细观察可发现，左移实际上就是不断地×2，右移实际上就是不断地÷2。</p>
</blockquote>
<hr />
<p><strong>位运算</strong></p>
<p>位运算是按位进行与、或、非和异或的运算。</p>
<p>与运算的规则是，必须两个数同时为1，结果才为1：</p>
<pre><code class="highlight plaintext">n = 0 &amp; 0; // 0
n = 0 &amp; 1; // 0
n = 1 &amp; 0; // 0
n = 1 &amp; 1; // 1</code></pre>
<p>或运算的规则是，只要任意一个为1，结果就为1：</p>
<pre><code class="highlight plaintext">n = 0 | 0; // 0
n = 0 | 1; // 1
n = 1 | 0; // 1
n = 1 | 1; // 1</code></pre>
<p>非运算的规则是，0和1互换：</p>
<pre><code class="highlight plaintext">n = ~0; // 1
n = ~1; // 0</code></pre>
<p>异或运算的规则是，如果两个数不同，结果为1，否则为0：</p>
<pre><code class="highlight plaintext">n = 0 ^ 0; // 0
n = 0 ^ 1; // 1
n = 1 ^ 0; // 1
n = 1 ^ 1; // 0</code></pre>
<p>对两个整数进行位运算，实际上就是按位对齐，然后依次对每一位进行运算。例如：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        int i = 167776589; // 00001010 00000000 00010001 01001101
        int n = 167776512; // 00001010 00000000 00010001 00000000
        System.out.println(i &amp; n); // 167776512
    &#125;
&#125;</code></pre>
<blockquote>
<p>上述按位与运算实际上可以看作两个整数表示的IP地址10.0.17.77和10.0.17.0，通过与运算，可以快速判断一个IP是否在给定的网段内。</p>
</blockquote>
<hr />
<p><strong>运算优先级</strong></p>
<p>在Java的计算表达式中，运算优先级从高到低依次是：</p>
<ul>
<li><code>()</code></li>
<li><code>! ~ ++ --</code></li>
<li><code>* / %</code></li>
<li><code>+ -</code></li>
<li><code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code></li>
<li><code>&amp;</code></li>
<li><code>|</code></li>
<li><code>+= -= *= /=</code></li>
</ul>
<h4 id="浮点数运算"><a class="markdownIt-Anchor" href="#浮点数运算"></a> 浮点数运算</h4>
<p>浮点数运算和整数运算相比，只能进行加减乘除这些数值计算，不能做位运算和移位运算。</p>
<p>在计算机中，浮点数虽然表示的范围大，但是，浮点数有个非常重要的特点，就是浮点数常常无法精确表示。</p>
<p>浮点数0.1在计算机中就无法精确表示，因为十进制的0.1换算成二进制是一个无限循环小数，很显然，无论使用float还是double，都只能存储一个0.1的近似值。但是，0.5这个浮点数又可以精确地表示。</p>
<p>因为浮点数常常无法精确表示，因此，浮点数运算会产生误差：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        double x = 1.0 / 10;
        double y = 1 - 9.0 / 10;
        // 观察x和y是否相等:
        System.out.println(x);  //0.1
        System.out.println(y);  //0.09999999999999998
    &#125;
&#125;</code></pre>
<p>由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数：</p>
<pre><code class="highlight plaintext">// 比较x和y是否相等，先计算其差的绝对值:
double r = Math.abs(x - y);
// 再判断绝对值是否足够小:
if (r &lt; 0.00001) &#123;
    // 可以认为相等
&#125; else &#123;
    // 不相等
&#125;</code></pre>
<p>浮点数在内存的表示方法和整数比更加复杂。Java的浮点数完全遵循IEEE-754标准，这也是绝大多数计算机平台都支持的浮点数标准表示方法。</p>
<hr />
<p><strong>类型提升</strong></p>
<p>如果参与运算的两个数其中一个是整型，那么整型可以自动提升到浮点型：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        int n = 5;
        double d = 1.2 + 24.0 / n; // 6.0
        System.out.println(d);
    &#125;
&#125;</code></pre>
<p>需要特别注意，在一个复杂的四则运算中，两个整数的运算不会出现自动提升的情况。例如：</p>
<pre><code class="highlight plaintext">double d = 1.2 + 24 / 5; // 5.2</code></pre>
<blockquote>
<p>计算结果为5.2，原因是编译器计算24 / 5这个子表达式时，按两个整数进行运算，结果仍为整数4</p>
</blockquote>
<hr />
<p><strong>溢出</strong></p>
<p>整数运算在除数为0时会报错，而浮点数运算在除数为0时，不会报错，但会返回几个特殊值：</p>
<ul>
<li>NaN 表示Not a Number</li>
<li>Infinity 表示无穷大</li>
<li>-Infinity 表示负无穷大</li>
</ul>
<pre><code class="highlight plaintext">double d1 = 0.0 / 0; // NaN
double d2 = 1.0 / 0; // Infinity
double d3 = -1.0 / 0; // -Infinity</code></pre>
<hr />
<p><strong>强制转型</strong></p>
<p>可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。例如：</p>
<pre><code class="highlight plaintext">int n1 = (int) 12.3; // 12
int n2 = (int) 12.7; // 12
int n2 = (int) -12.7; // -12
int n3 = (int) (12.7 + 0.5); // 13
int n4 = (int) 1.2e20; // 2147483647</code></pre>
<p>如果要进行四舍五入，可以对浮点数加上0.5再强制转型：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        double d = 2.6;
        int n = (int) (d + 0.5);
        System.out.println(n);
    &#125;
&#125;</code></pre>
<h4 id="布尔运算"><a class="markdownIt-Anchor" href="#布尔运算"></a> 布尔运算</h4>
<p>对于布尔类型boolean，永远只有true和false两个值。</p>
<p>布尔运算是一种关系运算，包括以下几类：</p>
<ul>
<li>比较运算符：&gt;，&gt;=，&lt;，&lt;=，==，!=</li>
<li>与运算 &amp;&amp;</li>
<li>或运算 ||</li>
<li>非运算 !</li>
</ul>
<pre><code class="highlight plaintext">boolean isGreater = 5 &gt; 3; // trueint age = 12;
boolean isZero = age == 0; // false
boolean isNonZero = !isZero; // true
boolean isAdult = age &gt;= 18; // false
boolean isTeenager = age &gt;6 &amp;&amp; age &lt;18; // true</code></pre>
<p>关系运算符的优先级从高到低依次是：</p>
<ul>
<li><code>!</code></li>
<li><code>&gt;，&gt;=，&lt;，&lt;=</code></li>
<li><code>==，!=</code></li>
<li><code>&amp;&amp;</code></li>
<li><code>||</code></li>
</ul>
<p><strong>短路运算</strong></p>
<p>布尔运算的一个重要特点是短路运算。如果一个布尔运算的表达式能提前确定结果，则后续的计算不再执行，直接返回结果。</p>
<p>因为false &amp;&amp; x的结果总是false，无论x是true还是false，因此，与运算在确定第一个值为false后，不再继续计算，而是直接返回false。</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        boolean b = 5 &lt; 3;
        boolean result = b &amp;&amp; (5 / 0 &gt; 0);
        System.out.println(result);
    &#125;
&#125;</code></pre>
<p>如果没有短路运算，&amp;&amp;后面的表达式会由于除数为0而报错，但实际上该语句并未报错，原因在于与运算是短路运算符，提前计算出了结果false</p>
<p>如果变量b的值为true，则表达式变为true &amp;&amp; (5 / 0 &gt; 0)。因为无法进行短路运算，该表达式必定会由于除数为0而报错，可以自行测试</p>
<blockquote>
<p>类似的，对于||运算，只要能确定第一个值为true，后续计算也不再进行，而是直接返回true</p>
</blockquote>
<p><strong>三元运算符</strong></p>
<p>Java还提供一个三元运算符b ? x : y，它根据第一个布尔表达式的结果，分别返回后续两个表达式之一的计算结果。</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        int n = -100;
        int x = n &gt;= 0 ? n : -n;
        System.out.println(x);
    &#125;
&#125;</code></pre>
<blockquote>
<p>上述语句的意思是，判断n &gt;= 0是否成立，如果为true，则返回n，否则返回-n。这实际上是一个求绝对值的表达式</p>
</blockquote>
<blockquote>
<p>注意到三元运算b ? x : y会首先计算b，如果b为true，则只计算x，否则，只计算y。此外，x和y的类型必须相同，因为返回值不是boolean，而是x和y之一</p>
</blockquote>
<h3 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h3>
<p>定义变量的时候，如果加上final修饰符，这个变量就变成了常量：</p>
<pre><code class="highlight plaintext">final double PI = 3.14; // PI是一个常量double r = 5.0;
double area = PI * r * r;
PI = 300; // compile error!</code></pre>
<p>常量在定义时进行<strong>初始化后就不可再次赋值</strong>，再次赋值会导致编译错误。</p>
<blockquote>
<p>根据习惯，常量名通常全部大写</p>
</blockquote>
<blockquote>
<p>常量如果是基本类型，那定义后就无法修改，如果是引用类型，定义后无法更改的只是引用地址，但是引用的对象内部成员变量是可以修改的</p>
</blockquote>
<h3 id="字符和字符串"><a class="markdownIt-Anchor" href="#字符和字符串"></a> 字符和字符串</h3>
<ul>
<li>Unicode是一种字符集(charset)，用两个字节就能囊括世界上所有的文字集合。</li>
<li>UTF-8是一种编码方式(encoding)，是Unicode的一种表现方式。</li>
</ul>
<p>在一个Java文件(该文件为UTF-8编码)里面写上这样一句话</p>
<pre><code class="highlight plaintext">char a = &#x27;猿&#x27;;</code></pre>
<p>编译后生成的class文件会把’猿’转化成Unicode的两字节。</p>
<pre><code class="highlight plaintext">&quot;a&quot;.getBytes().length;  //1</code></pre>
<p>getbyte是用你机器默认的编码(Unicode)方式对java内部的ucs-2字符串进行解码所得到的byte所以这个得到的byte不是unicode编码的字节，而是你机器平台的默认编码方式对应的字节比如GBK或者utf-8</p>
<hr />
<ul>
<li>JAVA使用UTF-16的编码(Unicode编码的一种解决方案),该编码方式使用定长,即16位来标识一个&quot;字符&quot;注意该处的字符不是基本数据类型Character),也就是两个字节,所以你看到char类型以及byte类型的大小都是两个字节(因为两个字节所表示的范围已经足够囊括这些,或者说可以囊括常用的).</li>
<li>但是使用8个bit为就可以标识所有英语字符以及英语标点,使用16bit来标识就显得浪费时间了,所以如果是ASCII字符,就会8bit来存储(该处设计到可变长的编码方式,如有疑问,请自行百度),汉字使用8bit是不存用来对应处所有汉字的(或者说常用汉字),所以他采用16bit来标识</li>
<li>总体来讲,可变长编码方案可以有效利用空间.</li>
<li>那么问题来了,计算机如何识别到底该用多少bit来存储该字符那???在可变长编码方案中,每byte种会被插入标志信息,计算机在读取该字符是,首先它会读取该标志位,如果该标志位代表英文字符,它就使用8bit来存储,如果代表汉字,就使用16bit存储</li>
<li>通常字符集会是ASCII编码的超集,因为英语的使用范围太广泛,也就是说,计算机在存储过程中对英语字符都是使用8bit进行存储</li>
<li>验证方式:将byte[]打印出来看看即可</li>
</ul>
<h4 id="字符类型"><a class="markdownIt-Anchor" href="#字符类型"></a> 字符类型</h4>
<p>字符类型char是基本数据类型，它是character的缩写。一个char保存一个Unicode字符：</p>
<pre><code class="highlight plaintext">char c1 = &#x27;A&#x27;;
char c2 = &#x27;中&#x27;;</code></pre>
<p>因为Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用一个char类型表示，它们都占用两个字节。要显示一个字符的Unicode编码，只需将char类型直接赋值给int类型即可：</p>
<pre><code class="highlight plaintext">int n1 = &#x27;A&#x27;; // 字母“A”的Unicodde编码是65
int n2 = &#x27;中&#x27;; // 汉字“中”的Unicode编码是20013</code></pre>
<p>还可以直接用转义字符\u+Unicode编码来表示一个字符：</p>
<pre><code class="highlight plaintext">// 注意是十六进制:
char c3 = &#x27;\u0041&#x27;; // &#x27;A&#x27;，因为十六进制0041 = 十进制65
char c4 = &#x27;\u4e2d&#x27;; // &#x27;中&#x27;，因为十六进制4e2d = 十进制20013</code></pre>
<h4 id="字符串类型"><a class="markdownIt-Anchor" href="#字符串类型"></a> 字符串类型</h4>
<p>Java字符串就是Unicode字符串序列，例如串&quot;Java&quot;就是四个Unicode字符J,a,v,a组成的</p>
<p>Java没有内置的字符串类型，而是再标准Java类库中提供了一个预定义类String，每个用双引号括起来的字符串都是一个String类的实例</p>
<p>String a= new String(“abc”)的意思是：以&quot;abc&quot;这个常量池中的对象为样本，构造出一个内容与“abc”对象完全相同的另一个对象，然后再把new出的对象的引用（地址）返回并初始化String</p>
<p>显示的通过new String()创建对象时，会在堆中生成一个String()对象</p>
<p>String a = “adf”;这句话在编译时便会把adf字符串当作一常量字符串String类型存在方法去中的常量池中，为了提高效率，避免创建出多个String()对象</p>
<p>String a = new String()+“asdf”;这句话底层是通过StringBuffered类的apend()方法实现的</p>
<p>String称为不可变字符序列，即final的</p>
<p>所以String每进行操作都会new一个新对象，新对象便会有一个新地址</p>
<p>双引号引起来的字符串也会作为一个String对象</p>
<p>和char类型不同，字符串类型String是引用类型，我们用双引号&quot;…&quot;表示字符串。一个字符串可以存储0个到任意个字符：</p>
<pre><code class="highlight plaintext">String s = &quot;&quot;; // 空字符串，包含0个字符
String s1 = &quot;A&quot;; // 包含一个字符
String s2 = &quot;ABC&quot;; // 包含3个字符
String s3 = &quot;中文 ABC&quot;; // 包含6个字符，其中有一个空格</code></pre>
<p>因为字符串使用双引号&quot;…&quot;表示开始和结束，那如果字符串本身恰好包含一个&quot;字符怎么表示？例如，“abc&quot;xyz”，编译器就无法判断中间的引号究竟是字符串的一部分还是表示字符串结束。这个时候，我们需要借助转义字符\：</p>
<pre><code class="highlight plaintext">String s = &quot;abc\&quot;xyz&quot;; // 包含7个字符: a, b, c, &quot;, x, y, z</code></pre>
<p>常见的转义字符包括：</p>
<ul>
<li>&quot; 表示字符&quot;</li>
<li>’ 表示字符’</li>
<li>\ 表示字符\</li>
<li>\n 表示换行符</li>
<li>\r 表示回车符</li>
<li>\t 表示Tab</li>
<li>\u#### 表示一个Unicode编码的字符</li>
</ul>
<pre><code class="highlight plaintext">String s = &quot;ABC\n\u4e2d\u6587&quot;; // 包含6个字符: A, B, C, 换行符, 中, 文</code></pre>
<hr />
<p><strong>字符串连接</strong></p>
<p>Java的编译器对字符串做了特殊照顾，可以使用+连接任意字符串和其他数据类型，这样极大地方便了字符串的处理。例如：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        String s1 = &quot;Hello&quot;;
        String s2 = &quot;world&quot;;
        String s = s1 + &quot; &quot; + s2 + &quot;!&quot;;
        System.out.println(s);
    &#125;
&#125;</code></pre>
<blockquote>
<p>如果用+连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接</p>
</blockquote>
<p><strong>多行字符串</strong></p>
<p>如果我们要表示多行字符串，使用+号连接会非常不方便：</p>
<pre><code class="highlight plaintext">String s = &quot;first line \n&quot;
         + &quot;second line \n&quot;
         + &quot;end&quot;;</code></pre>
<p>从Java 13开始，字符串可以用&quot;“”…“”&quot;表示多行字符串（Text Blocks）了。举个例子：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        String s = &quot;&quot;&quot;
                   SELECT * FROM
                     users
                   WHERE id &gt; 100
                   ORDER BY name DESC
                   &quot;&quot;&quot;;
        System.out.println(s);
    &#125;
&#125;</code></pre>
<p>上述多行字符串实际上是5行，在最后一个DESC后面还有一个\n。如果我们不想在字符串末尾加一个\n，就需要这么写：</p>
<pre><code class="highlight plaintext">String s = &quot;&quot;&quot; 
           SELECT * FROM
             users
           WHERE id &gt; 100
           ORDER BY name DESC&quot;&quot;&quot;;</code></pre>
<p>还需要注意到，多行字符串前面共同的空格会被去掉，即：</p>
<pre><code class="highlight plaintext">String s = &quot;&quot;&quot;
...........SELECT * FROM
...........  users
...........WHERE id &gt; 100
...........ORDER BY name DESC
...........&quot;&quot;&quot;;</code></pre>
<blockquote>
<p>用.标注的空格都会被去掉。</p>
</blockquote>
<p><strong>不可变性</strong></p>
<p>Java的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变。考察以下代码：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        String s = &quot;hello&quot;;
        System.out.println(s); // 显示 hello
        s = &quot;world&quot;;
        System.out.println(s); // 显示 world
    &#125;
&#125;</code></pre>
<p>观察执行结果，难道字符串s变了吗？其实变的不是字符串，而是变量s的“指向”</p>
<p>执行String s = “hello”;时，JVM虚拟机先创建字符串&quot;hello&quot;，然后，把字符串变量s指向它：</p>
<p>紧接着，执行s = “world”;时，JVM虚拟机先创建字符串&quot;world&quot;，然后，把字符串变量s指向它：</p>
<p>原来的字符串&quot;hello&quot;还在，只是我们无法通过变量s访问它而已。因此，字符串的不可变是指字符串内容不可变。</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        String s = &quot;hello&quot;;
        String t = s;
        s = &quot;world&quot;;
        System.out.println(t); // t是&quot;hello&quot;
    &#125;
&#125;</code></pre>
<p><strong>null值</strong></p>
<p>引用类型的变量可以指向一个空值null，它表示不存在，即该变量不指向任何对象。例如：</p>
<pre><code class="highlight plaintext">String s1 = null; // s1是null
String s2; // 没有赋初值值，s2也是null
String s3 = s1; // s3也是null
String s4 = &quot;&quot;; // s4指向空字符串，不是null</code></pre>
<hr />
<p><strong>常用方法</strong></p>
<p>输出：</p>
<h3 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h3>
<h4 id="数组类型"><a class="markdownIt-Anchor" href="#数组类型"></a> 数组类型</h4>
<p>可以使用数组来表示“一组”int类型。代码如下：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        // 5位同学的成绩:
        int[] ns = new int[5];
        ns[0] = 68;
        ns[1] = 79;
        ns[2] = 91;
        ns[3] = 85;
        ns[4] = 62;
    &#125;
&#125;</code></pre>
<p>定义一个数组类型的变量，使用数组类型“类型[]”，例如，int[]。和单个基本类型变量不同，数组变量初始化必须使用new int[5]表示创建一个可容纳5个int元素的数组</p>
<p>Java的数组有几个特点：</p>
<ul>
<li>数组所有元素初始化为默认值，整型都是0，浮点型是0.0，布尔型是false；</li>
<li>数组一旦创建后，大小就不可改变。</li>
</ul>
<p>要访问数组中的某一个元素，需要使用索引。数组索引从0开始，例如，5个元素的数组，索引范围是0~4</p>
<p>可以修改数组中的某一个元素，使用赋值语句，例如，</p>
<pre><code class="highlight plaintext">ns[1] = 79;</code></pre>
<p>可以用.length获取数组大小</p>
<pre><code class="highlight plaintext">数组变量.length</code></pre>
<p>数组是引用类型，在使用索引访问数组元素时，如果索引超出范围，运行时将报错：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        // 5位同学的成绩:
        int[] ns = new int[5];
        int n = 5;
        System.out.println(ns[n]); // 索引n不能超出范围
    &#125;
&#125;</code></pre>
<p>也可以在定义数组时直接指定初始化的元素，这样就不必写出数组大小，而是由编译器自动推算数组大小。例如：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        // 5位同学的成绩:
        int[] ns = new int[] &#123; 68, 79, 91, 85, 62 &#125;;
        //可简写int[] ns = &#123; 68, 79, 91, 85, 62 &#125;;
        System.out.println(ns.length); // 编译器自动推算数组大小为5
    &#125;
&#125;</code></pre>
<p>注意数组是引用类型，并且数组大小不可变。我们观察下面的代码：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        // 5位同学的成绩:
        int[] ns;
        ns = new int[] &#123; 68, 79, 91, 85, 62 &#125;;
        System.out.println(ns.length); // 5
        ns = new int[] &#123; 1, 2, 3 &#125;;
        System.out.println(ns.length); // 3
    &#125;
&#125;</code></pre>
<p>数组大小变了吗？看上去好像是变了，但其实根本没变。</p>
<p>对于数组ns来说，执行ns = new int[] { 68, 79, 91, 85, 62 };时，它指向一个5个元素的数组：</p>
<p>执行ns = new int[] { 1, 2, 3 };时，它指向一个新的3个元素的数组：</p>
<p>但是，原有的5个元素的数组并没有改变，只是无法通过变量ns引用到它们而已。</p>
<hr />
<p><strong>字符串数组</strong></p>
<p>如果数组元素不是基本类型，而是一个引用类型，那么，修改数组元素会有哪些不同？</p>
<p>字符串是引用类型，因此我们先定义一个字符串数组：</p>
<pre><code class="highlight plaintext">String[] names = &#123;
    &quot;ABC&quot;, &quot;XYZ&quot;, &quot;zoo&quot;
&#125;;</code></pre>
<p>对于String[]类型的数组变量names，它实际上包含3个元素，但每个元素都指向某个字符串对象：</p>
<p>对names[1]进行赋值，例如names[1] = “cat”;，效果如下：</p>
<p>这里注意到原来names[1]指向的字符串&quot;XYZ&quot;并没有改变，仅仅是将names[1]的引用从指向&quot;XYZ&quot;改成了指向&quot;cat&quot;，其结果是字符串&quot;XYZ&quot;再也无法通过names[1]访问到了。</p>
<h4 id="操作数组"><a class="markdownIt-Anchor" href="#操作数组"></a> 操作数组</h4>
<h5 id="遍历数组"><a class="markdownIt-Anchor" href="#遍历数组"></a> 遍历数组</h5>
<p>两种方式遍历数组：</p>
<p><strong>for 循环</strong></p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        int[] ns = &#123; 1, 4, 9, 16, 25 &#125;;
        for (int i=0; i&lt;ns.length; i++) &#123;
            int n = ns[i];
            System.out.println(n);
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>for each</strong></p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        int[] ns = &#123; 1, 4, 9, 16, 25 &#125;;
        for (int n : ns) &#123;
            System.out.println(n);
        &#125;
    &#125;
&#125;</code></pre>
<blockquote>
<p>注意：在for (int n : ns)循环中，变量n直接拿到ns数组的元素，而不是索引</p>
</blockquote>
<p>显然for each循环更加简洁。但是，for each循环无法拿到数组的索引，因此，到底用哪一种for循环，取决于我们的需要</p>
<hr />
<p><strong>打印数组内容</strong></p>
<p>直接打印数组变量，得到的是数组在JVM中的引用地址：</p>
<pre><code class="highlight plaintext">int[] ns = &#123; 1, 1, 2, 3, 5, 8 &#125;;
System.out.println(ns); // 类似 [I@7852e922</code></pre>
<p>这并没有什么意义，因为我们希望打印的数组的元素内容。因此，使用for each循环来打印它：</p>
<pre><code class="highlight plaintext">int[] ns = &#123; 1, 1, 2, 3, 5, 8 &#125;;
for (int n : ns) &#123;
    System.out.print(n + &quot;, &quot;);
&#125;</code></pre>
<p>使用for each循环打印也很麻烦。幸好Java标准库提供了Arrays.toString()，可以快速打印数组内容：</p>
<pre><code class="highlight plaintext">import java.util.Arrays;

public class Main &#123;
    public static void main(String[] args) &#123;
        int[] ns = &#123; 1, 1, 2, 3, 5, 8 &#125;;
        System.out.println(Arrays.toString(ns));
    &#125;
&#125;</code></pre>
<h5 id="数组排序"><a class="markdownIt-Anchor" href="#数组排序"></a> 数组排序</h5>
<p>对数组进行排序是程序中非常基本的需求。常用的排序算法有冒泡排序、插入排序和快速排序等。</p>
<p>我们来看一下如何使用冒泡排序算法对一个整型数组从小到大进行排序：</p>
<p><strong>冒泡排序</strong></p>
<ul>
<li>冒泡排序的特点是，每一轮循环后，最大的一个数被交换到末尾，因此，下一轮循环就可以“刨除”最后的数，每一轮循环都比上一轮循环的结束位置靠前一位</li>
</ul>
<pre><code class="highlight plaintext">import java.util.Arrays;

public class Main &#123;
    public static void main(String[] args) &#123;
        int[] ns = &#123; 28, 12, 89, 73, 65, 18, 96, 50, 8, 36 &#125;;
        // 排序前:
        System.out.println(Arrays.toString(ns));
        for (int i = 0; i &lt; ns.length - 1; i++) &#123;
            for (int j = 0; j &lt; ns.length - i - 1; j++) &#123;
                if (ns[j] &gt; ns[j+1]) &#123;
                    // 交换ns[j]和ns[j+1]:
                    int tmp = ns[j];
                    ns[j] = ns[j+1];
                    ns[j+1] = tmp;
                &#125;
            &#125;
        &#125;
        // 排序后:
        System.out.println(Arrays.toString(ns));
    &#125;
&#125;
</code></pre>
<blockquote>
<p>实际上，Java的标准库已经内置了排序功能，我们只需要调用JDK提供的Arrays.sort()就可以排序：</p>
</blockquote>
<pre><code class="highlight plaintext">import java.util.Arrays;

public class Main &#123;
    public static void main(String[] args) &#123;
        int[] ns = &#123; 28, 12, 89, 73, 65, 18, 96, 50, 8, 36 &#125;;
        Arrays.sort(ns);
        System.out.println(Arrays.toString(ns));
    &#125;
&#125;</code></pre>
<p>必须注意，对数组排序实际上修改了数组本身。例如，排序前的数组是：</p>
<pre><code class="highlight plaintext">int[] ns = &#123; 9, 3, 6, 5 &#125;;</code></pre>
<p>在内存中，这个整型数组表示如下：</p>
<p>当我们调用Arrays.sort(ns);后，这个整型数组在内存中变为：</p>
<p>即变量ns指向的数组内容已经被改变了。如果对一个字符串数组进行排序，例如：</p>
<pre><code class="highlight plaintext">String[] ns = &#123; &quot;banana&quot;, &quot;apple&quot;, &quot;pear&quot; &#125;;</code></pre>
<p>排序前，这个数组在内存中表示如下：</p>
<p>调用Arrays.sort(ns);排序后，这个数组在内存中表示如下：</p>
<p>原来的3个字符串在内存中均没有任何变化，但是ns数组的每个元素指向变化了。</p>
<h5 id="多维数组"><a class="markdownIt-Anchor" href="#多维数组"></a> 多维数组</h5>
<p><strong>二维数组</strong></p>
<p>就是数组的数组。定义一个二维数组如下：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        int[][] ns = &#123;
            &#123; 1, 2, 3, 4 &#125;,
            &#123; 5, 6, 7, 8 &#125;,
            &#123; 9, 10, 11, 12 &#125;
        &#125;;
        System.out.println(ns.length); // 3
    &#125;
&#125;</code></pre>
<p>因为ns包含3个数组，因此，ns.length为3。实际上ns在内存中的结构如下：</p>
<p>如果我们定义一个普通数组arr0，然后把ns[0]赋值给它：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        int[][] ns = &#123;
            &#123; 1, 2, 3, 4 &#125;,
            &#123; 5, 6, 7, 8 &#125;,
            &#123; 9, 10, 11, 12 &#125;
        &#125;;
        int[] arr0 = ns[0];
        System.out.println(arr0.length); // 4
    &#125;
&#125;</code></pre>
<p>实际上arr0就获取了ns数组的第0个元素。因为ns数组的每个元素也是一个数组，因此，arr0指向的数组就是{ 1, 2, 3, 4 }。在内存中，结构如下：</p>
<p>访问二维数组的某个元素需要使用array[row][col]，例如：</p>
<pre><code class="highlight plaintext">System.out.println(ns[1][2]); // 7</code></pre>
<p>二维数组的每个数组元素的长度并不要求相同，例如，可以这么定义ns数组：</p>
<pre><code class="highlight plaintext">int[][] ns = &#123;
    &#123; 1, 2, 3, 4 &#125;,
    &#123; 5, 6 &#125;,
    &#123; 7, 8, 9 &#125;
&#125;;</code></pre>
<p>这个二维数组在内存中的结构如下：</p>
<p>要打印一个二维数组，可以使用两层嵌套的for循环：</p>
<pre><code class="highlight plaintext">for (int[] arr : ns) &#123;
    for (int n : arr) &#123;
        System.out.print(n);
        System.out.print(&#x27;, &#x27;);
    &#125;
    System.out.println();
&#125;</code></pre>
<p>或者使用Java标准库的<code>Arrays.deepToString()</code>：</p>
<pre><code class="highlight plaintext">import java.util.Arrays;

public class Main &#123;
    public static void main(String[] args) &#123;
        int[][] ns = &#123;
            &#123; 1, 2, 3, 4 &#125;,
            &#123; 5, 6, 7, 8 &#125;,
            &#123; 9, 10, 11, 12 &#125;
        &#125;;
        System.out.println(Arrays.deepToString(ns));
    &#125;
&#125;</code></pre>
<hr />
<p><strong>三维数组</strong></p>
<p>三维数组就是二维数组的数组。可以这么定义一个三维数组：</p>
<pre><code class="highlight plaintext">int[][][] ns = &#123;
    &#123;
        &#123;1, 2, 3&#125;,
        &#123;4, 5, 6&#125;,
        &#123;7, 8, 9&#125;
    &#125;,
    &#123;
        &#123;10, 11&#125;,
        &#123;12, 13&#125;
    &#125;,
    &#123;
        &#123;14, 15, 16&#125;,
        &#123;17, 18&#125;
    &#125;
&#125;;</code></pre>
<p>它在内存中的结构如下：</p>
<p>如果我们要访问三维数组的某个元素，例如，ns[2][0][1]，只需要顺着定位找到对应的最终元素15即可。</p>
<p>理论上，我们可以定义任意的N维数组。但在实际应用中，除了二维数组在某些时候还能用得上，更高维度的数组很少使用。</p>
<h5 id="命令行参数"><a class="markdownIt-Anchor" href="#命令行参数"></a> 命令行参数</h5>
<p>Java程序的入口是main方法，而main方法可以接受一个命令行参数，它是一个String[]数组</p>
<p>这个命令行参数由JVM接收用户输入并传给main方法：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        for (String arg : args) &#123;
            System.out.println(arg);
        &#125;
    &#125;
&#125;</code></pre>
<p>我们可以利用接收到的命令行参数，根据不同的参数执行不同的代码。例如，实现一个-version参数，打印程序版本号：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        for (String arg : args) &#123;
            if (&quot;-version&quot;.equals(arg)) &#123;
                System.out.println(&quot;v 1.0&quot;);
                break;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>上面这个程序必须在命令行执行，我们先编译它：</p>
<pre><code class="highlight plaintext">$ javac Main.java</code></pre>
<p>然后，执行的时候，给它传递一个-version参数：</p>
<pre><code class="highlight plaintext">$ java Main -version
v 1.0</code></pre>
<p>这样，程序就可以根据传入的命令行参数，作出不同的响应。</p>
<h3 id="流程控制"><a class="markdownIt-Anchor" href="#流程控制"></a> 流程控制</h3>
<h4 id="输入输出"><a class="markdownIt-Anchor" href="#输入输出"></a> 输入输出</h4>
<h5 id="输出"><a class="markdownIt-Anchor" href="#输出"></a> 输出</h5>
<p>在前面的代码中，我们总是使用<code>System.out.println()</code>来向屏幕输出一些内容。</p>
<p>println是print line的缩写，表示输出并换行。因此，如果输出后不想换行，可以用print()：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        System.out.print(&quot;A,&quot;);
        System.out.print(&quot;B,&quot;);
        System.out.print(&quot;C.&quot;);
        System.out.println();
        System.out.println(&quot;END&quot;);
    &#125;
&#125;</code></pre>
<p><strong>格式化输出</strong></p>
<p>Java还提供了格式化输出的功能。为什么要格式化输出？因为计算机表示的数据不一定适合人来阅读：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        double d = 12900000;
        System.out.println(d); // 1.29E7
    &#125;
&#125;</code></pre>
<p>如果要把数据显示成我们期望的格式，就需要使用格式化输出的功能。格式化输出使用System.out.printf()，通过使用占位符%?，printf()可以把后面的参数格式化成指定格式：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        double d = 3.1415926;
        System.out.printf(&quot;%.2f\n&quot;, d); // 显示两位小数3.14
        System.out.printf(&quot;%.4f\n&quot;, d); // 显示4位小数3.1416
    &#125;
&#125;</code></pre>
<p>Java的格式化功能提供了多种占位符，可以把各种数据类型“格式化”成指定的字符串：</p>
<table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%d</td>
<td>格式化输出整数</td>
</tr>
<tr>
<td>%x</td>
<td>格式化输出十六进制整数</td>
</tr>
<tr>
<td>%f</td>
<td>格式化输出浮点数</td>
</tr>
<tr>
<td>%e</td>
<td>格式化输出科学计数法表示的浮点数</td>
</tr>
<tr>
<td>%s</td>
<td>格式化字符串</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意，由于%表示占位符，因此，连续两个%%表示一个%字符本身</p>
</blockquote>
<p>占位符本身还可以有更详细的格式化参数。下面的例子把一个整数格式化成十六进制，并用0补足8位：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        int n = 12345000;
        System.out.printf(&quot;n=%d, hex=%08x&quot;, n, n); // 注意，两个%占位符必须传入两个数
    &#125;
&#125;</code></pre>
<h5 id="输入"><a class="markdownIt-Anchor" href="#输入"></a> 输入</h5>
<pre><code class="highlight plaintext">import java.util.Scanner;

public class Main &#123;
    public static void main(String[] args) &#123;
        Scanner scanner = new Scanner(System.in); // 创建Scanner对象
        System.out.print(&quot;Input your name: &quot;); // 打印提示
        String name = scanner.nextLine(); // 读取一行输入并获取字符串
        System.out.print(&quot;Input your age: &quot;); // 打印提示
        int age = scanner.nextInt(); // 读取一行输入并获取整数
        System.out.printf(&quot;Hi, %s, you are %d\n&quot;, name, age); // 格式化输出
    &#125;
&#125;</code></pre>
<p><a target="_blank" rel="noopener" href="http://xn--ScannerSystem-ob4ud8x72ce47dvmjonc7230b.in">创建Scanner对象并传入System.in</a>。System.out代表标准输出流，而System.in代表标准输入流。直接使用System.in读取用户输入虽然是可以的，但需要更复杂的代码，而通过Scanner就可以简化后续的代码</p>
<p>有了Scanner对象后，要读取用户输入的字符串，使用scanner.nextLine()，要读取用户输入的整数，使用scanner.nextInt()。Scanner会自动转换数据类型，因此不必手动转换</p>
<h4 id="if"><a class="markdownIt-Anchor" href="#if"></a> if</h4>
<p>在Java程序中，如果要根据条件来决定是否执行某一段代码，就需要if语句。</p>
<pre><code class="highlight plaintext">if (条件) &#123;
    // 条件满足时执行
&#125;else if(条件)&#123;
    // 条件满足时执行
&#125;else&#123;
    // 条件满足时执行
&#125;</code></pre>
<p>根据if的计算结果（true还是false），JVM决定是否执行if语句块（即花括号{}包含的所有语句）</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        int n = 70;
        if (n &gt;= 60) &#123;
            System.out.println(&quot;及格了&quot;);
        &#125;
        System.out.println(&quot;END&quot;);
    &#125;
&#125;</code></pre>
<p>当条件n &gt;= 60计算结果为true时，if语句块被执行，将打印&quot;及格了&quot;，否则，if语句块将被跳过。修改n的值可以看到执行效果。</p>
<blockquote>
<p>当if语句块只有一行语句时，可以省略花括号{}：</p>
</blockquote>
<hr />
<p>判断数字是否相等：</p>
<ul>
<li>前面讲过了浮点数在计算机中常常无法精确表示，并且计算可能出现误差，因此，判断浮点数相等用==判断不靠谱</li>
</ul>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        double x = 1 - 9.0 / 10;
        if (Math.abs(x - 0.1) &lt; 0.00001) &#123;
            System.out.println(&quot;x is 0.1&quot;);
        &#125; else &#123;
            System.out.println(&quot;x is NOT 0.1&quot;);
        &#125;
    &#125;
&#125;</code></pre>
<hr />
<p><strong>判断引用类型相等</strong></p>
<p>在Java中，判断值类型的变量是否相等，可以使用==运算符。但是，判断引用类型的变量是否相等，<mark>表示“引用是否相等”，或者说，是否指向同一个对象。例如，下面的两个String类型，它们的内容是相同的，但是，分别指向不同的对象，用</mark>判断，结果为false：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        String s1 = &quot;hello&quot;;
        String s2 = &quot;HELLO&quot;.toLowerCase();
        System.out.println(s1);
        System.out.println(s2);
        if (s1 == s2) &#123;
            System.out.println(&quot;s1 == s2&quot;);
        &#125; else &#123;
            System.out.println(&quot;s1 != s2&quot;);
        &#125;
    &#125;
&#125;</code></pre>
<p>要判断引用类型的变量内容是否相等，必须使用equals()方法：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        String s1 = &quot;hello&quot;;
        String s2 = &quot;HELLO&quot;.toLowerCase();
        System.out.println(s1);
        System.out.println(s2);
        if (s1.equals(s2)) &#123;
            System.out.println(&quot;s1 equals s2&quot;);
        &#125; else &#123;
            System.out.println(&quot;s1 not equals s2&quot;);
        &#125;
    &#125;
&#125;</code></pre>
<blockquote>
<p>注意：执行语句s1.equals(s2)时，如果变量s1为null，会报NullPointerException：</p>
</blockquote>
<p>要避免NullPointerException错误，可以利用短路运算符&amp;&amp;：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        String s1 = null;
        if (s1 != null &amp;&amp; s1.equals(&quot;hello&quot;)) &#123;
            System.out.println(&quot;hello&quot;);
        &#125;
    &#125;
&#125;</code></pre>
<blockquote>
<p>还可以把一定不是null的对象&quot;hello&quot;放到前面：例如：</p>
</blockquote>
<pre><code class="highlight plaintext">if (&quot;hello&quot;.equals(s)) &#123; ... &#125;</code></pre>
<h4 id="switch"><a class="markdownIt-Anchor" href="#switch"></a> switch</h4>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        String fruit = &quot;apple&quot;;
        switch (fruit) &#123;
        case &quot;apple&quot;:
            System.out.println(&quot;Selected apple&quot;);
            break;
        case &quot;pear&quot;:
            System.out.println(&quot;Selected pear&quot;);
            break;
        case &quot;mango&quot;:
            System.out.println(&quot;Selected mango&quot;);
            break;
        default:
            System.out.println(&quot;No fruit selected&quot;);
            break;
        &#125;
    &#125;
&#125;</code></pre>
<blockquote>
<p>case语句具有“穿透性”，漏写break将导致后续case代码全部执行</p>
</blockquote>
<h4 id="while"><a class="markdownIt-Anchor" href="#while"></a> while</h4>
<p>while循环在每次循环开始前，首先判断条件是否成立。如果计算结果为true，就把循环体内的语句执行一遍，如果计算结果为false，那就直接跳到while循环的末尾，继续往下执行</p>
<pre><code class="highlight plaintext">while (条件表达式) &#123;
    循环语句
&#125;
// 继续执行后续代码</code></pre>
<blockquote>
<p>注意到while循环是先判断循环条件，再循环，因此，有可能一次循环都不做</p>
</blockquote>
<h4 id="de-while-循环"><a class="markdownIt-Anchor" href="#de-while-循环"></a> de while 循环</h4>
<p>在Java中，while循环是先判断循环条件，再执行循环。而另一种do while循环则是先执行循环，再判断条件，条件满足时继续循环，条件不满足时退出。它的用法是：</p>
<pre><code class="highlight plaintext">do &#123;
    执行循环语句
&#125; while (条件表达式);</code></pre>
<blockquote>
<p>可见，do while循环会至少循环一次</p>
</blockquote>
<h4 id="for循环"><a class="markdownIt-Anchor" href="#for循环"></a> for循环</h4>
<p>for循环的功能非常强大，它使用计数器实现循环。for循环会先初始化计数器，然后，在每次循环前检测循环条件，在每次循环后更新计数器。计数器变量通常命名为i</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        int sum = 0;
        for (int i=1; i&lt;=100; i++) &#123;
            sum = sum + i;
        &#125;
        System.out.println(sum);
    &#125;
&#125;</code></pre>
<p>在for循环执行前，会先执行初始化语句int i=1，它定义了计数器变量i并赋初始值为1，然后，循环前先检查循环条件i&lt;=100，循环后自动执行i++，因此，和while循环相比，for循环把更新计数器的代码统一放到了一起。在for循环的循环体内部，不需要去更新变量i</p>
<p>因此，for循环的用法是：</p>
<pre><code class="highlight plaintext">for (初始条件; 循环检测条件; 循环后更新计数器) &#123;
    // 执行语句
&#125;</code></pre>
<hr />
<p><strong>灵活使用for循环</strong></p>
<p>for循环还可以缺少初始化语句、循环条件和每次循环更新语句，例如：</p>
<pre><code class="highlight plaintext">// 不设置结束条件:
for (int i=0; ; i++) &#123;
    ...
&#125;</code></pre>
<pre><code class="highlight plaintext">// 不设置结束条件和更新语句:
for (int i=0; ;) &#123;
    ...
&#125;</code></pre>
<pre><code class="highlight plaintext">// 什么都不设置:
for (;;) &#123;
    ...
&#125;</code></pre>
<hr />
<p><strong>for each循环</strong></p>
<ul>
<li>和for循环相比，for each循环的变量n不再是计数器，而是直接对应到数组的每个元素。for each循环的写法也更简洁。但是，for each循环无法指定遍历顺序，也无法获取数组的索引</li>
</ul>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        int[] ns = &#123; 1, 4, 9, 16, 25 &#125;;
        for (int n : ns) &#123;
            System.out.println(n);
        &#125;
    &#125;
&#125;</code></pre>
<h4 id="break和continue"><a class="markdownIt-Anchor" href="#break和continue"></a> break和continue</h4>
<p><strong>break</strong></p>
<p>在循环过程中，可以使用break语句跳出当前循环</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        int sum = 0;
        for (int i=1; ; i++) &#123;
            sum = sum + i;
            if (i == 100) &#123;
                break;
            &#125;
        &#125;
        System.out.println(sum);
    &#125;
&#125;</code></pre>
<p>使用for循环计算从1到100时，我们并没有在for()中设置循环退出的检测条件。但是，在循环内部，我们用if判断，如果i==100，就通过break退出循环</p>
<p>因此，break语句通常都是配合if语句使用。要特别注意，break语句总是跳出自己所在的那一层循环</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        for (int i=1; i&lt;=10; i++) &#123;
            System.out.println(&quot;i = &quot; + i);
            for (int j=1; j&lt;=10; j++) &#123;
                System.out.println(&quot;j = &quot; + j);
                if (j &gt;= i) &#123;
                    break;
                &#125;
            &#125;
            // break跳到这里
            System.out.println(&quot;breaked&quot;);
        &#125;
    &#125;
&#125;</code></pre>
<p>上面的代码是两个for循环嵌套。因为break语句位于内层的for循环，因此，它会跳出内层for循环，但不会跳出外层for循环。</p>
<hr />
<p><strong>continue</strong></p>
<p>break会跳出当前循环，也就是整个循环都不会执行了。而continue则是提前结束本次循环，直接继续执行下次循环。我们看一个例子：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        int sum = 0;
        for (int i=1; i&lt;=10; i++) &#123;
            System.out.println(&quot;begin i = &quot; + i);
            if (i % 2 == 0) &#123;
                continue; // continue语句会结束本次循环
            &#125;
            sum = sum + i;
            System.out.println(&quot;end i = &quot; + i);
        &#125;
        System.out.println(sum); // 25
    &#125;
&#125;</code></pre>
<blockquote>
<p>在多层嵌套的循环中，continue语句同样是结束本次自己所在的循环</p>
</blockquote>
<h2 id="面向对象"><a class="markdownIt-Anchor" href="#面向对象"></a> 面向对象</h2>
<h3 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h3>
<p>对象是具体的，类是抽象的，类是一个模板，通过这个类的模板我门可以new对象</p>
<p>类的初始化顺序：（静态变量，静态初始化块）–&gt;（变量，初始化块）–&gt;构造器</p>
<pre><code class="highlight plaintext">public class name&#123;
     //属性     建议使用private
     private    数据类型    属性名   //建议增加相应的getter,setter方法
     //方法

     //构造方法（构造器） 
          1.方法名必须与类名保持一致
          2.无需加返回类型    实际返回该类的一个对象
          3.通过new来调用
          4.无参构造器
               如果我们没有手动定义构造器，系统会为我们添加一个无参构造器
               如果我们自己定义了构造器，系统就不会为我们添加无参构造器
          5.构造方法的第一句总是super，即调用直接父类的构造方法
               有继承关系的构造方法的调用顺序：父类-&gt;子类

&#125;
</code></pre>
<p><strong>定义class</strong></p>
<p>在Java中，创建一个类，例如，给这个类命名为Person，就是定义一个class：</p>
<pre><code class="highlight plaintext">class Person &#123;
    public String name;
    public int age;
&#125;</code></pre>
<p>一个class可以包含多个字段（field），字段用来描述一个类的特征。上面的Person类，我们定义了两个字段，一个是String类型的字段，命名为name，一个是int类型的字段，命名为age。因此，通过class，把一组数据汇集到一个对象上，实现了数据封装</p>
<blockquote>
<p>public是用来修饰字段的，它表示这个字段可以被外部访问</p>
</blockquote>
<hr />
<p><strong>创建实例</strong></p>
<p>创建实例定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符。new操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例：</p>
<pre><code class="highlight plaintext">Person ming = new Person();</code></pre>
<p>上述代码创建了一个Person类型的实例，并通过变量ming指向它</p>
<blockquote>
<p>注意区分Person ming是定义Person类型的变量ming，而new Person()是创建Person实例</p>
</blockquote>
<p>有了指向这个实例的变量，我们就可以通过这个变量来操作实例。访问实例变量可以用变量.字段，例如：</p>
<pre><code class="highlight plaintext">ming.name = &quot;Xiao Ming&quot;; // 对字段name赋值
ming.age = 12; // 对字段age赋值
System.out.println(ming.name); // 访问字段name

Person hong = new Person();
hong.name = &quot;Xiao Hong&quot;;
hong.age = 15;</code></pre>
<p>上述两个变量分别指向两个不同的实例，它们在内存中的结构如下：</p>
<p>两个instance拥有class定义的name和age字段，且各自都有一份独立的数据，互不干扰</p>
<h3 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h3>
<p><strong>定义方法</strong></p>
<pre><code class="highlight plaintext">修饰符 方法返回类型 方法名(方法参数列表) &#123;
    若干方法语句;
    return 方法返回值;
&#125;</code></pre>
<blockquote>
<p>方法返回值通过return语句实现，如果没有返回值，返回类型设置为void，可以省略return</p>
</blockquote>
<hr />
<p><strong>private方法</strong></p>
<p>有public方法，自然就有private方法。和private字段一样，private方法不允许外部调用</p>
<p>定义private方法的理由是内部方法是可以调用private方法的</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Person ming = new Person();
        ming.setBirth(2008);
        System.out.println(ming.getAge());
    &#125;
&#125;

class Person &#123;
    private String name;
    private int birth;

    public void setBirth(int birth) &#123;
        this.birth = birth;
    &#125;

    public int getAge() &#123;
        return calcAge(2019); // 调用private方法
    &#125;

    // private方法:
    private int calcAge(int currentYear) &#123;
        return currentYear - this.birth;
    &#125;
&#125;</code></pre>
<blockquote>
<p>观察上述代码，calcAge()是一个private方法，外部代码无法调用，但是，内部方法getAge()可以调用它</p>
</blockquote>
<blockquote>
<p>此外，我们还注意到，这个Person类只定义了birth字段，没有定义age字段，获取age时，通过方法getAge()返回的是一个实时计算的值，并非存储在某个字段的值。这说明方法可以封装一个类的对外接口，调用方不需要知道也不关心Person实例在内部到底有没有age字段</p>
</blockquote>
<hr />
<h4 id="this变量"><a class="markdownIt-Anchor" href="#this变量"></a> <strong>this变量</strong></h4>
<ol>
<li>jvm有类加载器，第一次加载类时执行类中的static域，jvm会专门划分一个内存区域给static程序块，可以成为静态区。属于这个类。</li>
<li>this指针是指向类的对象，在实例化对象时jvm会在堆区分配内存给一个具体的对象，this指针指向这个对象。而类中的static域始终是在静态区分配内存，this指向堆区，所以不能调用。static是属于类的。</li>
<li>this是对象指针对于static修饰的方法而言，可以使用类名来直接调用该方法，如果在static修饰的方法中使用this关键字，则这个关键字就无法指向合适的对象。所以static修饰的方法中不能使用this引用.从另外一个方面来说，由于static修饰的方法不能使用this引 用，所以static修饰的方法不能访问不使用static修饰的普通成员，这与静态成员不能直接访问非静态成员的结论也是一致的</li>
<li>static叫静态方法，也叫类方法，就是在程序启动的时候，就会为这个方法分配一块内存空间，所以什么时候都可以调用这个方法。</li>
</ol>
<p>没有static的其他方法，非静态方法，必须在类实例化时，才有内存空间，所以在类实例化之前是无法调用的。</p>
<p>所以，静态方法里不能调用非静态方法，除非你先实例化那个类。</p>
<p>this不能在static方法中使用</p>
<p>在方法内部，可以使用一个隐含的变量this，它始终指向当前实例。因此，通过this.field就可以访问当前实例的字段</p>
<p>如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上this</p>
<pre><code class="highlight plaintext">class Person &#123;
    private String name;

    public void setName(String name) &#123;
        this.name = name; // 前面的this不可少，少了就变成局部变量name了
    &#125;
&#125;</code></pre>
<hr />
<p><strong>方法参数</strong></p>
<p>方法可以包含0个或任意个参数。方法参数用于接收传递给方法的变量值。调用方法时，必须严格按照参数的定义一一传递</p>
<pre><code class="highlight plaintext">class Person &#123;
    ...
    public void setNameAndAge(String name, int age) &#123;
        ...
    &#125;
&#125;</code></pre>
<p>调用这个setNameAndAge()方法时，必须有两个参数，且第一个参数必须为String，第二个参数必须为int：</p>
<pre><code class="highlight plaintext">Person ming = new Person();
ming.setNameAndAge(&quot;Xiao Ming&quot;); // 编译错误：参数个数不对
ming.setNameAndAge(12, &quot;Xiao Ming&quot;); // 编译错误：参数类型不对</code></pre>
<hr />
<p><strong>可变参数</strong></p>
<p>可变参数用<code>类型...</code>定义，可变参数相当于数组类型：</p>
<pre><code class="highlight plaintext">class Group &#123;
    private String[] names;

    public void setNames(String... names) &#123;
        this.names = names;
    &#125;
&#125;</code></pre>
<p>上面的setNames()就定义了一个可变参数。调用时，可以这么写：</p>
<pre><code class="highlight plaintext">Group g = new Group();
g.setNames(&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;, &quot;Xiao Jun&quot;); // 传入3个String
g.setNames(&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;); // 传入2个String
g.setNames(&quot;Xiao Ming&quot;); // 传入1个String
g.setNames(); // 传入0个String</code></pre>
<p>完全可以把可变参数改写为String[]类型：</p>
<pre><code class="highlight plaintext">class Group &#123;
    private String[] names;

    public void setNames(String[] names) &#123;
        this.names = names;
    &#125;
&#125;</code></pre>
<p>但是，调用方需要自己先构造String[]，比较麻烦。例如：</p>
<pre><code class="highlight plaintext">Group g = new Group();
g.setNames(new String[] &#123;&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;, &quot;Xiao Jun&quot;&#125;); // 传入1个String[]</code></pre>
<p>另一个问题是，调用方可以传入null：</p>
<pre><code class="highlight plaintext">Group g = new Group();
g.setNames(null);</code></pre>
<p>而可变参数可以保证无法传入null，因为传入0个参数时，接收到的实际值是一个空数组而不是null</p>
<hr />
<p><strong>参数绑定</strong></p>
<p>调用方把参数传递给实例方法时，调用时传递的值会按参数位置一一绑定。</p>
<p>我们先观察一个<strong>基本类型</strong>参数的传递：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Person p = new Person();
        int n = 15; // n的值为15
        p.setAge(n); // 传入n的值
        System.out.println(p.getAge()); // 15
        n = 20; // n的值改为20
        System.out.println(p.getAge()); // 15
    &#125;
&#125;

class Person &#123;
    private int age;

    public int getAge() &#123;
        return this.age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;
&#125;</code></pre>
<p>运行代码，从结果可知，修改外部的局部变量n，不影响实例p的age字段，原因是setAge()方法获得的参数，复制了n的值，因此，p.age和局部变量n互不影响</p>
<p>结论：基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响</p>
<p>我们再看一个传递<strong>引用参数</strong>的例子：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Person p = new Person();
        String[] fullname = new String[] &#123; &quot;Homer&quot;, &quot;Simpson&quot; &#125;;
        p.setName(fullname); // 传入fullname数组
        System.out.println(p.getName()); // &quot;Homer Simpson&quot;
        fullname[0] = &quot;Bart&quot;; // fullname数组的第一个元素修改为&quot;Bart&quot;
        System.out.println(p.getName()); // &quot;Homer Simpson&quot;还是&quot;Bart Simpson&quot;?
    &#125;
&#125;

class Person &#123;
    private String[] name;

    public String getName() &#123;
        return this.name[0] + &quot; &quot; + this.name[1];
    &#125;

    public void setName(String[] name) &#123;
        this.name = name;
    &#125;
&#125;</code></pre>
<p>注意到setName()的参数现在是一个数组。一开始，把fullname数组传进去，然后，修改fullname数组的内容，结果发现，实例p的字段p.name也被修改了！</p>
<p>结论：引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）</p>
<blockquote>
<p>但是如果传入的String类型，就不会有参数绑定的情况</p>
</blockquote>
<h3 id="构造方法"><a class="markdownIt-Anchor" href="#构造方法"></a> 构造方法</h3>
<p><strong>如果子类的构造器没有显式的调用超类的构造器，则将自动调用超类默认的(无参)构造器</strong>，如果超类没有不带参数的构造器，并且子类中没有显式的调用超类其他构造器，则java编译错误</p>
<p><strong>子类的构造器也不可以直接访问父类的私有域，可以通过super对实现对超类构造器的调用</strong></p>
<p><strong>构造方法会系统默认的返回创建对象的(引用)地址</strong></p>
<p><strong>所有的构造方法第一句总是super()</strong></p>
<p><strong>如果没有写构造方法，编译器(eclipse)会自动加上一个无参的构造方法</strong></p>
<ul>
<li>实例在创建时通过new操作符会调用其对应的构造方法，构造方法用于初始化实例；</li>
<li>没有定义构造方法时，编译器会自动创建一个默认的无参数构造方法；</li>
<li>可以定义多个构造方法，编译器根据参数自动判断；</li>
<li>可以在一个构造方法内部调用另一个构造方法，便于代码复用</li>
</ul>
<pre><code class="highlight plaintext">class Person &#123;
    public Person() &#123;
    &#125;
&#125;</code></pre>
<blockquote>
<p><strong>要特别注意的是，如果我们自定义了一个构造方法，那么，编译器就不再自动创建默认构造方法</strong></p>
</blockquote>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Person p = new Person(); // 编译错误:找不到这个构造方法
    &#125;
&#125;

class Person &#123;
    private String name;
    private int age;

    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
    
    public String getName() &#123;
        return this.name;
    &#125;

    public int getAge() &#123;
        return this.age;
    &#125;
&#125;</code></pre>
<p>如果既对字段进行初始化，又在构造方法中对字段进行初始化：</p>
<pre><code class="highlight plaintext">class Person &#123;
    private String name = &quot;Unamed&quot;;
    private int age = 10;

    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
&#125;</code></pre>
<p>当我们创建对象的时候，<code>new Person(&quot;Xiao Ming&quot;, 12)</code>得到的对象实例，字段的初始值是啥？</p>
<p>在Java中，创建对象实例的时候，按照如下顺序进行初始化：</p>
<ul>
<li>先初始化字段，例如，int age = 10;表示字段初始化为10，double salary;表示字段默认初始化为0，String name;表示引用类型字段默认初始化为null；</li>
<li>执行构造方法的代码进行初始化。</li>
</ul>
<p>因此，构造方法的代码由于后运行，所以，new Person(“Xiao Ming”, 12)的字段值最终由构造方法的代码确定。</p>
<h3 id="重写重载"><a class="markdownIt-Anchor" href="#重写重载"></a> 重写/重载</h3>
<p>重写是子类的方法覆盖父类的方法，要求方法名和参数都相同</p>
<p>重载是在同一个类中的两个或两个以上的方法，拥有相同的方法名，但是参数却不相同，方法体也不相同</p>
<p>子类重写了父类的方法时，父类的方法依然存在，只是被隐藏了，可以通过super来调用。  ea:   super.father();</p>
<p>重写和重载都要求返回类型，方法名一致</p>
<h4 id="方法重载"><a class="markdownIt-Anchor" href="#方法重载"></a> 方法重载</h4>
<p><strong>这种方法名相同，但各自的参数不同，称为方法重载（Overload）</strong></p>
<ul>
<li>方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。 重载Overloading是一个类中多态性的一种表现。</li>
<li>Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。 调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。</li>
<li>重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准</li>
<li>两同（同一个类 ，同一个方法名）三不同（参数列表不同：类型，个数，顺序）    返回值不同不构成重载/形参名称不同不构成重载</li>
</ul>
<p>在一个类中，我们可以定义多个方法。如果有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成同名方法。例如，在Hello类中，定义多个hello()方法：</p>
<pre><code class="highlight plaintext">
class Hello &#123;
    public void hello() &#123;
        System.out.println(&quot;Hello, world!&quot;);
    &#125;

    public void hello(String name) &#123;
        System.out.println(&quot;Hello, &quot; + name + &quot;!&quot;);
    &#125;

    public void hello(String name, int age) &#123;
        if (age &lt; 18) &#123;
            System.out.println(&quot;Hi, &quot; + name + &quot;!&quot;);
        &#125; else &#123;
            System.out.println(&quot;Hello, &quot; + name + &quot;!&quot;);
        &#125;
    &#125;
&#125;</code></pre>
<blockquote>
<p>注意：方法重载的返回值类型通常都是相同的</p>
</blockquote>
<h4 id="方法重写"><a class="markdownIt-Anchor" href="#方法重写"></a> 方法重写</h4>
<ul>
<li>父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖。</li>
<li>若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。</li>
<li>子类函数的访问修饰权限不能少于父类的</li>
</ul>
<h3 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h3>
<p>Java使用extends关键字来实现继承：</p>
<pre><code class="highlight plaintext">
class Person &#123;
    private String name;
    private int age;

    public String getName() &#123;...&#125;
    public void setName(String name) &#123;...&#125;
    public int getAge() &#123;...&#125;
    public void setAge(int age) &#123;...&#125;
&#125;

class Student extends Person &#123;
    // 不要重复name和age字段/方法,
    // 只需要定义新增score字段/方法:
    private int score;

    public int getScore() &#123; … &#125;
    public void setScore(int score) &#123; … &#125;
&#125;</code></pre>
<p>可见，通过继承，Student只需要编写额外的功能，不再需要重复代码</p>
<p>在OOP的术语中，我们把Person称为超类（super class），父类（parent class），基类（base class），把Student称为子类（subclass），扩展类（extended class）</p>
<hr />
<p><strong>继承树</strong></p>
<p>注意到我们在定义Person的时候，没有写extends。在Java中，没有明确写extends的类，编译器会自动加上extends Object。所以，任何类，除了Object，都会继承自某个类。下图是Person、Student的继承树：</p>
<p>Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有Object特殊，它没有父类</p>
<p>类似的，如果我们定义一个继承自Person的Teacher，它们的继承树关系如下：</p>
<h4 id="protected"><a class="markdownIt-Anchor" href="#protected"></a> protected</h4>
<p>继承有个特点，就是子类无法访问父类的private字段或者private方法。例如，Student类就无法访问Person类的name和age字段：</p>
<pre><code class="highlight plaintext">class Person &#123;
    private String name;
    private int age;
&#125;

class Student extends Person &#123;
    public String hello() &#123;
        return &quot;Hello, &quot; + name; // 编译错误：无法访问name字段
    &#125;
&#125;</code></pre>
<p>这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把private改为protected。用protected修饰的字段可以被子类访问：</p>
<pre><code class="highlight plaintext">class Person &#123;
    protected String name;
    protected int age;
&#125;

class Student extends Person &#123;
    public String hello() &#123;
        return &quot;Hello, &quot; + name; // OK!
    &#125;
&#125;</code></pre>
<blockquote>
<p>因此，protected关键字可以把字段和方法的访问权限控制在继承树内部，一个protected字段和方法可以被其子类，以及子类的子类所访问</p>
</blockquote>
<h4 id="super"><a class="markdownIt-Anchor" href="#super"></a> super</h4>
<p><strong>this和super是所有方法的隐式参数</strong></p>
<p><strong>所有的没有调用父类其他构造器的子类构造器第一句总是super()</strong></p>
<p><strong>static方法中不能使用super</strong></p>
<p>当子类方法中的局部变量或者子类的成员变量与父类成员变量同名时，也就是子类局部变量覆盖父类成员变量时，用“super.成员变量名”来引用父类成员变量。当然，如果父类的成员变量没有被覆盖，也可以用“super.成员变量名”来引用父类成员变量，不过这是不必要的</p>
<p>当子类的成员方法覆盖了父类的成员方法时，也就是子类和父类有完全相同的方法定义（但方法体可以不同），此时，用“super.方法名(参数列表)”的方式访问父类的方法</p>
<p>super关键字表示父类（超类）。子类引用父类的字段时，可以用super.fieldName。例如：</p>
<pre><code class="highlight plaintext">class Student extends Person &#123;
    public String hello() &#123;
        return &quot;Hello, &quot; + super.name;
    &#125;
&#125;</code></pre>
<p>实际上，<a target="_blank" rel="noopener" href="http://xn--super-2b3hr36t1v2blxd.name">这里使用super.name</a>，<a target="_blank" rel="noopener" href="http://xn--this-475hs64m.name">或者this.name</a>，或者name，效果都是一样的。编译器会自动定位到父类的name字段。</p>
<p>但是，在某些时候，就必须使用super。我们来看一个例子：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Student s = new Student(&quot;Xiao Ming&quot;, 12, 89);
    &#125;
&#125;

class Person &#123;
    protected String name;
    protected int age;

    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
&#125;

class Student extends Person &#123;
    protected int score;

    public Student(String name, int age, int score) &#123;
        this.score = score;
    &#125;
&#125;</code></pre>
<p>运行上面的代码，会得到一个编译错误，大意是在Student的构造方法中，无法调用Person的构造方法。</p>
<p>这是因为在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句super();，所以，Student类的构造方法实际上是这样：</p>
<pre><code class="highlight plaintext">class Student extends Person &#123;
    protected int score;

    public Student(String name, int age, int score) &#123;
        super(); // 自动调用父类的构造方法
        this.score = score;
    &#125;
&#125;</code></pre>
<p>但是，Person类并没有无参数的构造方法，因此，编译失败。</p>
<p>解决方法是调用Person类存在的某个构造方法。例如：</p>
<pre><code class="highlight plaintext">class Student extends Person &#123;
    protected int score;

    public Student(String name, int age, int score) &#123;
        super(name, age); // 调用父类的构造方法Person(String, int)
        this.score = score;
    &#125;
&#125;</code></pre>
<p>因此我们得出结论：<strong>如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法</strong>。</p>
<p>这里还顺带引出了另一个问题：<strong>即子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的</strong></p>
<h4 id="上下转型"><a class="markdownIt-Anchor" href="#上下转型"></a> 上下转型</h4>
<p><strong>向上转型</strong></p>
<p>如果一个引用变量的类型是Student，那么它可以指向一个Student类型的实例：</p>
<pre><code class="highlight plaintext">Student s = new Student();</code></pre>
<p>如果一个引用类型的变量是Person，那么它可以指向一个Person类型的实例：</p>
<pre><code class="highlight plaintext">Person p = new Person();</code></pre>
<p>如果Student是从Person继承下来的，那么，一个引用类型为Person的变量，也可以指向Student类型</p>
<pre><code class="highlight plaintext">Student s = new Student();
Person p = s; // upcasting, ok
Object o1 = p; // upcasting, ok
Object o2 = s; // upcasting, ok</code></pre>
<p>这是因为Student继承自Person，因此，它拥有Person的全部功能。Person类型的变量，如果指向Student类型的实例，对它进行操作，是没有问题的！</p>
<blockquote>
<p>注意到继承树是Student &gt; Person &gt; Object，所以，可以把Student类型转型为Person，或者更高层次的Object</p>
</blockquote>
<p><strong>向下转型</strong></p>
<p>和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）。例如：</p>
<pre><code class="highlight plaintext">Person p1 = new Student(); // upcasting, ok
Person p2 = new Person();
Student s1 = (Student) p1; // ok
Student s2 = (Student) p2; // runtime error! ClassCastException!</code></pre>
<p>Person类型p1实际指向Student实例，Person类型变量p2实际指向Person实例。在向下转型的时候，把p1转型为Student会成功，因为p1确实指向Student实例，把p2转型为Student会失败，因为p2的实际类型是Person，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来</p>
<blockquote>
<p>因此，向下转型很可能会失败。失败的时候，Java虚拟机会报ClassCastException</p>
</blockquote>
<p>为了避免向下转型出错，Java提供了<strong>instanceof</strong>操作符，可以先判断一个实例究竟是不是某种类型：</p>
<pre><code class="highlight plaintext">Person p = new Person();
System.out.println(p instanceof Person); // true
System.out.println(p instanceof Student); // false

Student s = new Student();
System.out.println(s instanceof Person); // true
System.out.println(s instanceof Student); // true

Student n = null;
System.out.println(n instanceof Student); // false</code></pre>
<p>instanceof实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为null，那么对任何instanceof的判断都为false</p>
<p>利用instanceof，在向下转型前可以先判断：</p>
<pre><code class="highlight plaintext">Person p = new Student();
if (p instanceof Student) &#123;
    // 只有判断成功才会向下转型:
    Student s = (Student) p; // 一定会成功
&#125;</code></pre>
<h4 id="区分继承和组合"><a class="markdownIt-Anchor" href="#区分继承和组合"></a> 区分继承和组合</h4>
<p>在使用继承时，我们要注意逻辑一致性。</p>
<p>考察下面的Book类：</p>
<pre><code class="highlight plaintext">class Book &#123;
    protected String name;
    public String getName() &#123;...&#125;
    public void setName(String name) &#123;...&#125;
&#125;</code></pre>
<p>这个Book类也有name字段，那么，我们能不能让Student继承自Book呢？</p>
<pre><code class="highlight plaintext">class Student extends Book &#123;
    protected int score;
&#125;</code></pre>
<p>显然，从逻辑上讲，这是不合理的，Student不应该从Book继承，而应该从Person继承。</p>
<p>究其原因，是因为Student是Person的一种，它们是is关系，而Student并不是Book。实际上Student和Book的关系是has关系。</p>
<p>具有has关系不应该使用继承，而是使用组合，即Student可以持有一个Book实例：</p>
<pre><code class="highlight plaintext">class Student extends Person &#123;
    protected Book book;
    protected int score;
&#125;</code></pre>
<p>因此，继承是is关系，组合是has关系。</p>
<h3 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态</h3>
<ul>
<li>子类可以覆写（子类定义了一个与父类方法签名完全相同的方法）父类的方法（Override），覆写在子类中改变了父类方法的行为；</li>
<li>Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；</li>
<li>final修饰符有多种作用：
<ul>
<li>final修饰的方法可以阻止被覆写；</li>
<li>final修饰的class可以阻止被继承；</li>
<li>final修饰的field必须在创建对象时初始化，随后不可修改。</li>
</ul>
</li>
</ul>
<hr />
<p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）</p>
<p>例如，在Person类中，我们定义了run()方法：</p>
<pre><code class="highlight plaintext">class Person &#123;
    public void run() &#123;
        System.out.println(&quot;Person.run&quot;);
    &#125;
&#125;</code></pre>
<p>在子类Student中，覆写这个run()方法：</p>
<pre><code class="highlight plaintext">class Student extends Person &#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;Student.run&quot;);
    &#125;
&#125;</code></pre>
<p>重写Override和重载Overload不同的是，如果方法签名如果不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是Override</p>
<blockquote>
<p>注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。</p>
</blockquote>
<p>一个实际类型为Student，引用类型为Person的变量，调用其run()方法，实际上调用的方法是Student的run()方法</p>
<p>Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型</p>
<p>这个非常重要的特性在面向对象编程中称之为多态</p>
<hr />
<p><strong>多态</strong></p>
<p>多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法</p>
<pre><code class="highlight plaintext">Person p = new Student();
p.run(); // 无法确定运行时究竟调用哪个run()方法</code></pre>
<p>多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。</p>
<hr />
<p><strong>重写Object方法</strong></p>
<p>因为所有的class最终都继承自Object，而Object定义了几个重要的方法：</p>
<ul>
<li>toString()：把instance输出为String；</li>
<li>equals()：判断两个instance是否逻辑相等；</li>
<li>hashCode()：计算一个instance的哈希值。</li>
</ul>
<p>在必要的情况下，我们可以覆写Object的这几个方法。例如：</p>
<pre><code class="highlight plaintext">class Person &#123;
    ...
    // 显示更有意义的字符串:
    @Override
    public String toString() &#123;
        return &quot;Person:name=&quot; + name;
    &#125;

    // 比较是否相等:
    @Override
    public boolean equals(Object o) &#123;
        // 当且仅当o为Person类型:
        if (o instanceof Person) &#123;
            Person p = (Person) o;
            // 并且name字段相同时，返回true:
            return this.name.equals(p.name);
        &#125;
        return false;
    &#125;

    // 计算hash:
    @Override
    public int hashCode() &#123;
        return this.name.hashCode();
    &#125;
&#125;</code></pre>
<hr />
<p><strong>调用super</strong></p>
<p>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用。例如：</p>
<pre><code class="highlight plaintext">class Person &#123;
    protected String name;
    public String hello() &#123;
        return &quot;Hello, &quot; + name;
    &#125;
&#125;

Student extends Person &#123;
    @Override
    public String hello() &#123;
        // 调用父类的hello()方法:
        return super.hello() + &quot;!&quot;;
    &#125;
&#125;</code></pre>
<hr />
<p><strong>final</strong></p>
<p>继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为final。用final修饰的方法不能被Override：</p>
<pre><code class="highlight plaintext">class Person &#123;
    protected String name;
    public final String hello() &#123;
        return &quot;Hello, &quot; + name;
    &#125;
&#125;

Student extends Person &#123;
    // compile error: 不允许覆写
    @Override
    public String hello() &#123;
    &#125;
&#125;</code></pre>
<p>如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为final。用final修饰的类不能被继承：</p>
<pre><code class="highlight plaintext">final class Person &#123;
    protected String name;
&#125;

// compile error: 不允许继承自Person
Student extends Person &#123;
&#125;</code></pre>
<p>对于一个类的实例字段，同样可以用final修饰。用final修饰的字段在初始化后不能被修改。例如：</p>
<pre><code class="highlight plaintext">class Person &#123;
    public final String name = &quot;Unamed&quot;;
&#125;</code></pre>
<blockquote>
<p>对final字段重新赋值会报错</p>
</blockquote>
<h3 id="抽象类"><a class="markdownIt-Anchor" href="#抽象类"></a> 抽象类</h3>
<ul>
<li>有抽象方法的类只能定义抽象类</li>
<li>抽象类不能实例化，及不能用new来实例化抽象类</li>
<li>抽象类可以包含属性，方法，构造方法；但是构造方法不能用new实例，只能用来被子类调用</li>
<li>抽象类只能用来继承</li>
<li>抽象方法必须被子类实现</li>
</ul>
<p>如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用abstract修饰。</p>
<p>因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）</p>
<pre><code class="highlight plaintext">abstract class Person &#123;
    public abstract void run();
&#125;</code></pre>
<p>使用abstract修饰的类就是抽象类。我们无法实例化一个抽象类</p>
<p>因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“<strong>规范</strong>”</p>
<p>例如，Person类定义了抽象方法run()，那么，在实现子类Student的时候，就必须覆写run()方法：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Person p = new Student();
        p.run();
    &#125;
&#125;

abstract class Person &#123;
    public abstract void run();
&#125;

class Student extends Person &#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;Student.run&quot;);
    &#125;
&#125;</code></pre>
<h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3>
<p>在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。</p>
<p>如果一个抽象类没有字段，所有方法全部都是抽象方法：</p>
<pre><code class="highlight plaintext">abstract class Person &#123;
    public abstract void run();
    public abstract String getName();
&#125;</code></pre>
<p>就可以把该抽象类改写为接口：<strong>interface</strong></p>
<p>在Java中，使用interface可以声明一个接口：</p>
<pre><code class="highlight plaintext">interface Person &#123;
    void run();
    String getName();
&#125;</code></pre>
<p>所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来（写不写效果都一样）</p>
<p>当一个具体的class去实现一个interface时，需要使用implements关键字。举个例子：</p>
<pre><code class="highlight plaintext">class Student implements Person &#123;
    private String name;

    public Student(String name) &#123;
        this.name = name;
    &#125;

    @Override
    public void run() &#123;
        System.out.println(this.name + &quot; run&quot;);
    &#125;

    @Override
    public String getName() &#123;
        return this.name;
    &#125;
&#125;</code></pre>
<p>我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface，例如：</p>
<pre><code class="highlight plaintext">class Student implements Person, Hello &#123; // 实现了两个interface
    ...
&#125;</code></pre>
<hr />
<p><strong>抽象类和接口对比</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>abstract class</th>
<th>interface</th>
</tr>
</thead>
<tbody>
<tr>
<td>继承</td>
<td>只能extends一个class</td>
<td>可以implements多个interface</td>
</tr>
<tr>
<td>字段</td>
<td>可以定义实例字段</td>
<td>不能定义实例字段</td>
</tr>
<tr>
<td>抽象方法</td>
<td>可以定义抽象方法</td>
<td>可以定义抽象方法</td>
</tr>
<tr>
<td>非抽象方法</td>
<td>可以定义非抽象方法</td>
<td>可以定义default方法</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>接口继承</strong></p>
<p>一个interface可以继承自另一个interface。interface继承自interface使用extends，它相当于扩展了接口的方法。例如：</p>
<pre><code class="highlight plaintext">interface Hello &#123;
    void hello();
&#125;

interface Person extends Hello &#123;
    void run();
    String getName();
&#125;</code></pre>
<blockquote>
<p>此时，Person接口继承自Hello接口，因此，Person接口现在实际上有3个抽象方法签名，其中一个来自继承的Hello接口</p>
</blockquote>
<hr />
<p><strong>继承关系</strong></p>
<p>合理设计interface和abstract class的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在abstract class中，具体逻辑放到各个子类，而接口层次代表抽象程度。可以参考Java的集合类定义的一组接口、抽象类以及具体子类的继承关系：</p>
<p>在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象：</p>
<pre><code class="highlight plaintext">List list = new ArrayList(); // 用List接口引用具体子类的实例
Collection coll = list; // 向上转型为Collection接口
Iterable it = coll; // 向上转型为Iterable接口</code></pre>
<hr />
<p><strong>default方法</strong></p>
<p>在接口中，可以定义default方法。例如，把Person接口的run()方法改为default方法：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Person p = new Student(&quot;Xiao Ming&quot;);
        p.run();
    &#125;
&#125;

interface Person &#123;
    String getName();
    default void run() &#123;
        System.out.println(getName() + &quot; run&quot;);
    &#125;
&#125;

class Student implements Person &#123;
    private String name;

    public Student(String name) &#123;
        this.name = name;
    &#125;

    public String getName() &#123;
        return this.name;
    &#125;
&#125;</code></pre>
<p>实现类可以不必覆写default方法。default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法</p>
<p>default方法和抽象类的普通方法是有所不同的。因为interface没有字段，default方法无法访问字段，而抽象类的普通方法可以访问实例字段</p>
<h3 id="静态字段和静态方法"><a class="markdownIt-Anchor" href="#静态字段和静态方法"></a> 静态字段和静态方法</h3>
<p>在一个class中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响</p>
<p>还有一种字段，是用<strong>static</strong>修饰的字段，称为<strong>静态字段</strong>：static field</p>
<p>实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。举个例子：</p>
<pre><code class="highlight plaintext">class Person &#123;
    public String name;
    public int age;
    // 定义静态字段number:
    public static int number;
&#125;</code></pre>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Person ming = new Person(&quot;Xiao Ming&quot;, 12);
        Person hong = new Person(&quot;Xiao Hong&quot;, 15);
        ming.number = 88;
        System.out.println(hong.number);
        hong.number = 99;
        System.out.println(ming.number);
    &#125;
&#125;

class Person &#123;
    public String name;
    public int age;

    public static int number;

    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
&#125;
</code></pre>
<p>对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：所有实例的静态字段都被修改了，原因是静态字段并不属于实例：</p>
<p>虽然实例可以访问静态字段，但是它们指向的其实都是Person class的静态字段。所以，所有实例共享一个静态字段。</p>
<p>因此，不推荐用实例变量.静态字段去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为类名.静态字段来访问静态对象</p>
<p>推荐用类名来访问静态字段。可以把静态字段理解为描述class本身的字段（非实例字段）。对于上面的代码，更好的写法是：</p>
<pre><code class="highlight plaintext">Person.number = 99;
System.out.println(Person.number);</code></pre>
<hr />
<p><strong>静态方法</strong></p>
<p>有静态字段，就有静态方法。用static修饰的方法称为静态方法</p>
<p>调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数。例如：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Person.setNumber(99);
        System.out.println(Person.number);
    &#125;
&#125;

class Person &#123;
    public static int number;

    public static void setNumber(int value) &#123;
        number = value;
    &#125;
&#125;</code></pre>
<p>因为静态方法属于class而不属于实例，因此，静态方法内部，无法访问this变量，也无法访问实例字段，它只能访问静态字段。</p>
<p>通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已</p>
<p>通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告</p>
<p>静态方法经常用于工具类。例如：</p>
<ul>
<li>Arrays.sort()</li>
<li>Math.random()</li>
</ul>
<p>静态方法也经常用于辅助方法。注意到Java程序的入口main()也是静态方法。</p>
<hr />
<p><strong>接口的静态字段</strong></p>
<p>因为interface是一个纯抽象类，所以它不能定义实例字段。但是，interface是可以有静态字段的，并且静态字段必须为final类型：</p>
<pre><code class="highlight plaintext">public interface Person &#123;
    public static final int MALE = 1;
    public static final int FEMALE = 2;
&#125;</code></pre>
<p>实际上，因为interface的字段只能是public static final类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为：</p>
<pre><code class="highlight plaintext">public interface Person &#123;
    // 编译器会自动加上public statc final:
    int MALE = 1;
    int FEMALE = 2;
&#125;</code></pre>
<blockquote>
<p>编译器会自动把该字段变为public static final类型</p>
</blockquote>
<h3 id="包"><a class="markdownIt-Anchor" href="#包"></a> 包</h3>
<p>如果小军写了一个Arrays类，恰好JDK也自带了一个Arrays类，如何解决类名冲突？</p>
<p>在Java中，我们使用package来解决名字冲突。</p>
<p>Java定义了一种名字空间，称之为包：<strong>package</strong>。一个类总是属于某个包，类名（比如Person）只是一个简写，真正的完整类名是<strong>包名.类名</strong>。</p>
<p>例如：</p>
<ul>
<li>小军的Arrays类存放在包mr.jun下面，因此，完整类名是mr.jun.Arrays；</li>
<li>JDK的Arrays类存放在包java.util下面，因此，完整类名是java.util.Arrays</li>
</ul>
<p>在定义class的时候，我们需要在第一行声明这个class属于哪个包</p>
<ul>
<li>小明的Person.java文件：</li>
</ul>
<pre><code class="highlight plaintext">package ming; // 申明包名ming

public class Person &#123;
&#125;</code></pre>
<ul>
<li>小军的Arrays.java文件：</li>
</ul>
<pre><code class="highlight plaintext">package mr.jun; // 申明包名mr.jun

public class Arrays &#123;
&#125;</code></pre>
<blockquote>
<p>在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同</p>
</blockquote>
<p>包可以是多层结构，用.隔开。例如：java.util</p>
<blockquote>
<p>要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系</p>
</blockquote>
<p>没有定义包名的class，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法</p>
<p>我们还需要按照包结构把上面的Java文件组织起来。假设以package_sample作为根目录，src作为源码目录，那么所有文件结构就是：</p>
<p>即所有Java文件对应的目录层次要和包的层次一致。</p>
<p>编译后的.class文件也需要按照包结构存放。如果使用IDE，把编译后的.class文件放到bin目录下，那么，编译的文件结构就是：</p>
<p>编译的命令相对比较复杂，我们需要在src目录下执行javac命令：</p>
<pre><code class="highlight plaintext">javac -d ../bin ming/Person.java hong/Person.java mr/jun/Arrays.java</code></pre>
<hr />
<p><strong>包作用域</strong></p>
<p>位于同一个包的类，可以访问包作用域的字段和方法。不用public、protected、private修饰的字段和方法就是包作用域。</p>
<p>例如，Person类定义在hello包下面：</p>
<pre><code class="highlight plaintext">package hello;

public class Person &#123;
    // 包作用域:
    void hello() &#123;
        System.out.println(&quot;Hello!&quot;);
    &#125;
&#125;</code></pre>
<p>Main类也定义在hello包下面：</p>
<pre><code class="highlight plaintext">package hello;

public class Main &#123;
    public static void main(String[] args) &#123;
        Person p = new Person();
        p.hello(); // 可以调用，因为Main和Person在同一个包
    &#125;
&#125;</code></pre>
<hr />
<p><strong>import</strong></p>
<p>在一个class中，我们总会引用其他的class。例如，小明的ming.Person类，如果要引用小军的mr.jun.Arrays类，他有三种写法：</p>
<p>第一种，直接写出完整类名，例如：</p>
<pre><code class="highlight plaintext">// Person.java
package ming;

public class Person &#123;
    public void run() &#123;
        mr.jun.Arrays arrays = new mr.jun.Arrays();
    &#125;
&#125;</code></pre>
<p>因此，第二种写法是用import语句，导入小军的Arrays，然后写简单类名：</p>
<pre><code class="highlight plaintext">// Person.java
package ming;

// 导入完整类名:import mr.jun.Arrays;

public class Person &#123;
    public void run() &#123;
        Arrays arrays = new Arrays();
    &#125;
&#125;</code></pre>
<p>在写import的时候，可以使用<code>*</code>，表示把这个包下面的所有class都导入进来（但不包括子包的class）：</p>
<pre><code class="highlight plaintext">// Person.java
package ming;

// 导入mr.jun包的所有class:
import mr.jun.*;

public class Person &#123;
    public void run() &#123;
        Arrays arrays = new Arrays();
    &#125;
&#125;</code></pre>
<blockquote>
<p>我们一般不推荐这种写法，因为在导入了多个包后，很难看出Arrays类属于哪个包</p>
</blockquote>
<p>还有一种import static的语法，它可以导入可以导入一个类的静态字段和静态方法：</p>
<pre><code class="highlight plaintext">package main;

// 导入System类的所有静态字段和静态方法:
import static java.lang.System.*;

public class Main &#123;
    public static void main(String[] args) &#123;
        // 相当于调用System.out.println(…)
        out.println(&quot;Hello, world!&quot;);
    &#125;
&#125;</code></pre>
<blockquote>
<p>import static很少使用</p>
</blockquote>
<p>Java编译器最终编译出的.class文件只使用完整类名，因此，在代码中，当编译器遇到一个class名称时：</p>
<ul>
<li>如果是完整类名，就直接根据完整类名查找这个class；</li>
<li>如果是简单类名，按下面的顺序依次查找：
<ul>
<li>查找当前package是否存在这个class；</li>
<li>查找import的包是否包含这个class；</li>
<li>查找java.lang包是否包含这个class。</li>
</ul>
</li>
</ul>
<p>如果按照上面的规则还无法确定类名，则编译报错</p>
<p>我们来看一个例子：</p>
<pre><code class="highlight plaintext">// Main.java
package test;

import java.text.Format;

public class Main &#123;
    public static void main(String[] args) &#123;
        java.util.List list; // ok，使用完整类名 -&gt; java.util.List
        Format format = null; // ok，使用import的类 -&gt; java.text.Format
        String s = &quot;hi&quot;; // ok，使用java.lang包的String -&gt; java.lang.String
        System.out.println(s); // ok，使用java.lang包的System -&gt; java.lang.System
        MessageFormat mf = null; // 编译错误：无法找到MessageFormat: MessageFormat cannot be resolved to a type
    &#125;
&#125;</code></pre>
<p>因此，编写class的时候，编译器会自动帮我们做两个import动作：</p>
<ul>
<li>默认自动import当前package的其他class；</li>
<li>默认自动import java.lang.*。</li>
</ul>
<blockquote>
<p>注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入</p>
</blockquote>
<blockquote>
<p>如果有两个class名称相同，例如，mr.jun.Arrays和java.util.Arrays，那么只能import其中一个，另一个必须写完整类名</p>
</blockquote>
<hr />
<p><strong>最佳实践</strong></p>
<p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：</p>
<ul>
<li>org.apache</li>
<li>org.apache.commons.log</li>
<li>com.liaoxuefeng.sample</li>
</ul>
<p>子包就可以根据功能自行命名。</p>
<p>要注意不要和java.lang包的类重名，即自己的类不要使用这些名字：</p>
<ul>
<li>String</li>
<li>System</li>
<li>Runtime</li>
<li>…</li>
</ul>
<p>要注意也不要和JDK常用类重名：</p>
<ul>
<li>java.util.List</li>
<li>java.text.Format</li>
<li>java.math.BigInteger</li>
<li>…</li>
</ul>
<h3 id="作用域"><a class="markdownIt-Anchor" href="#作用域"></a> 作用域</h3>
<p>在Java中，我们经常看到public、protected、private这些修饰符。在Java中，这些修饰符可以用来限定访问作用域</p>
<h4 id="修饰符"><a class="markdownIt-Anchor" href="#修饰符"></a> 修饰符</h4>
<hr />
<p><strong>public</strong></p>
<p>定义为public的class、interface可以被其他任何类访问</p>
<p>定义为public的field、method可以被其他类访问，前提是首先有访问class的权限</p>
<hr />
<p><strong>private</strong></p>
<p>定义为private的field、method无法被其他类访问</p>
<p>实际上，确切地说，private访问权限被限定在class的内部，而且与方法声明顺序无关。推荐把private方法放到后面，因为public方法定义了类对外提供的功能，阅读代码的时候，应该先关注public方法</p>
<p>由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问private的权限</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Inner i = new Inner();
        i.hi();
    &#125;

    // private方法:
    private static void hello() &#123;
        System.out.println(&quot;private hello!&quot;);
    &#125;

    // 静态内部类:
    static class Inner &#123;
        public void hi() &#123;
            Main.hello();
        &#125;
    &#125;
&#125;</code></pre>
<blockquote>
<p>定义在一个class内部的class称为嵌套类（nested class），Java支持好几种嵌套类</p>
</blockquote>
<hr />
<p><strong>protected</strong></p>
<p>protected作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类</p>
<hr />
<p><strong>package</strong></p>
<p>最后，包作用域是指一个类允许访问同一个package的没有public、private修饰的class，以及没有public、protected、private修饰的字段和方法</p>
<blockquote>
<p>注意，包名必须完全一致，包没有父子关系，com.apache和com.apache.abc是不同的包</p>
</blockquote>
<h4 id="局部变量"><a class="markdownIt-Anchor" href="#局部变量"></a> 局部变量</h4>
<p>在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。</p>
<pre><code class="highlight plaintext">package abc;

public class Hello &#123;
    void hi(String name) &#123; // ①
        String s = name.toLowerCase(); // ②
        int len = s.length(); // ③
        if (len &lt; 10) &#123; // ④
            int p = 10 - len; // ⑤
            for (int i=0; i&lt;10; i++) &#123; // ⑥
                System.out.println(); // ⑦
            &#125; // ⑧
        &#125; // ⑨
    &#125; // ⑩
&#125;</code></pre>
<p>我们观察上面的hi()方法代码：</p>
<ul>
<li>方法参数name是局部变量，它的作用域是整个方法，即①～⑩；</li>
<li>变量s的作用域是定义处到方法结束，即②～⑩；</li>
<li>变量len的作用域是定义处到方法结束，即③～⑩；</li>
<li>变量p的作用域是定义处到if块结束，即⑤～⑨；</li>
<li>变量i的作用域是for循环，即⑥～⑧。</li>
</ul>
<p>使用局部变量时，应该尽可能把局部变量的作用域缩小，尽可能延后声明局部变量</p>
<h4 id="final"><a class="markdownIt-Anchor" href="#final"></a> final</h4>
<p>Java还提供了一个final修饰符。final与访问权限不冲突，它有很多作用</p>
<ul>
<li>用final修饰class可以阻止被继承</li>
<li>用final修饰method可以阻止被子类覆写</li>
<li>用final修饰field可以阻止被重新赋值</li>
<li>用final修饰局部变量可以阻止被重新赋值</li>
</ul>
<blockquote>
<p>一个.java文件只能包含一个public类，但可以包含多个非public类</p>
</blockquote>
<h3 id="内部类"><a class="markdownIt-Anchor" href="#内部类"></a> 内部类</h3>
<pre><code class="highlight plaintext">package com.li.类加载全过程;

public class InnerclassesTest &#123;

     //静态内部类
     private static class StaticNestedClass&#123;
     &#125;

     //普通内部类（成员内部类）
     private class FiedInnerClassP&#123;
     &#125;

     //匿名内部类 （同时也是成员内部类）
     Runnable runnable = new Runnable()&#123;  //两个作用，定义了匿名内部类的类体，创建了一个实例对象
           public void run() &#123;&#125;
     &#125;;

     void sayHello()&#123;
           //方法内部类
           class LocalClass&#123;&#125;;
           //匿名内部类 （同时也是方法内部类）
           Runnable runnable = new Runnable()&#123;  //两个作用，定义了匿名内部类的类体，创建了一个实例对象
                public void run() &#123;&#125;
           &#125;;
     &#125;
&#125;</code></pre>
<p>一般情况，我们把类定义称独立的单元。有些情况下，我们把一个类放在另一个类的内部定义，成为内部类。</p>
<p>内部类仍然是一个独立的类，在编译后内部类仍然会编译为一个独立的.class文件，但是前面冠以外部类的类名和$符号，内部类可以使用修饰符（public,protected,default,private）</p>
<p><strong>内部类的作用</strong></p>
<p>内部类提供了更好的封装，只能让外部类直接访问，不允许同一个包中的其他类直接访问。</p>
<p>内部类可以直接访问外部类的私有属性，内部类被当成其外部类的成员。但外部类不能直接访问内部类的内部属性。</p>
<p><strong>内部类的使用场合</strong></p>
<p>由于内部类提供了更好的封装特性，并且可以很方便发访问外部类发属性，所有，通常内部类在只为所在外部类提供服务的情况下优先的使用</p>
<hr />
<p><strong>内部类的分类</strong></p>
<p><strong>成员变量内部类</strong>（可以使用private，proteted,public任意进行修饰。类文件格式:外部类$内部类.class）</p>
<h4 id="非静态内部类"><a class="markdownIt-Anchor" href="#非静态内部类"></a> 非静态内部类</h4>
<p>（外部类里使用非静态内部类和平时使用其他类没什么不同）</p>
<ul>
<li>非静态内部类必须寄存在一个外部类对象里。因此，如果有一个非静态内部类对象那么一定存在一个对应的外部类对象。非静态内部类对象单独属于外部类发某个对象。(必须有外部类对象才能有内部类对象)</li>
<li>非静态内部类可以直接访问外部类的成员，但是外部类不可以直接访问非静态内部类成员。</li>
<li>非静态内部类不能有静态方法，静态属性，静态初始化块。</li>
<li>静态成员不能访问非静态成员，外部类发静态方法，静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量，创建实例。</li>
<li>成员变量访问要点
<ol>
<li>内部类里方法的局部变量：变量名</li>
<li>内部类属性：this.变量名</li>
<li>外部类属性/方法：外部类名.this.变量名/方法 Outer.inner varname = OuterObject.new lnner()</li>
</ol>
</li>
</ul>
<pre><code class="highlight plaintext">import com.li.类加载全过程.Outer.InnerClass;
/**
 * 成员内部类在外部类之外使用时必须按照下列的格式创建，两个类有着严重的依赖关系
 * @author Mr
 *
 */
public class Demo3 &#123;
     public static void main(String[] args) &#123;
           Outer outer = new Outer();
           InnerClass inner = outer.new InnerClass();
           inner.test();
     &#125;

&#125;

class Outer&#123;
     private int a = 3;
     int b = 10;

     public void ttt()&#123;
           InnerClass inn = new InnerClass();//在外部类方法中可以直接创建就
     &#125;
     //成员内部类
     class InnerClass&#123;  //内部不可以有静态成员，除非声明为final，并且只能是编译器可以确定值的表达式

           //如果成员内部类可以使用static，那就可以直接使用Outer.InnerClass.xx可以直接获得内部类对象，
           //这是成员内部类对象就完全脱离了内部类的控制，与设计成员内部类的初衷不符
           int c = 1;
//         static int d = 0;
           final static int d = 1;
           void test()&#123;

                System.out.println(a);
                System.out.println(&quot;内部类对象：&quot;+this);
                System.out.println(&quot;外部类对象：&quot;+Outer.this);
           &#125;
     &#125;

&#125;</code></pre>
<h4 id="静态内部类"><a class="markdownIt-Anchor" href="#静态内部类"></a> 静态内部类</h4>
<ul>
<li>当一个静态内部类存在，并不一定存在对应的内部对象。因此，静态内部类的实例方法不能直接访问外部类的实例方法。</li>
<li>静态内部类看做外部类的一个静态成员。因此，外部类的方法可以通过：静态内部类.名字   访问静态内部类的静态成员。通过new 静态内部类()访问静态内部类的实例。</li>
<li>静态内部类可以包含静态成员，非静态成员，静态内部类可以调用外部的静态属性，静态方法，但不能调用外部类的普通属性，普通方法</li>
<li>在不相关类中，可以直接创建内部类对象（不需要通过所在外部类），在本类中可以直接创建，在外部也可直接创建（导入包）</li>
<li>一般情况下是不可以用static修饰类的。如果一定要用static修饰类的话，通常static修饰的是匿名内部类。</li>
<li>静态内部类实际上和外部类联系很少，也就是命名空间上的问题</li>
</ul>
<pre><code class="highlight plaintext">static class ClassName&#123;
   //类体
&#125;</code></pre>
<p>如何创建：</p>
<pre><code class="highlight plaintext">Face.TestStaticInner  aInner = new  Face.TestStaticInner();

TestStaticInner alnner = new TestStaticInner(); //也可以直接创建</code></pre>
<hr />
<h4 id="匿名内部类"><a class="markdownIt-Anchor" href="#匿名内部类"></a> 匿名内部类</h4>
<p>适合那种只需要使用一次的类。比如：键盘监听操作等等。语法：</p>
<pre><code class="highlight plaintext">/*
 * 匿名内部类
 */
public class Demo6 &#123;

     public void test2(Car car)&#123;

     &#125;

     public void test()&#123;
           //匿名内部类(接口式)，由于内部类定义在方法中，同时也是方法内部类
           Runnable runnable = new Runnable()&#123;
                public void run() &#123;
                      // TODO Auto-generated method stub
                &#125;
           &#125;;

           //匿名内部类，继承式
           Car car = new Car()&#123;
                public void run()&#123;
                      System.out.println(&quot;子类的车在跑&quot;);
                &#125;
           &#125;;
           car.run();

           //参数式匿名内部类
           test2(new Car()&#123;
                public void run()&#123;
                      System.out.println(&quot;参数式匿名内部类&quot;);
                &#125;
           &#125;);
     &#125;

&#125;

class Car&#123;
     public void run()&#123;
           System.out.println(&quot;汽车跑！&quot;);
     &#125;
&#125;</code></pre>
<hr />
<h5 id="双花括号用法"><a class="markdownIt-Anchor" href="#双花括号用法"></a> 双花括号用法</h5>
<p>实例化代码块儿：和静态代码块儿的概念相对应，静态代码块儿是static 关键字 + 大括号，把静态代码块儿的static关键字去掉就是实例化代码块儿,静态代码块儿在类初始化的时候执行一次。</p>
<p>而实例化代码块儿在每次生成对象的时候都会执行(实例化代码块儿会先于构造方法执行)。</p>
<p>使用匿名内部类进行初始化：在new 一个对象的时候，小括号后边跟一个大括号</p>
<p>使用匿名内部类 + 实例化代码块儿 = 使用两个大括号进行初始化</p>
<pre><code class="highlight plaintext">package com.jiaoyiping.thinking;

import java.util.ArrayList;
import java.util.List;

/*
 * Created with Intellij IDEA
 * USER: 焦一平
 * Date: 2015/10/25
 * Time: 10:41
 * To change this template use File | Settings | File Template
 */
public class TestInstanceCodeBlock &#123;
    public static void main(final String[] args) &#123;

        //匿名内部类
        Person person = new Person(&quot;张三&quot;)&#123;
            @Override
            public String getName() &#123;
                return super.getName()+&quot;123&quot;;
            &#125;
        &#125;;
        System.out.println(person.getName());

        //两个大括号的方式初始化(本质上是匿名内部类 + 实例化代码块儿)
        List&lt;String&gt; personList = new ArrayList&lt;String&gt;()&#123;&#123;
            add(&quot;AA&quot;);
            add(&quot;BB&quot;);
            add(&quot;CC&quot;);
        &#125;&#125;;
        for (String s : personList)&#123;
            System.out.println(s);
        &#125;
    &#125;
&#125;

class Person&#123;
    String name;
    public Person(String name)&#123;
        this.name = name;
        System.out.println(&quot;构造方法执行...&quot;);
    &#125;
    //实例化代码块儿,先于构造方法执行
    &#123;
        System.out.println(&quot;实例初始化...&quot;);
    &#125;
    public String getName()&#123;
        return name;
    &#125;

&#125;</code></pre>
<h4 id="局部方法内部类"><a class="markdownIt-Anchor" href="#局部方法内部类"></a> <strong>局部（方法）内部类</strong></h4>
<ul>
<li>定义在方法内部。作用域只限于本方法。用的非常少</li>
</ul>
<pre><code class="highlight plaintext">public class Demo4 &#123;
方法内部类

&#125;

class Outer4&#123;
     public void test()&#123;
           final int a = 3;

           class Inner&#123;
                int b = 3;
//              static int c = 20; //方法内部类中只能定义非静态成员

                void tt()&#123;
                      System.out.println(b);
                      System.out.println(a);

                      //方法内部类中不能引用所在方法的普通成员变量，除非是常量；
                      //原因是：方法的声明周期可能和方法内部类对象的声明周期不一致，方法执行完，内部类对象可能依然存在
                &#125;

           &#125;

     &#125;
&#125;</code></pre>
<h3 id="自动装箱"><a class="markdownIt-Anchor" href="#自动装箱"></a> 自动装箱</h3>
<pre><code class="highlight plaintext">package com.li.oftenclass;
/**
 * 测试自动装箱/自动拆箱Demo
 * @author Mr
 *
 */
public class TestBoxing &#123;
     public static void main(String[] args) &#123;
           /*
            * 自动装箱，虽然不和逻辑(把整形赋值给引用类型)，但是可以为程序员省时省力
            */
           //Integer i = new Integer(1000);
           Integer a = 1000;  //jdk5.0以后      编译器自动装箱：编译器帮我们改进代码:Integer a = new Integer(1000);
           Integer b = 2000;
           
           /*
            * 自动拆箱
            */
           int c = new Integer(1500);  //编译器自动拆箱:int c = new Integer(1500).intValue();编译器自己改
           c = b;   //实际上是: c = b.intValue();
           System.out.println(c);
           
           Integer d = null;
           //c = d;    //实际上编译器改为: c = d.intValue();
           System.out.println(c);   //输出会报错,以为d 为空指针类型，调用的d.intValue()时找不到，所以报错
           
           Integer e = 1234;
           Integer f = 1234;
           System.out.println(e == f);   //因为是两个对象
           System.out.println(e.equals(f));
           
           System.out.println(&quot;********************&quot;);
           /*
            * [-128~127]之间的数，封装是封装了，但当作基本数据类型来处理    为了提高效率
            */
           Integer e1 = 123;
           Integer f1 = 123;
           System.out.println(e1 == f1); 
           System.out.println(e1.equals(f1));
     &#125;
&#125;</code></pre>
<h3 id="classpathjar"><a class="markdownIt-Anchor" href="#classpathjar"></a> classpath/jar</h3>
<p><strong>classpath</strong></p>
<p>classpath是JVM用到的一个环境变量，它用来指示JVM如何搜索class</p>
<p>因为Java是编译型语言，源码文件是.java，而编译后的.class文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个abc.xyz.Hello的类，应该去哪搜索对应的Hello.class文件</p>
<p>所以，classpath就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用;分隔，带空格的目录用&quot;&quot;括起来，可能长这样：</p>
<pre><code class="highlight plaintext">C:\work\project1\bin;C:\shared;&quot;D:\My Documents\project1\bin&quot;</code></pre>
<p>在Linux系统上，用:分隔，可能长这样：</p>
<pre><code class="highlight plaintext">/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin</code></pre>
<p>现在我们假设classpath是<code>.;C:\work\project1\bin;C:\shared</code>，当JVM在加载abc.xyz.Hello这个类时，会依次查找：</p>
<ul>
<li>&lt;当前目录&gt;\abc\xyz\Hello.class</li>
<li>C:\work\project1\bin\abc\xyz\Hello.class</li>
<li>C:\shared\abc\xyz\Hello.class</li>
</ul>
<p>注意到.代表当前目录。如果JVM在某个路径下找到了对应的class文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错</p>
<p>classpath的设定方法有两种：</p>
<ul>
<li>在系统环境变量中设置classpath环境变量，不推荐；</li>
<li>在启动JVM时设置classpath变量，推荐。</li>
</ul>
<p>我们强烈不推荐在系统环境变量中设置classpath，那样会污染整个系统环境。在启动JVM时设置classpath才是推荐的做法。实际上就是给java命令传入<code>-classpath</code>或<code>-cp</code>参数：</p>
<pre><code class="highlight plaintext">java -classpath .;C:\work\project1\bin;C:\shared abc.xyz.Hello</code></pre>
<p>或者使用cp简写：</p>
<pre><code class="highlight plaintext">java -cp .;C:\work\project1\bin;C:\shared abc.xyz.Hello</code></pre>
<p>没有设置系统环境变量，也没有传入-cp参数，那么JVM默认的classpath为.，即当前目录：</p>
<pre><code class="highlight plaintext">java abc.xyz.Hello</code></pre>
<blockquote>
<p>上述命令告诉JVM只在当前目录搜索Hello.class</p>
</blockquote>
<p>在IDE中运行Java程序，IDE自动传入的-cp参数是当前工程的bin目录和引入的jar包</p>
<p>通常，我们在自己编写的class中，会引用Java核心库的class，例如，String、ArrayList等。这些class应该上哪去找？</p>
<p>有很多“如何设置classpath”的文章会告诉你把JVM自带的rt.jar放入classpath，但事实上，根本不需要告诉JVM如何去Java核心库查找class，JVM怎么可能笨到连自己的核心库在哪都不知道？</p>
<blockquote>
<p>不要把任何Java核心库添加到classpath中！JVM根本不依赖classpath加载核心库！</p>
</blockquote>
<p>更好的做法是，不要设置classpath！默认的当前目录.对于绝大多数情况都够用了</p>
<hr />
<p><strong>jar</strong></p>
<p>如果有很多.class文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了</p>
<p>jar包就是用来干这个事的，它可以把package组织的目录层级，以及各个目录下的所有文件（包括.class文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了</p>
<p>jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的class，就可以把jar包放到classpath中：</p>
<pre><code class="highlight plaintext">java -cp ./hello.jar abc.xyz.Hello</code></pre>
<p>这样JVM会自动在hello.jar文件里去搜索某个类</p>
<p>因为<strong>jar包就是zip�</strong>�，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从.zip改为.jar，一个jar包就创建成功</p>
<p>假设编译输出的目录结构是这样：</p>
<p>这里需要特别注意的是，jar包里的第一层目录，不能是bin，而应该是hong、ming、mr。如果在Windows的资源管理器中看，应该长这样：</p>
<p>jar包还可以包含一个特殊的<code>/META-INF/MANIFEST.MF</code>文件，MANIFEST.MF是纯文本，可以指定Main-Class和其它信息。JVM会自动读取这个MANIFEST.MF文件，如果存在Main-Class，我们就不必在命令行指定启动的类名，而是用更方便的命令：</p>
<pre><code class="highlight plaintext">java -jar hello.jar</code></pre>
<p>jar包还可以包含其它jar包，这个时候，就需要在MANIFEST.MF文件里配置classpath了</p>
<p>在大型项目中，不可能手动编写MANIFEST.MF文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如Maven，可以非常方便地创建jar包</p>
<h3 id="模块"><a class="markdownIt-Anchor" href="#模块"></a> 模块</h3>
<p>从Java 9开始，JDK又引入了模块（Module）</p>
<p>我们知道，.class文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆.class文件，很不便于管理，所以，jar文件就是class文件的容器</p>
<p>在Java 9之前，一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫rt.jar，一共有60多M</p>
<p>如果是自己开发的程序，除了一个自己的app.jar以外，还需要一堆第三方的jar包，运行一个Java程序，一般来说，命令行写这样：</p>
<pre><code class="highlight plaintext">java -cp app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main</code></pre>
<blockquote>
<p>注意：JVM自带的标准库rt.jar不要写到classpath中，写了反而会干扰JVM的正常运行</p>
</blockquote>
<p>如果漏写了某个运行时需要用到的jar，那么在运行期极有可能抛出ClassNotFoundException</p>
<p>所以，jar只是用于存放class的容器，它并不关心class之间的依赖</p>
<p>从Java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果a.jar必须依赖另一个b.jar才能运行，那我们应该给a.jar加点说明啥的，让程序在编译和运行的时候能自动定位到b.jar，这种自带“依赖关系”的class容器就是模块</p>
<p>为了表明Java模块化的决心，从Java 9开始，原有的Java标准库已经由一个单一巨大的rt.jar分拆成了几十个模块，这些模块以.jmod扩展名标识，可以在$JAVA_HOME/jmods目录下找到它们：</p>
<ul>
<li>java.base.jmod</li>
<li>java.compiler.jmod</li>
<li>java.datatransfer.jmod</li>
<li>java.desktop.jmod</li>
<li>…</li>
</ul>
<p>这些.jmod文件每一个都是一个模块，模块名就是文件名。例如：模块java.base对应的文件就是java.base.jmod。模块之间的依赖关系已经被写入到模块内的module-info.class文件了。所有的模块都直接或间接地依赖java.base模块，只有java.base模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从Object直接或间接继承而来</p>
<p>把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是JNI扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本</p>
<hr />
<p><strong>编写模块</strong></p>
<p>那么，我们应该如何编写模块呢？还是以具体的例子来说。首先，创建模块和原有的创建Java项目是完全一样的，以oop-module工程为例，它的目录结构如下：</p>
<p>其中，bin目录存放编译后的class文件，src目录存放源码，按包名的目录结构存放，仅仅在src目录下多了一个module-info.java这个文件，这就是模块的描述文件。在这个模块中，它长这样：</p>
<pre><code class="highlight plaintext">module hello.world &#123;
        requires java.base; // 可不写，任何模块都会自动引入java.base
        requires java.xml;
&#125;</code></pre>
<p>其中，module是关键字，后面的hello.world是模块的名称，它的命名规范与包一致。花括号的requires xxx;表示这个模块需要引用的其他模块名。除了java.base可以被自动引入外，这里我们引入了一个java.xml的模块</p>
<p>当我们使用模块声明了依赖关系后，才能使用引入的模块。例如，Main.java代码如下：</p>
<pre><code class="highlight plaintext">package com.itranswarp.sample;

// 必须引入java.xml模块后才能使用其中的类:import javax.xml.XMLConstants;

public class Main &#123;
        public static void main(String[] args) &#123;
                Greeting g = new Greeting();
                System.out.println(g.hello(XMLConstants.XML_NS_PREFIX));
        &#125;
&#125;</code></pre>
<p>如果把requires java.xml;从module-info.java中去掉，编译将报错。可见，模块的重要作用就是声明依赖关系</p>
<p>下面，我们用JDK提供的命令行工具来编译并创建模块。</p>
<p>首先，我们把工作目录切换到oop-module，在当前目录下编译所有的.java文件，并存放到bin目录下，命令如下：</p>
<pre><code class="highlight plaintext">$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java</code></pre>
<p>如果编译成功，现在项目结构如下：</p>
<p>注意到src目录下的module-info.java被编译到bin目录下的module-info.class</p>
<p>下一步，我们需要把bin目录下的所有class文件先打包成jar，在打包的时候，注意传入–main-class参数，让这个jar包能自己定位main方法所在的类：</p>
<pre><code class="highlight plaintext">$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .</code></pre>
<p>现在我们就在当前目录下得到了hello.jar这个jar包，它和普通jar包并无区别，可以直接使用命令java -jar hello.jar来运行它。但是我们的目标是创建模块，所以，继续使用JDK自带的jmod命令把一个jar包转换成模块：</p>
<pre><code class="highlight plaintext">$ jmod create --class-path hello.jar hello.jmod</code></pre>
<p>于是，在当前目录下我们又得到了hello.jmod这个模块文件，这就是最后打包出来的传说中的模块！</p>
<hr />
<p><strong>运行模块</strong></p>
<p>要运行一个jar，我们使用java -jar xxx.jar命令。要运行一个模块，我们只需要指定模块名。试试：</p>
<pre><code class="highlight plaintext">$ java --module-path hello.jmod --module hello.world</code></pre>
<p>结果是一个错误：</p>
<pre><code class="highlight plaintext">Error occurred during initialization of boot layer
java.lang.module.FindException: JMOD format not supported at execution time: hello.jmod</code></pre>
<p>原因是.jmod不能被放入–module-path中。换成.jar就没问题了：</p>
<pre><code class="highlight plaintext">$ java --module-path hello.jar --module hello.worldHello, xml!</code></pre>
<p>那我们辛辛苦苦创建的hello.jmod有什么用？答案是我们可以用它来打包JRE。</p>
<hr />
<p><strong>打包JRE</strong></p>
<p>前面讲了，为了支持模块化，Java 9首先带头把自己的一个巨大无比的rt.jar拆成了几十个.jmod模块，原因就是，运行Java程序的时候，实际上我们用到的JDK模块，并没有那么多。不需要的模块，完全可以删除</p>
<p>过去发布一个Java应用程序，要运行它，必须下载一个完整的JRE，再运行jar包。而完整的JRE块头很大，有100多M。怎么给JRE瘦身呢？</p>
<p>现在，JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。怎么裁剪JRE呢？并不是说把系统安装的JRE给删掉部分模块，而是“复制”一份JRE，但只带上用到的模块。为此，JDK提供了jlink命令来干这件事。命令如下：</p>
<pre><code class="highlight plaintext">$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/</code></pre>
<p>我们在–module-path参数指定了我们自己的模块hello.jmod，然后，在–add-modules参数中指定了我们用到的3个模块java.base、java.xml和hello.world，用,分隔。最后，在–output参数指定输出目录。</p>
<p>现在，在当前目录下，我们可以找到jre目录，这是一个完整的并且带有我们自己hello.jmod模块的JRE。试试直接运行这个JRE：</p>
<pre><code class="highlight plaintext">$ jre/bin/java --module hello.worldHello, xml!</code></pre>
<p>要分发我们自己的Java应用程序，只需要把这个jre目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署</p>
<hr />
<p><strong>访问权限</strong></p>
<p>前面我们讲过，Java的class访问权限分为public、protected、private和默认的包访问权限。引入模块后，这些访问权限的规则就要稍微做些调整</p>
<p>确切地说，class的这些访问权限只在一个模块内有效，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是b模块明确地导出了可以访问的包</p>
<p>举个例子：我们编写的模块hello.world用到了模块java.xml的一个类javax.xml.XMLConstants，我们之所以能直接使用这个类，是因为模块java.xml的module-info.java中声明了若干导出：</p>
<pre><code class="highlight plaintext">module java.xml &#123;
    exports java.xml;
    exports javax.xml.catalog;
    exports javax.xml.datatype;
    ...
&#125;</code></pre>
<p>只有它声明的导出的包，外部代码才被允许访问。换句话说，如果外部代码想要访问我们的hello.world模块中的com.itranswarp.sample.Greeting类，我们必须将其导出：</p>
<pre><code class="highlight plaintext">module hello.world &#123;
    exports com.itranswarp.sample;

    requires java.base;
        requires java.xml;
&#125;</code></pre>
<p>因此，模块进一步隔离了代码的访问权限</p>
<h2 id="内存分析"><a class="markdownIt-Anchor" href="#内存分析"></a> 内存分析</h2>
<p>先在类的方法中定义实例并new出对象，调用该类的该方法时，（eg:Man m = new Man();）创建栈帧，实例m存在栈中，使用new Man()出的对象在堆中，栈中的m指向堆中的new Man()对象。但是方法一执行完成，便会释放栈中的内存，若堆中的Man()对象没有人指向它，它过一会便会被内存回收机制回收</p>
<p>接下来重点来了，但是LinkedList类中的众多节点是如何存储的呢？</p>
<ul>
<li>成员变量，在调用LinkedList类中的add(）方法时，创建了Node（节点）对象，并在栈中有一个实例指向它，但是方法一结束运行，栈帧一释放，实例就没有了，但是成员变量的first还指向它，所以它并不会被回收。</li>
</ul>
<p>一般Java在内存分配时会涉及到以下区域：</p>
<ol>
<li>寄存器：我们在程序中无法控制</li>
<li>栈：存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中</li>
<li>堆：存放用new产生的数据</li>
<li>静态域：存放在对象中用static定义的静态成员</li>
<li>常量池：存放常量</li>
<li>非RAM存储：硬盘等永久存储空间</li>
</ol>
<p>其中主要是堆，栈的存储</p>
<p><strong>堆/栈</strong></p>
<ul>
<li>函数中定义的一些基本类型的数据变量和对象的引用变量都在函数的栈内存中分配。<br />
栈的优势是存取速度比堆要快，仅次于直接位于CPU 的寄存器，而且数据可以共享。<br />
存在栈中的数据大小与生存周期必须是确定的。因此里面的变量通常是局部变量、函数参数等。<br />
当在一段代码块定义一个变量时（局部变量），Java就在栈中 为这个变量分配内存空间，当该变量退出该作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。</li>
<li>堆内存用来存放由new创建的对象和数组。 在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。</li>
</ul>
<p>堆内存用来存放由new创建的对象和数组。 在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。</p>
<p>在堆中产生了一个数组或对象后，还可以 在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。</p>
<p>引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序 运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能在被使用，但仍 然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。</p>
<p><strong>栈</strong>，就是那些由编译器在需要的时候分配，楚的变量的存储在不需要的时候自动清区。里面的变量通常是局部变量、函数参数等。</p>
<p><strong>堆</strong>，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收</p>
<h3 id="内存分析一"><a class="markdownIt-Anchor" href="#内存分析一"></a> 内存分析一</h3>
<pre><code class="highlight plaintext">package com.li.oop;
/**
 * 测试面向对象Demo
 * @author Mr
 *
 */
public class Student &#123;
     //静态的数据
     /**

      * 成员变量自动初始化    静态的成员变量也不会自己初始化

      */
     String name;
     int id;
     int age;
     String gender;
     int weight;
     
     //动态的行为
     public void study()&#123;
     /*
      * 局部变量不会自动初始化
      */
           int a;
           System.out.println(name+&quot;在学习&quot;);
     &#125;
     public void sayHallo(String sname)&#123;
           System.out.println(name+&quot;向&quot;+sname+&quot;说：你好&quot;);
     &#125;
     public static void main(String[] args) &#123;
           /**
            * 通过加载器Class Loader加载Student类，加载后，在方法区中就有了Student类的信息
            */
           Student s1 = new Student();

           s1.name = &quot;高琪&quot;;

           s1.study();
           s1.sayHallo(&quot;马士兵&quot;);

           Student s2 = new Student();
           s2.age = 18;
           s2.name = &quot;老高&quot;;

     &#125;
&#125;</code></pre>
<h3 id="内存分析二"><a class="markdownIt-Anchor" href="#内存分析二"></a> 内存分析二</h3>
<pre><code class="highlight plaintext">package com.li.oop;
public class Computer &#123;
     String brand;
     int cpuSpeed;
&#125;

/**
 * 测试面向对象Demo
 * @author Mr
 *
 */
public class Student &#123;
     //静态的数据
     /**
      * 成员变量自动初始化
      */
     String name;
     int id;
     int age;
     String gender;
     int weight;
     Computer computer;
     //动态的行为
     public void study()&#123;
     /*
      * 局部变量不会自动初始化
      */
           int a;
           System.out.println(name+&quot;在学习&quot;);
     &#125;
     public void sayHallo(String sname)&#123;
           System.out.println(name+&quot;向&quot;+sname+&quot;说：你好&quot;);
     &#125;
&#125;

public class Test2 &#123;
     public static void main(String[] args) &#123;
           Student s1 = new Student();
           s1.name = &quot;高琪&quot;;
           s1.age = 18;

           Computer c= new Computer();
           c.brand = &quot;联想&quot;;
           c.cpuSpeed = 100;

           s1.computer = c;

//c.brand = &quot;戴尔&quot;;  c.brand 改变时  s1.computer.brand  也会改变
// 因为他们指向同一个地方
           System.out.println(s1.computer.brand);
     &#125;
&#125;</code></pre>
<h3 id="内存机制"><a class="markdownIt-Anchor" href="#内存机制"></a> 内存机制</h3>
<p><strong>栈</strong></p>
<p>1.存放局部变量</p>
<p>2.不可以被多个线程共享</p>
<p>3.空间连续，速度快</p>
<p><strong>堆</strong></p>
<p>1.存放对象</p>
<p>2.可以被对各线程共享</p>
<p>空间不连续，速度慢，但是灵活</p>
<p><strong>方法区</strong></p>
<p>1.存放类的信息：代码，静态变量，字符串常量</p>
<p>2.可以被多个线程共享</p>
<p>3.空间不连续，速度慢，但是灵活</p>
<p><strong>常量池(constant pool)</strong></p>
<p>指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。它包括了关于类、方法、接口等中的常量，也包括字符串常量</p>
<h3 id="垃圾回收装置"><a class="markdownIt-Anchor" href="#垃圾回收装置"></a> 垃圾回收装置</h3>
<p><strong>对象空间的分配</strong></p>
<ul>
<li>使用new关键字创建对象即可</li>
</ul>
<p><strong>对象空间的释放</strong></p>
<ul>
<li>将对象赋值null即可，垃圾回收器将负责回收所有不可达对象的内存空间</li>
</ul>
<p><strong>要点</strong>：</p>
<ul>
<li>程序员无权调用垃圾回收器</li>
<li>程序员可以通过System.gc()，通知GC运行，但是JAVA规范并不能包装立刻运行</li>
<li>finalize方法，是JAVA提供给程序员用来释放对象或资源的方法，但是要尽量少用</li>
</ul>
<h2 id="java关键字"><a class="markdownIt-Anchor" href="#java关键字"></a> Java关键字</h2>
<h3 id="native"><a class="markdownIt-Anchor" href="#native"></a> Native</h3>
<p>native 关键字在 JDK 源码中很多类中都有，在 Object.java类中，其 getClass() 方法、hashCode()方法、clone() 方法等等都是用 native 关键字修饰的。</p>
<pre><code class="highlight plaintext">public final native Class&lt;?&gt; getClass();
public native int hashCode();
protected native Object clone() throws CloneNotSupportedException;</code></pre>
<p>那么为什么要用 native 来修饰方法，这样做有什么用？</p>
<h4 id="jnijava-native-interface"><a class="markdownIt-Anchor" href="#jnijava-native-interface"></a> JNI:Java Native Interface</h4>
<p>在介绍 native 之前，我们先了解什么是 JNI。</p>
<p>一般情况下，我们完全可以使用 Java 语言编写程序，但某些情况下，Java 可能会不满足应用程序的需求，或者是不能更好的满足需求，比如：</p>
<ul>
<li>标准的 Java 类库不支持应用程序平台所需的平台相关功能。</li>
<li>我们已经用另一种语言编写了一个类库，如何用Java代码调用？</li>
<li>某些运行次数特别多的方法代码，为了加快性能，我们需要用更接近硬件的语言（比如汇编）编写。</li>
</ul>
<p>上面这三种需求，其实说到底就是如何用 Java 代码调用不同语言编写的代码。那么 JNI 应运而生了。</p>
<p>从Java 1.1开始，Java Native Interface (JNI)标准就成为java平台的一部分，它允许Java代码和其他语言写的代码进行交互。JNI一开始是为了本地已编译语言，尤其是C和C++而设计 的，但是它并不妨碍你使用其他语言，只要调用约定受支持就可以了。使用java与本地已编译的代码交互，通常会丧失平台可移植性。但是，有些情况下这样做是可以接受的，甚至是必须的，比如，使用一些旧的库，与硬件、操作系统进行交互，或者为了提高程序的性能。JNI标准至少保证本地代码能工作在任何Java 虚拟机实现下。</p>
<p>通过 JNI，我们就可以通过 Java 程序（代码）调用到操作系统相关的技术实现的库函数，从而与其他技术和系统交互，使用其他技术实现的系统的功能；同时其他技术和系统也可以通过 JNI 提供的相应原生接口开调用 Java 应用系统内部实现的功能。</p>
<p>在windows系统上，一般可执行的应用程序都是基于 native 的PE结构，windows上的 JVM 也是基于native结构实现的。Java应用体系都是构建于 JVM 之上。</p>
<p>可能有人会问，Java不是跨平台的吗？如果用 JNI，那么程序不就将失去跨平台的优点?确实是这样的。</p>
<p><strong>JNI 的缺点：</strong></p>
<ul>
<li>程序不再跨平台。要想跨平台，必须在不同的系统环境下重新编译本地语言部分。</li>
<li>程序不再是绝对安全的，本地代码的不当使用可能导致整个程序崩溃。一个通用规则是，你应该让本地方法集中在少数几个类当中。这样就降低了JAVA和C之间的耦合性。</li>
</ul>
<p>目前来讲使用 JNI 的缺点相对于优点还是可以接受的，可能后面随着 Java 的技术发展，我们不在需要 JNI，但是目前 JDK 还是一直提供对 JNI 标准的支持。</p>
<h4 id="用c语言编写程序本地方法"><a class="markdownIt-Anchor" href="#用c语言编写程序本地方法"></a> 用C语言编写程序本地方法</h4>
<p>上面讲解了什么是 JNI，那么我们接下来就写个例子，如何用 Java 代码调用本地的 C 程序。</p>
<p>官方文档如下：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html">https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html</a></p>
<p>步骤如下：</p>
<ul>
<li>编写带有 native 声明的方法的java类，生成.java文件；(注意这里出现了 native 声明的方法关键字）</li>
<li>使用 javac 命令编译所编写的java类，生成.class文件；</li>
<li>使用 javah -jni  java类名 生成扩展名为 h 的头文件，也即生成.h文件；</li>
<li>使用C/C++（或者其他编程想语言）实现本地方法，创建.h文件的实现，也就是创建.cpp文件实现.h文件中的方法；</li>
<li>将C/C++编写的文件生成动态连接库，生成dll文件；</li>
</ul>
<p>下面我们通过一个 HelloWorld 程序的调用来完成这几个步骤。</p>
<blockquote>
<p>注意：下面所有操作都是在所有操作都是在目录：D:\JNI 下进行的。</p>
</blockquote>
<hr />
<p><strong>1.编写带有native声明的方法的Java类</strong></p>
<ul>
<li>用 native 声明的方法表示告知 JVM 调用，该方法在外部定义，也就是我们会用 C 语言去实现。</li>
<li>System.loadLibrary(“helloJNI”);加载动态库，参数 helloJNI 是动态库的名字。我们可以这样理解：程序中的方法 helloJNI() 在程序中没有实现，但是我们下面要调用这个方法，怎么办呢？我们就需要对这个方法进行初始化，所以用 static 代码块进行初始化。</li>
</ul>
<pre><code class="highlight plaintext">public class HelloJNI &#123;
    //native 关键字告诉 JVM 调用的是该方法在外部定义
    private native void helloJNI();
    
    static&#123;
        System.loadLibrary(&quot;helloJNI&quot;);//载入本地库
    &#125;
    public static void main(String[] args) &#123;
        HelloJNI jni = new HelloJNI();
        jni.helloJNI();
    &#125;
&#125;</code></pre>
<p>这时候如果我们直接运行该程序，会报“A Java Exception has occurred”错误：</p>
<hr />
<p><strong>2.使用javac命令编译所写的Java类，生成.class文件</strong></p>
<pre><code class="highlight plaintext">D:\JNI\javac HelloJNI.java</code></pre>
<p>执行上述命令后，生成 HelloJNI.class 文件：</p>
<hr />
<p><strong>3.使用javah -jni java类名 生成扩展名为.h的头文件</strong></p>
<pre><code class="highlight plaintext">D:\JNI\javah -jni HellloJNI</code></pre>
<p>执行上述命令后，在 D:/JNI 目录下多出了个 HelloJNI.h 文件：</p>
<hr />
<p><strong>4.使用C语言实现本地方法</strong></p>
<ul>
<li>如果不想安装visual studio 的，我们需要在 windows平台安装 gcc。</li>
<li>安装教程如下：<a target="_blank" rel="noopener" href="http://blog.csdn.net/altland/article/details/63252757">http://blog.csdn.net/altland/article/details/63252757</a></li>
<li>注意安装版本的选择，根据系统是32位还是64位来选择。64位 <a target="_blank" rel="noopener" href="https://sourceforge.net/projects/mingw-w64/files/latest/download?source=files">点击下载</a>。</li>
<li>安装完成之后注意配置环境变量，在 cmd 中输入 g++ -v，如果出现如下信息，则安装配置完成：</li>
</ul>
<p><strong>编写C代码并命名helloJNI.c</strong></p>
<pre><code class="highlight plaintext">#include &lt;stdio.h&gt;
int main(void)&#123;
    printf(&quot;Hello, world!&quot;);
    return 0;
&#125;</code></pre>
<p>接着输入如下命令：</p>
<ul>
<li>-m64：表示生成dll库是64位的。后面的路径表示本机安装的JDK路径。生成之后多了一个helloJNI.dll 文件</li>
</ul>
<pre><code class="highlight plaintext">gcc -m64  -Wl,--add-stdcall-alias -I&quot;C:\Program Files\Java\jdk1.8.0_152\include&quot; -I&quot;C:\Program Files\Java\jdk1.8.0_152\include\include\win32&quot; -shared -o helloJNI.dll helloJNI.c</code></pre>
<p>最后运行 HelloJNI：输出 Hello JNI! 大功告成。</p>
<h4 id="jni调用c流程图"><a class="markdownIt-Anchor" href="#jni调用c流程图"></a> JNI调用C流程图</h4>
<h4 id="native关键字"><a class="markdownIt-Anchor" href="#native关键字"></a> native关键字</h4>
<p>通过上面介绍了那么多JNI的知识，终于到介绍本篇文章的主角——native 关键字了。相信大家看完上面的介绍，应该也是知道什么是 native 了吧。</p>
<p>native 用来修饰方法，用 native 声明的方法表示告知 JVM 调用，该方法在外部定义，我们可以用任何语言去实现它。 简单地讲，一个native Method就是一个 Java 调用非 Java 代码的接口。</p>
<p>native 语法：</p>
<ul>
<li>修饰方法的位置必须在返回类型之前，和其余的方法控制符前后关系不受限制。</li>
<li>不能用 abstract 修饰，也没有方法体，也没有左右大括号。</li>
<li>返回值可以是任意类型</li>
</ul>
<p>我们在日常编程中看到native修饰的方法，只需要知道这个方法的作用是什么，至于别的就不用管了，操作系统会给我们实现。</p>
<h2 id="java核心类javalang"><a class="markdownIt-Anchor" href="#java核心类javalang"></a> Java核心类(java.lang)</h2>
<h3 id="字符串和编码"><a class="markdownIt-Anchor" href="#字符串和编码"></a> 字符串和编码</h3>
<h4 id="string"><a class="markdownIt-Anchor" href="#string"></a> String</h4>
<p>在Java中，String是一个引用类型，它本身也是一个class。但是，Java编译器对String有特殊处理，即可以直接用&quot;…&quot;来表示一个字符串：</p>
<pre><code class="highlight plaintext">String s1 = &quot;Hello!&quot;;</code></pre>
<p>实际上字符串在String内部是通过一个char[]数组表示的，因此，按下面的写法也是可以的：</p>
<pre><code class="highlight plaintext">String s2 = new String(new char[] &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;!&#x27;&#125;);</code></pre>
<p>因为String太常用了，所以Java提供了&quot;…&quot;这种字符串字面量表示方法。</p>
<p>Java字符串的一个重要特点就是字符串不可变。这种不可变性是通过内部的private final char[]字段，以及没有任何修改char[]的方法实现的。</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        String s = &quot;Hello&quot;;
        System.out.println(s);
        s = s.toUpperCase();
        System.out.println(s);
    &#125;
&#125;</code></pre>
<blockquote>
<p>上述例子中，实际上只是改变了s的引用，实际的Hello字符串对象并没有改变，转换大写是重新生成了一个新的字符串</p>
</blockquote>
<hr />
<p><strong>字符串比较</strong></p>
<p>当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想比较字符串的内容是否相同。必须使用equals()方法而不能用==</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        String s1 = &quot;hello&quot;;
        String s2 = &quot;hello&quot;;
        System.out.println(s1 == s2);   //true
        System.out.println(s1.equals(s2));  //true
    &#125;
&#125;</code></pre>
<blockquote>
<p>从表面上看，两个字符串用==和equals()比较都为true，但实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然s1和s2的引用就是相同的。</p>
</blockquote>
<p>所以，这种==比较返回true纯属巧合。换一种写法，==比较就会失败：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        String s1 = &quot;hello&quot;;
        String s2 = &quot;HELLO&quot;.toLowerCase();
        System.out.println(s1 == s2);   //false
        System.out.println(s1.equals(s2));  //true
    &#125;
&#125;</code></pre>
<blockquote>
<p>结论：两个字符串比较，<strong>必须总是使用equals()方法</strong>。</p>
</blockquote>
<p>要忽略大小写比较，使用equalsIgnoreCase()方法</p>
<hr />
<p><strong>搜索子串、提取子串</strong></p>
<p>String类还提供了多种方法来<strong>搜索子串、提取子串</strong>。常用的方法有：</p>
<pre><code class="highlight plaintext">// 是否包含子串:
&quot;Hello&quot;.contains(&quot;ll&quot;); // true

&quot;Hello&quot;.indexOf(&quot;l&quot;); // 2
&quot;Hello&quot;.lastIndexOf(&quot;l&quot;); // 3
&quot;Hello&quot;.startsWith(&quot;He&quot;); // true
&quot;Hello&quot;.endsWith(&quot;lo&quot;); // true

&quot;Hello&quot;.substring(2); // &quot;llo&quot;   索引从0开始
&quot;Hello&quot;.substring(2, 4); //&quot;ll&quot;</code></pre>
<blockquote>
<p>注意到contains()方法的参数是CharSequence而不是String，因为CharSequence是String的父类。</p>
</blockquote>
<hr />
<p><strong>去除首尾空白字符</strong></p>
<p>使用<strong>trim</strong>()方法可以移除字符串首尾空白字符。空白字符包括空格，\t，\r，\n：</p>
<pre><code class="highlight plaintext">&quot;  \tHello\r\n &quot;.trim(); // &quot;Hello&quot;</code></pre>
<blockquote>
<p>注意：trim()并没有改变字符串的内容，而是返回了一个新字符串</p>
</blockquote>
<p>另一个<strong>strip</strong>()方法也可以移除字符串首尾空白字符。它和trim()不同的是，类似中文的空格字符\u3000也会被移除：</p>
<pre><code class="highlight plaintext">&quot;\u3000Hello\u3000&quot;.strip(); // &quot;Hello&quot;
&quot; Hello &quot;.stripLeading(); // &quot;Hello &quot;
&quot; Hello &quot;.stripTrailing(); // &quot; Hello&quot;</code></pre>
<p>String还提供了<strong>isEmpty</strong>()和<strong>isBlank</strong>()来判断字符串是否为空和空白字符串：</p>
<pre><code class="highlight plaintext">&quot;&quot;.isEmpty(); // true，因为字符串长度为0
&quot;  &quot;.isEmpty(); // false，因为字符串长度不为0

&quot;  \n&quot;.isBlank(); // true，因为只包含空白字符
&quot; Hello &quot;.isBlank(); // false，因为包含非空白字符</code></pre>
<hr />
<p><strong>替换子串</strong></p>
<p>要在字符串中替换子串，有两种方法。一种是根据字符或字符串替换：</p>
<pre><code class="highlight plaintext">String s = &quot;hello&quot;;
s.replace(&#x27;l&#x27;, &#x27;w&#x27;); // &quot;hewwo&quot;，所有字符&#x27;l&#x27;被替换为&#x27;w&#x27;
s.replace(&quot;ll&quot;, &quot;~~&quot;); // &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot;</code></pre>
<p>另一种是通过正则表达式替换：</p>
<pre><code class="highlight plaintext">String s = &quot;A,,B;C ,D&quot;;
s.replaceAll(&quot;[\\,\\;\\s]+&quot;, &quot;,&quot;); // &quot;A,B,C,D&quot;</code></pre>
<blockquote>
<p>上面的代码通过正则表达式，把匹配的子串统一替换为&quot;,&quot;。关于正则表达式的用法我们会在后面详细讲解。</p>
</blockquote>
<hr />
<p><strong>分割字符串</strong></p>
<p>要分割字符串，使用split()方法，并且传入的也是正则表达式：</p>
<pre><code class="highlight plaintext">String s = &quot;A,B,C,D&quot;;
String[] ss = s.split(&quot;\\,&quot;); // &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;&#125;</code></pre>
<hr />
<p><strong>拼接字符串</strong></p>
<p>拼接字符串使用静态方法join()，它用指定的字符串连接字符串数组：</p>
<pre><code class="highlight plaintext">String[] arr = &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;;
String s = String.join(&quot;***&quot;, arr); // &quot;A***B***C&quot;</code></pre>
<hr />
<p><strong>类型转换</strong></p>
<p>要把任意基本类型或引用类型转换为字符串，可以使用静态方法valueOf()。这是一个重载方法，编译器会根据参数自动选择合适的方法：</p>
<pre><code class="highlight plaintext">String.valueOf(123); // &quot;123&quot;
String.valueOf(45.67); // &quot;45.67&quot;
String.valueOf(true); // &quot;true&quot;
String.valueOf(new Object()); // 类似java.lang.Object@636be97c</code></pre>
<p>要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为int类型：</p>
<pre><code class="highlight plaintext">int n1 = Integer.parseInt(&quot;123&quot;); // 123
int n2 = Integer.parseInt(&quot;ff&quot;, 16); // 按十六进制转换，255</code></pre>
<p>把字符串转换为boolean类型：</p>
<pre><code class="highlight plaintext">boolean b1 = Boolean.parseBoolean(&quot;true&quot;); // true
boolean b2 = Boolean.parseBoolean(&quot;FALSE&quot;); // false</code></pre>
<p>要特别注意，Integer有个getInteger(String)方法，它不是将字符串转换为int，而是把该字符串对应的系统变量转换为Integer：</p>
<pre><code class="highlight plaintext">Integer.getInteger(&quot;java.version&quot;); // 版本号，11</code></pre>
<hr />
<p><strong>转换为char[]</strong></p>
<p>String和char[]类型可以互相转换，方法是：</p>
<pre><code class="highlight plaintext">char[] cs = &quot;Hello&quot;.toCharArray(); // String -&gt; char[]
String s = new String(cs); // char[] -&gt; String</code></pre>
<p>如果修改了char[]数组，String并不会改变：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        char[] cs = &quot;Hello&quot;.toCharArray();
        String s = new String(cs);
        System.out.println(s);
        cs[0] = &#x27;X&#x27;;
        System.out.println(s);
    &#125;
&#125;</code></pre>
<blockquote>
<p>这是因为通过new String(char[])创建新的String实例时，它并不会直接引用传入的char[]数组，而是会复制一份，所以，修改外部的char[]数组不会影响String实例内部的char[]数组，因为这是两个不同的数组。</p>
</blockquote>
<p>从String的不变性设计可以看出，如果传入的对象有可能改变，我们需要复制而不是直接引用。</p>
<p>例如，下面的代码设计了一个Score类保存一组学生的成绩：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        int[] scores = new int[] &#123; 88, 77, 51, 66 &#125;;
        Score s = new Score(scores);
        s.printScores();
        scores[2] = 99;
        s.printScores();
    &#125;
&#125;

class Score &#123;
    private int[] scores;
    public Score(int[] scores) &#123;
        this.scores = scores;
    &#125;

    public void printScores() &#123;
        System.out.println(Arrays.toString(scores));
    &#125;
&#125;</code></pre>
<blockquote>
<p>观察两次输出，由于Score内部直接引用了外部传入的int[]数组，这会造成外部代码对int[]数组的修改，影响到Score类的字段。如果外部代码不可信，这就会造成安全隐患</p>
</blockquote>
<h4 id="字符编码"><a class="markdownIt-Anchor" href="#字符编码"></a> 字符编码</h4>
<p>在早期的计算机系统中，为了给字符编码，美国国家标准学会（American National Standard Institute：ANSI）制定了一套英文字母、数字和常用符号的编码，它占用一个字节，编码范围从0到127，最高位始终为0，称为ASCII编码。例如，字符’A’的编码是0x41，字符’1’的编码是0x31</p>
<p>如果要把汉字也纳入计算机编码，很显然一个字节是不够的。GB2312标准使用两个字节表示一个汉字，其中第一个字节的最高位始终为1，以便和ASCII编码区分开。例如，汉字’中’的GB2312编码是0xd6d0</p>
<p>类似的，日文有Shift_JIS编码，韩文有EUC-KR编码，这些编码因为标准不统一，同时使用，就会产生冲突</p>
<p>为了统一全球所有语言的编码，全球统一码联盟发布了Unicode编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。</p>
<p>Unicode编码需要两个或者更多字节表示，我们可以比较中英文字符在ASCII、GB2312和Unicode的编码：</p>
<p>英文字符’A’的ASCII编码和Unicode编码：</p>
<p>英文字符的Unicode编码就是简单地在前面添加一个00字节。中文字符’中’的GB2312编码和Unicode编码：</p>
<p>那我们经常使用的UTF-8又是什么编码呢？因为英文字符的Unicode编码高字节总是00，包含大量英文的文本会浪费空间，所以，出现了UTF-8编码，它是一种变长编码，用来把固定长度的Unicode编码变成1～4字节的变长编码。通过UTF-8编码，英文字符’A’的UTF-8编码变为0x41，正好和ASCII码一致，而中文’中’的UTF-8编码为3字节0xe4b8ad。</p>
<p>UTF-8编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为UTF-8编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。</p>
<p>在Java中，char类型实际上就是两个字节的Unicode编码。如果我们要手动把字符串转换成其他编码，可以这样做：</p>
<pre><code class="highlight plaintext">byte[] b1 = &quot;Hello&quot;.getBytes(); // 按ISO8859-1编码转换，不推荐
byte[] b2 = &quot;Hello&quot;.getBytes(&quot;UTF-8&quot;); // 按UTF-8编码转换
byte[] b2 = &quot;Hello&quot;.getBytes(&quot;GBK&quot;); // 按GBK编码转换
byte[] b3 = &quot;Hello&quot;.getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换</code></pre>
<p>如果要把已知编码的byte[]转换为String，可以这样做：</p>
<pre><code class="highlight plaintext">byte[] b = ...
String s1 = new String(b, &quot;GBK&quot;); // 按GBK转换
String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换</code></pre>
<blockquote>
<p><strong>始终牢记：Java的String和char在内存中总是以Unicode编码表示</strong></p>
</blockquote>
<h4 id="版本问题"><a class="markdownIt-Anchor" href="#版本问题"></a> 版本问题</h4>
<p>对于不同版本的JDK，String类在内存中有不同的优化方式。具体来说，早期JDK版本的String总是以char[]存储，它的定义如下：</p>
<pre><code class="highlight plaintext">public final class String &#123;
    private final char[] value;
    private final int offset;
    private final int count;
&#125;</code></pre>
<blockquote>
<p>final修饰的变量为常量，为基本类型时它的值无法被改变，为引用类型时他的引用无法被改变</p>
</blockquote>
<p>而较新的JDK版本的String则以byte[]存储：如果String仅包含ASCII字符，则每个byte存储一个字符，否则，每两个byte存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的String通常仅包含ASCII字符：</p>
<pre><code class="highlight plaintext">public final class String &#123;
    private final byte[] value;
    private final byte coder; // 0 = LATIN1, 1 = UTF16</code></pre>
<blockquote>
<p>对于使用者来说，String内部的优化不影响任何已有代码，因为它的public方法签名是不变的。</p>
</blockquote>
<h3 id="stringbuilder非线程安全的"><a class="markdownIt-Anchor" href="#stringbuilder非线程安全的"></a> StringBuilder(非线程安全的)</h3>
<p>Java编译器对String做了特殊处理，使得我们可以直接用+拼接字符串。</p>
<pre><code class="highlight plaintext">String s = &quot;&quot;;
for (int i = 0; i &lt; 1000; i++) &#123;
    s = s + &quot;,&quot; + i;
&#125;</code></pre>
<p>虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。</p>
<p>为了能高效拼接字符串，Java标准库提供了StringBuilder，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象：</p>
<pre><code class="highlight plaintext">StringBuilder sb = new StringBuilder(1024);
for (int i = 0; i &lt; 1000; i++) &#123;
    sb.append(&#x27;,&#x27;);
    sb.append(i);
&#125;
String s = sb.toString();

//StringBuilder还可以进行链式操作
public class Main &#123;
    public static void main(String[] args) &#123;
        var sb = new StringBuilder(1024);
        sb.append(&quot;Mr &quot;)
          .append(&quot;Bob&quot;)
          .append(&quot;!&quot;)
          .insert(0, &quot;Hello, &quot;);
        System.out.println(sb.toString());
    &#125;
&#125;</code></pre>
<blockquote>
<p>如果我们查看StringBuilder的源码，可以发现，进行链式操作的关键是，定义的append()方法会返回this，这样，就可以不断调用自身的其他方法。</p>
</blockquote>
<p>仿照StringBuilder，我们也可以设计支持链式操作的类。例如，一个可以不断增加的计数器：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Adder adder = new Adder();
        adder.add(3)
             .add(5)
             .inc()
             .add(10);
        System.out.println(adder.value());
    &#125;
&#125;

class Adder &#123;
    private int sum = 0;

    public Adder add(int n) &#123;
        sum += n;
        return this;
    &#125;

    public Adder inc() &#123;
        sum ++;
        return this;
    &#125;

    public int value() &#123;
        return sum;
    &#125;
&#125;</code></pre>
<blockquote>
<p>注意：对于普通的字符串+操作，并不需要我们将其改写为StringBuilder，因为Java编译器在编译时就自动把多个连续的+操作编码为StringConcatFactory的操作。在运行期，StringConcatFactory会自动把字符串连接操作优化为数组复制或者StringBuilder操作</p>
</blockquote>
<p>你可能还听说过StringBuffer，这是Java早期的一个StringBuilder的线程安全版本，它通过同步来保证多个线程操作StringBuffer也是安全的，但是同步会带来执行速度的下降。</p>
<p>StringBuilder和StringBuffer接口完全相同，现在完全没有必要使用StringBuffer</p>
<h3 id="stringjoiner"><a class="markdownIt-Anchor" href="#stringjoiner"></a> StringJoiner</h3>
<p>很多时候，我们拼接的字符串像这样：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        String[] names = &#123;&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;&#125;;
        var sb = new StringBuilder();
        sb.append(&quot;Hello &quot;);
        for (String name : names) &#123;
            sb.append(name).append(&quot;, &quot;);
        &#125;
        // 注意去掉最后的&quot;, &quot;:
        sb.delete(sb.length() - 2, sb.length());
        sb.append(&quot;!&quot;);
        System.out.println(sb.toString());
    &#125;
&#125;</code></pre>
<p>类似用分隔符拼接数组的需求很常见，所以Java标准库还提供了一个StringJoiner来干这个事：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        String[] names = &#123;&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;&#125;;
        var sj = new StringJoiner(&quot;, &quot;);
        for (String name : names) &#123;
            sj.add(name);
        &#125;
        System.out.println(sj.toString());
    &#125;
&#125;</code></pre>
<p>慢着！用StringJoiner的结果少了前面的&quot;Hello “和结尾的”!&quot;！遇到这种情况，需要给StringJoiner指定“开头”和“结尾”：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        String[] names = &#123;&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;&#125;;
        var sj = new StringJoiner(&quot;, &quot;, &quot;Hello &quot;, &quot;!&quot;);
        for (String name : names) &#123;
            sj.add(name);
        &#125;
        System.out.println(sj.toString());
    &#125;
&#125;</code></pre>
<blockquote>
<p>查看源码，可以发现，StringJoiner内部实际上就是使用了StringBuilder，所以拼接效率和StringBuilder几乎是一模一样的</p>
</blockquote>
<hr />
<p><strong>String.join()</strong></p>
<p>String还提供了一个静态方法join()，这个方法在内部使用了StringJoiner来拼接字符串，在不需要指定“开头”和“结尾”的时候，用String.join()更方便：</p>
<pre><code class="highlight plaintext">String[] names = &#123;&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;&#125;;
var s = String.join(&quot;, &quot;, names);</code></pre>
<h3 id="包装类型"><a class="markdownIt-Anchor" href="#包装类型"></a> 包装类型</h3>
<p>我们已经知道，Java的数据类型分两种：</p>
<ul>
<li><strong>基本类型</strong>：byte，short，int，long，boolean，float，double，char</li>
<li><strong>引用类型</strong>：所有class和interface类型</li>
</ul>
<p>引用类型可以赋值为null，表示空，但基本类型不能赋值为null：</p>
<pre><code class="highlight plaintext">String s = null;
int n = null; // compile error!</code></pre>
<p>那么，如何把一个基本类型视为对象（引用类型）？</p>
<p>比如，想要把int基本类型变成一个引用类型，我们可以定义一个Integer类，它只包含一个实例字段int，这样，Integer类就可以视为int的包装类（Wrapper Class）：</p>
<pre><code class="highlight plaintext">public class Integer &#123;
    private int value;

    public Integer(int value) &#123;
        this.value = value;
    &#125;

    public int intValue() &#123;
        return this.value;
    &#125;
&#125;</code></pre>
<p>定义好了Integer类，我们就可以把int和Integer互相转换：</p>
<pre><code class="highlight plaintext">Integer n = null;
Integer n2 = new Integer(99);
int n3 = n2.intValue();</code></pre>
<p>实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>对应的引用类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>java.lang.Boolean</td>
</tr>
<tr>
<td>byte</td>
<td>java.lang.Byte</td>
</tr>
<tr>
<td>short</td>
<td>java.lang.Short</td>
</tr>
<tr>
<td>int</td>
<td>java.lang.Integer</td>
</tr>
<tr>
<td>long</td>
<td>java.lang.Long</td>
</tr>
<tr>
<td>float</td>
<td>java.lang.Float</td>
</tr>
<tr>
<td>double</td>
<td>java.lang.Double</td>
</tr>
<tr>
<td>char</td>
<td>java.lang.Character</td>
</tr>
</tbody>
</table>
<p>我们可以直接使用，并不需要自己去定义：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        int i = 100;
        // 通过new操作符创建Integer实例(不推荐使用,会有编译警告):
        Integer n1 = new Integer(i);
        // 通过静态方法valueOf(int)创建Integer实例:
        Integer n2 = Integer.valueOf(i);
        // 通过静态方法valueOf(String)创建Integer实例:
        Integer n3 = Integer.valueOf(&quot;100&quot;);
        System.out.println(n3.intValue());
    &#125;
&#125;</code></pre>
<h4 id="auto-boxing-自动装箱"><a class="markdownIt-Anchor" href="#auto-boxing-自动装箱"></a> Auto Boxing 自动装箱</h4>
<p>因为int和Integer可以互相转换：</p>
<pre><code class="highlight plaintext">int i = 100;
Integer n = Integer.valueOf(i);
int x = n.intValue();</code></pre>
<p>所以，Java编译器可以帮助我们自动在int和Integer之间转型：</p>
<pre><code class="highlight plaintext">Integer n = 100; // 编译器自动使用Integer.valueOf(int)
int x = n; // 编译器自动使用Integer.intValue()</code></pre>
<p>这种直接把int变为Integer的赋值写法，称为自动装箱（Auto Boxing），反过来，把Integer变为int的赋值写法，称为自动拆箱（Auto Unboxing）</p>
<blockquote>
<p>注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。</p>
</blockquote>
<p>装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报NullPointerException：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Integer n = null;
        int i = n;
    &#125;
&#125;</code></pre>
<h4 id="不变类"><a class="markdownIt-Anchor" href="#不变类"></a> 不变类</h4>
<p>所有的包装类型都是不变类。我们查看Integer的源码可知，它的核心代码如下：</p>
<pre><code class="highlight plaintext">public final class Integer &#123;
    private final int value;
&#125;</code></pre>
<p>因此，一旦创建了Integer对象，该对象就是不变的。</p>
<p>对两个Integer实例进行比较要特别注意：绝对不能用==比较，因为Integer是引用类型，必须使用equals()比较：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Integer x = 127;
        Integer y = 127;
        Integer m = 99999;
        Integer n = 99999;
        System.out.println(&quot;x == y: &quot; + (x==y)); // true
        System.out.println(&quot;m == n: &quot; + (m==n)); // false
        System.out.println(&quot;x.equals(y): &quot; + x.equals(y)); // true
        System.out.println(&quot;m.equals(n): &quot; + m.equals(n)); // true
    &#125;
&#125;</code></pre>
<blockquote>
<p>仔细观察结果的童鞋可以发现，==比较，较小的两个相同的Integer返回true，较大的两个相同的Integer返回false，这是因为Integer是不变类，编译器把Integer x = 127;自动变为Integer x = Integer.valueOf(127);，为了节省内存，Integer.valueOf()对于较小的数，始终返回相同的实例，因此，<mark>比较“恰好”为true，但我们绝不能因为Java标准库的Integer内部有缓存优化就用</mark>比较，必须用equals()方法比较两个Integer</p>
</blockquote>
<p>因为Integer.valueOf()可能始终返回同一个Integer实例，因此，在我们自己创建Integer的时候，以下两种方法：</p>
<pre><code class="highlight plaintext">方法1：Integer n = new Integer(100);
方法2：Integer n = Integer.valueOf(100);</code></pre>
<p>方法2更好，因为方法1总是创建新的Integer实例，方法2把内部优化留给Integer的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化</p>
<p>我们把能创建“新”对象的静态方法称为静态工厂方法。Integer.valueOf()就是静态工厂方法，它尽可能地返回缓存的实例以节省内存</p>
<blockquote>
<p>创建新对象时，优先选用静态工厂方法而不是new操作符</p>
</blockquote>
<p>如果我们考察Byte.valueOf()方法的源码，可以看到，标准库返回的Byte实例全部是缓存实例，但调用者并不关心静态工厂方法以何种方式创建新实例还是直接返回缓存的实例。</p>
<h4 id="进制转换"><a class="markdownIt-Anchor" href="#进制转换"></a> 进制转换</h4>
<p>Integer类本身还提供了大量方法，例如，最常用的静态方法parseInt()可以把字符串解析成一个整数：</p>
<pre><code class="highlight plaintext">int x1 = Integer.parseInt(&quot;100&quot;); // 100int x2 = Integer.parseInt(&quot;100&quot;, 16); // 256,因为按16进制解析</code></pre>
<p>Integer还可以把整数格式化为指定进制的字符串：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        System.out.println(Integer.toString(100)); // &quot;100&quot;,表示为10进制
        System.out.println(Integer.toString(100, 36)); // &quot;2s&quot;,表示为36进制
        System.out.println(Integer.toHexString(100)); // &quot;64&quot;,表示为16进制
        System.out.println(Integer.toOctalString(100)); // &quot;144&quot;,表示为8进制
        System.out.println(Integer.toBinaryString(100)); // &quot;1100100&quot;,表示为2进制
    &#125;
&#125;</code></pre>
<blockquote>
<p>注意：上述方法的输出都是String，在计算机内存中，只用二进制表示，不存在十进制或十六进制的表示方法。int n = 100在内存中总是以4字节的二进制表示：</p>
</blockquote>
<p>我们经常使用的System.out.println(n);是依靠核心库自动把整数格式化为10进制输出并显示在屏幕上，使用Integer.toHexString(n)则通过核心库自动把整数格式化为16进制</p>
<p>这里我们注意到程序设计的一个重要原则：数据的存储和显示要分离。</p>
<p>Java的包装类型还定义了一些有用的静态变量</p>
<pre><code class="highlight plaintext">// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:
Boolean t = Boolean.TRUE;
Boolean f = Boolean.FALSE;

// int可表示的最大/最小值:
int max = Integer.MAX_VALUE; // 2147483647
int min = Integer.MIN_VALUE; // -2147483648

// long类型占用的bit和byte数量:
int sizeOfLong = Long.SIZE; // 64 (bits)
int bytesOfLong = Long.BYTES; // 8 (bytes)</code></pre>
<p>最后，所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型：</p>
<pre><code class="highlight plaintext">// 向上转型为Number:
Number num = new Integer(999);
// 获取byte, int, long, float, double:
byte b = num.byteValue();
int n = num.intValue();
long ln = num.longValue();
float f = num.floatValue();
double d = num.doubleValue();</code></pre>
<h4 id="无符号整数"><a class="markdownIt-Anchor" href="#无符号整数"></a> 无符号整数</h4>
<p>在Java中，并没有无符号整型（Unsigned）的基本数据类型。byte、short、int和long都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。</p>
<p>例如，byte是有符号整型，范围是-128<sub>+127，但如果把byte看作无符号整型，它的范围就是0</sub>255。我们把一个负的byte按无符号整型转换为int：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        byte x = -1;
        byte y = 127;
        System.out.println(Byte.toUnsignedInt(x)); // 255
        System.out.println(Byte.toUnsignedInt(y)); // 127
    &#125;
&#125;</code></pre>
<blockquote>
<p>因为byte的-1的二进制表示是11111111，以无符号整型转换后的int就是255。</p>
<p>类似的，可以把一个short按unsigned转换为int，把一个int按unsigned转换为long。</p>
</blockquote>
<h4 id="包装类型与基本类型比较问题"><a class="markdownIt-Anchor" href="#包装类型与基本类型比较问题"></a> 包装类型与基本类型比较问题</h4>
<p>首先明确一点：<mark>基本类型比较值，引用类型比较的是内存地址；equals若重写过，则比较的是重写的方法（没重写调用Object中的equals方法，使用</mark>比较）</p>
<ul>
<li><strong>基本类型</strong>和<strong>基本类型</strong>进行“==”比较，直接比较值</li>
<li><strong>基本类型</strong>和<strong>基本封装类型</strong>进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后（Integer变int）再进行比较，如果拆箱后基本类型不同，则会自动提高类型（byte/short/变int）,再进行值比较</li>
<li><strong>基本封装类型</strong>和<strong>基本封装类型</strong>进行“==”比较，比较两个对象的地址（如果使用直接赋值的方法，即 <code>Integer i=100;</code>，在[-128,127]区间的时候，为true。不在这个区间，则为false）（如果使用new的方法，即<code>Integer i = new Integer(100)</code>，则返回false）</li>
<li><strong>基本封装类型</strong>和<strong>基本封装类型</strong>进行equals比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true</li>
<li><strong>基本封装类型</strong>调用equals(),但是参数是<strong>基本类型</strong>，这时候，先会进行自动装箱，基本型转换为其封装类型（int转为Integer），若类型不同返回false，若装箱后类型相同，则比较值，如果值相同，则返回true，否则返回false</li>
</ul>
<blockquote>
<p>装箱过程是通过调用包装器的valueOf方法实现的</p>
<p>拆箱过程是通过调用包装器的xxxValue方法实现的（xxx表示对应的基本数据类型）</p>
</blockquote>
<hr />
<p><strong>缓存问题</strong>：</p>
<ul>
<li>直接给包装类型赋值时，编译器会使用<code>Integer.valueOf(100)</code>自动装箱，所以当值在[-128,127]中的时候，由于值缓存在IntegerCache中，那么当赋值在这个区间的时候，不会创建新的Integer对象，而是直接从缓存中获取已经创建好的Integer对象。而当大于这个区间的时候，会直接new Integer。</li>
</ul>
<pre><code class="highlight plaintext">Integer i = 100;  //这句话相当于Integer i = Integer.valueOf(100);
Integer i1 = new Integer(100);

//缓存问题
Integer x = 127;
Integer y = 127;
Integer m = 99999;
Integer n = 99999;
System.out.println(x==y);   //true
System.out.println(m==n);   //false</code></pre>
<p>包装器的缓存：</p>
<ul>
<li>Boolean：(全部缓存)</li>
<li>Byte：(全部缓存)</li>
<li>Character(&lt;= 127缓存)</li>
<li>Short(-128 — 127缓存)</li>
<li>Long(-128 — 127缓存)</li>
<li>Integer(-128 — 127缓存)</li>
<li>Float(没有缓存)</li>
<li>Doulbe(没有缓存)</li>
</ul>
<h3 id="javabean"><a class="markdownIt-Anchor" href="#javabean"></a> JavaBean</h3>
<p>在Java中，有很多class的定义都符合这样的规范：</p>
<ul>
<li>若干private实例字段；</li>
<li>通过public方法来读写实例字段。</li>
</ul>
<pre><code class="highlight plaintext">public class Person &#123;
    private String name;
    private int age;

    public String getName() &#123; return this.name; &#125;
    public void setName(String name) &#123; this.name = name; &#125;

    public int getAge() &#123; return this.age; &#125;
    public void setAge(int age) &#123; this.age = age; &#125;
&#125;</code></pre>
<p>boolean字段比较特殊，它的读方法一般命名为isXyz()：</p>
<pre><code class="highlight plaintext">// 读方法:
public boolean isChild()
// 写方法:
public void setChild(boolean value)</code></pre>
<p>我们通常把一组对应的读方法（getter）和写方法（setter）称为属性（property）。例如，name属性：</p>
<ul>
<li>对应的读方法是String getName()</li>
<li>对应的写方法是setName(String)</li>
</ul>
<p>只有getter的属性称为只读属性（read-only），例如，定义一个age只读属性：</p>
<ul>
<li>对应的读方法是int getAge()</li>
<li>无对应的写方法setAge(int)</li>
</ul>
<p>类似的，只有setter的属性称为只写属性（write-only）。</p>
<p>很明显，只读属性很常见，只写属性不常见。</p>
<hr />
<p><strong>枚举JavaBean属性</strong></p>
<p>要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的Introspector：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) throws Exception &#123;
        BeanInfo info = Introspector.getBeanInfo(Person.class);
        for (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123;
            System.out.println(pd.getName());
            System.out.println(&quot;  &quot; + pd.getReadMethod());
            System.out.println(&quot;  &quot; + pd.getWriteMethod());
        &#125;
    &#125;
&#125;

class Person &#123;
    private String name;
    private int age;

    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public int getAge() &#123;
        return age;
    &#125;
    public void setAge(int age) &#123;
        this.age = age;
    &#125;
&#125;</code></pre>
<blockquote>
<p>运行上述代码，可以列出所有的属性，以及对应的读写方法。注意class属性是从Object继承的getClass()方法带来的。</p>
</blockquote>
<h3 id="枚举类"><a class="markdownIt-Anchor" href="#枚举类"></a> 枚举类</h3>
<p>在Java中，我们可以通过static final来定义常量。例如，我们希望定义周一到周日这7个常量，可以用7个不同的int表示：</p>
<pre><code class="highlight plaintext">public class Weekday &#123;
    public static final int SUN = 0;
    public static final int MON = 1;
    public static final int TUE = 2;
    public static final int WED = 3;
    public static final int THU = 4;
    public static final int FRI = 5;
    public static final int SAT = 6;
&#125;</code></pre>
<p>使用常量的时候，可以这么引用：</p>
<pre><code class="highlight plaintext">if (day == Weekday.SAT || day == Weekday.SUN) &#123;
    // TODO: work at home
&#125;</code></pre>
<p>也可以把常量定义为字符串类型，例如，定义3种颜色的常量：</p>
<pre><code class="highlight plaintext">public class Color &#123;
    public static final String RED = &quot;r&quot;;
    public static final String GREEN = &quot;g&quot;;
    public static final String BLUE = &quot;b&quot;;
&#125;</code></pre>
<p>使用常量的时候，可以这么引用：</p>
<pre><code class="highlight plaintext">String color = ...
if (Color.RED.equals(color)) &#123;
    // TODO:
&#125;</code></pre>
<p>无论是int常量还是String常量，使用这些常量来表示一组枚举值的时候，有一个严重的问题就是，编译器无法检查每个值的合理性。例如：</p>
<pre><code class="highlight plaintext">if (weekday == 6 || weekday == 7) &#123;
    if (tasks == Weekday.MON) &#123;
        // TODO:
    &#125;
&#125;</code></pre>
<p>上述代码编译和运行均不会报错，但存在两个问题：</p>
<ul>
<li>注意到Weekday定义的常量范围是0~6，并不包含7，编译器无法检查不在枚举中的int值；</li>
<li>定义的常量仍可与其他变量比较，但其用途并非是枚举星期值。</li>
</ul>
<h4 id="enum"><a class="markdownIt-Anchor" href="#enum"></a> enum</h4>
<p>为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用enum来定义枚举类：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Weekday day = Weekday.SUN;
        if (day == Weekday.SAT || day == Weekday.SUN) &#123;
            System.out.println(&quot;Work at home!&quot;);
        &#125; else &#123;
            System.out.println(&quot;Work at office!&quot;);
        &#125;
    &#125;
&#125;

enum Weekday &#123;
    SUN, MON, TUE, WED, THU, FRI, SAT;
&#125;</code></pre>
<blockquote>
<p>注意到定义枚举类是通过关键字enum实现的，我们只需依次列出枚举的常量名。</p>
</blockquote>
<p>和int定义的常量相比，使用enum定义枚举有如下好处：</p>
<p>首先，enum常量本身带有类型信息，即Weekday.SUN类型是Weekday，编译器会自动检查出类型错误。例如，下面的语句不可能编译通过：</p>
<pre><code class="highlight plaintext">int day = 1;
if (day == Weekday.SUN) &#123; // Compile error: bad operand types for binary operator &#x27;==&#x27;
&#125;</code></pre>
<blockquote>
<p>其次，不可能引用到非枚举的值，因为无法通过编译。</p>
</blockquote>
<p>最后，不同类型的枚举不能互相比较或者赋值，因为类型不符。例如，不能给一个Weekday枚举类型的变量赋值为Color枚举类型的值：</p>
<pre><code class="highlight plaintext">Weekday x = Weekday.SUN; // ok!
Weekday y = Color.RED; // Compile error: incompatible types</code></pre>
<blockquote>
<p>这就使得编译器可以在编译期自动检查出所有可能的潜在错误。</p>
</blockquote>
<hr />
<p><strong>enum的比较</strong></p>
<p>使用enum定义的枚举类是一种引用类型。前面我们讲到，引用类型比较，要使用equals()方法，如果使用==比较，它比较的是两个引用类型的变量是否是同一个对象。因此，引用类型比较，要始终使用equals()方法，但enum类型可以例外</p>
<p>这是因为enum类型的每个常量在JVM中只有一个唯一实例，所以可以直接用==比较：</p>
<pre><code class="highlight plaintext">if (day == Weekday.FRI) &#123; // ok!
&#125;
if (day.equals(Weekday.SUN)) &#123; // ok, but more code!
&#125;</code></pre>
<hr />
<p><strong>enum类型</strong></p>
<p>通过enum定义的枚举类，和其他的class有什么区别？</p>
<p>答案是没有任何区别。enum定义的类型就是class，只不过它有以下几个特点：</p>
<ul>
<li>定义的enum类型总是继承自java.lang.Enum，且无法被继承；</li>
<li>只能定义出enum的实例，而无法通过new操作符创建enum的实例；</li>
<li>定义的每个实例都是引用类型的唯一实例；</li>
<li>可以将enum类型用于switch语句。</li>
</ul>
<p>例如，我们定义的Color枚举类：</p>
<pre><code class="highlight plaintext">public enum Color &#123;
    RED, GREEN, BLUE;
&#125;</code></pre>
<p>编译器编译出的class大概就像这样：</p>
<pre><code class="highlight plaintext">public final class Color extends Enum &#123; // 继承自Enum，标记为final class
    // 每个实例均为全局唯一:
    public static final Color RED = new Color();
    public static final Color GREEN = new Color();
    public static final Color BLUE = new Color();
    // private构造方法，确保外部无法调用new操作符:
    private Color() &#123;&#125;
&#125;</code></pre>
<p>所以，编译后的enum类和普通class并没有任何区别。但是我们自己无法按定义普通class那样来定义enum，必须使用enum关键字，这是Java语法规定的。</p>
<p>因为enum是一个class，每个枚举的值都是class实例，因此，这些实例有一些方法：</p>
<ul>
<li><strong>name</strong>()：返回常量名，例如：</li>
</ul>
<pre><code class="highlight plaintext">String s = Weekday.SUN.name(); // &quot;SUN&quot;</code></pre>
<ul>
<li><strong>ordinal</strong>()：返回定义的常量的顺序，从0开始计数，例如：</li>
</ul>
<pre><code class="highlight plaintext">int n = Weekday.MON.ordinal(); // 1</code></pre>
<blockquote>
<p>改变枚举常量定义的顺序就会导致ordinal()返回值发生变化</p>
<p>。例如：</p>
</blockquote>
<pre><code class="highlight plaintext">public enum Weekday &#123;
    SUN, MON, TUE, WED, THU, FRI, SAT;
&#125;

public enum Weekday &#123;
    MON, TUE, WED, THU, FRI, SAT, SUN;
&#125;</code></pre>
<p>这两段ordinal就是不同的。如果在代码中编写了类似if(x.ordinal()==1)这样的语句，就要保证enum的枚举顺序不能变。新增的常量必须放在最后</p>
<p>有些童鞋会想，Weekday的枚举常量如果要和int转换，使用ordinal()不是非常方便？比如这样写：</p>
<pre><code class="highlight plaintext">String task = Weekday.MON.ordinal() + &quot;/ppt&quot;;
saveToFile(task);</code></pre>
<p>但是，如果不小心修改了枚举的顺序，编译器是无法检查出这种逻辑错误的。要编写健壮的代码，就不要依靠ordinal()的返回值。因为enum本身是class，所以我们可以定义private的构造方法，并且，给每个枚举常量添加字段：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Weekday day = Weekday.SUN;
        if (day.dayValue == 6 || day.dayValue == 0) &#123;
            System.out.println(&quot;Work at home!&quot;);
        &#125; else &#123;
            System.out.println(&quot;Work at office!&quot;);
        &#125;
    &#125;
&#125;

enum Weekday &#123;
    MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6), SUN(0);

    public final int dayValue;

    private Weekday(int dayValue) &#123;
        this.dayValue = dayValue;
    &#125;
&#125;</code></pre>
<blockquote>
<p>这样就无需担心顺序的变化，新增枚举常量时，也需要指定一个int值。</p>
</blockquote>
<blockquote>
<p>注意：枚举类的字段也可以是非final类型，即可以在运行期修改，但是不推荐这样做！</p>
</blockquote>
<p>默认情况下，对枚举常量调用toString()会返回和name()一样的字符串。但是，toString()可以被覆写，而name()则不行。我们可以给Weekday添加toString()方法：</p>
<pre><code class="highlight plaintext">enum Weekday &#123;
    MON(1, &quot;星期一&quot;), TUE(2, &quot;星期二&quot;), WED(3, &quot;星期三&quot;), THU(4, &quot;星期四&quot;), FRI(5, &quot;星期五&quot;), SAT(6, &quot;星期六&quot;), SUN(0, &quot;星期日&quot;);

    public final int dayValue;
    private final String chinese;

    private Weekday(int dayValue, String chinese) &#123;
        this.dayValue = dayValue;
        this.chinese = chinese;
    &#125;

    @Override
    public String toString() &#123;
        return this.chinese;
    &#125;</code></pre>
<blockquote>
<p><strong>注意：判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()！</strong></p>
</blockquote>
<hr />
<p><strong>switch</strong></p>
<p>最后，枚举类可以应用在switch语句中。因为枚举类天生具有类型信息和有限个枚举常量，所以比int、String类型更适合用在switch语句中：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Weekday day = Weekday.SUN;
        switch(day) &#123;
        case MON:
        case TUE:
        case WED:
        case THU:
        case FRI:
            System.out.println(&quot;Today is &quot; + day + &quot;. Work at office!&quot;);
            break;
        case SAT:
        case SUN:
            System.out.println(&quot;Today is &quot; + day + &quot;. Work at home!&quot;);
            break;
        default:
            throw new RuntimeException(&quot;cannot process &quot; + day);
        &#125;
    &#125;
&#125;

enum Weekday &#123;
    MON, TUE, WED, THU, FRI, SAT, SUN;
&#125;</code></pre>
<blockquote>
<p>加上default语句，可以在漏写某个枚举常量时自动报错，从而及时发现错误。</p>
</blockquote>
<h3 id="biginteger"><a class="markdownIt-Anchor" href="#biginteger"></a> BigInteger</h3>
<p>在Java中，由CPU原生提供的整型最大范围是64位long型整数。使用long型整数可以直接通过CPU指令进行计算，速度非常快。</p>
<p>如果我们使用的整数范围超过了long型怎么办？这个时候，就只能用软件来模拟一个大整数。java.math.BigInteger就是用来表示任意大小的整数。BigInteger内部用一个int[]数组来模拟一个非常大的整数：</p>
<pre><code class="highlight plaintext">BigInteger bi = new BigInteger(&quot;1234567890&quot;);
System.out.println(bi.pow(5)); // 2867971860299718107233761438093672048294900000</code></pre>
<p>对BigInteger做运算的时候，只能使用实例方法，例如，加法运算：</p>
<pre><code class="highlight plaintext">BigInteger i1 = new BigInteger(&quot;1234567890&quot;);
BigInteger i2 = new BigInteger(&quot;12345678901234567890&quot;);
BigInteger sum = i1.add(i2); // 12345678902469135780</code></pre>
<p>和long型整数运算比，BigInteger不会有范围限制，但缺点是速度比较慢。</p>
<p>也可以把BigInteger转换成long型：</p>
<pre><code class="highlight plaintext">BigInteger i = new BigInteger(&quot;123456789000&quot;);
System.out.println(i.longValue()); // 123456789000
System.out.println(i.multiply(i).longValueExact()); // java.lang.ArithmeticException: BigInteger out of long range</code></pre>
<blockquote>
<p>使用longValueExact()方法时，如果超出了long型的范围，会抛出ArithmeticException</p>
</blockquote>
<p>BigInteger和Integer、Long一样，也是不可变类，并且也继承自Number类。因为Number定义了转换为基本类型的几个方法：</p>
<ul>
<li>转换为byte：byteValue()</li>
<li>转换为short：shortValue()</li>
<li>转换为int：intValue()</li>
<li>转换为long：longValue()</li>
<li>转换为float：floatValue()</li>
<li>转换为double：doubleValue()</li>
</ul>
<p>因此，通过上述方法，可以把BigInteger转换成基本类型。如果BigInteger表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用intValueExact()、longValueExact()等方法，在转换时如果超出范围，将直接抛出ArithmeticException异常。</p>
<h3 id="bigdecimal"><a class="markdownIt-Anchor" href="#bigdecimal"></a> BigDecimal</h3>
<p>和BigInteger类似，BigDecimal可以表示一个任意大小且精度完全准确的浮点数。</p>
<pre><code class="highlight plaintext">BigDecimal bd = new BigDecimal(&quot;123.4567&quot;);
System.out.println(bd.multiply(bd)); //</code></pre>
<p>15241.55677489BigDecimal用scale()表示小数位数，例如：</p>
<pre><code class="highlight plaintext">BigDecimal d1 = new BigDecimal(&quot;123.45&quot;);
BigDecimal d2 = new BigDecimal(&quot;123.4500&quot;);
BigDecimal d3 = new BigDecimal(&quot;1234500&quot;);
System.out.println(d1.scale()); // 2,两位小数
System.out.println(d2.scale()); // 4
System.out.println(d3.scale()); // 0</code></pre>
<p>通过BigDecimal的stripTrailingZeros()方法，可以将一个BigDecimal格式化为一个相等的，但去掉了末尾0的BigDecimal：</p>
<pre><code class="highlight plaintext">BigDecimal d1 = new BigDecimal(&quot;123.4500&quot;);
BigDecimal d2 = d1.stripTrailingZeros();
System.out.println(d1.scale()); // 4
System.out.println(d2.scale()); // 2,因为去掉了00

BigDecimal d3 = new BigDecimal(&quot;1234500&quot;);
BigDecimal d4 = d3.stripTrailingZeros();
System.out.println(d3.scale()); // 0
System.out.println(d4.scale()); // -2</code></pre>
<blockquote>
<p>如果一个BigDecimal的scale()返回负数，例如，-2，表示这个数是个整数，并且末尾有2个0。</p>
</blockquote>
<p>可以对一个BigDecimal设置它的scale，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p>
<pre><code class="highlight plaintext">import java.math.BigDecimal;
import java.math.RoundingMode;

public class Main &#123;
    public static void main(String[] args) &#123;
        BigDecimal d1 = new BigDecimal(&quot;123.456789&quot;);
        BigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 四舍五入，123.4568
        BigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // 直接截断，123.4567
        System.out.println(d2);
        System.out.println(d3);
    &#125;
&#125;</code></pre>
<p>对BigDecimal做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</p>
<pre><code class="highlight plaintext">BigDecimal d1 = new BigDecimal(&quot;123.456&quot;);
BigDecimal d2 = new BigDecimal(&quot;23.456789&quot;);
BigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入
BigDecimal d4 = d1.divide(d2); // 报错：ArithmeticException，因为除不尽</code></pre>
<p>还可以对BigDecimal做除法的同时求余数：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        BigDecimal n = new BigDecimal(&quot;12.345&quot;);
        BigDecimal m = new BigDecimal(&quot;0.12&quot;);
        BigDecimal[] dr = n.divideAndRemainder(m);
        System.out.println(dr[0]); // 102
        System.out.println(dr[1]); // 0.105
    &#125;
&#125;</code></pre>
<p>调用divideAndRemainder()方法时，返回的数组包含两个BigDecimal，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个BigDecimal是否是整数倍数：</p>
<pre><code class="highlight plaintext">BigDecimal n = new BigDecimal(&quot;12.75&quot;);
BigDecimal m = new BigDecimal(&quot;0.15&quot;);
BigDecimal[] dr = n.divideAndRemainder(m);
if (dr[1].signum() == 0) &#123;
    // n是m的整数倍
&#125;</code></pre>
<hr />
<p><strong>比较BigDecimal</strong></p>
<p>在比较两个BigDecimal的值是否相等时，要特别注意，使用equals()方法不但要求两个BigDecimal的值相等，还要求它们的scale()相等：</p>
<pre><code class="highlight plaintext">BigDecimal d1 = new BigDecimal(&quot;123.456&quot;);
BigDecimal d2 = new BigDecimal(&quot;123.45600&quot;);
System.out.println(d1.equals(d2)); // false,因为scale不同
System.out.println(d1.equals(d2.stripTrailingZeros())); // true,因为d2去除尾部0后scale变为2System.out.println(d1.compareTo(d2)); // 0</code></pre>
<p>必须使用compareTo()方法来比较，它根据两个值的大小分别返回负数、正数和0，分别表示小于、大于和等于</p>
<blockquote>
<p><strong>总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！</strong></p>
</blockquote>
<p>如果查看BigDecimal的源码，可以发现，实际上一个BigDecimal是通过一个BigInteger和一个scale来表示的，即BigInteger表示一个完整的整数，而scale表示小数位数：</p>
<pre><code class="highlight plaintext">public class BigDecimal extends Number implements Comparable&lt;BigDecimal&gt; &#123;
    private final BigInteger intVal;
    private final int scale;
&#125;</code></pre>
<blockquote>
<p>BigDecimal也是从Number继承的，也是不可变对象。</p>
</blockquote>
<h3 id="常用工具类"><a class="markdownIt-Anchor" href="#常用工具类"></a> 常用工具类</h3>
<h4 id="math"><a class="markdownIt-Anchor" href="#math"></a> Math</h4>
<p>顾名思义，Math类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算：</p>
<p>求绝对值：</p>
<pre><code class="highlight plaintext">Math.abs(-100); // 100
Math.abs(-7.8); // 7.8</code></pre>
<p>取最大或最小值：</p>
<pre><code class="highlight plaintext">Math.max(100, 99); // 100
Math.min(1.2, 2.3); // 1.2</code></pre>
<p>计算xy次方：</p>
<pre><code class="highlight plaintext">Math.pow(2, 10); // 2的10次方=1024</code></pre>
<p>计算√x：</p>
<pre><code class="highlight plaintext">Math.sqrt(2);   //1.414</code></pre>
<p>计算ex次方：</p>
<pre><code class="highlight plaintext">Math.exp(2); // 7.389...</code></pre>
<p>计算以e为底的对数：</p>
<pre><code class="highlight plaintext">Math.log(4); // 1.386..</code></pre>
<p>计算以10为底的对数：</p>
<pre><code class="highlight plaintext">Math.log10(100); // 2</code></pre>
<p>三角函数：</p>
<pre><code class="highlight plaintext">Math.sin(3.14); // 0.00159...
Math.cos(3.14); // -0.9999...
Math.tan(3.14); // -0.0015...
Math.asin(1.0); // 1.57079...
Math.acos(1.0); // 0.0</code></pre>
<p>Math还提供了几个数学常量：</p>
<pre><code class="highlight plaintext">double pi = Math.PI; // 3.14159...
double e = Math.E; // 2.7182818...
Math.sin(Math.PI / 6); // sin(π/6) = 0.5</code></pre>
<p>生成一个随机数x，x的范围是0 &lt;= x &lt; 1：</p>
<pre><code class="highlight plaintext">Math.random(); // 0.53907... 每次都不一样</code></pre>
<p>如果我们要生成一个区间在[MIN, MAX)的随机数，可以借助Math.random()实现，计算如下：</p>
<pre><code class="highlight plaintext">// 区间在[MIN, MAX)的随机数
public class Main &#123;
    public static void main(String[] args) &#123;
        double x = Math.random(); // x的范围是[0,1)
        double min = 10;
        double max = 50;
        double y = x * (max - min) + min; // y的范围是[10,50)
        long n = (long) y; // n的范围是[10,50)的整数
        System.out.println(y);
        System.out.println(n);
    &#125;
&#125;</code></pre>
<blockquote>
<p>有些童鞋可能注意到Java标准库还提供了一个StrictMath，它提供了和Math几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在误差，不同的平台（例如x86和ARM）计算的结果可能不一致（指误差不同），因此，StrictMath保证所有平台计算结果都是完全相同的，而Math会尽量针对平台优化计算速度，所以，绝大多数情况下，使用Math就足够了</p>
</blockquote>
<h4 id="random"><a class="markdownIt-Anchor" href="#random"></a> Random</h4>
<p>Random用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的</p>
<p>要生成一个随机数，可以使用nextInt()、nextLong()、nextFloat()、nextDouble()：</p>
<pre><code class="highlight plaintext">Random r = new Random();
r.nextInt(); // 2071575453,每次都不一样
r.nextInt(10); // 5,生成一个[0,10)之间的int
r.nextLong(); // 8811649292570369305,每次都不一样
r.nextFloat(); // 0.54335...生成一个[0,1)之间的float
r.nextDouble(); // 0.3716...生成一个[0,1)之间的double</code></pre>
<blockquote>
<p>我们创建Random实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同</p>
</blockquote>
<p>如果我们在创建Random实例时指定一个种子，就会得到完全确定的随机数序列：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Random r = new Random(12345);
        for (int i = 0; i &lt; 10; i++) &#123;
            System.out.println(r.nextInt(100));
        &#125;
        // 51, 80, 41, 28, 55...
    &#125;
&#125;</code></pre>
<blockquote>
<p>前面我们使用的Math.random()实际上内部调用了Random类，所以它也是伪随机数，只是我们无法指定种子</p>
</blockquote>
<h4 id="securerandom"><a class="markdownIt-Anchor" href="#securerandom"></a> SecureRandom</h4>
<p>有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，SecureRandom就是用来创建安全的随机数的：</p>
<pre><code class="highlight plaintext">SecureRandom sr = new SecureRandom();
System.out.println(sr.nextInt(100));</code></pre>
<p>SecureRandom无法指定种子，它使用RNG（random number generator）算法。JDK的SecureRandom实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器：</p>
<pre><code class="highlight plaintext">import java.util.Arrays;
import java.security.SecureRandom;
import java.security.NoSuchAlgorithmException;

public class Main &#123;
    public static void main(String[] args) &#123;
        SecureRandom sr = null;
        try &#123;
            sr = SecureRandom.getInstanceStrong(); // 获取高强度安全随机数生成器
        &#125; catch (NoSuchAlgorithmException e) &#123;
            sr = new SecureRandom(); // 获取普通的安全随机数生成器
        &#125;
        byte[] buffer = new byte[16];
        sr.nextBytes(buffer); // 用安全随机数填充buffer
        System.out.println(Arrays.toString(buffer));
    &#125;
&#125;</code></pre>
<p>SecureRandom的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”</p>
<p>在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用SecureRandom来产生安全的随机数。</p>
<blockquote>
<p><strong>需要使用安全随机数的时候，必须使用SecureRandom，绝不能使用Random！</strong></p>
</blockquote>
<h3 id="runtime"><a class="markdownIt-Anchor" href="#runtime"></a> Runtime</h3>
<p>RunTime类主要代表了应用程序的运行环境。一个RunTime就代表一个运行环境</p>
<p><strong>常用方法</strong></p>
<ul>
<li>getRuntime()：该方法用于返回当前应用程序的运行环境对象</li>
<li>exec(String command)：该方法用于根据指定的路径执行对应的可执行文件</li>
</ul>
<pre><code class="highlight plaintext">public class Demo7 &#123;
	public static void main(String[] args) throws IOException, InterruptedException &#123;
		Runtime runtime = Runtime.getRuntime();
		Process process = runtime.exec(&quot;C:\\Windows\\notepad.exe&quot;);//打开记事本程序，并返回一个进程
		Thread.sleep(3000); //让当前程序停止3秒。
		process.destroy();
	&#125;
&#125;</code></pre>
<ul>
<li>freeMemory()：该方法用于返回Java虚拟机中的空闲内存量，以字节为单位。</li>
<li>maxMemory()：该方法用于返回Java虚拟机试图使用的最大内存量。</li>
<li>totalMemory()：该方法用于返回Java虚拟机中的内存总量。</li>
<li>addShutdownHook(Tread hook)：注册一个新的虚拟机关闭挂钩</li>
</ul>
<h2 id="异常日志"><a class="markdownIt-Anchor" href="#异常日志"></a> 异常/日志</h2>
<h3 id="java异常"><a class="markdownIt-Anchor" href="#java异常"></a> Java异常</h3>
<p>在计算机程序运行的过程中，总是会出现各种各样的错误。</p>
<p>有一些错误是用户造成的，比如，希望用户输入一个int类型的年龄，但是用户的输入是abc：</p>
<pre><code class="highlight plaintext">// 假设用户输入了abc：
String s = &quot;abc&quot;;
int n = Integer.parseInt(s); // NumberFormatException!</code></pre>
<p>程序想要读写某个文件的内容，但是用户已经把它删除了：</p>
<pre><code class="highlight plaintext">// 用户删除了该文件：
String t = readFile(&quot;C:\\abc.txt&quot;); // FileNotFoundException!</code></pre>
<p>还有一些错误是随机出现，并且永远不可能避免的。比如：</p>
<ul>
<li>网络突然断了，连接不到远程服务器；</li>
<li>内存耗尽，程序崩溃了；</li>
<li>用户点“打印”，但根本没有打印机；</li>
<li>……</li>
</ul>
<p>所以，一个健壮的程序必须处理各种各样的错误。所谓错误，就是程序调用某个函数的时候，如果失败了，就表示出错。调用方如何获知调用失败的信息？有两种方法：</p>
<p>方法一：约定返回错误码</p>
<p>例如，处理一个文件，如果返回0，表示成功，返回其他整数，表示约定的错误码：</p>
<pre><code class="highlight plaintext">int code = processFile(&quot;C:\\test.txt&quot;);
if (code == 0) &#123;
    // ok:
&#125; else &#123;
    // error:
    switch (code) &#123;
    case 1:
        // file not found:
    case 2:
        // no read permission:
    default:
        // unknown error:
    &#125;
&#125;</code></pre>
<blockquote>
<p>因为使用int类型的错误码，想要处理就非常麻烦。这种方式常见于底层C函数。</p>
</blockquote>
<hr />
<p>方法二：在语言层面上提供一个异常处理机制。</p>
<p>Java内置了一套异常处理机制，总是使用异常来表示错误。</p>
<p>异常是一种class，因此它本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了：</p>
<pre><code class="highlight plaintext">try &#123;
    String s = processFile(“C:\\test.txt”);
    // ok:
&#125; catch (FileNotFoundException e) &#123;
    // file not found:
&#125; catch (SecurityException e) &#123;
    // no read permission:
&#125; catch (IOException e) &#123;
    // io error:
&#125; catch (Exception e) &#123;
    // other error:
&#125;</code></pre>
<p>因为Java的异常是class，它的继承关系如下：</p>
<p>从继承关系可知：Throwable是异常体系的根，它继承自Object。Throwable有两个体系：Error和Exception</p>
<p><strong>Error</strong> 表示严重的错误，程序对此一般无能为力，例如：</p>
<ul>
<li>OutOfMemoryError：内存耗尽</li>
<li>NoClassDefFoundError：无法加载某个</li>
<li>ClassStackOverflowError：栈溢出</li>
</ul>
<p><strong>Exception</strong> 则是运行时的错误，它可以被捕获并处理</p>
<ul>
<li>NumberFormatException：数值类型的格式错误</li>
<li>FileNotFoundException：未找到文件</li>
<li>SocketException：读取网络失败</li>
</ul>
<p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p>
<ul>
<li>NullPointerException：对某个null的对象调用方法或字段</li>
<li>IndexOutOfBoundsException：数组索引越界</li>
</ul>
<p>Exception又分为两大类：</p>
<ul>
<li>RuntimeException以及它的子类；</li>
<li>非RuntimeException（包括IOException、ReflectiveOperationException等等）</li>
</ul>
<p>Java规定：</p>
<ul>
<li>必须捕获的异常，包括Exception及其子类，但不包括RuntimeException及其子类，这种类型的异常称为Checked Exception。</li>
<li>不需要捕获的异常，包括Error及其子类，RuntimeException及其子类。</li>
</ul>
<hr />
<p><strong>捕获异常</strong></p>
<p>捕获异常使用try…catch语句，把可能发生异常的代码放到try {…}中，然后使用catch捕获对应的Exception及其子类：</p>
<pre><code class="highlight plaintext">// try...catch
import java.io.UnsupportedEncodingException;
import java.util.Arrays;
public class Main &#123;
    public static void main(String[] args) &#123;
        byte[] bs = toGBK(&quot;中文&quot;);
        System.out.println(Arrays.toString(bs));
    &#125;

    static byte[] toGBK(String s) &#123;
        try &#123;
            // 用指定编码转换String为byte[]:
            return s.getBytes(&quot;GBK&quot;);
        &#125; catch (UnsupportedEncodingException e) &#123;
            // 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:
            System.out.println(e); // 打印异常信息
            return s.getBytes(); // 尝试使用用默认编码
        &#125;
    &#125;
&#125;</code></pre>
<p>如果我们不捕获UnsupportedEncodingException，会出现编译失败的问题：</p>
<pre><code class="highlight plaintext">import java.io.UnsupportedEncodingException;
import java.util.Arrays;
public class Main &#123;
    public static void main(String[] args) &#123;
        byte[] bs = toGBK(&quot;中文&quot;);
        System.out.println(Arrays.toString(bs));
    &#125;

    static byte[] toGBK(String s) &#123;
        return s.getBytes(&quot;GBK&quot;);
    &#125;
&#125;</code></pre>
<blockquote>
<p>编译器会报错，错误信息类似：unreported exception UnsupportedEncodingException; must be caught or declared to be thrown，并且准确地指出需要捕获的语句是return s.getBytes(“GBK”);。意思是说，像UnsupportedEncodingException这样的Checked Exception，必须被捕获。</p>
</blockquote>
<p>这是因为String.getBytes(String)方法定义是：</p>
<pre><code class="highlight plaintext">public byte[] getBytes(String charsetName) throws UnsupportedEncodingException &#123;
    ...
&#125;</code></pre>
<blockquote>
<p>在方法定义的时候，使用throws Xxx表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错</p>
</blockquote>
<p>在toGBK()方法中，因为调用了String.getBytes(String)方法，就必须捕获UnsupportedEncodingException。我们也可以不捕获它，而是在方法定义处用throws表示toGBK()方法可能会抛出UnsupportedEncodingException，就可以让toGBK()方法通过编译器检查：</p>
<pre><code class="highlight plaintext">import java.io.UnsupportedEncodingException;
import java.util.Arrays;
public class Main &#123;
    public static void main(String[] args) &#123;
        byte[] bs = toGBK(&quot;中文&quot;);
        System.out.println(Arrays.toString(bs));
    &#125;

    static byte[] toGBK(String s) throws UnsupportedEncodingException &#123;
        return s.getBytes(&quot;GBK&quot;);
    &#125;
&#125;
</code></pre>
<p>上述代码仍然会得到编译错误，但这一次，编译器提示的不是调用return s.getBytes(“GBK”);的问题，而是byte[] bs = toGBK(“中文”);。因为在main()方法中，调用toGBK()，没有捕获它声明的可能抛出的UnsupportedEncodingException。修复方法是在main()方法中捕获异常并处理：</p>
<pre><code class="highlight plaintext">import java.io.UnsupportedEncodingException;
import java.util.Arrays;

public class Main &#123;
    public static void main(String[] args) &#123;
        try &#123;
            byte[] bs = toGBK(&quot;中文&quot;);
            System.out.println(Arrays.toString(bs));
        &#125; catch (UnsupportedEncodingException e) &#123;
            System.out.println(e);
        &#125;
    &#125;

    static byte[] toGBK(String s) throws UnsupportedEncodingException &#123;
        // 用指定编码转换String为byte[]:
        return s.getBytes(&quot;GBK&quot;);
    &#125;
&#125;</code></pre>
<blockquote>
<p>可见，只要是方法声明的Checked Exception，不在调用层捕获，也必须在更高的调用层捕获。所有未捕获的异常，最终也必须在main()方法中捕获，不会出现漏写try的情况。这是由编译器保证的。<strong>main()方法也是最后捕获Exception的机会</strong></p>
</blockquote>
<p>如果是测试代码，上面的写法就略显麻烦。如果不想写任何try代码，可以直接把main()方法定义为throws Exception：</p>
<pre><code class="highlight plaintext">import java.io.UnsupportedEncodingException;
import java.util.Arrays;
public class Main &#123;
    public static void main(String[] args) throws Exception &#123;
        byte[] bs = toGBK(&quot;中文&quot;);
        System.out.println(Arrays.toString(bs));
    &#125;

    static byte[] toGBK(String s) throws UnsupportedEncodingException &#123;
        // 用指定编码转换String为byte[]:
        return s.getBytes(&quot;GBK&quot;);
    &#125;
&#125;</code></pre>
<blockquote>
<p>因为main()方法声明了可能抛出Exception，也就声明了可能抛出所有的Exception，因此在内部就无需捕获了。代价就是一旦发生异常，程序会立刻退出。</p>
</blockquote>
<p>还有一些童鞋喜欢在toGBK()内部“消化”异常：</p>
<pre><code class="highlight plaintext">static byte[] toGBK(String s) &#123;
    try &#123;
        return s.getBytes(&quot;GBK&quot;);
    &#125; catch (UnsupportedEncodingException e) &#123;
        // 什么也不干
    &#125;
    return null;
&#125;</code></pre>
<p>这种捕获后不处理的方式是非常不好的，即使真的什么也做不了，也要先把异常记录下来：</p>
<pre><code class="highlight plaintext">static byte[] toGBK(String s) &#123;
    try &#123;
        return s.getBytes(&quot;GBK&quot;);
    &#125; catch (UnsupportedEncodingException e) &#123;
        // 先记下来再说:
        e.printStackTrace();
    &#125;
    return null;
&#125;</code></pre>
<blockquote>
<p>所有异常都可以调用printStackTrace()方法打印异常栈，这是一个简单有用的快速打印异常的方法。</p>
</blockquote>
<h3 id="捕获异常"><a class="markdownIt-Anchor" href="#捕获异常"></a> 捕获异常</h3>
<p>在Java中，凡是可能抛出异常的语句，都可以用try … catch捕获。把可能发生异常的语句放在try { … }中，然后使用catch捕获对应的Exception及其子类。</p>
<hr />
<p><strong>多catch语句</strong></p>
<p>可以使用多个catch语句，每个catch分别捕获对应的Exception及其子类。JVM在捕获到异常后，会从上到下匹配catch语句，匹配到某个catch后，执行catch代码块，然后不再继续匹配。</p>
<p>简单地说就是：多个catch语句只有一个能被执行。例如：</p>
<pre><code class="highlight plaintext">public static void main(String[] args) &#123;
    try &#123;
        process1();
        process2();
        process3();
    &#125; catch (IOException e) &#123;
        System.out.println(e);
    &#125; catch (NumberFormatException e) &#123;
        System.out.println(e);
    &#125;
&#125;</code></pre>
<p>存在多个catch的时候，catch的顺序非常重要：子类必须写在前面。例如：</p>
<pre><code class="highlight plaintext">public static void main(String[] args) &#123;
    try &#123;
        process1();
        process2();
        process3();
    &#125; catch (IOException e) &#123;
        System.out.println(&quot;IO error&quot;);
    &#125; catch (UnsupportedEncodingException e) &#123; // 永远捕获不到
        System.out.println(&quot;Bad encoding&quot;);
    &#125;
&#125;</code></pre>
<blockquote>
<p>对于上面的代码，UnsupportedEncodingException异常是永远捕获不到的，因为它是IOException的子类。当抛出UnsupportedEncodingException异常时，会被catch (IOException e) { … }捕获并执行。</p>
</blockquote>
<blockquote>
<p>因此，正确的写法是把子类放到前面：</p>
</blockquote>
<hr />
<p><strong>finally语句</strong></p>
<p>无论是否有异常发生，如果我们都希望执行一些语句，例如清理工作，怎么写？</p>
<pre><code class="highlight plaintext">public static void main(String[] args) &#123;
    try &#123;
        process1();
        process2();
        process3();
    &#125; catch (UnsupportedEncodingException e) &#123;
        System.out.println(&quot;Bad encoding&quot;);
    &#125; catch (IOException e) &#123;
        System.out.println(&quot;IO error&quot;);
    &#125; finally &#123;
        System.out.println(&quot;END&quot;);
    &#125;
&#125;</code></pre>
<p>注意finally有几个特点：</p>
<ul>
<li>finally语句不是必须的，可写可不写；</li>
<li>finally总是最后执行。</li>
</ul>
<p>如果没有发生异常，就正常执行try { … }语句块，然后执行finally。如果发生了异常，就中断执行try { … }语句块，然后跳转执行匹配的catch语句块，最后执行finally</p>
<p>可见，finally是用来保证一些代码必须执行的。</p>
<p>某些情况下，可以没有catch，只使用try … finally结构。例如：</p>
<pre><code class="highlight plaintext">void process(String file) throws IOException &#123;
    try &#123;
        ...
    &#125; finally &#123;
        System.out.println(&quot;END&quot;);
    &#125;
&#125;</code></pre>
<blockquote>
<p>因为方法声明了可能抛出的异常，所以可以不写catch。</p>
</blockquote>
<hr />
<p><strong>捕获多种异常</strong></p>
<p>如果某些异常的处理逻辑相同，但是异常本身不存在继承关系，那么就得编写多条catch子句：</p>
<pre><code class="highlight plaintext">public static void main(String[] args) &#123;
    try &#123;
        process1();
        process2();
        process3();
    &#125; catch (IOException e) &#123;
        System.out.println(&quot;Bad input&quot;);
    &#125; catch (NumberFormatException e) &#123;
        System.out.println(&quot;Bad input&quot;);
    &#125; catch (Exception e) &#123;
        System.out.println(&quot;Unknown error&quot;);
    &#125;
&#125;</code></pre>
<p>因为处理IOException和NumberFormatException的代码是相同的，所以我们可以把它两用|合并到一起：</p>
<pre><code class="highlight plaintext">public static void main(String[] args) &#123;
    try &#123;
        process1();
        process2();
        process3();
    &#125; catch (IOException | NumberFormatException e) &#123; // IOException或NumberFormatException
        System.out.println(&quot;Bad input&quot;);
    &#125; catch (Exception e) &#123;
        System.out.println(&quot;Unknown error&quot;);
    &#125;
&#125;</code></pre>
<h3 id="抛出异常"><a class="markdownIt-Anchor" href="#抛出异常"></a> 抛出异常</h3>
<p><strong>异常的传播</strong></p>
<p>当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个try … catch被捕获为止：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        try &#123;
            process1();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    static void process1() &#123;
        process2();
    &#125;

    static void process2() &#123;
        Integer.parseInt(null); // 会抛出NumberFormatException
    &#125;
&#125;</code></pre>
<p>通过printStackTrace()可以打印出方法的调用栈，类似：</p>
<pre><code class="highlight plaintext">java.lang.NumberFormatException: null
    at java.base/java.lang.Integer.parseInt(Integer.java:614)
    at java.base/java.lang.Integer.parseInt(Integer.java:770)
    at Main.process2(Main.java:16)
    at Main.process1(Main.java:12)
    at Main.main(Main.java:5)</code></pre>
<p>printStackTrace()对于调试错误非常有用，上述信息表示：NumberFormatException是在java.lang.Integer.parseInt方法中被抛出的，调用层次从上到下依次是：</p>
<ol>
<li>main()调用process1()；</li>
<li>process1()调用process2()；</li>
<li>process2()调用Integer.parseInt(String)；</li>
<li>Integer.parseInt(String)调用Integer.parseInt(String, int)</li>
</ol>
<p>查看Integer.java源码可知，抛出异常的方法代码如下：</p>
<pre><code class="highlight plaintext">public static int parseInt(String s, int radix) throws NumberFormatException &#123;
    if (s == null) &#123;
        throw new NumberFormatException(&quot;null&quot;);
    &#125;
    ...
&#125;</code></pre>
<blockquote>
<p>并且，每层调用均给出了源代码的行号，可直接定位</p>
</blockquote>
<hr />
<p><strong>抛出异常</strong></p>
<p>当发生错误时，例如，用户输入了非法的字符，我们就可以抛出异常。</p>
<p>如何抛出异常？参考Integer.parseInt()方法，抛出异常分两步：</p>
<ul>
<li>创建某个Exception的实例；</li>
<li>用throw语句抛出。</li>
</ul>
<pre><code class="highlight plaintext">void process2(String s) &#123;
    if (s==null) &#123;
        throw new NullPointerException();
    &#125;
&#125;</code></pre>
<p>如果一个方法捕获了某个异常后，又在catch子句中抛出新的异常，就相当于把抛出的异常类型“转换”了：</p>
<pre><code class="highlight plaintext">void process1(String s) &#123;
    try &#123;
        process2();
    &#125; catch (NullPointerException e) &#123;
        throw new IllegalArgumentException();
    &#125;
&#125;

void process2(String s) &#123;
    if (s==null) &#123;
        throw new NullPointerException();
    &#125;
&#125;</code></pre>
<blockquote>
<p>当process2()抛出NullPointerException后，被process1()捕获，然后抛出IllegalArgumentException()</p>
</blockquote>
<p>如果在main()中捕获IllegalArgumentException，我们看看打印的异常栈：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        try &#123;
            process1();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    static void process1() &#123;
        try &#123;
            process2();
        &#125; catch (NullPointerException e) &#123;
            throw new IllegalArgumentException();
        &#125;
    &#125;

    static void process2() &#123;
        throw new NullPointerException();
    &#125;
&#125;</code></pre>
<p>打印出的异常栈类似：</p>
<pre><code class="highlight plaintext">java.lang.IllegalArgumentException
    at Main.process1(Main.java:15)
    at Main.main(Main.java:5)</code></pre>
<blockquote>
<p>这说明新的异常丢失了原始异常信息，我们已经看不到原始异常NullPointerException的信息了</p>
</blockquote>
<p>为了能追踪到完整的异常栈，在构造异常的时候，把原始的Exception实例传进去，新的Exception就可以持有原始Exception信息。对上述代码改进如下：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        try &#123;
            process1();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    static void process1() &#123;
        try &#123;
            process2();
        &#125; catch (NullPointerException e) &#123;
            throw new IllegalArgumentException(e);
        &#125;
    &#125;

    static void process2() &#123;
        throw new NullPointerException();
    &#125;
&#125;</code></pre>
<p>运行上述代码，打印出的异常栈类似：</p>
<pre><code class="highlight plaintext">java.lang.IllegalArgumentException: java.lang.NullPointerException
    at Main.process1(Main.java:15)
    at Main.main(Main.java:5)Caused by: java.lang.NullPointerException
    at Main.process2(Main.java:20)
    at Main.process1(Main.java:13)</code></pre>
<blockquote>
<p>注意到Caused by: Xxx，说明捕获的IllegalArgumentException并不是造成问题的根源，根源在于NullPointerException，是在Main.process2()方法抛出的</p>
</blockquote>
<p>在代码中获取原始异常可以使用Throwable.getCause()方法。如果返回null，说明已经是“根异常”了。</p>
<p>有了完整的异常栈的信息，我们才能快速定位并修复代码的问题。</p>
<p>如果我们在try或者catch语句块中抛出异常，finally语句是否会执行？例如：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        try &#123;
            Integer.parseInt(&quot;abc&quot;);
        &#125; catch (Exception e) &#123;
            System.out.println(&quot;catched&quot;);
            throw new RuntimeException(e);
        &#125; finally &#123;
            System.out.println(&quot;finally&quot;);
        &#125;
    &#125;
&#125;</code></pre>
<p>上述代码执行结果如下：</p>
<pre><code class="highlight plaintext">catched
finally
Exception in thread &quot;main&quot; java.lang.RuntimeException: java.lang.NumberFormatException: For input string: &quot;abc&quot;
    at Main.main(Main.java:8)
Caused by: java.lang.NumberFormatException: For input string: &quot;abc&quot;</code></pre>
<p>第一行打印了catched，说明进入了catch语句块。第二行打印了finally，说明执行了finally语句块。</p>
<p>因此，在catch中抛出异常，不会影响finally的执行。JVM会先执行finally，然后抛出异常。</p>
<hr />
<p><strong>异常屏蔽</strong></p>
<p>如果在执行finally语句时抛出异常，那么，catch语句的异常还能否继续抛出？例如：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        try &#123;
            Integer.parseInt(&quot;abc&quot;);
        &#125; catch (Exception e) &#123;
            System.out.println(&quot;catched&quot;);
            throw new RuntimeException(e);
        &#125; finally &#123;
            System.out.println(&quot;finally&quot;);
            throw new IllegalArgumentException();
        &#125;
    &#125;
&#125;</code></pre>
<p>执行上述代码，发现异常信息如下：</p>
<pre><code class="highlight plaintext">catched
finally
Exception in thread &quot;main&quot; java.lang.IllegalArgumentException
    at Main.main(Main.java:11)</code></pre>
<p>这说明finally抛出异常后，原来在catch中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）</p>
<p>在极少数的情况下，我们需要获知所有的异常。如何保存所有的异常信息？方法是先用origin变量保存原始异常，然后调用Throwable.addSuppressed()，把原始异常添加进来，最后在finally抛出：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) throws Exception &#123;
        Exception origin = null;
        try &#123;
            System.out.println(Integer.parseInt(&quot;abc&quot;));
        &#125; catch (Exception e) &#123;
            origin = e;
            throw e;
        &#125; finally &#123;
            Exception e = new IllegalArgumentException();
            if (origin != null) &#123;
                e.addSuppressed(origin);
            &#125;
            throw e;
        &#125;
    &#125;
&#125;</code></pre>
<blockquote>
<p>当catch和finally都抛出了异常时，虽然catch的异常被屏蔽了，但是，finally抛出的异常仍然包含了它：</p>
</blockquote>
<pre><code class="highlight plaintext">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException
    at Main.main(Main.java:11)
Suppressed: java.lang.NumberFormatException: For input string: &quot;abc&quot;
    at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
    at java.base/java.lang.Integer.parseInt(Integer.java:652)
    at java.base/java.lang.Integer.parseInt(Integer.java:770)
    at Main.main(Main.java:6)</code></pre>
<blockquote>
<p>通过Throwable.getSuppressed()可以获取所有的Suppressed Exception。绝大多数情况下，在finally中不要抛出异常。因此，我们通常不需要关心Suppressed Exception。</p>
</blockquote>
<h3 id="自定义异常"><a class="markdownIt-Anchor" href="#自定义异常"></a> 自定义异常</h3>
<p>Java标准库定义的常用异常包括：</p>
<p>当我们在代码中需要抛出异常时，尽量使用JDK已定义的异常类型。例如，参数检查不合法，应该抛出IllegalArgumentException：</p>
<pre><code class="highlight plaintext">static void process1(int age) &#123;
    if (age &lt;= 0) &#123;
        throw new IllegalArgumentException();
    &#125;
&#125;</code></pre>
<p>在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。</p>
<p>一个常见的做法是自定义一个BaseException作为“根异常”，然后，派生出各种业务类型的异常。</p>
<p>BaseException需要从一个适合的Exception派生，通常建议从RuntimeException派生：</p>
<pre><code class="highlight plaintext">public class BaseException extends RuntimeException &#123;
&#125;</code></pre>
<p>其他业务类型的异常就可以从BaseException派生：</p>
<pre><code class="highlight plaintext">public class UserNotFoundException extends BaseException &#123;
&#125;

public class LoginFailedException extends BaseException &#123;
&#125;

...</code></pre>
<p>自定义的BaseException应该提供多个构造方法：</p>
<pre><code class="highlight plaintext">public class BaseException extends RuntimeException &#123;
    public BaseException() &#123;
        super();
    &#125;

    public BaseException(String message, Throwable cause) &#123;
        super(message, cause);
    &#125;

    public BaseException(String message) &#123;
        super(message);
    &#125;

    public BaseException(Throwable cause) &#123;
        super(cause);
    &#125;
&#125;</code></pre>
<blockquote>
<p>上述构造方法实际上都是原样照抄RuntimeException。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法</p>
</blockquote>
<h3 id="使用jdk-logging"><a class="markdownIt-Anchor" href="#使用jdk-logging"></a> 使用JDK Logging</h3>
<p>在编写程序的过程中，发现程序运行结果与预期不符，怎么办？当然是用System.out.println()打印出执行过程中的某些变量，观察每一步的结果与代码逻辑是否符合，然后有针对性地修改代码。</p>
<ul>
<li>代码改好了怎么办？当然是删除没有用的System.out.println()语句了。</li>
<li>如果改代码又改出问题怎么办？再加上System.out.println()。</li>
<li>反复这么搞几次，很快大家就发现使用System.out.println()非常麻烦。怎么办？</li>
</ul>
<p>解决方法是使用日志。</p>
<p>那什么是日志？日志就是Logging，它的目的是为了取代System.out.println()。</p>
<p>输出日志，而不是用System.out.println()，有以下几个好处：</p>
<ul>
<li>可以设置输出样式，避免自己每次都写&quot;ERROR: &quot; + var；</li>
<li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志；</li>
<li>可以被重定向到文件，这样可以在程序运行结束后查看日志；</li>
<li>可以按包名控制日志级别，只输出某些包打的日志；</li>
<li>可以……</li>
</ul>
<p>因为Java标准库内置了日志包java.util.logging，我们可以直接用。先看一个简单的例子：</p>
<pre><code class="highlight plaintext">// logging
import java.util.logging.Level;
import java.util.logging.Logger;
public class Hello &#123;
    public static void main(String[] args) &#123;
        Logger logger = Logger.getGlobal();
        logger.info(&quot;start process...&quot;);
        logger.warning(&quot;memory is running out...&quot;);
        logger.fine(&quot;ignored.&quot;);
        logger.severe(&quot;process will be terminated...&quot;);
    &#125;
&#125;</code></pre>
<p>运行上述代码，得到类似如下的输出：</p>
<pre><code class="highlight plaintext">Mar 02, 2019 6:32:13 PM Hello main
INFO: start process...
Mar 02, 2019 6:32:13 PM Hello main
WARNING: memory is running out...
Mar 02, 2019 6:32:13 PM Hello main
SEVERE: process will be terminated...</code></pre>
<blockquote>
<p>对比可见，使用日志最大的好处是，它自动打印了时间、调用类、调用方法等很多有用的信息。</p>
</blockquote>
<p>再仔细观察发现，4条日志，只打印了3条，logger.fine()没有打印。这是因为，日志的输出可以设定级别。JDK的Logging定义了7个日志级别，从严重到普通：</p>
<ul>
<li>SEVERE</li>
<li>WARNING</li>
<li>INFO</li>
<li>CONFIG</li>
<li>FINE</li>
<li>FINER</li>
<li>FINEST</li>
</ul>
<p>因为默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出</p>
<p>使用Java标准库内置的Logging有以下局限：</p>
<ul>
<li>Logging系统在JVM启动时读取配置文件并完成初始化，一旦开始运行main()方法，就无法修改配置；</li>
<li>配置不太方便，需要在JVM启动时传递参数-Djava.util.logging.config.file=<config-file-name></li>
</ul>
<blockquote>
<p>因此，Java标准库内置的Logging使用并不是非常广泛。更方便的日志系统我们稍后介绍。</p>
</blockquote>
<h3 id="使用commons-logging"><a class="markdownIt-Anchor" href="#使用commons-logging"></a> 使用Commons Logging</h3>
<p>和Java标准库提供的日志不同，Commons Logging是一个第三方日志库，它是由Apache创建的日志模块。</p>
<p>Commons Logging的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Loggin自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging</p>
<p>使用Commons Logging只需要和两个类打交道，并且只有两步：</p>
<ul>
<li>第一步，通过LogFactory获取Log类的实例；</li>
<li>第二步，使用Log实例的方法打日志。</li>
</ul>
<pre><code class="highlight plaintext">import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public class Main &#123;
    public static void main(String[] args) &#123;
        Log log = LogFactory.getLog(Main.class);
        log.info(&quot;start...&quot;);
        log.warn(&quot;end.&quot;);
    &#125;
&#125;</code></pre>
<p>运行上述代码，肯定会得到编译错误，类似error: package org.apache.commons.logging does not exist（找不到org.apache.commons.logging这个包）。因为Commons Logging是一个第三方提供的库，所以，必须先把它下载下来。下载后，解压，找到commons-logging-1.2.jar这个文件，再把Java源码Main.java放到一个目录下，例如work目录：</p>
<p>然后用javac编译Main.java，编译的时候要指定classpath，不然编译器找不到我们引用的org.apache.commons.logging包。编译命令如下：</p>
<pre><code class="highlight plaintext">javac -cp commons-logging-1.2.jar Main.java</code></pre>
<p>如果编译成功，那么当前目录下就会多出一个Main.class文件：</p>
<p>现在可以执行这个Main.class，使用java命令，也必须指定classpath，命令如下</p>
<pre><code class="highlight plaintext">java -cp .;commons-logging-1.2.jar Main</code></pre>
<p>注意到传入的classpath有两部分：一个是.，一个是commons-logging-1.2.jar，用;分割。.表示当前目录，如果没有这个.，JVM不会在当前目录搜索Main.class，就会报错。</p>
<p>如果在Linux或macOS下运行，注意classpath的分隔符不是; 而是:</p>
<pre><code class="highlight plaintext">java -cp .:commons-logging-1.2.jar Main</code></pre>
<p>运行结果如下：</p>
<pre><code class="highlight plaintext">Mar 02, 2019 7:15:31 PM Main mainINFO: start...
Mar 02, 2019 7:15:31 PM Main mainWARNING: end.</code></pre>
<p>Commons Logging定义了6个日志级别：</p>
<ul>
<li>FATAL</li>
<li>ERROR</li>
<li>WARNING</li>
<li>INFO</li>
<li>DEBUG</li>
<li>TRACE</li>
</ul>
<p>默认级别是INFO。</p>
<p>使用Commons Logging时，如果在静态方法中引用Log，通常直接定义一个静态类型变量：</p>
<pre><code class="highlight plaintext">// 在静态方法中引用Log:public class Main &#123;
    static final Log log = LogFactory.getLog(Main.class);

    static void foo() &#123;
        log.info(&quot;foo&quot;);
    &#125;
&#125;</code></pre>
<p>在实例方法中引用Log，通常定义一个实例变量：</p>
<pre><code class="highlight plaintext">// 在实例方法中引用Log:
public class Person &#123;
    protected final Log log = LogFactory.getLog(getClass());

    void foo() &#123;
        log.info(&quot;foo&quot;);
    &#125;
&#125;</code></pre>
<p>注意到实例变量log的获取方式是LogFactory.getLog(getClass())，虽然也可以用LogFactory.getLog(Person.class)，但是前一种方式有个非常大的好处，就是子类可以直接使用该log实例。例如：</p>
<pre><code class="highlight plaintext">// 在子类中使用父类实例化的log:
public class Student extends Person &#123;
    void bar() &#123;
        log.info(&quot;bar&quot;);
    &#125;
&#125;</code></pre>
<p>由于Java类的动态特性，子类获取的log字段实际上相当于LogFactory.getLog(Student.class)，但却是从父类继承而来，并且无需改动代码</p>
<p>此外，Commons Logging的日志方法，例如info()，除了标准的info(String)外，还提供了一个非常有用的重载方法：info(String, Throwable)，这使得记录异常更加简单：</p>
<pre><code class="highlight plaintext">try &#123;
    ...
&#125; catch (Exception e) &#123;
    log.error(&quot;got exception!&quot;, e);
&#125;</code></pre>
<h3 id="使用log4j"><a class="markdownIt-Anchor" href="#使用log4j"></a> 使用Log4j</h3>
<p>前面介绍了Commons Logging，可以作为“日志接口”来使用。而真正的“日志实现”可以使用Log4j。</p>
<p>Log4j是一种非常流行的日志框架，最新版本是2.x。</p>
<p>Log4j是一个组件化设计的日志系统，它的架构大致如下：</p>
<p>当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地。例如：</p>
<ul>
<li>console：输出到屏幕；</li>
<li>file：输出到文件；</li>
<li>socket：通过网络输出到远程计算机；</li>
<li>jdbc：输出到数据库</li>
</ul>
<p>在输出日志的过程中，通过Filter来过滤哪些log需要被输出，哪些log不需要被输出。例如，仅输出ERROR级别的日志。</p>
<p>最后，通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。</p>
<p>上述结构虽然复杂，但我们在实际使用的时候，并不需要关心Log4j的API，而是通过配置文件来配置它。</p>
<p>以XML配置为例，使用Log4j的时候，我们把一个log4j2.xml的文件放到classpath下就可以让Log4j读取配置文件并按照我们的配置来输出日志。下面是一个配置文件的例子：</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration&gt;
	&lt;Properties&gt;
        &lt;!-- 定义日志格式 --&gt;
		&lt;Property name=&quot;log.pattern&quot;&gt;%d&#123;MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125;%n%msg%n%n&lt;/Property&gt;
        &lt;!-- 定义文件名变量 --&gt;
		&lt;Property name=&quot;file.err.filename&quot;&gt;log/err.log&lt;/Property&gt;
		&lt;Property name=&quot;file.err.pattern&quot;&gt;log/err.%i.log.gz&lt;/Property&gt;
	&lt;/Properties&gt;
    &lt;!-- 定义Appender，即目的地 --&gt;
	&lt;Appenders&gt;
        &lt;!-- 定义输出到屏幕 --&gt;
		&lt;Console name=&quot;console&quot; target=&quot;SYSTEM_OUT&quot;&gt;
            &lt;!-- 日志格式引用上面定义的log.pattern --&gt;
			&lt;PatternLayout pattern=&quot;$&#123;log.pattern&#125;&quot; /&gt;
		&lt;/Console&gt;
        &lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;
		&lt;RollingFile name=&quot;err&quot; bufferedIO=&quot;true&quot; fileName=&quot;$&#123;file.err.filename&#125;&quot; filePattern=&quot;$&#123;file.err.pattern&#125;&quot;&gt;
			&lt;PatternLayout pattern=&quot;$&#123;log.pattern&#125;&quot; /&gt;
			&lt;Policies&gt;
                &lt;!-- 根据文件大小自动切割日志 --&gt;
				&lt;SizeBasedTriggeringPolicy size=&quot;1 MB&quot; /&gt;
			&lt;/Policies&gt;
            &lt;!-- 保留最近10份 --&gt;
			&lt;DefaultRolloverStrategy max=&quot;10&quot; /&gt;
		&lt;/RollingFile&gt;
	&lt;/Appenders&gt;
	&lt;Loggers&gt;
		&lt;Root level=&quot;info&quot;&gt;
            &lt;!-- 对info级别的日志，输出到console --&gt;
			&lt;AppenderRef ref=&quot;console&quot; level=&quot;info&quot; /&gt;
            &lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;
			&lt;AppenderRef ref=&quot;err&quot; level=&quot;error&quot; /&gt;
		&lt;/Root&gt;
	&lt;/Loggers&gt;
&lt;/Configuration&gt;</code></pre>
<p>虽然配置Log4j比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是INFO级别的日志，会自动输出到屏幕，而ERROR级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j就会自动切割新的日志文件，并最多保留10份。</p>
<p>有了配置文件还不够，因为Log4j也是一个第三方库，我们需要从这里下载Log4j，解压后，把以下3个jar包放到classpath中：</p>
<ul>
<li>log4j-api-2.x.jar</li>
<li>log4j-core-2.x.jar</li>
<li>log4j-jcl-2.x.jar</li>
</ul>
<p>因为Commons Logging会自动发现并使用Log4j，所以，把上一节下载的commons-logging-1.2.jar也放到classpath中。</p>
<p>要打印日志，只需要按Commons Logging的写法写，不需要改动任何代码，就可以得到Log4j的日志输出，类似：</p>
<pre><code class="highlight plaintext">03-03 12:09:45.880 [main] INFO  com.itranswarp.learnjava.MainStart process...</code></pre>
<hr />
<p><strong>最佳实践</strong></p>
<p>在开发阶段，始终使用Commons Logging接口来写入日志，并且开发阶段无需引入Log4j。如果需要把日志写入文件， 只需要把正确的配置文件和Log4j相关的jar包放入classpath，就可以自动把日志切换成使用Log4j写入，无需修改任何代码。</p>
<h3 id="使用slf4j和logback"><a class="markdownIt-Anchor" href="#使用slf4j和logback"></a> 使用SLF4J和Logback</h3>
<p>前面介绍了Commons Logging和Log4j这一对好基友，它们一个负责充当日志API，一个负责实现日志底层，搭配使用非常便于开发。</p>
<p>有的童鞋可能还听说过SLF4J和Logback。这两个东东看上去也像日志，它们又是啥？</p>
<p>其实SLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现。</p>
<p>为什么有了Commons Logging和Log4j，又会蹦出来SLF4J和Logback？</p>
<p>这是因为Java有着非常悠久的开源历史，不但OpenJDK本身是开源的，而且我们用到的第三方库，几乎全部都是开源的。</p>
<p>开源生态丰富的一个特定就是，同一个功能，可以找到若干种互相竞争的开源库。</p>
<p>因为对Commons Logging的接口不满意，有人就搞了SLF4J。因为对Log4j的性能不满意，有人就搞了Logback。</p>
<p>我们先来看看SLF4J对Commons Logging的接口有何改进。在Commons Logging中，我们要打印日志，有时候得这么写：</p>
<pre><code class="highlight plaintext">int score = 99;
p.setScore(score);
log.info(&quot;Set score &quot; + score + &quot; for Person &quot; + p.getName() + &quot; ok.&quot;);</code></pre>
<p>拼字符串是一个非常麻烦的事情，所以SLF4J的日志接口改进成这样了：</p>
<pre><code class="highlight plaintext">int score = 99;
p.setScore(score);
logger.info(&quot;Set score &#123;&#125; for Person &#123;&#125; ok.&quot;, score, p.getName());</code></pre>
<blockquote>
<p>我们靠猜也能猜出来，SLF4J的日志接口传入的是一个带占位符的字符串，用后面的变量自动替换占位符，所以看起来更加自然。</p>
</blockquote>
<p>如何使用SLF4J？它的接口实际上和Commons Logging几乎一模一样：</p>
<pre><code class="highlight plaintext">import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

class Main &#123;
    final Logger logger = LoggerFactory.getLogger(getClass());
&#125;</code></pre>
<p>对比一下Commons Logging和SLF4J的接口：</p>
<table>
<thead>
<tr>
<th>Commons Logging</th>
<th>SLF4J</th>
</tr>
</thead>
<tbody>
<tr>
<td>org.apache.commons.logging.Log</td>
<td>org.slf4j.Logger</td>
</tr>
<tr>
<td>org.apache.commons.logging.LogFactory</td>
<td>org.slf4j.LoggerFactory</td>
</tr>
</tbody>
</table>
<p>不同之处就是Log变成了Logger，LogFactory变成了LoggerFactory。</p>
<p>使用SLF4J和Logback和前面讲到的使用Commons Logging加Log4j是类似的，先分别下载SLF4J和Logback，然后把以下jar包放到classpath下：</p>
<ul>
<li>slf4j-api-1.7.x.jar</li>
<li>logback-classic-1.2.x.jar</li>
<li>logback-core-1.2.x.jar</li>
</ul>
<p>然后使用SLF4J的Logger和LoggerFactory即可。和Log4j类似，我们仍然需要一个Logback的配置文件，把logback.xml放到classpath下，配置如下：</p>
<pre><code class="highlight plaintext">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt;

        &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
                &lt;encoder&gt;
                        &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;
                &lt;/encoder&gt;
        &lt;/appender&gt;

        &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
                &lt;encoder&gt;
                        &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;
                        &lt;charset&gt;utf-8&lt;/charset&gt;
                &lt;/encoder&gt;
                &lt;file&gt;log/output.log&lt;/file&gt;
                &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;&gt;
                        &lt;fileNamePattern&gt;log/output.log.%i&lt;/fileNamePattern&gt;
                &lt;/rollingPolicy&gt;
                &lt;triggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;
                        &lt;MaxFileSize&gt;1MB&lt;/MaxFileSize&gt;
                &lt;/triggeringPolicy&gt;
        &lt;/appender&gt;

        &lt;root level=&quot;INFO&quot;&gt;
                &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;
                &lt;appender-ref ref=&quot;FILE&quot; /&gt;
        &lt;/root&gt;&lt;/configuration&gt;</code></pre>
<p>运行即可获得类似如下的输出：</p>
<pre><code class="highlight plaintext">13:15:25.328 [main] INFO  com.itranswarp.learnjava.Main - Start process...</code></pre>
<blockquote>
<p>从目前的趋势来看，越来越多的开源项目从Commons Logging加Log4j转向了SLF4J加Logback。</p>
</blockquote>
<h2 id="注解"><a class="markdownIt-Anchor" href="#注解"></a> 注解</h2>
<p>什么是注解（Annotation）？注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”：</p>
<pre><code class="highlight plaintext">// this is a component:@Resource(&quot;hello&quot;)
public class Hello &#123;
    @Inject
    int n;

    @PostConstruct
    public void hello(@Param String name) &#123;
        System.out.println(name);
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Hello&quot;;
    &#125;
&#125;</code></pre>
<blockquote>
<p>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</p>
</blockquote>
<h3 id="使用注解"><a class="markdownIt-Anchor" href="#使用注解"></a> 使用注解</h3>
<p>从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。</p>
<p>Java的注解可以分为三类：</p>
<ul>
<li><strong>第一类是由编译器使用的注解</strong>（这类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了），例如：
<ul>
<li>@Override：让编译器检查该方法是否正确地实现了覆写；</li>
<li>@SuppressWarnings：告诉编译器忽略此处代码产生的警告。</li>
</ul>
</li>
<li><strong>第二类是由工具处理.class文件使用的注解</strong>，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入.class文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</li>
<li><strong>第三类是在程序运行期能够读取的注解</strong>，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了@PostConstruct的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</li>
</ul>
<p>定义一个注解时，还可以定义配置参数。配置参数可以包括：</p>
<ul>
<li>所有基本类型；</li>
<li>String；</li>
<li>枚举类型；</li>
<li>基本类型、String以及枚举的数组。</li>
</ul>
<p>因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。</p>
<p>注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。</p>
<p>此外，大部分注解会有一个名为value的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。</p>
<p>如果只写注解，相当于全部使用默认值。</p>
<p>举个栗子，对以下代码：</p>
<pre><code class="highlight plaintext">public class Hello &#123;
    @Check(min=0, max=100, value=55)
    public int n;

    @Check(value=99)
    public int p;

    @Check(99) // @Check(value=99)
    public int x;

    @Check
    public int y;
&#125;</code></pre>
<p>@Check就是一个注解。第一个@Check(min=0, max=100, value=55)明确定义了三个参数，第二个@Check(value=99)只定义了一个value参数，它实际上和@Check(99)是完全一样的。最后一个@Check表示所有参数都使用默认值。</p>
<h3 id="定义注解"><a class="markdownIt-Anchor" href="#定义注解"></a> 定义注解</h3>
<p>Java语言使用@interface语法来定义注解（Annotation），它的格式如下：</p>
<pre><code class="highlight plaintext">public @interface Report &#123;
    int type() default 0;
    String level() default &quot;info&quot;;
    String value() default &quot;&quot;;
&#125;</code></pre>
<p>注解的参数类似无参数方法，可以用default设定一个默认值（强烈推荐）。最常用的参数应当命名为value。</p>
<h4 id="元注解"><a class="markdownIt-Anchor" href="#元注解"></a> 元注解</h4>
<p>有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解</p>
<p><strong>@Target</strong></p>
<p>最常用的元注解是@Target。使用@Target可以定义Annotation能够被应用于源码的哪些位置：</p>
<ul>
<li>类或接口：ElementType.TYPE；</li>
<li>字段：ElementType.FIELD；</li>
<li>方法：ElementType.METHOD；</li>
<li>构造方法：ElementType.CONSTRUCTOR；</li>
<li>方法参数：ElementType.PARAMETER。</li>
</ul>
<p>例如，定义注解@Report可用在方法上，我们必须添加一个@Target(ElementType.METHOD)：</p>
<pre><code class="highlight plaintext">@Target(ElementType.METHOD)
public @interface Report &#123;
    int type() default 0;
    String level() default &quot;info&quot;;
    String value() default &quot;&quot;;
&#125;</code></pre>
<p>定义注解@Report可用在方法或字段上，可以把@Target注解参数变为数组{ ElementType.METHOD, ElementType.FIELD }：</p>
<pre><code class="highlight plaintext">@Target(&#123;
    ElementType.METHOD,
    ElementType.FIELD
&#125;)
public @interface Report &#123;
    ...
&#125;</code></pre>
<blockquote>
<p>实际上@Target定义的value是ElementType[]数组，只有一个元素时，可以省略数组的写法。</p>
</blockquote>
<hr />
<p><strong>@Retention</strong></p>
<p>另一个重要的元注解@Retention定义了Annotation的生命周期：</p>
<ul>
<li>仅编译期：RetentionPolicy.SOURCE；</li>
<li>仅class文件：RetentionPolicy.CLASS；</li>
<li>运行期：RetentionPolicy.RUNTIME。</li>
</ul>
<p>如果@Retention不存在，则该Annotation默认为CLASS。因为通常我们自定义的Annotation都是RUNTIME，所以，务必要加上@Retention(RetentionPolicy.RUNTIME)这个元注解：</p>
<pre><code class="highlight plaintext">@Retention(RetentionPolicy.RUNTIME)
public @interface Report &#123;
    int type() default 0;
    String level() default &quot;info&quot;;
    String value() default &quot;&quot;;
&#125;</code></pre>
<hr />
<p><strong>@Repeatable</strong></p>
<p>使用@Repeatable这个元注解可以定义Annotation是否可重复。这个注解应用不是特别广泛。</p>
<pre><code class="highlight plaintext">@Repeatable@Target(ElementType.TYPE)
public @interface Report &#123;
    int type() default 0;
    String level() default &quot;info&quot;;
    String value() default &quot;&quot;;
&#125;</code></pre>
<p>经过@Repeatable修饰后，在某个类型声明处，就可以添加多个@Report注解：</p>
<pre><code class="highlight plaintext">@Report(type=1, level=&quot;debug&quot;)
@Report(type=2, level=&quot;warning&quot;)
public class Hello &#123;
&#125;</code></pre>
<p><strong>@Inherited</strong></p>
<p>使用@Inherited定义子类是否可继承父类定义的Annotation。@Inherited仅针对@Target(ElementType.TYPE)类型的annotation有效，并且仅针对class的继承，对interface的继承无效：</p>
<pre><code class="highlight plaintext">@Inherited@Target(ElementType.TYPE)
public @interface Report &#123;
    int type() default 0;
    String level() default &quot;info&quot;;
    String value() default &quot;&quot;;
&#125;</code></pre>
<p>在使用的时候，如果一个类用到了@Report：</p>
<pre><code class="highlight plaintext">@Report(type=1)
public class Person &#123;
&#125;</code></pre>
<p>则它的子类默认也定义了该注解：</p>
<pre><code class="highlight plaintext">public class Student extends Person &#123;
&#125;</code></pre>
<h4 id="定义annotation"><a class="markdownIt-Anchor" href="#定义annotation"></a> 定义Annotation</h4>
<p>我们总结一下定义Annotation的步骤：</p>
<p>第一步，用@interface定义注解：</p>
<pre><code class="highlight plaintext">public @interface Report &#123;
&#125;</code></pre>
<p>第二步，添加参数、默认值：</p>
<pre><code class="highlight plaintext">public @interface Report &#123;
    int type() default 0;
    String level() default &quot;info&quot;;
    String value() default &quot;&quot;;
&#125;</code></pre>
<p>把最常用的参数定义为value()，推荐所有参数都尽量设置默认值。</p>
<p>第三步，用元注解配置注解：</p>
<pre><code class="highlight plaintext">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Report &#123;
    int type() default 0;
    String level() default &quot;info&quot;;
    String value() default &quot;&quot;;
&#125;</code></pre>
<p>其中，必须设置@Target和@Retention，@Retention一般设置为RUNTIME，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写@Inherited和@Repeatable。</p>
<h3 id="处理注解"><a class="markdownIt-Anchor" href="#处理注解"></a> 处理注解</h3>
<p>Java的注解本身对代码逻辑没有任何影响。根据@Retention的配置：</p>
<ul>
<li>SOURCE类型的注解在编译期就被丢掉了；</li>
<li>CLASS类型的注解仅保存在class文件中，它们不会被加载进JVM；</li>
<li>RUNTIME类型的注解会被加载进JVM，并且在运行期可以被程序读取。</li>
</ul>
<p>如何使用注解完全由工具决定。SOURCE类型的注解主要由编译器使用，因此我们一般只使用，不编写。CLASS类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有RUNTIME类型的注解不但要使用，还经常需要编写。</p>
<p>因此，我们只讨论如何读取RUNTIME类型的注解。</p>
<p>因为注解定义后也是一种class，所有的注解都继承自java.lang.annotation.Annotation，因此，读取注解，需要使用反射API。</p>
<p>Java提供的使用反射API读取Annotation的方法包括：</p>
<p><strong>判断某个注解是否存在于Class、Field、Method或Constructor</strong>：</p>
<ul>
<li>Class.isAnnotationPresent(Class)</li>
<li>Field.isAnnotationPresent(Class)</li>
<li>Method.isAnnotationPresent(Class)</li>
<li>Constructor.isAnnotationPresent(Class)</li>
</ul>
<p>例如：</p>
<pre><code class="highlight plaintext">// 判断@Report是否存在于Person类:
Person.class.isAnnotationPresent(Report.class);</code></pre>
<p><strong>使用反射API读取Annotation</strong>：</p>
<ul>
<li>Class.getAnnotation(Class)</li>
<li>Field.getAnnotation(Class)</li>
<li>Method.getAnnotation(Class)</li>
<li>Constructor.getAnnotation(Class)</li>
</ul>
<p>例如：</p>
<pre><code class="highlight plaintext">// 获取Person定义的@Report注解:
Report report = Person.class.getAnnotation(Report.class);
int type = report.type();
String level = report.level();</code></pre>
<p>使用反射API读取Annotation有两种方法。</p>
<p>方法一是先判断Annotation是否存在，如果存在，就直接读取：</p>
<pre><code class="highlight plaintext">Class cls = Person.class;
if (cls.isAnnotationPresent(Report.class)) &#123;
    Report report = cls.getAnnotation(Report.class);
    ...
&#125;</code></pre>
<p>第二种方法是直接读取Annotation，如果Annotation不存在，将返回null：</p>
<pre><code class="highlight plaintext">Class cls = Person.class;
Report report = cls.getAnnotation(Report.class);
if (report != null) &#123;
   ...
&#125;</code></pre>
<p>读取方法、字段和构造方法的Annotation和Class类似。但要读取方法参数的Annotation就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。例如，对于以下方法定义的注解：</p>
<pre><code class="highlight plaintext">public void hello(@NotNull @Range(max=5) String name, @NotNull String prefix) &#123;
&#125;</code></pre>
<p>要读取方法参数的注解，我们先用反射获取Method实例，然后读取方法参数的所有注解：</p>
<pre><code class="highlight plaintext">// 获取Method实例:
Method m = ...
// 获取所有参数的Annotation:
Annotation[][] annos = m.getParameterAnnotations();
// 第一个参数（索引为0）的所有Annotation:
Annotation[] annosOfName = annos[0];
for (Annotation anno : annosOfName) &#123;
    if (anno instanceof Range) &#123; // @Range注解
        Range r = (Range) anno;
    &#125;
    if (anno instanceof NotNull) &#123; // @NotNull注解
        NotNull n = (NotNull) anno;
    &#125;
&#125;</code></pre>
<hr />
<p><strong>使用注解</strong></p>
<p>注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为@Test的方法。</p>
<p>我们来看一个@Range注解，我们希望用它来定义一个String字段的规则：字段长度满足@Range的参数定义：</p>
<pre><code class="highlight plaintext">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Range &#123;
    int min() default 0;
    int max() default 255;
&#125;</code></pre>
<p>在某个JavaBean中，我们可以使用该注解：</p>
<pre><code class="highlight plaintext">public class Person &#123;
    @Range(min=1, max=20)
    public String name;

    @Range(max=10)
    public String city;
&#125;</code></pre>
<p>但是，定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。这里，我们编写一个Person实例的检查方法，它可以检查Person实例的String字段长度是否满足@Range的定义：</p>
<pre><code class="highlight plaintext">void check(Person person) throws IllegalArgumentException, ReflectiveOperationException &#123;
    // 遍历所有Field:
    for (Field field : person.getClass().getFields()) &#123;
        // 获取Field定义的@Range:
        Range range = field.getAnnotation(Range.class);
        // 如果@Range存在:
        if (range != null) &#123;
            // 获取Field的值:
            Object value = field.get(person);
            // 如果值是String:
            if (value instanceof String) &#123;
                String s = (String) value;
                // 判断值是否满足@Range的min/max:
                if (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;
                    throw new IllegalArgumentException(&quot;Invalid field: &quot; + field.getName());
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>这样一来，我们通过@Range注解，配合check()方法，就可以完成Person实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。</p>
<h2 id="泛型"><a class="markdownIt-Anchor" href="#泛型"></a> 泛型</h2>
<h3 id="什么是泛型"><a class="markdownIt-Anchor" href="#什么是泛型"></a> 什么是泛型</h3>
<p>在讲解什么是泛型之前，我们先观察Java标准库提供的ArrayList，它可以看作“可变长度”的数组，因为用起来比数组更方便。</p>
<p>实际上ArrayList内部就是一个Object[]数组，配合存储一个当前分配的长度，就可以充当“可变数组”：</p>
<pre><code class="highlight plaintext">public class ArrayList &#123;
    private Object[] array;
    private int size;
    public void add(Object e) &#123;...&#125;
    public void remove(int index) &#123;...&#125;
    public Object get(int index) &#123;...&#125;
&#125;</code></pre>
<p>如果用上述ArrayList存储String类型，会有这么几个缺点：</p>
<ul>
<li>需要强制转型；</li>
<li>不方便，易出错。</li>
</ul>
<p>例如，代码必须这么写：</p>
<pre><code class="highlight plaintext">ArrayList list = new ArrayList();
list.add(&quot;Hello&quot;);
// 获取到Object，必须强制转型为String:
String first = (String) list.get(0);</code></pre>
<p>很容易出现ClassCastException，因为容易“误转型”：</p>
<pre><code class="highlight plaintext">list.add(new Integer(123));
// ERROR: ClassCastException:
String second = (String) list.get(1);</code></pre>
<p>要解决上述问题，我们可以为String单独编写一种ArrayList：</p>
<pre><code class="highlight plaintext">public class StringArrayList &#123;
    private String[] array;
    private int size;
    public void add(String e) &#123;...&#125;
    public void remove(int index) &#123;...&#125;
    public String get(int index) &#123;...&#125;
&#125;</code></pre>
<p>这样一来，存入的必须是String，取出的也一定是String，不需要强制转型，因为编译器会强制检查放入的类型：</p>
<pre><code class="highlight plaintext">StringArrayList list = new StringArrayList();
list.add(&quot;Hello&quot;);
String first = list.get(0);
// 编译错误: 不允许放入非String类型:list.add(new Integer(123));</code></pre>
<p>问题暂时解决。</p>
<p>然而，新的问题是，如果要存储Integer，还需要为Integer单独编写一种ArrayList：</p>
<pre><code class="highlight plaintext">public class IntegerArrayList &#123;
    private Integer[] array;
    private int size;
    public void add(Integer e) &#123;...&#125;
    public void remove(int index) &#123;...&#125;
    public Integer get(int index) &#123;...&#125;
&#125;</code></pre>
<p>实际上，还需要为其他所有class单独编写一种ArrayList：</p>
<ul>
<li>LongArrayList</li>
<li>DoubleArrayList</li>
<li>PersonArrayList</li>
<li>…</li>
</ul>
<p>这是不可能的，JDK的class就有上千个，而且它还不知道其他人编写的class。</p>
<p>为了解决新的问题，我们必须把ArrayList变成一种模板：ArrayList<T>，代码如下：</p>
<pre><code class="highlight plaintext">public class ArrayList&lt;T&gt; &#123;
    private T[] array;
    private int size;
    public void add(T e) &#123;...&#125;
    public void remove(int index) &#123;...&#125;
    public T get(int index) &#123;...&#125;
&#125;</code></pre>
<p>T可以是任何class。这样一来，我们就实现了：编写一次模版，可以创建任意类型的ArrayList：</p>
<pre><code class="highlight plaintext">// 创建可以存储String的ArrayList:
ArrayList&lt;String&gt; strList = new ArrayList&lt;String&gt;();
// 创建可以存储Float的ArrayList:
ArrayList&lt;Float&gt; floatList = new ArrayList&lt;Float&gt;();
// 创建可以存储Person的ArrayList:
ArrayList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</code></pre>
<p>因此，泛型就是定义一种模板，例如ArrayList<T>，然后在代码中为用到的类创建对应的ArrayList&lt;类型&gt;：</p>
<pre><code class="highlight plaintext">ArrayList&lt;String&gt; strList = new ArrayList&lt;String&gt;();</code></pre>
<p>由编译器针对类型作检查：</p>
<pre><code class="highlight plaintext">strList.add(&quot;hello&quot;); // OK
String s = strList.get(0); // OK
strList.add(new Integer(123)); // compile error!
Integer n = strList.get(0); // compile error!</code></pre>
<p>这样一来，既实现了编写一次，万能匹配，又通过编译器保证了类型安全：这就是泛型。</p>
<hr />
<p><strong>向上转型</strong></p>
<p>在Java标准库中的ArrayList<T>实现了List<T>接口，它可以向上转型为List<T>：</p>
<pre><code class="highlight plaintext">public class ArrayList&lt;T&gt; implements List&lt;T&gt; &#123;
    ...
&#125;

List&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></pre>
<p>即类型ArrayList<T>可以向上转型为List<T>。</p>
<blockquote>
<p>要特别注意：不能把ArrayList<Integer>向上转型为ArrayList<Number>或List<Number></p>
</blockquote>
<p>这是为什么呢？假设ArrayList<Integer>可以向上转型为ArrayList<Number>，观察一下代码：</p>
<pre><code class="highlight plaintext">// 创建ArrayList&lt;Integer&gt;类型：
ArrayList&lt;Integer&gt; integerList = new ArrayList&lt;Integer&gt;();
// 添加一个Integer：
integerList.add(new Integer(123));
// “向上转型”为ArrayList&lt;Number&gt;：
ArrayList&lt;Number&gt; numberList = integerList;
// 添加一个Float，因为Float也是Number：
numberList.add(new Float(12.34));
// 从ArrayList&lt;Integer&gt;获取索引为1的元素（即添加的Float）：
Integer n = integerList.get(1); // ClassCastException!</code></pre>
<p>我们把一个ArrayList<Integer>转型为ArrayList<Number>类型后，这个ArrayList<Number>就可以接受Float类型，因为Float是Number的子类。但是，ArrayList<Number>实际上和ArrayList<Integer>是同一个对象，也就是ArrayList<Integer>类型，它不可能接受Float类型， 所以在获取Integer的时候将产生ClassCastException。</p>
<p>实际上，编译器为了避免这种错误，根本就不允许把ArrayList<Integer>转型为ArrayList<Number>。</p>
<blockquote>
<p><strong>ArrayList<Integer>和ArrayList<Number>两者完全没有继承关系</strong>。</p>
</blockquote>
<h3 id="使用泛型"><a class="markdownIt-Anchor" href="#使用泛型"></a> 使用泛型</h3>
<p>使用ArrayList时，如果不定义泛型类型时，泛型类型实际上就是Object：</p>
<pre><code class="highlight plaintext">// 编译器警告:
List list = new ArrayList();
list.add(&quot;Hello&quot;);
list.add(&quot;World&quot;);
String first = (String) list.get(0);
String second = (String) list.get(1);</code></pre>
<p>此时，只能把<T>当作Object使用，没有发挥泛型的优势。</p>
<p>当我们定义泛型类型<String>后，List<T>的泛型接口变为强类型List<String>：</p>
<pre><code class="highlight plaintext">// 无编译器警告:
List&lt;String&gt; list = new ArrayList&lt;String&gt;();
list.add(&quot;Hello&quot;);
list.add(&quot;World&quot;);
// 无强制转型:
String first = list.get(0);
String second = list.get(1);</code></pre>
<p>当我们定义泛型类型<Number>后，List<T>的泛型接口变为强类型List<Number>：</p>
<pre><code class="highlight plaintext">List&lt;Number&gt; list = new ArrayList&lt;Number&gt;();
list.add(new Integer(123));
list.add(new Double(12.34));
Number first = list.get(0);
Number second = list.get(1);</code></pre>
<hr />
<p>编译器如果能自动推断出泛型类型，就可以省略后面的泛型类型。例如，对于下面的代码：</p>
<pre><code class="highlight plaintext">List&lt;Number&gt; list = new ArrayList&lt;Number&gt;();</code></pre>
<p>编译器看到泛型类型List<Number>就可以自动推断出后面的ArrayList<T>的泛型类型必须是ArrayList<Number>，因此，可以把代码简写为：</p>
<pre><code class="highlight plaintext">// 可以省略后面的Number，编译器可以自动推断泛型类型：
List&lt;Number&gt; list = new ArrayList&lt;&gt;();</code></pre>
<hr />
<p><strong>泛型接口</strong></p>
<p>除了ArrayList<T>使用了泛型，还可以在接口中使用泛型。例如，Arrays.sort(Object[])可以对任意数组进行排序，但待排序的元素必须实现Comparable<T>这个泛型接口：</p>
<pre><code class="highlight plaintext">public interface Comparable&lt;T&gt; &#123;
    /**
     * 返回-1: 当前实例比参数o小
     * 返回0: 当前实例与参数o相等
     * 返回1: 当前实例比参数o大
     */
    int compareTo(T o);
&#125;</code></pre>
<p>可以直接对String数组进行排序：</p>
<pre><code class="highlight plaintext">import java.util.Arrays;

public class Main &#123;
    public static void main(String[] args) &#123;
        String[] ss = new String[] &#123; &quot;Orange&quot;, &quot;Apple&quot;, &quot;Pear&quot; &#125;;
        Arrays.sort(ss);
        System.out.println(Arrays.toString(ss));

    &#125;
&#125;</code></pre>
<p>这是因为String本身已经实现了Comparable<String>接口。如果换成我们自定义的Person类型试试：</p>
<pre><code class="highlight plaintext">
import java.util.Arrays;

public class Main &#123;
    public static void main(String[] args) &#123;
            Person[] ps = new Person[] &#123;
            new Person(&quot;Bob&quot;, 61),
            new Person(&quot;Alice&quot;, 88),
            new Person(&quot;Lily&quot;, 75),
        &#125;;
        Arrays.sort(ps);
        System.out.println(Arrays.toString(ps));
    &#125;
&#125;

class Person &#123;
    String name;
    int score;
    Person(String name, int score) &#123;
        this.name = name;
        this.score = score;
    &#125;
    public String toString() &#123;
        return this.name + &quot;,&quot; + this.score;
    &#125;
&#125;</code></pre>
<p>运行程序，我们会得到ClassCastException，即无法将Person转型为Comparable。我们修改代码，让Person实现Comparable<T>接口：</p>
<pre><code class="highlight plaintext">// sort
import java.util.Arrays;

public class Main &#123;
    public static void main(String[] args) &#123;
        Person[] ps = new Person[] &#123;
            new Person(&quot;Bob&quot;, 61),
            new Person(&quot;Alice&quot;, 88),
            new Person(&quot;Lily&quot;, 75),
        &#125;;
        Arrays.sort(ps);
        System.out.println(Arrays.toString(ps));
    &#125;
&#125;
class Person implements Comparable&lt;Person&gt; &#123;
    String name;
    int score;
    Person(String name, int score) &#123;
        this.name = name;
        this.score = score;
    &#125;
    public int compareTo(Person other) &#123;
        return this.name.compareTo(other.name);
    &#125;
    public String toString() &#123;
        return this.name + &quot;,&quot; + this.score;
    &#125;
&#125;</code></pre>
<p>运行上述代码，可以正确实现按name进行排序。也可以修改比较逻辑，例如，按score从高到低排序。请自行修改测试。</p>
<h3 id="编写泛型"><a class="markdownIt-Anchor" href="#编写泛型"></a> 编写泛型</h3>
<p>编写泛型类比普通类要复杂。通常来说，泛型类一般用在集合类中，例如ArrayList<T>，我们很少需要编写泛型类。</p>
<p>如果我们确实需要编写一个泛型类，那么，应该如何编写它？</p>
<p>可以按照以下步骤来编写一个泛型类。</p>
<p>首先，按照某种类型，例如：String，来编写类：</p>
<pre><code class="highlight plaintext">public class Pair &#123;
    private String first;
    private String last;
    public Pair(String first, String last) &#123;
        this.first = first;
        this.last = last;
    &#125;
    public String getFirst() &#123;
        return first;
    &#125;
    public String getLast() &#123;
        return last;
    &#125;
&#125;</code></pre>
<p>然后，标记所有的特定类型，这里是String，把特定类型String替换为T，并申明<T>：</p>
<pre><code class="highlight plaintext">public class Pair&lt;T&gt; &#123;
    private T first;
    private T last;
    public Pair(T first, T last) &#123;
        this.first = first;
        this.last = last;
    &#125;
    public T getFirst() &#123;
        return first;
    &#125;
    public T getLast() &#123;
        return last;
    &#125;
&#125;</code></pre>
<blockquote>
<p>熟练后即可直接从T开始编写。</p>
</blockquote>
<hr />
<p><strong>静态方法</strong></p>
<p>编写泛型类时，要特别注意，泛型类型<T>不能用于静态方法。例如：</p>
<pre><code class="highlight plaintext">public class Pair&lt;T&gt; &#123;
    private T first;
    private T last;
    public Pair(T first, T last) &#123;
        this.first = first;
        this.last = last;
    &#125;
    public T getFirst() &#123; ... &#125;
    public T getLast() &#123; ... &#125;

    // 对静态方法使用&lt;T&gt;:
    public static Pair&lt;T&gt; create(T first, T last) &#123;
        return new Pair&lt;T&gt;(first, last);
    &#125;
&#125;</code></pre>
<p>上述代码会导致编译错误，我们无法在静态方法create()的方法参数和返回类型上使用泛型类型T。</p>
<p>有些同学在网上搜索发现，可以在static修饰符后面加一个<T>，编译就能通过：</p>
<pre><code class="highlight plaintext">public class Pair&lt;T&gt; &#123;
    private T first;
    private T last;
    public Pair(T first, T last) &#123;
        this.first = first;
        this.last = last;
    &#125;
    public T getFirst() &#123; ... &#125;
    public T getLast() &#123; ... &#125;

    // 可以编译通过:
    public static &lt;T&gt; Pair&lt;T&gt; create(T first, T last) &#123;
        return new Pair&lt;T&gt;(first, last);
    &#125;
&#125;</code></pre>
<p>但实际上，这个<T>和Pair<T>类型的<T>已经没有任何关系了。</p>
<p>对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可。对于上面的create()静态方法，我们应该把它改为另一种泛型类型，例如，<K>：</p>
<pre><code class="highlight plaintext">public class Pair&lt;T&gt; &#123;
    private T first;
    private T last;
    public Pair(T first, T last) &#123;
        this.first = first;
        this.last = last;
    &#125;
    public T getFirst() &#123; ... &#125;
    public T getLast() &#123; ... &#125;

    // 静态泛型方法应该使用其他类型区分:
    public static &lt;K&gt; Pair&lt;K&gt; create(K first, K last) &#123;
        return new Pair&lt;K&gt;(first, last);
    &#125;
&#125;</code></pre>
<blockquote>
<p>这样才能清楚地将静态方法的泛型类型和实例类型的泛型类型区分开</p>
</blockquote>
<hr />
<p><strong>多个泛型类型</strong></p>
<p>泛型还可以定义多种类型。例如，我们希望Pair不总是存储两个类型一样的对象，就可以使用类型&lt;T, K&gt;：</p>
<pre><code class="highlight plaintext">public class Pair&lt;T, K&gt; &#123;
    private T first;
    private K last;
    public Pair(T first, K last) &#123;
        this.first = first;
        this.last = last;
    &#125;
    public T getFirst() &#123; ... &#125;
    public K getLast() &#123; ... &#125;
&#125;</code></pre>
<p>使用的时候，需要指出两种类型：</p>
<pre><code class="highlight plaintext">Pair&lt;String, Integer&gt; p = new Pair&lt;&gt;(&quot;test&quot;, 123);</code></pre>
<p>Java标准库的Map&lt;K, V&gt;就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。</p>
<h3 id="擦拭法"><a class="markdownIt-Anchor" href="#擦拭法"></a> 擦拭法</h3>
<p>Java的泛型是采用擦拭法实现的；</p>
<p>擦拭法决定了泛型<T>：</p>
<ul>
<li>不能是基本类型，例如：int；</li>
<li>不能获取带泛型类型的Class，例如：Pair<String>.class；</li>
<li>不能判断带泛型类型的类型，例如：x instanceof Pair<String>；</li>
<li>不能实例化T类型，例如：new T()。</li>
</ul>
<p>泛型方法要防止重复定义方法，例如：public boolean equals(T obj)；</p>
<p>子类可以获取父类的泛型类型<T>。</p>
<hr />
<p>泛型是一种类似”模板代码“的技术，不同语言的泛型实现方式不一定相同。</p>
<p>Java语言的泛型实现方式是擦拭法（Type Erasure）。</p>
<p>所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。</p>
<p>例如，我们编写了一个泛型类Pair<T>，这是编译器看到的代码：</p>
<pre><code class="highlight plaintext">public class Pair&lt;T&gt; &#123;
    private T first;
    private T last;
    public Pair(T first, T last) &#123;
        this.first = first;
        this.last = last;
    &#125;
    public T getFirst() &#123;
        return first;
    &#125;
    public T getLast() &#123;
        return last;
    &#125;
&#125;</code></pre>
<p>而虚拟机根本不知道泛型。这是虚拟机执行的代码：</p>
<pre><code class="highlight plaintext">public class Pair &#123;
    private Object first;
    private Object last;
    public Pair(Object first, Object last) &#123;
        this.first = first;
        this.last = last;
    &#125;
    public Object getFirst() &#123;
        return first;
    &#125;
    public Object getLast() &#123;
        return last;
    &#125;
&#125;</code></pre>
<p>因此，Java使用擦拭法实现泛型，导致了：</p>
<ul>
<li>编译器把类型<T>视为Object；</li>
<li>编译器根据<T>实现安全的强制转型。</li>
</ul>
<p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p>
<pre><code class="highlight plaintext">Pair&lt;String&gt; p = new Pair&lt;&gt;(&quot;Hello&quot;, &quot;world&quot;);
String first = p.getFirst();
String last = p.getLast();</code></pre>
<p>而虚拟机执行的代码并没有泛型：</p>
<pre><code class="highlight plaintext">Pair p = new Pair(&quot;Hello&quot;, &quot;world&quot;);
String first = (String) p.getFirst();
String last = (String) p.getLast();</code></pre>
<p>所以，Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型T视为Object处理，但是，在需要转型的时候，编译器会根据T的类型自动为我们实行安全地强制转型。</p>
<p>了解了Java泛型的实现方式——擦拭法，我们就知道了Java泛型的局限：</p>
<p><strong>局限一</strong>：<T>不能是基本类型，例如int，因为实际类型是Object，Object类型无法持有基本类型：</p>
<pre><code class="highlight plaintext">Pair&lt;int&gt; p = new Pair&lt;&gt;(1, 2); // compile error!</code></pre>
<p><strong>局限二</strong>：无法取得带泛型的Class。观察以下代码：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
            Pair&lt;String&gt; p1 = new Pair&lt;&gt;(&quot;Hello&quot;, &quot;world&quot;);
        Pair&lt;Integer&gt; p2 = new Pair&lt;&gt;(123, 456);
        Class c1 = p1.getClass();
        Class c2 = p2.getClass();
        System.out.println(c1==c2); // true
        System.out.println(c1==Pair.class); // true

    &#125;
&#125;

class Pair&lt;T&gt; &#123;
    private T first;
    private T last;
    public Pair(T first, T last) &#123;
        this.first = first;
        this.last = last;
    &#125;
    public T getFirst() &#123;
        return first;
    &#125;
    public T getLast() &#123;
        return last;
    &#125;
&#125;</code></pre>
<blockquote>
<p>因为T是Object，我们对Pair<String>和Pair<Integer>类型获取Class时，获取到的是同一个Class，也就是Pair类的Class。</p>
</blockquote>
<blockquote>
<p>换句话说，所有泛型实例，无论T的类型是什么，getClass()返回同一个Class实例，因为编译后它们全部都是Pair<Object></p>
</blockquote>
<p><strong>局限三</strong>：无法判断带泛型的Class：</p>
<pre><code class="highlight plaintext">Pair&lt;Integer&gt; p = new Pair&lt;&gt;(123, 456);
// Compile error:
if (p instanceof Pair&lt;String&gt;.class) &#123;
&#125;</code></pre>
<blockquote>
<p>原因和前面一样，并不存在Pair<String>.class，而是只有唯一的Pair.class</p>
</blockquote>
<p><strong>局限四</strong>：不能实例化T类型：</p>
<pre><code class="highlight plaintext">public class Pair&lt;T&gt; &#123;
    private T first;
    private T last;
    public Pair() &#123;
        // Compile error:
        first = new T();
        last = new T();
    &#125;
&#125;</code></pre>
<p>上述代码无法通过编译，因为构造方法的两行语句：</p>
<pre><code class="highlight plaintext">first = new T();
last = new T();</code></pre>
<p>擦拭后实际上变成了：</p>
<pre><code class="highlight plaintext">first = new Object();
last = new Object();</code></pre>
<p>这样一来，创建new Pair<String>()和创建new Pair<Integer>()就全部成了Object，显然编译器要阻止这种类型不对的代码。</p>
<p>要实例化T类型，我们必须借助额外的Class<T>参数：</p>
<pre><code class="highlight plaintext">public class Pair&lt;T&gt; &#123;
    private T first;
    private T last;
    public Pair(Class&lt;T&gt; clazz) &#123;
        first = clazz.newInstance();
        last = clazz.newInstance();
    &#125;
&#125;</code></pre>
<p>上述代码借助Class<T>参数并通过反射来实例化T类型，使用的时候，也必须传入Class<T>。例如：</p>
<pre><code class="highlight plaintext">Pair&lt;String&gt; pair = new Pair&lt;&gt;(String.class);</code></pre>
<p>因为传入了Class<String>的实例，所以我们借助String.class就可以实例化String类型。</p>
<hr />
<p><strong>不恰当的覆写方法</strong></p>
<p>有些时候，一个看似正确定义的方法会无法通过编译。例如：</p>
<pre><code class="highlight plaintext">public class Pair&lt;T&gt; &#123;
    public boolean equals(T t) &#123;
        return this == t;
    &#125;
&#125;</code></pre>
<p>这是因为，定义的equals(T t)方法实际上会被擦拭成equals(Object t)，而这个方法是继承自Object的，编译器会阻止一个实际上会变成覆写的泛型方法定义。</p>
<p>换个方法名，避开与Object.equals(Object)的冲突就可以成功编译：</p>
<pre><code class="highlight plaintext">public class Pair&lt;T&gt; &#123;
    public boolean same(T t) &#123;
        return this == t;
    &#125;
&#125;</code></pre>
<hr />
<p><strong>泛型继承</strong></p>
<p>一个类可以继承自一个泛型类。例如：父类的类型是Pair<Integer>，子类的类型是IntPair，可以这么继承：</p>
<pre><code class="highlight plaintext">public class IntPair extends Pair&lt;Integer&gt; &#123;
&#125;</code></pre>
<p>使用的时候，因为子类IntPair并没有泛型类型，所以，正常使用即可：</p>
<pre><code class="highlight plaintext">IntPair ip = new IntPair(1, 2);</code></pre>
<p>前面讲了，我们无法获取Pair<T>的T类型，即给定一个变量Pair<Integer> p，无法从p中获取到Integer类型。</p>
<p>但是，在父类是泛型类型的情况下，编译器就必须把类型T（对IntPair来说，也就是Integer类型）保存到子类的class文件中，不然编译器就不知道IntPair只能存取Integer这种类型。</p>
<p>在继承了泛型类型的情况下，子类可以获取父类的泛型类型。例如：IntPair可以获取到父类的泛型类型Integer。获取父类的泛型类型代码比较复杂：</p>
<pre><code class="highlight plaintext">
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

public class Main &#123;
    public static void main(String[] args) &#123;
        Class&lt;IntPair&gt; clazz = IntPair.class;
        Type t = clazz.getGenericSuperclass();
        if (t instanceof ParameterizedType) &#123;
            ParameterizedType pt = (ParameterizedType) t;
            Type[] types = pt.getActualTypeArguments(); // 可能有多个泛型类型
            Type firstType = types[0]; // 取第一个泛型类型
            Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType;
            System.out.println(typeClass); // Integer
        &#125;

    &#125;
&#125;

class Pair&lt;T&gt; &#123;
    private T first;
    private T last;
    public Pair(T first, T last) &#123;
        this.first = first;
        this.last = last;
    &#125;
    public T getFirst() &#123;
        return first;
    &#125;
    public T getLast() &#123;
        return last;
    &#125;
&#125;

class IntPair extends Pair&lt;Integer&gt; &#123;
    public IntPair(Integer first, Integer last) &#123;
        super(first, last);
    &#125;
&#125;</code></pre>
<p>因为Java引入了泛型，所以，只用Class来标识类型已经不够了。实际上，Java的类型系统结构如下：</p>
<h3 id="extends通配符"><a class="markdownIt-Anchor" href="#extends通配符"></a> extends通配符</h3>
<p>我们前面已经讲到了泛型的继承关系：Pair<Integer>不是Pair<Number>的子类。</p>
<p>假设我们定义了Pair<T>：</p>
<pre><code class="highlight plaintext">public class Pair&lt;T&gt; &#123; ... &#125;</code></pre>
<p>然后，我们又针对Pair<Number>类型写了一个静态方法，它接收的参数类型是Pair<Number>：</p>
<pre><code class="highlight plaintext">public class PairHelper &#123;
    static int add(Pair&lt;Number&gt; p) &#123;
        Number first = p.getFirst();
        Number last = p.getLast();
        return first.intValue() + last.intValue();
    &#125;
&#125;</code></pre>
<p>上述代码是可以正常编译的。使用的时候，我们传入：</p>
<pre><code class="highlight plaintext">int sum = PairHelper.add(new Pair&lt;Number&gt;(1, 2));</code></pre>
<p>注意：传入的类型是Pair<Number>，实际参数类型是(Integer, Integer)。</p>
<p>既然实际参数是Integer类型，试试传入Pair<Integer>：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Pair&lt;Integer&gt; p = new Pair&lt;&gt;(123, 456);
        int n = add(p);
        System.out.println(n);
    &#125;

    static int add(Pair&lt;Number&gt; p) &#123;
        Number first = p.getFirst();
        Number last = p.getLast();
        return first.intValue() + last.intValue();
    &#125;
&#125;

class Pair&lt;T&gt; &#123;
    private T first;
    private T last;
    public Pair(T first, T last) &#123;
        this.first = first;
        this.last = last;
    &#125;
    public T getFirst() &#123;
        return first;
    &#125;
    public T getLast() &#123;
        return last;
    &#125;
&#125;</code></pre>
<p>直接运行，会得到一个编译错误：</p>
<pre><code class="highlight plaintext">incompatible types: Pair&lt;Integer&gt; cannot be converted to Pair&lt;Number&gt;</code></pre>
<p>原因很明显，因为Pair<Integer>不是Pair<Number>的子类，因此，add(Pair<Number>)不接受参数类型Pair<Integer>。</p>
<p>但是从add()方法的代码可知，传入Pair<Integer>是完全符合内部代码的类型规范，因为语句：</p>
<pre><code class="highlight plaintext">Number first = p.getFirst();
Number last = p.getLast();</code></pre>
<p>实际类型是Integer，引用类型是Number，没有问题。问题在于方法参数类型定死了只能传入Pair<Number>。</p>
<p>有没有办法使得方法参数接受Pair<Integer>？办法是有的，这就是使用Pair&lt;? extends Number&gt;使得方法接收所有泛型类型为Number或Number子类的Pair类型。我们把代码改写如下：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Pair&lt;Integer&gt; p = new Pair&lt;&gt;(123, 456);
        int n = add(p);
        System.out.println(n);
    &#125;

    static int add(Pair&lt;? extends Number&gt; p) &#123;
        Number first = p.getFirst();
        Number last = p.getLast();
        return first.intValue() + last.intValue();
    &#125;
&#125;

class Pair&lt;T&gt; &#123;
    private T first;
    private T last;
    public Pair(T first, T last) &#123;
        this.first = first;
        this.last = last;
    &#125;
    public T getFirst() &#123;
        return first;
    &#125;
    public T getLast() &#123;
        return last;
    &#125;
&#125;</code></pre>
<p>这样一来，给方法传入Pair<Integer>类型时，它符合参数Pair&lt;? extends Number&gt;类型。这种使用&lt;? extends Number&gt;的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型T的上界限定在Number了。</p>
<p>除了可以传入Pair<Integer>类型，我们还可以传入Pair<Double>类型，Pair<BigDecimal>类型等等，因为Double和BigDecimal都是Number的子类。</p>
<p>如果我们考察对Pair&lt;? extends Number&gt;类型调用getFirst()方法，实际的方法签名变成了：</p>
<pre><code class="highlight plaintext">&lt;? extends Number&gt; getFirst();</code></pre>
<p>即返回值是Number或Number的子类，因此，可以安全赋值给Number类型的变量：</p>
<pre><code class="highlight plaintext">Number x = p.getFirst();</code></pre>
<p>然后，我们不可预测实际类型就是Integer，例如，下面的代码是无法通过编译的：</p>
<pre><code class="highlight plaintext">Integer x = p.getFirst();</code></pre>
<p>这是因为实际的返回类型可能是Integer，也可能是Double或者其他类型，编译器只能确定类型一定是Number的子类（包括Number类型本身），但具体类型无法确定。</p>
<p>我们再来考察一下Pair<T>的set方法：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Pair&lt;Integer&gt; p = new Pair&lt;&gt;(123, 456);
        int n = add(p);
        System.out.println(n);
    &#125;

    static int add(Pair&lt;? extends Number&gt; p) &#123;
        Number first = p.getFirst();
        Number last = p.getLast();
        p.setFirst(new Integer(first.intValue() + 100));
        p.setLast(new Integer(last.intValue() + 100));
        return p.getFirst().intValue() + p.getFirst().intValue();
    &#125;

&#125;

class Pair&lt;T&gt; &#123;
    private T first;
    private T last;

    public Pair(T first, T last) &#123;
        this.first = first;
        this.last = last;
    &#125;

    public T getFirst() &#123;
        return first;
    &#125;
    public T getLast() &#123;
        return last;
    &#125;
    public void setFirst(T first) &#123;
        this.first = first;
    &#125;
    public void setLast(T last) &#123;
        this.last = last;
    &#125;
&#125;</code></pre>
<p>不出意外，我们会得到一个编译错误：</p>
<pre><code class="highlight plaintext">incompatible types: Integer cannot be converted to CAP#1
where CAP#1 is a fresh type-variable:
    CAP#1 extends Number from capture of ? extends Number</code></pre>
<p>编译错误发生在p.setFirst()传入的参数是Integer类型。有些童鞋会问了，既然p的定义是Pair&lt;? extends Number&gt;，那么setFirst(? extends Number)为什么不能传入Integer？</p>
<p>原因还在于擦拭法。如果我们传入的p是Pair<Double>，显然它满足参数定义Pair&lt;? extends Number&gt;，然而，Pair<Double>的setFirst()显然无法接受Integer类型。</p>
<p>这就是&lt;? extends Number&gt;通配符的一个重要限制：方法参数签名setFirst(? extends Number)无法传递任何Number类型给setFirst(? extends Number)。</p>
<p>这里唯一的例外是可以给方法参数传入null：</p>
<pre><code class="highlight plaintext">p.setFirst(null); // ok, 但是后面会抛出NullPointerException
p.getFirst().intValue(); // NullPointerException</code></pre>
<hr />
<p><strong>extends通配符的作用</strong></p>
<p>如果我们考察Java标准库的java.util.List<T>接口，它实现的是一个类似“可变数组”的列表，主要功能包括：</p>
<pre><code class="highlight plaintext">public interface List&lt;T&gt; &#123;
    int size(); // 获取个数
    T get(int index); // 根据索引获取指定元素
    void add(T t); // 添加一个新元素
    void remove(T t); // 删除一个已有元素
&#125;</code></pre>
<p>现在，让我们定义一个方法来处理列表的每个元素：</p>
<pre><code class="highlight plaintext">int sumOfList(List&lt;? extends Integer&gt; list) &#123;
    int sum = 0;
    for (int i=0; i&lt;list.size(); i++) &#123;
        Integer n = list.get(i);
        sum = sum + n;
    &#125;
    return sum;
&#125;</code></pre>
<p>为什么我们定义的方法参数类型是List&lt;? extends Integer&gt;而不是List<Integer>？从方法内部代码看，传入List&lt;? extends Integer&gt;或者List<Integer>是完全一样的，但是，注意到List&lt;? extends Integer&gt;的限制：</p>
<ul>
<li>允许调用get()方法获取Integer的引用；</li>
<li>不允许调用set(? extends Integer)方法并传入任何Integer的引用（null除外）。</li>
</ul>
<p>因此，方法参数类型List&lt;? extends Integer&gt;表明了该方法内部只会读取List的元素，不会修改List的元素（因为无法调用add(? extends Integer)、remove(? extends Integer)这些方法。换句话说，这是一个对参数List&lt;? extends Integer&gt;进行只读的方法（恶意调用set(null)除外）。</p>
<hr />
<p><strong>使用extends限定T类型</strong></p>
<p>在定义泛型类型Pair<T>的时候，也可以使用extends通配符来限定T的类型：</p>
<pre><code class="highlight plaintext">public class Pair&lt;T extends Number&gt; &#123; ... &#125;</code></pre>
<p>现在，我们只能定义：</p>
<pre><code class="highlight plaintext">Pair&lt;Number&gt; p1 = null;
Pair&lt;Integer&gt; p2 = new Pair&lt;&gt;(1, 2);
Pair&lt;Double&gt; p3 = null;</code></pre>
<p>因为Number、Integer和Double都符合<T extends Number>。</p>
<p>非Number类型将无法通过编译：</p>
<pre><code class="highlight plaintext">Pair&lt;String&gt; p1 = null; // compile error!
Pair&lt;Object&gt; p2 = null; // compile error!</code></pre>
<p>因为String、Object都不符合<T extends Number>，因为它们不是Number类型或Number的子类。</p>
<h3 id="super通配符"><a class="markdownIt-Anchor" href="#super通配符"></a> super通配符</h3>
<p>我们前面已经讲到了泛型的继承关系：Pair<Integer>不是Pair<Number>的子类。考察下面的set方法：</p>
<pre><code class="highlight plaintext">void set(Pair&lt;Integer&gt; p, Integer first, Integer last) &#123;
    p.setFirst(first);
    p.setLast(last);
&#125;</code></pre>
<p>传入Pair<Integer>是允许的，但是传入Pair<Number>是不允许的。</p>
<p>和extends通配符相反，这次，我们希望接受Pair<Integer>类型，以及Pair<Number>、Pair<Object>，因为Number和Object是Integer的父类，setFirst(Number)和setFirst(Object)实际上允许接受Integer类型。</p>
<p>我们使用super通配符来改写这个方法：</p>
<pre><code class="highlight plaintext">void set(Pair&lt;? super Integer&gt; p, Integer first, Integer last) &#123;
    p.setFirst(first);
    p.setLast(last);
&#125;</code></pre>
<p>注意到Pair&lt;? super Integer&gt;表示，方法参数接受所有泛型类型为Integer或Integer父类的Pair类型。</p>
<p>下面的代码可以被正常编译：</p>
<pre><code class="highlight plaintext">public class Main &#123;
    public static void main(String[] args) &#123;
        Pair&lt;Number&gt; p1 = new Pair&lt;&gt;(12.3, 4.56);
        Pair&lt;Integer&gt; p2 = new Pair&lt;&gt;(123, 456);
        setSame(p1, 100);
        setSame(p2, 200);
        System.out.println(p1.getFirst() + &quot;, &quot; + p1.getLast());
        System.out.println(p2.getFirst() + &quot;, &quot; + p2.getLast());
    &#125;

    static void setSame(Pair&lt;? super Integer&gt; p, Integer n) &#123;
        p.setFirst(n);
        p.setLast(n);
    &#125;
&#125;

class Pair&lt;T&gt; &#123;
    private T first;
    private T last;

    public Pair(T first, T last) &#123;
        this.first = first;
        this.last = last;
    &#125;

    public T getFirst() &#123;
        return first;
    &#125;
    public T getLast() &#123;
        return last;
    &#125;
    public void setFirst(T first) &#123;
        this.first = first;
    &#125;
    public void setLast(T last) &#123;
        this.last = last;
    &#125;
&#125;</code></pre>
<p>考察Pair&lt;? super Integer&gt;的setFirst()方法，它的方法签名实际上是：</p>
<pre><code class="highlight plaintext">void setFirst(? super Integer);</code></pre>
<p>因此，可以安全地传入Integer类型。</p>
<p>再考察Pair&lt;? super Integer&gt;的getFirst()方法，它的方法签名实际上是：</p>
<pre><code class="highlight plaintext">? super Integer getFirst();</code></pre>
<p>这里注意到我们无法使用Integer类型来接收getFirst()的返回值，即下面的语句将无法通过编译：</p>
<pre><code class="highlight plaintext">Integer x = p.getFirst();</code></pre>
<p>因为如果传入的实际类型是Pair<Number>，编译器无法将Number类型转型为Integer。</p>
<blockquote>
<p>注意：虽然Number是一个抽象类，我们无法直接实例化它。但是，即便Number不是抽象类，这里仍然无法通过编译。此外，传入Pair<Object>类型时，编译器也无法将Object类型转型为Integer。</p>
</blockquote>
<p>唯一可以接收getFirst()方法返回值的是Object类型：</p>
<pre><code class="highlight plaintext">Object obj = p.getFirst();</code></pre>
<p>因此，使用&lt;? super Integer&gt;通配符表示：</p>
<ul>
<li>允许调用set(? super Integer)方法传入Integer的引用；</li>
<li>不允许调用get()方法获得Integer的引用。<br />
唯一例外是可以获取Object的引用：Object o = p.getFirst()。</li>
</ul>
<p>换句话说，使用&lt;? super Integer&gt;通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。</p>
<hr />
<p><strong>对比extends和super通配符</strong></p>
<p>我们再回顾一下extends通配符。作为方法参数，&lt;? extends T&gt;类型和&lt;? super T&gt;类型的区别在于：</p>
<ul>
<li>
<? extends T>允许调用读方法T get()获取T的引用，但不允许调用写方法set(T)传入T的引用（传入null除外）；
</li>
<li>
<? super T>允许调用写方法set(T)传入T的引用，但不允许调用读方法T get()获取T的引用（获取Object除外）。
</li>
</ul>
<p>一个是允许读不允许写，另一个是允许写不允许读。</p>
<p>先记住上面的结论，我们来看Java标准库的Collections类定义的copy()方法：</p>
<pre><code class="highlight plaintext">public class Collections &#123;
    // 把src的每个元素复制到dest中:
    public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123;
        for (int i=0; i&lt;src.size(); i++) &#123;
            T t = src.get(i);
            dest.add(t);
        &#125;
    &#125;
&#125;</code></pre>
<p>它的作用是把一个List的每个元素依次添加到另一个List中。它的第一个参数是List&lt;? super T&gt;，表示目标List，第二个参数List&lt;? extends T&gt;，表示要复制的List。我们可以简单地用for循环实现复制。在for循环中，我们可以看到，对于类型&lt;? extends T&gt;的变量src，我们可以安全地获取类型T的引用，而对于类型&lt;? super T&gt;的变量dest，我们可以安全地传入T的引用。</p>
<p>这个copy()方法的定义就完美地展示了extends和super的意图：</p>
<ul>
<li>copy()方法内部不会读取dest，因为不能调用dest.get()来获取T的引用；</li>
<li>copy()方法内部也不会修改src，因为不能调用src.add(T)。</li>
</ul>
<p>这是由编译器检查来实现的。如果在方法代码中意外修改了src，或者意外读取了dest，就会导致一个编译错误：</p>
<pre><code class="highlight plaintext">public class Collections &#123;
    // 把src的每个元素复制到dest中:
    public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123;
        ...
        T t = dest.get(0); // compile error!
        src.add(t); // compile error!
    &#125;
&#125;</code></pre>
<p>这个copy()方法的另一个好处是可以安全地把一个List<Integer>添加到List<Number>，但是无法反过来添加：</p>
<pre><code class="highlight plaintext">// copy List&lt;Integer&gt; to List&lt;Number&gt; ok:
List&lt;Number&gt; numList = ...;
List&lt;Integer&gt; intList = ...;
Collections.copy(numList, intList);

// ERROR: cannot copy List&lt;Number&gt; to List&lt;Integer&gt;:
Collections.copy(intList, numList);</code></pre>
<blockquote>
<p>而这些都是通过super和extends通配符，并由编译器强制检查来实现的。</p>
</blockquote>
<hr />
<p><strong>PECS原则</strong></p>
<p>何时使用extends，何时使用super？为了便于记忆，我们可以用PECS原则：Producer Extends Consumer Super。</p>
<p>即：如果需要返回T，它是生产者（Producer），要使用extends通配符；如果需要写入T，它是消费者（Consumer），要使用super通配符。</p>
<p>还是以Collections的copy()方法为例：</p>
<pre><code class="highlight plaintext">public class Collections &#123;
    public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123;
        for (int i=0; i&lt;src.size(); i++) &#123;
            T t = src.get(i); // src是producer
            dest.add(t); // dest是consumer
        &#125;
    &#125;
&#125;</code></pre>
<p>需要返回T的src是生产者，因此声明为List&lt;? extends T&gt;，需要写入T的dest是消费者，因此声明为List&lt;? super T&gt;。</p>
<hr />
<p><strong>无限定通配符</strong></p>
<p>我们已经讨论了&lt;? extends T&gt;和&lt;? super T&gt;作为方法参数的作用。实际上，Java的泛型还允许使用无限定通配符（Unbounded Wildcard Type），即只定义一个?：</p>
<pre><code class="highlight plaintext">void sample(Pair&lt;?&gt; p) &#123;
&#125;</code></pre>
<p>因为&lt;?&gt;通配符既没有extends，也没有super，因此：</p>
<ul>
<li>不允许调用set(T)方法并传入引用（null除外）；</li>
<li>不允许调用T get()方法并获取T引用（只能获取Object引用）。</li>
</ul>
<p>换句话说，既不能读，也不能写，那只能做一些null判断：</p>
<pre><code class="highlight plaintext">static boolean isNull(Pair&lt;?&gt; p) &#123;
    return p.getFirst() == null || p.getLast() == null;
&#125;</code></pre>
<p>大多数情况下，可以引入泛型参数<T>消除&lt;?&gt;通配符：</p>
<pre><code class="highlight plaintext">static &lt;T&gt; boolean isNull(Pair&lt;T&gt; p) &#123;
    return p.getFirst() == null || p.getLast() == null;
&#125;</code></pre>
<?>通配符有一个独特的特点，就是：Pair<?>是所有Pair<T>的超类：
<pre><code class="highlight plaintext">
public class Main &#123;
    public static void main(String[] args) &#123;
        Pair&lt;Integer&gt; p = new Pair&lt;&gt;(123, 456);
        Pair&lt;?&gt; p2 = p; // 安全地向上转型
        System.out.println(p2.getFirst() + &quot;, &quot; + p2.getLast());
    &#125;
&#125;

class Pair&lt;T&gt; &#123;
    private T first;
    private T last;

    public Pair(T first, T last) &#123;
        this.first = first;
        this.last = last;
    &#125;

    public T getFirst() &#123;
        return first;
    &#125;
    public T getLast() &#123;
        return last;
    &#125;
    public void setFirst(T first) &#123;
        this.first = first;
    &#125;
    public void setLast(T last) &#123;
        this.last = last;
    &#125;
&#125;</code></pre>
<blockquote>
<p>上述代码是可以正常编译运行的，因为Pair<Integer>是Pair&lt;?&gt;的子类，可以安全地向上转型。</p>
</blockquote>
<h3 id="泛型和反射"><a class="markdownIt-Anchor" href="#泛型和反射"></a> 泛型和反射</h3>
<p>Java的部分反射API也是泛型。例如：Class<T>就是泛型：</p>
<pre><code class="highlight plaintext">// compile warning:
Class clazz = String.class;
String str = (String) clazz.newInstance();

// no warning:
Class&lt;String&gt; clazz = String.class;
String str = clazz.newInstance();</code></pre>
<p>调用Class的getSuperclass()方法返回的Class类型是Class&lt;? super T&gt;：</p>
<pre><code class="highlight plaintext">Class&lt;? super String&gt; sup = String.class.getSuperclass();</code></pre>
<p>构造方法Constructor<T>也是泛型：</p>
<pre><code class="highlight plaintext">Class&lt;Integer&gt; clazz = Integer.class;
Constructor&lt;Integer&gt; cons = clazz.getConstructor(int.class);
Integer i = cons.newInstance(123);</code></pre>
<p>我们可以声明带泛型的数组，但不能用new操作符创建带泛型的数组：</p>
<pre><code class="highlight plaintext">Pair&lt;String&gt;[] ps = null; // ok
Pair&lt;String&gt;[] ps = new Pair&lt;String&gt;[2]; // compile error!</code></pre>
<p>必须通过强制转型实现带泛型的数组：</p>
<pre><code class="highlight plaintext">@SuppressWarnings(&quot;unchecked&quot;)
Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) new Pair[2];</code></pre>
<p>使用泛型数组要特别小心，因为数组实际上在运行期没有泛型，编译器可以强制检查变量ps，因为它的类型是泛型数组。但是，编译器不会检查变量arr，因为它不是泛型数组。因为这两个变量实际上指向同一个数组，所以，操作arr可能导致从ps获取元素时报错，例如，以下代码演示了不安全地使用带泛型的数组：</p>
<pre><code class="highlight plaintext">Pair[] arr = new Pair[2];
Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) arr;

ps[0] = new Pair&lt;String&gt;(&quot;a&quot;, &quot;b&quot;);
arr[1] = new Pair&lt;Integer&gt;(1, 2);

// ClassCastException:
Pair&lt;String&gt; p = ps[1];
String s = p.getFirst();</code></pre>
<p>要安全地使用泛型数组，必须扔掉arr的引用：</p>
<pre><code class="highlight plaintext">@SuppressWarnings(&quot;unchecked&quot;)
Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) new Pair[2];</code></pre>
<p>上面的代码中，由于拿不到原始数组的引用，就只能对泛型数组ps进行操作，这种操作就是安全的。</p>
<p>带泛型的数组实际上是编译器的类型擦除：</p>
<pre><code class="highlight plaintext">Pair[] arr = new Pair[2];
Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) arr;

System.out.println(ps.getClass() == Pair[].class); // true

String s1 = (String) arr[0].getFirst();
String s2 = ps[0].getFirst();</code></pre>
<p>所以我们不能直接创建泛型数组T[]，因为擦拭后代码变为Object[]：</p>
<pre><code class="highlight plaintext">// compile error:public class Abc&lt;T&gt; &#123;
    T[] createArray() &#123;
        return new T[5];
    &#125;
&#125;</code></pre>
<p>必须借助Class<T>来创建泛型数组：</p>
<pre><code class="highlight plaintext">T[] createArray(Class&lt;T&gt; cls) &#123;
    return (T[]) Array.newInstance(cls, 5);
&#125;</code></pre>
<p>我们还可以利用可变参数创建泛型数组T[]：</p>
<pre><code class="highlight plaintext">public class ArrayHelper &#123;
    @SafeVarargs
    static &lt;T&gt; T[] asArray(T... objs) &#123;
        return objs;
    &#125;
&#125;

String[] ss = ArrayHelper.asArray(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
Integer[] ns = ArrayHelper.asArray(1, 2, 3);</code></pre>
<hr />
<p><strong>谨慎使用泛型可变参数</strong></p>
<p>在上面的例子中，我们看到，通过：</p>
<pre><code class="highlight plaintext">static &lt;T&gt; T[] asArray(T... objs) &#123;
    return objs;
&#125;</code></pre>
<p>似乎可以安全地创建一个泛型数组。但实际上，这种方法非常危险。以下代码来自《Effective Java》的示例：</p>
<pre><code class="highlight plaintext">
import java.util.Arrays;

public class Main &#123;
    public static void main(String[] args) &#123;
        String[] arr = asArray(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);
        System.out.println(Arrays.toString(arr));
        // ClassCastException:
        String[] firstTwo = pickTwo(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);
        System.out.println(Arrays.toString(firstTwo));
    &#125;

    static &lt;K&gt; K[] pickTwo(K k1, K k2, K k3) &#123;
        return asArray(k1, k2);
    &#125;

    static &lt;T&gt; T[] asArray(T... objs) &#123;
        return objs;
    &#125;
&#125;</code></pre>
<p>直接调用asArray(T…)似乎没有问题，但是在另一个方法中，我们返回一个泛型数组就会产生ClassCastException，原因还是因为擦拭法，在pickTwo()方法内部，编译器无法检测K[]的正确类型，因此返回了Object[]。</p>
<p>如果仔细观察，可以发现编译器对所有可变泛型参数都会发出警告，除非确认完全没有问题，才可以用@SafeVarargs消除警告。</p>
<blockquote>
<p>如果在方法内部创建了泛型数组，最好不要将它返回给外部使用。</p>
</blockquote>
<h2 id="日期与时间"><a class="markdownIt-Anchor" href="#日期与时间"></a> 日期与时间</h2>
<h3 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h3>
<p>在计算机中，我们经常需要处理日期和时间。</p>
<p>这是日期：</p>
<ul>
<li>2019-11-20</li>
<li>2020-1-1</li>
</ul>
<p>这是时间：</p>
<ul>
<li>12:30:59</li>
<li>2020-1-1 20:21:59</li>
</ul>
<p>日期是指某一天，它不是连续变化的，而是应该被看成离散的。</p>
<p>而时间有两种概念，一种是不带日期的时间，例如，12:30:59。另一种是带日期的时间，例如，2020-1-1 20:21:59，只有这种带日期的时间能唯一确定某个时刻，不带日期的时间是无法确定一个唯一时刻的。</p>
<p><strong>本地时间</strong></p>
<p>当我们说当前时刻是2019年11月20日早上8:15的时候，我们说的实际上是本地时间。在国内就是北京时间。在这个时刻，如果地球上不同地方的人们同时看一眼手表，他们各自的本地时间是不同的：</p>
<p>所以，不同的时区，在同一时刻，本地时间是不同的。全球一共分为24个时区，伦敦所在的时区称为标准时区，其他时区按东／西偏移的小时区分，北京所在的时区是东八区。</p>
<p><strong>时区</strong></p>
<p>因为光靠本地时间还无法唯一确定一个准确的时刻，所以我们还需要给本地时间加上一个时区。</p>
<p>时区有好几种表示方式。一种是以GMT或者UTC加时区偏移表示，例如：GMT+08:00或者UTC+08:00表示东八区。</p>
<p>GMT和UTC可以认为基本是等价的，只是UTC使用更精确的原子钟计时，每隔几年会有一个闰秒，我们在开发程序的时候可以忽略两者的误差，因为计算机的时钟在联网的时候会自动与时间服务器同步时间。</p>
<p>另一种是缩写，例如，CST表示China Standard Time，也就是中国标准时间。但是CST也可以表示美国中部时间Central Standard Time USA，因此，缩写容易产生混淆，我们尽量不要使用缩写。</p>
<p>最后一种是以洲／城市表示，例如，Asia/Shanghai，表示上海所在地的时区。特别注意城市名称不是任意的城市，而是由国际标准组织规定的城市。</p>
<p>因为时区的存在，东八区的2019年11月20日早上8:15，和西五区的2019年11月19日晚上19:15，他们的时刻是相同的：</p>
<p>时刻相同的意思就是，分别在两个时区的两个人，如果在这一刻通电话，他们各自报出自己手表上的时间，虽然本地时间是不同的，但是这两个时间表示的时刻是相同的。</p>
<h4 id="夏令时"><a class="markdownIt-Anchor" href="#夏令时"></a> 夏令时</h4>
<p>时区还不是最复杂的，更复杂的是夏令时。所谓夏令时，就是夏天开始的时候，把时间往后拨1小时，夏天结束的时候，再把时间往前拨1小时。我们国家实行过一段时间夏令时，1992年就废除了，但是矫情的美国人到现在还在使用，所以时间换算更加复杂。</p>
<p>因为涉及到夏令时，相同的时区，如果表示的方式不同，转换出的时间是不同的。我们举个栗子：</p>
<p>对于2019-11-20和2019-6-20两个日期来说，假设北京人在纽约：</p>
<ul>
<li>如果以GMT或者UTC作为时区，无论日期是多少，时间都是19:00；</li>
<li>如果以国家／城市表示，例如America／NewYork，虽然纽约也在西五区，但是，因为夏令时的存在，在不同的日期，GMT时间和纽约时间可能是不一样的：</li>
</ul>
<p>实行夏令时的不同地区，进入和退出夏令时的时间很可能是不同的。同一个地区，根据历史上是否实行过夏令时，标准时间在不同年份换算成当地时间也是不同的。因此，计算夏令时，没有统一的公式，必须按照一组给定的规则来算，并且，该规则要定期更新。</p>
<blockquote>
<p>计算夏令时请使用标准库提供的相关类，不要试图自己计算夏令时。</p>
</blockquote>
<h4 id="本地化"><a class="markdownIt-Anchor" href="#本地化"></a> 本地化</h4>
<p>在计算机中，通常使用Locale表示一个国家或地区的日期、时间、数字、货币等格式。Locale由语言_国家的字母缩写构成，例如，zh_CN表示中文+中国，en_US表示英文+美国。语言使用小写，国家使用大写。</p>
<p>对于日期来说，不同的Locale，例如，中国和美国的表示方式如下：</p>
<ul>
<li>zh_CN：2016-11-30</li>
<li>en_US：11/30/2016</li>
</ul>
<p>计算机用Locale在日期、时间、货币和字符串之间进行转换。一个电商网站会根据用户所在的Locale对用户显示如下：</p>
<h3 id="date和calendar"><a class="markdownIt-Anchor" href="#date和calendar"></a> Date和Calendar</h3>
<p>在计算机中，应该如何表示日期和时间呢？</p>
<p>我们经常看到的日期和时间表示方式如下：</p>
<ul>
<li>2019-11-20 0:15:00 GMT+00:00</li>
<li>2019年11月20日8:15:00</li>
<li>11/19/2019 19:15:00 America/New_York</li>
</ul>
<p>如果直接以字符串的形式存储，那么不同的格式，不同的语言会让表示方式非常繁琐。在理解日期和时间的表示方式之前，我们先要理解数据的存储和展示。</p>
<p>当我们定义一个整型变量并赋值时：</p>
<pre><code class="highlight plaintext">int n = 123400;</code></pre>
<p>编译器会把上述字符串（程序源码就是一个字符串）编译成字节码。在程序的运行期，变量n指向的内存实际上是一个4字节区域：</p>
<p>注意到计算机内存除了二进制的0/1外没有其他任何格式。上述十六机制是为了简化表示。</p>
<p>当我们用System.out.println(n)打印这个整数的时候，实际上println()这个方法在内部把int类型转换成String类型，然后打印出字符串123400。</p>
<p>类似的，我们也可以以十六进制的形式打印这个整数，或者，如果n表示一个价格，我们就以$123,400.00的形式来打印它：</p>
<pre><code class="highlight plaintext">import java.text.*;
import java.util.*;

public class Main &#123;
    public static void main(String[] args) &#123;
        int n = 123400;
        // 123400
        System.out.println(n);
        // 1e208
        System.out.println(Integer.toHexString(n));
        // $123,400.00
        System.out.println(NumberFormat.getCurrencyInstance(Locale.US).format(n));
    &#125;
&#125;</code></pre>
<p>可见，整数123400是数据的存储格式，它的存储格式非常简单。而我们打印的各种各样的字符串，则是数据的展示格式。展示格式有多种形式，但本质上它就是一个转换方法：</p>
<pre><code class="highlight plaintext">String toDisplay(int n) &#123; ... &#125;</code></pre>
<p>理解了数据的存储和展示，我们回头看看以下几种日期和时间：</p>
<ul>
<li>2019-11-20 0:15:01 GMT+00:00</li>
<li>2019年11月20日8:15:01</li>
<li>11/19/2019 19:15:01 America/New_York</li>
</ul>
<p>它们实际上是数据的展示格式，分别按英国时区、中国时区、纽约时区对同一个时刻进行展示。而这个“同一个时刻”在计算机中存储的本质上只是一个整数，我们称它为Epoch Time。</p>
<p>Epoch Time是计算<strong>从1970年1月1日零点（格林威治时区／GMT+00:00）到现在所经历的秒数</strong>，例如：1574208900表示从从1970年1月1日零点GMT时区到该时刻一共经历了1574208900秒，换算成伦敦、北京和纽约时间分别是：</p>
<p>因此，在计算机中，只需要存储一个整数1574208900表示某一时刻。当需要显示为某一地区的当地时间时，我们就把它格式化为一个字符串：</p>
<pre><code class="highlight plaintext">String displayDateTime(int n, String timezone) &#123; ... &#125;</code></pre>
<p>Epoch Time又称为时间戳，在不同的编程语言中，会有几种存储方式：</p>
<ul>
<li>以秒为单位的整数：1574208900，缺点是精度只能到秒；</li>
<li>以毫秒为单位的整数：1574208900123，最后3位表示毫秒数；</li>
<li>以秒为单位的浮点数：1574208900.123，小数点后面表示零点几秒。</li>
</ul>
<p>它们之间转换非常简单。而在Java程序中，时间戳通常是用long表示的毫秒数，即：</p>
<pre><code class="highlight plaintext">long t = 1574208900123L;</code></pre>
<p>转换成北京时间就是2019-11-20T8:15:00.123。要获取当前时间戳，可以使用System.currentTimeMillis()，这是Java程序获取时间戳最常用的方法。</p>
<h4 id="标准库api"><a class="markdownIt-Anchor" href="#标准库api"></a> 标准库API</h4>
<p>我们再来看一下Java标准库提供的API。Java标准库有两套处理日期和时间的API：</p>
<ul>
<li>一套定义在java.util这个包里面，主要包括Date、Calendar和TimeZone这几个类；</li>
<li>一套新的API是在Java 8引入的，定义在java.time这个包里面，主要包括LocalDateTime、ZonedDateTime、ZoneId等。</li>
</ul>
<p>为什么会有新旧两套API呢？因为历史遗留原因，旧的API存在很多问题，所以引入了新的API。</p>
<p>那么我们能不能跳过旧的API直接用新的API呢？如果涉及到遗留代码就不行，因为很多遗留代码仍然使用旧的API，所以目前仍然需要对旧的API有一定了解，很多时候还需要在新旧两种对象之间进行转换。</p>
<p>本节我们快速讲解旧API的常用类型和方法。</p>
<h4 id="date"><a class="markdownIt-Anchor" href="#date"></a> Date</h4>
<p>java.util.Date是用于表示一个日期和时间的对象，注意与java.sql.Date区分，后者用在数据库中。如果观察Date的源码，可以发现它实际上存储了一个long类型的以毫秒表示的时间戳：</p>
<pre><code class="highlight plaintext">public class Date implements Serializable, Cloneable, Comparable&lt;Date&gt; &#123;

    private transient long fastTime;

    ...
&#125;</code></pre>
<p>基本用法：</p>
<pre><code class="highlight plaintext">import java.util.*;
public class Main &#123;
    public static void main(String[] args) &#123;
        // 获取当前时间:
        Date date = new Date();
        System.out.println(date.getYear() + 1900); // 必须加上1900
        System.out.println(date.getMonth() + 1); // 0~11，必须加上1
        System.out.println(date.getDate()); // 1~31，不能加1
        // 转换为String:
        System.out.println(date.toString());
        // 转换为GMT时区:
        System.out.println(date.toGMTString());
        // 转换为本地时区:
        System.out.println(date.toLocaleString());
    &#125;
&#125;</code></pre>
<p>注意getYear()返回的年份必须加上1900，getMonth()返回的月份是0<sub>11分别表示1</sub>12月，所以要加1，而getDate()返回的日期范围是1~31，又不能加1。</p>
<h4 id="simpledateformat时间格式化"><a class="markdownIt-Anchor" href="#simpledateformat时间格式化"></a> SimpleDateFormat时间格式化</h4>
<p>打印本地时区表示的日期和时间时，不同的计算机可能会有不同的结果。如果我们想要针对用户的偏好精确地控制日期和时间的格式，就可以使用<strong>SimpleDateFormat</strong>对一个Date进行转换。它用预定义的字符串表示格式化：</p>
<ul>
<li>yyyy：年</li>
<li>MM：月</li>
<li>dd: 日</li>
<li>HH: 小时</li>
<li>mm: 分钟</li>
<li>ss: 秒</li>
</ul>
<p>我们来看如何以<strong>自定义的格式输出</strong>：</p>
<pre><code class="highlight plaintext">import java.text.*;
import java.util.*;
public class Main &#123;
    public static void main(String[] args) &#123;
        // 获取当前时间:
        Date date = new Date();
        var sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        System.out.println(sdf.format(date));
    &#125;
&#125;</code></pre>
<p>上述代码在不同的语言环境会打印出类似Sun Sep 15, 2019这样的日期。可以从JDK文档查看详细的格式说明。一般来说，字母越长，输出越长。以M为例，假设当前月份是9月：</p>
<ul>
<li>M：输出9</li>
<li>MM：输出09</li>
<li>MMM：输出Sep</li>
<li>MMMM：输出September</li>
</ul>
<p>Date对象有几个严重的问题：它不能转换时区，除了toGMTString()可以按GMT+0:00输出外，Date总是以当前计算机系统的默认时区为基础进行输出。此外，我们也很难对日期和时间进行加减，计算两个日期相差多少天，计算某个月第一个星期一的日期等。</p>
<h4 id="calendar时间计算"><a class="markdownIt-Anchor" href="#calendar时间计算"></a> Calendar时间计算</h4>
<p>Calendar可以用于获取并设置年、月、日、时、分、秒，它和Date比，主要多了一个可以做简单的日期和时间运算的功能。</p>
<p>我们来看Calendar的基本用法：</p>
<pre><code class="highlight plaintext">import java.util.*;

public class Main &#123;
    public static void main(String[] args) &#123;
        // 获取当前时间:
        Calendar c = Calendar.getInstance();
        int y = c.get(Calendar.YEAR);
        int m = 1 + c.get(Calendar.MONTH);
        int d = c.get(Calendar.DAY_OF_MONTH);
        int w = c.get(Calendar.DAY_OF_WEEK);
        int hh = c.get(Calendar.HOUR_OF_DAY);
        int mm = c.get(Calendar.MINUTE);
        int ss = c.get(Calendar.SECOND);
        int ms = c.get(Calendar.MILLISECOND);
        System.out.println(y + &quot;-&quot; + m + &quot;-&quot; + d + &quot; &quot; + w + &quot; &quot; + hh + &quot;:&quot; + mm + &quot;:&quot; + ss + &quot;.&quot; + ms);
    &#125;
&#125;</code></pre>
<p>注意到Calendar获取年月日这些信息变成了get(int field)，返回的年份不必转换，返回的月份仍然要加1，返回的星期要特别注意，1~7分别表示周日，周一，……，周六。</p>
<p>Calendar只有一种方式获取，即Calendar.getInstance()，而且一获取到就是当前时间。如果我们想给它设置成特定的一个日期和时间，就必须先清除所有字段：</p>
<pre><code class="highlight plaintext">import java.text.*;
import java.util.*;
public class Main &#123;
    public static void main(String[] args) &#123;
        // 当前时间:
        Calendar c = Calendar.getInstance();
        // 清除所有:
        c.clear();
        // 设置2019年:
        c.set(Calendar.YEAR, 2019);
        // 设置9月:注意8表示9月:
        c.set(Calendar.MONTH, 8);
        // 设置2日:
        c.set(Calendar.DATE, 2);
        // 设置时间:
        c.set(Calendar.HOUR_OF_DAY, 21);
        c.set(Calendar.MINUTE, 22);
        c.set(Calendar.SECOND, 23);
        System.out.println(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(c.getTime()));
        // 2019-09-02 21:22:23
    &#125;
&#125;</code></pre>
<p>利用Calendar.getTime()可以将一个Calendar对象转换成Date对象，然后就可以用SimpleDateFormat进行格式化了。</p>
<h4 id="timezone时区转换"><a class="markdownIt-Anchor" href="#timezone时区转换"></a> TimeZone时区转换</h4>
<p>Calendar和Date相比，它提供了时区转换的功能。时区用TimeZone对象表示：</p>
<pre><code class="highlight plaintext">import java.util.*;
public class Main &#123;
    public static void main(String[] args) &#123;
        TimeZone tzDefault = TimeZone.getDefault(); // 当前时区
        TimeZone tzGMT9 = TimeZone.getTimeZone(&quot;GMT+09:00&quot;); // GMT+9:00时区
        TimeZone tzNY = TimeZone.getTimeZone(&quot;America/New_York&quot;); // 纽约时区
        System.out.println(tzDefault.getID()); // Asia/Shanghai
        System.out.println(tzGMT9.getID()); // GMT+09:00
        System.out.println(tzNY.getID()); // America/New_York
    &#125;
&#125;</code></pre>
<p>时区的唯一标识是以字符串表示的ID，我们获取指定TimeZone对象也是以这个ID为参数获取，GMT+09:00、Asia/Shanghai都是有效的时区ID。要列出系统支持的所有ID，请使用TimeZone.getAvailableIDs()。</p>
<p>有了时区，我们就可以对指定时间进行转换。例如，下面的例子演示了如何将北京时间2019-11-20 8:15:00转换为纽约时间：</p>
<pre><code class="highlight plaintext">import java.text.*;
import java.util.*;
public class Main &#123;
    public static void main(String[] args) &#123;
        // 当前时间:
        Calendar c = Calendar.getInstance();
        // 清除所有:
        c.clear();
        // 设置为北京时区:
        c.setTimeZone(TimeZone.getTimeZone(&quot;Asia/Shanghai&quot;));
        // 设置年月日时分秒:
        c.set(2019, 10 /* 11月 */, 20, 8, 15, 0);
        // 显示时间:
        var sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        sdf.setTimeZone(TimeZone.getTimeZone(&quot;America/New_York&quot;));
        System.out.println(sdf.format(c.getTime()));
        // 2019-11-19 19:15:00
    &#125;
&#125;</code></pre>
<p>可见，利用Calendar进行时区转换的步骤是：</p>
<ol>
<li>清除所有字段；</li>
<li>设定指定时区；</li>
<li>设定日期和时间；</li>
<li>创建SimpleDateFormat并设定目标时区；</li>
<li>格式化获取的Date对象（注意Date对象无时区信息，时区信息存储在SimpleDateFormat中）。</li>
</ol>
<p>因此，本质上时区转换只能通过SimpleDateFormat在显示的时候完成。Calendar也可以对日期和时间进行简单的加减：</p>
<pre><code class="highlight plaintext">import java.text.*;
import java.util.*;

public class Main &#123;
    public static void main(String[] args) &#123;
        // 当前时间:
        Calendar c = Calendar.getInstance();
        // 清除所有:
        c.clear();
        // 设置年月日时分秒:
        c.set(2019, 10 /* 11月 */, 20, 8, 15, 0);
        // 加5天并减去2小时:
        c.add(Calendar.DAY_OF_MONTH, 5);
        c.add(Calendar.HOUR_OF_DAY, -2);
        // 显示时间:
        var sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        Date d = c.getTime();
        System.out.println(sdf.format(d));
        // 2019-11-25 6:15:00
    &#125;
&#125;</code></pre>
<h3 id="localdatetime"><a class="markdownIt-Anchor" href="#localdatetime"></a> LocalDateTime</h3>
<p>从Java 8开始，java.time包提供了新的日期和时间API，主要涉及的类型有：</p>
<ul>
<li>本地日期和时间：LocalDateTime，LocalDate，LocalTime；</li>
<li>带时区的日期和时间：ZonedDateTime；</li>
<li>时刻：Instant；</li>
<li>时区：ZoneId，ZoneOffset；</li>
<li>时间间隔：Duration。</li>
<li>以及一套新的用于取代SimpleDateFormat的格式化类型DateTimeFormatter</li>
</ul>
<p>和旧的API相比，新API严格区分了时刻、本地日期、本地时间和带时区的日期时间，并且，对日期和时间进行运算更加方便。</p>
<p>此外，新API修正了旧API不合理的常量设计：</p>
<ul>
<li>Month的范围用1~12表示1月到12月；</li>
<li>Week的范围用1~7表示周一到周日。</li>
</ul>
<p>最后，新API的类型几乎全部是不变类型（和String类似），可以放心使用不必担心被修改。</p>
<h4 id="localdatetime-2"><a class="markdownIt-Anchor" href="#localdatetime-2"></a> LocalDateTime</h4>
<pre><code class="highlight plaintext">import java.time.*;
public class Main &#123;
    public static void main(String[] args) &#123;
        LocalDate d = LocalDate.now(); // 当前日期
        LocalTime t = LocalTime.now(); // 当前时间
        LocalDateTime dt = LocalDateTime.now(); // 当前日期和时间
        System.out.println(d); // 严格按照ISO 8601格式打印
        System.out.println(t); // 严格按照ISO 8601格式打印
        System.out.println(dt); // 严格按照ISO 8601格式打印
    &#125;
&#125;</code></pre>
<p>本地日期和时间通过now()获取到的总是以当前默认时区返回的，和旧API不同，LocalDateTime、LocalDate和LocalTime默认严格按照ISO 8601规定的日期和时间格式进行打印。</p>
<p>上述代码其实有一个小问题，在获取3个类型的时候，由于执行一行代码总会消耗一点时间，因此，3个类型的日期和时间很可能对不上（时间的毫秒数基本上不同）。为了保证获取到同一时刻的日期和时间，可以改写如下：</p>
<pre><code class="highlight plaintext">LocalDateTime dt = LocalDateTime.now(); // 当前日期和时间
LocalDate d = dt.toLocalDate(); // 转换到当前日期
LocalTime t = dt.toLocalTime(); // 转换到当前时间</code></pre>
<p>反过来，通过指定的日期和时间创建LocalDateTime可以通过of()方法：</p>
<pre><code class="highlight plaintext">// 指定日期和时间:
LocalDate d2 = LocalDate.of(2019, 11, 30); // 2019-11-30, 注意11=11月
LocalTime t2 = LocalTime.of(15, 16, 17); // 15:16:17
LocalDateTime dt2 = LocalDateTime.of(2019, 11, 30, 15, 16, 17);
LocalDateTime dt3 = LocalDateTime.of(d2, t2);</code></pre>
<p>因为严格按照ISO 8601的格式，因此，将字符串转换为LocalDateTime就可以传入标准格式：</p>
<pre><code class="highlight plaintext">LocalDateTime dt = LocalDateTime.parse(&quot;2019-11-19T15:16:17&quot;);
LocalDate d = LocalDate.parse(&quot;2019-11-19&quot;);
LocalTime t = LocalTime.parse(&quot;15:16:17&quot;);</code></pre>
<p>注意ISO 8601规定的日期和时间分隔符是T。标准格式如下：</p>
<ul>
<li>日期：yyyy-MM-dd</li>
<li>时间：HH:mm:ss</li>
<li>带毫秒的时间：HH:mm:ss.SSS</li>
<li>日期和时间：yyyy-MM-dd’T’HH:mm:ss</li>
<li>带毫秒的日期和时间：yyyy-MM-dd’T’HH:mm:ss.SSS</li>
</ul>
<h4 id="datatimeformatter"><a class="markdownIt-Anchor" href="#datatimeformatter"></a> DataTimeFormatter</h4>
<p>如果要自定义输出的格式，或者要把一个非ISO 8601格式的字符串解析成LocalDateTime，可以使用新的DateTimeFormatter：</p>
<pre><code class="highlight plaintext">import java.time.*;
import java.time.format.*;
public class Main &#123;
    public static void main(String[] args) &#123;
        // 自定义格式化:
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd HH:mm:ss&quot;);
        System.out.println(dtf.format(LocalDateTime.now()));

        // 用自定义格式解析:
        LocalDateTime dt2 = LocalDateTime.parse(&quot;2019/11/30 15:16:17&quot;, dtf);
        System.out.println(dt2);
    &#125;
&#125;
</code></pre>
<p>LocalDateTime提供了对日期和时间进行加减的非常简单的链式调用：</p>
<pre><code class="highlight plaintext">import java.time.*;

public class Main &#123;
    public static void main(String[] args) &#123;
        LocalDateTime dt = LocalDateTime.of(2019, 10, 26, 20, 30, 59);
        System.out.println(dt);
        // 加5天减3小时:
        LocalDateTime dt2 = dt.plusDays(5).minusHours(3);
        System.out.println(dt2); // 2019-10-31T17:30:59
        // 减1月:
        LocalDateTime dt3 = dt2.minusMonths(1);
        System.out.println(dt3); // 2019-09-30T17:30:59
    &#125;
&#125;</code></pre>
<p>注意到月份加减会自动调整日期，例如从2019-10-31减去1个月得到的结果是2019-09-30，因为9月没有31日。</p>
<p>对日期和时间进行调整则使用withXxx()方法，例如：withHour(15)会把10:11:12变为15:11:12：</p>
<ul>
<li>调整年：withYear()</li>
<li>调整月：withMonth()</li>
<li>调整日：withDayOfMonth()</li>
<li>调整时：withHour()</li>
<li>调整分：withMinute()</li>
<li>调整秒：withSecond()</li>
</ul>
<pre><code class="highlight plaintext">import java.time.*;
public class Main &#123;
    public static void main(String[] args) &#123;
        LocalDateTime dt = LocalDateTime.of(2019, 10, 26, 20, 30, 59);
        System.out.println(dt);
        // 日期变为31日:
        LocalDateTime dt2 = dt.withDayOfMonth(31);
        System.out.println(dt2); // 2019-10-31T20:30:59
        // 月份变为9:
        LocalDateTime dt3 = dt2.withMonth(9);
        System.out.println(dt3); // 2019-09-30T20:30:59
    &#125;
&#125;</code></pre>
<p>同样注意到调整月份时，会相应地调整日期，即把2019-10-31的月份调整为9时，日期也自动变为30。</p>
<p>实际上，LocalDateTime还有一个通用的with()方法允许我们做更复杂的运算。例如：</p>
<pre><code class="highlight plaintext">import java.time.*;
import java.time.temporal.*;

public class Main &#123;
    public static void main(String[] args) &#123;
        // 本月第一天0:00时刻:
        LocalDateTime firstDay = LocalDate.now().withDayOfMonth(1).atStartOfDay();
        System.out.println(firstDay);

        // 本月最后1天:
        LocalDate lastDay = LocalDate.now().with(TemporalAdjusters.lastDayOfMonth());
        System.out.println(lastDay);

        // 下月第1天:
        LocalDate nextMonthFirstDay = LocalDate.now().with(TemporalAdjusters.firstDayOfNextMonth());
        System.out.println(nextMonthFirstDay);

        // 本月第1个周一:
        LocalDate firstWeekday = LocalDate.now().with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));
        System.out.println(firstWeekday);
    &#125;
&#125;</code></pre>
<p>对于计算某个月第1个周日这样的问题，新的API可以轻松完成。</p>
<p>要判断两个LocalDateTime的先后，可以使用isBefore()、isAfter()方法，对于LocalDate和LocalTime类似：</p>
<pre><code class="highlight plaintext">import java.time.*;

public class Main &#123;
    public static void main(String[] args) &#123;
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime target = LocalDateTime.of(2019, 11, 19, 8, 15, 0);
        System.out.println(now.isBefore(target));
        System.out.println(LocalDate.now().isBefore(LocalDate.of(2019, 11, 19)));
        System.out.println(LocalTime.now().isAfter(LocalTime.parse(&quot;08:15:00&quot;)));
    &#125;
&#125;</code></pre>
<p>注意到LocalDateTime无法与时间戳进行转换，因为LocalDateTime没有时区，无法确定某一时刻。后面我们要介绍的ZonedDateTime相当于LocalDateTime加时区的组合，它具有时区，可以与long表示的时间戳进行转换。</p>
<h4 id="duration和period"><a class="markdownIt-Anchor" href="#duration和period"></a> Duration和Period</h4>
<p>Duration表示两个时刻之间的时间间隔。另一个类似的Period表示两个日期之间的天数：</p>
<pre><code class="highlight plaintext">import java.time.*;

public class Main &#123;
    public static void main(String[] args) &#123;
        LocalDateTime start = LocalDateTime.of(2019, 11, 19, 8, 15, 0);
        LocalDateTime end = LocalDateTime.of(2020, 1, 9, 19, 25, 30);
        Duration d = Duration.between(start, end);
        System.out.println(d); // PT1235H10M30S

        Period p = LocalDate.of(2019, 11, 19).until(LocalDate.of(2020, 1, 9));
        System.out.println(p); // P1M21D
    &#125;
&#125;</code></pre>
<p>注意到两个LocalDateTime之间的差值使用Duration表示，类似PT1235H10M30S，表示1235小时10分钟30秒。而两个LocalDate之间的差值用Period表示，类似P1M21D，表示1个月21天。</p>
<p>Duration和Period的表示方法也符合ISO 8601的格式，它以P…T…的形式表示，P…T之间表示日期间隔，T后面表示时间间隔。如果是PT…的格式表示仅有时间间隔。利用ofXxx()或者parse()方法也可以直接创建Duration：</p>
<pre><code class="highlight plaintext">Duration d1 = Duration.ofHours(10); // 10 hours
Duration d2 = Duration.parse(&quot;P1DT2H3M&quot;); // 1 day, 2 hours, 3 minutes</code></pre>
<p>有的童鞋可能发现Java 8引入的java.timeAPI。怎么和一个开源的Joda Time很像？难道JDK也开始抄袭开源了？其实正是因为开源的Joda Time设计很好，应用广泛，所以JDK团队邀请Joda Time的作者Stephen Colebourne共同设计了java.timeAPI。</p>
<h3 id="zoneddatetime"><a class="markdownIt-Anchor" href="#zoneddatetime"></a> ZonedDateTime</h3>
<p>LocalDateTime总是表示本地日期和时间，要表示一个带时区的日期和时间，我们就需要ZonedDateTime。</p>
<p>可以简单地把ZonedDateTime理解成LocalDateTime加ZoneId。ZoneId是java.time引入的新的时区类，注意和旧的java.util.TimeZone区别。</p>
<p>要创建一个ZonedDateTime对象，有以下几种方法，一种是通过now()方法返回当前时间：</p>
<pre><code class="highlight plaintext">import java.time.*;
public class Main &#123;
    public static void main(String[] args) &#123;
        ZonedDateTime zbj = ZonedDateTime.now(); // 默认时区
        ZonedDateTime zny = ZonedDateTime.now(ZoneId.of(&quot;America/New_York&quot;)); // 用指定时区获取当前时间
        System.out.println(zbj);
        System.out.println(zny);
    &#125;
&#125;</code></pre>
<p>观察打印的两个ZonedDateTime，发现它们时区不同，但表示的时间都是同一时刻（毫秒数不同是执行语句时的时间差）：</p>
<pre><code class="highlight plaintext">2019-09-15T20:58:18.786182+08:00[Asia/Shanghai]
2019-09-15T08:58:18.788860-04:00[America/New_York]</code></pre>
<p>另一种方式是通过给一个LocalDateTime附加一个ZoneId，就可以变成ZonedDateTime：</p>
<pre><code class="highlight plaintext">import java.time.*;
public class Main &#123;
    public static void main(String[] args) &#123;
        LocalDateTime ldt = LocalDateTime.of(2019, 9, 15, 15, 16, 17);
        ZonedDateTime zbj = ldt.atZone(ZoneId.systemDefault());
        ZonedDateTime zny = ldt.atZone(ZoneId.of(&quot;America/New_York&quot;));
        System.out.println(zbj);
        System.out.println(zny);
    &#125;
&#125;</code></pre>
<p>以这种方式创建的ZonedDateTime，它的日期和时间与LocalDateTime相同，但附加的时区不同，因此是两个不同的时刻：</p>
<pre><code class="highlight plaintext">2019-09-15T15:16:17+08:00[Asia/Shanghai]
2019-09-15T15:16:17-04:00[America/New_York]</code></pre>
<p>时区转换</p>
<p>要转换时区，首先我们需要有一个ZonedDateTime对象，然后，通过withZoneSameInstant()将关联时区转换到另一个时区，转换后日期和时间都会相应调整。</p>
<p>下面的代码演示了如何将北京时间转换为纽约时间：</p>
<pre><code class="highlight plaintext">
import java.time.*;

public class Main &#123;
    public static void main(String[] args) &#123;
        // 以中国时区获取当前时间:
        ZonedDateTime zbj = ZonedDateTime.now(ZoneId.of(&quot;Asia/Shanghai&quot;));
        // 转换为纽约时间:
        ZonedDateTime zny = zbj.withZoneSameInstant(ZoneId.of(&quot;America/New_York&quot;));
        System.out.println(zbj);
        System.out.println(zny);
    &#125;
&#125;</code></pre>
<p>要特别注意，时区转换的时候，由于夏令时的存在，不同的日期转换的结果很可能是不同的。这是北京时间9月15日的转换结果：</p>
<pre><code class="highlight plaintext">2019-09-15T21:05:50.187697+08:00[Asia/Shanghai]
2019-09-15T09:05:50.187697-04:00[America/New_York]</code></pre>
<p>这是北京时间11月15日的转换结果：</p>
<pre><code class="highlight plaintext">2019-11-15T21:05:50.187697+08:00[Asia/Shanghai]
2019-11-15T08:05:50.187697-05:00[America/New_York]</code></pre>
<p>两次转换后的纽约时间有1小时的夏令时时差。</p>
<blockquote>
<p>涉及到时区时，千万不要自己计算时差，否则难以正确处理夏令时。</p>
</blockquote>
<p>有了ZonedDateTime，将其转换为本地时间就非常简单：</p>
<pre><code class="highlight plaintext">ZonedDateTime zdt = ...
LocalDateTime ldt = zdt.toLocalDateTime();</code></pre>
<p>转换为LocalDateTime时，直接丢弃了时区信息。</p>
<h3 id="datetimeformatter"><a class="markdownIt-Anchor" href="#datetimeformatter"></a> DateTimeFormatter</h3>
<p>使用旧的Date对象时，我们用SimpleDateFormat进行格式化显示。使用新的LocalDateTime或ZonedDateTime时，我们要进行格式化显示，就要使用DateTimeFormatter。</p>
<p>和SimpleDateFormat不同的是，DateTimeFormatter不但是不变对象，它还是线程安全的。线程的概念我们会在后面涉及到。现在我们只需要记住：因为SimpleDateFormat不是线程安全的，使用的时候，只能在方法内部创建新的局部变量。而DateTimeFormatter可以只创建一个实例，到处引用。</p>
<p>创建DateTimeFormatter时，我们仍然通过传入格式化字符串实现：</p>
<pre><code class="highlight plaintext">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm&quot;);</code></pre>
<p>格式化字符串的使用方式与SimpleDateFormat完全一致。</p>
<p>另一种创建DateTimeFormatter的方法是，传入格式化字符串时，同时指定Locale：</p>
<pre><code class="highlight plaintext">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;E, yyyy-MMMM-dd HH:mm&quot;, Locale.US);</code></pre>
<p>这种方式可以按照Locale默认习惯格式化。我们来看实际效果：</p>
<pre><code class="highlight plaintext">import java.time.*;
import java.time.format.*;
import java.util.Locale;

public class Main &#123;
    public static void main(String[] args) &#123;
        ZonedDateTime zdt = ZonedDateTime.now();
        var formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm ZZZZ&quot;);
        System.out.println(formatter.format(zdt));

        var zhFormatter = DateTimeFormatter.ofPattern(&quot;yyyy MMM dd EE HH:mm&quot;, Locale.CHINA);
        System.out.println(zhFormatter.format(zdt));

        var usFormatter = DateTimeFormatter.ofPattern(&quot;E, MMMM/dd/yyyy HH:mm&quot;, Locale.US);
        System.out.println(usFormatter.format(zdt));
    &#125;</code></pre>
<p>在格式化字符串中，如果需要输出固定字符，可以用’xxx’表示。</p>
<p>运行上述代码，分别以默认方式、中国地区和美国地区对当前时间进行显示，结果如下：</p>
<pre><code class="highlight plaintext">2019-09-15T23:16 GMT+08:00
2019 9月 15 周日 23:16
Sun, September/15/2019 23:16</code></pre>
<p>当我们直接调用System.out.println()对一个ZonedDateTime或者LocalDateTime实例进行打印的时候，实际上，调用的是它们的toString()方法，默认的toString()方法显示的字符串就是按照ISO 8601格式显示的，我们可以通过DateTimeFormatter预定义的几个静态变量来引用：</p>
<pre><code class="highlight plaintext">var ldt = LocalDateTime.now();
System.out.println(DateTimeFormatter.ISO_DATE.format(ldt));
System.out.println(DateTimeFormatter.ISO_DATE_TIME.format(ldt));</code></pre>
<p>得到的输出和toString()类似：</p>
<pre><code class="highlight plaintext">2019-09-15
2019-09-15T23:16:51.56217</code></pre>
<h3 id="instant"><a class="markdownIt-Anchor" href="#instant"></a> Instant</h3>
<p>我们已经讲过，计算机存储的当前时间，本质上只是一个不断递增的整数。Java提供的System.currentTimeMillis()返回的就是以毫秒表示的当前时间戳。</p>
<p>这个当前时间戳在java.time中以Instant类型表示，我们用Instant.now()获取当前时间戳，效果和System.currentTimeMillis()类似：</p>
<pre><code class="highlight plaintext">import java.time.*;
public class Main &#123;
    public static void main(String[] args) &#123;
        Instant now = Instant.now();
        System.out.println(now.getEpochSecond()); // 秒
        System.out.println(now.toEpochMilli()); // 毫秒
    &#125;
&#125;</code></pre>
<p>实际上，Instant内部只有两个核心字段：</p>
<pre><code class="highlight plaintext">public final class Instant implements ... &#123;
    private final long seconds;
    private final int nanos;
&#125;</code></pre>
<p>一个是以秒为单位的时间戳，一个是更精确的纳秒精度。它和System.currentTimeMillis()返回的long相比，只是多了更高精度的纳秒。</p>
<p>既然Instant就是时间戳，那么，给它附加上一个时区，就可以创建出ZonedDateTime：</p>
<pre><code class="highlight plaintext">// 以指定时间戳创建Instant:
Instant ins = Instant.ofEpochSecond(1568568760);
ZonedDateTime zdt = ins.atZone(ZoneId.systemDefault());
System.out.println(zdt); // 2019-09-16T01:32:40+08:00[Asia/Shanghai]</code></pre>
<p>可见，对于某一个时间戳，给它关联上指定的ZoneId，就得到了ZonedDateTime，继而可以获得了对应时区的LocalDateTime。</p>
<p>所以，LocalDateTime，ZoneId，Instant，ZonedDateTime和long都可以互相转换：</p>
<h2 id="函数式编程"><a class="markdownIt-Anchor" href="#函数式编程"></a> 函数式编程</h2>
<h3 id="lambda表达式"><a class="markdownIt-Anchor" href="#lambda表达式"></a> Lambda表达式</h3>
<p>Java 8终于引进了lambda表达式，这标志着Java往函数式编程又迈进了一小步。</p>
<p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</p>
<p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p>
<p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p>
<h4 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h4>
<p>lambda 表达式的语法格式如下：</p>
<ul>
<li><strong>可选类型声明</strong>：不需要声明参数类型，编译器可以统一识别参数值</li>
<li><strong>可选的参数圆括号</strong>：一个参数无需定义圆括号，但多个参数需要定义圆括号</li>
<li><strong>可选的大括号</strong>：如果主体包含了一个语句，就不需要使用大括号</li>
<li><strong>可选的返回关键字</strong>：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li>
</ul>
<pre><code class="highlight plaintext">(parameters) -&gt; expression 
或 
(parameters) -&gt;&#123; statements; &#125;</code></pre>
<h4 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h4>
<p>Lambda 表达式的简单例子:</p>
<pre><code class="highlight plaintext">// 1. 不需要参数,返回值为 
5  () -&gt; 5  
  
// 2. 接收一个参数(数字类型),返回其2倍的值  
x -&gt; 2 * x  
  
// 3. 接受2个参数(数字),并返回他们的差值  
(x, y) -&gt; x – y  
  
// 4. 接收2个int型整数,返回他们的和  
(int x, int y) -&gt; x + y  
  
// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  
(String s) -&gt; System.out.print(s)</code></pre>
<p>Lambda 表达式的复杂例子:</p>
<pre><code class="highlight plaintext">public class Java8Tester &#123;
   public static void main(String args[])&#123;
      Java8Tester tester = new Java8Tester();
        
      // 类型声明
      MathOperation addition = (int a, int b) -&gt; a + b;
        
      // 不用类型声明
      MathOperation subtraction = (a, b) -&gt; a - b;
        
      // 大括号中的返回语句
      MathOperation multiplication = (int a, int b) -&gt; &#123; return a * b; &#125;;
        
      // 没有大括号及返回语句
      MathOperation division = (int a, int b) -&gt; a / b;
        
      System.out.println(&quot;10 + 5 = &quot; + tester.operate(10, 5, addition));
      System.out.println(&quot;10 - 5 = &quot; + tester.operate(10, 5, subtraction));
      System.out.println(&quot;10 x 5 = &quot; + tester.operate(10, 5, multiplication));
      System.out.println(&quot;10 / 5 = &quot; + tester.operate(10, 5, division));
        
      // 不用括号
      GreetingService greetService1 = message -&gt;
      System.out.println(&quot;Hello &quot; + message);
        
      // 用括号
      GreetingService greetService2 = (message) -&gt;
      System.out.println(&quot;Hello &quot; + message);
        
      greetService1.sayMessage(&quot;Runoob&quot;);
      greetService2.sayMessage(&quot;Google&quot;);
   &#125;
    
   interface MathOperation &#123;
      int operation(int a, int b);
   &#125;
    
   interface GreetingService &#123;
      void sayMessage(String message);
   &#125;
    
   private int operate(int a, int b, MathOperation mathOperation)&#123;
      return mathOperation.operation(a, b);
   &#125;
&#125;</code></pre>
<p>执行以上脚本，输出结果为：</p>
<pre><code class="highlight plaintext">$ javac Java8Tester.java 
$ java Java8Tester
10 + 5 = 15
10 - 5 = 5
10 x 5 = 50
10 / 5 = 2
Hello RunoobHello Google</code></pre>
<p>使用 Lambda 表达式需要注意以下两点：</p>
<blockquote>
<p>Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的Lambda表达式来定义MathOperation接口的方法。然后我们定义了sayMessage的执行。</p>
</blockquote>
<blockquote>
<p>Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。</p>
</blockquote>
<p>在Java 8以前的代码中，为了实现带一个方法的接口，往往需要定义一个匿名类并复写接口方法，代码显得很臃肿。比如常见的Comparator接口：</p>
<pre><code class="highlight plaintext">String[] oldWay = &quot;Improving code with Lambda expressions in Java 8&quot;.split(&quot; &quot;);
Arrays.sort(oldWay, new Comparator&lt;String&gt;() &#123;
    @Override
    public int compare(String s1, String s2) &#123;
        // 忽略大小写排序:
        return s1.toLowerCase().compareTo(s2.toLowerCase());
    &#125;
&#125;);
System.out.println(String.join(&quot;, &quot;, oldWay));</code></pre>
<p>对于只有一个方法的接口，在Java 8中，现在可以把它视为一个函数，用lambda表示式简化如下：</p>
<pre><code class="highlight plaintext">String[] newWay = &quot;Improving code with Lambda expressions in Java 8&quot;.split(&quot; &quot;);
Arrays.sort(newWay, (s1, s2) -&gt; &#123;
    return s1.toLowerCase().compareTo(s2.toLowerCase());
&#125;);
System.out.println(String.join(&quot;, &quot;, newWay));</code></pre>
<p>Java 8没有引入新的关键字lambda，而是用()-&gt;{}这个奇怪的符号表示lambda函数。函数类型不需要申明，可以由接口的方法签名自动推导出来，对于上面的lambda函数：</p>
<pre><code class="highlight plaintext">(s1, s2) -&gt; &#123;
    return s1.toLowerCase().compareTo(s2.toLowerCase());
&#125;);</code></pre>
<p>参数由Comparator<String>自动推导出String类型，返回值也必须符合接口的方法签名。</p>
<p>实际上，lambda表达式最终也被编译为一个实现类，不过语法上做了简化。</p>
<p>对于Java自带的标准库里的大量单一方法接口，很多都已经标记为@<strong>FunctionalInterface</strong>，<strong>表明该接口可以作为函数使用</strong></p>
<p>以Runnable接口为例，很多时候干活的代码还没有定义class的代码多，现在可以用lambda实现：</p>
<pre><code class="highlight plaintext">public static void main(String[] args) &#123;
    // old way:
    Runnable oldRunnable = new Runnable() &#123;
        @Override
        public void run() &#123;
            System.out.println(Thread.currentThread().getName() + &quot;: Old Runnable&quot;);
        &#125;
    &#125;;
    Runnable newRunnable = () -&gt; &#123;
        System.out.println(Thread.currentThread().getName() + &quot;: New Lambda Runnable&quot;);
    &#125;;
    new Thread(oldRunnable).start();
    new Thread(newRunnable).start();
&#125;</code></pre>
<h4 id="变量作用域"><a class="markdownIt-Anchor" href="#变量作用域"></a> 变量作用域</h4>
<p>lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</p>
<pre><code class="highlight plaintext">public class Java8Tester &#123;
 
   final static String salutation = &quot;Hello! &quot;;
   
   public static void main(String args[])&#123;
      GreetingService greetService1 = message -&gt; 
      System.out.println(salutation + message);
      greetService1.sayMessage(&quot;Runoob&quot;);
   &#125;
    
   interface GreetingService &#123;
      void sayMessage(String message);
   &#125;
&#125;</code></pre>
<p>执行以上脚本，输出结果为：</p>
<pre><code class="highlight plaintext">$ javac Java8Tester.java 
$ java Java8TesterHello! Runoob</code></pre>
<p>我们也可以直接在 lambda 表达式中访问外层的局部变量：</p>
<pre><code class="highlight plaintext">public class Java8Tester &#123;
    public static void main(String args[]) &#123;
        final int num = 1;
        Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));
        s.convert(2);  // 输出结果为 3
    &#125;
 
    public interface Converter&lt;T1, T2&gt; &#123;
        void convert(int i);
    &#125;
&#125;</code></pre>
<p>lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）</p>
<pre><code class="highlight plaintext">int num = 1;  
Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));
s.convert(2);
num = 5;  
//报错信息：Local variable num defined in an enclosing scope must be final or effectively final</code></pre>
<p>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</p>
<pre><code class="highlight plaintext">String first = &quot;&quot;;  
Comparator&lt;String&gt; comparator = (first, second) -&gt; Integer.compare(first.length(), second.length());  //编译会出错</code></pre>
<h3 id="全新的stream-api"><a class="markdownIt-Anchor" href="#全新的stream-api"></a> 全新的Stream API</h3>
<p>Java 8引入了全新的Stream API。这里的Stream和I/O流不同，它更像具有Iterable的集合类，但行为和集合类又有所不同</p>
<p>Stream API引入的目的在于弥补Java函数式编程的缺陷。对于很多支持函数式编程的语言，map()、reduce()基本上都内置到语言的标准库中了，不过，Java 8的Stream API总体来讲仍然是非常完善和强大，足以用很少的代码完成许多复杂的功能。</p>
<p>创建一个Stream有很多方法，最简单的方法是把一个Collection变成Stream。我们来看最基本的几个操作：</p>
<pre><code class="highlight plaintext">public static void main(String[] args) &#123;
    List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    Stream&lt;Integer&gt; stream = numbers.stream();
    stream.filter((x) -&gt; &#123;
        return x % 2 == 0;
    &#125;).map((x) -&gt; &#123;
        return x * x;
    &#125;).forEach(System.out::println);
&#125;</code></pre>
<p>集合类新增的stream()方法用于把一个集合变成Stream，然后，通过filter()、map()等实现Stream的变换。Stream还有一个forEach()来完成每个元素的迭代。</p>
<p>为什么不在集合类实现这些操作，而是定义了全新的Stream API？Oracle官方给出了几个重要原因：</p>
<p>一是集合类持有的所有元素都是存储在内存中的，非常巨大的集合类会占用大量的内存，而Stream的元素却是在访问的时候才被计算出来，这种“延迟计算”的特性有点类似Clojure的lazy-seq，占用内存很少。</p>
<p>二是集合类的迭代逻辑是调用者负责，通常是for循环，而Stream的迭代是隐含在对Stream的各种操作中，例如map()。</p>
<p>要理解“延迟计算”，不妨创建一个无穷大小的Stream。</p>
<p>如果要表示自然数集合，显然用集合类是不可能实现的，因为自然数有无穷多个。但是Stream可以做到。</p>
<p>自然数集合的规则非常简单，每个元素都是前一个元素的值+1，因此，自然数发生器用代码实现如下：</p>
<pre><code class="highlight plaintext">class NaturalSupplier implements Supplier&lt;Long&gt; &#123;

    long value = 0;

    public Long get() &#123;
        this.value = this.value + 1;
        return this.value;
    &#125;
&#125;</code></pre>
<p>反复调用get()，将得到一个无穷数列，利用这个Supplier，可以创建一个无穷的Stream：</p>
<pre><code class="highlight plaintext">public static void main(String[] args) &#123;
    Stream&lt;Long&gt; natural = Stream.generate(new NaturalSupplier());
    natural.map((x) -&gt; &#123;
        return x * x;
    &#125;).limit(10).forEach(System.out::println);
&#125;</code></pre>
<p>对这个Stream做任何map()、filter()等操作都是完全可以的，这说明Stream API对Stream进行转换并生成一个新的Stream并非实时计算，而是做了延迟计算。</p>
<p>当然，对这个无穷的Stream不能直接调用forEach()，这样会无限打印下去。但是我们可以利用limit()变换，把这个无穷Stream变换为有限的Stream。</p>
<p>利用Stream API，可以设计更加简单的数据接口。例如，生成斐波那契数列，完全可以用一个无穷流表示（受限Java的long型大小，可以改为BigInteger）：</p>
<pre><code class="highlight plaintext">class FibonacciSupplier implements Supplier&lt;Long&gt; &#123;

    long a = 0;
    long b = 1;

    @Override
    public Long get() &#123;
        long x = a + b;
        a = b;
        b = x;
        return a;
    &#125;
&#125;

public class FibonacciStream &#123;

    public static void main(String[] args) &#123;
        Stream&lt;Long&gt; fibonacci = Stream.generate(new FibonacciSupplier());
        fibonacci.limit(10).forEach(System.out::println);
    &#125;
&#125;</code></pre>
<p>如果想取得数列的前10项，用limit(10)，如果想取得数列的第20~30项，用：</p>
<pre><code class="highlight plaintext">List&lt;Long&gt; list = fibonacci.skip(20).limit(10).collect(Collectors.toList());</code></pre>
<p>最后通过collect()方法把Stream变为List。该List存储的所有元素就已经是计算出的确定的元素了。</p>
<p>用Stream表示Fibonacci数列，其接口比任何其他接口定义都要来得简单灵活并且高效。</p>
<p>计算π可以利用π的展开式：</p>
<pre><code class="highlight plaintext">π/4 = 1 - 1/3 + 1/5 - 1/7 + 1/9 - ...</code></pre>
<p>把π表示为一个无穷Stream如下：</p>
<pre><code class="highlight plaintext">class PiSupplier implements Supplier&lt;Double&gt; &#123;

    double sum = 0.0;
    double current = 1.0;
    boolean sign = true;

    @Override
    public Double get() &#123;
        sum += (sign ? 4 : -4) / this.current;
        this.current = this.current + 2.0;
        this.sign = ! this.sign;
        return sum;
    &#125;
&#125;

Stream&lt;Double&gt; piStream = Stream.generate(new PiSupplier());
piStream.skip(100).limit(10)
        .forEach(System.out::println);</code></pre>
<p>这个级数从100项开始可以把π的值精确到3.13~3.15之间：</p>
<pre><code class="highlight plaintext">3.1514934010709914
3.1317889675734545
3.1513011626954057
3.131977491197821
3.1511162471786824
3.1321589012071183
3.150938243930123
3.132333592767332
3.1507667724908344
3.1325019323081857</code></pre>
<p>利用欧拉变换对级数进行加速，可以利用下面的公式：</p>
<p>%!(EXTRA markdown.ResourceType=, string=, string=)</p>
<p>用代码实现就是把一个流变成另一个流：</p>
<pre><code class="highlight plaintext">class EulerTransform implements Function&lt;Double, Double&gt; &#123;

    double n1 = 0.0;
    double n2 = 0.0;
    double n3 = 0.0;

    @Override
    public Double apply(Double t) &#123;
        n1 = n2;
        n2 = n3;
        n3 = t;
        if (n1 == 0.0) &#123;
            return 0.0;
        &#125;
        return calc();
    &#125;

    double calc() &#123;
        double d = n3 - n2;
        return n3 - d * d / (n1 - 2 * n2 + n3);
    &#125;
&#125;

Stream&lt;Double&gt; piStream2 = Stream.generate(new PiSupplier());
piStream2.map(new EulerTransform())
         .limit(10)
         .forEach(System.out::println);</code></pre>
<p>可以在10项之内把π的值计算到3.141~3.142之间：</p>
<pre><code class="highlight plaintext">0.0
0.0
3.166666666666667
3.1333333333333337
3.1452380952380956
3.13968253968254
3.1427128427128435
3.1408813408813416
3.142071817071818
3.1412548236077655</code></pre>
<p>还可以多次应用这个加速器：</p>
<pre><code class="highlight plaintext">Stream&lt;Double&gt; piStream3 = Stream.generate(new PiSupplier());
piStream3.map(new EulerTransform())
         .map(new EulerTransform())
         .map(new EulerTransform())
         .map(new EulerTransform())
         .map(new EulerTransform())
         .limit(20)
         .forEach(System.out::println);</code></pre>
<p>20项之内可以计算出极其精确的值：</p>
<pre><code class="highlight plaintext">...
3.14159265359053
3.1415926535894667
3.141592653589949
3.141592653589719</code></pre>
<p>可见用Stream API可以写出多么简洁的代码，用其他的模型也可以写出来，但是代码会非常复杂。</p>
<h2 id="jdk9新特性"><a class="markdownIt-Anchor" href="#jdk9新特性"></a> JDK9新特性</h2>
<h2 id="jdk11新特性"><a class="markdownIt-Anchor" href="#jdk11新特性"></a> JDK11新特性</h2>
<h3 id="local-var"><a class="markdownIt-Anchor" href="#local-var"></a> Local Var</h3>
<p>在Lambda表达式中，可以使用var关键字来标识变量，变量类型由编译器自行推断。例如：</p>
<pre><code class="highlight plaintext">// LocalVar.javapackage com.itranswarp.jdk11;

import java.util.Arrays;

public class LocalVar &#123;
    public static void main(String[] args) &#123;
        Arrays.asList(&quot;Java&quot;, &quot;Python&quot;, &quot;Ruby&quot;)
            .forEach((var s) -&gt; &#123;
                System.out.println(&quot;Hello, &quot; + s);
            &#125;);
        &#125;
&#125;</code></pre>
<h3 id="httpclient"><a class="markdownIt-Anchor" href="#httpclient"></a> HttpClient</h3>
<p>长期以来，如果要访问Http资源，JDK的标准库中只有一个HttpURLConnection，这个古老的API使用非常麻烦，而且已经不适用于最新的HTTP协议。</p>
<p>JDK11的新的HttpClient支持HTTP/2和WebSocket，并且可以使用异步接口：</p>
<pre><code class="highlight plaintext">// HttpApi.javapackage com.itranswarp.jdk11;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.concurrent.CompletableFuture;

public class HttpApi &#123;

    public static void main(String[] args) &#123;
        HttpRequest request = HttpRequest.newBuilder().uri(URI.create(&quot;https://www.qq.com/&quot;)).GET().build();
        HttpResponse.BodyHandler&lt;String&gt; bodyHandler = HttpResponse.BodyHandlers.ofString();
        HttpClient client = HttpClient.newHttpClient();
        CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; future = client.sendAsync(request, bodyHandler);
        future.thenApply(HttpResponse::body).thenAccept(System.out::println).join();
    &#125;
&#125;</code></pre>
<h3 id="list-api"><a class="markdownIt-Anchor" href="#list-api"></a> List API</h3>
<p>对于List接口，新增了一个of(T…)接口，用于快速创建List对象：</p>
<pre><code class="highlight plaintext">List&lt;String&gt; list = List.of(&quot;Java&quot;, &quot;Python&quot;, &quot;Ruby&quot;);</code></pre>
<p>List的toArray()还新增了一个重载方法，可以更方便地把List转换为数组。可以比较一下两种转换方法：</p>
<pre><code class="highlight plaintext">// 旧的方法:传入String[]:
String[] oldway = list.toArray(new String[list.size()]);

// 新的方法:传入IntFunction:
String[] newway = list.toArray(String[]::new);</code></pre>
<h3 id="读写文件"><a class="markdownIt-Anchor" href="#读写文件"></a> 读写文件</h3>
<p>对Files类增加了writeString和readString两个静态方法，可以直接把String写入文件，或者把整个文件读出为一个String：</p>
<pre><code class="highlight plaintext">// 路径 内容 编码
Files.writeString(Path.of(&quot;./&quot;, &quot;tmp.txt&quot;), &quot;hello, jdk11 files api&quot;,StandardCharsets.UTF_8);
//路径 编码
String s = Files.readString(Paths.get(&quot;./tmp.txt&quot;),StandardCharsets.UTF_8);</code></pre>
<blockquote>
<p>这两个方法可以大大简化读取配置文件之类的问题</p>
</blockquote>
<h3 id="string-api"><a class="markdownIt-Anchor" href="#string-api"></a> String API</h3>
<p><strong>strip</strong>()</p>
<p>String新增了<strong>strip</strong>()方法，和trim()相比，strip()可以去掉Unicode空格，例如，中文空格：</p>
<pre><code class="highlight plaintext">String s = &quot; Hello, JDK11!\u3000\u3000&quot;;
System.out.println(&quot;     original: [&quot; + s + &quot;]&quot;);
System.out.println(&quot;         trim: [&quot; + s.trim() + &quot;]&quot;);
System.out.println(&quot;        strip: [&quot; + s.strip() + &quot;]&quot;);
System.out.println(&quot; stripLeading: [&quot; + s.stripLeading() + &quot;]&quot;);
System.out.println(&quot;stripTrailing: [&quot; + s.stripTrailing() + &quot;]&quot;);</code></pre>
<p>输出如下：</p>
<pre><code class="highlight plaintext">        original: [ Hello, JDK11!　　]
             trim: [Hello, JDK11!　　]
             strip: [Hello, JDK11!]
stripLeading: [Hello, JDK11!　　]
 stripTrailing: [ Hello, JDK11!]</code></pre>
<hr />
<p><strong>isBlank</strong>()</p>
<p>新增isBlank()方法，可判断字符串是不是“空白”字符串：</p>
<pre><code class="highlight plaintext">String s = &quot; \u3000&quot;; // 由一个空格和一个中文空格构成
System.out.println(s.isEmpty()); // falseSystem.out.println(s.isBlank()); // true</code></pre>
<hr />
<p><strong>lines</strong>()</p>
<p>新增<strong>lines</strong>()方法，可以非常方便地按行分割字符串：</p>
<pre><code class="highlight plaintext">String s = &quot;Java\nPython\nRuby&quot;;
s.lines().forEach(System.out::println);</code></pre>
<hr />
<p><strong>repeat()</strong></p>
<p>新增repeat()方法，可以指定重复次数：</p>
<pre><code class="highlight plaintext">System.out.println(&quot;-&quot;.repeat(10)); // 打印----------</code></pre>
<h3 id="新增gc"><a class="markdownIt-Anchor" href="#新增gc"></a> 新增GC</h3>
<p>除了新增的API外，JDK11还带来了EpsilonGC，就是什么也不做的GC，以及ZGC，一个几乎可以做到毫秒级暂停的GC。ZGC还处于实验阶段，所以启动它需要命令行参数</p>
<pre><code class="highlight plaintext">-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</code></pre>
</main>

</article>


<script src="/js/highlight.js"></script>

  </main>
  <footer class="footer">
  
  <span>Copyright © 2026 Lism Blog | lisisism@qq.com</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>